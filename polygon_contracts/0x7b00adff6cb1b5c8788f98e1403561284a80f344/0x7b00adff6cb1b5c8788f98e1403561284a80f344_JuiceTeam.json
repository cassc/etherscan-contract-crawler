{"SourceCode": "// File: contracts/operator-filter-registry/src/IOperatorFilterRegistry.sol\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\ninterface IOperatorFilterRegistry {\r\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\r\n    function register(address registrant) external;\r\n    function registerAndSubscribe(address registrant, address subscription) external;\r\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\r\n    function unregister(address addr) external;\r\n    function updateOperator(address registrant, address operator, bool filtered) external;\r\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\r\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\r\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\r\n    function subscribe(address registrant, address registrantToSubscribe) external;\r\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\r\n    function subscriptionOf(address addr) external returns (address registrant);\r\n    function subscribers(address registrant) external returns (address[] memory);\r\n    function subscriberAt(address registrant, uint256 index) external returns (address);\r\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\r\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\r\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\r\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\r\n    function filteredOperators(address addr) external returns (address[] memory);\r\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\r\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\r\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\r\n    function isRegistered(address addr) external returns (bool);\r\n    function codeHashOf(address addr) external returns (bytes32);\r\n}\r\n\r\n// File: contracts/operator-filter-registry/src/UpdatableOperatorFilterer.sol\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\n\r\n/**\r\n * @title  UpdatableOperatorFilterer\r\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\r\n *         registrant's entries in the OperatorFilterRegistry. This contract allows the Owner to update the\r\n *         OperatorFilterRegistry address via updateOperatorFilterRegistryAddress, including to the zero address,\r\n *         which will bypass registry checks.\r\n *         Note that OpenSea will still disable creator fee enforcement if filtered operators begin fulfilling orders\r\n *         on-chain, eg, if the registry is revoked or bypassed.\r\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\r\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\r\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\r\n */\r\nabstract contract UpdatableOperatorFilterer {\r\n    error OperatorNotAllowed(address operator);\r\n    error OnlyOwner();\r\n\r\n    IOperatorFilterRegistry public operatorFilterRegistry;\r\n\r\n    constructor(address _registry, address subscriptionOrRegistrantToCopy, bool subscribe) {\r\n        IOperatorFilterRegistry registry = IOperatorFilterRegistry(_registry);\r\n        operatorFilterRegistry = registry;\r\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\r\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\r\n        // order for the modifier to filter addresses.\r\n        if (address(registry).code.length > 0) {\r\n            if (subscribe) {\r\n                registry.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\r\n            } else {\r\n                if (subscriptionOrRegistrantToCopy != address(0)) {\r\n                    registry.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\r\n                } else {\r\n                    registry.register(address(this));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    modifier onlyAllowedOperator(address from) virtual {\r\n        // Allow spending tokens from addresses with balance\r\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\r\n        // from an EOA.\r\n        if (from != msg.sender) {\r\n            _checkFilterOperator(msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\r\n        _checkFilterOperator(operator);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the address that the contract will make OperatorFilter checks against. When set to the zero\r\n     *         address, checks will be bypassed. OnlyOwner.\r\n     */\r\n    function updateOperatorFilterRegistryAddress(address newRegistry) public virtual {\r\n        if (msg.sender != owner()) {\r\n            revert OnlyOwner();\r\n        }\r\n        operatorFilterRegistry = IOperatorFilterRegistry(newRegistry);\r\n    }\r\n\r\n    /**\r\n     * @dev assume the contract has an owner, but leave specific Ownable implementation up to inheriting contract\r\n     */\r\n    function owner() public view virtual returns (address);\r\n\r\n    function _checkFilterOperator(address operator) internal view virtual {\r\n        IOperatorFilterRegistry registry = operatorFilterRegistry;\r\n        // Check registry code length to facilitate testing in environments without a deployed registry.\r\n        if (address(registry) != address(0) && address(registry).code.length > 0) {\r\n            if (!registry.isOperatorAllowed(address(this), operator)) {\r\n                revert OperatorNotAllowed(operator);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/utils/Whitelist_ECDSA.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n* Edit  : Squeebo\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Whitelist_ECDSA {\r\n\t// Errors\r\n  /**\r\n  * @dev Thrown when trying to query the whitelist while it's not set\r\n  */\r\n\terror Whitelist_NOT_SET();\r\n  /**\r\n  * @dev Thrown when `account` has consumed their alloted access and tries to query more\r\n  * \r\n  * @param account : address trying to access the whitelist\r\n  */\r\n\terror Whitelist_CONSUMED( address account );\r\n  /**\r\n  * @dev Thrown when `account` does not have enough alloted access to fulfil their query\r\n  * \r\n  * @param account : address trying to access the whitelist\r\n  */\r\n\terror Whitelist_FORBIDDEN( address account );\r\n\r\n\t/**\r\n  * @dev A structure representing a signature proof to be decoded by the contract\r\n  */\r\n\tstruct Proof {\r\n\t\tbytes32 r;\r\n\t\tbytes32 s;\r\n\t\tuint8   v;\r\n\t}\r\n\r\n\taddress private _adminSigner;\r\n\tmapping( uint8 => mapping ( address => uint256 ) ) private _consumed;\r\n\r\n\t/**\r\n\t* @dev Ensures that `account_` has `qty_` alloted access on the `whitelistId_` whitelist.\r\n\t* \r\n\t* @param account_     : the address to validate access\r\n\t* @param whitelistId_ : the identifier of the whitelist being queried\r\n\t* @param alloted_     : the max amount of whitelist spots allocated\r\n\t* @param proof_       : the signature proof to validate whitelist allocation\r\n\t* @param qty_         : the amount of whitelist access requested\r\n\t*/\r\n\tmodifier isWhitelisted( address account_, uint8 whitelistId_, uint256 alloted_, Proof memory proof_, uint256 qty_ ) {\r\n\t\tuint256 _allowed_ = checkWhitelistAllowance( account_, whitelistId_, alloted_, proof_ );\r\n\r\n\t\tif ( _allowed_ < qty_ ) {\r\n\t\t\trevert Whitelist_FORBIDDEN( account_ );\r\n\t\t}\r\n\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Sets the pass to protect the whitelist.\r\n\t* \r\n\t* @param adminSigner_ : the address validating the whitelist signatures\r\n\t*/\r\n\tfunction _setWhitelist( address adminSigner_ ) internal virtual {\r\n\t\t_adminSigner = adminSigner_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the amount that `account_` is allowed to access from the whitelist.\r\n\t* \r\n\t* @param account_     : the address to validate access\r\n\t* @param whitelistId_ : the identifier of the whitelist being queried\r\n\t* @param alloted_     : the max amount of whitelist spots allocated\r\n\t* @param proof_       : the signature proof to validate whitelist allocation\r\n\t* \r\n\t* @return uint256 : the total amount of whitelist allocation remaining for `account_`\r\n\t* \r\n\t* Requirements:\r\n\t* \r\n\t* - `_adminSigner` must be set.\r\n\t*/\r\n\tfunction checkWhitelistAllowance( address account_, uint8 whitelistId_, uint256 alloted_, Proof memory proof_ ) public view returns ( uint256 ) {\r\n\t\tif ( _adminSigner == address( 0 ) ) {\r\n\t\t\trevert Whitelist_NOT_SET();\r\n\t\t}\r\n\r\n\t\tif ( _consumed[ whitelistId_ ][ account_ ] >= alloted_ ) {\r\n\t\t\trevert Whitelist_CONSUMED( account_ );\r\n\t\t}\r\n\r\n\t\tif ( ! _validateProof( account_, whitelistId_, alloted_, proof_ ) ) {\r\n\t\t\trevert Whitelist_FORBIDDEN( account_ );\r\n\t\t}\r\n\r\n\t\treturn alloted_ - _consumed[ whitelistId_ ][ account_ ];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal function to decode a signature and compare it with the `_adminSigner`.\r\n\t* \r\n\t* @param account_     : the address to validate access\r\n\t* @param whitelistId_ : the identifier of the whitelist being queried\r\n\t* @param alloted_     : the max amount of whitelist spots allocated\r\n\t* @param proof_       : the signature proof to validate whitelist allocation\r\n\t* \r\n\t* @return bool : whether the signature is valid or not\r\n\t*/ \r\n\tfunction _validateProof( address account_, uint8 whitelistId_, uint256 alloted_, Proof memory proof_ ) private view returns ( bool ) {\r\n\t\tbytes32 _digest_ = keccak256( abi.encode( whitelistId_, alloted_, account_ ) );\r\n\t\taddress _signer_ = ecrecover( _digest_, proof_.v, proof_.r, proof_.s );\r\n\t\treturn _signer_ == _adminSigner;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Consumes `amount_` whitelist access passes from `account_`.\r\n\t* \r\n\t* @param account_     : the address to consume access from\r\n\t* @param whitelistId_ : the identifier of the whitelist being queried\r\n\t* @param qty_         : the amount of whitelist access consumed\r\n\t* \r\n\t* Note: Before calling this function, eligibility should be checked through {Whitelistable-checkWhitelistAllowance}.\r\n\t*/\r\n\tfunction _consumeWhitelist( address account_, uint8 whitelistId_, uint256 qty_ ) internal {\r\n\t\tunchecked {\r\n\t\t\t_consumed[ whitelistId_ ][ account_ ] += qty_;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/utils/ProxyAccess.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\ncontract ProxyRegistry {\r\n\tfunction proxies( address tokenOwner_ ) external view returns ( address ) {}\r\n}\r\n\r\nabstract contract ProxyAccess {\r\n\t// list of accepted proxy registries\r\n\taddress[] public proxyRegistries;\r\n\r\n\t/**\r\n\t* @dev Internal function that adds a proxy registry to the list of accepted proxy registries.\r\n\t* \r\n\t* @param proxyRegistryAddress_ : the address of the new proxy registry\r\n\t*/\r\n\tfunction _addProxyRegistry( address proxyRegistryAddress_ ) internal {\r\n\t\tuint256 _index_ = proxyRegistries.length;\r\n\t\twhile ( _index_ > 0 ) {\r\n\t\t\tunchecked {\r\n\t\t\t\t_index_ --;\r\n\t\t\t}\r\n\t\t\tif ( proxyRegistries[ _index_ ] == proxyRegistryAddress_ ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tproxyRegistries.push( proxyRegistryAddress_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal function that removes a proxy registry from the list of accepted proxy registries.\r\n\t* \r\n\t* @param proxyRegistryAddress_ : the address of the proxy registry to remove\r\n\t*/\r\n\tfunction _removeProxyRegistry( address proxyRegistryAddress_ ) internal {\r\n\t\tuint256 _len_ = proxyRegistries.length;\r\n\t\tuint256 _index_ = _len_;\r\n\t\twhile ( _index_ > 0 ) {\r\n\t\t\tunchecked {\r\n\t\t\t\t_index_ --;\r\n\t\t\t}\r\n\t\t\tif ( proxyRegistries[ _index_ ] == proxyRegistryAddress_ ) {\r\n\t\t\t\tif ( _index_ + 1 != _len_ ) {\r\n\t\t\t\t\tproxyRegistries[ _index_ ] = proxyRegistries[ _len_ - 1 ];\r\n\t\t\t\t}\r\n\t\t\t\tproxyRegistries.pop();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal function that checks if `operator_` is a registered proxy for `tokenOwner_`.\r\n\t* \r\n\t* Note: Use this function to allow whitelisting of registered proxy.\r\n\t* \r\n\t* @param tokenOwner_ : the address the proxy operates on the behalf of\r\n\t* @param operator_   : the proxy address that operates on behalf of the token owner\r\n\t* \r\n\t* @return bool : whether `operator_` is allowed to operate on behalf of `tokenOwner_` or not\r\n\t*/\r\n\tfunction _isRegisteredProxy( address tokenOwner_, address operator_ ) internal view returns ( bool ) {\r\n\t\tuint256 _index_ = proxyRegistries.length;\r\n\t\twhile ( _index_ > 0 ) {\r\n\t\t\tunchecked {\r\n\t\t\t\t_index_ --;\r\n\t\t\t}\r\n\t\t\tProxyRegistry _proxyRegistry_ = ProxyRegistry( proxyRegistries[ _index_ ] );\r\n\t\t\tif ( address( _proxyRegistry_.proxies( tokenOwner_ ) ) == operator_ ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n// File: contracts/EthereumContracts/contracts/utils/ContractState.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract ContractState {\r\n\t// Enum to represent the sale state, defaults to ``PAUSED``.\r\n\tuint8 public constant PAUSED = 0;\r\n\r\n\t// Errors\r\n  /**\r\n  * @dev Thrown when a function is called with the wrong contract state.\r\n  * \r\n  * @param currentState : the current state of the contract\r\n  */\r\n\terror ContractState_INCORRECT_STATE( uint8 currentState );\r\n  /**\r\n  * @dev Thrown when trying to set the contract state to an invalid value.\r\n  * \r\n  * @param invalidState : the invalid contract state\r\n  */\r\n\terror ContractState_INVALID_STATE( uint8 invalidState );\r\n\r\n\t// The current state of the contract\r\n\tuint8 private _contractState;\r\n\r\n\t/**\r\n\t* @dev Emitted when the sale state changes\r\n\t*/\r\n\tevent ContractStateChanged( uint8 indexed previousState, uint8 indexed newState );\r\n\r\n\t/**\r\n\t* @dev Ensures that contract state is `expectedState_`.\r\n\t* \r\n\t* @param expectedState_ : the desirable contract state\r\n\t*/\r\n\tmodifier isState( uint8 expectedState_ ) {\r\n\t\tif ( _contractState != expectedState_ ) {\r\n\t\t\trevert ContractState_INCORRECT_STATE( _contractState );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Ensures that contract state is not `unexpectedState_`.\r\n\t* \r\n\t* @param unexpectedState_ : the undesirable contract state\r\n\t*/\r\n\tmodifier isNotState( uint8 unexpectedState_ ) {\r\n\t\tif ( _contractState == unexpectedState_ ) {\r\n\t\t\trevert ContractState_INCORRECT_STATE( _contractState );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal function setting the contract state to `newState_`.\r\n\t* \r\n\t* Note: Contract state defaults to ``PAUSED``.\r\n\t* \t\t\tTo maintain extendability, this value kept as uint8 instead of enum.\r\n\t* \t\t\tAs a result, it is possible to set the state to an incorrect value.\r\n\t* \t\t\tTo avoid issues, `newState_` should be validated before calling this function\r\n\t*/\r\n\tfunction _setContractState( uint8 newState_ ) internal virtual {\r\n\t\tuint8 _previousState_ = _contractState;\r\n\t\t_contractState = newState_;\r\n\t\temit ContractStateChanged( _previousState_, newState_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the current contract state.\r\n\t* \r\n\t* @return uint8 : the current contract state\r\n\t*/\r\n\tfunction getContractState() public virtual view returns ( uint8 ) {\r\n\t\treturn _contractState;\r\n\t}\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/interfaces/IERC2981.sol\r\n\r\n\r\npragma solidity 0.8.17;\r\n\r\n///\r\n/// @dev Interface for the NFT Royalty Standard\r\n///\r\ninterface IERC2981 /* is IERC165 */ {\r\n  /// ERC165 bytes to add to interface array - set in parent contract\r\n  /// implementing this standard\r\n  ///\r\n  /// bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\r\n  /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n  /// _registerInterface(_INTERFACE_ID_ERC2981);\r\n\r\n  /// @notice Called with the sale price to determine how much royalty\r\n  //          is owed and to whom.\r\n  /// @param tokenId_ - the NFT asset queried for royalty information\r\n  /// @param salePrice_ - the sale price of the NFT asset specified by tokenId_\r\n  /// @return receiver - address of who should be sent the royalty payment\r\n  /// @return royaltyAmount - the royalty payment amount for salePrice_\r\n  function royaltyInfo( uint256 tokenId_, uint256 salePrice_ ) external view returns ( address receiver, uint256 royaltyAmount );\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/utils/ERC2981.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\n\r\nabstract contract ERC2981 is IERC2981 {\r\n\t// Errors\r\n  /**\r\n  * @dev Thrown when the desired royalty rate is higher than 10,000\r\n  * \r\n  * @param royaltyRate : the desired royalty rate\r\n  * @param royaltyBase : the maximum royalty rate\r\n  */\r\n\terror IERC2981_INVALID_ROYALTIES( uint256 royaltyRate, uint256 royaltyBase );\r\n\r\n\t// Royalty rate is stored out of 10,000 instead of a percentage to allow for\r\n\t// up to two digits below the unit such as 2.5% or 1.25%.\r\n\tuint private constant ROYALTY_BASE = 10000;\r\n\r\n\t// Represents the percentage of royalties on each sale on secondary markets.\r\n\t// Set to 0 to have no royalties.\r\n\tuint256 private _royaltyRate;\r\n\r\n\t// Address of the recipient of the royalties.\r\n\taddress private _royaltyRecipient;\r\n\r\n\t/**\r\n\t* @notice Called with the sale price to determine how much royalty is owed and to whom.\r\n\t* \r\n\t* Note: This function should be overriden to revert on a query for non existent token.\r\n\t* \r\n  * @param tokenId_   : identifier of the NFT being referenced\r\n  * @param salePrice_ : the sale price of the token sold\r\n  * \r\n  * @return address : the address receiving the royalties\r\n  * @return uint256 : the royalty payment amount\r\n\t*/\r\n\tfunction royaltyInfo( uint256 tokenId_, uint256 salePrice_ ) public view virtual override returns ( address, uint256 ) {\r\n\t\tif ( salePrice_ == 0 || _royaltyRate == 0 ) {\r\n\t\t\treturn ( _royaltyRecipient, 0 );\r\n\t\t}\r\n\t\tuint256 _royaltyAmount_ = _royaltyRate * salePrice_ / ROYALTY_BASE;\r\n\t\treturn ( _royaltyRecipient, _royaltyAmount_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Sets the royalty rate to `royaltyRate_` and the royalty recipient to `royaltyRecipient_`.\r\n\t* \r\n\t* @param royaltyRecipient_ : the address that will receive royalty payments\r\n\t* @param royaltyRate_      : the percentage of the sale price that will be taken off as royalties, expressed in Basis Points (100 BP = 1%)\r\n\t* \r\n\t* Requirements: \r\n\t* \r\n\t* - `royaltyRate_` cannot be higher than `10,000`;\r\n\t*/\r\n\tfunction _setRoyaltyInfo( address royaltyRecipient_, uint256 royaltyRate_ ) internal virtual {\r\n\t\tif ( royaltyRate_ > ROYALTY_BASE ) {\r\n\t\t\trevert IERC2981_INVALID_ROYALTIES( royaltyRate_, ROYALTY_BASE );\r\n\t\t}\r\n\t\t_royaltyRate      = royaltyRate_;\r\n\t\t_royaltyRecipient = royaltyRecipient_;\r\n\t}\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/interfaces/IERC173.sol\r\n\r\n\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n* @dev Required interface of an ERC173 compliant contract, as defined in the\r\n* https://eips.ethereum.org/EIPS/eip-173[EIP].\r\n*/\r\ninterface IERC173 /* is IERC165 */ {\r\n    /// @dev This emits when ownership of a contract changes.    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner    \r\n    /// @return The address of the owner.\r\n    function owner() view external returns(address);\r\n\t\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract    \r\n    function transferOwnership(address _newOwner) external;\t\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/utils/ERC173.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\n\r\n/**\r\n* @dev Contract module which provides a basic access control mechanism, where\r\n* there is an account (an owner) that can be granted exclusive access to\r\n* specific functions.\r\n*\r\n* By default, the owner account will be the one that deploys the contract. This\r\n* can later be changed with {transferOwnership}.\r\n*\r\n* This module is used through inheritance. It will make available the modifier\r\n* `onlyOwner`, which can be applied to your functions to restrict their use to\r\n* the owner.\r\n*/\r\nabstract contract ERC173 is IERC173 {\r\n\t// Errors\r\n  /**\r\n  * @dev Thrown when `operator` is not the contract owner.\r\n  * \r\n  * @param operator : address trying to use a function reserved to contract owner without authorization\r\n  */\r\n  error IERC173_NOT_OWNER( address operator );\r\n\r\n\t// The owner of the contract\r\n\taddress private _owner;\r\n\r\n\t/**\r\n\t* @dev Throws if called by any account other than the owner.\r\n\t*/\r\n\tmodifier onlyOwner() {\r\n\t\taddress _sender_ = msg.sender;\r\n\t\tif ( owner() != _sender_ ) {\r\n\t\t\trevert IERC173_NOT_OWNER( _sender_ );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Sets the contract owner.\r\n\t* \r\n\t* Note: This function needs to be called in the contract constructor to initialize the contract owner, \r\n\t* if it is not, then parts of the contract might be non functional\r\n\t* \r\n\t* @param owner_ : address that owns the contract\r\n\t*/\r\n\tfunction _setOwner( address owner_ ) internal {\r\n\t\t_owner = owner_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the address of the current contract owner.\r\n\t* \r\n\t* @return address : the current contract owner\r\n\t*/\r\n\tfunction owner() public view virtual returns ( address ) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfers ownership of the contract to `newOwner_`.\r\n\t* \r\n\t* @param newOwner_ : address of the new contract owner\r\n\t* \r\n\t* Requirements:\r\n\t* \r\n  * - Caller must be the contract owner.\r\n\t*/\r\n\tfunction transferOwnership( address newOwner_ ) public virtual onlyOwner {\r\n\t\taddress _oldOwner_ = _owner;\r\n\t\t_owner = newOwner_;\r\n\t\temit OwnershipTransferred( _oldOwner_, newOwner_ );\r\n\t}\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/interfaces/IERC1155MetadataURI.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n* @dev Interface of the optional ERC1155MetadataExtension interface, as defined\r\n* in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\r\n*\r\n* _Available since v3.1._\r\n*/\r\ninterface IERC1155MetadataURI /* is IERC1155 */ {\r\n\t/**\r\n\t* @dev Returns the URI for token type `id`.\r\n\t*\r\n\t* If the `\\{id\\}` substring is present in the URI, it must be replaced by\r\n\t* clients with the actual token type ID.\r\n\t*/\r\n\tfunction uri(uint256 id) external view returns (string memory);\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/interfaces/IERC1155Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155Receiver.sol)\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver {\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/interfaces/IERC1155.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\n// import \"./IERC165.sol\";\r\n\r\n/**\r\n* @title ERC-1155 Multi Token Standard\r\n* @dev See https://eips.ethereum.org/EIPS/eip-1155\r\n* Note: The ERC-165 identifier for this interface is 0xd9b67a26.\r\n*/\r\ninterface IERC1155 /* is IERC165 */ {\r\n\t/**\r\n\t* @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\r\n\t* The `operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\r\n\t* The `from` argument MUST be the address of the holder whose balance is decreased.\r\n\t* The `to` argument MUST be the address of the recipient whose balance is increased.\r\n\t* The `id` argument MUST be the token type being transferred.\r\n\t* The `value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\r\n\t* When minting/creating tokens, the `from` argument MUST be set to `0x0` (i.e. zero address).\r\n\t* When burning/destroying tokens, the `to` argument MUST be set to `0x0` (i.e. zero address).        \r\n\t*/\r\n\tevent TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n\t/**\r\n\t* @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).      \r\n\t* The `operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\r\n\t* The `from` argument MUST be the address of the holder whose balance is decreased.\r\n\t* The `to` argument MUST be the address of the recipient whose balance is increased.\r\n\t* The `ids` argument MUST be the list of tokens being transferred.\r\n\t* The `values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in ids) the holder balance is decreased by and match what the recipient balance is increased by.\r\n\t* When minting/creating tokens, the `from` argument MUST be set to `0x0` (i.e. zero address).\r\n\t* When burning/destroying tokens, the `to` argument MUST be set to `0x0` (i.e. zero address).                \r\n\t*/\r\n\tevent TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n\t/**\r\n\t* @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).        \r\n\t*/\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\t/**\r\n\t* @dev MUST emit when the URI is updated for a token ID.\r\n\t* URIs are defined in RFC 3986.\r\n\t* The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\r\n\t*/\r\n\tevent URI(string value, uint256 indexed id);\r\n\r\n\t/**\r\n\t* @notice Transfers `value` amount of an `id` from the `from` address to the `to` address specified (with safety call).\r\n\t* @dev Caller must be approved to manage the tokens being transferred out of the `from` account (see \"Approval\" section of the standard).\r\n\t* MUST revert if `to` is the zero address.\r\n\t* MUST revert if balance of holder for token `id` is lower than the `value` sent.\r\n\t* MUST revert on any other error.\r\n\t* MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\r\n\t* After the above conditions are met, this function MUST check if `to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).        \r\n\t* @param from    Source address\r\n\t* @param to      Target address\r\n\t* @param id      ID of the token type\r\n\t* @param value   Transfer amount\r\n\t* @param data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `to`\r\n\t*/\r\n\tfunction safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\r\n\r\n\t/**\r\n\t* @notice Transfers `values` amount(s) of `ids` from the `from` address to the `to` address specified (with safety call).\r\n\t* @dev Caller must be approved to manage the tokens being transferred out of the `from` account (see \"Approval\" section of the standard).\r\n\t* MUST revert if `to` is the zero address.\r\n\t* MUST revert if length of `ids` is not the same as length of `values`.\r\n\t* MUST revert if any of the balance(s) of the holder(s) for token(s) in `ids` is lower than the respective amount(s) in `values` sent to the recipient.\r\n\t* MUST revert on any other error.        \r\n\t* MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\r\n\t* Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before ids[1]/_values[1], etc).\r\n\t* After the above conditions for the transfer(s) in the batch are met, this function MUST check if `to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).                      \r\n\t* @param from    Source address\r\n\t* @param to      Target address\r\n\t* @param ids     IDs of each token type (order and length must match values array)\r\n\t* @param values  Transfer amounts per token type (order and length must match ids array)\r\n\t* @param data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `to`\r\n\t*/\r\n\tfunction safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata values, bytes calldata data) external;\r\n\r\n\t/**\r\n\t* @notice Get the balance of an account's tokens.\r\n\t* @param owner  The address of the token holder\r\n\t* @param id     ID of the token\r\n\t* @return       The owner's balance of the token type requested\r\n\t*/\r\n\tfunction balanceOf(address owner, uint256 id) external view returns (uint256);\r\n\r\n\t/**\r\n\t* @notice Get the balance of multiple account/token pairs\r\n\t* @param owners The addresses of the token holders\r\n\t* @param ids    ID of the tokens\r\n\t* @return       The owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\r\n\t*/\r\n\tfunction balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory);\r\n\r\n\t/**\r\n\t* @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n\t* @dev MUST emit the ApprovalForAll event on success.\r\n\t* @param operator  Address to add to the set of authorized operators\r\n\t* @param approved  True if the operator is approved, false to revoke approval\r\n\t*/\r\n\tfunction setApprovalForAll(address operator, bool approved) external;\r\n\r\n\t/**\r\n\t* @notice Queries the approval status of an operator for a given owner.\r\n\t* @param owner     The owner of the tokens\r\n\t* @param operator  Address of authorized operator\r\n\t* @return          True if the operator is approved, false if not\r\n\t*/\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/interfaces/IERC165.sol\r\n\r\n\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/interfaces/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n// https://eips.ethereum.org/EIPS/eip-20\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n* @dev Interface of the ERC20 standard as defined in the EIP.\r\n*/\r\ninterface IERC20 /* is IERC165 */ {\r\n    /**\r\n    * @dev Returns the amount of tokens in existence.\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Returns the amount of tokens owned by `account`.\r\n    */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Returns the remaining number of tokens that `spender` will be\r\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n    * zero by default.\r\n    *\r\n    * This value changes when {approve} or {transferFrom} are called.\r\n    */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n    * that someone may use both the old and the new allowance by unfortunate\r\n    * transaction ordering. One possible solution to mitigate this race\r\n    * condition is to first reduce the spender's allowance to 0 and set the\r\n    * desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    *\r\n    * Emits an {Approval} event.\r\n    */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n    * allowance mechanism. `amount` is then deducted from the caller's\r\n    * allowance.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n    * another (`to`).\r\n    *\r\n    * Note that `value` may be zero.\r\n    */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n    * a call to {approve}. `value` is the new allowance.\r\n    */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/interfaces/INFTSupplyErrors.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface INFTSupplyErrors {\r\n  /**\r\n  * @dev Thrown when trying to mint 0 token.\r\n  */\r\n  error NFT_INVALID_QTY();\r\n  /**\r\n  * @dev Thrown when trying to set max supply to an invalid amount.\r\n  */\r\n  error NFT_INVALID_SUPPLY();\r\n  /**\r\n  * @dev Thrown when trying to mint more tokens than the max allowed per transaction.\r\n  * \r\n  * @param qtyRequested : the amount of tokens requested\r\n  * @param maxBatch     : the maximum amount that can be minted per transaction\r\n  */\r\n  error NFT_MAX_BATCH( uint256 qtyRequested, uint256 maxBatch );\r\n  /**\r\n  * @dev Thrown when trying to mint more tokens from the reserve than the amount left.\r\n  * \r\n  * @param qtyRequested : the amount of tokens requested\r\n  * @param reserveLeft  : the amount of tokens left in the reserve\r\n  */\r\n  error NFT_MAX_RESERVE( uint256 qtyRequested, uint256 reserveLeft );\r\n  /**\r\n  * @dev Thrown when trying to mint more tokens than the amount left to be minted (except reserve).\r\n  * \r\n  * @param qtyRequested    : the amount of tokens requested\r\n  * @param remainingSupply : the amount of tokens left in the reserve\r\n  */\r\n  error NFT_MAX_SUPPLY( uint256 qtyRequested, uint256 remainingSupply );\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/interfaces/IERC1155Errors.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IERC1155Errors {\r\n  /**\r\n  * @dev Thrown when `operator` has not been approved to manage `tokenId` on behalf of `tokenOwner`.\r\n  * \r\n  * @param from     : address owning the token\r\n  * @param operator : address trying to manage the token\r\n  */\r\n  error IERC1155_CALLER_NOT_APPROVED( address from, address operator );\r\n  /**\r\n  * @dev Thrown when trying to create series `id` that already exists.\r\n  * \r\n  * @param id : identifier of the NFT being referenced\r\n  */\r\n  error IERC1155_EXISTANT_TOKEN( uint256 id );\r\n  /**\r\n  * @dev Thrown when `from` tries to transfer more than they own.\r\n  * \r\n  * @param from    : address that the NFT are being transferred from\r\n  * @param id      : identifier of the NFT being referenced\r\n  * @param balance : amount of tokens that the address owns\r\n  */\r\n  error IERC1155_INSUFFICIENT_BALANCE( address from, uint256 id, uint256 balance );\r\n  /**\r\n  * @dev Thrown when operator tries to approve themselves for managing a token they own.\r\n  */\r\n  error IERC1155_INVALID_CALLER_APPROVAL();\r\n  /**\r\n  * @dev Thrown when a token is being transferred to the zero address.\r\n  */\r\n  error IERC1155_INVALID_TRANSFER();\r\n  /**\r\n  * @dev Thrown when the requested token doesn't exist.\r\n  * \r\n  * @param id : identifier of the NFT being referenced\r\n  */\r\n  error IERC1155_NON_EXISTANT_TOKEN( uint256 id );\r\n  /**\r\n  * @dev Thrown when a token is being safely transferred to a contract unable to handle it.\r\n  * \r\n  * @param receiver : address unable to receive the token\r\n  */\r\n  error IERC1155_NON_ERC1155_RECEIVER( address receiver );\r\n  /**\r\n  * @dev Thrown when an ERC1155Receiver contract rejects a transfer.\r\n  */\r\n  error IERC1155_REJECTED_TRANSFER();\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/interfaces/IEtherErrors.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IEtherErrors {\r\n  /**\r\n  * @dev Thrown when an incorrect amount of eth is being sent for a payable operation.\r\n  * \r\n  * @param amountReceived : the amount the contract received\r\n  * @param amountExpected : the actual amount the contract expected to receive\r\n  */\r\n  error ETHER_INCORRECT_PRICE( uint256 amountReceived, uint256 amountExpected );\r\n  /**\r\n  * @dev Thrown when trying to withdraw from the contract with no balance.\r\n  */\r\n  error ETHER_NO_BALANCE();\r\n  /**\r\n  * @dev Thrown when contract fails to send ether to recipient.\r\n  * \r\n  * @param to     : the recipient of the ether\r\n  * @param amount : the amount of ether being sent\r\n  */\r\n  error ETHER_TRANSFER_FAIL( address to, uint256 amount );\r\n}\r\n\r\n// File: contracts/EthereumContracts/contracts/interfaces/IArrayErrors.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IArrayErrors {\r\n  /**\r\n  * @dev Thrown when two related arrays have different lengths\r\n  */\r\n  error ARRAY_LENGTH_MISMATCH();\r\n}\r\n\r\n// File: contracts/JuiceTeam.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract JuiceTeam is \r\n\tIERC1155Errors, IArrayErrors, IEtherErrors, INFTSupplyErrors,\r\n\tIERC165, IERC1155, IERC1155MetadataURI,\r\n\tUpdatableOperatorFilterer, ProxyAccess, ERC2981, ERC173, ContractState, Whitelist_ECDSA {\r\n\t/**\r\n\t* @dev Thrown when `account` doesn't own the expected amount of `tokenAddress` tokens.\r\n\t* \r\n\t* @param account      : the operating account\r\n\t* @param amount       : the amount of tokens expected\r\n\t* @param tokenAddress : the contract address being checked\r\n\t*/\r\n\terror JT_INSUFFICIENT_BALANCE( address account, uint256 amount, address tokenAddress );\r\n\r\n\t/**\r\n\t* @dev A structure representing the deployment configuration of the contract.\r\n\t* It contains several pieces of information:\r\n\t* - maxBatch         : The maximum amount of tokens that can be minted in one transaction (for public sale)\r\n\t* - name             : The name of the tokens, for token trackers (i.e. 'Cool Cats')\r\n\t* - symbol           : The symbol of the tokens, for token trackers (i.e. 'COOL')\r\n\t*/\r\n\tstruct Config {\r\n\t\tuint256 maxBatch;\r\n\t\tstring  name;\r\n\t\tstring  symbol;\r\n\t}\r\n\r\n\tuint8 private constant _OPEN = 1;\r\n\tuint256 public constant DEFAULT_PASS_ID = 1;\r\n\taddress public constant DEFAULT_SUBSCRIPTION = address( 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6 );\r\n\taddress public constant DEFAULT_OPERATOR_FILTER_REGISTRY = address( 0x000000000000AAeB6D7670E522A718067333cd4E );\r\n\taddress public constant OS_PROXY_REGISTRY = address( 0xa5409ec958C83C3f309868babACA7c86DCB077c1 );\r\n\taddress public constant WETH_ADDRESS = address( 0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619 );\r\n\r\n\tConfig  private _config;\r\n\taddress private _treasury;\r\n\tstring  private _uri;\r\n\tIERC20  public  immutable WETH;\r\n\t// Mapping from token ID to reserves\r\n\tmapping( uint256 => uint256 ) private _reserves;\r\n\t// Mapping from series ID to public prices\r\n\tmapping( uint256 => uint256 ) public publicSalePrices;\r\n\t// Mapping from series ID to presale prices\r\n\tmapping( uint256 => uint256 ) public privateSalePrices;\r\n\t// Mapping from series ID to remaining supplies\r\n\tmapping( uint256 => uint256 ) public remainingSupplies;\r\n\t// Mapping from series ID to max supplies\r\n\tmapping( uint256 => uint256 ) public maxSupplies;\r\n\t// Mapping from series ID to balances\r\n\tmapping( uint256 => mapping( address => uint256 ) ) private _balances;\r\n\t// Mapping from owner to operator approvals\r\n\tmapping( address => mapping( address => bool ) ) private _operatorApprovals;\r\n\r\n\tconstructor(\r\n\t\taddress treasury_\r\n\t) UpdatableOperatorFilterer( DEFAULT_OPERATOR_FILTER_REGISTRY, DEFAULT_SUBSCRIPTION, true ) {\r\n\t\tConfig memory _config_ = Config(\r\n\t\t\t10,\r\n\t\t\t\"Juice Team Founder Key\",\r\n\t\t\t\"JTFK\"\r\n\t\t);\r\n\t\t__init_NFT1155(\r\n\t\t\ttreasury_,\r\n\t\t\t_config_\r\n\t\t);\r\n\t\t_uri = \"https://gateway.pinata.cloud/ipfs/QmaunTfDSG5B3avd69GbmJrVogkrzTcHoC62rPyy4FJt4s/\";\r\n\t\t_setOwner( msg.sender );\r\n\t\t_setRoyaltyInfo( treasury_, 500 );\r\n\t\t_addProxyRegistry( OS_PROXY_REGISTRY );\r\n\t\tWETH = IERC20( WETH_ADDRESS );\r\n\t}\r\n\r\n\tfunction __init_NFT1155(\r\n\t\taddress treasury_,\r\n\t\tConfig memory config_\r\n\t) internal {\r\n\t\t_treasury = treasury_;\r\n\t\t_config = config_;\r\n\t}\r\n\r\n\t// **************************************\r\n\t// *****          MODIFIER          *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Throws if sale state is not `whitelist[ id_ ]`.\r\n\t\t*/\r\n\t\tmodifier isWhitelist( uint256 id_ ) {\r\n\t\t\tif ( getContractState() != id_ ) {\r\n\t\t\t\trevert ContractState_INCORRECT_STATE( getContractState() );\r\n\t\t\t}\r\n\t\t\t_;\r\n\t\t}\r\n\r\n\t\tmodifier isWhitelistOrOpen ( uint256 id_ ) {\r\n\t\t\tuint8 _currentState_ = getContractState();\r\n\t\t\tif ( _currentState_ != _OPEN &&\r\n\t\t\t\t\t _currentState_ != id_ ) {\r\n\t\t\t\trevert ContractState_INCORRECT_STATE( _currentState_ );\r\n\t\t\t}\r\n\t\t\t_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Ensures that `qty_` is higher than 0\r\n\t\t* \r\n\t\t* @param qty_ : the amount to validate \r\n\t\t*/\r\n\t\tmodifier validateAmount( uint256 qty_ ) {\r\n\t\t\tif ( qty_ == 0 ) {\r\n\t\t\t\trevert NFT_INVALID_QTY();\r\n\t\t\t}\r\n\t\t\t_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Ensures that `id_` is a valid series\r\n\t\t* \r\n\t\t* @param id_ : the series id to validate \r\n\t\t*/\r\n\t\tmodifier isValidSeries( uint256 id_ ) {\r\n\t\t\tif ( maxSupplies[ id_ ] == 0 ) {\r\n\t\t\t\trevert IERC1155_NON_EXISTANT_TOKEN( id_ );\r\n\t\t\t}\r\n\t\t\t_;\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****          INTERNAL          *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Internal function that checks if the receiver address is a smart contract able to handle batches of IERC1155 tokens.\r\n\t\t*/\r\n\t\tfunction _doSafeBatchTransferAcceptanceCheck( address operator_, address from_, address to_, uint256[] memory ids_, uint256[] memory amounts_, bytes memory data_ ) private {\r\n\t\t\tuint256 _size_;\r\n\t\t\tassembly {\r\n\t\t\t\t_size_ := extcodesize( to_ )\r\n\t\t\t}\r\n\t\t\tif ( _size_ > 0 ) {\r\n\t\t\t\ttry IERC1155Receiver( to_ ).onERC1155BatchReceived( operator_, from_, ids_, amounts_, data_ ) returns ( bytes4 response ) {\r\n\t\t\t\t\tif ( response != IERC1155Receiver.onERC1155BatchReceived.selector ) {\r\n\t\t\t\t\t\trevert IERC1155_REJECTED_TRANSFER();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( bytes memory reason ) {\r\n\t\t\t\t\tif ( reason.length == 0 ) {\r\n\t\t\t\t\t\trevert IERC1155_REJECTED_TRANSFER();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tassembly {\r\n\t\t\t\t\t\t\trevert( add( 32, reason ), mload( reason ) )\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function that checks if the receiver address is a smart contract able to handle IERC1155 tokens.\r\n\t\t*/\r\n\t\tfunction _doSafeTransferAcceptanceCheck( address operator_, address from_, address to_, uint256 id_, uint256 amount_, bytes memory data_ ) private {\r\n\t\t\tuint256 _size_;\r\n\t\t\tassembly {\r\n\t\t\t\t_size_ := extcodesize( to_ )\r\n\t\t\t}\r\n\t\t\tif ( _size_ > 0 ) {\r\n\t\t\t\ttry IERC1155Receiver( to_ ).onERC1155Received( operator_, from_, id_, amount_, data_ ) returns ( bytes4 response ) {\r\n\t\t\t\t\tif ( response != IERC1155Receiver.onERC1155Received.selector ) {\r\n\t\t\t\t\t\trevert IERC1155_REJECTED_TRANSFER();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( bytes memory reason ) {\r\n\t\t\t\t\tif ( reason.length == 0 ) {\r\n\t\t\t\t\t\trevert IERC1155_REJECTED_TRANSFER();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tassembly {\r\n\t\t\t\t\t\t\trevert( add( 32, reason ), mload( reason ) )\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function that checks if `operator_` is allowed to handle tokens on behalf of `owner_`\r\n\t\t*/\r\n\t\tfunction _isApprovedOrOwner( address owner_, address operator_ ) internal view returns ( bool ) {\r\n\t\t\treturn owner_ == operator_ ||\r\n\t\t\t\t\t\t isApprovedForAll( owner_, operator_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function that checks whether `id_` is an existing series.\r\n\t\t*/\r\n\t\tfunction _isValidSeries( uint256 id_ ) internal view returns ( bool ) {\r\n\t\t\tif ( maxSupplies[ id_ ] == 0 ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function that mints `amount_` tokens from series `id_` into `account_`.\r\n\t\t*/\r\n\t\tfunction _mint( address account_, uint256 id_, uint256 amount_ ) internal {\r\n\t\t\tunchecked {\r\n\t\t\t\t_balances[ id_ ][ account_ ] += amount_;\r\n\t\t\t\tremainingSupplies[ id_ ] -= amount_;\r\n\t\t\t}\r\n\t\t\temit TransferSingle( account_, address( 0 ), account_, id_, amount_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function burning the necessary amount of currency from `tokenOwner_`.\r\n\t\t* \r\n\t\t* @param tokenOwner_ : the token owner to check\r\n\t\t* @param amount_     : the amount of coin to be paid\r\n\t\t*/\r\n\t\tfunction _processPayment( address tokenOwner_, uint256 amount_ ) internal {\r\n\t\t\ttry WETH.transferFrom( tokenOwner_, address( this ), amount_ ) {}\r\n\t\t\tcatch Error( string memory ) {\r\n\t\t\t\trevert JT_INSUFFICIENT_BALANCE( tokenOwner_, amount_, address( WETH ) );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n\t\t*/\r\n\t\tfunction _toString( uint256 value_ ) internal pure returns ( string memory ) {\r\n\t\t\t// Inspired by OraclizeAPI's implementation - MIT licence\r\n\t\t\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\t\t\tif ( value_ == 0 ) {\r\n\t\t\t\treturn \"0\";\r\n\t\t\t}\r\n\t\t\tuint256 _temp_ = value_;\r\n\t\t\tuint256 _digits_;\r\n\t\t\twhile ( _temp_ != 0 ) {\r\n\t\t\t\t_digits_ ++;\r\n\t\t\t\t_temp_ /= 10;\r\n\t\t\t}\r\n\t\t\tbytes memory _buffer_ = new bytes( _digits_ );\r\n\t\t\twhile ( value_ != 0 ) {\r\n\t\t\t\t_digits_ -= 1;\r\n\t\t\t\t_buffer_[ _digits_ ] = bytes1( uint8( 48 + uint256( value_ % 10 ) ) );\r\n\t\t\t\tvalue_ /= 10;\r\n\t\t\t}\r\n\t\t\treturn string( _buffer_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****           PUBLIC           *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @notice Mints `qty_` amount of `id_` to the caller address.\r\n\t\t* \r\n\t\t* @param id_       The series id to mint \r\n\t\t* @param qty_      Amount of tokens to mint\r\n\t\t* @param alloted_  Amount of tokens that caller is allowed to claim\r\n\t\t* @param proof_    Signature confirming that the caller is allowed to mint `alloeted_` number of tokens\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Contract state must be `whitelist[ id_ ]`\r\n\t\t* - Whitelist must be set \r\n\t\t* - Caller must be allowed to mint `qty_` tokens\r\n\t\t*/\r\n\t\tfunction mintWhitelist( uint256 id_, uint256 qty_, uint256 alloted_, Proof memory proof_ ) external isValidSeries( id_ ) isWhitelist( id_ ) validateAmount( qty_ ) isWhitelisted( msg.sender, uint8( id_ ), alloted_, proof_, qty_ ) {\r\n\t\t\tif ( qty_ > remainingSupplies[ id_ ] ) {\r\n\t\t\t\trevert NFT_MAX_SUPPLY( qty_, remainingSupplies[ id_ ] );\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _expected_ = qty_ * privateSalePrices[ id_ ];\r\n\t\t\tif ( _expected_ > WETH.balanceOf( msg.sender ) ) {\r\n\t\t\t\trevert JT_INSUFFICIENT_BALANCE( msg.sender, _expected_, address( WETH ) );\r\n\t\t\t}\r\n\r\n\t\t\t_consumeWhitelist( msg.sender, uint8( id_ ), qty_ );\r\n\t\t\t_mint( msg.sender, id_, qty_ );\r\n\t\t\t_processPayment( msg.sender, _expected_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Mints `qty_` amount of `id_` to the caller address.\r\n\t\t* \r\n\t\t* @param qty_  Amount of tokens to mint\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Contract state must be `OPEN`\r\n\t\t* - `qty_` must be lower than `_config.maxBatch`\r\n\t\t* - `qty_` must be lower or equal to `remainingSupplies[ id_ ]`\r\n\t\t* - Caller must send enough eth to pay for `qty_` tokens\r\n\t\t*/\r\n\t\tfunction mintPublicOrWhitelist( uint256 id_, uint256 qty_ ) external payable isValidSeries( id_ ) isWhitelistOrOpen( id_ ) validateAmount( qty_ ) {\r\n\t\t\tif ( qty_ > remainingSupplies[ id_ ] ) {\r\n\t\t\t\trevert NFT_MAX_SUPPLY( qty_, remainingSupplies[ id_ ] );\r\n\t\t\t}\r\n\t\t\tif ( qty_ > _config.maxBatch ) {\r\n\t\t\t\trevert NFT_MAX_BATCH( qty_, _config.maxBatch );\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _expected_ = qty_ * publicSalePrices[ id_ ];\r\n\t\t\tif ( _expected_ > WETH.balanceOf( msg.sender ) ) {\r\n\t\t\t\trevert JT_INSUFFICIENT_BALANCE( msg.sender, _expected_, address( WETH ) );\r\n\t\t\t}\r\n\r\n\t\t\t_mint( msg.sender, id_, qty_ );\r\n\t\t\t_processPayment( msg.sender, _expected_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Mints `qty_` amount of `id_` to the caller address.\r\n\t\t* \r\n\t\t* @param qty_  Amount of tokens to mint\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Contract state must be `OPEN`\r\n\t\t* - `qty_` must be lower than `_config.maxBatch`\r\n\t\t* - `qty_` must be lower or equal to `remainingSupplies[ id_ ]`\r\n\t\t* - Caller must send enough eth to pay for `qty_` tokens\r\n\t\t*/\r\n\t\tfunction mintPublic( uint256 id_, uint256 qty_ ) external payable isValidSeries( id_ ) isState( _OPEN ) validateAmount( qty_ ) {\r\n\t\t\tif ( qty_ > remainingSupplies[ id_ ] ) {\r\n\t\t\t\trevert NFT_MAX_SUPPLY( qty_, remainingSupplies[ id_ ] );\r\n\t\t\t}\r\n\t\t\tif ( qty_ > _config.maxBatch ) {\r\n\t\t\t\trevert NFT_MAX_BATCH( qty_, _config.maxBatch );\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _expected_ = qty_ * publicSalePrices[ id_ ];\r\n\t\t\tif ( _expected_ > WETH.balanceOf( msg.sender ) ) {\r\n\t\t\t\trevert JT_INSUFFICIENT_BALANCE( msg.sender, _expected_, address( WETH ) );\r\n\t\t\t}\r\n\r\n\t\t\t_mint( msg.sender, id_, qty_ );\r\n\t\t\t_processPayment( msg.sender, _expected_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Transfers `amounts_` amount(s) of `ids_` from the `from_` address to the `to_` address specified (with safety call).\r\n\t\t* \r\n\t\t* @param from_     Source address\r\n\t\t* @param to_       Target address\r\n\t\t* @param ids_      IDs of each token type (order and length must match `amounts_` array)\r\n\t\t* @param amounts_  Transfer amounts per token type (order and length must match `ids_` array)\r\n\t\t* @param data_     Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `to_`\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be approved to manage the tokens being transferred out of the `from_` account (see \"Approval\" section of the standard).\r\n\t\t* - MUST revert if `to_` is the zero address.\r\n\t\t* - MUST revert if length of `ids_` is not the same as length of `amounts_`.\r\n\t\t* - MUST revert if any of the balance(s) of the holder(s) for token(s) in `ids_` is lower than the respective amount(s) in `amounts_` sent to the recipient.\r\n\t\t* - MUST revert on any other error.        \r\n\t\t* - MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\r\n\t\t* - Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_amounts[0] before ids_[1]/_amounts[1], etc).\r\n\t\t* - After the above conditions for the transfer(s) in the batch are met, this function MUST check if `to_` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `to_` and act appropriately (see \"Safe Transfer Rules\" section of the standard).                      \r\n\t\t*/\r\n\t\tfunction safeBatchTransferFrom( address from_, address to_, uint256[] calldata ids_, uint256[] calldata amounts_, bytes calldata data_ ) external override onlyAllowedOperator( msg.sender ) {\r\n\t\t\tif ( to_ == address( 0 ) ) {\r\n\t\t\t\trevert IERC1155_INVALID_TRANSFER();\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _len_ = ids_.length;\r\n\t\t\tif ( amounts_.length != _len_ ) {\r\n\t\t\t\trevert ARRAY_LENGTH_MISMATCH();\r\n\t\t\t}\r\n\r\n\t\t\taddress _operator_ = msg.sender;\r\n\t\t\tif ( ! _isApprovedOrOwner( from_, _operator_ ) ) {\r\n\t\t\t\trevert IERC1155_CALLER_NOT_APPROVED( from_, _operator_ );\r\n\t\t\t}\r\n\r\n\t\t\tfor ( uint256 i; i < _len_; ) {\r\n\t\t\t\tif ( ! _isValidSeries( ids_[ i ] ) ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tuint256 _balance_ = _balances[ ids_[ i ] ][ from_ ];\r\n\t\t\t\tif ( _balance_ < amounts_[ i ] ) {\r\n\t\t\t\t\trevert IERC1155_INSUFFICIENT_BALANCE( from_, ids_[ i ], _balance_);\r\n\t\t\t\t}\r\n\t\t\t\tunchecked {\r\n\t\t\t\t\t_balances[ ids_[ i ] ][ from_ ] = _balance_ - amounts_[ i ];\r\n\t\t\t\t}\r\n\t\t\t\t_balances[ ids_[ i ] ][ to_ ] += amounts_[ i ];\r\n\t\t\t\tunchecked {\r\n\t\t\t\t\t++i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\temit TransferBatch( _operator_, from_, to_, ids_, amounts_ );\r\n\r\n\t\t\t_doSafeBatchTransferAcceptanceCheck( _operator_, from_, to_, ids_, amounts_, data_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Transfers `amount_` amount of an `id_` from the `from_` address to the `to_` address specified (with safety call).\r\n\t\t* \r\n\t\t* @param from_    Source address\r\n\t\t* @param to_      Target address\r\n\t\t* @param id_      ID of the token type\r\n\t\t* @param amount_  Transfer amount\r\n\t\t* @param data_    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `to_`\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be approved to manage the tokens being transferred out of the `from_` account (see \"Approval\" section of the standard).\r\n\t\t* - MUST revert if `to_` is the zero address.\r\n\t\t* - MUST revert if balance of holder for token type `id_` is lower than the `amount_` sent.\r\n\t\t* - MUST revert on any other error.\r\n\t\t* - MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\r\n\t\t* - After the above conditions are met, this function MUST check if `to_` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `to_` and act appropriately (see \"Safe Transfer Rules\" section of the standard).        \r\n\t\t*/\r\n\t\tfunction safeTransferFrom( address from_, address to_, uint256 id_, uint256 amount_, bytes calldata data_ ) external override isValidSeries( id_ ) onlyAllowedOperator( msg.sender ) {\r\n\t\t\tif ( to_ == address( 0 ) ) {\r\n\t\t\t\trevert IERC1155_INVALID_TRANSFER();\r\n\t\t\t}\r\n\r\n\t\t\taddress _operator_ = msg.sender;\r\n\t\t\tif ( ! _isApprovedOrOwner( from_, _operator_ ) ) {\r\n\t\t\t\trevert IERC1155_CALLER_NOT_APPROVED( from_, _operator_ );\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _balance_ = _balances[ id_ ][ from_ ];\r\n\t\t\tif ( _balance_ < amount_ ) {\r\n\t\t\t\trevert IERC1155_INSUFFICIENT_BALANCE( from_, id_, _balance_ );\r\n\t\t\t}\r\n\t\t\tunchecked {\r\n\t\t\t\t_balances[ id_ ][ from_ ] = _balance_ - amount_;\r\n\t\t\t}\r\n\t\t\t_balances[ id_ ][ to_ ] += amount_;\r\n\t\t\temit TransferSingle( _operator_, from_, to_, id_, amount_ );\r\n\r\n\t\t\t_doSafeTransferAcceptanceCheck( _operator_, from_, to_, id_, amount_, data_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n\t\t* \r\n\t\t* @param operator_  Address to add to the set of authorized operators\r\n\t\t* @param approved_  True if the operator is approved, false to revoke approval\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - MUST emit the ApprovalForAll event on success.\r\n\t\t*/\r\n\t\tfunction setApprovalForAll( address operator_, bool approved_ ) external override onlyAllowedOperatorApproval( msg.sender ) {\r\n\t\t\taddress _tokenOwner_ = msg.sender;\r\n\t\t\tif ( _tokenOwner_ == operator_ ) {\r\n\t\t\t\trevert IERC1155_INVALID_CALLER_APPROVAL();\r\n\t\t\t}\r\n\r\n\t\t\t_operatorApprovals[ _tokenOwner_ ][ operator_ ] = approved_;\r\n\t\t\temit ApprovalForAll( _tokenOwner_, operator_, approved_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****       CONTRACT OWNER       *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @notice Adds a proxy registry to the list of accepted proxy registries.\r\n\t\t* \r\n\t\t* @param proxyRegistryAddress_  the address of the proxy registry to be added\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction addProxyRegistry( address proxyRegistryAddress_ ) external onlyOwner {\r\n\t\t\t_addProxyRegistry( proxyRegistryAddress_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Mints `amounts_` tokens of `id_` and transfers them to `accounts_`.\r\n\t\t* \r\n\t\t* @param accounts_ : the list of accounts that will receive airdropped tokens\r\n\t\t* @param amounts_  : the amount of tokens each account will receive\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t* - `accounts_` and `amounts_` must have the same length.\r\n\t\t* - There must be enough tokens left in the reserve.\r\n\t\t*/\r\n\t\tfunction airdrop( uint256 id_, address[] memory accounts_, uint256[] memory amounts_ ) public onlyOwner isValidSeries( id_ ) {\r\n\t\t\tuint256 _amountsLen_ = amounts_.length;\r\n\t\t\tif ( accounts_.length != _amountsLen_ ) {\r\n\t\t\t\trevert ARRAY_LENGTH_MISMATCH();\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _totalQty_;\r\n\t\t\tfor ( uint256 i = _amountsLen_; i > 0; i -- ) {\r\n\t\t\t\t_totalQty_ += amounts_[ i - 1 ];\r\n\t\t\t}\r\n\t\t\tif ( _totalQty_ > _reserves[ id_ ] ) {\r\n\t\t\t\trevert NFT_MAX_RESERVE( _totalQty_, _reserves[ id_ ] );\r\n\t\t\t}\r\n\t\t\tunchecked {\r\n\t\t\t\t_reserves[ id_ ] -= _totalQty_;\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _count_ = _amountsLen_;\r\n\t\t\twhile ( _count_ > 0 ) {\r\n\t\t\t\tunchecked {\r\n\t\t\t\t\t_count_ --;\r\n\t\t\t\t}\r\n\t\t\t\t_mint( accounts_[ _count_ ], id_, amounts_[ _count_ ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Creates a new series\r\n\t\t* \r\n\t\t* @param id_               the new series ID\r\n\t\t* @param maxSupply_        the new series max supply\r\n\t\t* @param publicSalePrice_  the new series public price\r\n\t\t* @param privateSalePrice_ the new series private price\r\n\t\t* @param reserve_          the new series reserve\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction createSeries( uint256 id_, uint256 maxSupply_, uint256 publicSalePrice_, uint256 privateSalePrice_, uint256 reserve_ ) external onlyOwner {\r\n\t\t\tif ( maxSupplies[ id_ ] != 0 ) {\r\n\t\t\t\trevert IERC1155_EXISTANT_TOKEN( id_ );\r\n\t\t\t}\r\n\r\n\t\t\tmaxSupplies[ id_ ] = maxSupply_;\r\n\t\t\tremainingSupplies[ id_ ] = maxSupply_;\r\n\t\t\tpublicSalePrices[ id_ ] = publicSalePrice_;\r\n\t\t\tprivateSalePrices[ id_ ] = privateSalePrice_;\r\n\t\t\t_reserves[ id_ ] = reserve_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Updates an existing series\r\n\t\t* \r\n\t\t* @param id_               the new series ID\r\n\t\t* @param maxSupply_        the new series max supply\r\n\t\t* @param publicSalePrice_  the new series public price\r\n\t\t* @param privateSalePrice_ the new series private price\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction updateSeries( uint256 id_, uint256 maxSupply_, uint256 publicSalePrice_, uint256 privateSalePrice_, uint256 reserve_ ) external onlyOwner isValidSeries( id_ ) {\r\n\t\t\tuint256 _diff_ = maxSupplies[ id_ ] - maxSupply_;\r\n\t\t\tif ( maxSupplies[ id_ ] > maxSupply_ ||\r\n\t\t\t\t\t _diff_ > remainingSupplies[ id_ ] ) {\r\n\t\t\t\trevert NFT_INVALID_SUPPLY();\r\n\t\t\t}\r\n\r\n\t\t\tunchecked {\r\n\t\t\t\tremainingSupplies[ id_ ] -= _diff_;\r\n\t\t\t}\r\n\t\t\tmaxSupplies[ id_ ] = maxSupply_;\r\n\t\t\tpublicSalePrices[ id_ ] = publicSalePrice_;\r\n\t\t\tprivateSalePrices[ id_ ] = privateSalePrice_;\r\n\t\t\t_reserves[ id_ ] = reserve_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Removes a proxy registry from the list of accepted proxy registries.\r\n\t\t* \r\n\t\t* @param proxyRegistryAddress_  the address of the proxy registry to be removed\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction removeProxyRegistry( address proxyRegistryAddress_ ) external onlyOwner {\r\n\t\t\t_removeProxyRegistry( proxyRegistryAddress_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Sets the contract state to `newState_`.\r\n\t\t* \r\n\t\t* @param newState_  the new sale state\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction setContractState( uint8 newState_ ) external onlyOwner {\r\n\t\t\t_setContractState( newState_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Updates the royalty recipient and rate.\r\n\t\t* \r\n\t\t* @param royaltyRecipient_  the new recipient of the royalties\r\n\t\t* @param royaltyRate_       the new royalty rate\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner\r\n\t\t* - `royaltyRate_` must be between 0 and 10,000\r\n\t\t*/\r\n\t\tfunction setRoyaltyInfo( address royaltyRecipient_, uint256 royaltyRate_ ) external onlyOwner {\r\n\t\t\t_setRoyaltyInfo( royaltyRecipient_, royaltyRate_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Sets the uri of the tokens.\r\n\t\t* \r\n\t\t* @param uri_  The new uri of the tokens\r\n\t\t*/\r\n\t\tfunction setURI( string memory uri_ ) external onlyOwner {\r\n\t\t\t_uri = uri_;\r\n\t\t\temit URI( uri_, DEFAULT_PASS_ID );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Sets the whitelist signer.\r\n\t\t* \r\n\t\t* @param adminSigner_  The address signing the whitelist permissions\r\n\t\t*/\r\n\t\tfunction setWhitelist( address adminSigner_ ) public onlyOwner {\r\n\t\t\t_setWhitelist( adminSigner_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Withdraws all the money stored in the contract and sends it to the caller.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t* - Contract must have a positive balance.\r\n\t\t*/\r\n\t\tfunction withdraw() public onlyOwner {\r\n\t\t\tuint256 _balance_ = WETH.balanceOf( address( this ) );\r\n\t\t\tif ( _balance_ == 0 ) {\r\n\t\t\t\trevert ETHER_NO_BALANCE();\r\n\t\t\t}\r\n\r\n\t\t\ttry WETH.transfer( _treasury, _balance_ ) {}\r\n\t\t\tcatch Error( string memory ) {\r\n\t\t\t\trevert JT_INSUFFICIENT_BALANCE( address( this ), _balance_, address( WETH ) );\r\n\t\t\t}\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****            VIEW            *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @notice Get the balance of an account's tokens.\r\n\t\t* \r\n\t\t* @param owner_  The address of the token holder\r\n\t\t* @param id_     ID of the token type\r\n\t\t* @return        The owner_'s balance of the token type requested\r\n\t\t*/\r\n\t\tfunction balanceOf( address owner_, uint256 id_ ) public view override isValidSeries( id_ ) returns ( uint256 ) {\r\n\t\t\treturn _balances[ id_ ][ owner_ ];\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Get the balance of multiple account/token pairs\r\n\t\t* \r\n\t\t* @param owners_  The addresses of the token holders\r\n\t\t* @param ids_     ID of the token types\r\n\t\t* @return         The owners_' balance of the token types requested (i.e. balance for each (owner, id) pair)\r\n\t\t*/\r\n\t\tfunction balanceOfBatch( address[] calldata owners_, uint256[] calldata ids_ ) public view override returns ( uint256[] memory ) {\r\n\t\t\tuint256 _len_ = owners_.length;\r\n\t\t\tif ( _len_ != ids_.length ) {\r\n\t\t\t\trevert ARRAY_LENGTH_MISMATCH();\r\n\t\t\t}\r\n\r\n\t\t\tuint256[] memory _balances_ = new uint256[]( _len_ );\r\n\t\t\twhile ( _len_ > 0 ) {\r\n\t\t\t\tunchecked {\r\n\t\t\t\t\t--_len_;\r\n\t\t\t\t}\r\n\t\t\t\tif ( ! _isValidSeries( ids_[ _len_ ] ) ) {\r\n\t\t\t\t\t_balances_[ _len_ ] = 0;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_balances_[ _len_ ] = _balances[ ids_[ _len_ ] ][ owners_[ _len_ ] ];\r\n\t\t\t}\r\n\r\n\t\t\treturn _balances_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Queries the approval status of an operator for a given owner.\r\n\t\t* \r\n\t\t* @param owner_     The owner of the tokens\r\n\t\t* @param operator_  Address of authorized operator\r\n\t\t* @return           True if the operator is approved, false if not\r\n\t\t*/\r\n\t\tfunction isApprovedForAll( address owner_, address operator_ ) public view override returns ( bool ) {\r\n\t\t\treturn _operatorApprovals[ owner_ ][ operator_ ] ||\r\n\t\t\t\t\t\t _isRegisteredProxy( owner_, operator_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev returns the contract owner.\r\n\t\t*/\r\n\t\tfunction owner() public view override(ERC173, UpdatableOperatorFilterer) returns ( address ) {\r\n\t\t\treturn ERC173.owner();\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @notice Query if a contract implements an interface.\r\n\t\t* \r\n\t\t* @dev Interface identification is specified in ERC-165. This function uses less than 30,000 gas.\r\n\t\t* @param interfaceID_  The interface identifier, as specified in ERC-165\r\n\t\t* @return \t\t\t\t\t\t `true` if the contract implements `interfaceID` and `interfaceID` is not 0xffffffff, `false` otherwise\r\n\t\t*/\r\n\t\tfunction supportsInterface( bytes4 interfaceID_ ) public pure override returns ( bool ) {\r\n\t\t\treturn interfaceID_ == type( IERC165 ).interfaceId ||\r\n\t\t\t\t\t\t interfaceID_ == type( IERC173 ).interfaceId ||\r\n\t\t\t\t\t\t interfaceID_ == type( IERC1155 ).interfaceId ||\r\n\t\t\t\t\t\t interfaceID_ == type( IERC1155MetadataURI ).interfaceId ||\r\n\t\t\t\t\t\t interfaceID_ == type( IERC2981 ).interfaceId;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Returns the URI for token type `id`.\r\n\t\t*\r\n\t\t* If the `\\{id\\}` substring is present in the URI, it must be replaced by\r\n\t\t* clients with the actual token type ID.\r\n\t\t*/\r\n\t\tfunction uri( uint256 id_ ) external view isValidSeries( id_ ) returns ( string memory ) {\r\n\t\t\treturn bytes( _uri ).length > 0 ? string( abi.encodePacked( _uri, _toString( id_ ) ) ) : _toString( id_ );\r\n\t\t}\r\n\t// **************************************\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ARRAY_LENGTH_MISMATCH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"currentState\",\"type\":\"uint8\"}],\"name\":\"ContractState_INCORRECT_STATE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"invalidState\",\"type\":\"uint8\"}],\"name\":\"ContractState_INVALID_STATE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountExpected\",\"type\":\"uint256\"}],\"name\":\"ETHER_INCORRECT_PRICE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ETHER_NO_BALANCE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ETHER_TRANSFER_FAIL\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"IERC1155_CALLER_NOT_APPROVED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"IERC1155_EXISTANT_TOKEN\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"IERC1155_INSUFFICIENT_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC1155_INVALID_CALLER_APPROVAL\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC1155_INVALID_TRANSFER\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"IERC1155_NON_ERC1155_RECEIVER\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"IERC1155_NON_EXISTANT_TOKEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC1155_REJECTED_TRANSFER\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"IERC173_NOT_OWNER\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"royaltyRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltyBase\",\"type\":\"uint256\"}],\"name\":\"IERC2981_INVALID_ROYALTIES\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"JT_INSUFFICIENT_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFT_INVALID_QTY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NFT_INVALID_SUPPLY\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"qtyRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBatch\",\"type\":\"uint256\"}],\"name\":\"NFT_MAX_BATCH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"qtyRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveLeft\",\"type\":\"uint256\"}],\"name\":\"NFT_MAX_RESERVE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"qtyRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingSupply\",\"type\":\"uint256\"}],\"name\":\"NFT_MAX_SUPPLY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Whitelist_CONSUMED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Whitelist_FORBIDDEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Whitelist_NOT_SET\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"previousState\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"ContractStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_OPERATOR_FILTER_REGISTRY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_PASS_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_SUBSCRIPTION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OS_PROXY_REGISTRY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSED\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxyRegistryAddress_\",\"type\":\"address\"}],\"name\":\"addProxyRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids_\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"whitelistId_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"alloted_\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Whitelist_ECDSA.Proof\",\"name\":\"proof_\",\"type\":\"tuple\"}],\"name\":\"checkWhitelistAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicSalePrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"privateSalePrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve_\",\"type\":\"uint256\"}],\"name\":\"createSeries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractState\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxSupplies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty_\",\"type\":\"uint256\"}],\"name\":\"mintPublic\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty_\",\"type\":\"uint256\"}],\"name\":\"mintPublicOrWhitelist\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"alloted_\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Whitelist_ECDSA.Proof\",\"name\":\"proof_\",\"type\":\"tuple\"}],\"name\":\"mintWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorFilterRegistry\",\"outputs\":[{\"internalType\":\"contract IOperatorFilterRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"privateSalePrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proxyRegistries\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"publicSalePrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remainingSupplies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxyRegistryAddress_\",\"type\":\"address\"}],\"name\":\"removeProxyRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice_\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved_\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newState_\",\"type\":\"uint8\"}],\"name\":\"setContractState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"royaltyRecipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyRate_\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminSigner_\",\"type\":\"address\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID_\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRegistry\",\"type\":\"address\"}],\"name\":\"updateOperatorFilterRegistryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicSalePrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"privateSalePrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve_\",\"type\":\"uint256\"}],\"name\":\"updateSeries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "JuiceTeam", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "8888", "ConstructorArguments": "00000000000000000000000052957c8534b48a5debd9e9524a830c424ad0fe7f", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4494c103c2db2ad370de402077fe7598e5c44596f5b5583dfa83bcf6826272cb"}