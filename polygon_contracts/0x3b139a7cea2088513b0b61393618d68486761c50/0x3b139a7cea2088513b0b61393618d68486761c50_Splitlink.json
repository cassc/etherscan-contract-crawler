{"SourceCode": "/**\r\n *Submitted for verification at polygonscan.com on 2023-02-20\r\n*/\r\n\r\n/**\r\n *Submitted for verification at polygonscan.com on 2023-02-19\r\n*/\r\n\r\n/**\r\n *Submitted for verification at polygonscan.com on 2022-11-17\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function name() external view returns (string memory);\r\n\r\n  function getOwner() external view returns (address);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Splitlink {\r\n    using SafeMath for uint256; \r\n    IERC20 public Dai;\r\n    uint256 private constant baseDivider = 10000;\r\n    uint256 private constant feePercents = 9000; \r\n    uint256 private constant minDeposit = 50e18;\r\n    uint256 private constant maxDeposit = 2000e18;\r\n    uint256 private constant freezeIncomePercents = 3000;\r\n    uint256 private constant timeStep = 1 days;\r\n    uint256 private constant dayPerCycle = 15 days; \r\n    uint256 private constant dayRewardPercents = 150;\r\n    uint256 private constant maxAddFreeze = 35 days;\r\n    uint256 private constant referDepth = 20;\r\n\r\n    uint256 private constant directPercents = 500;\r\n    uint256[4] private level4Percents = [100, 200, 300, 100];\r\n    uint256[15] private level5Percents = [50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50];\r\n\r\n    uint256[7] private balDown = [10e22, 30e22, 100e22, 500e22, 1000e22,1500e22,2000e22];\r\n    uint256[7] private balDownRate = [1000, 1500, 2000, 5000, 6000,7000,8000]; \r\n    uint256[7] private balRecover = [15e22, 50e22, 150e22, 500e22, 1000e22,1500e22, 2000e22];\r\n    mapping(uint256=>bool) public balStatus; // bal=>status\r\n\r\n    address[4] public feeReceivers;\r\n\r\n    address public defaultRefer;\r\n    uint256 public startTime;\r\n    uint256 public lastDistribute;\r\n    uint256 public totalUser; \r\n\r\n    address public receivers;\r\n\r\n    address[] public level4Users;\r\n\r\n    struct OrderInfo {\r\n        uint256 amount; \r\n        uint256 start;\r\n        uint256 unfreeze; \r\n        bool isUnfreezed;\r\n    }\r\n\r\n    mapping(address => OrderInfo[]) public orderInfos;\r\n\r\n    address[] public depositors;\r\n\r\n    struct UserInfo {\r\n        address referrer;\r\n        uint256 start;\r\n        uint256 level; // 0, 1, 2, 3, 4, 5\r\n        uint256 maxDeposit;\r\n        uint256 totalDeposit;\r\n        uint256 teamNum;\r\n        uint256 maxDirectDeposit;\r\n        uint256 teamTotalDeposit;\r\n        uint256 totalFreezed;\r\n        uint256 totalRevenue;\r\n    }\r\n\r\n    mapping(address=>UserInfo) public userInfo;\r\n    mapping(uint256 => mapping(address => uint256)) public userLayer1DayDeposit; // day=>user=>amount\r\n    mapping(address => mapping(uint256 => address[])) public teamUsers;\r\n\r\n    struct RewardInfo{\r\n        uint256 capitals;\r\n        uint256 statics;\r\n        uint256 directs;\r\n        uint256 level4Freezed;\r\n        uint256 level4Released;\r\n        uint256 level5Left;\r\n        uint256 level5Freezed;\r\n        uint256 level5Released;\r\n\r\n        uint256 split;\r\n        uint256 splitDebt;\r\n    }\r\n\r\n    mapping(address=>RewardInfo) public rewardInfo;\r\n    \r\n    bool public isFreezeReward;\r\n\r\n    event Register(address user, address referral);\r\n    event Deposit(address user, uint256 amount);\r\n    event DepositBySplit(address user, uint256 amount);\r\n    event TransferBySplit(address user, address receiver, uint256 amount);\r\n    event Withdraw(address user, uint256 withdrawable);\r\n\r\n    constructor(address _usdtAddr, address _defaultRefer)   {\r\n        Dai = IERC20(_usdtAddr);\r\n       \r\n        feeReceivers[0] = address(0xab11ee55Dc0c05E3f9D9fa9A507cdB752aB90865);\r\n       \r\n        startTime = block.timestamp;\r\n        lastDistribute = block.timestamp;\r\n        defaultRefer = _defaultRefer;\r\n        receivers = _defaultRefer;\r\n    }\r\n\r\n    function register(address _referral) external {\r\n        require(userInfo[_referral].totalDeposit > 0 || _referral == defaultRefer, \"invalid refer\");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.referrer == address(0), \"referrer bonded\");\r\n        user.referrer = _referral;\r\n        user.start = block.timestamp;\r\n        _updateTeamNum(msg.sender);\r\n        totalUser = totalUser.add(1);\r\n        emit Register(msg.sender, _referral);\r\n    }\r\n\r\n    function deposit(uint256 _amount) external {\r\n        Dai.transferFrom(msg.sender, address(this), _amount);\r\n         _distributeDeposit(_amount);\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    function withdrawal(uint256 _amount, address _address) external {\r\n        Dai.transferFrom(msg.sender, address(this), _amount);\r\n         _distributeWithdrawal(_amount, _address);\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    function depositBySplit(uint256 _amount) external {\r\n        require(_amount >= minDeposit && _amount.mod(minDeposit) == 0, \"amount err\");\r\n        require(userInfo[msg.sender].totalDeposit == 0, \"actived\");\r\n        uint256 splitLeft = getCurSplit(msg.sender);\r\n        require(splitLeft >= _amount, \"insufficient split\");\r\n        rewardInfo[msg.sender].splitDebt = rewardInfo[msg.sender].splitDebt.add(_amount);\r\n        _deposit(msg.sender, _amount);\r\n        emit DepositBySplit(msg.sender, _amount);\r\n    }\r\n\r\n    function transferBySplit(address _receiver, uint256 _amount) external {\r\n        require(_amount >= minDeposit && _amount.mod(minDeposit) == 0, \"amount err\");\r\n        uint256 splitLeft = getCurSplit(msg.sender);\r\n        require(splitLeft >= _amount, \"insufficient income\");\r\n        rewardInfo[msg.sender].splitDebt = rewardInfo[msg.sender].splitDebt.add(_amount);\r\n        rewardInfo[_receiver].split = rewardInfo[_receiver].split.add(_amount);\r\n        emit TransferBySplit(msg.sender, _receiver, _amount);\r\n    }\r\n\r\n    function withdraw() external {\r\n        // distributePoolRewards();\r\n        (uint256 staticReward, uint256 staticSplit) = _calCurStaticRewards(msg.sender);\r\n        uint256 splitAmt = staticSplit;\r\n        uint256 withdrawable = staticReward;\r\n\r\n        (uint256 dynamicReward, uint256 dynamicSplit) = _calCurDynamicRewards(msg.sender);\r\n        withdrawable = withdrawable.add(dynamicReward);\r\n        splitAmt = splitAmt.add(dynamicSplit);\r\n\r\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n        userRewards.split = userRewards.split.add(splitAmt);\r\n\r\n        userRewards.statics = 0;\r\n\r\n        userRewards.directs = 0;\r\n        userRewards.level4Released = 0;\r\n        userRewards.level5Released = 0;\r\n        \r\n        withdrawable = withdrawable.add(userRewards.capitals);\r\n        userRewards.capitals = 0;\r\n        \r\n        Dai.transfer(msg.sender, withdrawable);\r\n        uint256 bal = Dai.balanceOf(address(this));\r\n        _setFreezeReward(bal);\r\n\r\n        emit Withdraw(msg.sender, withdrawable);\r\n    }\r\n\r\n    function getCurDay() public view returns(uint256) {\r\n        return (block.timestamp.sub(startTime)).div(timeStep);\r\n    }\r\n\r\n\r\n    function getTeamUsersLength(address _user, uint256 _layer) external view returns(uint256) {\r\n        return teamUsers[_user][_layer].length;\r\n    }\r\n\r\n    function getOrderLength(address _user) external view returns(uint256) {\r\n        return orderInfos[_user].length;\r\n    }\r\n\r\n    function getDepositorsLength() external view returns(uint256) {\r\n        return depositors.length;\r\n    }\r\n\r\n    function getMaxFreezing(address _user) public view returns(uint256) {\r\n        uint256 maxFreezing;\r\n        for(uint256 i = orderInfos[_user].length; i > 0; i--){\r\n            OrderInfo storage order = orderInfos[_user][i - 1];\r\n            if(order.unfreeze > block.timestamp){\r\n                if(order.amount > maxFreezing){\r\n                    maxFreezing = order.amount;\r\n                }\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n        return maxFreezing;\r\n    }\r\n\r\n    function getTeamDeposit(address _user) public view returns(uint256, uint256, uint256){\r\n        uint256 totalTeam;\r\n        uint256 maxTeam;\r\n        uint256 otherTeam;\r\n        for(uint256 i = 0; i < teamUsers[_user][0].length; i++){\r\n            uint256 userTotalTeam = userInfo[teamUsers[_user][0][i]].teamTotalDeposit.add(userInfo[teamUsers[_user][0][i]].totalDeposit);\r\n            totalTeam = totalTeam.add(userTotalTeam);\r\n            if(userTotalTeam > maxTeam){\r\n                maxTeam = userTotalTeam;\r\n            }\r\n        }\r\n        otherTeam = totalTeam.sub(maxTeam);\r\n        return(maxTeam, otherTeam, totalTeam);\r\n    }\r\n\r\n    function getCurSplit(address _user) public view returns(uint256){\r\n        (, uint256 staticSplit) = _calCurStaticRewards(_user);\r\n        (, uint256 dynamicSplit) = _calCurDynamicRewards(_user);\r\n        return rewardInfo[_user].split.add(staticSplit).add(dynamicSplit).sub(rewardInfo[_user].splitDebt);\r\n    }\r\n\r\n    function _calCurStaticRewards(address _user) private view returns(uint256, uint256) {\r\n        RewardInfo storage userRewards = rewardInfo[_user];\r\n        uint256 totalRewards = userRewards.statics;\r\n        uint256 splitAmt = totalRewards.mul(freezeIncomePercents).div(baseDivider);\r\n        uint256 withdrawable = totalRewards.sub(splitAmt);\r\n        return(withdrawable, splitAmt);\r\n    }\r\n\r\n    function _calCurDynamicRewards(address _user) private view returns(uint256, uint256) {\r\n        RewardInfo storage userRewards = rewardInfo[_user];\r\n        uint256 totalRewards = userRewards.directs.add(userRewards.level4Released).add(userRewards.level5Released);\r\n        totalRewards = totalRewards;\r\n        uint256 splitAmt = totalRewards.mul(freezeIncomePercents).div(baseDivider);\r\n        uint256 withdrawable = totalRewards.sub(splitAmt);\r\n        return(withdrawable, splitAmt);\r\n    }\r\n\r\n    function _updateTeamNum(address _user) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].teamNum = userInfo[upline].teamNum.add(1);\r\n                teamUsers[upline][i].push(_user);\r\n                _updateLevel(upline);\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function _removeInvalidDeposit(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                if(userInfo[upline].teamTotalDeposit > _amount){\r\n                    userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.sub(_amount);\r\n                }else{\r\n                    userInfo[upline].teamTotalDeposit = 0;\r\n                }\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateReferInfo(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.add(_amount);\r\n                _updateLevel(upline);\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateLevel(address _user) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 levelNow = _calLevelNow(_user);\r\n        if(levelNow > user.level){\r\n            user.level = levelNow;\r\n            if(levelNow == 4){\r\n                level4Users.push(_user);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _calLevelNow(address _user) private view returns(uint256) {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 total = user.totalDeposit;\r\n        uint256 levelNow;\r\n        if(total >= 1000e18){\r\n            (uint256 maxTeam, uint256 otherTeam, ) = getTeamDeposit(_user);\r\n            if(total >= 2000e18 && user.teamNum >= 160 && maxTeam >= 50000e18 && otherTeam >= 50000e18){\r\n                levelNow = 5;\r\n            }else if(user.teamNum >= 40 && maxTeam >= 10000e18 && otherTeam >= 10000e18){\r\n                levelNow = 4;\r\n            }else{\r\n                levelNow = 3;\r\n            }\r\n        }else if(total >= 500e18){\r\n            levelNow = 2;\r\n        }else if(total >= 50e18){\r\n            levelNow = 1;\r\n        }\r\n\r\n        return levelNow;\r\n    }\r\n\r\n    function _deposit(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        require(user.referrer != address(0), \"register first\");\r\n        require(_amount >= minDeposit, \"less than min\");\r\n        require(_amount.mod(minDeposit) == 0 && _amount >= minDeposit, \"mod err\");\r\n        require(user.maxDeposit == 0 || _amount >= user.maxDeposit, \"less before\");\r\n\r\n        if(user.maxDeposit == 0){\r\n            user.maxDeposit = _amount;\r\n        }else if(user.maxDeposit < _amount){\r\n            user.maxDeposit = _amount;\r\n        }\r\n\r\n        _distributeDeposit(_amount);\r\n\r\n\r\n        depositors.push(_user);\r\n        \r\n        user.totalDeposit = user.totalDeposit.add(_amount);\r\n        user.totalFreezed = user.totalFreezed.add(_amount);\r\n\r\n        _updateLevel(msg.sender);\r\n\r\n        uint256 addFreeze = (orderInfos[_user].length.div(2)).mul(timeStep);\r\n        if(addFreeze > maxAddFreeze){\r\n            addFreeze = maxAddFreeze;\r\n        }\r\n        uint256 unfreezeTime = block.timestamp.add(dayPerCycle).add(addFreeze);\r\n        orderInfos[_user].push(OrderInfo(\r\n            _amount, \r\n            block.timestamp, \r\n            unfreezeTime,\r\n            false\r\n        ));\r\n\r\n        _unfreezeFundAndUpdateReward(msg.sender, _amount);\r\n\r\n\r\n        _updateReferInfo(msg.sender, _amount);\r\n\r\n        _updateReward(msg.sender, _amount);\r\n\r\n        _releaseUpRewards(msg.sender, _amount);\r\n\r\n        uint256 bal = Dai.balanceOf(address(this));\r\n        _balActived(bal);\r\n        if(isFreezeReward){\r\n            _setFreezeReward(bal);\r\n        }\r\n    }\r\n\r\n    function _unfreezeFundAndUpdateReward(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        bool isUnfreezeCapital;\r\n        for(uint256 i = 0; i < orderInfos[_user].length; i++){\r\n            OrderInfo storage order = orderInfos[_user][i];\r\n            if(block.timestamp > order.unfreeze  && order.isUnfreezed == false && _amount >= order.amount){\r\n                order.isUnfreezed = true;\r\n                isUnfreezeCapital = true;\r\n                \r\n                if(user.totalFreezed > order.amount){\r\n                    user.totalFreezed = user.totalFreezed.sub(order.amount);\r\n                }else{\r\n                    user.totalFreezed = 0;\r\n                }\r\n                \r\n                _removeInvalidDeposit(_user, order.amount);\r\n\r\n                uint256 staticReward = order.amount.mul(dayRewardPercents).mul(dayPerCycle).div(timeStep).div(baseDivider);\r\n                if(isFreezeReward){\r\n                    if(user.totalFreezed > user.totalRevenue){\r\n                        uint256 leftCapital = user.totalFreezed.sub(user.totalRevenue);\r\n                        if(staticReward > leftCapital){\r\n                            staticReward = leftCapital;\r\n                        }\r\n                    }else{\r\n                        staticReward = 0;\r\n                    }\r\n                }\r\n                rewardInfo[_user].capitals = rewardInfo[_user].capitals.add(order.amount);\r\n\r\n                rewardInfo[_user].statics = rewardInfo[_user].statics.add(staticReward);\r\n                \r\n                user.totalRevenue = user.totalRevenue.add(staticReward);\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(!isUnfreezeCapital){ \r\n            RewardInfo storage userReward = rewardInfo[_user];\r\n            if(userReward.level5Freezed > 0){\r\n                uint256 release = _amount;\r\n                if(_amount >= userReward.level5Freezed){\r\n                    release = userReward.level5Freezed;\r\n                }\r\n                userReward.level5Freezed = userReward.level5Freezed.sub(release);\r\n                userReward.level5Released = userReward.level5Released.add(release);\r\n                user.totalRevenue = user.totalRevenue.add(release);\r\n            }\r\n        }\r\n    }\r\n\r\n \r\n\r\n    function _distributeDeposit(uint256 _amount) private {\r\n        //uint256 fee = _amount.mul(feePercents).div(baseDivider);\r\n        Dai.transfer(feeReceivers[0], _amount);\r\n    }\r\n\r\n    function _distributeWithdrawal(uint256 _amount, address _address) private {\r\n        //uint256 fee = _amount.mul(feePercents).div(baseDivider);\r\n        Dai.transfer(_address, _amount);\r\n    }\r\n\r\n    function _updateReward(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                uint256 newAmount = _amount;\r\n                if(upline != defaultRefer){\r\n                    uint256 maxFreezing = getMaxFreezing(upline);\r\n                    if(maxFreezing < _amount){\r\n                        newAmount = maxFreezing;\r\n                    }\r\n                }\r\n                RewardInfo storage upRewards = rewardInfo[upline];\r\n                uint256 reward;\r\n                if(i > 4){\r\n                    if(userInfo[upline].level > 4){\r\n                        reward = newAmount.mul(level5Percents[i - 5]).div(baseDivider);\r\n                        upRewards.level5Freezed = upRewards.level5Freezed.add(reward);\r\n                    }\r\n                }else if(i > 0){\r\n                    if( userInfo[upline].level > 3){\r\n                        reward = newAmount.mul(level4Percents[i - 1]).div(baseDivider);\r\n                        upRewards.level4Freezed = upRewards.level4Freezed.add(reward);\r\n                    }\r\n                }else{\r\n                    reward = newAmount.mul(directPercents).div(baseDivider);\r\n                    upRewards.directs = upRewards.directs.add(reward);\r\n                    userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                }\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _releaseUpRewards(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                uint256 newAmount = _amount;\r\n                if(upline != defaultRefer){\r\n                    uint256 maxFreezing = getMaxFreezing(upline);\r\n                    if(maxFreezing < _amount){\r\n                        newAmount = maxFreezing;\r\n                    }\r\n                }\r\n\r\n                RewardInfo storage upRewards = rewardInfo[upline];\r\n                if(i > 0 && i < 5 && userInfo[upline].level > 3){\r\n                    if(upRewards.level4Freezed > 0){\r\n                        uint256 level4Reward = newAmount.mul(level4Percents[i - 1]).div(baseDivider);\r\n                        if(level4Reward > upRewards.level4Freezed){\r\n                            level4Reward = upRewards.level4Freezed;\r\n                        }\r\n                        upRewards.level4Freezed = upRewards.level4Freezed.sub(level4Reward); \r\n                        upRewards.level4Released = upRewards.level4Released.add(level4Reward);\r\n                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(level4Reward);\r\n                    }\r\n                }\r\n\r\n                if(i >= 5 && userInfo[upline].level > 4){\r\n                    if(upRewards.level5Left > 0){\r\n                        uint256 level5Reward = newAmount.mul(level5Percents[i - 5]).div(baseDivider);\r\n                        if(level5Reward > upRewards.level5Left){\r\n                            level5Reward = upRewards.level5Left;\r\n                        }\r\n                        upRewards.level5Left = upRewards.level5Left.sub(level5Reward); \r\n                        upRewards.level5Freezed = upRewards.level5Freezed.add(level5Reward);\r\n                    }\r\n                }\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _balActived(uint256 _bal) private {\r\n        for(uint256 i = balDown.length; i > 0; i--){\r\n            if(_bal >= balDown[i - 1]){\r\n                balStatus[balDown[i - 1]] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _setFreezeReward(uint256 _bal) private {\r\n        for(uint256 i = balDown.length; i > 0; i--){\r\n            if(balStatus[balDown[i - 1]]){\r\n                uint256 maxDown = balDown[i - 1].mul(balDownRate[i - 1]).div(baseDivider);\r\n                if(_bal < balDown[i - 1].sub(maxDown)){\r\n                    isFreezeReward = true;\r\n                }else if(isFreezeReward && _bal >= balRecover[i - 1]){\r\n                    isFreezeReward = false;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultRefer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Dai\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRefer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeReceivers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getCurSplit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositorsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMaxFreezing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFreezeReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"level4Users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receivers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"capitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level4Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level4Released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level5Left\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level5Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level5Released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDirectDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLayer1DayDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"withdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Splitlink", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000008f3cf7ad23cd3cadbd9735aff958023239c6a063000000000000000000000000b051821a4aacfc0f6046df5d957911714bb7621f", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://75e70bcba1d37a6cd9a40bb93dd39b9646c791d439994a098a564b8f0a173aca"}