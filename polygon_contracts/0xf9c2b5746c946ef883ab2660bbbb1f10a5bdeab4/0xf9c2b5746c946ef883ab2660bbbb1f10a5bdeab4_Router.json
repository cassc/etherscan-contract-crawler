{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/periphery/Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\npragma abicoder v2;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {TickMath} from '../libraries/TickMath.sol';\\nimport {SafeCast} from '../libraries/SafeCast.sol';\\nimport {PathHelper} from './libraries/PathHelper.sol';\\nimport {PoolAddress} from './libraries/PoolAddress.sol';\\n\\nimport {IPool} from '../interfaces/IPool.sol';\\nimport {IFactory} from '../interfaces/IFactory.sol';\\nimport {IRouter} from '../interfaces/periphery/IRouter.sol';\\nimport {IWETH} from '../interfaces/IWETH.sol';\\n\\nimport {DeadlineValidation} from './base/DeadlineValidation.sol';\\nimport {Multicall} from './base/Multicall.sol';\\nimport {RouterTokenHelperWithFee} from './base/RouterTokenHelperWithFee.sol';\\n\\n/// @title KyberSwap V2 Swap Router\\ncontract Router is IRouter, RouterTokenHelperWithFee, Multicall, DeadlineValidation {\\n  using PathHelper for bytes;\\n  using SafeCast for uint256;\\n\\n  /// @dev Use as the placeholder value for amountInCached\\n  uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\\n\\n  /// @dev Use to cache the computed amount in for an exact output swap.\\n  uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n\\n  constructor(address _factory, address _WETH) RouterTokenHelperWithFee(_factory, _WETH) {}\\n\\n  struct SwapCallbackData {\\n    bytes path;\\n    address source;\\n  }\\n\\n  function swapCallback(\\n    int256 deltaQty0,\\n    int256 deltaQty1,\\n    bytes calldata data\\n  ) external override {\\n    require(deltaQty0 > 0 || deltaQty1 > 0, 'Router: invalid delta qties');\\n    SwapCallbackData memory swapData = abi.decode(data, (SwapCallbackData));\\n    (address tokenIn, address tokenOut, uint24 fee) = swapData.path.decodeFirstPool();\\n    require(\\n      msg.sender == address(_getPool(tokenIn, tokenOut, fee)),\\n      'Router: invalid callback sender'\\n    );\\n\\n    (bool isExactInput, uint256 amountToTransfer) = deltaQty0 > 0\\n      ? (tokenIn < tokenOut, uint256(deltaQty0))\\n      : (tokenOut < tokenIn, uint256(deltaQty1));\\n    if (isExactInput) {\\n      // transfer token from source to the pool which is the msg.sender\\n      // wrap eth -> weth and transfer if needed\\n      _transferTokens(tokenIn, swapData.source, msg.sender, amountToTransfer);\\n    } else {\\n      if (swapData.path.hasMultiplePools()) {\\n        swapData.path = swapData.path.skipToken();\\n        _swapExactOutputInternal(amountToTransfer, msg.sender, 0, swapData);\\n      } else {\\n        amountInCached = amountToTransfer;\\n        // transfer tokenOut to the pool (it's the original tokenIn)\\n        // wrap eth -> weth and transfer if user uses passes eth with the swap\\n        _transferTokens(tokenOut, swapData.source, msg.sender, amountToTransfer);\\n      }\\n    }\\n  }\\n\\n  function swapExactInputSingle(ExactInputSingleParams calldata params)\\n    external\\n    payable\\n    override\\n    onlyNotExpired(params.deadline)\\n    returns (uint256 amountOut)\\n  {\\n    amountOut = _swapExactInputInternal(\\n      params.amountIn,\\n      params.recipient,\\n      params.limitSqrtP,\\n      SwapCallbackData({\\n        path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut),\\n        source: msg.sender\\n      })\\n    );\\n    require(amountOut >= params.minAmountOut, 'Router: insufficient amountOut');\\n  }\\n\\n  function swapExactInput(ExactInputParams memory params)\\n    external\\n    payable\\n    override\\n    onlyNotExpired(params.deadline)\\n    returns (uint256 amountOut)\\n  {\\n    address source = msg.sender; // msg.sender is the source of tokenIn for the first swap\\n\\n    while (true) {\\n      bool hasMultiplePools = params.path.hasMultiplePools();\\n\\n      params.amountIn = _swapExactInputInternal(\\n        params.amountIn,\\n        hasMultiplePools ? address(this) : params.recipient, // for intermediate swaps, this contract custodies\\n        0,\\n        SwapCallbackData({path: params.path.getFirstPool(), source: source})\\n      );\\n\\n      if (hasMultiplePools) {\\n        source = address(this);\\n        params.path = params.path.skipToken();\\n      } else {\\n        amountOut = params.amountIn;\\n        break;\\n      }\\n    }\\n\\n    require(amountOut >= params.minAmountOut, 'Router: insufficient amountOut');\\n  }\\n\\n  function swapExactOutputSingle(ExactOutputSingleParams calldata params)\\n    external\\n    payable\\n    override\\n    onlyNotExpired(params.deadline)\\n    returns (uint256 amountIn)\\n  {\\n    amountIn = _swapExactOutputInternal(\\n      params.amountOut,\\n      params.recipient,\\n      params.limitSqrtP,\\n      SwapCallbackData({\\n        path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn),\\n        source: msg.sender\\n      })\\n    );\\n    require(amountIn <= params.maxAmountIn, 'Router: amountIn is too high');\\n    // has to be reset even though we don't use it in the single hop case\\n    amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n  }\\n\\n  function swapExactOutput(ExactOutputParams calldata params)\\n    external\\n    payable\\n    override\\n    onlyNotExpired(params.deadline)\\n    returns (uint256 amountIn)\\n  {\\n    _swapExactOutputInternal(\\n      params.amountOut,\\n      params.recipient,\\n      0,\\n      SwapCallbackData({path: params.path, source: msg.sender})\\n    );\\n\\n    amountIn = amountInCached;\\n    require(amountIn <= params.maxAmountIn, 'Router: amountIn is too high');\\n    amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n  }\\n\\n  /// @dev Performs a single exact input swap\\n  function _swapExactInputInternal(\\n    uint256 amountIn,\\n    address recipient,\\n    uint160 limitSqrtP,\\n    SwapCallbackData memory data\\n  ) private returns (uint256 amountOut) {\\n    // allow swapping to the router address with address 0\\n    if (recipient == address(0)) recipient = address(this);\\n\\n    (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\\n\\n    bool isFromToken0 = tokenIn < tokenOut;\\n\\n    (int256 amount0, int256 amount1) = _getPool(tokenIn, tokenOut, fee).swap(\\n      recipient,\\n      amountIn.toInt256(),\\n      isFromToken0,\\n      limitSqrtP == 0\\n        ? (isFromToken0 ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\\n        : limitSqrtP,\\n      abi.encode(data)\\n    );\\n    return uint256(-(isFromToken0 ? amount1 : amount0));\\n  }\\n\\n  /// @dev Perform a swap exact amount out using callback\\n  function _swapExactOutputInternal(\\n    uint256 amountOut,\\n    address recipient,\\n    uint160 limitSqrtP,\\n    SwapCallbackData memory data\\n  ) private returns (uint256 amountIn) {\\n    // consider address 0 as the router address\\n    if (recipient == address(0)) recipient = address(this);\\n\\n    (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\\n\\n    bool isFromToken0 = tokenOut < tokenIn;\\n\\n    (int256 amount0Delta, int256 amount1Delta) = _getPool(tokenIn, tokenOut, fee).swap(\\n      recipient,\\n      -amountOut.toInt256(),\\n      isFromToken0,\\n      limitSqrtP == 0\\n        ? (isFromToken0 ? TickMath.MAX_SQRT_RATIO - 1 : TickMath.MIN_SQRT_RATIO + 1)\\n        : limitSqrtP,\\n      abi.encode(data)\\n    );\\n\\n    uint256 receivedAmountOut;\\n    (amountIn, receivedAmountOut) = isFromToken0\\n      ? (uint256(amount1Delta), uint256(-amount0Delta))\\n      : (uint256(amount0Delta), uint256(-amount1Delta));\\n\\n    // if no price limit has been specified, \\breceivedAmountOut should be equals to amountOut\\n    assert(limitSqrtP != 0 || receivedAmountOut == amountOut);\\n  }\\n\\n  /// @dev Returns the pool address for the requested token pair swap fee\\n  ///   Because the function calculates it instead of fetching the address from the factory,\\n  ///   the returned pool address may not be in existence yet\\n  function _getPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 fee\\n  ) private view returns (IPool) {\\n    return IPool(PoolAddress.computeAddress(factory, tokenA, tokenB, fee, poolInitHash));\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TickMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n  int24 internal constant MIN_TICK = -887272;\\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n  int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n  uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n  uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n  /// @dev Throws if |tick| > max tick\\n  /// @param tick The input tick for the above formula\\n  /// @return sqrtP A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n  /// at the given tick\\n  function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtP) {\\n    unchecked {\\n      uint256 absTick = uint256(tick < 0 ? -int256(tick) : int256(tick));\\n      require(absTick <= uint256(int256(MAX_TICK)), 'T');\\n\\n      // do bitwise comparison, if i-th bit is turned on,\\n      // multiply ratio by hardcoded values of sqrt(1.0001^-(2^i)) * 2^128\\n      // where 0 <= i <= 19\\n      uint256 ratio = (absTick & 0x1 != 0)\\n        ? 0xfffcb933bd6fad37aa2d162d1a594001\\n        : 0x100000000000000000000000000000000;\\n      if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n      if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n      if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n      if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n      if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n      if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n      if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n      if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n      if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n      if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n      if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n      if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n      if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n      if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n      if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n      if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n      if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n      if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n      if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n      // take reciprocal for positive tick values\\n      if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n      // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n      // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n      // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n      sqrtP = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n  }\\n\\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n  /// @dev Throws in case sqrtP < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n  /// ever return.\\n  /// @param sqrtP The sqrt ratio for which to compute the tick as a Q64.96\\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n  function getTickAtSqrtRatio(uint160 sqrtP) internal pure returns (int24 tick) {\\n    // second inequality must be < because the price can never reach the price at the max tick\\n    require(sqrtP >= MIN_SQRT_RATIO && sqrtP < MAX_SQRT_RATIO, 'R');\\n    uint256 ratio = uint256(sqrtP) << 32;\\n\\n    uint256 r = ratio;\\n    uint256 msb = 0;\\n\\n    unchecked {\\n      assembly {\\n        let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(5, gt(r, 0xFFFFFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(4, gt(r, 0xFFFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(3, gt(r, 0xFF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(2, gt(r, 0xF))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := shl(1, gt(r, 0x3))\\n        msb := or(msb, f)\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        let f := gt(r, 0x1)\\n        msb := or(msb, f)\\n      }\\n\\n      if (msb >= 128) r = ratio >> (msb - 127);\\n      else r = ratio << (127 - msb);\\n\\n      int256 log_2 = (int256(msb) - 128) << 64;\\n\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(63, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(62, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(61, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(60, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(59, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(58, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(57, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(56, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(55, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(54, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(53, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(52, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(51, f))\\n        r := shr(f, r)\\n      }\\n      assembly {\\n        r := shr(127, mul(r, r))\\n        let f := shr(128, r)\\n        log_2 := or(log_2, shl(50, f))\\n      }\\n\\n      int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n      int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n      int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n      tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtP ? tickHi : tickLow;\\n    }\\n  }\\n\\n  function getMaxNumberTicks(int24 _tickDistance) internal pure returns (uint24 numTicks) {\\n    return uint24(TickMath.MAX_TICK / _tickDistance) * 2;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n  /// @notice Cast a uint256 to uint32, revert on overflow\\n  /// @param y The uint256 to be downcasted\\n  /// @return z The downcasted integer, now type uint32\\n  function toUint32(uint256 y) internal pure returns (uint32 z) {\\n    require((z = uint32(y)) == y);\\n  }\\n\\n  /// @notice Cast a uint128 to a int128, revert on overflow\\n  /// @param y The uint256 to be casted\\n  /// @return z The casted integer, now type int256\\n  function toInt128(uint128 y) internal pure returns (int128 z) {\\n    require(y < 2**127);\\n    z = int128(y);\\n  }\\n\\n  /// @notice Cast a uint256 to a uint128, revert on overflow\\n  /// @param y the uint256 to be downcasted\\n  /// @return z The downcasted integer, now type uint128\\n  function toUint128(uint256 y) internal pure returns (uint128 z) {\\n    require((z = uint128(y)) == y);\\n  }\\n\\n  /// @notice Cast a int128 to a uint128 and reverses the sign.\\n  /// @param y The int128 to be casted\\n  /// @return z = -y, now type uint128\\n  function revToUint128(int128 y) internal pure returns (uint128 z) {\\n    unchecked {\\n      return type(uint128).max - uint128(y) + 1;\\n    }\\n  }\\n\\n  /// @notice Cast a uint256 to a uint160, revert on overflow\\n  /// @param y The uint256 to be downcasted\\n  /// @return z The downcasted integer, now type uint160\\n  function toUint160(uint256 y) internal pure returns (uint160 z) {\\n    require((z = uint160(y)) == y);\\n  }\\n\\n  /// @notice Cast a uint256 to a int256, revert on overflow\\n  /// @param y The uint256 to be casted\\n  /// @return z The casted integer, now type int256\\n  function toInt256(uint256 y) internal pure returns (int256 z) {\\n    require(y < 2**255);\\n    z = int256(y);\\n  }\\n\\n  /// @notice Cast a uint256 to a int256 and reverses the sign, revert on overflow\\n  /// @param y The uint256 to be casted\\n  /// @return z = -y, now type int256\\n  function revToInt256(uint256 y) internal pure returns (int256 z) {\\n    require(y < 2**255);\\n    z = -int256(y);\\n  }\\n\\n  /// @notice Cast a int256 to a uint256 and reverses the sign.\\n  /// @param y The int256 to be casted\\n  /// @return z = -y, now type uint256\\n  function revToUint256(int256 y) internal pure returns (uint256 z) {\\n    unchecked {\\n      return type(uint256).max - uint256(y) + 1;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/libraries/PathHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\n\\nimport './BytesLib.sol';\\n\\n/// @title Functions for manipulating path data for multihop swaps\\nlibrary PathHelper {\\n  using BytesLib for bytes;\\n\\n  /// @dev The length of the bytes encoded address\\n  uint256 private constant ADDR_SIZE = 20;\\n  /// @dev The length of the bytes encoded fee\\n  uint256 private constant FEE_SIZE = 3;\\n\\n  /// @dev The offset of a single token address and pool fee\\n  uint256 private constant TOKEN_AND_POOL_OFFSET = ADDR_SIZE + FEE_SIZE;\\n  /// @dev The offset of an encoded pool data\\n  uint256 private constant POOL_DATA_OFFSET = TOKEN_AND_POOL_OFFSET + ADDR_SIZE;\\n  /// @dev The minimum length of an encoding that contains 2 or more pools\\n  uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POOL_DATA_OFFSET + TOKEN_AND_POOL_OFFSET;\\n\\n  /// @notice Returns true iff the path contains two or more pools\\n  /// @param path The encoded swap path\\n  /// @return True if path contains two or more pools, otherwise false\\n  function hasMultiplePools(bytes memory path) internal pure returns (bool) {\\n    return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\\n  }\\n\\n  /// @notice Returns the number of pools in the path\\n  /// @param path The encoded swap path\\n  /// @return The number of pools in the path\\n  function numPools(bytes memory path) internal pure returns (uint256) {\\n    // Ignore the first token address. From then on every fee and token offset indicates a pool.\\n    return ((path.length - ADDR_SIZE) / TOKEN_AND_POOL_OFFSET);\\n  }\\n\\n  /// @notice Decodes the first pool in path\\n  /// @param path The bytes encoded swap path\\n  /// @return tokenA The first token of the given pool\\n  /// @return tokenB The second token of the given pool\\n  /// @return fee The fee level of the pool\\n  function decodeFirstPool(bytes memory path)\\n    internal\\n    pure\\n    returns (\\n      address tokenA,\\n      address tokenB,\\n      uint24 fee\\n    )\\n  {\\n    tokenA = path.toAddress(0);\\n    fee = path.toUint24(ADDR_SIZE);\\n    tokenB = path.toAddress(TOKEN_AND_POOL_OFFSET);\\n  }\\n\\n  /// @notice Gets the segment corresponding to the first pool in the path\\n  /// @param path The bytes encoded swap path\\n  /// @return The segment containing all data necessary to target the first pool in the path\\n  function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\\n    return path.slice(0, POOL_DATA_OFFSET);\\n  }\\n\\n  /// @notice Skips a token + fee element from the buffer and returns the remainder\\n  /// @param path The swap path\\n  /// @return The remaining token + fee elements in the path\\n  function skipToken(bytes memory path) internal pure returns (bytes memory) {\\n    return path.slice(TOKEN_AND_POOL_OFFSET, path.length - TOKEN_AND_POOL_OFFSET);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/libraries/PoolAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\n\\n/// @title Provides a function for deriving a pool address from the factory, tokens, and swap fee\\nlibrary PoolAddress {\\n  /// @notice Deterministically computes the pool address from the given data\\n  /// @param factory the factory address\\n  /// @param token0 One of the tokens constituting the token pair, regardless of order\\n  /// @param token1 The other token constituting the token pair, regardless of order\\n  /// @param swapFee Fee to be collected upon every swap in the pool, in fee units\\n  /// @param poolInitHash The keccak256 hash of the Pool creation code\\n  /// @return pool the pool address\\n  function computeAddress(\\n    address factory,\\n    address token0,\\n    address token1,\\n    uint24 swapFee,\\n    bytes32 poolInitHash\\n  ) internal pure returns (address pool) {\\n    (token0, token1) = token0 < token1 ? (token0, token1) : (token1, token0);\\n    bytes32 hashed = keccak256(\\n      abi.encodePacked(\\n        hex'ff',\\n        factory,\\n        keccak256(abi.encode(token0, token1, swapFee)),\\n        poolInitHash\\n      )\\n    );\\n    pool = address(uint160(uint256(hashed)));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IPoolActions} from './pool/IPoolActions.sol';\\nimport {IPoolEvents} from './pool/IPoolEvents.sol';\\nimport {IPoolStorage} from './pool/IPoolStorage.sol';\\n\\ninterface IPool is IPoolActions, IPoolEvents, IPoolStorage {}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @title KyberSwap v2 factory\\n/// @notice Deploys KyberSwap v2 pools and manages control over government fees\\ninterface IFactory {\\n  /// @notice Emitted when a pool is created\\n  /// @param token0 First pool token by address sort order\\n  /// @param token1 Second pool token by address sort order\\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\n  /// @param tickDistance Minimum number of ticks between initialized ticks\\n  /// @param pool The address of the created pool\\n  event PoolCreated(\\n    address indexed token0,\\n    address indexed token1,\\n    uint24 indexed swapFeeUnits,\\n    int24 tickDistance,\\n    address pool\\n  );\\n\\n  /// @notice Emitted when a new fee is enabled for pool creation via the factory\\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\n  /// @param tickDistance Minimum number of ticks between initialized ticks for pools created with the given fee\\n  event SwapFeeEnabled(uint24 indexed swapFeeUnits, int24 indexed tickDistance);\\n\\n  /// @notice Emitted when vesting period changes\\n  /// @param vestingPeriod The maximum time duration for which LP fees\\n  /// are proportionally burnt upon LP removals\\n  event VestingPeriodUpdated(uint32 vestingPeriod);\\n\\n  /// @notice Emitted when configMaster changes\\n  /// @param oldConfigMaster configMaster before the update\\n  /// @param newConfigMaster configMaster after the update\\n  event ConfigMasterUpdated(address oldConfigMaster, address newConfigMaster);\\n\\n  /// @notice Emitted when fee configuration changes\\n  /// @param feeTo Recipient of government fees\\n  /// @param governmentFeeUnits Fee amount, in fee units,\\n  /// to be collected out of the fee charged for a pool swap\\n  event FeeConfigurationUpdated(address feeTo, uint24 governmentFeeUnits);\\n\\n  /// @notice Emitted when whitelist feature is enabled\\n  event WhitelistEnabled();\\n\\n  /// @notice Emitted when whitelist feature is disabled\\n  event WhitelistDisabled();\\n\\n  /// @notice Returns the maximum time duration for which LP fees\\n  /// are proportionally burnt upon LP removals\\n  function vestingPeriod() external view returns (uint32);\\n\\n  /// @notice Returns the tick distance for a specified fee.\\n  /// @dev Once added, cannot be updated or removed.\\n  /// @param swapFeeUnits Swap fee, in fee units.\\n  /// @return The tick distance. Returns 0 if fee has not been added.\\n  function feeAmountTickDistance(uint24 swapFeeUnits) external view returns (int24);\\n\\n  /// @notice Returns the address which can update the fee configuration\\n  function configMaster() external view returns (address);\\n\\n  /// @notice Returns the keccak256 hash of the Pool creation code\\n  /// This is used for pre-computation of pool addresses\\n  function poolInitHash() external view returns (bytes32);\\n\\n  /// @notice Returns the pool oracle contract for twap\\n  function poolOracle() external view returns (address);\\n\\n  /// @notice Fetches the recipient of government fees\\n  /// and current government fee charged in fee units\\n  function feeConfiguration() external view returns (address _feeTo, uint24 _governmentFeeUnits);\\n\\n  /// @notice Returns the status of whitelisting feature of NFT managers\\n  /// If true, anyone can mint liquidity tokens\\n  /// Otherwise, only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\n  function whitelistDisabled() external view returns (bool);\\n\\n  //// @notice Returns all whitelisted NFT managers\\n  /// If the whitelisting feature is turned on,\\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\n  function getWhitelistedNFTManagers() external view returns (address[] memory);\\n\\n  /// @notice Checks if sender is a whitelisted NFT manager\\n  /// If the whitelisting feature is turned on,\\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\n  /// @param sender address to be checked\\n  /// @return true if sender is a whistelisted NFT manager, false otherwise\\n  function isWhitelistedNFTManager(address sender) external view returns (bool);\\n\\n  /// @notice Returns the pool address for a given pair of tokens and a swap fee\\n  /// @dev Token order does not matter\\n  /// @param tokenA Contract address of either token0 or token1\\n  /// @param tokenB Contract address of the other token\\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\n  /// @return pool The pool address. Returns null address if it does not exist\\n  function getPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 swapFeeUnits\\n  ) external view returns (address pool);\\n\\n  /// @notice Fetch parameters to be used for pool creation\\n  /// @dev Called by the pool constructor to fetch the parameters of the pool\\n  /// @return factory The factory address\\n  /// @return poolOracle The pool oracle for twap\\n  /// @return token0 First pool token by address sort order\\n  /// @return token1 Second pool token by address sort order\\n  /// @return swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\n  /// @return tickDistance Minimum number of ticks between initialized ticks\\n  function parameters()\\n    external\\n    view\\n    returns (\\n      address factory,\\n      address poolOracle,\\n      address token0,\\n      address token1,\\n      uint24 swapFeeUnits,\\n      int24 tickDistance\\n    );\\n\\n  /// @notice Creates a pool for the given two tokens and fee\\n  /// @param tokenA One of the two tokens in the desired pool\\n  /// @param tokenB The other of the two tokens in the desired pool\\n  /// @param swapFeeUnits Desired swap fee for the pool, in fee units\\n  /// @dev Token order does not matter. tickDistance is determined from the fee.\\n  /// Call will revert under any of these conditions:\\n  ///     1) pool already exists\\n  ///     2) invalid swap fee\\n  ///     3) invalid token arguments\\n  /// @return pool The address of the newly created pool\\n  function createPool(\\n    address tokenA,\\n    address tokenB,\\n    uint24 swapFeeUnits\\n  ) external returns (address pool);\\n\\n  /// @notice Enables a fee amount with the given tickDistance\\n  /// @dev Fee amounts may never be removed once enabled\\n  /// @param swapFeeUnits The fee amount to enable, in fee units\\n  /// @param tickDistance The distance between ticks to be enforced for all pools created with the given fee amount\\n  function enableSwapFee(uint24 swapFeeUnits, int24 tickDistance) external;\\n\\n  /// @notice Updates the address which can update the fee configuration\\n  /// @dev Must be called by the current configMaster\\n  function updateConfigMaster(address) external;\\n\\n  /// @notice Updates the vesting period\\n  /// @dev Must be called by the current configMaster\\n  function updateVestingPeriod(uint32) external;\\n\\n  /// @notice Updates the address receiving government fees and fee quantity\\n  /// @dev Only configMaster is able to perform the update\\n  /// @param feeTo Address to receive government fees collected from pools\\n  /// @param governmentFeeUnits Fee amount, in fee units,\\n  /// to be collected out of the fee charged for a pool swap\\n  function updateFeeConfiguration(address feeTo, uint24 governmentFeeUnits) external;\\n\\n  /// @notice Enables the whitelisting feature\\n  /// @dev Only configMaster is able to perform the update\\n  function enableWhitelist() external;\\n\\n  /// @notice Disables the whitelisting feature\\n  /// @dev Only configMaster is able to perform the update\\n  function disableWhitelist() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/periphery/IRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\npragma abicoder v2;\\n\\nimport '../callback/ISwapCallback.sol';\\n\\n/// @notice Functions for swapping tokens via KyberSwap v2\\n/// - Support swap with exact input or exact output\\n/// - Support swap with a price limit\\n/// - Support swap within a single pool and between multiple pools\\ninterface IRouter is ISwapCallback {\\n  /// @dev Params for swapping exact input amount\\n  /// @param tokenIn the token to swap\\n  /// @param tokenOut the token to receive\\n  /// @param fee the pool's fee\\n  /// @param recipient address to receive tokenOut\\n  /// @param deadline time that the transaction will be expired\\n  /// @param amountIn the tokenIn amount to swap\\n  /// @param amountOutMinimum the minimum receive amount\\n  /// @param limitSqrtP the price limit, if reached, stop swapping\\n  struct ExactInputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint24 fee;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountIn;\\n    uint256 minAmountOut;\\n    uint160 limitSqrtP;\\n  }\\n\\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n  /// @return amountOut The amount of the received token\\n  function swapExactInputSingle(ExactInputSingleParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountOut);\\n\\n  /// @dev Params for swapping exact input using multiple pools\\n  /// @param path the encoded path to swap from tokenIn to tokenOut\\n  ///   If the swap is from token0 -> token1 -> token2, then path is encoded as [token0, fee01, token1, fee12, token2]\\n  /// @param recipient address to receive tokenOut\\n  /// @param deadline time that the transaction will be expired\\n  /// @param amountIn the tokenIn amount to swap\\n  /// @param amountOutMinimum the minimum receive amount\\n  struct ExactInputParams {\\n    bytes path;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountIn;\\n    uint256 minAmountOut;\\n  }\\n\\n  /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n  /// @return amountOut The amount of the received token\\n  function swapExactInput(ExactInputParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountOut);\\n\\n  /// @dev Params for swapping exact output amount\\n  /// @param tokenIn the token to swap\\n  /// @param tokenOut the token to receive\\n  /// @param fee the pool's fee\\n  /// @param recipient address to receive tokenOut\\n  /// @param deadline time that the transaction will be expired\\n  /// @param amountOut the tokenOut amount of tokenOut\\n  /// @param amountInMaximum the minimum input amount\\n  /// @param limitSqrtP the price limit, if reached, stop swapping\\n  struct ExactOutputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint24 fee;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountOut;\\n    uint256 maxAmountIn;\\n    uint160 limitSqrtP;\\n  }\\n\\n  /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n  /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n  /// @return amountIn The amount of the input token\\n  function swapExactOutputSingle(ExactOutputSingleParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountIn);\\n\\n  /// @dev Params for swapping exact output using multiple pools\\n  /// @param path the encoded path to swap from tokenIn to tokenOut\\n  ///   If the swap is from token0 -> token1 -> token2, then path is encoded as [token2, fee12, token1, fee01, token0]\\n  /// @param recipient address to receive tokenOut\\n  /// @param deadline time that the transaction will be expired\\n  /// @param amountOut the tokenOut amount of tokenOut\\n  /// @param amountInMaximum the minimum input amount\\n  struct ExactOutputParams {\\n    bytes path;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountOut;\\n    uint256 maxAmountIn;\\n  }\\n\\n  /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n  /// @return amountIn The amount of the input token\\n  function swapExactOutput(ExactOutputParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/// @title Interface for WETH\\ninterface IWETH is IERC20 {\\n  /// @notice Deposit ether to get wrapped ether\\n  function deposit() external payable;\\n\\n  /// @notice Withdraw wrapped ether to get ether\\n  function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/base/DeadlineValidation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\n\\n/// @title Validate if the transaction is still valid\\nabstract contract DeadlineValidation {\\n  modifier onlyNotExpired(uint256 deadline) {\\n    require(_blockTimestamp() <= deadline, 'Expired');\\n    _;\\n  }\\n\\n  /// @dev Override this function to test easier with block timestamp\\n  function _blockTimestamp() internal view virtual returns (uint256) {\\n    return block.timestamp;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/base/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\npragma abicoder v2;\\n\\nimport {IMulticall} from '../../interfaces/periphery/IMulticall.sol';\\n\\n/// @title Multicall\\n/// @notice Enables calling multiple methods in a single call to the contract\\nabstract contract Multicall is IMulticall {\\n  /// @inheritdoc IMulticall\\n  function multicall(bytes[] calldata data)\\n    external\\n    payable\\n    override\\n    returns (bytes[] memory results)\\n  {\\n    results = new bytes[](data.length);\\n    for (uint256 i = 0; i < data.length; i++) {\\n      (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n\\n      if (!success) {\\n        // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n        if (result.length < 68) revert();\\n        assembly {\\n          result := add(result, 0x04)\\n        }\\n        revert(abi.decode(result, (string)));\\n      }\\n      results[i] = result;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/base/RouterTokenHelperWithFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {TokenHelper} from '../libraries/TokenHelper.sol';\\n\\nimport {IRouterTokenHelperWithFee} from '../../interfaces/periphery/IRouterTokenHelperWithFee.sol';\\nimport {IWETH} from '../../interfaces/IWETH.sol';\\n\\nimport {RouterTokenHelper} from './RouterTokenHelper.sol';\\n\\nabstract contract RouterTokenHelperWithFee is RouterTokenHelper, IRouterTokenHelperWithFee {\\n  uint256 constant FEE_UNITS = 100000;\\n\\n  constructor(address _factory, address _WETH) RouterTokenHelper(_factory, _WETH) {}\\n\\n  function unwrapWethWithFee(\\n    uint256 minAmount,\\n    address recipient,\\n    uint256 feeUnits,\\n    address feeRecipient\\n  ) public payable override {\\n    require(feeUnits > 0 && feeUnits <= 1000, 'High fee');\\n\\n    uint256 balanceWETH = IWETH(WETH).balanceOf(address(this));\\n    require(balanceWETH >= minAmount, 'Insufficient WETH');\\n\\n    if (balanceWETH > 0) {\\n      IWETH(WETH).withdraw(balanceWETH);\\n      uint256 feeAmount = (balanceWETH * feeUnits) / FEE_UNITS;\\n      if (feeAmount > 0) TokenHelper.transferEth(feeRecipient, feeAmount);\\n      TokenHelper.transferEth(recipient, balanceWETH - feeAmount);\\n    }\\n  }\\n\\n  function transferAllTokensWithFee(\\n    address token,\\n    uint256 minAmount,\\n    address recipient,\\n    uint256 feeUnits,\\n    address feeRecipient\\n  ) public payable override {\\n    require(feeUnits > 0 && feeUnits <= 1000, 'High fee');\\n\\n    uint256 balanceToken = IERC20(token).balanceOf(address(this));\\n    require(balanceToken >= minAmount, 'Insufficient token');\\n\\n    if (balanceToken > 0) {\\n      uint256 feeAmount = (balanceToken * feeUnits) / FEE_UNITS;\\n      if (feeAmount > 0)\\n        TokenHelper.transferToken(IERC20(token), feeAmount, address(this), feeRecipient);\\n      TokenHelper.transferToken(IERC20(token), balanceToken - feeAmount, address(this), recipient);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/libraries/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity 0.8.9;\\n\\nlibrary BytesLib {\\n  function slice(\\n    bytes memory _bytes,\\n    uint256 _start,\\n    uint256 _length\\n  ) internal pure returns (bytes memory) {\\n    require(_length + 31 >= _length, 'slice_overflow');\\n    require(_bytes.length >= _start + _length, 'slice_outOfBounds');\\n\\n    bytes memory tempBytes;\\n\\n    assembly {\\n      switch iszero(_length)\\n      case 0 {\\n        // Get a location of some free memory and store it in tempBytes as\\n        // Solidity does for memory variables.\\n        tempBytes := mload(0x40)\\n\\n        // The first word of the slice result is potentially a partial\\n        // word read from the original array. To read it, we calculate\\n        // the length of that partial word and start copying that many\\n        // bytes into the array. The first word we copy will start with\\n        // data we don't care about, but the last `lengthmod` bytes will\\n        // land at the beginning of the contents of the new array. When\\n        // we're done copying, we overwrite the full first word with\\n        // the actual length of the slice.\\n        let lengthmod := and(_length, 31)\\n\\n        // The multiplication in the next line is necessary\\n        // because when slicing multiples of 32 bytes (lengthmod == 0)\\n        // the following copy loop was copying the origin's length\\n        // and then ending prematurely not copying everything it should.\\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n        let end := add(mc, _length)\\n\\n        for {\\n          // The multiplication in the next line has the same exact purpose\\n          // as the one above.\\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n        } lt(mc, end) {\\n          mc := add(mc, 0x20)\\n          cc := add(cc, 0x20)\\n        } {\\n          mstore(mc, mload(cc))\\n        }\\n\\n        mstore(tempBytes, _length)\\n\\n        // update free-memory pointer\\n        // allocating the array padded to 32 bytes like the compiler does now\\n        mstore(0x40, and(add(mc, 31), not(31)))\\n      }\\n      //if we want a zero-length slice let's just return a zero-length array\\n      default {\\n        tempBytes := mload(0x40)\\n        // zero out the 32 bytes slice we are about to return\\n        // we need to do it because Solidity does not garbage collect\\n        mstore(tempBytes, 0)\\n\\n        mstore(0x40, add(tempBytes, 0x20))\\n      }\\n    }\\n    return tempBytes;\\n  }\\n\\n  function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n    require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\\n    address tempAddress;\\n\\n    assembly {\\n      tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n    }\\n\\n    return tempAddress;\\n  }\\n\\n  function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n    require(_bytes.length >= _start + 2, 'toUint16_outOfBounds');\\n    uint16 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x2), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n\\n  function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n    require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\\n    uint24 tempUint;\\n\\n    assembly {\\n      tempUint := mload(add(add(_bytes, 0x3), _start))\\n    }\\n\\n    return tempUint;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pool/IPoolActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IPoolActions {\\n  /// @notice Sets the initial price for the pool and seeds reinvestment liquidity\\n  /// @dev Assumes the caller has sent the necessary token amounts\\n  /// required for initializing reinvestment liquidity prior to calling this function\\n  /// @param initialSqrtP the initial sqrt price of the pool\\n  /// @param qty0 token0 quantity sent to and locked permanently in the pool\\n  /// @param qty1 token1 quantity sent to and locked permanently in the pool\\n  function unlockPool(uint160 initialSqrtP) external returns (uint256 qty0, uint256 qty1);\\n\\n  /// @notice Adds liquidity for the specified recipient/tickLower/tickUpper position\\n  /// @dev Any token0 or token1 owed for the liquidity provision have to be paid for when\\n  /// the IMintCallback#mintCallback is called to this method's caller\\n  /// The quantity of token0/token1 to be sent depends on\\n  /// tickLower, tickUpper, the amount of liquidity, and the current price of the pool.\\n  /// Also sends reinvestment tokens (fees) to the recipient for any fees collected\\n  /// while the position is in range\\n  /// Reinvestment tokens have to be burnt via #burnRTokens in exchange for token0 and token1\\n  /// @param recipient Address for which the added liquidity is credited to\\n  /// @param tickLower Recipient position's lower tick\\n  /// @param tickUpper Recipient position's upper tick\\n  /// @param ticksPrevious The nearest tick that is initialized and <= the lower & upper ticks\\n  /// @param qty Liquidity quantity to mint\\n  /// @param data Data (if any) to be passed through to the callback\\n  /// @return qty0 token0 quantity sent to the pool in exchange for the minted liquidity\\n  /// @return qty1 token1 quantity sent to the pool in exchange for the minted liquidity\\n  /// @return feeGrowthInside position's updated feeGrowthInside value\\n  function mint(\\n    address recipient,\\n    int24 tickLower,\\n    int24 tickUpper,\\n    int24[2] calldata ticksPrevious,\\n    uint128 qty,\\n    bytes calldata data\\n  )\\n    external\\n    returns (\\n      uint256 qty0,\\n      uint256 qty1,\\n      uint256 feeGrowthInside\\n    );\\n\\n  /// @notice Remove liquidity from the caller\\n  /// Also sends reinvestment tokens (fees) to the caller for any fees collected\\n  /// while the position is in range\\n  /// Reinvestment tokens have to be burnt via #burnRTokens in exchange for token0 and token1\\n  /// @param tickLower Position's lower tick for which to burn liquidity\\n  /// @param tickUpper Position's upper tick for which to burn liquidity\\n  /// @param qty Liquidity quantity to burn\\n  /// @return qty0 token0 quantity sent to the caller\\n  /// @return qty1 token1 quantity sent to the caller\\n  /// @return feeGrowthInside position's updated feeGrowthInside value\\n  function burn(\\n    int24 tickLower,\\n    int24 tickUpper,\\n    uint128 qty\\n  )\\n    external\\n    returns (\\n      uint256 qty0,\\n      uint256 qty1,\\n      uint256 feeGrowthInside\\n    );\\n\\n  /// @notice Burns reinvestment tokens in exchange to receive the fees collected in token0 and token1\\n  /// @param qty Reinvestment token quantity to burn\\n  /// @param isLogicalBurn true if burning rTokens without returning any token0/token1\\n  ///         otherwise should transfer token0/token1 to sender\\n  /// @return qty0 token0 quantity sent to the caller for burnt reinvestment tokens\\n  /// @return qty1 token1 quantity sent to the caller for burnt reinvestment tokens\\n  function burnRTokens(uint256 qty, bool isLogicalBurn)\\n    external\\n    returns (uint256 qty0, uint256 qty1);\\n\\n  /// @notice Swap token0 -> token1, or vice versa\\n  /// @dev This method's caller receives a callback in the form of ISwapCallback#swapCallback\\n  /// @dev swaps will execute up to limitSqrtP or swapQty is fully used\\n  /// @param recipient The address to receive the swap output\\n  /// @param swapQty The swap quantity, which implicitly configures the swap as exact input (>0), or exact output (<0)\\n  /// @param isToken0 Whether the swapQty is specified in token0 (true) or token1 (false)\\n  /// @param limitSqrtP the limit of sqrt price after swapping\\n  /// could be MAX_SQRT_RATIO-1 when swapping 1 -> 0 and MIN_SQRT_RATIO+1 when swapping 0 -> 1 for no limit swap\\n  /// @param data Any data to be passed through to the callback\\n  /// @return qty0 Exact token0 qty sent to recipient if < 0. Minimally received quantity if > 0.\\n  /// @return qty1 Exact token1 qty sent to recipient if < 0. Minimally received quantity if > 0.\\n  function swap(\\n    address recipient,\\n    int256 swapQty,\\n    bool isToken0,\\n    uint160 limitSqrtP,\\n    bytes calldata data\\n  ) external returns (int256 qty0, int256 qty1);\\n\\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\n  /// @dev The caller of this method receives a callback in the form of IFlashCallback#flashCallback\\n  /// @dev Fees collected are sent to the feeTo address if it is set in Factory\\n  /// @param recipient The address which will receive the token0 and token1 quantities\\n  /// @param qty0 token0 quantity to be loaned to the recipient\\n  /// @param qty1 token1 quantity to be loaned to the recipient\\n  /// @param data Any data to be passed through to the callback\\n  function flash(\\n    address recipient,\\n    uint256 qty0,\\n    uint256 qty1,\\n    bytes calldata data\\n  ) external;\\n\\n\\n  /// @notice sync fee of position\\n  /// @param tickLower Position's lower tick\\n  /// @param tickUpper Position's upper tick\\n  function tweakPosZeroLiq(int24 tickLower, int24 tickUpper)\\n    external returns(uint256 feeGrowthInsideLast);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pool/IPoolEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IPoolEvents {\\n  /// @notice Emitted only once per pool when #initialize is first called\\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\n  /// @param sqrtP The initial price of the pool\\n  /// @param tick The initial tick of the pool\\n  event Initialize(uint160 sqrtP, int24 tick);\\n\\n  /// @notice Emitted when liquidity is minted for a given position\\n  /// @dev transfers reinvestment tokens for any collected fees earned by the position\\n  /// @param sender address that minted the liquidity\\n  /// @param owner address of owner of the position\\n  /// @param tickLower position's lower tick\\n  /// @param tickUpper position's upper tick\\n  /// @param qty liquidity minted to the position range\\n  /// @param qty0 token0 quantity needed to mint the liquidity\\n  /// @param qty1 token1 quantity needed to mint the liquidity\\n  event Mint(\\n    address sender,\\n    address indexed owner,\\n    int24 indexed tickLower,\\n    int24 indexed tickUpper,\\n    uint128 qty,\\n    uint256 qty0,\\n    uint256 qty1\\n  );\\n\\n  /// @notice Emitted when a position's liquidity is removed\\n  /// @dev transfers reinvestment tokens for any collected fees earned by the position\\n  /// @param owner address of owner of the position\\n  /// @param tickLower position's lower tick\\n  /// @param tickUpper position's upper tick\\n  /// @param qty liquidity removed\\n  /// @param qty0 token0 quantity withdrawn from removal of liquidity\\n  /// @param qty1 token1 quantity withdrawn from removal of liquidity\\n  event Burn(\\n    address indexed owner,\\n    int24 indexed tickLower,\\n    int24 indexed tickUpper,\\n    uint128 qty,\\n    uint256 qty0,\\n    uint256 qty1\\n  );\\n\\n  /// @notice Emitted when reinvestment tokens are burnt\\n  /// @param owner address which burnt the reinvestment tokens\\n  /// @param qty reinvestment token quantity burnt\\n  /// @param qty0 token0 quantity sent to owner for burning reinvestment tokens\\n  /// @param qty1 token1 quantity sent to owner for burning reinvestment tokens\\n  event BurnRTokens(address indexed owner, uint256 qty, uint256 qty0, uint256 qty1);\\n\\n  /// @notice Emitted for swaps by the pool between token0 and token1\\n  /// @param sender Address that initiated the swap call, and that received the callback\\n  /// @param recipient Address that received the swap output\\n  /// @param deltaQty0 Change in pool's token0 balance\\n  /// @param deltaQty1 Change in pool's token1 balance\\n  /// @param sqrtP Pool's sqrt price after the swap\\n  /// @param liquidity Pool's liquidity after the swap\\n  /// @param currentTick Log base 1.0001 of pool's price after the swap\\n  event Swap(\\n    address indexed sender,\\n    address indexed recipient,\\n    int256 deltaQty0,\\n    int256 deltaQty1,\\n    uint160 sqrtP,\\n    uint128 liquidity,\\n    int24 currentTick\\n  );\\n\\n  /// @notice Emitted by the pool for any flash loans of token0/token1\\n  /// @param sender The address that initiated the flash loan, and that received the callback\\n  /// @param recipient The address that received the flash loan quantities\\n  /// @param qty0 token0 quantity loaned to the recipient\\n  /// @param qty1 token1 quantity loaned to the recipient\\n  /// @param paid0 token0 quantity paid for the flash, which can exceed qty0 + fee\\n  /// @param paid1 token1 quantity paid for the flash, which can exceed qty0 + fee\\n  event Flash(\\n    address indexed sender,\\n    address indexed recipient,\\n    uint256 qty0,\\n    uint256 qty1,\\n    uint256 paid0,\\n    uint256 paid1\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pool/IPoolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {IFactory} from '../IFactory.sol';\\nimport {IPoolOracle} from '../oracle/IPoolOracle.sol';\\n\\ninterface IPoolStorage {\\n  /// @notice The contract that deployed the pool, which must adhere to the IFactory interface\\n  /// @return The contract address\\n  function factory() external view returns (IFactory);\\n\\n  /// @notice The oracle contract that stores necessary data for price oracle\\n  /// @return The contract address\\n  function poolOracle() external view returns (IPoolOracle);\\n\\n  /// @notice The first of the two tokens of the pool, sorted by address\\n  /// @return The token contract address\\n  function token0() external view returns (IERC20);\\n\\n  /// @notice The second of the two tokens of the pool, sorted by address\\n  /// @return The token contract address\\n  function token1() external view returns (IERC20);\\n\\n  /// @notice The fee to be charged for a swap in basis points\\n  /// @return The swap fee in basis points\\n  function swapFeeUnits() external view returns (uint24);\\n\\n  /// @notice The pool tick distance\\n  /// @dev Ticks can only be initialized and used at multiples of this value\\n  /// It remains an int24 to avoid casting even though it is >= 1.\\n  /// e.g: a tickDistance of 5 means ticks can be initialized every 5th tick, i.e., ..., -10, -5, 0, 5, 10, ...\\n  /// @return The tick distance\\n  function tickDistance() external view returns (int24);\\n\\n  /// @notice Maximum gross liquidity that an initialized tick can have\\n  /// @dev This is to prevent overflow the pool's active base liquidity (uint128)\\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n  /// @return The max amount of liquidity per tick\\n  function maxTickLiquidity() external view returns (uint128);\\n\\n  /// @notice Look up information about a specific tick in the pool\\n  /// @param tick The tick to look up\\n  /// @return liquidityGross total liquidity amount from positions that uses this tick as a lower or upper tick\\n  /// liquidityNet how much liquidity changes when the pool tick crosses above the tick\\n  /// feeGrowthOutside the fee growth on the other side of the tick relative to the current tick\\n  /// secondsPerLiquidityOutside the seconds per unit of liquidity  spent on the other side of the tick relative to the current tick\\n  function ticks(int24 tick)\\n    external\\n    view\\n    returns (\\n      uint128 liquidityGross,\\n      int128 liquidityNet,\\n      uint256 feeGrowthOutside,\\n      uint128 secondsPerLiquidityOutside\\n    );\\n\\n  /// @notice Returns the previous and next initialized ticks of a specific tick\\n  /// @dev If specified tick is uninitialized, the returned values are zero.\\n  /// @param tick The tick to look up\\n  function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\\n\\n  /// @notice Returns the information about a position by the position's key\\n  /// @return liquidity the liquidity quantity of the position\\n  /// @return feeGrowthInsideLast fee growth inside the tick range as of the last mint / burn action performed\\n  function getPositions(\\n    address owner,\\n    int24 tickLower,\\n    int24 tickUpper\\n  ) external view returns (uint128 liquidity, uint256 feeGrowthInsideLast);\\n\\n  /// @notice Fetches the pool's prices, ticks and lock status\\n  /// @return sqrtP sqrt of current price: sqrt(token1/token0)\\n  /// @return currentTick pool's current tick\\n  /// @return nearestCurrentTick pool's nearest initialized tick that is <= currentTick\\n  /// @return locked true if pool is locked, false otherwise\\n  function getPoolState()\\n    external\\n    view\\n    returns (\\n      uint160 sqrtP,\\n      int24 currentTick,\\n      int24 nearestCurrentTick,\\n      bool locked\\n    );\\n\\n  /// @notice Fetches the pool's liquidity values\\n  /// @return baseL pool's base liquidity without reinvest liqudity\\n  /// @return reinvestL the liquidity is reinvested into the pool\\n  /// @return reinvestLLast last cached value of reinvestL, used for calculating reinvestment token qty\\n  function getLiquidityState()\\n    external\\n    view\\n    returns (\\n      uint128 baseL,\\n      uint128 reinvestL,\\n      uint128 reinvestLLast\\n    );\\n\\n  /// @return feeGrowthGlobal All-time fee growth per unit of liquidity of the pool\\n  function getFeeGrowthGlobal() external view returns (uint256);\\n\\n  /// @return secondsPerLiquidityGlobal All-time seconds per unit of liquidity of the pool\\n  /// @return lastUpdateTime The timestamp in which secondsPerLiquidityGlobal was last updated\\n  function getSecondsPerLiquidityData()\\n    external\\n    view\\n    returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\\n\\n  /// @notice Calculates and returns the active time per unit of liquidity until current block.timestamp\\n  /// @param tickLower The lower tick (of a position)\\n  /// @param tickUpper The upper tick (of a position)\\n  /// @return secondsPerLiquidityInside active time (multiplied by 2^96)\\n  /// between the 2 ticks, per unit of liquidity.\\n  function getSecondsPerLiquidityInside(int24 tickLower, int24 tickUpper)\\n    external\\n    view\\n    returns (uint128 secondsPerLiquidityInside);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/oracle/IPoolOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IPoolOracle {\\n  /// @notice Owner withdrew funds in the pool oracle in case some funds are stuck there\\n  event OwnerWithdrew(\\n    address indexed owner,\\n    address indexed token,\\n    uint256 indexed amount\\n  );\\n\\n  /// @notice Emitted by the Pool Oracle for increases to the number of observations that can be stored\\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\\n  /// just before a mint/swap/burn.\\n  /// @param pool The pool address to update\\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\\n  event IncreaseObservationCardinalityNext(\\n    address pool,\\n    uint16 observationCardinalityNextOld,\\n    uint16 observationCardinalityNextNew\\n  );\\n\\n  /// @notice Initalize observation data for the caller.\\n  function initializeOracle(uint32 time)\\n    external\\n    returns (uint16 cardinality, uint16 cardinalityNext);\\n\\n  /// @notice Write a new oracle entry into the array\\n  ///   and update the observation index and cardinality\\n  /// Read the Oralce.write function for more details\\n  function writeNewEntry(\\n    uint16 index,\\n    uint32 blockTimestamp,\\n    int24 tick,\\n    uint128 liquidity,\\n    uint16 cardinality,\\n    uint16 cardinalityNext\\n  )\\n    external\\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated);\\n\\n  /// @notice Write a new oracle entry into the array, take the latest observaion data as inputs\\n  ///   and update the observation index and cardinality\\n  /// Read the Oralce.write function for more details\\n  function write(\\n    uint32 blockTimestamp,\\n    int24 tick,\\n    uint128 liquidity\\n  )\\n    external\\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated);\\n\\n  /// @notice Increase the maximum number of price observations that this pool will store\\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\\n  /// the input observationCardinalityNext.\\n  /// @param pool The pool address to be updated\\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\\n  function increaseObservationCardinalityNext(\\n    address pool,\\n    uint16 observationCardinalityNext\\n  )\\n    external;\\n\\n  /// @notice Returns the accumulator values as of each time seconds ago from the latest block time in the array of `secondsAgos`\\n  /// @dev Reverts if `secondsAgos` > oldest observation\\n  /// @dev It fetches the latest current tick data from the pool\\n  /// Read the Oracle.observe function for more details\\n  function observeFromPool(\\n    address pool,\\n    uint32[] memory secondsAgos\\n  )\\n    external view\\n    returns (int56[] memory tickCumulatives);\\n\\n  /// @notice Returns the accumulator values as the time seconds ago from the latest block time of secondsAgo\\n  /// @dev Reverts if `secondsAgo` > oldest observation\\n  /// @dev It fetches the latest current tick data from the pool\\n  /// Read the Oracle.observeSingle function for more details\\n  function observeSingleFromPool(\\n    address pool,\\n    uint32 secondsAgo\\n  )\\n    external view\\n    returns (int56 tickCumulative);\\n\\n  /// @notice Return the latest pool observation data given the pool address\\n  function getPoolObservation(address pool)\\n    external view\\n    returns (bool initialized, uint16 index, uint16 cardinality, uint16 cardinalityNext);\\n\\n  /// @notice Returns data about a specific observation index\\n  /// @param pool The pool address of the observations array to fetch\\n  /// @param index The element of the observations array to fetch\\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\n  /// ago, rather than at a specific index in the array.\\n  /// @return blockTimestamp The timestamp of the observation,\\n  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\n  /// Returns initialized whether the observation has been initialized and the values are safe to use\\n  function getObservationAt(address pool, uint256 index)\\n    external view\\n    returns (\\n      uint32 blockTimestamp,\\n      int56 tickCumulative,\\n      bool initialized\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/callback/ISwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @title Callback for IPool#swap\\n/// @notice Any contract that calls IPool#swap must implement this interface\\ninterface ISwapCallback {\\n  /// @notice Called to `msg.sender` after swap execution of IPool#swap.\\n  /// @dev This function's implementation must pay tokens owed to the pool for the swap.\\n  /// The caller of this method must be checked to be a Pool deployed by the canonical Factory.\\n  /// deltaQty0 and deltaQty1 can both be 0 if no tokens were swapped.\\n  /// @param deltaQty0 The token0 quantity that was sent (negative) or must be received (positive) by the pool by\\n  /// the end of the swap. If positive, the callback must send deltaQty0 of token0 to the pool.\\n  /// @param deltaQty1 The token1 quantity that was sent (negative) or must be received (positive) by the pool by\\n  /// the end of the swap. If positive, the callback must send deltaQty1 of token1 to the pool.\\n  /// @param data Data passed through by the caller via the IPool#swap call\\n  function swapCallback(\\n    int256 deltaQty0,\\n    int256 deltaQty1,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/periphery/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\npragma abicoder v2;\\n\\n/// @title Multicall interface\\n/// @notice Enables calling multiple methods in a single call to the contract\\ninterface IMulticall {\\n  /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n  /// @dev The `msg.value` should not be trusted for any method callable from multicall.\\n  /// @param data The encoded function data for each of the calls to make to this contract\\n  /// @return results The results from each of the calls passed in via data\\n  function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/libraries/TokenHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\n\\n/// @title Helper to transfer token or ETH\\nlibrary TokenHelper {\\n  using SafeERC20 for IERC20;\\n\\n  /// @dev Transfer token from the sender to the receiver\\n  /// @notice If the sender is the contract address, should just call transfer token to receiver\\n  ///   otherwise, tansfer tokens from the sender to the receiver\\n  function transferToken(\\n    IERC20 token,\\n    uint256 amount,\\n    address sender,\\n    address receiver\\n  ) internal {\\n    if (sender == address(this)) {\\n      token.safeTransfer(receiver, amount);\\n    } else {\\n      token.safeTransferFrom(sender, receiver, amount);\\n    }\\n  }\\n\\n  /// @dev Transfer ETh to the receiver\\n  function transferEth(address receiver, uint256 amount) internal {\\n    if (receiver == address(this)) return;\\n    (bool success, ) = payable(receiver).call{value: amount}('');\\n    require(success, 'transfer eth failed');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/periphery/IRouterTokenHelperWithFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport './IRouterTokenHelper.sol';\\n\\ninterface IRouterTokenHelperWithFee is IRouterTokenHelper {\\n  /// @notice Unwraps the contract's WETH balance and sends it to recipient as ETH, with a percentage between\\n  /// 0 (exclusive), and 1 (inclusive) going to feeRecipient\\n  /// @dev The minAmount parameter prevents malicious contracts from stealing WETH from users.\\n  function unwrapWethWithFee(\\n    uint256 minAmount,\\n    address recipient,\\n    uint256 feeUnits,\\n    address feeRecipient\\n  ) external payable;\\n\\n  /// @notice Transfers the full amount of a token held by this contract to recipient, with a percentage between\\n  /// 0 (exclusive) and 1 (inclusive) going to feeRecipient\\n  /// @dev The minAmount parameter prevents malicious contracts from stealing the token from users\\n  function transferAllTokensWithFee(\\n    address token,\\n    uint256 minAmount,\\n    address recipient,\\n    uint256 feeBips,\\n    address feeRecipient\\n  ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/base/RouterTokenHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {TokenHelper} from '../libraries/TokenHelper.sol';\\n\\nimport {IRouterTokenHelper} from '../../interfaces/periphery/IRouterTokenHelper.sol';\\nimport {IWETH} from '../../interfaces/IWETH.sol';\\n\\nimport {ImmutablePeripheryStorage} from './ImmutablePeripheryStorage.sol';\\n\\nabstract contract RouterTokenHelper is IRouterTokenHelper, ImmutablePeripheryStorage {\\n  constructor(address _factory, address _WETH) ImmutablePeripheryStorage(_factory, _WETH) {}\\n\\n  receive() external payable {\\n    require(msg.sender == WETH, 'Not WETH');\\n  }\\n\\n  /// @dev Unwrap all ETH balance and send to the recipient\\n  function unwrapWeth(uint256 minAmount, address recipient) external payable override {\\n    uint256 balanceWETH = IWETH(WETH).balanceOf(address(this));\\n    require(balanceWETH >= minAmount, 'Insufficient WETH');\\n\\n    if (balanceWETH > 0) {\\n      IWETH(WETH).withdraw(balanceWETH);\\n      TokenHelper.transferEth(recipient, balanceWETH);\\n    }\\n  }\\n\\n  /// @dev Transfer all tokens from the contract to the recipient\\n  function transferAllTokens(\\n    address token,\\n    uint256 minAmount,\\n    address recipient\\n  ) public payable virtual override {\\n    uint256 balanceToken = IERC20(token).balanceOf(address(this));\\n    require(balanceToken >= minAmount, 'Insufficient token');\\n\\n    if (balanceToken > 0) {\\n      TokenHelper.transferToken(IERC20(token), balanceToken, address(this), recipient);\\n    }\\n  }\\n\\n  /// @dev Send all ETH balance of this contract to the sender\\n  function refundEth() external payable override {\\n    if (address(this).balance > 0) TokenHelper.transferEth(msg.sender, address(this).balance);\\n  }\\n\\n  /// @dev Transfer tokenAmount amount of token from the sender to the recipient\\n  function _transferTokens(\\n    address token,\\n    address sender,\\n    address recipient,\\n    uint256 tokenAmount\\n  ) internal {\\n    if (token == WETH && address(this).balance >= tokenAmount) {\\n      IWETH(WETH).deposit{value: tokenAmount}();\\n      IWETH(WETH).transfer(recipient, tokenAmount);\\n    } else {\\n      TokenHelper.transferToken(IERC20(token), tokenAmount, sender, recipient);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/periphery/IRouterTokenHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\ninterface IRouterTokenHelper {\\n  /// @notice Unwraps the contract's WETH balance and sends it to recipient as ETH.\\n  /// @dev The minAmount parameter prevents malicious contracts from stealing WETH from users.\\n  /// @param minAmount The minimum amount of WETH to unwrap\\n  /// @param recipient The address receiving ETH\\n  function unwrapWeth(uint256 minAmount, address recipient) external payable;\\n\\n  /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\\n  /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\\n  /// that use ether for the input amount\\n  function refundEth() external payable;\\n\\n  /// @notice Transfers the full amount of a token held by this contract to recipient\\n  /// @dev The minAmount parameter prevents malicious contracts from stealing the token from users\\n  /// @param token The contract address of the token which will be transferred to `recipient`\\n  /// @param minAmount The minimum amount of token required for a transfer\\n  /// @param recipient The destination address of the token\\n  function transferAllTokens(\\n    address token,\\n    uint256 minAmount,\\n    address recipient\\n  ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/base/ImmutablePeripheryStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.9;\\n\\nimport {IFactory} from '../../interfaces/IFactory.sol';\\n\\n/// @title Immutable state\\n/// @notice Immutable state used by periphery contracts\\nabstract contract ImmutablePeripheryStorage {\\n  address public immutable factory;\\n  address public immutable WETH;\\n  bytes32 internal immutable poolInitHash;\\n\\n  constructor(address _factory, address _WETH) {\\n    factory = _factory;\\n    WETH = _WETH;\\n    poolInitHash = IFactory(_factory).poolInitHash();\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"deltaQty0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"deltaQty1\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"internalType\":\"struct IRouter.ExactInputParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapExactInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"limitSqrtP\",\"type\":\"uint160\"}],\"internalType\":\"struct IRouter.ExactInputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapExactInputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"}],\"internalType\":\"struct IRouter.ExactOutputParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapExactOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"limitSqrtP\",\"type\":\"uint160\"}],\"internalType\":\"struct IRouter.ExactOutputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"swapExactOutputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transferAllTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeUnits\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"name\":\"transferAllTokensWithFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unwrapWeth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeUnits\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"name\":\"unwrapWethWithFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Router", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "000000000000000000000000c7a590291e07b9fe9e64b86c58fd8fc764308c4a0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}