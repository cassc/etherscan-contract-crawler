{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/HumanboundToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport \\\"@violetprotocol/erc721extendable/contracts/extensions/metadata/ERC721Metadata.sol\\\";\\n\\ncontract HumanboundToken is ERC721Metadata {\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address extendLogic,\\n        address approveLogic,\\n        address getterLogic,\\n        address onReceiveLogic,\\n        address transferLogic,\\n        address hooksLogic\\n    )\\n        ERC721Metadata(\\n            name_,\\n            symbol_,\\n            extendLogic,\\n            approveLogic,\\n            getterLogic,\\n            onReceiveLogic,\\n            transferLogic,\\n            hooksLogic\\n        )\\n    {}\\n}\\n\"\r\n    },\r\n    \"@violetprotocol/erc721extendable/contracts/extensions/metadata/ERC721Metadata.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../base/ERC721.sol\\\";\\n\\n/**\\n * @dev ERC721Metadata Extendable contract\\n *\\n * Constructor arguments take usual `name` and `symbol` arguments for the token\\n * with additional extension addresses specifying where the functional logic\\n * for each of the token features live which is passed to the Base ERC721 contract\\n *\\n * Metadata-specific extensions must be extended immediately after deployment by\\n * calling the `finaliseERC721MetadataExtending` function.\\n *\\n */\\nbytes4 constant ERC721MetadataInterfaceId = 0x5b5e139f;\\n\\ncontract ERC721Metadata is ERC721 {\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address extendLogic,\\n        address approveLogic,\\n        address getterLogic,\\n        address onReceiveLogic,\\n        address transferLogic,\\n        address hooksLogic\\n    ) ERC721(name_, symbol_, extendLogic, approveLogic, getterLogic, onReceiveLogic, transferLogic, hooksLogic) {}\\n\\n    /**\\n     * @dev Extends the contract with Metadata-specific functionalities\\n     *\\n     * Must be called immediately after contract deployment.\\n     *\\n     */\\n    function finaliseERC721MetadataExtending(\\n        address metadataGetterLogic,\\n        address setTokenURILogic,\\n        address mintLogic,\\n        address burnLogic\\n    ) public {\\n        IExtendLogic self = IExtendLogic(address(this));\\n\\n        self.extend(metadataGetterLogic);\\n        self.extend(setTokenURILogic);\\n        self.extend(mintLogic);\\n        self.extend(burnLogic);\\n\\n        IERC165Register(address(this)).registerInterface(ERC721MetadataInterfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@violetprotocol/erc721extendable/contracts/extensions/base/ERC721.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@violetprotocol/extendable/extendable/Extendable.sol\\\";\\nimport \\\"@violetprotocol/extendable/extensions/extend/IExtendLogic.sol\\\";\\nimport { ERC721State, ERC721Storage } from \\\"../../storage/ERC721Storage.sol\\\";\\n\\n/**\\n * @dev Core ERC721 Extendable contract\\n *\\n * Constructor arguments take usual `name` and `symbol` arguments for the token\\n * with additional extension addresses specifying where the functional logic\\n * for each of the token features live.\\n *\\n */\\nbytes4 constant ERC721InterfaceId = 0x80ac58cd;\\n\\ncontract ERC721 is Extendable {\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address extendLogic,\\n        address approveLogic,\\n        address getterLogic,\\n        address onReceiveLogic,\\n        address transferLogic,\\n        address hooksLogic\\n    ) Extendable(extendLogic) {\\n        // Set the token name and symbol\\n        ERC721State storage erc721State = ERC721Storage._getState();\\n        erc721State._name = name_;\\n        erc721State._symbol = symbol_;\\n\\n        // Attempt to extend the contract with core functionality\\n        // Must use low-level calls since contract has not yet been fully deployed\\n        (bool extendApproveSuccess, ) = extendLogic.delegatecall(\\n            abi.encodeWithSignature(\\\"extend(address)\\\", approveLogic)\\n        );\\n        require(extendApproveSuccess, \\\"failed to initialise approve\\\");\\n\\n        (bool extendGetterSuccess, ) = extendLogic.delegatecall(\\n            abi.encodeWithSignature(\\\"extend(address)\\\", getterLogic)\\n        );\\n        require(extendGetterSuccess, \\\"failed to initialise getter\\\");\\n\\n        (bool extendOnReceiveSuccess, ) = extendLogic.delegatecall(\\n            abi.encodeWithSignature(\\\"extend(address)\\\", onReceiveLogic)\\n        );\\n        require(extendOnReceiveSuccess, \\\"failed to initialise onReceive\\\");\\n\\n        (bool extendTransferSuccess, ) = extendLogic.delegatecall(\\n            abi.encodeWithSignature(\\\"extend(address)\\\", transferLogic)\\n        );\\n        require(extendTransferSuccess, \\\"failed to initialise transfer\\\");\\n\\n        (bool extendHooksSuccess, ) = extendLogic.delegatecall(abi.encodeWithSignature(\\\"extend(address)\\\", hooksLogic));\\n        require(extendHooksSuccess, \\\"failed to initialise hooks\\\");\\n\\n        (bool registerInterfaceSuccess, ) = extendLogic.delegatecall(\\n            abi.encodeWithSignature(\\\"registerInterface(bytes4)\\\", ERC721InterfaceId)\\n        );\\n        require(registerInterfaceSuccess, \\\"failed to register erc721 interface\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@violetprotocol/extendable/extendable/Extendable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../errors/Errors.sol\\\";\\nimport {CallerState, CallerContextStorage} from \\\"../storage/CallerContextStorage.sol\\\";\\nimport {ExtendableState, ExtendableStorage} from \\\"../storage/ExtendableStorage.sol\\\";\\n\\n/**\\n *  ______  __  __  ______  ______  __   __  _____   ______  ______  __      ______    \\n * /\\\\  ___\\\\/\\\\_\\\\_\\\\_\\\\/\\\\__  _\\\\/\\\\  ___\\\\/\\\\ \\\"-.\\\\ \\\\/\\\\  __-./\\\\  __ \\\\/\\\\  == \\\\/\\\\ \\\\    /\\\\  ___\\\\\\n * \\\\ \\\\  __\\\\\\\\/_/\\\\_\\\\/\\\\/_/\\\\ \\\\/\\\\ \\\\  __\\\\\\\\ \\\\ \\\\-.  \\\\ \\\\ \\\\/\\\\ \\\\ \\\\  __ \\\\ \\\\  __<\\\\ \\\\ \\\\___\\\\ \\\\  __\\\\\\n *  \\\\ \\\\_____\\\\/\\\\_\\\\/\\\\_\\\\ \\\\ \\\\_\\\\ \\\\ \\\\_____\\\\ \\\\_\\\\\\\\\\\"\\\\_\\\\ \\\\____-\\\\ \\\\_\\\\ \\\\_\\\\ \\\\_____\\\\ \\\\_____\\\\ \\\\_____\\\\\\n *   \\\\/_____/\\\\/_/\\\\/_/  \\\\/_/  \\\\/_____/\\\\/_/ \\\\/_/\\\\/____/ \\\\/_/\\\\/_/\\\\/_____/\\\\/_____/\\\\/_____/\\n *\\n *  Core module for the Extendable framework\\n *  \\n *  Inherit this contract to make your contracts Extendable!\\n *\\n *  Your contract can perform ad-hoc addition or removal of functions\\n *  which allows modularity, re-use, upgrade, and extension of your\\n *  deployed contracts. You can make your contract immutable by removing\\n *  the ability for it to be extended.\\n *\\n *  Constructor initialises owner-based permissioning to manage\\n *  extending, where only the `owner` can extend the contract.\\n *  \\n *  You may change this constructor or use extension replacement to\\n *  use a different permissioning pattern for your contract.\\n *\\n *  Requirements:\\n *      - ExtendLogic contract must already be deployed\\n */\\ncontract Extendable {\\n    /**\\n     * @dev Contract constructor initialising the first extension `ExtendLogic`\\n     *      to allow the contract to be extended.\\n     *\\n     * This implementation assumes that the `ExtendLogic` being used also uses\\n     * an ownership pattern that only allows `owner` to extend the contract.\\n     * \\n     * This constructor sets the owner of the contract and extends itself\\n     * using the ExtendLogic extension.\\n     *\\n     * To change owner or ownership mode, your contract must be extended with the\\n     * PermissioningLogic extension, giving it access to permissioning management.\\n     */\\n    constructor(address extendLogic) {\\n        // wrap main constructor logic in pre/post fallback hooks for callstack registration\\n        _beforeFallback();\\n\\n        // extend extendable contract with the first extension: extend, using itself in low-level call\\n        (bool extendSuccess, ) = extendLogic.delegatecall(abi.encodeWithSignature(\\\"extend(address)\\\", extendLogic));\\n\\n        // check that initialisation tasks were successful\\n        require(extendSuccess, \\\"failed to initialise extension\\\");\\n\\n        _afterFallback();\\n    }\\n    \\n    /**\\n     * @dev Delegates function calls to the specified `delegatee`.\\n     *\\n     * Performs a delegatecall to the `delegatee` with the incoming transaction data\\n     * as the input and returns the result. The transaction data passed also includes \\n     * the function signature which determines what function is attempted to be called.\\n     * \\n     * If the `delegatee` returns a ExtensionNotImplemented error, the `delegatee` is\\n     * an extension that does not implement the function to be called.\\n     *\\n     * Otherwise, the function execution fails/succeeds as determined by the function \\n     * logic and returns as such.\\n     */\\n    function _delegate(address delegatee) internal virtual returns(bool) {\\n        _beforeFallback();\\n        \\n        bytes memory out;\\n        (bool success, bytes memory result) = delegatee.delegatecall(msg.data);\\n\\n        _afterFallback();\\n\\n        // copy all returndata to `out` once instead of duplicating copy for each conditional branch\\n        assembly {\\n            returndatacopy(out, 0, returndatasize())\\n        }\\n\\n        // if the delegatecall execution did not succeed\\n        if (!success) {\\n            // check if failure was due to an ExtensionNotImplemented error\\n            if (Errors.catchCustomError(result, ExtensionNotImplemented.selector)) {\\n                // cleanly return false if error is caught\\n                return false;\\n            } else {\\n                // otherwise revert, passing in copied full returndata\\n                assembly {\\n                    revert(out, returndatasize())\\n                }\\n            }\\n        } else {\\n            // otherwise end execution and return the copied full returndata\\n            assembly {\\n                return(out, returndatasize())\\n            }\\n        }\\n    }\\n    \\n    /**\\n     * @dev Internal fallback function logic that attempts to delegate execution\\n     *      to extension contracts\\n     *\\n     * Initially attempts to locate an interfaceId match with a function selector\\n     * which are extensions that house single functions (singleton extensions)\\n     *\\n     * If no implementations are found that match the requested function signature,\\n     * returns ExtensionNotImplemented error\\n     */\\n    function _fallback() internal virtual {\\n        ExtendableState storage state = ExtendableStorage._getState();\\n\\n        // if an extension exists that matches in the functionsig\\n        if (state.extensionContracts[msg.sig] != address(0x0)) {\\n            // call it\\n            _delegate(state.extensionContracts[msg.sig]);\\n        } else {                                                 \\n            revert ExtensionNotImplemented();\\n        }\\n    }\\n\\n    /**\\n     * @dev Default fallback function to catch unrecognised selectors.\\n     *\\n     * Used in order to perform extension lookups by _fallback().\\n     *\\n     * Core fallback logic sandwiched between caller context work.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n    \\n    /**\\n     * @dev Payable fallback function to catch unrecognised selectors with ETH payments.\\n     *\\n     * Used in order to perform extension lookups by _fallback().\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n    \\n    /**\\n     * @dev Virtual hook that is called before _fallback().\\n     */\\n    function _beforeFallback() internal virtual {\\n        CallerState storage state = CallerContextStorage._getState();\\n        state.callerStack.push(msg.sender);\\n    }\\n    \\n    /**\\n     * @dev Virtual hook that is called after _fallback().\\n     */\\n    function _afterFallback() internal virtual {\\n        CallerState storage state = CallerContextStorage._getState();\\n        state.callerStack.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"@violetprotocol/extendable/extensions/extend/IExtendLogic.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../Extension.sol\\\";\\nimport {ExtendableState, ExtendableStorage} from \\\"../../storage/ExtendableStorage.sol\\\";\\n\\n/**\\n * @dev Interface for ExtendLogic extension\\n*/\\ninterface IExtendLogic {\\n    /**\\n     * @dev Emitted when `extension` is successfully extended\\n     */\\n    event Extended(address extension);\\n    \\n    /**\\n     * @dev Emitted when extend() is called and contract owner has not been set\\n     */\\n    event OwnerInitialised(address newOwner);\\n\\n    /**\\n     * @dev Extend function to extend your extendable contract with new logic\\n     *\\n     * Integrate with ExtendableStorage to persist state\\n     *\\n     * Sets the known implementor of each function of `extension` as the current call context\\n     * contract.\\n     *\\n     * Emits `Extended` event upon successful extending.\\n     *\\n     * Requirements:\\n     *  - `extension` contract must implement EIP-165.\\n     *  - `extension` must inherit IExtension\\n     *  - Must record the `extension` by both its interfaceId and address\\n     *  - The functions of `extension` must not already be extended by another attached extension\\n    */\\n    function extend(address extension) external;\\n\\n    /**\\n     * @dev Returns a string-formatted representation of the full interface of the current\\n     *      Extendable contract as an interface named IExtended\\n     *\\n     * Expects `extension.getSolidityInterface` to return interface-compatible syntax with line-separated\\n     * function declarations including visibility, mutability and returns.\\n    */\\n    function getFullInterface() external view returns(string memory fullInterface);\\n\\n    /**\\n     * @dev Returns an array of interfaceIds that are currently implemented by the current\\n     *      Extendable contract\\n    */\\n    function getExtensionsInterfaceIds() external view returns(bytes4[] memory);\\n    /**\\n     * @dev Returns an array of function selectors that are currently implemented by the current\\n     *      Extendable contract\\n    */\\n    function getExtensionsFunctionSelectors() external view returns(bytes4[] memory);\\n\\n    /**\\n     * @dev Returns an array of all extension addresses that are currently attached to the\\n     *      current Extendable contract\\n    */\\n    function getExtensionAddresses() external view returns(address[] memory);\\n}\\n\\n/**\\n * @dev Abstract Extension for ExtendLogic\\n*/\\nabstract contract ExtendExtension is IExtendLogic, Extension {\\n    /**\\n     * @dev see {IExtension-getSolidityInterface}\\n    */\\n    function getSolidityInterface() override virtual public pure returns(string memory) {\\n        return  \\\"function extend(address extension) external;\\\\n\\\"\\n                \\\"function getFullInterface() external view returns(string memory);\\\\n\\\"\\n                \\\"function getExtensionsInterfaceIds() external view returns(bytes4[] memory);\\\\n\\\"\\n                \\\"function getExtensionsFunctionSelectors() external view returns(bytes4[] memory);\\\\n\\\"\\n                \\\"function getExtensionAddresses() external view returns(address[] memory);\\\\n\\\";\\n    }\\n\\n    /**\\n     * @dev see {IExtension-getInterface}\\n    */\\n    function getInterface() override virtual public pure returns(Interface[] memory interfaces) {\\n        interfaces = new Interface[](1);\\n\\n        bytes4[] memory functions = new bytes4[](5);\\n        functions[0] = IExtendLogic.extend.selector;\\n        functions[1] = IExtendLogic.getFullInterface.selector;\\n        functions[2] = IExtendLogic.getExtensionsInterfaceIds.selector;\\n        functions[3] = IExtendLogic.getExtensionsFunctionSelectors.selector;\\n        functions[4] = IExtendLogic.getExtensionAddresses.selector;\\n\\n        interfaces[0] = Interface(\\n            type(IExtendLogic).interfaceId,\\n            functions\\n        );\\n    }\\n}\"\r\n    },\r\n    \"@violetprotocol/erc721extendable/contracts/storage/ERC721Storage.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nstruct ERC721State {\\n    // Token name\\n    string _name;\\n    // Token symbol\\n    string _symbol;\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) _owners;\\n    // Mapping owner address to token count\\n    mapping(address => uint256) _balances;\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) _tokenApprovals;\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) _operatorApprovals;\\n}\\n\\nlibrary ERC721Storage {\\n    bytes32 constant STORAGE_NAME = keccak256(\\\"extendable:erc721:base\\\");\\n\\n    function _getState() internal view returns (ERC721State storage erc721State) {\\n        bytes32 position = keccak256(abi.encodePacked(address(this), STORAGE_NAME));\\n        assembly {\\n            erc721State.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@violetprotocol/extendable/errors/Errors.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev  ExtensionNotImplemented error is emitted by Extendable and Extensions\\n *       where no implementation for a specified function signature exists\\n *       in the contract\\n*/\\nerror ExtensionNotImplemented();\\n\\n\\n/**\\n * @dev  Utility library for contracts to catch custom errors\\n *       Pass in a return `result` from a call, and the selector for your error message\\n *       and the `catchCustomError` function will return `true` if the error was found\\n *       or `false` otherwise\\n*/\\nlibrary Errors {\\n    function catchCustomError(bytes memory result, bytes4 errorSelector) internal pure returns(bool) {\\n        bytes4 caught;\\n        assembly {\\n            caught := mload(add(result, 0x20))\\n        }\\n\\n        return caught == errorSelector;\\n    }\\n}\"\r\n    },\r\n    \"@violetprotocol/extendable/storage/CallerContextStorage.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nstruct CallerState {\\n    // Stores a list of callers in the order they are received\\n    // The current caller context is always the last-most address\\n    address[] callerStack;\\n}\\n\\nlibrary CallerContextStorage {\\n    bytes32 constant private STORAGE_NAME = keccak256(\\\"extendable.framework.v1:caller-state\\\");\\n\\n    function _getState()\\n        internal \\n        view\\n        returns (CallerState storage callerState) \\n    {\\n        bytes32 position = keccak256(abi.encodePacked(address(this), STORAGE_NAME));\\n        assembly {\\n            callerState.slot := position\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@violetprotocol/extendable/storage/ExtendableStorage.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Storage struct used to hold state for Extendable contracts\\n */\\nstruct ExtendableState {\\n    // Array of full interfaceIds extended by the Extendable contract instance\\n    bytes4[] implementedInterfaceIds;\\n\\n    // Array of function selectors extended by the Extendable contract instance\\n    mapping(bytes4 => bytes4[]) implementedFunctionsByInterfaceId;\\n\\n    // Mapping of interfaceId/functionSelector to the extension address that implements it\\n    mapping(bytes4 => address) extensionContracts;\\n}\\n\\n/**\\n * @dev Storage library to access storage slot for the state struct\\n */\\nlibrary ExtendableStorage {\\n    bytes32 constant private STORAGE_NAME = keccak256(\\\"extendable.framework.v1:extendable-state\\\");\\n\\n    function _getState()\\n        internal \\n        view\\n        returns (ExtendableState storage extendableState) \\n    {\\n        bytes32 position = keccak256(abi.encodePacked(address(this), STORAGE_NAME));\\n        assembly {\\n            extendableState.slot := position\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@violetprotocol/extendable/extensions/Extension.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IExtension.sol\\\";\\nimport \\\"../errors/Errors.sol\\\";\\nimport \\\"../utils/CallerContext.sol\\\";\\nimport \\\"../erc165/IERC165Logic.sol\\\";\\n\\n/**\\n *  ______  __  __  ______  ______  __   __  _____   ______  ______  __      ______    \\n * /\\\\  ___\\\\/\\\\_\\\\_\\\\_\\\\/\\\\__  _\\\\/\\\\  ___\\\\/\\\\ \\\"-.\\\\ \\\\/\\\\  __-./\\\\  __ \\\\/\\\\  == \\\\/\\\\ \\\\    /\\\\  ___\\\\\\n * \\\\ \\\\  __\\\\\\\\/_/\\\\_\\\\/\\\\/_/\\\\ \\\\/\\\\ \\\\  __\\\\\\\\ \\\\ \\\\-.  \\\\ \\\\ \\\\/\\\\ \\\\ \\\\  __ \\\\ \\\\  __<\\\\ \\\\ \\\\___\\\\ \\\\  __\\\\\\n *  \\\\ \\\\_____\\\\/\\\\_\\\\/\\\\_\\\\ \\\\ \\\\_\\\\ \\\\ \\\\_____\\\\ \\\\_\\\\\\\\\\\"\\\\_\\\\ \\\\____-\\\\ \\\\_\\\\ \\\\_\\\\ \\\\_____\\\\ \\\\_____\\\\ \\\\_____\\\\\\n *   \\\\/_____/\\\\/_/\\\\/_/  \\\\/_/  \\\\/_____/\\\\/_/ \\\\/_/\\\\/____/ \\\\/_/\\\\/_/\\\\/_____/\\\\/_____/\\\\/_____/\\n *\\n *  Base contract for Extensions in the Extendable Framework\\n *  \\n *  Inherit and implement this contract to create Extension contracts!\\n *\\n *  Implements the EIP-165 standard for interface detection of implementations during runtime.\\n *  Uses the ERC165 singleton pattern where the actual implementation logic of the interface is\\n *  deployed in a separate contract. See ERC165Logic. Deterministic deployment guarantees the\\n *  ERC165Logic contract to always exist as static address 0x16C940672fA7820C36b2123E657029d982629070\\n *\\n *  Define your custom Extension interface and implement it whilst inheriting this contract:\\n *      contract YourExtension is IYourExtension, Extension {...}\\n *\\n */\\nabstract contract Extension is CallerContext, IExtension, IERC165, IERC165Register {\\n    address constant ERC165LogicAddress = 0x16C940672fA7820C36b2123E657029d982629070;\\n\\n    /**\\n     * @dev Constructor registers your custom Extension interface under EIP-165:\\n     *      https://eips.ethereum.org/EIPS/eip-165\\n    */\\n    constructor() {\\n        Interface[] memory interfaces = getInterface();\\n        for (uint256 i = 0; i < interfaces.length; i++) {\\n            Interface memory iface = interfaces[i];\\n            registerInterface(iface.interfaceId);\\n\\n            for (uint256 j = 0; j < iface.functions.length; j++) {\\n                registerInterface(iface.functions[j]);\\n            }\\n        }\\n\\n        registerInterface(type(IExtension).interfaceId);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) external override virtual returns(bool) {\\n        (bool success, bytes memory result) = ERC165LogicAddress.delegatecall(abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", interfaceId));\\n\\n        if (!success) {\\n            assembly {\\n                revert(result, returndatasize())\\n            }\\n        }\\n\\n        return abi.decode(result, (bool));\\n    }\\n\\n    function registerInterface(bytes4 interfaceId) public override virtual {\\n        (bool success, ) = ERC165LogicAddress.delegatecall(abi.encodeWithSignature(\\\"registerInterface(bytes4)\\\", interfaceId));\\n\\n        if (!success) {\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unidentified function signature calls to any Extension reverts with\\n     *      ExtensionNotImplemented error\\n    */\\n    function _fallback() internal virtual {\\n        revert ExtensionNotImplemented();\\n    }\\n\\n    /**\\n     * @dev Fallback function passes to internal _fallback() logic\\n    */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n    \\n    /**\\n     * @dev Payable fallback function passes to internal _fallback() logic\\n    */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Virtual override declaration of getFunctionSelectors() function to silence compiler\\n     *\\n     * Must be implemented in inherited contract.\\n    */\\n    function getInterface() override public virtual returns(Interface[] memory);\\n}\"\r\n    },\r\n    \"@violetprotocol/extendable/extensions/IExtension.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nstruct Interface {\\n    bytes4 interfaceId;\\n    bytes4[] functions;\\n}\\n\\n/**\\n * @dev Interface for Extension\\n*/\\ninterface IExtension {\\n    /**\\n     * @dev Returns a full view of the functional interface of the extension\\n     *\\n     * Must return a list of the functions in the interface of your custom Extension\\n     * in the same format and syntax as in the interface itself as a string, \\n     * escaped-newline separated.\\n     *\\n     * OPEN TO SUGGESTIONS FOR IMPROVEMENT ON THIS METHODOLOGY FOR \\n     * DEEP DESCRIPTIVE RUNTIME INTROSPECTION\\n     *\\n     * Intent is to allow developers that want to integrate with an Extendable contract\\n     * that will have a constantly evolving interface, due to the nature of Extendables,\\n     * to be able to easily inspect and query for the current state of the interface and\\n     * integrate with it.\\n     *\\n     * See {ExtendLogic-getSolidityInterface} for an example.\\n    */\\n    function getSolidityInterface() external pure returns(string memory);\\n\\n    /**\\n     * @dev Returns the interface IDs that are implemented by the Extension\\n     *\\n     * These are full interface IDs and ARE NOT function selectors. Full interface IDs are\\n     * XOR'd function selectors of an interface. For example the interface ID of the ERC721\\n     * interface is 0x80ac58cd determined by the XOR or all function selectors of the interface.\\n     * \\n     * If an interface only consists of a single function, then the interface ID is identical\\n     * to that function selector.\\n     * \\n     * Provides a simple abstraction from the developer for any custom Extension to \\n     * be EIP-165 compliant out-of-the-box simply by implementing this function. \\n     *\\n     * Excludes any functions either already described by other interface definitions\\n     * that are not developed on top of this backbone i.e. EIP-165, IExtension\\n    */\\n    function getInterface() external returns(Interface[] memory interfaces);\\n}\"\r\n    },\r\n    \"@violetprotocol/extendable/utils/CallerContext.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {CallerState, CallerContextStorage} from \\\"../storage/CallerContextStorage.sol\\\";\\n\\n/**\\n * @dev CallerContext contract provides Extensions with proper caller-scoped contexts.\\n *      Inherit this contract with your Extension to make use of caller references.\\n *\\n * `msg.sender` may not behave as developer intends when using within Extensions as many\\n * calls may be exchanged between intra-contract extensions which result in a `msg.sender` as self.\\n * Instead of using `msg.sender`, replace it with \\n *      - `_lastExternalCaller()` for the most recent caller in the call chain that is external to this contract\\n *      - `_lastCaller()` for the most recent caller\\n *\\n * CallerContext provides a deep callstack to track the caller of the Extension/Extendable contract\\n * at any point in the execution cycle.\\n *\\n*/\\ncontract CallerContext {\\n    /**\\n     * @dev Returns the most recent caller of this contract that came from outside this contract.\\n     *\\n     * Used by extensions that require fetching msg.sender that aren't cross-extension calls.\\n     * Cross-extension calls resolve msg.sender as the current contract and so the actual\\n     * caller context is obfuscated.\\n     * \\n     * This function should be used in place of `msg.sender` where external callers are read.\\n     */\\n    function _lastExternalCaller() internal view returns(address) {\\n        CallerState storage state = CallerContextStorage._getState();\\n\\n        for (uint i = state.callerStack.length - 1; i >= 0; i--) {\\n            address lastSubsequentCaller = state.callerStack[i];\\n            if (lastSubsequentCaller != address(this)) {\\n                return lastSubsequentCaller;\\n            }\\n        }\\n\\n        revert(\\\"_lastExternalCaller: end of stack\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the most recent caller of this contract.\\n     *\\n     * Last caller may also be the current contract.\\n     *\\n     * If the call is directly to the contract, without passing an Extendable, return `msg.sender` instead\\n     */\\n    function _lastCaller() internal view returns(address) {\\n        CallerState storage state = CallerContextStorage._getState();\\n        if (state.callerStack.length > 0)\\n            return state.callerStack[state.callerStack.length - 1];\\n        else\\n            return msg.sender;\\n    }\\n}\"\r\n    },\r\n    \"@violetprotocol/extendable/erc165/IERC165Logic.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external returns (bool);\\n}\\n\\n\\n/**\\n * @dev Storage based implementation of the {IERC165} interface.\\n *\\n * Uses Extendable storage pattern to populate the registered interfaces storage variable.\\n */\\ninterface IERC165Register {\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function registerInterface(bytes4 interfaceId) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"extendLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"approveLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"getterLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"onReceiveLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"transferLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"hooksLogic\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ExtensionNotImplemented\",\"type\":\"error\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"metadataGetterLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"setTokenURILogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mintLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"burnLogic\",\"type\":\"address\"}],\"name\":\"finaliseERC721MetadataExtending\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HumanboundToken", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000d1e7ac631052552348c755474034de66785dff13000000000000000000000000267ab9245a056730c92a54f447b1522ee7412ad4000000000000000000000000e7d118354e726f1cd1e004a2db90b771adba3588000000000000000000000000ef8894089c991cf9c009cd66f7f2fb9dc0e2fb190000000000000000000000006f474fd17c1b34e88ece3fa6a37da6d2363b34f0000000000000000000000000623afecba4800ddbdabeab56a4843797cf3a0b51000000000000000000000000000000000000000000000000000000000000001048756d616e626f756e6420546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034842540000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xf8f1257afd2a8a3f3dfd60bd51b35223ba4c4763", "SwarmSource": ""}