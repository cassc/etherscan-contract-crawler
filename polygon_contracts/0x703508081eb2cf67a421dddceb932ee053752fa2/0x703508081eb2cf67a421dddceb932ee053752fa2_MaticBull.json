{"SourceCode": "/**\r\n *Submitted for verification at polygonscan.com on 2023-06-10\r\n*/\r\n\r\n/**\r\n *Submitted for verification at polygonscan.com on 2023-06-07\r\n*/\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);   \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom( address sender, address recipient,uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner,address indexed spender,uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n \r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash= 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount,\"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success,\"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n\r\n    function functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n \r\n    function functionCallWithValue( address target,bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue( target, data, value,\"Address: low-level call with value failed\");\r\n    }\r\n\r\n\r\n    function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require( address(this).balance >= value,\"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue( address target, bytes memory data, uint256 weiValue,string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    function owner() public view returns (address) {\r\n    return _owner;\r\n    }\r\n\r\n    function setOwner(address newOwner) internal {\r\n        _owner = newOwner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_msgSender() == _owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0),\"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        setOwner(newOwner);\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n    require(!paused, \"Pausable: paused\");\r\n    _;\r\n    }\r\n\r\n\r\n    function pause() external onlyOwner {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n \r\n    function unpause() external onlyOwner {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n\r\n\r\n}\r\n\r\nabstract contract Initializable {\r\n\r\n    bool private _initialized;\r\n\r\n    bool private _initializing;\r\n\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract MaticBull is  Ownable, Pausable, Initializable {\r\n\r\n\r\n    uint public INIT_PRICE;\r\n    uint public FACTOR; \r\n    uint public  BASEPRICE;\r\n    uint public CALPRICE;\r\n    uint public  FACTOR_DIVIDER;\r\n    uint public totalSupply;\r\n    uint public decimal;\r\n    uint256 public totalBalance;\r\n    string public name;\r\n    string public symbol;\r\n\r\n     struct User {\r\n        uint id;\r\n        uint256 balancetoken;\r\n         uint256 lasttrdate;\r\n     }\r\n     \r\n     address payable  public  devwallet;\r\n     mapping(address => User) public users;\r\n    mapping(uint => address) public idToAddress;\r\n    mapping(address => uint256) internal balances;\r\n   uint public lastUserId = 2;\r\n    event Buy( address indexed investor,uint256 amountBuy,uint256 tokenPrice);\r\n    event Selltoken( address indexed  user , uint maticAmt, uint price, uint tokenAmt);\r\n    event LevelUpgrade(address indexed investor,uint256 amountBuy,uint256 tokenPrice);\r\n    event Registration(address indexed investor,string referrer,string referrerId,uint256 package,uint256 tokenPrice,uint256 tokenQty);\r\n\r\n    function initialize(address payable _owner,uint _totalSupply) external initializer {\r\n        INIT_PRICE = 1000000000;\r\n        FACTOR = 10; \r\n        BASEPRICE = 1000000000;\r\n        CALPRICE = 90000000;\r\n        FACTOR_DIVIDER = 100;\r\n        totalSupply = _totalSupply*10**18;\r\n        setOwner(_owner);\r\n        balances[address(this)] = (_totalSupply*10**18);\r\n        totalBalance=0;\r\n        decimal = 18;\r\n        name = \"MaticBull\";\r\n        symbol = \"MTB\";\r\n        users[_owner].balancetoken=0;\r\n        users[_owner].id=1;\r\n        idToAddress[1] = _owner;\r\n        users[_owner].lasttrdate=0;\r\n        devwallet=_owner;\r\n    }\r\n\r\n    function price() public  view returns (uint) {\r\n        return (INIT_PRICE+(((INIT_PRICE*(totalBalance))*FACTOR)/FACTOR_DIVIDER)/1e18);\r\n    }\r\n\r\n    function balanceOf(address user) external view returns (uint) {\r\n        return balances[user];\r\n    }\r\n\r\n    function registration(string memory refadd,string memory _referrerId,uint mmtAmount ) public payable {\r\n       require (msg.value>=mmtAmount,\"Invalid Amount\");\r\n       require(mmtAmount>=10*1e18,\"Invalid Amount\");\r\n       require(!isUserExists(msg.sender), \"User Exist\");\r\n        uint _price = INIT_PRICE;\r\n        uint tokenQty =((mmtAmount*1e18)*25/100)/_price;\r\n        totalBalance+= (mmtAmount*25/100);\r\n        users[msg.sender].balancetoken=tokenQty;\r\n        users[msg.sender].id=lastUserId;\r\n        users[msg.sender].lasttrdate=block.timestamp;\r\n        idToAddress[1] = msg.sender;\r\n        address owner=owner();\r\n        payable(owner).transfer(mmtAmount);\r\n        emit Registration(msg.sender,refadd,_referrerId,msg.value,_price,tokenQty);\r\n        lastUserId++;\r\n        uint256 effprice=((mmtAmount*CALPRICE)/1e18);\r\n        INIT_PRICE += effprice;\r\n   \t}\r\n\r\n    function upgradelevel(uint mmtAmount ) public payable {\r\n       require (msg.value>=mmtAmount,\"Invalid Amount\");\r\n       require(isUserExists(msg.sender), \"User Not Exist\");\r\n        uint _price = INIT_PRICE;\r\n        uint tokenQty =((mmtAmount*1e18)*25/100)/_price;\r\n        totalBalance+= (mmtAmount*25/100);\r\n        users[msg.sender].balancetoken+=tokenQty;\r\n        address owner=owner();\r\n        payable(owner).transfer(mmtAmount);\r\n        emit LevelUpgrade(msg.sender,tokenQty,_price);\r\n        uint256 effprice=((mmtAmount*CALPRICE)/1e18);\r\n        INIT_PRICE += effprice;\r\n   \t}\r\n    function buytoken(uint mmtAmount ) public payable {\r\n       require (msg.value>=mmtAmount,\"Invalid Amount\");\r\n       require(isUserExists(msg.sender), \"User Not Exist\");\r\n        uint _price = INIT_PRICE;\r\n        uint tokenQty =(mmtAmount*1e18)/_price;\r\n        totalBalance+= mmtAmount;\r\n        users[msg.sender].balancetoken+=tokenQty;\r\n        address owner=owner();\r\n        payable(owner).transfer(mmtAmount);\r\n        emit Buy(msg.sender,tokenQty,_price);\r\n        uint256 effprice=((mmtAmount*CALPRICE)/1e18);\r\n        INIT_PRICE += effprice;\r\n   \t}\r\n\r\n    function withdrawla(uint tokenQty ) public payable {\r\n        require(isUserExists(msg.sender), \"User Not Exist\");\r\n        require(users[msg.sender].balancetoken>=tokenQty,\"Insufficient token Balance\");\r\n        uint256 lastdt=users[msg.sender].lasttrdate;\r\n        uint256 currentdt=block.timestamp;\r\n        uint256 getdate=lastdt+24 hours;\r\n        require(currentdt>getdate,\"Transaction Not Allow\");\r\n        uint256 getBal=users[msg.sender].balancetoken;\r\n        uint256 allowWith=getBal*3/100;\r\n        uint256 minAmt=getBal*1/100;\r\n        require(tokenQty<=allowWith,\"Maximum Withdrawl is 3%\");\r\n        require(tokenQty>=minAmt,\"Minimum Withdrawl is 1%\");\r\n        if(currentdt>getdate && tokenQty<=allowWith && tokenQty>=minAmt)\r\n        {\r\n            uint _price = INIT_PRICE;\r\n            uint maticAmt =((tokenQty*_price)/1e18);\r\n            totalBalance-= maticAmt;\r\n            users[msg.sender].balancetoken-=tokenQty;\r\n            emit Selltoken(msg.sender,maticAmt,tokenQty,_price);\r\n            maticAmt = ((tokenQty*BASEPRICE)/1e18);\r\n            uint256 effprice=((maticAmt*CALPRICE)/1e18);\r\n            if(effprice<INIT_PRICE){\r\n            INIT_PRICE -= effprice;\r\n            } else {\r\n            INIT_PRICE = BASEPRICE;   \r\n            }\r\n        }\r\n   \t}\r\n\r\n    function isUserExists(address user) public view returns (bool) \r\n    {\r\n        return (users[user].id != 0);\r\n    }\r\n\r\n    function withdrawLost(uint256 WithAmt) public {\r\n        require(msg.sender == devwallet, \"onlyOwner\");\r\n        devwallet.transfer(WithAmt);\r\n    }\r\n    \r\n  \r\n\tfunction withdrawLostTokenFromBalance(uint256 QtyAmt,IERC20 _TOKEN) public \r\n\t{\r\n        require(msg.sender == devwallet, \"onlyOwner\");\r\n        _TOKEN.transfer(devwallet,QtyAmt);\r\n\t}\r\n\r\n    function SendMatic() public payable {\r\n    \r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"name\":\"LevelUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"referrer\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"referrerId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenQty\",\"type\":\"uint256\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maticAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmt\",\"type\":\"uint256\"}],\"name\":\"Selltoken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASEPRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CALPRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FACTOR_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SendMatic\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mmtAmount\",\"type\":\"uint256\"}],\"name\":\"buytoken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devwallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"refadd\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_referrerId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"mmtAmount\",\"type\":\"uint256\"}],\"name\":\"registration\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mmtAmount\",\"type\":\"uint256\"}],\"name\":\"upgradelevel\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancetoken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lasttrdate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"WithAmt\",\"type\":\"uint256\"}],\"name\":\"withdrawLost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"QtyAmt\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_TOKEN\",\"type\":\"address\"}],\"name\":\"withdrawLostTokenFromBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenQty\",\"type\":\"uint256\"}],\"name\":\"withdrawla\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "MaticBull", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bb7bd822f232340d80aad09f4c9a965efbdda3a30afa3aad5ade60b0d0d53654"}