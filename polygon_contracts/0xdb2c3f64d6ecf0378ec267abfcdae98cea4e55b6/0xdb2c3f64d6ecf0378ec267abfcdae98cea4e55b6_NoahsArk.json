{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Bucket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.14;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"./DateTime.sol\\\";\\r\\n\\r\\ncontract Bucket {\\r\\n    using SafeMath for *;\\r\\n    using DateTime for uint256;\\r\\n    struct BucketStock {\\r\\n        mapping(uint => uint256) dailyTradeVolume;\\r\\n        mapping(uint => mapping(uint => uint256[24])) hourTradeVolume;\\r\\n        uint256 currentTotalVolume;\\r\\n        mapping(uint => uint256[45]) epochDaysVolume;\\r\\n        uint256 maxReturnRateOrderNum;\\r\\n        uint256 minReturnRateOrderNum;\\r\\n    }\\r\\n\\r\\n    uint256 public constant MAX_RETURN_RATE = 10000; // 1%\\r\\n    uint256 public constant MIN_RETURN_RATE = 6180; // 0.618%\\r\\n    uint256 public constant DAILY_GROWTH = 20000; // 2%\\r\\n    uint256 public constant MAX_VOLUME = 72e22; // 72W\\r\\n\\r\\n    uint256 public contractCreateTime;\\r\\n\\r\\n    BucketStock  ledgerBucketStock;\\r\\n\\r\\n    constructor(){\\r\\n        // initialize contract params\\r\\n        contractCreateTime = block.timestamp;\\r\\n        uint yesterdayTimestamp = DateTime.getYesterdayTimestamp(block.timestamp);\\r\\n        BucketStock storage bucketStock = ledgerBucketStock;\\r\\n        bucketStock.dailyTradeVolume[yesterdayTimestamp] = 12e22;\\r\\n    }\\r\\n\\r\\n    function _pickLocation(uint epoch, uint start, uint end) internal returns (uint){\\r\\n        BucketStock storage bucketStock = ledgerBucketStock;\\r\\n        uint minValueIndex = start;\\r\\n        for(uint i = start + 1; i < end; i++){\\r\\n            if(bucketStock.epochDaysVolume[epoch][i] < bucketStock.epochDaysVolume[epoch][minValueIndex]){\\r\\n                minValueIndex = i;\\r\\n            }\\r\\n        }\\r\\n        return minValueIndex;\\r\\n    }\\r\\n\\r\\n    function pickLocation(uint epoch) internal returns (uint){\\r\\n        BucketStock storage bucketStock = ledgerBucketStock;\\r\\n        uint256 rate = _getReturnRate(epoch);\\r\\n        uint start = 0;\\r\\n        uint end = 44;\\r\\n        if (rate == MAX_RETURN_RATE){\\r\\n            // 1. 0-14 50% 2. 15-29 40% 3. 30-44 10%\\r\\n            if (bucketStock.maxReturnRateOrderNum % 10 < 5){\\r\\n                start = 0;\\r\\n                end = 14;\\r\\n            }else if (bucketStock.maxReturnRateOrderNum % 10 < 9){\\r\\n                start = 15;\\r\\n                end = 29;\\r\\n            }else{\\r\\n                start = 30;\\r\\n                end = 44;\\r\\n            }\\r\\n            bucketStock.maxReturnRateOrderNum += 1;\\r\\n        } else {\\r\\n            // 1. 0-14 30% 2. 15-29 40% 3. 30-44 30%\\r\\n            if (bucketStock.minReturnRateOrderNum % 10 < 3){\\r\\n                start = 0;\\r\\n                end = 14;\\r\\n            }else if (bucketStock.minReturnRateOrderNum % 10 < 7){\\r\\n                start = 15;\\r\\n                end = 29;\\r\\n            }else{\\r\\n                start = 30;\\r\\n                end = 44;\\r\\n            }\\r\\n            bucketStock.minReturnRateOrderNum += 1;\\r\\n        }\\r\\n        return _pickLocation(epoch, start, end);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    *\\r\\n    */\\r\\n    function getReturnRate(uint epoch) external view returns (uint256 rate) {\\r\\n        (rate) = _getReturnRate(epoch);\\r\\n    }\\r\\n\\r\\n    function _getReturnRate(uint epoch) internal view returns (uint256) {\\r\\n        BucketStock storage bucketStock = ledgerBucketStock;\\r\\n        if (bucketStock.currentTotalVolume >= MAX_VOLUME) {\\r\\n            return MIN_RETURN_RATE;\\r\\n        }\\r\\n        uint yesterdayTimestamp = DateTime.getYesterdayTimestamp(block.timestamp);\\r\\n        uint256 todayTarget = bucketStock.dailyTradeVolume[yesterdayTimestamp].mul(DAILY_GROWTH).div(1000000);\\r\\n        uint256 hourTarget = todayTarget.div(24);\\r\\n        uint hour = DateTime.getHour(block.timestamp);\\r\\n        uint timestamp = DateTime.getTodayTimestamp(block.timestamp);\\r\\n        uint256 currentSales = bucketStock.hourTradeVolume[epoch][timestamp][hour];\\r\\n        if (currentSales >= hourTarget) {\\r\\n            return MIN_RETURN_RATE;\\r\\n        } else {\\r\\n            return MAX_RETURN_RATE;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: nv3ob61\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nlibrary DateTime {\\r\\n    /*\\r\\n     *  Date and Time utilities for ethereum contracts\\r\\n     *\\r\\n     */\\r\\n    struct _DateTime {\\r\\n        uint16 year;\\r\\n        uint8 month;\\r\\n        uint8 day;\\r\\n        uint8 hour;\\r\\n        uint8 minute;\\r\\n        uint8 second;\\r\\n        uint8 weekday;\\r\\n    }\\r\\n\\r\\n    uint constant DAY_IN_SECONDS = 86400;\\r\\n    uint constant YEAR_IN_SECONDS = 31536000;\\r\\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\\r\\n\\r\\n    uint constant MAX_TIMESTAMP = 5175273600;  // years, months, days\\r\\n    uint constant MIN_TIMESTAMP = 0; // Epoch\\r\\n\\r\\n    uint constant HOUR_IN_SECONDS = 3600;\\r\\n    uint constant MINUTE_IN_SECONDS = 60;\\r\\n\\r\\n    uint16 constant ORIGIN_YEAR = 1970;\\r\\n\\r\\n    uint16 constant nonce = 0;\\r\\n\\r\\n    function isLeapYear(uint16 year) public pure returns (bool) {\\r\\n        if (year % 4 != 0) {\\r\\n            return false;\\r\\n        }\\r\\n        if (year % 100 != 0) {\\r\\n            return true;\\r\\n        }\\r\\n        if (year % 400 != 0) {\\r\\n            return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function isDateInRange(uint timestamp) public pure returns (bool){\\r\\n        if (timestamp >= MIN_TIMESTAMP && timestamp <= MAX_TIMESTAMP) {\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function random() public view returns (uint) {\\r\\n        uint randomNumber = uint(keccak256(abi.encodePacked(block.timestamp, msg.sender))) % MAX_TIMESTAMP;\\r\\n        randomNumber = randomNumber + 100;\\r\\n        return randomNumber;\\r\\n    }\\r\\n\\r\\n    function leapYearsBefore(uint year) public pure returns (uint) {\\r\\n        year -= 1;\\r\\n        return year / 4 - year / 100 + year / 400;\\r\\n    }\\r\\n\\r\\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\\r\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\r\\n            return 31;\\r\\n        }\\r\\n        else if (month == 4 || month == 6 || month == 9 || month == 11) {\\r\\n            return 30;\\r\\n        }\\r\\n        else if (isLeapYear(year)) {\\r\\n            return 29;\\r\\n        }\\r\\n        else {\\r\\n            return 28;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function parseTimestamp(uint timestamp) internal pure returns (_DateTime memory dt) {\\r\\n        uint secondsAccountedFor = 0;\\r\\n        uint buf;\\r\\n        uint8 i;\\r\\n\\r\\n        // Year\\r\\n        dt.year = getYear(timestamp);\\r\\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\\r\\n\\r\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\\r\\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\\r\\n\\r\\n        // Month\\r\\n        uint secondsInMonth;\\r\\n        for (i = 1; i <= 12; i++) {\\r\\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\\r\\n            if (secondsInMonth + secondsAccountedFor > timestamp) {\\r\\n                dt.month = i;\\r\\n                break;\\r\\n            }\\r\\n            secondsAccountedFor += secondsInMonth;\\r\\n        }\\r\\n\\r\\n        // Day\\r\\n        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\\r\\n            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\\r\\n                dt.day = i;\\r\\n                break;\\r\\n            }\\r\\n            secondsAccountedFor += DAY_IN_SECONDS;\\r\\n        }\\r\\n\\r\\n        // Hour\\r\\n        dt.hour = getHour(timestamp);\\r\\n\\r\\n        // Minute\\r\\n        dt.minute = getMinute(timestamp);\\r\\n\\r\\n        // Second\\r\\n        dt.second = getSecond(timestamp);\\r\\n\\r\\n        // Day of week.\\r\\n        dt.weekday = getWeekday(timestamp);\\r\\n    }\\r\\n\\r\\n    function getYear(uint timestamp) public pure returns (uint16) {\\r\\n        uint secondsAccountedFor = 0;\\r\\n        uint16 year;\\r\\n        uint numLeapYears;\\r\\n\\r\\n        // Year\\r\\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\\r\\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\r\\n\\r\\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\\r\\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\\r\\n\\r\\n        while (secondsAccountedFor > timestamp) {\\r\\n            if (isLeapYear(uint16(year - 1))) {\\r\\n                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\\r\\n            }\\r\\n            else {\\r\\n                secondsAccountedFor -= YEAR_IN_SECONDS;\\r\\n            }\\r\\n            year -= 1;\\r\\n        }\\r\\n        return year;\\r\\n    }\\r\\n\\r\\n    function getMonth(uint timestamp) public pure returns (uint8) {\\r\\n        return parseTimestamp(timestamp).month;\\r\\n    }\\r\\n\\r\\n    function getDay(uint timestamp) public pure returns (uint8) {\\r\\n        return parseTimestamp(timestamp).day;\\r\\n    }\\r\\n\\r\\n    function getTodayTimestamp(uint timestamp) public pure returns (uint){\\r\\n        _DateTime memory dt = parseTimestamp(timestamp);\\r\\n        return toTimestamp(dt.year, dt.month, dt.day);\\r\\n    }\\r\\n\\r\\n    function getYesterdayTimestamp(uint timestamp) public pure returns (uint){\\r\\n        _DateTime memory dt = parseTimestamp(timestamp-86400);\\r\\n        return toTimestamp(dt.year, dt.month, dt.day);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * get day 12 periods 0-2 -> 1, 2-4 -> 2, 4-6 -> 3\\r\\n    */\\r\\n    function getDay12Periods(uint timestamp) public pure returns (uint){\\r\\n        uint hour = parseTimestamp(timestamp).hour;\\r\\n        if (hour == 0) return 1;\\r\\n        if (hour % 2 == 0) {\\r\\n            return hour / 2;\\r\\n        }\\r\\n        return uint8(hour / 2) + 1;\\r\\n    }\\r\\n\\r\\n    function getHour(uint timestamp) public pure returns (uint8) {\\r\\n        return uint8((timestamp / 60 / 60) % 24);\\r\\n    }\\r\\n\\r\\n    function getMinute(uint timestamp) public pure returns (uint8) {\\r\\n        return uint8((timestamp / 60) % 60);\\r\\n    }\\r\\n\\r\\n    function getSecond(uint timestamp) public pure returns (uint8) {\\r\\n        return uint8(timestamp % 60);\\r\\n    }\\r\\n\\r\\n    function getWeekday(uint timestamp) public pure returns (uint8) {\\r\\n        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\\r\\n    }\\r\\n\\r\\n    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\\r\\n        return toTimestamp(year, month, day, 0, 0, 0);\\r\\n    }\\r\\n\\r\\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\\r\\n        return toTimestamp(year, month, day, hour, 0, 0);\\r\\n    }\\r\\n\\r\\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\\r\\n        return toTimestamp(year, month, day, hour, minute, 0);\\r\\n    }\\r\\n\\r\\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\\r\\n        uint16 i;\\r\\n\\r\\n        // Year\\r\\n        for (i = ORIGIN_YEAR; i < year; i++) {\\r\\n            if (isLeapYear(i)) {\\r\\n                timestamp += LEAP_YEAR_IN_SECONDS;\\r\\n            }\\r\\n            else {\\r\\n                timestamp += YEAR_IN_SECONDS;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Month\\r\\n        uint8[12] memory monthDayCounts;\\r\\n        monthDayCounts[0] = 31;\\r\\n        if (isLeapYear(year)) {\\r\\n            monthDayCounts[1] = 29;\\r\\n        }\\r\\n        else {\\r\\n            monthDayCounts[1] = 28;\\r\\n        }\\r\\n        monthDayCounts[2] = 31;\\r\\n        monthDayCounts[3] = 30;\\r\\n        monthDayCounts[4] = 31;\\r\\n        monthDayCounts[5] = 30;\\r\\n        monthDayCounts[6] = 31;\\r\\n        monthDayCounts[7] = 31;\\r\\n        monthDayCounts[8] = 30;\\r\\n        monthDayCounts[9] = 31;\\r\\n        monthDayCounts[10] = 30;\\r\\n        monthDayCounts[11] = 31;\\r\\n\\r\\n        for (i = 1; i < month; i++) {\\r\\n            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\\r\\n        }\\r\\n\\r\\n        // Day\\r\\n        timestamp += DAY_IN_SECONDS * (day - 1);\\r\\n\\r\\n        // Hour\\r\\n        timestamp += HOUR_IN_SECONDS * (hour);\\r\\n\\r\\n        // Minute\\r\\n        timestamp += MINUTE_IN_SECONDS * (minute);\\r\\n\\r\\n        // Second\\r\\n        timestamp += second;\\r\\n\\r\\n        return timestamp;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/NoahsArk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.14;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"./Bucket.sol\\\";\\r\\n\\r\\ncontract NoahsArk is ReentrancyGuard, Bucket {\\r\\n    using SafeMath for *;\\r\\n    uint256 public constant PRINCIPAL_RATIO = 600000; // 60%\\r\\n    uint256 public constant INVEST_RATIO = 390000; // 39%\\r\\n    uint256 public constant PLATFORM_RATIO = 10000; // 1%\\r\\n    uint256 public constant REFERRER_RATIO = 60000; // 6%\\r\\n    uint256 public constant INCENTIVE_RATIO = 10000; // 1%\\r\\n    uint256 public constant PRICE_PRECISION = 1e6; // 100%\\r\\n\\r\\n    uint256 public constant MIN_INVEST = 5e19; // 50\\r\\n    uint256 public constant MAX_INVEST = 5e20; // 500\\r\\n\\r\\n    uint256 public constant TIME_UNIT = 1 days;\\r\\n\\r\\n    uint256 public constant MAX_SEARCH_DEPTH = 50;\\r\\n    uint256 public constant RANKED_INCENTIVE = 60;\\r\\n\\r\\n    address public platformAddress; // will be payment splitter contract address\\r\\n\\r\\n    uint256 public currentEpochs;\\r\\n\\r\\n    // round epoch => address => position index => position info\\r\\n    mapping(uint256 => mapping(address => PositionInfo[])) public roundLedgers;\\r\\n    //\\r\\n    mapping(uint256 => RoundInfo) public roundInfos;\\r\\n    //\\r\\n    mapping(address => UserRoundInfo[]) public userRoundsInfos;\\r\\n\\r\\n    mapping(address => UserGlobalInfo) public userGlobalInfos;\\r\\n\\r\\n    mapping(address => address[]) public children; // used for easily retrieve the referrer tree structure from front-end\\r\\n\\r\\n    // temp admin\\r\\n    address public tempAdmin;\\r\\n    address public operator;\\r\\n    bool public gamePaused;\\r\\n\\r\\n    struct FundTarget {\\r\\n        uint256 lastCheckTime;\\r\\n        uint256 amount;\\r\\n        uint256 achievedAmount;\\r\\n    }\\r\\n\\r\\n    struct UserGlobalInfo {\\r\\n        // referrer chain to record the referrer relationship\\r\\n        address referrer;\\r\\n        // referrer rearward vault\\r\\n        uint256 totalReferrerReward;\\r\\n        uint256 referrerRewardClaimed;\\r\\n        // boost credit\\r\\n        uint256 boostCredit;\\r\\n        // sales record\\r\\n        uint256 maxChildrenSales;\\r\\n        uint256 sales;\\r\\n        uint256 totalPositionAmount;\\r\\n        uint256 reportedSales;\\r\\n        uint8 salesLevel;\\r\\n    }\\r\\n\\r\\n    struct PositionInfo {\\r\\n        uint256 amount;\\r\\n        uint256 openTime;\\r\\n        uint256 expiryTime;\\r\\n        uint256 investReturnRate;\\r\\n        uint256 withdrawnAmount;\\r\\n        uint256 incentiveAmount;\\r\\n        uint256 investReturnAmount;\\r\\n        uint256 index;\\r\\n        bool incentiveClaimable;\\r\\n    }\\r\\n\\r\\n    struct LinkedPosition {\\r\\n        address user;\\r\\n        uint256 userPositionIndex;\\r\\n    }\\r\\n\\r\\n    struct RoundInfo {\\r\\n        FundTarget fundTarget;\\r\\n        uint256 totalPositionAmount; // total amount of all positions\\r\\n        uint256 currentPrincipalAmount; // current principal amount\\r\\n        uint256 currentInvestAmount; // current invest amount\\r\\n        uint256 totalPositionCount; // total count of all positions\\r\\n        uint256 currentPositionCount; // total count of all open positions\\r\\n        uint256 currentIncentiveAmount; // current incentive amount\\r\\n        uint256 incentiveSnapshot; // check total position of last N positions\\r\\n        uint256 head; // head of linked position for last N positions\\r\\n        mapping(uint256 => LinkedPosition) linkedPositions; // used for incentive track\\r\\n        mapping(address => uint256) ledgerRoundToUserRoundIndex; // this round index in userRoundsInfos\\r\\n        bool stopLoss; // default false means the round is running\\r\\n    }\\r\\n\\r\\n    struct UserRoundInfo {\\r\\n        uint256 epoch;\\r\\n        uint256 totalPositionAmount;\\r\\n        uint256 currentPrincipalAmount;\\r\\n        uint256 totalWithdrawnAmount;\\r\\n        uint256 totalIncentiveClaimedAmount;\\r\\n        uint256 totalClosedPositionCount;\\r\\n        uint256 returnRateBoostedAmount;\\r\\n    }\\r\\n\\r\\n    struct ReferrerSearch {\\r\\n        uint256 currentUserSales;\\r\\n        uint256 currentReferrerSales;\\r\\n        address currentReferrer;\\r\\n        uint256 currentReferrerAmount;\\r\\n        uint256 levelDiffAmount;\\r\\n        uint256 leftLevelDiffAmount;\\r\\n        uint256 levelDiffAmountPerLevel;\\r\\n        uint256 levelSearchAmount;\\r\\n        uint256 leftLevelSearchAmount;\\r\\n        uint256 levelSearchAmountPerReferrer;\\r\\n        uint256 levelSearchSales;\\r\\n        uint256 currentReferrerMaxChildSales;\\r\\n        uint256 currentUserTotalPosAmount;\\r\\n        uint256 currentUserReportedSales;\\r\\n        address currentUser;\\r\\n        uint8 depth;\\r\\n        uint8 levelSearchStep;\\r\\n        uint8 currentLevelDiff;\\r\\n        uint8 numLevelSearchCandidate;\\r\\n        uint8 baseSalesLevel;\\r\\n        uint8 currentReferrerLevel;\\r\\n        bool levelDiffDone;\\r\\n        bool levelSearchDone;\\r\\n        bool levelSalesDone;\\r\\n    }\\r\\n\\r\\n    struct OpenPositionParams {\\r\\n        uint256 principalAmount;\\r\\n        uint256 investAmount;\\r\\n        uint256 referrerAmount;\\r\\n        uint256 incentiveAmount;\\r\\n        uint256 investReturnRate;\\r\\n    }\\r\\n\\r\\n    event PositionOpened(\\r\\n        address indexed user,\\r\\n        uint256 indexed epoch,\\r\\n        uint256 positionIndex,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    event PositionClosed(\\r\\n        address indexed user,\\r\\n        uint256 indexed epoch,\\r\\n        uint256 positionIndex,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    event NewReferrer(address indexed user, address indexed referrer);\\r\\n    event NewRound(uint256 indexed epoch);\\r\\n    event ReferrerRewardAdded(address indexed user, uint256 amount, uint256 indexed rewardType);\\r\\n    event ReferrerRewardClaimed(address indexed user, uint256 amount);\\r\\n    event SalesLevelUpdated(address indexed user, uint8 level);\\r\\n    event IncentiveClaimed(address indexed user, uint256 amount);\\r\\n\\r\\n    modifier notContract() {\\r\\n        require(msg.sender == tx.origin, \\\"Contract not allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _platformAddress The address of the platform\\r\\n     * @param _tempAdmin The address of the temp admin\\r\\n     * @param _operator The address of the operator\\r\\n     */\\r\\n    constructor(\\r\\n        address _platformAddress,\\r\\n        address _tempAdmin,\\r\\n        address _operator\\r\\n    ) {\\r\\n        require(\\r\\n            _platformAddress != address(0) && _tempAdmin != address(0) && _operator != address(0),\\r\\n            \\\"Invalid address provided\\\"\\r\\n        );\\r\\n        emit NewRound(0);\\r\\n\\r\\n        tempAdmin = _tempAdmin;\\r\\n        operator = _operator;\\r\\n        platformAddress = _platformAddress;\\r\\n        gamePaused = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the game paused status\\r\\n     * @param _paused: The game paused status\\r\\n     */\\r\\n    function setPause(bool _paused) external {\\r\\n        require(msg.sender == operator, \\\"Only operator\\\");\\r\\n        // make sure the admin has dropped when game is unpaused\\r\\n        if (!_paused) {\\r\\n            require(tempAdmin == address(0), \\\"Temp admin not dropped\\\");\\r\\n        }\\r\\n        gamePaused = _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer operator\\r\\n     */\\r\\n    function transferOperator(address _operator) external {\\r\\n        require(msg.sender == operator, \\\"Only operator\\\");\\r\\n        require(_operator != address(0), \\\"Invalid address\\\");\\r\\n        operator = _operator;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Drop the temp admin privilege\\r\\n     */\\r\\n    function dropTempAdmin() external {\\r\\n        require(msg.sender == tempAdmin, \\\"Only admin\\\");\\r\\n        tempAdmin = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Batch set referrer information for users\\r\\n     * @param users: The users to set\\r\\n     * @param referrers: The referrers to set\\r\\n     * @param salesLevels: The sales levels to set\\r\\n     */\\r\\n    function batchSetReferrerInfo(\\r\\n        address[] calldata users,\\r\\n        address[] calldata referrers,\\r\\n        uint8[] calldata salesLevels\\r\\n    ) external {\\r\\n        require(msg.sender == tempAdmin, \\\"Only admin\\\");\\r\\n        require(users.length == referrers.length && users.length == salesLevels.length, \\\"Invalid input\\\");\\r\\n        UserGlobalInfo storage userGlobalInfo;\\r\\n        uint256 userLength = users.length;\\r\\n        for (uint256 i = 0; i < userLength; ++i) {\\r\\n            require(users[i] != address(0), \\\"Invalid address provided\\\");\\r\\n            userGlobalInfo = userGlobalInfos[users[i]];\\r\\n            require(userGlobalInfo.referrer == address(0), \\\"Referrer already set\\\");\\r\\n            userGlobalInfo.referrer = referrers[i];\\r\\n            userGlobalInfo.salesLevel = salesLevels[i];\\r\\n            children[referrers[i]].push(users[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Open a new position\\r\\n     * @param targetEpoch: The target epoch to open\\r\\n     * @param referrer: The expected referrer\\r\\n     */\\r\\n    function openPosition(\\r\\n        uint256 targetEpoch,\\r\\n        address referrer\\r\\n    ) external payable notContract nonReentrant {\\r\\n        require(targetEpoch == currentEpochs, \\\"Invalid epoch\\\");\\r\\n        require(msg.value >= MIN_INVEST, \\\"Too small\\\");\\r\\n        require(msg.value <= MAX_INVEST, \\\"Too large\\\");\\r\\n        require(!gamePaused, \\\"Paused\\\");\\r\\n\\r\\n        // load user global info\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\r\\n        // load global round info\\r\\n        RoundInfo storage roundInfo = roundInfos[targetEpoch];\\r\\n        // placeholder for user round info\\r\\n        UserRoundInfo storage userRoundInfo;\\r\\n\\r\\n        // determine referrer\\r\\n        {\\r\\n            address _referrer = userGlobalInfo.referrer;\\r\\n            // if referrer is already set or msg.sender is the root user whose referrer is address(0)\\r\\n            if (_referrer == address(0) && children[msg.sender].length == 0) {\\r\\n                // if referrer is not set, set it and make sure it is a valid referrer\\r\\n                require(referrer != address(0) && referrer != msg.sender, \\\"Invalid referrer\\\");\\r\\n                // make sure referrer is registered already\\r\\n                require(\\r\\n                    userGlobalInfos[referrer].referrer != address(0) || children[referrer].length > 0,\\r\\n                    \\\"Invalid referrer\\\"\\r\\n                );\\r\\n\\r\\n                // update storage\\r\\n                userGlobalInfo.referrer = referrer;\\r\\n                children[referrer].push(msg.sender);\\r\\n                emit NewReferrer(msg.sender, referrer);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // calculate each part of the amount\\r\\n        OpenPositionParams memory params = OpenPositionParams({\\r\\n            principalAmount: (msg.value * PRINCIPAL_RATIO) / PRICE_PRECISION,\\r\\n            investAmount: (msg.value * INVEST_RATIO) / PRICE_PRECISION,\\r\\n            referrerAmount: (msg.value * REFERRER_RATIO) / PRICE_PRECISION,\\r\\n            incentiveAmount: (msg.value * INCENTIVE_RATIO) / PRICE_PRECISION,\\r\\n            investReturnRate: _getReturnRate(currentEpochs)\\r\\n        });\\r\\n\\r\\n        // update user's current ledger and current round info\\r\\n        uint256 userRoundInfoLength = userRoundsInfos[msg.sender].length;\\r\\n        if (\\r\\n            userRoundInfoLength == 0 ||\\r\\n            userRoundsInfos[msg.sender][userRoundInfoLength - 1].epoch < targetEpoch\\r\\n        ) {\\r\\n            // this is users first position in this round of this ledger type\\r\\n            UserRoundInfo memory _userRoundInfo;\\r\\n            _userRoundInfo = UserRoundInfo({\\r\\n                epoch: targetEpoch,\\r\\n                totalPositionAmount: 0,\\r\\n                currentPrincipalAmount: 0,\\r\\n                totalWithdrawnAmount: 0,\\r\\n                totalIncentiveClaimedAmount: 0,\\r\\n                totalClosedPositionCount: 0,\\r\\n                returnRateBoostedAmount: 0\\r\\n            });\\r\\n            // push roundInfo to storage\\r\\n            userRoundsInfos[msg.sender].push(_userRoundInfo);\\r\\n            roundInfo.ledgerRoundToUserRoundIndex[msg.sender] = userRoundInfoLength;\\r\\n            userRoundInfoLength += 1;\\r\\n        }\\r\\n\\r\\n        // fetch back the roundInfo from storage for further direct modification\\r\\n        userRoundInfo = userRoundsInfos[msg.sender][userRoundInfoLength - 1];\\r\\n        userRoundInfo.totalPositionAmount += msg.value;\\r\\n        userRoundInfo.currentPrincipalAmount += params.principalAmount;\\r\\n\\r\\n        // default use boost\\r\\n        {\\r\\n            uint256 boostCredit = userGlobalInfo.boostCredit;\\r\\n            if (boostCredit >= msg.value) {\\r\\n                params.investReturnRate = params.investReturnRate * 2;\\r\\n                userGlobalInfo.boostCredit -= msg.value;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // update ledger round info\\r\\n        roundInfo.totalPositionAmount += msg.value;\\r\\n        roundInfo.currentPrincipalAmount += params.principalAmount;\\r\\n        roundInfo.currentInvestAmount += params.investAmount;\\r\\n        roundInfo.currentPositionCount += 1;\\r\\n        roundInfo.currentIncentiveAmount += params.incentiveAmount;\\r\\n        roundInfo.incentiveSnapshot += msg.value;\\r\\n        roundInfo.totalPositionCount += 1;\\r\\n\\r\\n        uint256 userTotalPositionCount = roundLedgers[targetEpoch][msg.sender].length;\\r\\n        // construct position info\\r\\n        {\\r\\n            uint location = pickLocation(targetEpoch);\\r\\n            uint256 expiryTime = block.timestamp;\\r\\n            expiryTime += (location + 1) * TIME_UNIT;\\r\\n            PositionInfo memory positionInfo = PositionInfo({\\r\\n                amount: msg.value,\\r\\n                openTime: block.timestamp,\\r\\n                expiryTime: expiryTime,\\r\\n                investReturnRate: params.investReturnRate,\\r\\n                withdrawnAmount: 0,\\r\\n                incentiveAmount: 0,\\r\\n                investReturnAmount: 0,\\r\\n                index: userTotalPositionCount,\\r\\n                incentiveClaimable: true\\r\\n            });\\r\\n\\r\\n            // do bucket stock\\r\\n            {\\r\\n                BucketStock storage bucketStock = ledgerBucketStock;\\r\\n                uint hour = DateTime.getHour(block.timestamp);\\r\\n                uint timestamp = DateTime.getTodayTimestamp(block.timestamp);\\r\\n                bucketStock.hourTradeVolume[currentEpochs][timestamp][hour] += msg.value;\\r\\n                bucketStock.currentTotalVolume += msg.value;\\r\\n                bucketStock.epochDaysVolume[currentEpochs][location] += msg.value;\\r\\n            }\\r\\n\\r\\n            // push position info to round ledgers\\r\\n            roundLedgers[targetEpoch][msg.sender].push(positionInfo);\\r\\n        }\\r\\n\\r\\n        // distribute referrer funds\\r\\n        _distributeReferrerReward(msg.sender, params.referrerAmount);\\r\\n        {\\r\\n            // ranked incentive track\\r\\n            mapping(uint256 => LinkedPosition) storage linkedPositions = roundInfo.linkedPositions;\\r\\n\\r\\n            // update the latest position (which is the current position) node\\r\\n            LinkedPosition storage linkedPosition = linkedPositions[roundInfo.totalPositionCount - 1];\\r\\n            linkedPosition.user = msg.sender;\\r\\n            linkedPosition.userPositionIndex = userTotalPositionCount;\\r\\n\\r\\n            // adjust head in order to keep track last N positions\\r\\n            if (roundInfo.totalPositionCount - roundInfo.head > RANKED_INCENTIVE) {\\r\\n                // fetch current head node\\r\\n                LinkedPosition storage headLinkedPosition = linkedPositions[roundInfo.head];\\r\\n                PositionInfo storage headPositionInfo = roundLedgers[targetEpoch][headLinkedPosition.user][\\r\\n                headLinkedPosition.userPositionIndex\\r\\n                ];\\r\\n                // previous head position now is not eligible for incentive\\r\\n                headPositionInfo.incentiveClaimable = false;\\r\\n                // subtract head position amount, because we only keep the last RANKED_INCENTIVE positions\\r\\n                roundInfo.incentiveSnapshot -= headPositionInfo.amount;\\r\\n                // shift head to next global position to keep track the last N positions\\r\\n                roundInfo.head += 1;\\r\\n\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // do transfer to platform\\r\\n        {\\r\\n            (bool success,) = platformAddress.call{\\r\\n                    value: msg.value.mul(PLATFORM_RATIO).div(PRICE_PRECISION)\\r\\n                }(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        }\\r\\n        // emit event\\r\\n        emit PositionOpened(msg.sender, targetEpoch, userTotalPositionCount, msg.value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Close position\\r\\n     * @param epoch: Epoch of the ledger\\r\\n     * @param positionIndex: Position index of the user\\r\\n     */\\r\\n    function closePosition(\\r\\n        uint256 epoch,\\r\\n        uint256 positionIndex\\r\\n    ) external notContract nonReentrant {\\r\\n        require(epoch <= currentEpochs, \\\"Invalid epoch\\\");\\r\\n\\r\\n        // check index is valid\\r\\n        PositionInfo[] storage positionInfos = roundLedgers[epoch][msg.sender];\\r\\n        require(positionIndex < positionInfos.length, \\\"Invalid position index\\\");\\r\\n\\r\\n        // get position Info\\r\\n        PositionInfo storage positionInfo = positionInfos[positionIndex];\\r\\n\\r\\n        // get roundIno\\r\\n        RoundInfo storage roundInfo = roundInfos[epoch];\\r\\n\\r\\n        // user global info\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\r\\n\\r\\n        _safeClosePosition(epoch, positionIndex, positionInfo, roundInfo, userGlobalInfo);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Close a batch of positions\\r\\n     * @param epoch: Epoch of the ledger\\r\\n     * @param positionIndexes: Position indexes of the user\\r\\n     */\\r\\n    function batchClosePositions(\\r\\n        uint256 epoch,\\r\\n        uint256[] calldata positionIndexes\\r\\n    ) external nonReentrant {\\r\\n        require(epoch <= currentEpochs, \\\"Invalid epoch\\\");\\r\\n        require(positionIndexes.length > 0, \\\"Invalid position indexes\\\");\\r\\n\\r\\n        // check index is valid\\r\\n        PositionInfo[] storage positionInfos = roundLedgers[epoch][msg.sender];\\r\\n\\r\\n        // get roundIno\\r\\n        RoundInfo storage roundInfo = roundInfos[epoch];\\r\\n\\r\\n        // position info placeholder\\r\\n        PositionInfo storage positionInfo;\\r\\n\\r\\n        // user global info\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\r\\n\\r\\n        uint256 positionIndexesLength = positionIndexes.length;\\r\\n        uint256 positionInfosLength = positionInfos.length;\\r\\n        for (uint256 i = 0; i < positionIndexesLength; ++i) {\\r\\n            require(positionIndexes[i] < positionInfosLength, \\\"Invalid position index\\\");\\r\\n            // get position Info\\r\\n            positionInfo = positionInfos[positionIndexes[i]];\\r\\n            _safeClosePosition(epoch, positionIndexes[i], positionInfo, roundInfo, userGlobalInfo);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Claim a batch of incentive claimable positions\\r\\n     * @param epoch: Epoch of the ledger\\r\\n     * @param positionIndexes: Position indexes of the user\\r\\n     */\\r\\n    function batchClaimPositionIncentiveReward(\\r\\n        uint256 epoch,\\r\\n        uint256[] calldata positionIndexes\\r\\n    ) external notContract nonReentrant {\\r\\n        require(epoch < currentEpochs, \\\"Epoch not finished\\\");\\r\\n\\r\\n        // get position infos\\r\\n        PositionInfo[] storage positionInfos = roundLedgers[epoch][msg.sender];\\r\\n\\r\\n        // get roundInfo\\r\\n        RoundInfo storage roundInfo = roundInfos[epoch];\\r\\n\\r\\n        // get user round info\\r\\n        uint256 userRoundIndex = roundInfo.ledgerRoundToUserRoundIndex[msg.sender];\\r\\n        UserRoundInfo storage userRoundInfo = userRoundsInfos[msg.sender][userRoundIndex];\\r\\n\\r\\n        // position info placeholder\\r\\n        PositionInfo storage positionInfo;\\r\\n\\r\\n        // collect payout\\r\\n        uint256 payoutAmount;\\r\\n        uint256 positionIndex;\\r\\n        uint256 positionIndexesLength = positionIndexes.length;\\r\\n        uint256 positionInfosLength = positionInfos.length;\\r\\n        for (uint256 i = 0; i < positionIndexesLength; ++i) {\\r\\n            positionIndex = positionIndexes[i];\\r\\n            require(positionIndex < positionInfosLength, \\\"Invalid position index\\\");\\r\\n            // get position Info\\r\\n            positionInfo = positionInfos[positionIndex];\\r\\n            require(positionInfo.incentiveClaimable, \\\"Position not eligible\\\");\\r\\n            // update positionInfo\\r\\n            payoutAmount += _safeProcessIncentiveAmount(positionInfo, roundInfo);\\r\\n        }\\r\\n\\r\\n        // transfer\\r\\n        {\\r\\n            (bool success,) = msg.sender.call{value: payoutAmount}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        }\\r\\n\\r\\n        // update userRoundInfo\\r\\n        userRoundInfo.totalIncentiveClaimedAmount += payoutAmount;\\r\\n        emit IncentiveClaimed(msg.sender, payoutAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Report a batch users' sales\\r\\n     * @param users: list of users\\r\\n     */\\r\\n    function batchReportSales(address[] calldata users) external {\\r\\n        uint256 usersLength = users.length;\\r\\n        for (uint256 i = 0; i < usersLength; ++i) {\\r\\n            _safeReportSales(users[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Claim referrer reward\\r\\n     * @param referrer: referrer address\\r\\n     */\\r\\n    function claimReferrerReward(address referrer) external notContract nonReentrant {\\r\\n        require(referrer != address(0), \\\"Invalid referrer address\\\");\\r\\n\\r\\n        // get user global info\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[referrer];\\r\\n\\r\\n        // get claimable amount\\r\\n        uint256 claimableAmount = userGlobalInfo.totalReferrerReward - userGlobalInfo.referrerRewardClaimed;\\r\\n\\r\\n        require(claimableAmount > 0, \\\"No claimable amount\\\");\\r\\n\\r\\n        // update state\\r\\n        userGlobalInfo.referrerRewardClaimed += claimableAmount;\\r\\n\\r\\n        // do transfer\\r\\n        {\\r\\n            (bool success,) = referrer.call{value: claimableAmount}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        }\\r\\n\\r\\n        // emit event\\r\\n        emit ReferrerRewardClaimed(referrer, claimableAmount);\\r\\n    }\\r\\n\\r\\n    function getLinkedPositionInfo(\\r\\n        uint256 epoch,\\r\\n        uint256 cursor,\\r\\n        uint256 size\\r\\n    ) external view returns (LinkedPosition[] memory, uint256) {\\r\\n        uint256 length = size;\\r\\n        uint256 positionCount = roundInfos[epoch].totalPositionCount;\\r\\n        if (cursor + length > positionCount) {\\r\\n            length = positionCount - cursor;\\r\\n        }\\r\\n        LinkedPosition[] memory linkedPositions = new LinkedPosition[](length);\\r\\n        RoundInfo storage roundInfo = roundInfos[epoch];\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            linkedPositions[i] = roundInfo.linkedPositions[cursor + i];\\r\\n        }\\r\\n        return (linkedPositions, cursor + length);\\r\\n    }\\r\\n\\r\\n    function getUserRounds(\\r\\n        address user,\\r\\n        uint256 cursor,\\r\\n        uint256 size\\r\\n    ) external view returns (UserRoundInfo[] memory, uint256) {\\r\\n        uint256 length = size;\\r\\n        uint256 roundCount = userRoundsInfos[user].length;\\r\\n        if (cursor + length > roundCount) {\\r\\n            length = roundCount - cursor;\\r\\n        }\\r\\n\\r\\n        UserRoundInfo[] memory userRoundInfos = new UserRoundInfo[](length);\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            userRoundInfos[i] = userRoundsInfos[user][cursor + i];\\r\\n        }\\r\\n\\r\\n        return (userRoundInfos, cursor + length);\\r\\n    }\\r\\n\\r\\n    function getUserRoundsLength(address user) external view returns (uint256) {\\r\\n        return userRoundsInfos[user].length;\\r\\n    }\\r\\n\\r\\n    function getUserRoundLedgers(\\r\\n        uint256 epoch,\\r\\n        address user,\\r\\n        uint256 cursor,\\r\\n        uint256 size\\r\\n    ) external view returns (PositionInfo[] memory, uint256) {\\r\\n        uint256 length = size;\\r\\n        uint256 positionCount = roundLedgers[epoch][user].length;\\r\\n        if (cursor + length > positionCount) {\\r\\n            length = positionCount - cursor;\\r\\n        }\\r\\n\\r\\n        PositionInfo[] memory positionInfos = new PositionInfo[](length);\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            positionInfos[i] = roundLedgers[epoch][user][cursor + i];\\r\\n        }\\r\\n\\r\\n        return (positionInfos, cursor + length);\\r\\n    }\\r\\n\\r\\n    function getUserRoundLedgersLength(\\r\\n        uint256 epoch,\\r\\n        address user\\r\\n    ) external view returns (uint256) {\\r\\n        return roundLedgers[epoch][user].length;\\r\\n    }\\r\\n\\r\\n    function getChildren(\\r\\n        address user,\\r\\n        uint256 cursor,\\r\\n        uint256 size\\r\\n    ) external view returns (address[] memory, uint256) {\\r\\n        uint256 length = size;\\r\\n        uint256 childrenCount = children[user].length;\\r\\n        if (cursor + length > childrenCount) {\\r\\n            length = childrenCount - cursor;\\r\\n        }\\r\\n\\r\\n        address[] memory _children = new address[](length);\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            _children[i] = children[user][cursor + i];\\r\\n        }\\r\\n\\r\\n        return (_children, cursor + length);\\r\\n    }\\r\\n\\r\\n    function getLedgerRoundToUserRoundIndex(\\r\\n        uint256 epoch,\\r\\n        address user\\r\\n    ) external view returns (uint256) {\\r\\n        return roundInfos[epoch].ledgerRoundToUserRoundIndex[user];\\r\\n    }\\r\\n\\r\\n    function getChildrenLength(address user) external view returns (uint256) {\\r\\n        return children[user].length;\\r\\n    }\\r\\n\\r\\n    function getUserDepartSalesAndLevel(address user) external view returns (uint256, uint8) {\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[user];\\r\\n        return (userGlobalInfo.sales - userGlobalInfo.maxChildrenSales, userGlobalInfo.salesLevel);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice close a given position\\r\\n     * @param epoch: epoch of the ledger\\r\\n     * @param positionIndex: position index of the user\\r\\n     * @param positionInfo: storage of the position info\\r\\n     * @param roundInfo: storage of the round info\\r\\n     */\\r\\n    function _safeClosePosition(\\r\\n        uint256 epoch,\\r\\n        uint256 positionIndex,\\r\\n        PositionInfo storage positionInfo,\\r\\n        RoundInfo storage roundInfo,\\r\\n        UserGlobalInfo storage userGlobalInfo\\r\\n    ) internal {\\r\\n        require(positionInfo.withdrawnAmount == 0, \\\"Position already claimed\\\");\\r\\n        require(positionInfo.expiryTime <= block.timestamp || roundInfo.stopLoss, \\\"Position not expired\\\");\\r\\n\\r\\n        // get user round info from storage\\r\\n        uint256 targetRoundInfoIndex = roundInfo.ledgerRoundToUserRoundIndex[msg.sender];\\r\\n        UserRoundInfo storage userRoundInfo = userRoundsInfos[msg.sender][targetRoundInfoIndex];\\r\\n\\r\\n        // calculate the amount to withdraw\\r\\n        uint256 payoutAmount;\\r\\n        uint256 principalAmount = (positionInfo.amount * PRINCIPAL_RATIO) / PRICE_PRECISION;\\r\\n\\r\\n        // get back the principal amount\\r\\n        payoutAmount += principalAmount;\\r\\n\\r\\n        // update roundInfo\\r\\n        roundInfo.currentPositionCount -= 1;\\r\\n        roundInfo.currentPrincipalAmount -= principalAmount;\\r\\n\\r\\n        if (!roundInfo.stopLoss) {\\r\\n            // calculate expected invest return amount\\r\\n            // how many days passed\\r\\n            uint256 daysPassed = (positionInfo.expiryTime - positionInfo.openTime);\\r\\n\\r\\n            uint256 expectedInvestReturnAmount = (positionInfo.amount * positionInfo.investReturnRate * daysPassed) /\\r\\n            PRICE_PRECISION /\\r\\n            TIME_UNIT;\\r\\n\\r\\n            // calculate the amount should be paid back from invest pool\\r\\n            // 39% to total amount + expected return amount\\r\\n            uint256 investReturnAmount = positionInfo.amount - principalAmount + expectedInvestReturnAmount;\\r\\n\\r\\n            // compare if current invest pool has enough amount\\r\\n            if (roundInfo.currentInvestAmount < investReturnAmount) {\\r\\n                // not enough, then just pay back the current invest pool amount\\r\\n                investReturnAmount = roundInfo.currentInvestAmount;\\r\\n                roundInfo.currentInvestAmount = 0;\\r\\n            } else {\\r\\n                // update round info\\r\\n            unchecked {\\r\\n                roundInfo.currentInvestAmount -= investReturnAmount;\\r\\n            }\\r\\n            }\\r\\n\\r\\n            // check round is stop loss\\r\\n            if (roundInfo.currentInvestAmount == 0) {\\r\\n                roundInfo.stopLoss = true;\\r\\n                currentEpochs += 1;\\r\\n                emit NewRound(currentEpochs);\\r\\n            }\\r\\n\\r\\n            // update payout amount\\r\\n            payoutAmount += investReturnAmount;\\r\\n\\r\\n            // update positionInfo\\r\\n            positionInfo.investReturnAmount = investReturnAmount;\\r\\n        }\\r\\n\\r\\n        uint256 incentiveAmount = 0;\\r\\n        // calculate incentive amount if eligible\\r\\n        if (roundInfo.stopLoss && positionInfo.incentiveClaimable) {\\r\\n            incentiveAmount = _safeProcessIncentiveAmount(positionInfo, roundInfo);\\r\\n\\r\\n            // update payout amount\\r\\n            payoutAmount += incentiveAmount;\\r\\n\\r\\n            // update incentive info to storage\\r\\n            userRoundInfo.totalIncentiveClaimedAmount += incentiveAmount;\\r\\n\\r\\n            emit IncentiveClaimed(msg.sender, incentiveAmount);\\r\\n        }\\r\\n\\r\\n        // update user round info\\r\\n        userRoundInfo.totalWithdrawnAmount += payoutAmount;\\r\\n        userRoundInfo.currentPrincipalAmount -= principalAmount;\\r\\n\\r\\n        // update positionInfo\\r\\n        positionInfo.withdrawnAmount = payoutAmount;\\r\\n\\r\\n        // accumulate user's boost credit\\r\\n        if (payoutAmount - incentiveAmount < positionInfo.amount) {\\r\\n            userGlobalInfo.boostCredit += positionInfo.amount - (positionInfo.amount * PRINCIPAL_RATIO / PRICE_PRECISION);\\r\\n        }\\r\\n\\r\\n        if (payoutAmount > address(this).balance) {\\r\\n            payoutAmount = address(this).balance;\\r\\n        }\\r\\n        // do transfer\\r\\n        {\\r\\n            (bool success,) = msg.sender.call{value: payoutAmount}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        }\\r\\n\\r\\n        // emit event\\r\\n        emit PositionClosed(msg.sender, epoch, positionIndex, payoutAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice process positionInfo and return incentive amount\\r\\n     * @param positionInfo: storage of the position info\\r\\n     * @param roundInfo: storage of the round info\\r\\n     */\\r\\n    function _safeProcessIncentiveAmount(PositionInfo storage positionInfo, RoundInfo storage roundInfo)\\r\\n    internal\\r\\n    returns (uint256)\\r\\n    {\\r\\n        // calculate incentive amount\\r\\n        uint256 incentiveAmount = (positionInfo.amount * roundInfo.totalPositionAmount * INCENTIVE_RATIO) /\\r\\n        roundInfo.incentiveSnapshot /\\r\\n        PRICE_PRECISION;\\r\\n\\r\\n        // with PRICE_PRECISION is due to the precision of division may result in a few wei left over\\r\\n        if (roundInfo.currentIncentiveAmount < incentiveAmount + PRICE_PRECISION) {\\r\\n            // clean up incentive amount\\r\\n            incentiveAmount = roundInfo.currentIncentiveAmount;\\r\\n            roundInfo.currentIncentiveAmount = 0;\\r\\n        } else {\\r\\n            roundInfo.currentIncentiveAmount -= incentiveAmount;\\r\\n        }\\r\\n\\r\\n        // this position is no longer eligible for incentive\\r\\n        positionInfo.incentiveClaimable = false;\\r\\n\\r\\n        // update positionInfo\\r\\n        positionInfo.incentiveAmount = incentiveAmount;\\r\\n\\r\\n        return incentiveAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice process user's level info and return the current level\\r\\n     * @param currentLevel: user current level\\r\\n     * @param user: user address\\r\\n     * @param currentSales: user current sales\\r\\n     * @param userGlobalInfo: storage of the user global info\\r\\n     */\\r\\n    function _safeProcessSalesLevel(\\r\\n        uint8 currentLevel,\\r\\n        address user,\\r\\n        uint256 currentSales,\\r\\n        UserGlobalInfo storage userGlobalInfo\\r\\n    ) internal returns (uint8) {\\r\\n        uint8 newLevel = _getSalesToLevel(currentSales);\\r\\n        if (newLevel > currentLevel) {\\r\\n            userGlobalInfo.salesLevel = newLevel;\\r\\n            emit SalesLevelUpdated(user, newLevel);\\r\\n        } else {\\r\\n            newLevel = currentLevel;\\r\\n        }\\r\\n        return newLevel;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice report user's sales and update its referrer sales level\\r\\n     * @param user: user address\\r\\n     */\\r\\n    function _safeReportSales(address user) internal {\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[user];\\r\\n        address referrer = userGlobalInfo.referrer;\\r\\n        uint256 userSales = userGlobalInfo.sales;\\r\\n        uint256 userReportedSales = userGlobalInfo.reportedSales;\\r\\n\\r\\n        // get user's un-reported sales\\r\\n        uint256 unreportedSales = userSales - userReportedSales;\\r\\n\\r\\n        if (unreportedSales > 0) {\\r\\n            // get referrer global info from storage\\r\\n            UserGlobalInfo storage referrerGlobalInfo = userGlobalInfos[referrer];\\r\\n            // fill up the sales to the referrer\\r\\n            referrerGlobalInfo.sales += unreportedSales;\\r\\n            // update user's reported sales\\r\\n            userGlobalInfo.reportedSales = userSales;\\r\\n\\r\\n            // all reported sales + user's own contributed position will be current user's final sales\\r\\n            userSales += userGlobalInfo.totalPositionAmount;\\r\\n            // current referrer's max children sales\\r\\n            uint256 maxChildrenSales = referrerGlobalInfo.maxChildrenSales;\\r\\n            // update max children sales if needed\\r\\n            if (userSales > maxChildrenSales) {\\r\\n                // referrer's max children sales is updated\\r\\n                referrerGlobalInfo.maxChildrenSales = userSales;\\r\\n                // update cache of max children sales\\r\\n                maxChildrenSales = userSales;\\r\\n            }\\r\\n            // process referrer's sales level\\r\\n            _safeProcessSalesLevel(\\r\\n                referrerGlobalInfo.salesLevel,\\r\\n                referrer,\\r\\n                referrerGlobalInfo.sales - maxChildrenSales, // sales for level calculation is sales - max children sales\\r\\n                referrerGlobalInfo\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice distribute referrer reward\\r\\n     * @param user: user address\\r\\n     * @param referrerAmount: total amount of referrer reward\\r\\n     */\\r\\n    function _distributeReferrerReward(address user, uint256 referrerAmount) internal virtual {\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[user];\\r\\n        UserGlobalInfo storage referrerGlobalInfo;\\r\\n        uint256 positionAmount = msg.value;\\r\\n\\r\\n        // init all local variables as a search struct\\r\\n        ReferrerSearch memory search;\\r\\n        search.baseSalesLevel = 0;\\r\\n        search.currentReferrer = userGlobalInfo.referrer;\\r\\n        search.levelDiffAmount = (referrerAmount * 50) / 100;\\r\\n        search.leftLevelDiffAmount = search.levelDiffAmount;\\r\\n        search.levelDiffAmountPerLevel = search.levelDiffAmount / 6;\\r\\n        search.levelSearchAmount = referrerAmount - search.levelDiffAmount;\\r\\n        search.leftLevelSearchAmount = search.levelSearchAmount;\\r\\n        search.levelSearchAmountPerReferrer = search.levelSearchAmount / 10;\\r\\n\\r\\n        search.currentUserTotalPosAmount = userGlobalInfo.totalPositionAmount + positionAmount;\\r\\n        userGlobalInfo.totalPositionAmount = search.currentUserTotalPosAmount;\\r\\n        search.currentUser = user;\\r\\n\\r\\n        while (search.depth < MAX_SEARCH_DEPTH) {\\r\\n            // stop if current referrer is the root\\r\\n            if (search.currentReferrer == address(0)) {\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            // this position does not counted as reported sales for first user himself\\r\\n            if (search.depth > 0) userGlobalInfo.reportedSales += positionAmount;\\r\\n\\r\\n            // cache current user information\\r\\n            search.currentUserSales = userGlobalInfo.sales;\\r\\n            search.currentUserReportedSales = userGlobalInfo.reportedSales;\\r\\n\\r\\n            // cache current referrer information\\r\\n            referrerGlobalInfo = userGlobalInfos[search.currentReferrer];\\r\\n\\r\\n            // update referrer sales\\r\\n            {\\r\\n                search.currentReferrerSales = referrerGlobalInfo.sales;\\r\\n                // add current sales to current referrer\\r\\n                search.currentReferrerSales += positionAmount;\\r\\n                // check unreported sales\\r\\n                if (search.currentUserReportedSales < search.currentUserSales) {\\r\\n                    // update referrerSales to include unreported sales\\r\\n                    search.currentReferrerSales += search.currentUserSales - search.currentUserReportedSales;\\r\\n                    // update current node storage for reported sales\\r\\n                    userGlobalInfo.reportedSales = search.currentUserSales;\\r\\n                }\\r\\n                // update sales for current referrer\\r\\n                referrerGlobalInfo.sales = search.currentReferrerSales;\\r\\n            }\\r\\n\\r\\n            // update referrer max children sales\\r\\n            {\\r\\n                // add current user's total position amount to current user's sales\\r\\n                search.currentUserSales += search.currentUserTotalPosAmount;\\r\\n                // check referrer's max child sales\\r\\n                search.currentReferrerMaxChildSales = referrerGlobalInfo.maxChildrenSales;\\r\\n                if (search.currentReferrerMaxChildSales < search.currentUserSales) {\\r\\n                    // update max child sales\\r\\n                    referrerGlobalInfo.maxChildrenSales = search.currentUserSales;\\r\\n                    search.currentReferrerMaxChildSales = search.currentUserSales;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // process referrer's sales level\\r\\n            // @notice: current referrer sales level should ignore its max child sales\\r\\n            search.currentReferrerLevel = _safeProcessSalesLevel(\\r\\n                referrerGlobalInfo.salesLevel,\\r\\n                search.currentReferrer,\\r\\n                search.currentReferrerSales - search.currentReferrerMaxChildSales,\\r\\n                referrerGlobalInfo\\r\\n            );\\r\\n\\r\\n            // start level diff calculation\\r\\n            if (!search.levelDiffDone) {\\r\\n                // compare the current referrer's level with the base sales level\\r\\n                if (search.currentReferrerLevel > search.baseSalesLevel) {\\r\\n                    // level diff\\r\\n                    search.currentLevelDiff = search.currentReferrerLevel - search.baseSalesLevel;\\r\\n\\r\\n                    // update base level\\r\\n                    search.baseSalesLevel = search.currentReferrerLevel;\\r\\n\\r\\n                    // calculate the referrer amount\\r\\n                    search.currentReferrerAmount = search.currentLevelDiff * search.levelDiffAmountPerLevel;\\r\\n\\r\\n                    // check left referrer amount\\r\\n                    if (search.currentReferrerAmount + PRICE_PRECISION > search.leftLevelDiffAmount) {\\r\\n                        search.currentReferrerAmount = search.leftLevelDiffAmount;\\r\\n                    }\\r\\n\\r\\n                    // update referrer's referrer amount\\r\\n                    referrerGlobalInfo.totalReferrerReward += search.currentReferrerAmount;\\r\\n                    emit ReferrerRewardAdded(search.currentReferrer, search.currentReferrerAmount, 0);\\r\\n\\r\\n                unchecked {\\r\\n                    search.leftLevelDiffAmount -= search.currentReferrerAmount;\\r\\n                }\\r\\n\\r\\n                    if (search.leftLevelDiffAmount == 0) {\\r\\n                        search.levelDiffDone = true;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            if (!search.levelSearchDone) {\\r\\n                // level search use referrer's real level\\r\\n                search.levelSearchStep = _getLevelToLevelSearchStep(\\r\\n                    _getSalesToLevel(search.currentReferrerSales - search.currentReferrerMaxChildSales)\\r\\n                );\\r\\n                if (search.numLevelSearchCandidate + 1 <= search.levelSearchStep) {\\r\\n                    search.numLevelSearchCandidate += 1;\\r\\n\\r\\n                    // check left referrer amount\\r\\n                    if (search.levelSearchAmountPerReferrer + PRICE_PRECISION > search.leftLevelSearchAmount) {\\r\\n                        search.levelSearchAmountPerReferrer = search.leftLevelSearchAmount;\\r\\n                    }\\r\\n\\r\\n                    // update referrer's referrer amount\\r\\n                    referrerGlobalInfo.totalReferrerReward += search.levelSearchAmountPerReferrer;\\r\\n                    emit ReferrerRewardAdded(search.currentReferrer, search.levelSearchAmountPerReferrer, 1);\\r\\n                unchecked {\\r\\n                    search.leftLevelSearchAmount -= search.levelSearchAmountPerReferrer;\\r\\n                }\\r\\n\\r\\n                    if (search.leftLevelSearchAmount == 0) {\\r\\n                        search.levelSearchDone = true;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            search.currentUser = search.currentReferrer;\\r\\n            search.currentReferrer = referrerGlobalInfo.referrer;\\r\\n\\r\\n            userGlobalInfo = referrerGlobalInfo;\\r\\n            search.currentUserTotalPosAmount = userGlobalInfo.totalPositionAmount;\\r\\n\\r\\n        unchecked {\\r\\n            search.depth += 1;\\r\\n        }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice get sales level from sales amount\\r\\n     * @param amount: sales amount\\r\\n     */\\r\\n    function _getSalesToLevel(uint256 amount) internal pure virtual returns (uint8) {\\r\\n        /* istanbul ignore else  */\\r\\n        if (amount < 10000 ether) {\\r\\n            return 0;\\r\\n        } else if (amount < 100000 ether) {\\r\\n            return 1;\\r\\n        } else if (amount < 500000 ether) {\\r\\n            return 2;\\r\\n        } else if (amount < 2000000 ether) {\\r\\n            return 3;\\r\\n        } else if (amount < 5000000 ether) {\\r\\n            return 4;\\r\\n        } else if (amount < 10000000 ether) {\\r\\n            return 5;\\r\\n        }\\r\\n        return 6;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice level search step from level\\r\\n     * @param level: sales level (0-10)\\r\\n     */\\r\\n    function _getLevelToLevelSearchStep(uint8 level) internal pure returns (uint8) {\\r\\n    unchecked {\\r\\n        if (level < 5) return level * 2;\\r\\n    }\\r\\n        return 10;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/DateTime.sol\": {\r\n        \"DateTime\": \"0xb24eb72f5ada2771269e01f374fe846a0174ae62\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_platformAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tempAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"IncentiveClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"NewReferrer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PositionClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PositionOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewardType\",\"type\":\"uint256\"}],\"name\":\"ReferrerRewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferrerRewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"SalesLevelUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAILY_GROWTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INCENTIVE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INVEST_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_INVEST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_RETURN_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SEARCH_DEPTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VOLUME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_INVEST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_RETURN_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRINCIPAL_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RANKED_INCENTIVE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRER_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_UNIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"positionIndexes\",\"type\":\"uint256[]\"}],\"name\":\"batchClaimPositionIncentiveReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"positionIndexes\",\"type\":\"uint256[]\"}],\"name\":\"batchClosePositions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"batchReportSales\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referrers\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"salesLevels\",\"type\":\"uint8[]\"}],\"name\":\"batchSetReferrerInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"children\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"claimReferrerReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"}],\"name\":\"closePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractCreateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpochs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropTempAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getChildren\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getChildrenLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLedgerRoundToUserRoundIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getLinkedPositionInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userPositionIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct NoahsArk.LinkedPosition[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"getReturnRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserDepartSalesAndLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getUserRoundLedgers\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"incentiveClaimable\",\"type\":\"bool\"}],\"internalType\":\"struct NoahsArk.PositionInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserRoundLedgersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getUserRounds\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalIncentiveClaimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClosedPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returnRateBoostedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct NoahsArk.UserRoundInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserRoundsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetEpoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"openPosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastCheckTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"achievedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct NoahsArk.FundTarget\",\"name\":\"fundTarget\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentInvestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentIncentiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"head\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stopLoss\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundLedgers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"incentiveClaimable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tempAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"transferOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userGlobalInfos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalReferrerReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerRewardClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boostCredit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxChildrenSales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reportedSales\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"salesLevel\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userRoundsInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalIncentiveClaimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClosedPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returnRateBoostedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NoahsArk", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000dded3fc6a60f83dd876c213fd05d28fe38f18134000000000000000000000000dacdc7930371c0a8f9c573029eacbfe956f1accb000000000000000000000000dacdc7930371c0a8f9c573029eacbfe956f1accb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}