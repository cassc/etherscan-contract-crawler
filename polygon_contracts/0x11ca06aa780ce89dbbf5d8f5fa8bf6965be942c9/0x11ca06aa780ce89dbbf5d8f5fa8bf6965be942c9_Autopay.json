{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"autopay/contracts/Autopay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport {UsingTellor} from \\\"usingtellor/contracts/UsingTellor.sol\\\";\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IQueryDataStorage.sol\\\";\\n\\n/**\\n @author Tellor Inc.\\n @title Autopay\\n @dev This is a contract for automatically paying for Tellor oracle data at\\n * specific time intervals, as well as one time tips.\\n*/\\ncontract Autopay is UsingTellor {\\n    // Storage\\n    IERC20 public token; // TRB token address\\n    IQueryDataStorage public queryDataStorage; // Query data storage contract\\n    uint256 public fee; // 1000 is 100%, 50 is 5%, etc.\\n\\n    mapping(bytes32 => bytes32[]) currentFeeds; // mapping queryId to dataFeedIds array\\n    mapping(bytes32 => mapping(bytes32 => Feed)) dataFeed; // mapping queryId to dataFeedId to details\\n    mapping(bytes32 => bytes32) public queryIdFromDataFeedId; // mapping dataFeedId to queryId\\n    mapping(bytes32 => uint256) public queryIdsWithFundingIndex; // mapping queryId to queryIdsWithFunding index plus one (0 if not in array)\\n    mapping(bytes32 => Tip[]) public tips; // mapping queryId to tips\\n    mapping(address => uint256) public userTipsTotal; // track user tip total per user\\n\\n    bytes32[] public feedsWithFunding; // array of dataFeedIds that have funding\\n    bytes32[] public queryIdsWithFunding; // array of queryIds that have funding\\n\\n    // Structs\\n    struct Feed {\\n        FeedDetails details;\\n        mapping(uint256 => bool) rewardClaimed; // tracks which tips were already paid out\\n    }\\n\\n    struct FeedDetails {\\n        uint256 reward; // amount paid for each eligible data submission\\n        uint256 balance; // account remaining balance\\n        uint256 startTime; // time of first payment window\\n        uint256 interval; // time between pay periods\\n        uint256 window; // amount of time data can be submitted per interval\\n        uint256 priceThreshold; //change in price necessitating an update 100 = 1%\\n        uint256 rewardIncreasePerSecond; // amount reward increases per second within window (0 for flat rewards)\\n        uint256 feedsWithFundingIndex; // index plus one of dataFeedID in feedsWithFunding array (0 if not in array)\\n    }\\n\\n    struct FeedDetailsWithQueryData {\\n        FeedDetails details; // feed details for feed id with funding\\n        bytes queryData; // query data for requested data\\n    }\\n\\n    struct SingleTipsWithQueryData {\\n        bytes queryData; // query data with single tip for requested data\\n        uint256 tip; // reward amount for request\\n    }\\n\\n    struct Tip {\\n        uint256 amount; // amount tipped\\n        uint256 timestamp; // time tipped\\n        uint256 cumulativeTips; // cumulative tips for query ID\\n    }\\n\\n    // Events\\n    event DataFeedFunded(\\n        bytes32 indexed _queryId,\\n        bytes32 indexed _feedId,\\n        uint256 indexed _amount,\\n        address _feedFunder,\\n        FeedDetails _feedDetails\\n    );\\n    event NewDataFeed(\\n        bytes32 indexed _queryId,\\n        bytes32 indexed _feedId,\\n        bytes _queryData,\\n        address _feedCreator\\n    );\\n    event OneTimeTipClaimed(\\n        bytes32 indexed _queryId,\\n        uint256 indexed _amount,\\n        address indexed _reporter\\n    );\\n    event TipAdded(\\n        bytes32 indexed _queryId,\\n        uint256 indexed _amount,\\n        bytes _queryData,\\n        address _tipper\\n    );\\n    event TipClaimed(\\n        bytes32 indexed _feedId,\\n        bytes32 indexed _queryId,\\n        uint256 indexed _amount,\\n        address _reporter\\n    );\\n\\n    // Functions\\n    /**\\n     * @dev Initializes system parameters\\n     * @param _tellor address of Tellor contract\\n     * @param _queryDataStorage address of query data storage contract\\n     * @param _fee percentage, 1000 is 100%, 50 is 5%, etc.\\n     */\\n    constructor(\\n        address payable _tellor,\\n        address _queryDataStorage,\\n        uint256 _fee\\n    ) UsingTellor(_tellor) {\\n        token = IERC20(tellor.token());\\n        queryDataStorage = IQueryDataStorage(_queryDataStorage);\\n        fee = _fee;\\n    }\\n\\n    /**\\n     * @dev Function to claim singular tip\\n     * @param _queryId id of reported data\\n     * @param _timestamps[] batch of timestamps array of reported data eligible for reward\\n     */\\n    function claimOneTimeTip(\\n        bytes32 _queryId,\\n        uint256[] calldata _timestamps\\n    ) external {\\n        require(\\n            tips[_queryId].length > 0,\\n            \\\"no tips submitted for this queryId\\\"\\n        );\\n        uint256 _cumulativeReward;\\n        for (uint256 _i = 0; _i < _timestamps.length; _i++) {\\n            _cumulativeReward += _getOneTimeTipAmount(\\n                _queryId,\\n                _timestamps[_i]\\n            );\\n        }\\n        require(\\n            token.transfer(\\n                msg.sender,\\n                _cumulativeReward - ((_cumulativeReward * fee) / 1000)\\n            )\\n        );\\n        token.approve(address(tellor), (_cumulativeReward * fee) / 1000);\\n        tellor.addStakingRewards((_cumulativeReward * fee) / 1000);\\n        if (getCurrentTip(_queryId) == 0) {\\n            if (queryIdsWithFundingIndex[_queryId] != 0) {\\n                uint256 _idx = queryIdsWithFundingIndex[_queryId] - 1;\\n                // Replace unfunded feed in array with last element\\n                queryIdsWithFunding[_idx] = queryIdsWithFunding[\\n                    queryIdsWithFunding.length - 1\\n                ];\\n                bytes32 _queryIdLastFunded = queryIdsWithFunding[_idx];\\n                queryIdsWithFundingIndex[_queryIdLastFunded] = _idx + 1;\\n                queryIdsWithFundingIndex[_queryId] = 0;\\n                queryIdsWithFunding.pop();\\n            }\\n        }\\n        emit OneTimeTipClaimed(_queryId, _cumulativeReward, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows Tellor reporters to claim their tips in batches\\n     * @param _feedId unique feed identifier\\n     * @param _queryId ID of reported data\\n     * @param _timestamps batch of timestamps array of reported data eligible for reward\\n     */\\n    function claimTip(\\n        bytes32 _feedId,\\n        bytes32 _queryId,\\n        uint256[] calldata _timestamps\\n    ) external {\\n        Feed storage _feed = dataFeed[_queryId][_feedId];\\n        uint256 _balance = _feed.details.balance;\\n        require(_balance > 0, \\\"no funds available for this feed\\\");\\n        uint256 _cumulativeReward;\\n        for (uint256 _i = 0; _i < _timestamps.length; _i++) {\\n            require(\\n                block.timestamp - _timestamps[_i] > 12 hours,\\n                \\\"buffer time has not passed\\\"\\n            );\\n            require(\\n                getReporterByTimestamp(_queryId, _timestamps[_i]) == msg.sender,\\n                \\\"message sender not reporter for given queryId and timestamp\\\"\\n            );\\n            _cumulativeReward += _getRewardAmount(\\n                _feedId,\\n                _queryId,\\n                _timestamps[_i]\\n            );\\n            if (_cumulativeReward >= _balance) {\\n                // Balance runs out\\n                require(\\n                    _i == _timestamps.length - 1,\\n                    \\\"insufficient balance for all submitted timestamps\\\"\\n                );\\n                _cumulativeReward = _balance;\\n                // Adjust currently funded feeds\\n                if (feedsWithFunding.length > 1) {\\n                    uint256 _idx = _feed.details.feedsWithFundingIndex - 1;\\n                    // Replace unfunded feed in array with last element\\n                    feedsWithFunding[_idx] = feedsWithFunding[\\n                        feedsWithFunding.length - 1\\n                    ];\\n                    bytes32 _feedIdLastFunded = feedsWithFunding[_idx];\\n                    bytes32 _queryIdLastFunded = queryIdFromDataFeedId[\\n                        _feedIdLastFunded\\n                    ];\\n                    dataFeed[_queryIdLastFunded][_feedIdLastFunded]\\n                        .details\\n                        .feedsWithFundingIndex = _idx + 1;\\n                }\\n                feedsWithFunding.pop();\\n                _feed.details.feedsWithFundingIndex = 0;\\n            }\\n            _feed.rewardClaimed[_timestamps[_i]] = true;\\n        }\\n        _feed.details.balance -= _cumulativeReward;\\n        require(\\n            token.transfer(\\n                msg.sender,\\n                _cumulativeReward - ((_cumulativeReward * fee) / 1000)\\n            )\\n        );\\n        token.approve(address(tellor), (_cumulativeReward * fee) / 1000);\\n        tellor.addStakingRewards((_cumulativeReward * fee) / 1000);\\n        emit TipClaimed(_feedId, _queryId, _cumulativeReward, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows dataFeed account to be filled with tokens\\n     * @param _feedId unique feed identifier\\n     * @param _queryId identifier of reported data type associated with feed\\n     * @param _amount quantity of tokens to fund feed\\n     */\\n    function fundFeed(\\n        bytes32 _feedId,\\n        bytes32 _queryId,\\n        uint256 _amount\\n    ) public {\\n        FeedDetails storage _feed = dataFeed[_queryId][_feedId].details;\\n        require(_feed.reward > 0, \\\"feed not set up\\\");\\n        require(_amount > 0, \\\"must be sending an amount\\\");\\n        _feed.balance += _amount;\\n        require(\\n            token.transferFrom(msg.sender, address(this), _amount),\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        // Add to array of feeds with funding\\n        if (_feed.feedsWithFundingIndex == 0 && _feed.balance > 0) {\\n            feedsWithFunding.push(_feedId);\\n            _feed.feedsWithFundingIndex = feedsWithFunding.length;\\n        }\\n        userTipsTotal[msg.sender] += _amount;\\n        emit DataFeedFunded(_feedId, _queryId, _amount, msg.sender, _feed);\\n    }\\n\\n    /**\\n     * @dev Initializes dataFeed parameters.\\n     * @param _queryId unique identifier of desired data feed\\n     * @param _reward tip amount per eligible data submission\\n     * @param _startTime timestamp of first autopay window\\n     * @param _interval amount of time between autopay windows\\n     * @param _window amount of time after each new interval when reports are eligible for tips\\n     * @param _priceThreshold amount price must change to automate update regardless of time (negated if 0, 100 = 1%)\\n     * @param _rewardIncreasePerSecond amount reward increases per second within a window (0 for flat reward)\\n     * @param _queryData the data used by reporters to fulfill the query\\n     * @param _amount optional initial amount to fund it with\\n     */\\n    function setupDataFeed(\\n        bytes32 _queryId,\\n        uint256 _reward,\\n        uint256 _startTime,\\n        uint256 _interval,\\n        uint256 _window,\\n        uint256 _priceThreshold,\\n        uint256 _rewardIncreasePerSecond,\\n        bytes calldata _queryData,\\n        uint256 _amount\\n    ) external returns (bytes32 _feedId) {\\n        require(\\n            _queryId == keccak256(_queryData),\\n            \\\"id must be hash of bytes data\\\"\\n        );\\n        _feedId = keccak256(\\n            abi.encode(\\n                _queryId,\\n                _reward,\\n                _startTime,\\n                _interval,\\n                _window,\\n                _priceThreshold,\\n                _rewardIncreasePerSecond\\n            )\\n        );\\n        FeedDetails storage _feed = dataFeed[_queryId][_feedId].details;\\n        require(_feed.reward == 0, \\\"feed must not be set up already\\\");\\n        require(_reward > 0, \\\"reward must be greater than zero\\\");\\n        require(_interval > 0, \\\"interval must be greater than zero\\\");\\n        require(\\n            _window < _interval,\\n            \\\"window must be less than interval length\\\"\\n        );\\n        _feed.reward = _reward;\\n        _feed.startTime = _startTime;\\n        _feed.interval = _interval;\\n        _feed.window = _window;\\n        _feed.priceThreshold = _priceThreshold;\\n        _feed.rewardIncreasePerSecond = _rewardIncreasePerSecond;\\n        currentFeeds[_queryId].push(_feedId);\\n        queryIdFromDataFeedId[_feedId] = _queryId;\\n        queryDataStorage.storeData(_queryData);\\n        emit NewDataFeed(_queryId, _feedId, _queryData, msg.sender);\\n        if (_amount > 0) {\\n            fundFeed(_feedId, _queryId, _amount);\\n        }\\n        return _feedId;\\n    }\\n\\n    /**\\n     * @dev Function to run a single tip\\n     * @param _queryId ID of tipped data\\n     * @param _amount amount to tip\\n     * @param _queryData the data used by reporters to fulfill the query\\n     */\\n    function tip(\\n        bytes32 _queryId,\\n        uint256 _amount,\\n        bytes calldata _queryData\\n    ) external {\\n        require(\\n            _queryId == keccak256(_queryData),\\n            \\\"id must be hash of bytes data\\\"\\n        );\\n        require(_amount > 0, \\\"tip must be greater than zero\\\");\\n        Tip[] storage _tips = tips[_queryId];\\n        if (_tips.length == 0) {\\n            _tips.push(Tip(_amount, block.timestamp + 1, _amount));\\n            queryDataStorage.storeData(_queryData);\\n        } else {\\n            (, uint256 _timestampRetrieved) = _getCurrentValue(_queryId);\\n            if (_timestampRetrieved < _tips[_tips.length - 1].timestamp) {\\n                _tips[_tips.length - 1].timestamp = block.timestamp + 1;\\n                _tips[_tips.length - 1].amount += _amount;\\n                _tips[_tips.length - 1].cumulativeTips += _amount;\\n            } else {\\n                _tips.push(\\n                    Tip(\\n                        _amount,\\n                        block.timestamp + 1,\\n                        _tips[_tips.length - 1].cumulativeTips + _amount\\n                    )\\n                );\\n            }\\n        }\\n        if (\\n            queryIdsWithFundingIndex[_queryId] == 0 &&\\n            getCurrentTip(_queryId) > 0\\n        ) {\\n            queryIdsWithFunding.push(_queryId);\\n            queryIdsWithFundingIndex[_queryId] = queryIdsWithFunding.length;\\n        }\\n        require(\\n            token.transferFrom(msg.sender, address(this), _amount),\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        userTipsTotal[msg.sender] += _amount;\\n        emit TipAdded(_queryId, _amount, _queryData, msg.sender);\\n    }\\n\\n    // Getters\\n    /**\\n     * @dev Getter function to read current data feeds\\n     * @param _queryId id of reported data\\n     * @return feedIds array for queryId\\n     */\\n    function getCurrentFeeds(\\n        bytes32 _queryId\\n    ) external view returns (bytes32[] memory) {\\n        return currentFeeds[_queryId];\\n    }\\n\\n    /**\\n     * @dev Getter function to current oneTime tip by queryId\\n     * @param _queryId id of reported data\\n     * @return amount of tip\\n     */\\n    function getCurrentTip(bytes32 _queryId) public view returns (uint256) {\\n        // if no tips, return 0\\n        if (tips[_queryId].length == 0) {\\n            return 0;\\n        }\\n        (, uint256 _timestampRetrieved) = _getCurrentValue(_queryId);\\n        Tip memory _lastTip = tips[_queryId][tips[_queryId].length - 1];\\n        if (_timestampRetrieved < _lastTip.timestamp) {\\n            return _lastTip.amount;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Getter function to read a specific dataFeed\\n     * @param _feedId unique feedId of parameters\\n     * @return FeedDetails details of specified feed\\n     */\\n    function getDataFeed(\\n        bytes32 _feedId\\n    ) external view returns (FeedDetails memory) {\\n        return (dataFeed[queryIdFromDataFeedId[_feedId]][_feedId].details);\\n    }\\n\\n    /**\\n     * @dev Getter function for currently funded feed details\\n     * @return FeedDetailsWithQueryData[] array of details for funded feeds\\n     */\\n    function getFundedFeedDetails()\\n        external\\n        view\\n        returns (FeedDetailsWithQueryData[] memory)\\n    {\\n        bytes32[] memory _feeds = this.getFundedFeeds();\\n        FeedDetailsWithQueryData[]\\n            memory _details = new FeedDetailsWithQueryData[](_feeds.length);\\n        for (uint256 i = 0; i < _feeds.length; i++) {\\n            FeedDetails memory _feedDetail = this.getDataFeed(_feeds[i]);\\n            bytes32 _queryId = this.getQueryIdFromFeedId(_feeds[i]);\\n            bytes memory _queryData = queryDataStorage.getQueryData(_queryId);\\n            _details[i].details = _feedDetail;\\n            _details[i].queryData = _queryData;\\n        }\\n        return _details;\\n    }\\n\\n    /**\\n     * @dev Getter function for currently funded feeds\\n     */\\n    function getFundedFeeds() external view returns (bytes32[] memory) {\\n        return feedsWithFunding;\\n    }\\n\\n    /**\\n     * @dev Getter function for queryIds with current one time tips\\n     */\\n    function getFundedQueryIds() external view returns (bytes32[] memory) {\\n        return queryIdsWithFunding;\\n    }\\n\\n    /**\\n     * @dev Getter function for currently funded single tips with queryData\\n     * @return SingleTipsWithQueryData[] array of current tips\\n     */\\n    function getFundedSingleTipsInfo()\\n        external\\n        view\\n        returns (SingleTipsWithQueryData[] memory)\\n    {\\n        bytes32[] memory _fundedQueryIds = this.getFundedQueryIds();\\n        SingleTipsWithQueryData[] memory _query = new SingleTipsWithQueryData[](\\n            _fundedQueryIds.length\\n        );\\n        for (uint256 i = 0; i < _fundedQueryIds.length; i++) {\\n            bytes memory _data = queryDataStorage.getQueryData(\\n                _fundedQueryIds[i]\\n            );\\n            uint256 _reward = this.getCurrentTip(_fundedQueryIds[i]);\\n            _query[i].queryData = _data;\\n            _query[i].tip = _reward;\\n        }\\n        return _query;\\n    }\\n\\n    /**\\n     * @dev Getter function to get number of past tips\\n     * @param _queryId id of reported data\\n     * @return count of tips available\\n     */\\n    function getPastTipCount(bytes32 _queryId) external view returns (uint256) {\\n        return tips[_queryId].length;\\n    }\\n\\n    /**\\n     * @dev Getter function for past tips\\n     * @param _queryId id of reported data\\n     * @return Tip struct (amount/timestamp) of all past tips\\n     */\\n    function getPastTips(\\n        bytes32 _queryId\\n    ) external view returns (Tip[] memory) {\\n        return tips[_queryId];\\n    }\\n\\n    /**\\n     * @dev Getter function for past tips by index\\n     * @param _queryId id of reported data\\n     * @param _index uint index in the Tip array\\n     * @return amount/timestamp of specific tip\\n     */\\n    function getPastTipByIndex(\\n        bytes32 _queryId,\\n        uint256 _index\\n    ) external view returns (Tip memory) {\\n        return tips[_queryId][_index];\\n    }\\n\\n    /**\\n     * @dev Getter function to lookup query IDs from dataFeed IDs\\n     * @param _feedId dataFeed unique identifier\\n     * @return bytes32 corresponding query ID\\n     */\\n    function getQueryIdFromFeedId(\\n        bytes32 _feedId\\n    ) external view returns (bytes32) {\\n        return queryIdFromDataFeedId[_feedId];\\n    }\\n\\n    /**\\n     * @dev Getter function to read potential rewards for a set of oracle submissions\\n     * NOTE: Does not consider reporter address, 12-hour dispute buffer period, or duplicate timestamps\\n     * @param _feedId dataFeed unique identifier\\n     * @param _queryId unique identifier of reported data\\n     * @param _timestamps array of timestamps of oracle submissions\\n     * @return _cumulativeReward total potential reward for the set of oracle submissions\\n     */\\n    function getRewardAmount(\\n        bytes32 _feedId,\\n        bytes32 _queryId,\\n        uint256[] calldata _timestamps\\n    ) external view returns (uint256 _cumulativeReward) {\\n        FeedDetails storage _feed = dataFeed[_queryId][_feedId].details;\\n        for (uint256 _i = 0; _i < _timestamps.length; _i++) {\\n            _cumulativeReward += _getRewardAmount(\\n                _feedId,\\n                _queryId,\\n                _timestamps[_i]\\n            );\\n        }\\n        if (_cumulativeReward > _feed.balance) {\\n            _cumulativeReward = _feed.balance;\\n        }\\n        _cumulativeReward -= ((_cumulativeReward * fee) / 1000);\\n    }\\n\\n    /**\\n     * @dev Getter function for reading whether a reward has been claimed\\n     * @param _feedId feedId of dataFeed\\n     * @param _queryId id of reported data\\n     * @param _timestamp id or reported data\\n     * @return bool rewardClaimed\\n     */\\n    function getRewardClaimedStatus(\\n        bytes32 _feedId,\\n        bytes32 _queryId,\\n        uint256 _timestamp\\n    ) external view returns (bool) {\\n        return dataFeed[_queryId][_feedId].rewardClaimed[_timestamp];\\n    }\\n\\n    /**\\n     * @dev Getter function for reading whether a reward has been claimed\\n     * @param _feedId feedId of dataFeed\\n     * @param _queryId queryId of reported data\\n     * @param _timestamp[] list of report timestamps\\n     * @return bool[] list of rewardClaim status\\n     */\\n    function getRewardClaimStatusList(\\n        bytes32 _feedId,\\n        bytes32 _queryId,\\n        uint256[] calldata _timestamp\\n    ) external view returns (bool[] memory) {\\n        bool[] memory _status = new bool[](_timestamp.length);\\n        for (uint256 i = 0; i < _timestamp.length; i++) {\\n            _status[i] = dataFeed[_queryId][_feedId].rewardClaimed[\\n                _timestamp[i]\\n            ];\\n        }\\n        return _status;\\n    }\\n\\n    /**\\n     * @dev Getter function for retrieving the total amount of tips paid by a given address\\n     * @param _user address of user to query\\n     * @return uint256 total amount of tips paid by user\\n     */\\n    function getTipsByAddress(address _user) external view returns (uint256) {\\n        return userTipsTotal[_user];\\n    }\\n\\n    // Internal functions\\n    /**\\n     * @dev Internal function to read if a reward has been claimed\\n     * @param _b bytes value to convert to uint256\\n     * @return _number uint256 converted from bytes\\n     */\\n    function _bytesToUint(\\n        bytes memory _b\\n    ) internal pure returns (uint256 _number) {\\n        for (uint256 _i = 0; _i < _b.length; _i++) {\\n            _number = _number * 256 + uint8(_b[_i]);\\n        }\\n    }\\n\\n    /**\\n     ** @dev Internal function which determines tip eligibility for a given oracle submission\\n     * @param _queryId id of reported data\\n     * @param _timestamp timestamp of one time tip\\n     * @return _tipAmount of tip\\n     */\\n    function _getOneTimeTipAmount(\\n        bytes32 _queryId,\\n        uint256 _timestamp\\n    ) internal returns (uint256 _tipAmount) {\\n        require(\\n            block.timestamp - _timestamp > 12 hours,\\n            \\\"buffer time has not passed\\\"\\n        );\\n        require(!isInDispute(_queryId, _timestamp), \\\"value disputed\\\");\\n        require(\\n            msg.sender == getReporterByTimestamp(_queryId, _timestamp),\\n            \\\"msg sender must be reporter address\\\"\\n        );\\n        Tip[] storage _tips = tips[_queryId];\\n        uint256 _min = 0;\\n        uint256 _max = _tips.length;\\n        uint256 _mid;\\n        while (_max - _min > 1) {\\n            _mid = (_max + _min) / 2;\\n            if (_tips[_mid].timestamp > _timestamp) {\\n                _max = _mid;\\n            } else {\\n                _min = _mid;\\n            }\\n        }\\n        (, uint256 _timestampBefore) = getDataBefore(_queryId, _timestamp);\\n        require(\\n            _timestampBefore < _tips[_min].timestamp,\\n            \\\"tip earned by previous submission\\\"\\n        );\\n        require(\\n            _timestamp >= _tips[_min].timestamp,\\n            \\\"timestamp not eligible for tip\\\"\\n        );\\n        require(_tips[_min].amount > 0, \\\"tip already claimed\\\");\\n        _tipAmount = _tips[_min].amount;\\n        _tips[_min].amount = 0;\\n        uint256 _minBackup = _min;\\n        // check whether eligible for previous tips in array due to disputes\\n        (, uint256 _indexNow) = getIndexForDataBefore(_queryId, _timestamp + 1);\\n        (bool _found, uint256 _indexBefore) = getIndexForDataBefore(\\n            _queryId,\\n            _timestampBefore + 1\\n        );\\n        if (_indexNow - _indexBefore > 1 || !_found) {\\n            if (!_found) {\\n                _tipAmount = _tips[_minBackup].cumulativeTips;\\n            } else {\\n                _max = _min;\\n                _min = 0;\\n                _mid;\\n                while (_max - _min > 1) {\\n                    _mid = (_max + _min) / 2;\\n                    if (_tips[_mid].timestamp > _timestampBefore) {\\n                        _max = _mid;\\n                    } else {\\n                        _min = _mid;\\n                    }\\n                }\\n                _min++;\\n                if (_min < _minBackup) {\\n                    _tipAmount =\\n                        _tips[_minBackup].cumulativeTips -\\n                        _tips[_min].cumulativeTips +\\n                        _tips[_min].amount;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Allows the user to get the latest value for the queryId specified\\n     * @param _queryId is the id to look up the value for\\n     * @return _value the value retrieved\\n     * @return _timestampRetrieved the retrieved value's timestamp\\n     */\\n\\n    function _getCurrentValue(\\n        bytes32 _queryId\\n    ) internal view returns (bytes memory _value, uint256 _timestampRetrieved) {\\n        uint256 _count = getNewValueCountbyQueryId(_queryId);\\n        if (_count == 0) {\\n            return (bytes(\\\"\\\"), 0);\\n        }\\n        uint256 _time;\\n        //loop handles for dispute (value = \\\"\\\" if disputed)\\n        while (_count > 0) {\\n            _count--;\\n            _time = getTimestampbyQueryIdandIndex(_queryId, _count);\\n            _value = retrieveData(_queryId, _time);\\n            if (_value.length > 0) {\\n                return (_value, _time);\\n            }\\n        }\\n        return (bytes(\\\"\\\"), _time);\\n    }\\n\\n    /**\\n     * @dev Internal function which determines the reward amount for a given oracle submission\\n     * @param _feedId id of dataFeed\\n     * @param _queryId id of reported data\\n     * @param _timestamp timestamp of reported data eligible for reward\\n     * @return _rewardAmount potential reward amount for the given oracle submission\\n     */\\n    function _getRewardAmount(\\n        bytes32 _feedId,\\n        bytes32 _queryId,\\n        uint256 _timestamp\\n    ) internal view returns (uint256 _rewardAmount) {\\n        require(\\n            block.timestamp - _timestamp < 4 weeks,\\n            \\\"timestamp too old to claim tip\\\"\\n        );\\n        Feed storage _feed = dataFeed[_queryId][_feedId];\\n        require(!_feed.rewardClaimed[_timestamp], \\\"reward already claimed\\\");\\n        uint256 _n = (_timestamp - _feed.details.startTime) /\\n            _feed.details.interval; // finds closest interval _n to timestamp\\n        uint256 _c = _feed.details.startTime + _feed.details.interval * _n; // finds start timestamp _c of interval _n\\n        bytes memory _valueRetrieved = retrieveData(_queryId, _timestamp);\\n        require(_valueRetrieved.length != 0, \\\"no value exists at timestamp\\\");\\n        (\\n            bytes memory _valueRetrievedBefore,\\n            uint256 _timestampBefore\\n        ) = getDataBefore(_queryId, _timestamp);\\n        uint256 _priceChange = 0; // price change from last value to current value\\n        if (_feed.details.priceThreshold != 0) {\\n            uint256 _v1 = _bytesToUint(_valueRetrieved);\\n            uint256 _v2 = _bytesToUint(_valueRetrievedBefore);\\n            if (_v2 == 0) {\\n                _priceChange = 10000;\\n            } else if (_v1 >= _v2) {\\n                _priceChange = (10000 * (_v1 - _v2)) / _v2;\\n            } else {\\n                _priceChange = (10000 * (_v2 - _v1)) / _v2;\\n            }\\n        }\\n        _rewardAmount = _feed.details.reward;\\n        uint256 _timeDiff = _timestamp - _c; // time difference between report timestamp and start of interval\\n        // ensure either report is first within a valid window, or price change threshold is met\\n        if (_timeDiff < _feed.details.window && _timestampBefore < _c) {\\n            // add time based rewards if applicable\\n            _rewardAmount += _feed.details.rewardIncreasePerSecond * _timeDiff;\\n        } else {\\n            require(\\n                _priceChange > _feed.details.priceThreshold,\\n                \\\"price threshold not met\\\"\\n            );\\n        }\\n\\n        if (_feed.details.balance < _rewardAmount) {\\n            _rewardAmount = _feed.details.balance;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"autopay/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\ninterface IERC20 {\\n  function transfer(address _to, uint256 _amount) external returns(bool);\\n  function transferFrom(address _from, address _to, uint256 _amount) external returns(bool);\\n  function approve(address _spender, uint256 _amount) external returns(bool);\\n}\\n\"\r\n    },\r\n    \"autopay/contracts/interfaces/IQueryDataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IQueryDataStorage {\\n  function storeData(bytes memory _queryData) external; \\n  function getQueryData(bytes32 _queryId) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"usingtellor/contracts/interface/IERC2362.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/**\\n    * @dev EIP2362 Interface for pull oracles\\n    * https://github.com/tellor-io/EIP-2362\\n*/\\ninterface IERC2362\\n{\\n\\t/**\\n\\t * @dev Exposed function pertaining to EIP standards\\n\\t * @param _id bytes32 ID of the query\\n\\t * @return int,uint,uint returns the value, timestamp, and status code of query\\n\\t */\\n\\tfunction valueFor(bytes32 _id) external view returns(int256,uint256,uint256);\\n}\"\r\n    },\r\n    \"usingtellor/contracts/interface/IMappingContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IMappingContract{\\n    function getTellorID(bytes32 _id) external view returns(bytes32);\\n}\"\r\n    },\r\n    \"usingtellor/contracts/interface/ITellor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface ITellor {\\n    //Controller\\n    function addresses(bytes32) external view returns (address);\\n\\n    function uints(bytes32) external view returns (uint256);\\n\\n    function burn(uint256 _amount) external;\\n\\n    function changeDeity(address _newDeity) external;\\n\\n    function changeOwner(address _newOwner) external;\\n    function changeUint(bytes32 _target, uint256 _amount) external;\\n\\n    function migrate() external;\\n\\n    function mint(address _reciever, uint256 _amount) external;\\n\\n    function init() external;\\n\\n    function getAllDisputeVars(uint256 _disputeId)\\n        external\\n        view\\n        returns (\\n            bytes32,\\n            bool,\\n            bool,\\n            bool,\\n            address,\\n            address,\\n            address,\\n            uint256[9] memory,\\n            int256\\n        );\\n\\n    function getDisputeIdByDisputeHash(bytes32 _hash)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getLastNewValueById(uint256 _requestId)\\n        external\\n        view\\n        returns (uint256, bool);\\n\\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getNewValueCountbyRequestId(uint256 _requestId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getAddressVars(bytes32 _data) external view returns (address);\\n\\n    function getUintVar(bytes32 _data) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function isMigrated(address _addy) external view returns (bool);\\n\\n    function allowance(address _user, address _spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function allowedToTrade(address _user, uint256 _amount)\\n        external\\n        view\\n        returns (bool);\\n\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\n\\n    function approveAndTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external returns (bool);\\n\\n    function balanceOf(address _user) external view returns (uint256);\\n\\n    function balanceOfAt(address _user, uint256 _blockNumber)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function transfer(address _to, uint256 _amount)\\n        external\\n        returns (bool success);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external returns (bool success);\\n\\n    function depositStake() external;\\n\\n    function requestStakingWithdraw() external;\\n\\n    function withdrawStake() external;\\n\\n    function changeStakingStatus(address _reporter, uint256 _status) external;\\n\\n    function slashReporter(address _reporter, address _disputer) external;\\n\\n    function getStakerInfo(address _staker)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function getTimestampbyRequestIDandIndex(uint256 _requestId, uint256 _index)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getNewCurrentVariables()\\n        external\\n        view\\n        returns (\\n            bytes32 _c,\\n            uint256[5] memory _r,\\n            uint256 _d,\\n            uint256 _t\\n        );\\n\\n    function getNewValueCountbyQueryId(bytes32 _queryId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\\n        external\\n        view\\n        returns (bytes memory);\\n\\n    //Governance\\n    enum VoteResult {\\n        FAILED,\\n        PASSED,\\n        INVALID\\n    }\\n\\n    function setApprovedFunction(bytes4 _func, bool _val) external;\\n\\n    function beginDispute(bytes32 _queryId, uint256 _timestamp) external;\\n\\n    function delegate(address _delegate) external;\\n\\n    function delegateOfAt(address _user, uint256 _blockNumber)\\n        external\\n        view\\n        returns (address);\\n\\n    function executeVote(uint256 _disputeId) external;\\n\\n    function proposeVote(\\n        address _contract,\\n        bytes4 _function,\\n        bytes calldata _data,\\n        uint256 _timestamp\\n    ) external;\\n\\n    function tallyVotes(uint256 _disputeId) external;\\n\\n    function governance() external view returns (address);\\n\\n    function updateMinDisputeFee() external;\\n\\n    function verify() external pure returns (uint256);\\n\\n    function vote(\\n        uint256 _disputeId,\\n        bool _supports,\\n        bool _invalidQuery\\n    ) external;\\n\\n    function voteFor(\\n        address[] calldata _addys,\\n        uint256 _disputeId,\\n        bool _supports,\\n        bool _invalidQuery\\n    ) external;\\n\\n    function getDelegateInfo(address _holder)\\n        external\\n        view\\n        returns (address, uint256);\\n\\n    function isFunctionApproved(bytes4 _func) external view returns (bool);\\n\\n    function isApprovedGovernanceContract(address _contract)\\n        external\\n        returns (bool);\\n\\n    function getVoteRounds(bytes32 _hash)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function getVoteCount() external view returns (uint256);\\n\\n    function getVoteInfo(uint256 _disputeId)\\n        external\\n        view\\n        returns (\\n            bytes32,\\n            uint256[9] memory,\\n            bool[2] memory,\\n            VoteResult,\\n            bytes memory,\\n            bytes4,\\n            address[2] memory\\n        );\\n\\n    function getDisputeInfo(uint256 _disputeId)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            bytes memory,\\n            address\\n        );\\n\\n    function getOpenDisputesOnId(bytes32 _queryId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function didVote(uint256 _disputeId, address _voter)\\n        external\\n        view\\n        returns (bool);\\n\\n    //Oracle\\n    function getReportTimestampByIndex(bytes32 _queryId, uint256 _index)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getValueByTimestamp(bytes32 _queryId, uint256 _timestamp)\\n        external\\n        view\\n        returns (bytes memory);\\n\\n    function getBlockNumberByTimestamp(bytes32 _queryId, uint256 _timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getReportingLock() external view returns (uint256);\\n\\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp)\\n        external\\n        view\\n        returns (address);\\n\\n    function reportingLock() external view returns (uint256);\\n\\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external;\\n    function getTipsByUser(address _user) external view returns(uint256);\\n    function tipQuery(bytes32 _queryId, uint256 _tip, bytes memory _queryData) external;\\n    function submitValue(bytes32 _queryId, bytes calldata _value, uint256 _nonce, bytes memory _queryData) external;\\n    function burnTips() external;\\n\\n    function changeReportingLock(uint256 _newReportingLock) external;\\n    function getReportsSubmittedByAddress(address _reporter) external view returns(uint256);\\n    function changeTimeBasedReward(uint256 _newTimeBasedReward) external;\\n    function getReporterLastTimestamp(address _reporter) external view returns(uint256);\\n    function getTipsById(bytes32 _queryId) external view returns(uint256);\\n    function getTimeBasedReward() external view returns(uint256);\\n    function getTimestampCountById(bytes32 _queryId) external view returns(uint256);\\n    function getTimestampIndexByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\\n    function getCurrentReward(bytes32 _queryId) external view returns(uint256, uint256);\\n    function getCurrentValue(bytes32 _queryId) external view returns(bytes memory);\\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp) external view returns(bool _ifRetrieve, bytes memory _value, uint256 _timestampRetrieved);\\n    function getTimeOfLastNewValue() external view returns(uint256);\\n    function depositStake(uint256 _amount) external;\\n    function requestStakingWithdraw(uint256 _amount) external;\\n\\n    //Test functions\\n    function changeAddressVar(bytes32 _id, address _addy) external;\\n\\n    //parachute functions\\n    function killContract() external;\\n\\n    function migrateFor(address _destination, uint256 _amount) external;\\n\\n    function rescue51PercentAttack(address _tokenHolder) external;\\n\\n    function rescueBrokenDataReporting() external;\\n\\n    function rescueFailedUpdate() external;\\n\\n    //Tellor 360\\n    function addStakingRewards(uint256 _amount) external;\\n\\n    function _sliceUint(bytes memory _b)\\n        external\\n        pure\\n        returns (uint256 _number);\\n\\n    function claimOneTimeTip(bytes32 _queryId, uint256[] memory _timestamps)\\n        external;\\n\\n    function claimTip(\\n        bytes32 _feedId,\\n        bytes32 _queryId,\\n        uint256[] memory _timestamps\\n    ) external;\\n\\n    function fee() external view returns (uint256);\\n\\n    function feedsWithFunding(uint256) external view returns (bytes32);\\n\\n    function fundFeed(\\n        bytes32 _feedId,\\n        bytes32 _queryId,\\n        uint256 _amount\\n    ) external;\\n\\n    function getCurrentFeeds(bytes32 _queryId)\\n        external\\n        view\\n        returns (bytes32[] memory);\\n\\n    function getCurrentTip(bytes32 _queryId) external view returns (uint256);\\n\\n    function getDataAfter(bytes32 _queryId, uint256 _timestamp)\\n        external\\n        view\\n        returns (bytes memory _value, uint256 _timestampRetrieved);\\n\\n    function getDataFeed(bytes32 _feedId)\\n        external\\n        view\\n        returns (Autopay.FeedDetails memory);\\n\\n    function getFundedFeeds() external view returns (bytes32[] memory);\\n\\n    function getFundedQueryIds() external view returns (bytes32[] memory);\\n\\n    function getIndexForDataAfter(bytes32 _queryId, uint256 _timestamp)\\n        external\\n        view\\n        returns (bool _found, uint256 _index);\\n\\n    function getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp)\\n        external\\n        view\\n        returns (bool _found, uint256 _index);\\n\\n    function getMultipleValuesBefore(\\n        bytes32 _queryId,\\n        uint256 _timestamp,\\n        uint256 _maxAge,\\n        uint256 _maxCount\\n    )\\n        external\\n        view\\n        returns (uint256[] memory _values, uint256[] memory _timestamps);\\n\\n    function getPastTipByIndex(bytes32 _queryId, uint256 _index)\\n        external\\n        view\\n        returns (Autopay.Tip memory);\\n\\n    function getPastTipCount(bytes32 _queryId) external view returns (uint256);\\n\\n    function getPastTips(bytes32 _queryId)\\n        external\\n        view\\n        returns (Autopay.Tip[] memory);\\n\\n    function getQueryIdFromFeedId(bytes32 _feedId)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    function getRewardAmount(\\n        bytes32 _feedId,\\n        bytes32 _queryId,\\n        uint256[] memory _timestamps\\n    ) external view returns (uint256 _cumulativeReward);\\n\\n    function getRewardClaimedStatus(\\n        bytes32 _feedId,\\n        bytes32 _queryId,\\n        uint256 _timestamp\\n    ) external view returns (bool);\\n\\n    function getTipsByAddress(address _user) external view returns (uint256);\\n\\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\\n        external\\n        view\\n        returns (bool);\\n\\n    function queryIdFromDataFeedId(bytes32) external view returns (bytes32);\\n\\n    function queryIdsWithFunding(uint256) external view returns (bytes32);\\n\\n    function queryIdsWithFundingIndex(bytes32) external view returns (uint256);\\n\\n    function setupDataFeed(\\n        bytes32 _queryId,\\n        uint256 _reward,\\n        uint256 _startTime,\\n        uint256 _interval,\\n        uint256 _window,\\n        uint256 _priceThreshold,\\n        uint256 _rewardIncreasePerSecond,\\n        bytes memory _queryData,\\n        uint256 _amount\\n    ) external;\\n\\n    function tellor() external view returns (address);\\n\\n    function tip(\\n        bytes32 _queryId,\\n        uint256 _amount,\\n        bytes memory _queryData\\n    ) external;\\n\\n    function tips(bytes32, uint256)\\n        external\\n        view\\n        returns (uint256 amount, uint256 timestamp);\\n\\n    function token() external view returns (address);\\n\\n    function userTipsTotal(address) external view returns (uint256);\\n\\n    function valueFor(bytes32 _id)\\n        external\\n        view\\n        returns (\\n            int256 _value,\\n            uint256 _timestamp,\\n            uint256 _statusCode\\n        );\\n}\\n\\ninterface Autopay {\\n    struct FeedDetails {\\n        uint256 reward;\\n        uint256 balance;\\n        uint256 startTime;\\n        uint256 interval;\\n        uint256 window;\\n        uint256 priceThreshold;\\n        uint256 rewardIncreasePerSecond;\\n        uint256 feedsWithFundingIndex;\\n    }\\n\\n    struct Tip {\\n        uint256 amount;\\n        uint256 timestamp;\\n    }\\n    function getStakeAmount() external view returns(uint256);\\n    function stakeAmount() external view returns(uint256);\\n    function token() external view returns(address);\\n}\\n\"\r\n    },\r\n    \"usingtellor/contracts/UsingTellor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"./interface/ITellor.sol\\\";\\nimport \\\"./interface/IERC2362.sol\\\";\\nimport \\\"./interface/IMappingContract.sol\\\";\\n\\n/**\\n @author Tellor Inc\\n @title UsingTellor\\n @dev This contract helps smart contracts read data from Tellor\\n */\\ncontract UsingTellor is IERC2362 {\\n    ITellor public tellor;\\n    IMappingContract public idMappingContract;\\n\\n    /*Constructor*/\\n    /**\\n     * @dev the constructor sets the oracle address in storage\\n     * @param _tellor is the Tellor Oracle address\\n     */\\n    constructor(address payable _tellor) {\\n        tellor = ITellor(_tellor);\\n    }\\n\\n    /*Getters*/\\n    /**\\n     * @dev Retrieves the next value for the queryId after the specified timestamp\\n     * @param _queryId is the queryId to look up the value for\\n     * @param _timestamp after which to search for next value\\n     * @return _value the value retrieved\\n     * @return _timestampRetrieved the value's timestamp\\n     */\\n    function getDataAfter(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bytes memory _value, uint256 _timestampRetrieved)\\n    {\\n        (bool _found, uint256 _index) = getIndexForDataAfter(\\n            _queryId,\\n            _timestamp\\n        );\\n        if (!_found) {\\n            return (\\\"\\\", 0);\\n        }\\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _index);\\n        _value = retrieveData(_queryId, _timestampRetrieved);\\n        return (_value, _timestampRetrieved);\\n    }\\n\\n    /**\\n     * @dev Retrieves the latest value for the queryId before the specified timestamp\\n     * @param _queryId is the queryId to look up the value for\\n     * @param _timestamp before which to search for latest value\\n     * @return _value the value retrieved\\n     * @return _timestampRetrieved the value's timestamp\\n     */\\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bytes memory _value, uint256 _timestampRetrieved)\\n    {\\n        (, _value, _timestampRetrieved) = tellor.getDataBefore(\\n            _queryId,\\n            _timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\\n     * @param _queryId is the queryId to look up the index for\\n     * @param _timestamp is the timestamp before which to search for the latest index\\n     * @return _found whether the index was found\\n     * @return _index the latest index found before the specified timestamp\\n     */\\n    // slither-disable-next-line calls-loop\\n    function getIndexForDataAfter(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bool _found, uint256 _index)\\n    {\\n        uint256 _count = getNewValueCountbyQueryId(_queryId);\\n        if (_count == 0) return (false, 0);\\n        _count--;\\n        bool _search = true; // perform binary search\\n        uint256 _middle = 0;\\n        uint256 _start = 0;\\n        uint256 _end = _count;\\n        uint256 _timestampRetrieved;\\n        // checking boundaries to short-circuit the algorithm\\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _end);\\n        if (_timestampRetrieved <= _timestamp) return (false, 0);\\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _start);\\n        if (_timestampRetrieved > _timestamp) {\\n            // candidate found, check for disputes\\n            _search = false;\\n        }\\n        // since the value is within our boundaries, do a binary search\\n        while (_search) {\\n            _middle = (_end + _start) / 2;\\n            _timestampRetrieved = getTimestampbyQueryIdandIndex(\\n                _queryId,\\n                _middle\\n            );\\n            if (_timestampRetrieved > _timestamp) {\\n                // get immediate previous value\\n                uint256 _prevTime = getTimestampbyQueryIdandIndex(\\n                    _queryId,\\n                    _middle - 1\\n                );\\n                if (_prevTime <= _timestamp) {\\n                    // candidate found, check for disputes\\n                    _search = false;\\n                } else {\\n                    // look from start to middle -1(prev value)\\n                    _end = _middle - 1;\\n                }\\n            } else {\\n                // get immediate next value\\n                uint256 _nextTime = getTimestampbyQueryIdandIndex(\\n                    _queryId,\\n                    _middle + 1\\n                );\\n                if (_nextTime > _timestamp) {\\n                    // candidate found, check for disputes\\n                    _search = false;\\n                    _middle++;\\n                    _timestampRetrieved = _nextTime;\\n                } else {\\n                    // look from middle + 1(next value) to end\\n                    _start = _middle + 1;\\n                }\\n            }\\n        }\\n        // candidate found, check for disputed values\\n        if (!isInDispute(_queryId, _timestampRetrieved)) {\\n            // _timestampRetrieved is correct\\n            return (true, _middle);\\n        } else {\\n            // iterate forward until we find a non-disputed value\\n            while (\\n                isInDispute(_queryId, _timestampRetrieved) && _middle < _count\\n            ) {\\n                _middle++;\\n                _timestampRetrieved = getTimestampbyQueryIdandIndex(\\n                    _queryId,\\n                    _middle\\n                );\\n            }\\n            if (\\n                _middle == _count && isInDispute(_queryId, _timestampRetrieved)\\n            ) {\\n                return (false, 0);\\n            }\\n            // _timestampRetrieved is correct\\n            return (true, _middle);\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\\n     * @param _queryId is the queryId to look up the index for\\n     * @param _timestamp is the timestamp before which to search for the latest index\\n     * @return _found whether the index was found\\n     * @return _index the latest index found before the specified timestamp\\n     */\\n    // slither-disable-next-line calls-loop\\n    function getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bool _found, uint256 _index)\\n    {\\n        return tellor.getIndexForDataBefore(_queryId, _timestamp);\\n    }\\n\\n    /**\\n     * @dev Retrieves multiple uint256 values before the specified timestamp\\n     * @param _queryId the unique id of the data query\\n     * @param _timestamp the timestamp before which to search for values\\n     * @param _maxAge the maximum number of seconds before the _timestamp to search for values\\n     * @param _maxCount the maximum number of values to return\\n     * @return _values the values retrieved, ordered from oldest to newest\\n     * @return _timestamps the timestamps of the values retrieved\\n     */\\n    function getMultipleValuesBefore(\\n        bytes32 _queryId,\\n        uint256 _timestamp,\\n        uint256 _maxAge,\\n        uint256 _maxCount\\n    )\\n        public\\n        view\\n        returns (bytes[] memory _values, uint256[] memory _timestamps)\\n    {\\n        // get index of first possible value\\n        (bool _ifRetrieve, uint256 _startIndex) = getIndexForDataAfter(\\n            _queryId,\\n            _timestamp - _maxAge\\n        );\\n        // no value within range\\n        if (!_ifRetrieve) {\\n            return (new bytes[](0), new uint256[](0));\\n        }\\n        uint256 _endIndex;\\n        // get index of last possible value\\n        (_ifRetrieve, _endIndex) = getIndexForDataBefore(_queryId, _timestamp);\\n        // no value before _timestamp\\n        if (!_ifRetrieve) {\\n            return (new bytes[](0), new uint256[](0));\\n        }\\n        uint256 _valCount = 0;\\n        uint256 _index = 0;\\n        uint256[] memory _timestampsArrayTemp = new uint256[](_maxCount);\\n        // generate array of non-disputed timestamps within range\\n        while (_valCount < _maxCount && _endIndex + 1 - _index > _startIndex) {\\n            uint256 _timestampRetrieved = getTimestampbyQueryIdandIndex(\\n                _queryId,\\n                _endIndex - _index\\n            );\\n            if (!isInDispute(_queryId, _timestampRetrieved)) {\\n                _timestampsArrayTemp[_valCount] = _timestampRetrieved;\\n                _valCount++;\\n            }\\n            _index++;\\n        }\\n\\n        bytes[] memory _valuesArray = new bytes[](_valCount);\\n        uint256[] memory _timestampsArray = new uint256[](_valCount);\\n        // retrieve values and reverse timestamps order\\n        for (uint256 _i = 0; _i < _valCount; _i++) {\\n            _timestampsArray[_i] = _timestampsArrayTemp[_valCount - 1 - _i];\\n            _valuesArray[_i] = retrieveData(_queryId, _timestampsArray[_i]);\\n        }\\n        return (_valuesArray, _timestampsArray);\\n    }\\n\\n    /**\\n     * @dev Counts the number of values that have been submitted for the queryId\\n     * @param _queryId the id to look up\\n     * @return uint256 count of the number of values received for the queryId\\n     */\\n    function getNewValueCountbyQueryId(bytes32 _queryId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return tellor.getNewValueCountbyQueryId(_queryId);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the reporter who submitted a value for a data ID at a specific time\\n     * @param _queryId is ID of the specific data feed\\n     * @param _timestamp is the timestamp to find a corresponding reporter for\\n     * @return address of the reporter who reported the value for the data ID at the given timestamp\\n     */\\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return tellor.getReporterByTimestamp(_queryId, _timestamp);\\n    }\\n\\n    /**\\n     * @dev Gets the timestamp for the value based on their index\\n     * @param _queryId is the id to look up\\n     * @param _index is the value index to look up\\n     * @return uint256 timestamp\\n     */\\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return tellor.getTimestampbyQueryIdandIndex(_queryId, _index);\\n    }\\n\\n    /**\\n     * @dev Determines whether a value with a given queryId and timestamp has been disputed\\n     * @param _queryId is the value id to look up\\n     * @param _timestamp is the timestamp of the value to look up\\n     * @return bool true if queryId/timestamp is under dispute\\n     */\\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return tellor.isInDispute(_queryId, _timestamp);\\n    }\\n\\n    /**\\n     * @dev Retrieve value from oracle based on queryId/timestamp\\n     * @param _queryId being requested\\n     * @param _timestamp to retrieve data/value from\\n     * @return bytes value for query/timestamp submitted\\n     */\\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bytes memory)\\n    {\\n        return tellor.retrieveData(_queryId, _timestamp);\\n    }\\n\\n    /**\\n     * @dev allows dev to set mapping contract for valueFor (EIP2362)\\n     * @param _addy address of mapping contract\\n     */\\n    function setIdMappingContract(address _addy) external {\\n        require(address(idMappingContract) == address(0));\\n        idMappingContract = IMappingContract(_addy);\\n    }\\n\\n    /**\\n     * @dev Retrieve most recent int256 value from oracle based on queryId\\n     * @param _id being requested\\n     * @return _value most recent value submitted\\n     * @return _timestamp timestamp of most recent value\\n     * @return _statusCode 200 if value found, 404 if not found\\n     */\\n    function valueFor(bytes32 _id)\\n        external\\n        view\\n        override\\n        returns (\\n            int256 _value,\\n            uint256 _timestamp,\\n            uint256 _statusCode\\n        )\\n    {\\n        bytes32 _queryId = idMappingContract.getTellorID(_id);\\n        bytes memory _valueBytes;\\n        (_valueBytes, _timestamp) = getDataBefore(\\n            _queryId,\\n            block.timestamp + 1\\n        );\\n        if (_timestamp == 0) {\\n            return (0, 0, 404);\\n        }\\n        uint256 _valueUint = _sliceUint(_valueBytes);\\n        _value = int256(_valueUint);\\n        return (_value, _timestamp, 200);\\n    }\\n\\n    // Internal functions\\n    /**\\n     * @dev Convert bytes to uint256\\n     * @param _b bytes value to convert to uint256\\n     * @return _number uint256 converted from bytes\\n     */\\n    function _sliceUint(bytes memory _b)\\n        internal\\n        pure\\n        returns (uint256 _number)\\n    {\\n        for (uint256 _i = 0; _i < _b.length; _i++) {\\n            _number = _number * 256 + uint8(_b[_i]);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_tellor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_queryDataStorage\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_feedId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_feedFunder\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardIncreasePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feedsWithFundingIndex\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Autopay.FeedDetails\",\"name\":\"_feedDetails\",\"type\":\"tuple\"}],\"name\":\"DataFeedFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_feedId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_queryData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_feedCreator\",\"type\":\"address\"}],\"name\":\"NewDataFeed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"}],\"name\":\"OneTimeTipClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_queryData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tipper\",\"type\":\"address\"}],\"name\":\"TipAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_feedId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"}],\"name\":\"TipClaimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"_timestamps\",\"type\":\"uint256[]\"}],\"name\":\"claimOneTimeTip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_feedId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"_timestamps\",\"type\":\"uint256[]\"}],\"name\":\"claimTip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feedsWithFunding\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_feedId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"fundFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getCurrentFeeds\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getCurrentTip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getDataAfter\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"_value\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getDataBefore\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"_value\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_feedId\",\"type\":\"bytes32\"}],\"name\":\"getDataFeed\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardIncreasePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feedsWithFundingIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct Autopay.FeedDetails\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFundedFeedDetails\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardIncreasePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feedsWithFundingIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct Autopay.FeedDetails\",\"name\":\"details\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"queryData\",\"type\":\"bytes\"}],\"internalType\":\"struct Autopay.FeedDetailsWithQueryData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFundedFeeds\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFundedQueryIds\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFundedSingleTipsInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"queryData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"tip\",\"type\":\"uint256\"}],\"internalType\":\"struct Autopay.SingleTipsWithQueryData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getIndexForDataAfter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_found\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getIndexForDataBefore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_found\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxCount\",\"type\":\"uint256\"}],\"name\":\"getMultipleValuesBefore\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_values\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_timestamps\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getNewValueCountbyQueryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPastTipByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeTips\",\"type\":\"uint256\"}],\"internalType\":\"struct Autopay.Tip\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getPastTipCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getPastTips\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeTips\",\"type\":\"uint256\"}],\"internalType\":\"struct Autopay.Tip[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_feedId\",\"type\":\"bytes32\"}],\"name\":\"getQueryIdFromFeedId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getReporterByTimestamp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_feedId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"_timestamps\",\"type\":\"uint256[]\"}],\"name\":\"getRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_cumulativeReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_feedId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"_timestamp\",\"type\":\"uint256[]\"}],\"name\":\"getRewardClaimStatusList\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_feedId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getRewardClaimedStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTimestampbyQueryIdandIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTipsByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idMappingContract\",\"outputs\":[{\"internalType\":\"contract IMappingContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"isInDispute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryDataStorage\",\"outputs\":[{\"internalType\":\"contract IQueryDataStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"queryIdFromDataFeedId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"queryIdsWithFunding\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"queryIdsWithFundingIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"setIdMappingContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_window\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardIncreasePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_queryData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setupDataFeed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_feedId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tellor\",\"outputs\":[{\"internalType\":\"contract ITellor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_queryData\",\"type\":\"bytes\"}],\"name\":\"tip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeTips\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTipsTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"valueFor\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"_value\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_statusCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Autopay", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "300", "ConstructorArguments": "0000000000000000000000008cfc184c877154a8f9ffe0fe75649dbe5e2dbebf000000000000000000000000b0ff935b775a70504b810cf97c39987058e185500000000000000000000000000000000000000000000000000000000000000014", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}