{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.16;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\npragma solidity ^0.8.16;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.8.16;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x095ea7b3, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: APPROVE_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IPawToken is IERC20 {\r\n    function devLocked() external view returns (bool);\r\n}\r\n\r\ncontract Protocol is Ownable {\r\n    enum Status {\r\n        OPEN,\r\n        WORKING,\r\n        CLOSED,\r\n        CANCELED\r\n    }\r\n    enum Role {\r\n        SUPPLY,\r\n        BORROW\r\n    }\r\n    struct SupportedTokenSettings {\r\n        bool isRewarded;\r\n        uint256 denominator;\r\n    }\r\n\r\n    struct Order {\r\n        uint256 id;\r\n        address lender;\r\n        address borrower;\r\n        address loanToken;\r\n        uint256 loanAmount;\r\n        address collateralToken;\r\n        uint256 collateralAmount;\r\n        uint256 lenderFeeAmount;\r\n        uint256[] timestamps;\r\n        uint256 rewardAmount;\r\n        Status status;\r\n        Role role;\r\n    }\r\n\r\n    address public governanceContract;\r\n    IPawToken public protocolToken;\r\n\r\n    uint256 public protocolTokenDecimals = 18;\r\n    // Orders\r\n    uint256 public ordersCount;\r\n    mapping(uint256 => Order) public orders;\r\n    // DAO\r\n    address[] public supportedTokens;\r\n    mapping(address => SupportedTokenSettings) public supportedTokensSettings;\r\n\r\n    uint256 public DAOFeePercent = 30; // 0,3%\r\n    uint256 public maxRewardDays = 200;\r\n\r\n    event NewOrder(uint256 indexed orderId, Order order);\r\n    event OrderStatusChange(uint256 indexed orderId, Status status);\r\n\r\n    modifier noContracts() {\r\n        require(msg.sender == tx.origin, \"NC\");\r\n        _;\r\n    }\r\n\r\n    function init(\r\n        address _protocolToken,\r\n        address _governanceContract\r\n    ) public onlyOwner {\r\n        require(address(protocolToken) == address(0));\r\n        protocolToken = IPawToken(_protocolToken);\r\n        governanceContract = _governanceContract;\r\n    }\r\n\r\n    function newOrder(\r\n        address _loanToken,\r\n        uint256 _loanAmount,\r\n        address _collateralToken,\r\n        uint256 _collateralAmount,\r\n        uint256 _lenderFeeAmount,\r\n        uint256[] memory _timestamps,\r\n        Role _role\r\n    ) public noContracts returns (uint256 orderId) {\r\n        require(msg.sender != address(0), \"0A\");\r\n        require(\r\n            _timestamps[0] > block.timestamp &&\r\n                _timestamps[1] > block.timestamp &&\r\n                _timestamps[1] > _timestamps[0],\r\n            \"WTS\"\r\n        );\r\n        require(_role == Role.SUPPLY || _role == Role.BORROW, \"WR\");\r\n        require(_loanAmount > 0 && _collateralAmount > 0, \"WA\");\r\n        require(\r\n            (_loanToken != address(0)) &&\r\n                (_collateralToken != address(0)) &&\r\n                (_loanToken != _collateralToken),\r\n            \"WTP\"\r\n        );\r\n        uint256 rewardAmount = _calcRewardAmount(\r\n            _timestamps[0],\r\n            _loanToken,\r\n            _loanAmount\r\n        );\r\n\r\n        uint256 amount;\r\n        uint256 DAOFeeAmount;\r\n        if (_role == Role.SUPPLY) {\r\n            amount = _transferToProtocol(_loanToken, msg.sender, _loanAmount);\r\n            DAOFeeAmount = (amount * DAOFeePercent) / 10000;\r\n            require(_lenderFeeAmount + DAOFeeAmount < amount, \"WA\");\r\n        } else if (_role == Role.BORROW) {\r\n            amount = _transferToProtocol(\r\n                _collateralToken,\r\n                msg.sender,\r\n                _collateralAmount\r\n            );\r\n            DAOFeeAmount = (_loanAmount * DAOFeePercent) / 10000;\r\n            require(_lenderFeeAmount + DAOFeeAmount < _loanAmount, \"WA\");\r\n        }\r\n        orderId = ordersCount;\r\n        Order memory order;\r\n        order = Order(\r\n            orderId,\r\n            _role == Role.SUPPLY ? msg.sender : address(0),\r\n            _role == Role.BORROW ? msg.sender : address(0),\r\n            _loanToken,\r\n            _role == Role.SUPPLY ? amount : _loanAmount,\r\n            _collateralToken,\r\n            _role == Role.BORROW ? amount : _collateralAmount,\r\n            _lenderFeeAmount,\r\n            _timestamps,\r\n            rewardAmount,\r\n            Status.OPEN,\r\n            _role\r\n        );\r\n        orders[orderId] = order;\r\n        ordersCount++;\r\n        emit NewOrder(orderId, order);\r\n        return orderId;\r\n    }\r\n\r\n    function _transferToProtocol(\r\n        address _token,\r\n        address _sender,\r\n        uint256 _amount\r\n    ) public returns (uint256 amount) {\r\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\r\n        TransferHelper.safeTransferFrom(\r\n            _token,\r\n            _sender,\r\n            address(this),\r\n            _amount\r\n        );\r\n        uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\r\n        require((balanceAfter - balanceBefore) > 0, \"TF\");\r\n        return balanceAfter - balanceBefore;\r\n    }\r\n\r\n    function _calcRewardAmount(\r\n        uint256 repayTimestamp,\r\n        address _loanToken,\r\n        uint256 _loanAmount\r\n    ) internal view returns (uint256 rewardAmount) {\r\n        uint256 daysAmount = (repayTimestamp - block.timestamp) / 1 days;\r\n        uint256 addDays;\r\n        if (supportedTokensSettings[_loanToken].denominator != 0) {\r\n            addDays =\r\n                _loanAmount /\r\n                supportedTokensSettings[_loanToken].denominator;\r\n            addDays = addDays > maxRewardDays ? maxRewardDays : addDays; // TODO 365 days and settings addDays\r\n        }\r\n        if ((daysAmount != 0) && (daysAmount >= 20)) {\r\n            rewardAmount =\r\n                ((daysAmount + addDays) ** 2) *\r\n                10 ** protocolTokenDecimals;\r\n        } else {\r\n            rewardAmount = 0;\r\n        }\r\n    }\r\n\r\n    function getOrder(uint256 _orderId) public noContracts {\r\n        if (orders[_orderId].role == Role.SUPPLY) {\r\n            _getSupplyOrder(_orderId);\r\n        } else if (orders[_orderId].role == Role.BORROW) {\r\n            _getBorrowOrder(_orderId);\r\n        }\r\n        emit OrderStatusChange(_orderId, orders[_orderId].status);\r\n    }\r\n\r\n    function _getSupplyOrder(uint256 _orderId) private {\r\n        require(block.timestamp < orders[_orderId].timestamps[1], \"WT\");\r\n        require(msg.sender != address(0), \"0A\");\r\n        require(orders[_orderId].status == Status.OPEN, \"WS\");\r\n        orders[_orderId].status = Status.WORKING;\r\n        require(msg.sender != orders[_orderId].lender, \"LCB\");\r\n        uint256 amount = _transferToProtocol(\r\n            orders[_orderId].collateralToken,\r\n            msg.sender,\r\n            orders[_orderId].collateralAmount\r\n        );\r\n        orders[_orderId].collateralAmount = amount;\r\n        uint256 DAOFeeAmount = (orders[_orderId].loanAmount * DAOFeePercent) /\r\n            10000;\r\n        TransferHelper.safeTransfer(\r\n            orders[_orderId].loanToken,\r\n            msg.sender,\r\n            orders[_orderId].loanAmount -\r\n                (DAOFeeAmount + orders[_orderId].lenderFeeAmount)\r\n        );\r\n        TransferHelper.safeTransfer(\r\n            orders[_orderId].loanToken,\r\n            owner(),\r\n            DAOFeeAmount\r\n        );\r\n        if (orders[_orderId].lenderFeeAmount > 0) {\r\n            TransferHelper.safeTransfer(\r\n                orders[_orderId].loanToken,\r\n                orders[_orderId].lender,\r\n                orders[_orderId].lenderFeeAmount\r\n            );\r\n        }\r\n        orders[_orderId].borrower = msg.sender;\r\n    }\r\n\r\n    function _getBorrowOrder(uint256 _orderId) private {\r\n        require(block.timestamp < orders[_orderId].timestamps[1], \"WT\");\r\n        require(msg.sender != address(0), \"0A\");\r\n        require(orders[_orderId].status == Status.OPEN, \"WS\");\r\n        orders[_orderId].status = Status.WORKING;\r\n        require(msg.sender != orders[_orderId].borrower, \"BCL\");\r\n        uint256 amount = _transferToProtocol(\r\n            orders[_orderId].loanToken,\r\n            msg.sender,\r\n            orders[_orderId].loanAmount\r\n        );\r\n        orders[_orderId].loanAmount = amount;\r\n        uint256 DAOFeeAmount = (amount * DAOFeePercent) / 10000;\r\n        require(orders[_orderId].lenderFeeAmount + DAOFeeAmount < amount, \"WA\");\r\n        TransferHelper.safeTransfer(\r\n            orders[_orderId].loanToken,\r\n            orders[_orderId].borrower,\r\n            amount - (orders[_orderId].lenderFeeAmount + DAOFeeAmount)\r\n        );\r\n        TransferHelper.safeTransfer(\r\n            orders[_orderId].loanToken,\r\n            owner(),\r\n            DAOFeeAmount\r\n        );\r\n        if (orders[_orderId].lenderFeeAmount > 0) {\r\n            TransferHelper.safeTransfer(\r\n                orders[_orderId].loanToken,\r\n                msg.sender,\r\n                orders[_orderId].lenderFeeAmount\r\n            );\r\n        }\r\n        orders[_orderId].lender = msg.sender;\r\n    }\r\n\r\n    function cancelOrder(uint256 _orderId) public noContracts {\r\n        require(orders[_orderId].status == Status.OPEN, \"WS\");\r\n        orders[_orderId].status = Status.CANCELED;\r\n        require(\r\n            (orders[_orderId].role == Role.SUPPLY &&\r\n                orders[_orderId].lender == msg.sender) ||\r\n                (orders[_orderId].role == Role.BORROW &&\r\n                    orders[_orderId].borrower == msg.sender),\r\n            \"CF\"\r\n        );\r\n        uint256 amount = orders[_orderId].role == Role.SUPPLY\r\n            ? orders[_orderId].loanAmount\r\n            : orders[_orderId].collateralAmount;\r\n\r\n        orders[_orderId].role == Role.SUPPLY\r\n            ? TransferHelper.safeTransfer(\r\n                orders[_orderId].loanToken,\r\n                msg.sender,\r\n                amount\r\n            )\r\n            : TransferHelper.safeTransfer(\r\n                orders[_orderId].collateralToken,\r\n                msg.sender,\r\n                amount\r\n            );\r\n\r\n        emit OrderStatusChange(_orderId, orders[_orderId].status);\r\n    }\r\n\r\n    function repayOrder(uint256 _orderId) public noContracts {\r\n        require(orders[_orderId].status == Status.WORKING, \"WS\");\r\n        orders[_orderId].status = Status.CLOSED;\r\n        require(\r\n            orders[_orderId].timestamps[0] < block.timestamp &&\r\n                block.timestamp < orders[_orderId].timestamps[1],\r\n            \"WT\"\r\n        );\r\n        require(orders[_orderId].borrower == msg.sender, \"BR\");\r\n        uint256 amount = _transferToProtocol(\r\n            orders[_orderId].loanToken,\r\n            msg.sender,\r\n            orders[_orderId].loanAmount\r\n        );\r\n        TransferHelper.safeTransfer(\r\n            orders[_orderId].loanToken,\r\n            orders[_orderId].lender,\r\n            amount\r\n        );\r\n        TransferHelper.safeTransfer(\r\n            orders[_orderId].collateralToken,\r\n            orders[_orderId].borrower,\r\n            orders[_orderId].collateralAmount\r\n        );\r\n        _reward(orders[_orderId].borrower, orders[_orderId].rewardAmount);\r\n        emit OrderStatusChange(_orderId, orders[_orderId].status);\r\n    }\r\n\r\n    function liquidateOrder(uint256 _orderId) public noContracts {\r\n        require(orders[_orderId].status == Status.WORKING, \"WS\");\r\n        orders[_orderId].status = Status.CLOSED;\r\n        require(block.timestamp > orders[_orderId].timestamps[1], \"WT\");\r\n        require(orders[_orderId].lender == msg.sender, \"LL\");\r\n        TransferHelper.safeTransfer(\r\n            orders[_orderId].collateralToken,\r\n            orders[_orderId].lender,\r\n            orders[_orderId].collateralAmount\r\n        );\r\n        _reward(orders[_orderId].lender, orders[_orderId].rewardAmount);\r\n\r\n        emit OrderStatusChange(_orderId, orders[_orderId].status);\r\n    }\r\n\r\n    function _reward(address _to, uint256 _amount) private {\r\n        if (_amount > 0) {\r\n            uint256 contractBalance = protocolToken.balanceOf(address(this));\r\n            if (contractBalance > _amount) {\r\n                require(protocolToken.transfer(_to, _amount), \"TF\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAllOrders() public view returns (Order[] memory allOrders) {\r\n        allOrders = new Order[](ordersCount);\r\n        for (uint256 i = 0; i < ordersCount; i++) {\r\n            Order storage order = orders[i];\r\n            allOrders[i] = order;\r\n        }\r\n        return allOrders;\r\n    }\r\n\r\n    function getSupportedTokens()\r\n        public\r\n        view\r\n        returns (address[] memory allTokens)\r\n    {\r\n        allTokens = new address[](supportedTokens.length);\r\n        for (uint256 i = 0; i < supportedTokens.length; i++) {\r\n            address token = supportedTokens[i];\r\n            allTokens[i] = token;\r\n        }\r\n        return allTokens;\r\n    }\r\n\r\n    function setMaxRewardDays(uint256 _newMaxRewardDays) public onlyOwner {\r\n        require(_newMaxRewardDays <= 365 && _newMaxRewardDays >= 100, \"WD\");\r\n        maxRewardDays = _newMaxRewardDays;\r\n    }\r\n\r\n    function addSupportedToken(\r\n        address _tokenAddress,\r\n        uint256 _denominator\r\n    ) public onlyOwner {\r\n        for (uint256 i = 0; i < supportedTokens.length; i++) {\r\n            require(supportedTokens[i] != _tokenAddress);\r\n        }\r\n        supportedTokens.push(_tokenAddress);\r\n        supportedTokensSettings[_tokenAddress].isRewarded = true;\r\n        supportedTokensSettings[_tokenAddress].denominator = _denominator;\r\n    }\r\n\r\n    function setTokenReward(\r\n        address _tokenAddress,\r\n        bool _flag,\r\n        uint256 _denominator\r\n    ) public onlyOwner {\r\n        supportedTokensSettings[_tokenAddress].isRewarded = _flag;\r\n        supportedTokensSettings[_tokenAddress].denominator = _denominator;\r\n    }\r\n\r\n    function changeDAOFeePercent(uint256 _DAOFeePercent) public onlyOwner {\r\n        require(_DAOFeePercent >= 10 && _DAOFeePercent <= 150);\r\n        DAOFeePercent = _DAOFeePercent;\r\n    }\r\n\r\n    function withdraw() public onlyOwner returns (bytes memory) {\r\n        (, bytes memory resp) = owner().call{value: address(this).balance}(\"\");\r\n        return resp;\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lenderFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"timestamps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum Protocol.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"enum Protocol.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct Protocol.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"NewOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum Protocol.Status\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"OrderStatusChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAOFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_transferToProtocol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"addSupportedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_DAOFeePercent\",\"type\":\"uint256\"}],\"name\":\"changeDAOFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lenderFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"timestamps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum Protocol.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"enum Protocol.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"internalType\":\"struct Protocol.Order[]\",\"name\":\"allOrders\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"getOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"allTokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governanceContract\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"liquidateOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRewardDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loanToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lenderFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_timestamps\",\"type\":\"uint256[]\"},{\"internalType\":\"enum Protocol.Role\",\"name\":\"_role\",\"type\":\"uint8\"}],\"name\":\"newOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lenderFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum Protocol.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"enum Protocol.Role\",\"name\":\"role\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ordersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolToken\",\"outputs\":[{\"internalType\":\"contract IPawToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolTokenDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"repayOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxRewardDays\",\"type\":\"uint256\"}],\"name\":\"setMaxRewardDays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"setTokenReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"supportedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedTokensSettings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isRewarded\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Protocol", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a6124d6fc25f4d9d510926697aebcee0e593555e2a72a0debca9c09cb4b2aa26"}