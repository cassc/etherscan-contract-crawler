{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"project:/contracts/token-flat.sol\": {\r\n      \"content\": \"/**\\n *  SourceUnit: eveeland/contracts/token.sol\\n */\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n    Ownership contract\\n    Modified https://eips.ethereum.org/EIPS/eip-173\\n    Added ownership transfer confirmation to prevent form giving ownership to wrong address\\n */\\ncontract Ownable {\\n    /// Current contract owner\\n    address public owner;\\n    /// New contract owner to be confirmed\\n    address public newOwner;\\n    /// Emit on every owner change\\n    event OwnershipChanged(address indexed from, address indexed to);\\n\\n    /**\\n        Set default owner as contract deployer\\n     */\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n        Use this modifier to limit function to contract owner\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only for Owner\\\");\\n        _;\\n    }\\n\\n    /**\\n        Prepare to change ownersip. New owner need to confirm it.\\n        @param user address delegated to be new contract owner\\n     */\\n    function giveOwnership(address user) external onlyOwner {\\n        require(user != address(0x0), \\\"renounceOwnership() instead\\\");\\n        newOwner = user;\\n    }\\n\\n    /**\\n        Accept contract ownership by new owner.\\n     */\\n    function acceptOwnership() external {\\n        require(\\n            newOwner != address(0x0) && msg.sender == newOwner,\\n            \\\"Only newOwner can accept\\\"\\n        );\\n        emit OwnershipChanged(owner, newOwner);\\n        owner = newOwner;\\n        delete newOwner;\\n    }\\n\\n    /**\\n        Renounce ownership of the contract.\\n        Any function uses \\\"onlyOwner\\\" modifier will be inaccessible.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        emit OwnershipChanged(owner, address(0x0));\\n        delete owner;\\n    }\\n}\\n\\n/**\\n *  SourceUnit: eveeland/contracts/token.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * ////IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\\n/**\\n *  SourceUnit: eveeland/contracts/token.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\n// based on https://github.com/CoinbaseStablecoin/eip-3009\\n\\npragma solidity ^0.8.0;\\n\\nabstract contract EIP712Domain {\\n    /**\\n     * @dev EIP712 Domain Separator\\n     */\\n    bytes32 public DOMAIN_SEPARATOR;\\n    uint256 public CHAINID;\\n    bytes32 public EIP712_DOMAIN_TYPEHASH;\\n}\\n\\n/**\\n * @title ECRecover\\n * @notice A library that provides a safe ECDSA recovery function\\n */\\nlibrary ECRecover {\\n    /**\\n     * @notice Recover signer's address from a signed message\\n     * @dev Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/65e4ffde586ec89af3b7e9140bdc9235d1254853/contracts/cryptography/ECDSA.sol\\n     * Modifications: Accept v, r, and s as separate arguments\\n     * @param digest    Keccak-256 hash digest of the signed message\\n     * @param v         v of the signature\\n     * @param r         r of the signature\\n     * @param s         s of the signature\\n     * @return Signer address\\n     */\\n    function recover(\\n        bytes32 digest,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (\\n            uint256(s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) {\\n            revert(\\\"ECRecover: invalid signature 's' value\\\");\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            revert(\\\"ECRecover: invalid signature 'v' value\\\");\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(digest, v, r, s);\\n        require(signer != address(0), \\\"ECRecover: invalid signature\\\");\\n\\n        return signer;\\n    }\\n}\\n\\n/**\\n * @title EIP712\\n * @notice A library that provides EIP712 helper functions\\n */\\nlibrary EIP712 {\\n    // keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")\\n    bytes32 public constant EIP712_DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /**\\n     * @notice Make EIP712 domain separator\\n     * @param name      Contract name\\n     * @param version   Contract version\\n     * @return Domain separator\\n     */\\n    function makeDomainSeparator(\\n        string memory name,\\n        string memory version,\\n        uint256 chainId\\n    ) internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    EIP712_DOMAIN_TYPEHASH,\\n                    keccak256(bytes(name)),\\n                    keccak256(bytes(version)),\\n                    chainId,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Recover signer's address from a EIP712 signature\\n     * @param domainSeparator   Domain separator\\n     * @param v                 v of the signature\\n     * @param r                 r of the signature\\n     * @param s                 s of the signature\\n     * @param typeHashAndData   Type hash concatenated with data\\n     * @return Signer's address\\n     */\\n    function recover(\\n        bytes32 domainSeparator,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        bytes memory typeHashAndData\\n    ) internal pure returns (address) {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                domainSeparator,\\n                keccak256(typeHashAndData)\\n            )\\n        );\\n        return ECRecover.recover(digest, v, r, s);\\n    }\\n}\\n\\n/**\\n *  SourceUnit: eveeland/contracts/token.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n    Internal functions from ERC20 token to be used for IEP2612 and IEP3009\\n */\\nabstract contract ERC20Internal {\\n    // internal _approve call\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual;\\n\\n    // internal _transfer call\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual;\\n}\\n\\n/**\\n *  SourceUnit: eveeland/contracts/token.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\n\\npragma solidity ^0.8.0;\\n\\n////import \\\"./IERC20.sol\\\";\\n////import \\\"./Ownable.sol\\\";\\n\\n/**\\n    ERC20 token and native coin recovery functions\\n */\\nabstract contract Recoverable is Ownable {\\n    string internal constant ERR_NOTHING = \\\"Nothing to recover\\\";\\n\\n    /// Recover native coin from contract\\n    function recoverETH() external onlyOwner {\\n        uint256 amt = address(this).balance;\\n        require(amt > 0, ERR_NOTHING);\\n        payable(owner).transfer(amt);\\n    }\\n\\n    /**\\n        Recover ERC20 token from contract\\n        @param token address of token to witdraw\\n        @param amount of tokens to withdraw (if 0 - take all, useful for \\\"pay fee\\\" tokens)\\n     */\\n    function recoverERC20(address token, uint256 amount)\\n        external\\n        virtual\\n        onlyOwner\\n    {\\n        uint256 amt = IERC20(token).balanceOf(address(this));\\n        require(amt > 0, ERR_NOTHING);\\n        if (amount != 0) {\\n            amt = amount;\\n        }\\n        IERC20(token).transfer(owner, amt);\\n    }\\n}\\n\\n/**\\n *  SourceUnit: eveeland/contracts/token.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\n// Following https://eips.ethereum.org/EIPS/eip-3009\\n// based on https://github.com/CoinbaseStablecoin/eip-3009\\n\\npragma solidity ^0.8.0;\\n\\n////import \\\"./ERC20internal.sol\\\";\\n////import \\\"./EIP712.sol\\\";\\n\\n/**\\n    EIP3009 implementation\\n */\\nabstract contract ERC3009 is ERC20Internal, EIP712Domain {\\n    // events\\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\\n    event AuthorizationCanceled(\\n        address indexed authorizer,\\n        bytes32 indexed nonce\\n    );\\n\\n    // constant typehashes\\n    // keccak256(\\\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\\n        0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\\n\\n    // keccak256(\\\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\n    bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH =\\n        0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\\n\\n    // keccak256(\\\"CancelAuthorization(address authorizer,bytes32 nonce)\\\")\\n    bytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH =\\n        0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\\n\\n    // data store\\n\\n    string constant ERR_REUSED = \\\"EIP3009: Authorization reused\\\";\\n    string constant ERR_SIGNATURE = \\\"EIP3009: Invalid signature\\\";\\n\\n    /**\\n     * @dev authorizer address => nonce => state (true = used / false = unused)\\n     */\\n    mapping(address => mapping(bytes32 => bool)) internal _authorizationStates;\\n\\n    // viewers\\n\\n    /**\\n     * @notice Returns the state of an authorization\\n     * @dev Nonces are randomly generated 32-byte data unique to the authorizer's\\n     * address\\n     * @param authorizer    Authorizer's address\\n     * @param nonce         Nonce of the authorization\\n     * @return True if the nonce is used\\n     */\\n    function authorizationState(address authorizer, bytes32 nonce)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return _authorizationStates[authorizer][nonce];\\n    }\\n\\n    // functions\\n\\n    /**\\n     * @notice Execute a transfer with a signed authorization\\n     * @param from          Payer's address (Authorizer)\\n     * @param to            Payee's address\\n     * @param value         Amount to be transferred\\n     * @param validAfter    The time after which this is valid (unix time)\\n     * @param validBefore   The time before which this is valid (unix time)\\n     * @param nonce         Unique nonce\\n     * @param v             v of the signature\\n     * @param r             r of the signature\\n     * @param s             s of the signature\\n     */\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        _transferWithAuthorization(\\n            TRANSFER_WITH_AUTHORIZATION_TYPEHASH,\\n            from,\\n            to,\\n            value,\\n            validAfter,\\n            validBefore,\\n            nonce,\\n            v,\\n            r,\\n            s\\n        );\\n    }\\n\\n    /**\\n     * @notice Receive a transfer with a signed authorization from the payer\\n     * @dev This has an additional check to ensure that the payee's address matches\\n     * the caller of this function to prevent front-running attacks. (See security\\n     * considerations)\\n     * @param from          Payer's address (Authorizer)\\n     * @param to            Payee's address\\n     * @param value         Amount to be transferred\\n     * @param validAfter    The time after which this is valid (unix time)\\n     * @param validBefore   The time before which this is valid (unix time)\\n     * @param nonce         Unique nonce\\n     * @param v             v of the signature\\n     * @param r             r of the signature\\n     * @param s             s of the signature\\n     */\\n    function receiveWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(to == msg.sender, \\\"EIP3009: caller must be the payee\\\");\\n\\n        _transferWithAuthorization(\\n            RECEIVE_WITH_AUTHORIZATION_TYPEHASH,\\n            from,\\n            to,\\n            value,\\n            validAfter,\\n            validBefore,\\n            nonce,\\n            v,\\n            r,\\n            s\\n        );\\n    }\\n\\n    function _transferWithAuthorization(\\n        bytes32 typeHash,\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 timeNow = block.timestamp;\\n        require(\\n            timeNow > validAfter,\\n            \\\"EIP3009: authorization is not yet valid\\\"\\n        );\\n        require(timeNow < validBefore, \\\"EIP3009: authorization is expired\\\");\\n        require(!_authorizationStates[from][nonce], ERR_REUSED);\\n\\n        bytes memory data = abi.encode(\\n            typeHash,\\n            from,\\n            to,\\n            value,\\n            validAfter,\\n            validBefore,\\n            nonce\\n        );\\n        require(\\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == from,\\n            ERR_SIGNATURE\\n        );\\n\\n        _authorizationStates[from][nonce] = true;\\n        emit AuthorizationUsed(from, nonce);\\n\\n        _transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @notice Attempt to cancel an authorization\\n     * @param authorizer    Authorizer's address\\n     * @param nonce         Nonce of the authorization\\n     * @param v             v of the signature\\n     * @param r             r of the signature\\n     * @param s             s of the signature\\n     */\\n    function cancelAuthorization(\\n        address authorizer,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(!_authorizationStates[authorizer][nonce], ERR_REUSED);\\n\\n        bytes memory data = abi.encode(\\n            CANCEL_AUTHORIZATION_TYPEHASH,\\n            authorizer,\\n            nonce\\n        );\\n        require(\\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == authorizer,\\n            ERR_SIGNATURE\\n        );\\n\\n        _authorizationStates[authorizer][nonce] = true;\\n        emit AuthorizationCanceled(authorizer, nonce);\\n    }\\n}\\n\\n/**\\n *  SourceUnit: eveeland/contracts/token.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\n// Following https://eips.ethereum.org/EIPS/eip-2612\\n// based on https://github.com/CoinbaseStablecoin/eip-3009\\n\\npragma solidity ^0.8.0;\\n\\n////import \\\"./ERC20internal.sol\\\";\\n////import \\\"./EIP712.sol\\\";\\n\\n/**\\n    EIP2612 implementation\\n */\\nabstract contract ERC2612 is ERC20Internal, EIP712Domain {\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    mapping(address => uint256) internal _nonces;\\n\\n    /**\\n     * @notice Nonces for permit\\n     * @param owner Token owner's address\\n     * @return Next nonce\\n     */\\n    function nonces(address owner) external view returns (uint256) {\\n        return _nonces[owner];\\n    }\\n\\n    /**\\n     * @notice update allowance with a signed permit\\n     * @param owner     Token owner's address (Authorizer)\\n     * @param spender   Spender's address\\n     * @param value     Amount of allowance\\n     * @param deadline  The time at which this expires (unix time)\\n     * @param v         v of the signature\\n     * @param r         r of the signature\\n     * @param s         s of the signature\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(deadline >= block.timestamp, \\\"EIP2612: permit is expired\\\");\\n\\n        bytes memory data = abi.encode(\\n            PERMIT_TYPEHASH,\\n            owner,\\n            spender,\\n            value,\\n            _nonces[owner]++,\\n            deadline\\n        );\\n        require(\\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,\\n            \\\"EIP2612: invalid signature\\\"\\n        );\\n\\n        _approve(owner, spender, value);\\n    }\\n}\\n\\n/**\\n *  SourceUnit: eveeland/contracts/token.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\n\\npragma solidity ^0.8.0;\\n\\n////import \\\"./IERC20.sol\\\";\\n////import \\\"./ERC20internal.sol\\\";\\n\\n/**\\n    ERC20 burnable token implementation\\n */\\nabstract contract ERC20 is IERC20, ERC20Internal {\\n    //\\n    // ERC20 data store\\n    //\\n    string internal _name;\\n    string internal _symbol;\\n    uint256 internal _supply;\\n    mapping(address => uint256) _balances;\\n    mapping(address => mapping(address => uint256)) _allowances;\\n\\n    string private constant ERR_BTL = \\\"Balance to low\\\";\\n    string private constant ERR_ATL = \\\"Allowance to low\\\";\\n    string private constant ERR_ZERO = \\\"Address 0x0\\\";\\n\\n    /**\\n        Token constructor\\n        @param name_ token name\\n        @param symbol_ token symbol\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    //\\n    // modifiers\\n    //\\n    modifier notZeroAddress(address user) {\\n        require(user != address(0x0), ERR_ZERO);\\n        _;\\n    }\\n\\n    //\\n    // readers\\n    //\\n\\n    /// Token name\\n    function name() external view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /// Token symbol\\n    function symbol() external view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /// Token decimals\\n    function decimals() external pure override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /// Current total supply of token\\n    function totalSupply() external view override returns (uint256) {\\n        return _supply;\\n    }\\n\\n    /// Balance of given user\\n    function balanceOf(address user) external view override returns (uint256) {\\n        return _balances[user];\\n    }\\n\\n    /// Return current allowance\\n    function allowance(address user, address spender)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _allowances[user][spender];\\n    }\\n\\n    //\\n    // external functions\\n    //\\n\\n    /**\\n        Transfer tokens, emits event\\n        @param to destinantion address\\n        @param amount of tokens to send\\n        @return boolean true if succeed\\n     */\\n    function transfer(address to, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n        Approve another address to spend (or burn) tokens\\n        @param spender authorized user address\\n        @param amount of tokens to be used\\n        @return boolean true if succeed\\n     */\\n    function approve(address spender, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n        Transfer tokens by spending previous approval.\\n        \\\"from\\\" address need to set approval to transaction sender\\n        @param from source address\\n        @param to destination address\\n        @param amount of tokens to send\\n        @return boolean true if succeed\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        uint256 currentAllowance = _allowances[from][msg.sender];\\n        require(currentAllowance >= amount, ERR_ATL);\\n        if (currentAllowance < type(uint256).max) {\\n            unchecked {\\n                _allowances[from][msg.sender] = currentAllowance - amount;\\n            }\\n        }\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n        Destroy tokens form caller address\\n        @param amount of tokens to destory\\n        @return boolean true if succeed\\n     */\\n    function burn(uint256 amount) external returns (bool) {\\n        _burn(msg.sender, amount);\\n        return true;\\n    }\\n\\n    /**\\n        Destroy tokens from earlier approved account\\n        @param user address of token owner to burn from\\n        @param amount of tokens to burn\\n        @return boolean true if succeed\\n     */\\n    function burnFrom(address user, uint256 amount) external returns (bool) {\\n        uint256 currentAllowance = _allowances[user][msg.sender];\\n        require(currentAllowance >= amount, ERR_ATL);\\n        unchecked {\\n            _allowances[user][msg.sender] = currentAllowance - amount;\\n        }\\n        _burn(user, amount);\\n        return true;\\n    }\\n\\n    //\\n    // internal functions\\n    //\\n\\n    /// Internal approve function, emits Approval event\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal override {\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /// Internal transfer function, emits Transfer event\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override notZeroAddress(to) notZeroAddress(from) {\\n        uint256 balance = _balances[from];\\n        require(balance >= amount, ERR_BTL);\\n        unchecked {\\n            _balances[from] = balance - amount;\\n            _balances[to] += amount;\\n        }\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /// internal burn function, emits Transfer event\\n    function _burn(address from, uint256 amount) internal {\\n        uint256 currentBalance = _balances[from];\\n        require(currentBalance >= amount, ERR_BTL);\\n        unchecked {\\n            _balances[from] = currentBalance - amount;\\n            _supply -= amount;\\n        }\\n        emit Transfer(from, address(0x0), amount);\\n    }\\n}\\n\\n/**\\n *  SourceUnit: eveeland/contracts/token.sol\\n */\\n\\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\\n\\npragma solidity ^0.8.10;\\n\\n////import \\\"./ERC20.sol\\\";\\n////import \\\"./ERC2612.sol\\\";\\n////import \\\"./ERC3009.sol\\\";\\n////import \\\"./Recovery.sol\\\";\\n\\n/**\\n    ERC20 token contract for EVVELAND project\\n */\\ncontract EvveToken is ERC20, ERC2612, ERC3009, Recoverable {\\n    //\\n    // constructor\\n    //\\n\\n    /**\\n        Contract constructor\\n        @param tokenName token name\\n        @param tokenSymbol token symbol\\n        @param contractVersion contract version\\n        @param supply token supply minted to deployer\\n     */\\n    constructor(\\n        string memory tokenName,\\n        string memory tokenSymbol,\\n        string memory contractVersion,\\n        uint256 supply\\n    ) ERC20(tokenName, tokenSymbol) {\\n        // generate domainSeparator for EIP712\\n        uint256 chainId = block.chainid;\\n        DOMAIN_SEPARATOR = EIP712.makeDomainSeparator(\\n            tokenName,\\n            contractVersion,\\n            chainId\\n        );\\n        CHAINID = chainId;\\n        EIP712_DOMAIN_TYPEHASH = EIP712.EIP712_DOMAIN_TYPEHASH;\\n        // mint tokens\\n        _balances[msg.sender] = supply;\\n        _supply = supply;\\n        emit Transfer(address(0x0), msg.sender, supply);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractVersion\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANCEL_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RECEIVE_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"authorizationState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"giveOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"receiveWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"transferWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EvveToken", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000033b2e3c9fd0803ce80000000000000000000000000000000000000000000000000000000000000000000008457676656c616e640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004455656450000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000013100000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b9a5157c0fca0a2402a6e1cb1542364552c3964266e0845e857b8b63d5fc4994"}