{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/examples/erc20-transfer/FxERC20ChildTunnel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {FxBaseChildTunnel} from \\\"../../tunnel/FxBaseChildTunnel.sol\\\";\\nimport {Create2} from \\\"../../lib/Create2.sol\\\";\\nimport {IFxERC20} from \\\"../../tokens/IFxERC20.sol\\\";\\n\\n/**\\n * @title FxERC20ChildTunnel\\n */\\ncontract FxERC20ChildTunnel is FxBaseChildTunnel, Create2 {\\n    bytes32 public constant DEPOSIT = keccak256(\\\"DEPOSIT\\\");\\n    bytes32 public constant MAP_TOKEN = keccak256(\\\"MAP_TOKEN\\\");\\n    string public constant SUFFIX_NAME = \\\" (FXERC20)\\\";\\n    string public constant PREFIX_SYMBOL = \\\"fx\\\";\\n\\n    // event for token maping\\n    event TokenMapped(address indexed rootToken, address indexed childToken);\\n    // root to child token\\n    mapping(address => address) public rootToChildToken;\\n    // token template\\n    address public tokenTemplate;\\n\\n    constructor(address _fxChild, address _tokenTemplate) FxBaseChildTunnel(_fxChild) {\\n        tokenTemplate = _tokenTemplate;\\n        require(_isContract(_tokenTemplate), \\\"Token template is not contract\\\");\\n    }\\n\\n    function withdraw(address childToken, uint256 amount) public {\\n        _withdraw(childToken, msg.sender, amount);\\n    }\\n\\n    function withdrawTo(\\n        address childToken,\\n        address receiver,\\n        uint256 amount\\n    ) public {\\n        _withdraw(childToken, receiver, amount);\\n    }\\n\\n    //\\n    // Internal methods\\n    //\\n\\n    function _processMessageFromRoot(\\n        uint256, /* stateId */\\n        address sender,\\n        bytes memory data\\n    ) internal override validateSender(sender) {\\n        // decode incoming data\\n        (bytes32 syncType, bytes memory syncData) = abi.decode(data, (bytes32, bytes));\\n\\n        if (syncType == DEPOSIT) {\\n            _syncDeposit(syncData);\\n        } else if (syncType == MAP_TOKEN) {\\n            _mapToken(syncData);\\n        } else {\\n            revert(\\\"FxERC20ChildTunnel: INVALID_SYNC_TYPE\\\");\\n        }\\n    }\\n\\n    function _mapToken(bytes memory syncData) internal returns (address) {\\n        (address rootToken, string memory name, string memory symbol, uint8 decimals) = abi.decode(\\n            syncData,\\n            (address, string, string, uint8)\\n        );\\n\\n        // get root to child token\\n        address childToken = rootToChildToken[rootToken];\\n\\n        // check if it's already mapped\\n        require(childToken == address(0x0), \\\"FxERC20ChildTunnel: ALREADY_MAPPED\\\");\\n\\n        // deploy new child token\\n        bytes32 salt = keccak256(abi.encodePacked(rootToken));\\n        childToken = createClone(salt, tokenTemplate);\\n        IFxERC20(childToken).initialize(\\n            address(this),\\n            rootToken,\\n            string(abi.encodePacked(name, SUFFIX_NAME)),\\n            string(abi.encodePacked(PREFIX_SYMBOL, symbol)),\\n            decimals\\n        );\\n\\n        // map the token\\n        rootToChildToken[rootToken] = childToken;\\n        emit TokenMapped(rootToken, childToken);\\n\\n        // return new child token\\n        return childToken;\\n    }\\n\\n    function _syncDeposit(bytes memory syncData) internal {\\n        (address rootToken, address depositor, address to, uint256 amount, bytes memory depositData) = abi.decode(\\n            syncData,\\n            (address, address, address, uint256, bytes)\\n        );\\n        address childToken = rootToChildToken[rootToken];\\n\\n        // deposit tokens\\n        IFxERC20 childTokenContract = IFxERC20(childToken);\\n        childTokenContract.mint(to, amount);\\n\\n        // call `onTokenTranfer` on `to` with limit and ignore error\\n        if (_isContract(to)) {\\n            uint256 txGas = 2000000;\\n            bool success = false;\\n            bytes memory data = abi.encodeWithSignature(\\n                \\\"onTokenTransfer(address,address,address,address,uint256,bytes)\\\",\\n                rootToken,\\n                childToken,\\n                depositor,\\n                to,\\n                amount,\\n                depositData\\n            );\\n            // solium-disable-next-line security/no-inline-assembly\\n            assembly {\\n                success := call(txGas, to, 0, add(data, 0x20), mload(data), 0, 0)\\n            }\\n        }\\n    }\\n\\n    function _withdraw(\\n        address childToken,\\n        address receiver,\\n        uint256 amount\\n    ) internal {\\n        IFxERC20 childTokenContract = IFxERC20(childToken);\\n        // child token contract will have root token\\n        address rootToken = childTokenContract.connectedToken();\\n\\n        // validate root and child token mapping\\n        require(\\n            childToken != address(0x0) && rootToken != address(0x0) && childToken == rootToChildToken[rootToken],\\n            \\\"FxERC20ChildTunnel: NO_MAPPED_TOKEN\\\"\\n        );\\n\\n        // withdraw tokens\\n        childTokenContract.burn(msg.sender, amount);\\n\\n        // send message to root regarding token burn\\n        _sendMessageToRoot(abi.encode(rootToken, childToken, receiver, amount));\\n    }\\n\\n    // check if address is contract\\n    function _isContract(address _addr) private view returns (bool) {\\n        uint32 size;\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tunnel/FxBaseChildTunnel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// IFxMessageProcessor represents interface to process message\\ninterface IFxMessageProcessor {\\n    function processMessageFromRoot(\\n        uint256 stateId,\\n        address rootMessageSender,\\n        bytes calldata data\\n    ) external;\\n}\\n\\n/**\\n * @notice Mock child tunnel contract to receive and send message from L2\\n */\\nabstract contract FxBaseChildTunnel is IFxMessageProcessor {\\n    // MessageTunnel on L1 will get data from this event\\n    event MessageSent(bytes message);\\n\\n    // fx child\\n    address public fxChild;\\n\\n    // fx root tunnel\\n    address public fxRootTunnel;\\n\\n    constructor(address _fxChild) {\\n        fxChild = _fxChild;\\n    }\\n\\n    // Sender must be fxRootTunnel in case of ERC20 tunnel\\n    modifier validateSender(address sender) {\\n        require(sender == fxRootTunnel, \\\"FxBaseChildTunnel: INVALID_SENDER_FROM_ROOT\\\");\\n        _;\\n    }\\n\\n    // set fxRootTunnel if not set already\\n    function setFxRootTunnel(address _fxRootTunnel) external virtual {\\n        require(fxRootTunnel == address(0x0), \\\"FxBaseChildTunnel: ROOT_TUNNEL_ALREADY_SET\\\");\\n        fxRootTunnel = _fxRootTunnel;\\n    }\\n\\n    function processMessageFromRoot(\\n        uint256 stateId,\\n        address rootMessageSender,\\n        bytes calldata data\\n    ) external override {\\n        require(msg.sender == fxChild, \\\"FxBaseChildTunnel: INVALID_SENDER\\\");\\n        _processMessageFromRoot(stateId, rootMessageSender, data);\\n    }\\n\\n    /**\\n     * @notice Emit message that can be received on Root Tunnel\\n     * @dev Call the internal function when need to emit message\\n     * @param message bytes message that will be sent to Root Tunnel\\n     * some message examples -\\n     *   abi.encode(tokenId);\\n     *   abi.encode(tokenId, tokenMetadata);\\n     *   abi.encode(messageType, messageData);\\n     */\\n    function _sendMessageToRoot(bytes memory message) internal {\\n        emit MessageSent(message);\\n    }\\n\\n    /**\\n     * @notice Process message received from Root Tunnel\\n     * @dev function needs to be implemented to handle message as per requirement\\n     * This is called by onStateReceive function.\\n     * Since it is called via a system call, any event will not be emitted during its execution.\\n     * @param stateId unique state id\\n     * @param sender root message sender\\n     * @param message bytes message that was sent from Root Tunnel\\n     */\\n    function _processMessageFromRoot(\\n        uint256 stateId,\\n        address sender,\\n        bytes memory message\\n    ) internal virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Create2 adds common methods for minimal proxy with create2\\nabstract contract Create2 {\\n    // creates clone using minimal proxy\\n    function createClone(bytes32 _salt, address _target) internal returns (address _result) {\\n        bytes20 _targetBytes = bytes20(_target);\\n\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(clone, 0x14), _targetBytes)\\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            _result := create2(0, clone, 0x37, _salt)\\n        }\\n\\n        require(_result != address(0), \\\"Create2: Failed on minimal deploy\\\");\\n    }\\n\\n    // get minimal proxy creation code\\n    function minimalProxyCreationCode(address logic) internal pure returns (bytes memory) {\\n        bytes10 creation = 0x3d602d80600a3d3981f3;\\n        bytes10 prefix = 0x363d3d373d3d3d363d73;\\n        bytes20 targetBytes = bytes20(logic);\\n        bytes15 suffix = 0x5af43d82803e903d91602b57fd5bf3;\\n        return abi.encodePacked(creation, prefix, targetBytes, suffix);\\n    }\\n\\n    // get computed create2 address\\n    function computedCreate2Address(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) public pure returns (address) {\\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\\n        return address(uint160(uint256(_data)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IFxERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"../lib/IERC20.sol\\\";\\n\\ninterface IFxERC20 is IERC20 {\\n    function fxManager() external returns (address);\\n\\n    function connectedToken() external returns (address);\\n\\n    function initialize(\\n        address _fxManager,\\n        address _connectedToken,\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) external;\\n\\n    function mint(address user, uint256 amount) external;\\n\\n    function burn(address user, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxChild\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenTemplate\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rootToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"childToken\",\"type\":\"address\"}],\"name\":\"TokenMapped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEPOSIT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAP_TOKEN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PREFIX_SYMBOL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUFFIX_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"bytecodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"name\":\"computedCreate2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxChild\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxRootTunnel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stateId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rootMessageSender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"processMessageFromRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rootToChildToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxRootTunnel\",\"type\":\"address\"}],\"name\":\"setFxRootTunnel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenTemplate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"childToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"childToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FxERC20ChildTunnel", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "0000000000000000000000008397259c983751daf40400790063935a11afa28a000000000000000000000000ad87e3b217c66b0d45deafbc540330d300811b94", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}