{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/1delta/proxy/DeltaBroker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Achthar <achim@1delta.io>\\n/******************************************************************************/\\n\\nimport {LibModules} from \\\"./libraries/LibModules.sol\\\";\\nimport {IModuleConfig} from \\\"./interfaces/IModuleConfig.sol\\\";\\n\\ncontract DeltaBrokerProxy {\\n    error noImplementation();\\n\\n    constructor(address _contractOwner, address _moduleConfigModule) payable {\\n        LibModules.setContractOwner(_contractOwner);\\n\\n        // Add the moduleConfig external function from the moduleConfigModule\\n        IModuleConfig.ModuleConfig[] memory cut = new IModuleConfig.ModuleConfig[](1);\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = IModuleConfig.configureModules.selector;\\n        cut[0] = IModuleConfig.ModuleConfig({\\n            moduleAddress: _moduleConfigModule,\\n            action: IModuleConfig.ModuleConfigAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n        LibModules.configureModules(cut);\\n    }\\n\\n    // An efficient multicall implementation for directly calling functions across multiple modules\\n    function multicall(bytes[] calldata data) external payable {\\n        // This is used in assembly below as impls.slot.\\n        mapping(bytes4 => address) storage impls = LibModules.moduleStorage().selectorToModule;\\n        // loop throught the calls and execute\\n        for (uint256 i; i != data.length; ) {\\n            bytes calldata call = data[i];\\n            assembly {\\n                let len := call.length\\n                calldatacopy(0x40, call.offset, len) // copy calldata to 0x40\\n                let target := and(\\n                    mload(0x40), // calldata was copied to 0, we load the selector from there\\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(0, target)\\n                mstore(0x20, impls.slot)\\n                let slot := keccak256(0, 0x40)\\n                target := sload(slot)\\n                if iszero(target) {\\n                    // Reverting with NoImplementation\\n                    mstore(0, 0x6826a5a500000000000000000000000000000000000000000000000000000000)\\n                    revert(0, 4)\\n                }\\n                let success := delegatecall(gas(), target, 0x40, len, 0, 0)\\n                len := returndatasize()\\n                returndatacopy(0, 0, len)\\n                // revert if not successful - do not return any values on success\\n                if iszero(success) {\\n                    revert(0, len)\\n                }\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    // Find module for function that is called and execute the\\n    // function if a module is found and return any value.\\n    fallback() external payable {\\n        // This is used in assembly below as impls.slot.\\n        mapping(bytes4 => address) storage impls = LibModules.moduleStorage().selectorToModule;\\n\\n        assembly {\\n            let cdlen := calldatasize()\\n            // Store at 0x40, to leave 0x00-0x3F for slot calculation below.\\n            calldatacopy(0x40, 0, cdlen)\\n            let target := and(mload(0x40), 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\\n\\n            // Slot for impls[target] is keccak256(target . impls.slot).\\n            mstore(0, target)\\n            mstore(0x20, impls.slot)\\n            let slot := keccak256(0, 0x40)\\n            target := sload(slot) // overwrite target to delegate address\\n            if iszero(target) {\\n                // Revert with:\\n                // abi.encodeWithSelector(\\n                //   bytes4(keccak256(\\\"NoImplementation()\\\")))\\n                mstore(0, 0x6826a5a500000000000000000000000000000000000000000000000000000000)\\n                revert(0, 4)\\n            }\\n\\n            let success := delegatecall(gas(), target, 0x40, cdlen, 0, 0)\\n            let rdlen := returndatasize()\\n            returndatacopy(0, 0, rdlen)\\n            if success {\\n                return(0, rdlen)\\n            }\\n            revert(0, rdlen)\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/1delta/proxy/interfaces/IModuleConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n * Vendored on December 23, 2021 from:\\n * https://github.com/mudgen/diamond-3-hardhat/blob/7feb995/contracts/interfaces/IModuleConfig.sol\\n */\\npragma solidity ^0.8.0;\\n\\ninterface IModuleConfig {\\n    enum ModuleConfigAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct ModuleConfig {\\n        address moduleAddress;\\n        ModuleConfigAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _moduleConfig Contains the module addresses and function selectors\\n    function configureModules(ModuleConfig[] calldata _moduleConfig) external;\\n}\\n\"\r\n    },\r\n    \"contracts/1delta/proxy/libraries/LibModules.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Achthar - 1delta.io\\n* Modified diamond module handling library\\n/******************************************************************************/\\n\\nimport {IModuleConfig} from \\\"../interfaces/IModuleConfig.sol\\\";\\n\\n// solhint-disable max-line-length\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibModules {\\n    bytes32 constant MODULE_STORAGE_POSITION = keccak256(\\\"diamond.standard.module.storage\\\");\\n\\n    struct ModuleAddressAndPosition {\\n        address moduleAddress;\\n        uint96 functionSelectorPosition; // position in moduleFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct ModuleFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 moduleAddressPosition; // position of moduleAddress in moduleAddresses array\\n    }\\n\\n    struct ModuleStorage {\\n        // maps function selector to the module address and\\n        // the position of the selector in the moduleFunctionSelectors.selectors array\\n        mapping(bytes4 => ModuleAddressAndPosition) selectorToModuleAndPosition;\\n        // maps selector to module\\n        mapping(bytes4 => address) selectorToModule;\\n        // maps module addresses to function selectors\\n        mapping(address => ModuleFunctionSelectors) moduleFunctionSelectors;\\n        // module addresses\\n        address[] moduleAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // Used to query if a module exits\\n        mapping(address => bool) moduleExists;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function moduleStorage() internal pure returns (ModuleStorage storage ds) {\\n        bytes32 position = MODULE_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        ModuleStorage storage ds = moduleStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = moduleStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == moduleStorage().contractOwner, \\\"LibModuleConfig: Must be contract owner\\\");\\n    }\\n\\n    event Upgrade(IModuleConfig.ModuleConfig[] _moduleChange);\\n\\n    // Internal function version of diamondCut\\n    function configureModules(IModuleConfig.ModuleConfig[] memory _moduleChange) internal {\\n        for (uint256 moduleIndex; moduleIndex < _moduleChange.length; moduleIndex++) {\\n            IModuleConfig.ModuleConfigAction action = _moduleChange[moduleIndex].action;\\n            if (action == IModuleConfig.ModuleConfigAction.Add) {\\n                addFunctions(_moduleChange[moduleIndex].moduleAddress, _moduleChange[moduleIndex].functionSelectors);\\n            } else if (action == IModuleConfig.ModuleConfigAction.Replace) {\\n                replaceFunctions(_moduleChange[moduleIndex].moduleAddress, _moduleChange[moduleIndex].functionSelectors);\\n            } else if (action == IModuleConfig.ModuleConfigAction.Remove) {\\n                removeFunctions(_moduleChange[moduleIndex].moduleAddress, _moduleChange[moduleIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibModuleConfig: Incorrect ModuleConfigAction\\\");\\n            }\\n        }\\n        emit Upgrade(_moduleChange);\\n    }\\n\\n    function addFunctions(address _moduleAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibModuleConfig: No selectors in module to cut\\\");\\n        ModuleStorage storage ds = moduleStorage();\\n        require(_moduleAddress != address(0), \\\"LibModuleConfig: Add module can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.moduleFunctionSelectors[_moduleAddress].functionSelectors.length);\\n        // add new module address if it does not exist\\n        if (selectorPosition == 0) {\\n            addModule(ds, _moduleAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldModuleAddress = ds.selectorToModuleAndPosition[selector].moduleAddress;\\n            require(oldModuleAddress == address(0), \\\"LibModuleConfig: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _moduleAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _moduleAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibModuleConfig: No selectors in module to cut\\\");\\n        ModuleStorage storage ds = moduleStorage();\\n        require(_moduleAddress != address(0), \\\"LibModuleConfig: Add module can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.moduleFunctionSelectors[_moduleAddress].functionSelectors.length);\\n        // add new module address if it does not exist\\n        if (selectorPosition == 0) {\\n            addModule(ds, _moduleAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldModuleAddress = ds.selectorToModuleAndPosition[selector].moduleAddress;\\n            require(oldModuleAddress != _moduleAddress, \\\"LibModuleConfig: Can't replace function with same function\\\");\\n            removeFunction(ds, oldModuleAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _moduleAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _moduleAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibModuleConfig: No selectors in module to cut\\\");\\n        ModuleStorage storage ds = moduleStorage();\\n        // if function does not exist then do nothing and return\\n        require(_moduleAddress == address(0), \\\"LibModuleConfig: Remove module address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldModuleAddress = ds.selectorToModuleAndPosition[selector].moduleAddress;\\n            removeFunction(ds, oldModuleAddress, selector);\\n        }\\n    }\\n\\n    function addModule(ModuleStorage storage ds, address _moduleAddress) internal {\\n        enforceHasContractCode(_moduleAddress, \\\"LibModuleConfig: New module has no code\\\");\\n        ds.moduleFunctionSelectors[_moduleAddress].moduleAddressPosition = ds.moduleAddresses.length;\\n        ds.moduleAddresses.push(_moduleAddress);\\n        ds.moduleExists[_moduleAddress] = true;\\n    }\\n\\n    function addFunction(\\n        ModuleStorage storage ds,\\n        bytes4 _selector,\\n        uint96 _selectorPosition,\\n        address _moduleAddress\\n    ) internal {\\n        ds.selectorToModuleAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.moduleFunctionSelectors[_moduleAddress].functionSelectors.push(_selector);\\n        ds.selectorToModuleAndPosition[_selector].moduleAddress = _moduleAddress;\\n        ds.selectorToModule[_selector] = _moduleAddress;\\n    }\\n\\n    function removeFunction(\\n        ModuleStorage storage ds,\\n        address _moduleAddress,\\n        bytes4 _selector\\n    ) internal {\\n        require(_moduleAddress != address(0), \\\"LibModuleConfig: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_moduleAddress != address(this), \\\"LibModuleConfig: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToModuleAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.moduleFunctionSelectors[_moduleAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.moduleFunctionSelectors[_moduleAddress].functionSelectors[lastSelectorPosition];\\n            ds.moduleFunctionSelectors[_moduleAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToModuleAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.moduleFunctionSelectors[_moduleAddress].functionSelectors.pop();\\n        delete ds.selectorToModuleAndPosition[_selector];\\n        delete ds.selectorToModule[_selector];\\n\\n        // if no more selectors for module address then delete the module address\\n        if (lastSelectorPosition == 0) {\\n            // replace module address with last module address and delete last module address\\n            uint256 lastModuleAddressPosition = ds.moduleAddresses.length - 1;\\n            uint256 moduleAddressPosition = ds.moduleFunctionSelectors[_moduleAddress].moduleAddressPosition;\\n            if (moduleAddressPosition != lastModuleAddressPosition) {\\n                address lastModuleAddress = ds.moduleAddresses[lastModuleAddressPosition];\\n                ds.moduleAddresses[moduleAddressPosition] = lastModuleAddress;\\n                ds.moduleFunctionSelectors[lastModuleAddress].moduleAddressPosition = moduleAddressPosition;\\n            }\\n            ds.moduleAddresses.pop();\\n            delete ds.moduleFunctionSelectors[_moduleAddress].moduleAddressPosition;\\n            ds.moduleExists[_moduleAddress] = false;\\n        }\\n    }\\n\\n    function initializeModuleConfig(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(_init, \\\"LibModuleConfig: _init address has no code\\\");\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_moduleConfigModule\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"noImplementation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"moduleAddress\",\"type\":\"address\"},{\"internalType\":\"enum IModuleConfig.ModuleConfigAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IModuleConfig.ModuleConfig[]\",\"name\":\"_moduleChange\",\"type\":\"tuple[]\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DeltaBrokerProxy", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000999999833d965c275a2c102a4ebf222ca938546f00000000000000000000000032b31a066c8dd3f7b77283ba1d89ddaf6da0a8ae", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x476a0d24790a88185c721ee728d18465c66e9611", "SwarmSource": ""}