{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/AutomationBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract AutomationBase {\\n  error OnlySimulatedBackend();\\n\\n  /**\\n   * @notice method that allows it to be simulated via eth_call by checking that\\n   * the sender is the zero address.\\n   */\\n  function preventExecution() internal view {\\n    if (tx.origin != address(0)) {\\n      revert OnlySimulatedBackend();\\n    }\\n  }\\n\\n  /**\\n   * @notice modifier that allows it to be simulated via eth_call by checking\\n   * that the sender is the zero address.\\n   */\\n  modifier cannotExecute() {\\n    preventExecution();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/AutomationCompatible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AutomationBase.sol\\\";\\nimport \\\"./interfaces/AutomationCompatibleInterface.sol\\\";\\n\\nabstract contract AutomationCompatible is AutomationBase, AutomationCompatibleInterface {}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AutomationCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easily be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/VerifiableDraws.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.19;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/AutomationCompatible.sol\\\"; // ChainLink Automation\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\"; // ChainLink VRF\\nimport \\\"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\\\"; // ChainLink VRF\\nimport \\\"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\\\"; // Ownership\\n\\n/**\\n * @title Verifiable Draws Contract\\n * @author Lancelot Chardonnet\\n *\\n * @notice You can use this contract to create decentralized and verifiable random draws\\n * \\n */\\ncontract VerifiableDraws is AutomationCompatibleInterface, VRFConsumerBaseV2, ConfirmedOwner {\\n\\n    /*** Errors ***/\\n\\n    error DrawAlreadyExists(string cid);\\n    error DrawDoesNotExist(string cid);\\n    error DrawTooEarly(string cid);\\n    error DrawAlreadyTriggered(string cid);\\n    error DrawAlreadyCompleted(string cid);\\n    error NoEntropyNeeded(string[] cids);\\n    error RequestDoesNotExist(uint256 id);\\n    error RequestAlreadyFulfilled(uint256 id);\\n    error RandomnessFulfilledButEmpty(uint256 id);\\n\\n\\n    /*** Events ***/\\n\\n    event DrawLaunched(string cid, uint64 publishedAt, uint64 scheduledAt, uint32 entropyNeeded);\\n    event RandomnessRequested(\\n        uint256 requestId,\\n        string[] cids,\\n        uint32 numWords,\\n        bytes32 keyHash,\\n        uint64 s_subscriptionId,\\n        uint16 requestConfirmations,\\n        uint32 callbackGasLimit\\n    );\\n    event RandomnessFulfilled(uint256 requestId, uint256[] randomWords);\\n    event DrawsCompleted(string[] cids);\\n\\n\\n    /*** Draws ***/\\n\\n    struct Draw {\\n        uint64 publishedAt; // block number at which the draw was published on the contract\\n        uint64 scheduledAt; // timestamp at which the draw should be triggered\\n        uint256 occuredAt; // block number at which the draw has occurred\\n        uint32 nbParticipants; // number of participants\\n        uint32 nbWinners; // number of winners to select for this draw\\n        uint32 entropyNeeded; // number of bytes of information needed to compute winners\\n        bytes entropy; // entropy used to pick winners\\n        bool entropyPending; // when the random numbers are being generated\\n        bool completed; // when the draw is done and entropy as been filled\\n    }\\n   \\n    mapping(string => Draw) private draws; // Content Identifier (CID) => Draw\\n    string[] private queue; // draws for which completed = false\\n    uint32 private drawCount = 0;\\n\\n\\n    /*** Requests ***/\\n\\n    struct RequestStatus {\\n        bool fulfilled; // whether the request has been successfully fulfilled\\n        uint256 createdAt; // block timestamp\\n        uint256[] randomWords;\\n        string[] cids;\\n    }\\n\\n    mapping(uint256 => RequestStatus) public s_requests; /* requestId --> requestStatus */\\n    uint256[] private pendingRequests;\\n\\n\\n    /*** VRF ***/\\n    \\n    VRFCoordinatorV2Interface COORDINATOR;\\n    uint64 private s_subscriptionId;\\n\\n    // See https://docs.chain.link/docs/vrf-contracts/#configurations\\n    address link_token_contract = 0xb0897686c545045aFc77CF20eC7A532E3120E0F1;\\n    address vrfCoordinator = 0xAE975071Be8F8eE67addBC1A82488F1C24858067;\\n    bytes32 keyHash = 0xcc294a196eeeb44da2888d17c0625cc88d70d9760a69d58d853ba6581a9ab0cd;\\n    uint32 callbackGasLimit = 2500000;\\n    uint16 requestConfirmations = 3;\\n\\n\\n    constructor (\\n        uint64 subscriptionId\\n    )\\n        VRFConsumerBaseV2(vrfCoordinator)\\n        ConfirmedOwner(msg.sender)\\n    {\\n        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\\n        s_subscriptionId = subscriptionId;\\n    }\\n\\n\\n    function launchDraw(\\n        string memory cid,\\n        uint64 scheduledAt,\\n        uint32 nbParticipants,\\n        uint32 nbWinners,\\n        uint32 entropyNeeded\\n    )\\n        external\\n        onlyOwner\\n    {\\n        if (draws[cid].publishedAt != 0) {\\n            revert DrawAlreadyExists(cid);\\n        }\\n\\n        uint64 publishedAt = uint64(block.number);\\n        uint256 occuredAt = 0;\\n        bytes memory entropy = \\\"\\\";\\n        draws[cid] = Draw(publishedAt, scheduledAt, occuredAt, nbParticipants, nbWinners, entropyNeeded, entropy, false, false);\\n        queue.push(cid);\\n        drawCount++;\\n        emit DrawLaunched(cid, publishedAt, scheduledAt, entropyNeeded);\\n    }\\n    \\n\\n    function checkUpkeep(\\n        bytes calldata /* checkData */\\n    )\\n        external\\n        view\\n        override\\n        returns (bool upkeepNeeded, bytes memory performData)\\n    {\\n        upkeepNeeded = false;\\n        bool[] memory isReady = new bool[](queue.length);\\n        uint32 count = 0;\\n\\n        for (uint64 i = 0; i < queue.length; i++) {\\n\\n            string memory cid = queue[i];\\n\\n            // Conditions needed in order to trigger a draw\\n            if (draws[cid].publishedAt > 0 && block.timestamp >= draws[cid].scheduledAt && !draws[cid].entropyPending && !draws[cid].completed) {\\n                upkeepNeeded = true;\\n                isReady[i] = true;\\n                count++;\\n            }\\n        }\\n\\n        if (upkeepNeeded) {\\n            uint32 j = 0;\\n            uint32[] memory queueIdx = new uint32[](count);\\n            for (uint32 i = 0; i < isReady.length; i++) {\\n                if (isReady[i]) {\\n                    queueIdx[j] = i;\\n                    j++;\\n                }\\n            }\\n            performData = abi.encode(queueIdx);\\n        }\\n\\n        return (upkeepNeeded, performData);\\n    }\\n\\n\\n    function performUpkeep(\\n        bytes calldata performData\\n    )\\n        external\\n        override\\n    {\\n        uint32[] memory queueIdx = abi.decode(performData, (uint32[]));\\n        string[] memory requestedCids = new string[](queueIdx.length);\\n        uint32 totalEntropyNeeded = 0;\\n\\n        // We revalidate the draws in the performUpkeep to prevent malicious actors\\n        // from calling performUpkeep with wrong parameters \\n        for (uint64 i = 0; i < queueIdx.length; i++) {\\n\\n            string memory cid = queue[queueIdx[i]];\\n            requestedCids[i] = cid;\\n            \\n            if (draws[cid].publishedAt == 0) {\\n                revert DrawDoesNotExist(cid);\\n            }\\n\\n            if (block.timestamp < draws[cid].scheduledAt) {\\n                revert DrawTooEarly(cid);\\n            }\\n\\n            if (draws[cid].entropyPending) {\\n                revert DrawAlreadyTriggered(cid);\\n            }\\n\\n            if (draws[cid].completed) {\\n                revert DrawAlreadyCompleted(cid);\\n            }\\n\\n            draws[cid].entropyPending = true;\\n            totalEntropyNeeded += draws[cid].entropyNeeded;\\n        }\\n\\n        if (totalEntropyNeeded == 0) {\\n            revert NoEntropyNeeded(requestedCids);\\n        }\\n\\n        removeIndexesFromArray(queue, queueIdx);\\n        generateEntropyFor(requestedCids, totalEntropyNeeded);\\n    }\\n\\n    function generateEntropyFor(string[] memory requestedCids, uint32 totalEntropyNeeded)\\n        private\\n    {\\n \\n        // Each word gives an entropy of 256 bits, i.e. 32 bytes\\n        uint32 numWords = divisionRoundUp(totalEntropyNeeded, 32);\\n\\n        // Will revert if subscription is not set and funded.\\n        uint256 requestId = COORDINATOR.requestRandomWords(\\n            keyHash,\\n            s_subscriptionId,\\n            requestConfirmations,\\n            callbackGasLimit,\\n            numWords\\n        );\\n\\n        s_requests[requestId] = RequestStatus({\\n            randomWords: new uint256[](0),\\n            cids: requestedCids,\\n            fulfilled: false,\\n            createdAt: block.timestamp\\n        });\\n\\n        pendingRequests.push(requestId);\\n\\n        emit RandomnessRequested(\\n            requestId,\\n            requestedCids,\\n            numWords,\\n            keyHash,\\n            s_subscriptionId,\\n            requestConfirmations,\\n            callbackGasLimit\\n        );\\n    }\\n\\n    function fulfillRandomWords(\\n        uint256 _requestId,\\n        uint256[] memory _randomWords\\n    ) internal override {\\n        RequestStatus memory request = s_requests[_requestId];\\n\\n        if (request.createdAt == 0) {\\n            revert RequestDoesNotExist(_requestId);\\n        }\\n\\n        if (request.fulfilled) {\\n            revert RequestAlreadyFulfilled(_requestId);\\n        }\\n\\n        if (_randomWords.length == 0) {\\n            revert RandomnessFulfilledButEmpty(_requestId);\\n        }\\n\\n        s_requests[_requestId].fulfilled = true;\\n        s_requests[_requestId].randomWords = _randomWords;\\n\\n        for (uint256 i = 0; i < pendingRequests.length; i++) {\\n            if (pendingRequests[i] == _requestId) {\\n                if (i != pendingRequests.length - 1) {\\n                    pendingRequests[i] = pendingRequests[pendingRequests.length - 1];\\n                }\\n                \\n                pendingRequests.pop();\\n                break;\\n            }\\n        }\\n        emit RandomnessFulfilled(_requestId, _randomWords);\\n\\n        bytes memory totalEntropy = abi.encodePacked(_randomWords);\\n        uint32 from = 0;\\n        uint32 bytesNeeded = 0;\\n\\n        for (uint64 i = 0; i < request.cids.length; i++) {\\n            string memory cid = request.cids[i];\\n\\n            if (!draws[cid].completed) {\\n                bytesNeeded = draws[cid].entropyNeeded;\\n                draws[cid].entropy = extractBytes(totalEntropy, from, bytesNeeded);\\n                draws[cid].occuredAt = block.number;\\n                draws[cid].entropyPending = false;\\n                draws[cid].completed = true;\\n                from += bytesNeeded;\\n            } else {\\n                revert DrawAlreadyCompleted(cid);\\n            }\\n        }\\n\\n        emit DrawsCompleted(request.cids);\\n    }\\n\\n\\n    /*** Getters ***/\\n\\n    function getRequestStatus(\\n        uint256 _requestId\\n    ) external view returns (bool fulfilled, uint256[] memory randomWords) {\\n\\n        RequestStatus memory request = s_requests[_requestId];\\n\\n        if (request.createdAt == 0) {\\n            revert RequestDoesNotExist(_requestId);\\n        }\\n\\n        return (request.fulfilled, request.randomWords);\\n    }\\n\\n    function getDrawCount() external view onlyOwner returns (uint32) {\\n        return drawCount;\\n    }\\n\\n    function getDrawDetails(string memory cid) external view returns (Draw memory) {\\n        return draws[cid];\\n    }\\n\\n    function getRandomnessForDraw(string memory cid) external view returns (bytes memory) {\\n        return draws[cid].entropy;\\n    }\\n\\n    function getWinners(string memory cid) external view returns (uint32[] memory) {\\n\\n        bytes memory totalEntropy = draws[cid].entropy;\\n        require(totalEntropy.length != 0, \\\"The draw has not occured yet. Come back later.\\\");\\n\\n        uint32 nbWinners = draws[cid].nbWinners;\\n        uint32 nbParticipants = draws[cid].nbParticipants;\\n        uint32[] memory winnerIndexes = new uint32[](nbWinners); // Fixed sized array, all elements initialize to 0\\n        uint32 from = 0;\\n\\n        for (uint32 i = 0; i < nbWinners; i++) {\\n\\n            uint32 nbBytesNeeded = divisionRoundUp(uint32(log2(nbParticipants - i)), 8);\\n            bytes memory extractedEntropy = extractBytes(totalEntropy, from, nbBytesNeeded);\\n            from += nbBytesNeeded;\\n\\n            uint32 randomNumber = uint32(bytesToUint(extractedEntropy));\\n            randomNumber = randomNumber % (nbParticipants - i);\\n            uint32 tempIndex = randomNumber;\\n            uint32 min = 0;\\n\\n            while (true) {\\n                uint32 offset = nbValuesBetween(winnerIndexes, min, tempIndex, i);\\n                if (offset == 0) {\\n                    break;\\n                }\\n                min = tempIndex + 1;\\n                tempIndex += offset;\\n            }\\n\\n            winnerIndexes[i] = tempIndex;\\n        }\\n\\n        // We want to display line numbers, not indexes, so all indexes need to be +1\\n        for (uint32 i = 0; i < nbWinners; i++) {\\n            winnerIndexes[i] += 1;\\n        }\\n\\n        return winnerIndexes;\\n    }\\n\\n    function getQueue() external view onlyOwner returns (string[] memory) {\\n        return queue;\\n    }\\n\\n\\n    /*** Setters ***/\\n\\n    function setSubscription(uint64 subscriptionId) external onlyOwner {\\n        s_subscriptionId = subscriptionId;\\n    }\\n\\n\\n    /*** Utils ***/\\n\\n    // Division rounds down by default in Solidity, this function rounds up\\n    function divisionRoundUp(uint32 a, uint32 m) private pure returns (uint32) {\\n        return (a + m - 1) / m;\\n    }\\n\\n    function extractBytes(bytes memory data, uint32 from, uint32 n) private pure returns (bytes memory) {\\n        \\n        require(data.length >= from + n, \\\"Slice out of bounds\\\");\\n        \\n        bytes memory returnValue = new bytes(n);\\n        for (uint32 i = 0; i < n; i++) {\\n            returnValue[i] = data[from + i]; \\n        }\\n        return returnValue;\\n    }\\n\\n    // See https://ethereum.stackexchange.com/a/51234\\n    function bytesToUint(bytes memory b) internal pure returns (uint256) {\\n        uint256 number;\\n        for(uint i = 0; i < b.length; i++){\\n            number = number + uint(uint8(b[i]))*(2**(8*(b.length-(i+1))));\\n        }\\n        return number;\\n    }\\n\\n    function nbValuesBetween(uint32[] memory arr, uint32 min, uint32 max, uint32 imax) internal pure returns (uint32) {\\n        uint32 count = 0;\\n\\n        for (uint32 i = 0; i < imax; i++) {\\n            if (arr[i] >= min && arr[i] <= max) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    // See https://ethereum.stackexchange.com/a/30168\\n    function log2(uint256 x) internal pure returns (uint256 y) {\\n        assembly {\\n            let arg := x\\n            x := sub(x,1)\\n            x := or(x, div(x, 0x02))\\n            x := or(x, div(x, 0x04))\\n            x := or(x, div(x, 0x10))\\n            x := or(x, div(x, 0x100))\\n            x := or(x, div(x, 0x10000))\\n            x := or(x, div(x, 0x100000000))\\n            x := or(x, div(x, 0x10000000000000000))\\n            x := or(x, div(x, 0x100000000000000000000000000000000))\\n            x := add(x, 1)\\n            let m := mload(0x40)\\n            mstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\\n            mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\\n            mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\\n            mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\\n            mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\\n            mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\\n            mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\\n            mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\\n            mstore(0x40, add(m, 0x100))\\n            let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\\n            let shift := 0x100000000000000000000000000000000000000000000000000000000000000\\n            let a := div(mul(x, magic), shift)\\n            y := div(mload(add(m,sub(255,a))), shift)\\n            y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\\n        }  \\n    }\\n\\n    // idx must be sorted in ascending order\\n    function removeIndexesFromArray(string[] storage arr, uint32[] memory idx) internal {\\n\\n        uint32 previous = idx[0];\\n        for (uint32 i = 1; i < idx.length; i++) {\\n            if (previous < idx[i]) {\\n                previous = idx[i];\\n            } else {\\n                revert(\\\"Indexes must be sorted\\\");\\n            }\\n        }\\n        require(idx[idx.length - 1] < arr.length, \\\"Index to remove out of bound\\\");\\n\\n        uint32 stopAtIndex = uint32(arr.length - idx.length);\\n        uint32 indexToMove = uint32(arr.length);\\n        uint32 j = 0;\\n\\n        for (uint32 i = 0; i < idx.length; i++) {\\n\\n            if (idx[i] >= stopAtIndex) {\\n                break;\\n            }\\n\\n            indexToMove--;\\n\\n            while (j < idx.length) {\\n                uint32 indexToRemove = idx[idx.length-j-1];\\n\\n                if (indexToRemove == indexToMove) {\\n                    indexToMove--;\\n                } else {\\n                    break;\\n                }\\n\\n                j++;\\n            }\\n\\n            arr[idx[i]] = arr[indexToMove];\\n        }\\n\\n        for (uint32 i = 0; i < idx.length; i++) {\\n            arr.pop();\\n        }\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"}],\"name\":\"DrawAlreadyCompleted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"}],\"name\":\"DrawAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"}],\"name\":\"DrawAlreadyTriggered\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"}],\"name\":\"DrawDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"}],\"name\":\"DrawTooEarly\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"cids\",\"type\":\"string[]\"}],\"name\":\"NoEntropyNeeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"RandomnessFulfilledButEmpty\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"RequestAlreadyFulfilled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"RequestDoesNotExist\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"publishedAt\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"scheduledAt\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"entropyNeeded\",\"type\":\"uint32\"}],\"name\":\"DrawLaunched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"cids\",\"type\":\"string[]\"}],\"name\":\"DrawsCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"RandomnessFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"cids\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"s_subscriptionId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"requestConfirmations\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"}],\"name\":\"RandomnessRequested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDrawCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"}],\"name\":\"getDrawDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"publishedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"scheduledAt\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"occuredAt\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nbParticipants\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"nbWinners\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"entropyNeeded\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"entropy\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"entropyPending\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"}],\"internalType\":\"struct VerifiableDraws.Draw\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQueue\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"}],\"name\":\"getRandomnessForDraw\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getRequestStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"}],\"name\":\"getWinners\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"scheduledAt\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"nbParticipants\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"nbWinners\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"entropyNeeded\",\"type\":\"uint32\"}],\"name\":\"launchDraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"s_requests\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"name\":\"setSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VerifiableDraws", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000305", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}