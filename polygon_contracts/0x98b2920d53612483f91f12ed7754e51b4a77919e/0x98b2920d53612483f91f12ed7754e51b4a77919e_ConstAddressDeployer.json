{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2022-08-31\r\n*/\r\n\r\n// Sources flattened with hardhat v2.10.1 https://hardhat.org\r\n\r\n// File contracts/ConstAddressDeployer.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.9;\r\n\r\ncontract ConstAddressDeployer {\r\n    error EmptyBytecode();\r\n    error FailedDeploy();\r\n    error FailedInit();\r\n\r\n    event Deployed(bytes32 indexed bytecodeHash, bytes32 indexed salt, address indexed deployedAddress);\r\n\r\n    /**\r\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\r\n     * will be deployed can be known in advance via {deployedAddress}.\r\n     *\r\n     * The bytecode for a contract can be obtained from Solidity with\r\n     * `type(contractName).creationCode`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `bytecode` must not be empty.\r\n     * - `salt` must have not been used for `bytecode` already by the same `msg.sender`.\r\n     */\r\n    function deploy(bytes memory bytecode, bytes32 salt) external returns (address deployedAddress_) {\r\n        deployedAddress_ = _deploy(bytecode, keccak256(abi.encode(msg.sender, salt)));\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys a contract using `CREATE2` and initialize it. The address where the contract\r\n     * will be deployed can be known in advance via {deployedAddress}.\r\n     *\r\n     * The bytecode for a contract can be obtained from Solidity with\r\n     * `type(contractName).creationCode`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `bytecode` must not be empty.\r\n     * - `salt` must have not been used for `bytecode` already by the same `msg.sender`.\r\n     * - `init` is used to initialize the deployed contract\r\n     *    as an option to not have the constructor args affect the address derived by `CREATE2`.\r\n     */\r\n    function deployAndInit(\r\n        bytes memory bytecode,\r\n        bytes32 salt,\r\n        bytes calldata init\r\n    ) external returns (address deployedAddress_) {\r\n        deployedAddress_ = _deploy(bytecode, keccak256(abi.encode(msg.sender, salt)));\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, ) = deployedAddress_.call(init);\r\n        if (!success) revert FailedInit();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} or {deployAndInit} by `sender`.\r\n     * Any change in the `bytecode`, `sender`, or `salt` will result in a new destination address.\r\n     */\r\n    function deployedAddress(\r\n        bytes calldata bytecode,\r\n        address sender,\r\n        bytes32 salt\r\n    ) external view returns (address deployedAddress_) {\r\n        bytes32 newSalt = keccak256(abi.encode(sender, salt));\r\n        deployedAddress_ = address(\r\n            uint160(\r\n                uint256(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            hex'ff',\r\n                            address(this),\r\n                            newSalt,\r\n                            keccak256(bytecode) // init code hash\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    function _deploy(bytes memory bytecode, bytes32 salt) internal returns (address deployedAddress_) {\r\n        if (bytecode.length == 0) revert EmptyBytecode();\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            deployedAddress_ := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n\r\n        if (deployedAddress_ == address(0)) revert FailedDeploy();\r\n\r\n        emit Deployed(keccak256(bytecode), salt, deployedAddress_);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"EmptyBytecode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedDeploy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInit\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bytecodeHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployedAddress\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"init\",\"type\":\"bytes\"}],\"name\":\"deployAndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deployedAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ConstAddressDeployer", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6a8d0537e27fe239a39d5ad8e5334db0447d0a1d7d49a7e82479baaa1319b396"}