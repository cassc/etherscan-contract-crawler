{"SourceCode": "{\"earnpassive.sol\":{\"content\":\"// SPDX-License-Identifier: GPLv3\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ncontract AddressChecker {\\r\\n    function isContract(address _address) public view returns (bool) {\\r\\n        uint256 size;\\r\\n        assembly { size := extcodesize(_address) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\ncontract Earnpassiveclub is ReentrancyGuard ,AddressChecker {\\r\\n    using SafeMath for uint256; \\r\\n    uint256 private constant timeStep = 1 days; // use to calculate different time\\r\\n    uint256 private constant dayPerCycle = 5 days;  // this is cycle \\r\\n    uint256 private constant maxAddFreeze = 35 days; // this will add with day per cycle and defined cycle upto 35 days\\r\\n    uint256 private constant predictDuration = 30 minutes; // only 30 minutes can alloted to participate in prediction\\r\\n    uint256 private constant initDayNewbies = 5;  // this is how much newbie can join each day\\r\\n    uint256 private constant incInterval = 2;  // this is interval which increase the newbie joining number\\r\\n    uint256 private constant incNumber = 1; // this is increament to newbie joining after interval\\r\\n    uint256 private constant unlimitDay = 1095; // unlimmited joining after this count days\\r\\n    uint256 private constant predictFee = 2e6; // prediction participate fee\\r\\n    uint256 private constant dayPredictLimit = 10; // only 10 person can predict in 1 day\\r\\n    uint256 private constant maxSearchDepth = 3000; // maximum depth for seach\\r\\n    uint256 private constant baseDividend = 10000; // divide values on it\\r\\n    uint256 private constant incomeFeePercents = 700; // income percent 7 %\\r\\n    uint256 private constant bonusPercents = 500; // bonus percent 5 % only apply 1 time\\r\\n    uint256 private constant splitPercents = 3000; // on withdrawal 30% split fee\\r\\n    uint256 private constant transferFeePercents = 1000; // on split transfer 10% will be deducted\\r\\n    uint256 private constant dayRewardPercents = 200;  //user will get per day 2 %\\r\\n    uint256 private constant predictPoolPercents = 300; //on transfer 3 % prediction pool fee\\r\\n    uint256 private constant unfreezeWithoutIncomePercents = 15000;\\r\\n    uint256 private constant unfreezeWithIncomePercents = 20000;\\r\\n    uint256 private constant specialCLubParti=500*1e6;\\r\\n    uint256 private constant SpecialDays= 7 days;\\r\\n    struct SpecialClub {\\r\\n    uint256 SpecialClubUsersCount;\\r\\n    bool isEligible;\\r\\n    uint256 timeTogetIn;\\r\\n    uint256 unlockedTime;\\r\\n    uint256 getreward;\\r\\n\\r\\n    }\\r\\n\\r\\n    mapping(address=\\u003eSpecialClub) public SpecialClubInfo;\\r\\n\\r\\n    \\r\\n\\r\\n    uint256 private Gasvalue=0.03e6;\\r\\n    address private owner;\\r\\n    uint256 public Additionaldays;\\r\\n    uint256[8] private SpecialClubWinner = [2e6, 4e6, 8e6, 16e6, 32e6, 64e6, 128e6, 256e6]; // lottery winner percentage\\r\\n    uint256[5] private levelTeam = [0, 0, 0, 50, 200]; // need this number of team member to level up\\r\\n    uint256[5] private levelInvite = [0, 0, 0, 10000e6, 20000e6]; // level deposit check to upgrade level \\r\\n    uint256[6] private levelDeposit = [50e6, 500e6, 1000e6, 2000e6, 3000e6, 5000e6]; // this is level based minimum deposit condition\\r\\n    uint256[5] private balReached = [50e10, 100e10, 200e10, 500e10, 1000e10]; //contract balance used to stop rewards \\r\\n    uint256[5] private balFreeze = [35e10, 70e10, 100e10, 300e10, 500e10]; // contract balance check freezing ballance\\r\\n    uint256[5] private balUnfreeze = [80e10, 150e10, 200e10, 500e10, 1000e10]; // contract balance check freezing ballance\\r\\n    uint256[20] private invitePercents = [600, 100, 200, 300, 200, 100, 100, 100, 50, 50, 50, 50, 30, 20, 20];  // referal percentage\\r\\n    uint256[20] private predictWinnerPercents = [3000, 2000, 1000, 500, 500, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200]; // lottery winner percentage\\r\\n\\r\\n    IERC20 private usdt;\\r\\n    address private feeReceiver; // receive the fee as a owner of contract\\r\\n    address private defaultRefer;// receive the default referal fee\\r\\n    uint256 private startTime;  //plan started time\\r\\n    uint256 private lastDistribute;\\r\\n    uint256 private totalUsers;\\r\\n    uint256 private totalDeposit;\\r\\n    uint256 private freezedTimes;\\r\\n    uint256 private predictPool;\\r\\n    uint256 private totalPredictPool;\\r\\n    uint256 private totalWinners;\\r\\n    bool private isFreezing;\\r\\n    address[] private depositors;\\r\\n    mapping(uint256=\\u003ebool) private balStatus;\\r\\n    mapping(uint256=\\u003eaddress[]) private dayNewbies;\\r\\n    mapping(uint256=\\u003euint256) private freezeTime;\\r\\n    mapping(uint256=\\u003euint256) private unfreezeTime;\\r\\n    mapping(uint256=\\u003euint256) private dayPredictPool;\\r\\n    mapping(uint256=\\u003euint256) private dayDeposits;\\r\\n    mapping(address=\\u003emapping(uint256=\\u003ebool)) private isUnfreezedReward;\\r\\n    mapping(uint256=\\u003emapping(uint256=\\u003eaddress[])) private dayPredictors;\\r\\n    mapping(uint256=\\u003emapping(address=\\u003ePredictInfo[])) private userPredicts;\\r\\n    \\r\\n    struct UserInfo {\\r\\n        address referrer;\\r\\n        uint256 level;\\r\\n        uint256 maxDeposit;\\r\\n        uint256 maxDepositable;\\r\\n        uint256 teamNum;\\r\\n        uint256 teamTotalDeposit;\\r\\n        uint256 totalFreezed;\\r\\n        uint256 totalRevenue;\\r\\n        uint256 unfreezeIndex;\\r\\n        uint256 startTime;\\r\\n        bool isMaxFreezing;\\r\\n    }\\r\\n    struct RewardInfo{\\r\\n        uint256 capitals;\\r\\n        uint256 statics;\\r\\n        uint256 invited;\\r\\n        uint256 bonusFreezed;\\r\\n        uint256 bonusReleased;\\r\\n        uint256 l5Freezed;\\r\\n        uint256 l5Released;\\r\\n        uint256 predictWin;\\r\\n        uint256 split;\\r\\n        uint256 lastWithdaw;\\r\\n    }\\r\\n    struct OrderInfo {\\r\\n        uint256 amount;\\r\\n        uint256 start;\\r\\n        uint256 unfreeze;\\r\\n        bool isUnfreezed;\\r\\n    }\\r\\n    struct PredictInfo {\\r\\n        uint256 time;\\r\\n        uint256 number;\\r\\n    }\\r\\n\\r\\n    struct GasInfo{\\r\\n        uint256 remainigPoint;\\r\\n        uint256 number; \\r\\n    }\\r\\n    mapping(address=\\u003eUserInfo) private userInfo;\\r\\n    mapping(address=\\u003eRewardInfo) private rewardInfo;\\r\\n    mapping(address=\\u003eOrderInfo[]) private orderInfos;\\r\\n    mapping (address =\\u003eGasInfo) public GasFeeInfo;\\r\\n    mapping(address=\\u003emapping(uint256=\\u003euint256)) private userCycleMax;\\r\\n    mapping(address=\\u003emapping(uint256=\\u003eaddress[])) private teamUsers;\\r\\n    mapping(address=\\u003eaddress[]) private specialrefaddress;\\r\\n    mapping(address=\\u003ebool) public blacklistAddress;\\r\\n\\r\\n    event Register(address user, address referral);\\r\\n    event Deposit(address user, uint256 types, uint256 amount, bool isFreezing);\\r\\n    event TransferBySplit(address user, uint256 subBal, address receiver, uint256 amount);\\r\\n    event Withdraw(address user, uint256 incomeFee, uint256 poolFee, uint256 split, uint256 withdraw);\\r\\n    event Predict(uint256 time, address user, uint256 amount);\\r\\n    event DistributePredictPool(uint256 day, uint256 reward, uint256 pool, uint256 time);\\r\\n\\r\\n    constructor(address _usdtAddr, address _defaultRefer, address _feeReceiver, uint256 _startTime) {\\r\\n        usdt = IERC20(_usdtAddr);\\r\\n        defaultRefer = _defaultRefer;\\r\\n        feeReceiver = _feeReceiver;\\r\\n        startTime = _startTime;\\r\\n        lastDistribute = _startTime;\\r\\n        owner=msg.sender;\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n     modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"Not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function register(address _referral) external nonReentrant {\\r\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\r\\n        require(userInfo[_referral].maxDeposit \\u003e 0 || _referral == defaultRefer, \\\"invalid refer\\\");\\r\\n        require(userInfo[msg.sender].referrer == address(0), \\\"referrer bonded\\\");\\r\\n        userInfo[msg.sender].referrer = _referral;\\r\\n        emit Register(msg.sender, _referral);\\r\\n    }\\r\\n\\r\\n    function deposit(uint256 _amount) external  nonReentrant{\\r\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\r\\n        _deposit(msg.sender, _amount, 0);\\r\\n    }\\r\\n\\r\\n    function depositBySplit(uint256 _amount) public nonReentrant{\\r\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\r\\n        _deposit(msg.sender, _amount, 1);\\r\\n\\r\\n    }\\r\\n\\r\\n    function redeposit() public nonReentrant{\\r\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\r\\n        _deposit(msg.sender, 0, 2);\\r\\n    }\\r\\n\\r\\n    function _deposit(address _userAddr, uint256 _amount, uint256 _types) private {\\r\\n        require(block.timestamp \\u003e= startTime, \\\"not start\\\");\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        require(user.referrer != address(0), \\\"not register\\\");\\r\\n        require(blacklistAddress[_userAddr]==false,\\\"Not Allowed!\\\");\\r\\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\\r\\n        GasFeeInfo[_userAddr].remainigPoint+=Gasvalue;\\r\\n        \\r\\n\\r\\n        \\r\\n        \\r\\n        // simple deposit , also checked the contract balance thresholds \\r\\n        if(_types == 0)\\r\\n        {\\r\\n            usdt.transferFrom(_userAddr, address(this), _amount);\\r\\n            _balActived();\\r\\n\\r\\n            if(user.maxDeposit==0 \\u0026\\u0026 _amount\\u003e=specialCLubParti)\\r\\n            {\\r\\n                SpecialClubInfo[_userAddr].isEligible=true;\\r\\n                specialrefaddress[user.referrer].push(msg.sender);\\r\\n            \\r\\n                if(SpecialClubInfo[user.referrer].isEligible==true)\\r\\n                {\\r\\n                    SpecialClubInfo[user.referrer].SpecialClubUsersCount+=1;\\r\\n                    if(SpecialClubInfo[user.referrer].SpecialClubUsersCount==2)\\r\\n                    {\\r\\n                        SpecialClubInfo[user.referrer].timeTogetIn=block.timestamp;\\r\\n                        SpecialClubInfo[user.referrer].unlockedTime=block.timestamp+ timeStep;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // split deposit, \\r\\n        else if(_types == 1){\\r\\n            require(user.level == 0, \\\"actived\\\");\\r\\n            require(userRewards.split \\u003e= _amount, \\\"insufficient\\\");\\r\\n            require(_amount.mod(levelDeposit[0].mul(2)) == 0, \\\"amount err\\\");\\r\\n            userRewards.split = userRewards.split.sub(_amount);\\r\\n        }\\r\\n        //redeposit\\r\\n        else{\\r\\n            require(user.level \\u003e 0, \\\"newbie\\\");\\r\\n            _amount = orderInfos[_userAddr][user.unfreezeIndex].amount;\\r\\n        }\\r\\n\\r\\n        uint256 curCycle = getCurCycle();\\r\\n        \\r\\n        (uint256 userCurMin, uint256 userCurMax) = getUserCycleDepositable(_userAddr, curCycle);\\r\\n        if(getOrderLength(_userAddr)==0)\\r\\n        {\\r\\n            require(_amount\\u003e=50e6 \\u0026\\u0026 _amount\\u003c=1000e6,\\\"1st cycle min or max not fulfiled !\\\");\\r\\n        }\\r\\n        else if(getOrderLength(_userAddr)==2)\\r\\n        {\\r\\n            require(_amount\\u003e=50e6 \\u0026\\u0026 _amount\\u003c=2000e6,\\\"3rd cycle min or max not fulfiled !\\\");\\r\\n        }\\r\\n          else if(getOrderLength(_userAddr)==4)\\r\\n        {\\r\\n            require(_amount\\u003e=50e6 \\u0026\\u0026 _amount\\u003c=3000e6,\\\"5th cycle min or max not fulfiled !\\\");\\r\\n        }\\r\\n          else if(getOrderLength(_userAddr)==6)\\r\\n        {\\r\\n            require(_amount\\u003e=50e6 \\u0026\\u0026 _amount\\u003c=4000e6,\\\"7th cycle min or max not fulfiled !\\\");\\r\\n        }\\r\\n          else if(getOrderLength(_userAddr)==8)\\r\\n        {\\r\\n            require(_amount\\u003e=50e6 \\u0026\\u0026 _amount\\u003c=5000e6,\\\"9th cycle min or max not fulfiled !\\\");\\r\\n        }\\r\\n\\r\\n        require(_amount \\u003e= userCurMin \\u0026\\u0026 _amount \\u003c= userCurMax \\u0026\\u0026 _amount.mod(levelDeposit[0]) == 0, \\\"amount err\\\");\\r\\n        if(getOrderLength(_userAddr)\\u003e8){\\r\\n            require(user.teamNum\\u003e0,\\\"Need atleast 1 direct to start 9th cycle\\\");\\r\\n        }\\r\\n        if(isFreezing \\u0026\\u0026 !isUnfreezedReward[_userAddr][freezedTimes]) \\r\\n        isUnfreezedReward[_userAddr][freezedTimes] = true;\\r\\n        \\r\\n        uint256 curDay = getCurDay();\\r\\n        dayDeposits[curDay] = dayDeposits[curDay].add(_amount);\\r\\n        totalDeposit = totalDeposit.add(_amount);\\r\\n        depositors.push(_userAddr);\\r\\n\\r\\n        if(user.level == 0){\\r\\n            if(curDay \\u003c unlimitDay) \\r\\n            require(dayNewbies[curDay].length \\u003c getMaxDayNewbies(curDay), \\\"reach max\\\");\\r\\n            dayNewbies[curDay].push(_userAddr);\\r\\n            totalUsers = totalUsers + 1;\\r\\n            user.startTime = block.timestamp;\\r\\n            if(_types == 0) {\\r\\n                userRewards.bonusFreezed = _amount.mul(bonusPercents).div(baseDividend);\\r\\n                user.totalRevenue = user.totalRevenue.add(userRewards.bonusFreezed);\\r\\n            }\\r\\n        }\\r\\n        _updateUplineReward(_userAddr, _amount);\\r\\n        _unfreezeCapitalOrReward(_userAddr, _amount, _types);\\r\\n        bool isMaxFreezing = _addNewOrder(_userAddr, _amount, _types, user.startTime, user.isMaxFreezing);\\r\\n        user.isMaxFreezing = isMaxFreezing;\\r\\n        _updateUserMax(_userAddr, _amount, userCurMax, curCycle);\\r\\n        _updateLevel(_userAddr);\\r\\n        if(isFreezing) _setFreezeReward();\\r\\n        emit Deposit(_userAddr, _types, _amount, isFreezing);\\r\\n    }\\r\\n\\r\\n    function _updateUplineReward(address _userAddr, uint256 _amount) private {\\r\\n        address upline = userInfo[_userAddr].referrer;\\r\\n        for(uint256 i = 0; i \\u003c invitePercents.length; i++){\\r\\n            if(upline != address(0)){\\r\\n                if(!isFreezing || isUnfreezedReward[upline][freezedTimes]){\\r\\n                    OrderInfo[] storage upOrders = orderInfos[upline];\\r\\n                    if(upOrders.length \\u003e 0){\\r\\n                        uint256 latestUnFreezeTime = getOrderUnfreezeTime(upline, upOrders.length - 1);\\r\\n                        uint256 maxFreezing = latestUnFreezeTime \\u003e block.timestamp ? upOrders[upOrders.length - 1].amount : 0;\\r\\n                        uint256 newAmount = maxFreezing \\u003c _amount ? maxFreezing : _amount;\\r\\n                        if(newAmount \\u003e 0){\\r\\n                            RewardInfo storage upRewards = rewardInfo[upline];\\r\\n                            uint256 reward = newAmount.mul(invitePercents[i]).div(baseDividend);\\r\\n                            if(i == 0 || (i \\u003c 4 \\u0026\\u0026 userInfo[upline].level \\u003e= 4)){\\r\\n                                upRewards.invited = upRewards.invited.add(reward);\\r\\n                                userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\\r\\n                            }else if(userInfo[upline].level \\u003e= 5){\\r\\n                                upRewards.l5Freezed = upRewards.l5Freezed.add(reward);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n                if(upline == defaultRefer) break;\\r\\n                upline = userInfo[upline].referrer;\\r\\n            }else{\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function _unfreezeCapitalOrReward(address _userAddr, uint256 _amount, uint256 _types) private {\\r\\n        (uint256 unfreezed, uint256 rewards) = _unfreezeOrder(_userAddr, _amount);\\r\\n        if(_types == 0){\\r\\n            require(_amount \\u003e unfreezed, \\\"redeposit only\\\");\\r\\n        }else if(_types \\u003e= 2){\\r\\n            require(_amount == unfreezed, \\\"redeposit err\\\");\\r\\n        }\\r\\n\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\\r\\n        if(unfreezed \\u003e 0){\\r\\n            user.unfreezeIndex = user.unfreezeIndex + 1;\\r\\n            if(userRewards.bonusFreezed \\u003e 0){\\r\\n                userRewards.bonusReleased = userRewards.bonusFreezed;\\r\\n                userRewards.bonusFreezed = 0;\\r\\n            }\\r\\n\\r\\n            if(rewards \\u003e 0) userRewards.statics = userRewards.statics.add(rewards);\\r\\n            if(_types \\u003c 2) userRewards.capitals = userRewards.capitals.add(unfreezed);\\r\\n        }else{\\r\\n            uint256 l5Freezed = userRewards.l5Freezed;\\r\\n            if(l5Freezed \\u003e 0){\\r\\n                rewards = _amount \\u003c= l5Freezed ? _amount : l5Freezed;\\r\\n                userRewards.l5Freezed = l5Freezed.sub(rewards);\\r\\n                userRewards.l5Released = userRewards.l5Released.add(rewards);\\r\\n            }\\r\\n        }\\r\\n        user.totalRevenue = user.totalRevenue.add(rewards);\\r\\n        _updateFreezeAndTeamDeposit(_userAddr, _amount, unfreezed);\\r\\n    }\\r\\n\\r\\n    function _unfreezeOrder(address _userAddr, uint256 _amount) private returns(uint256 unfreezed, uint256 rewards){\\r\\n        if(orderInfos[_userAddr].length \\u003e 0){\\r\\n            UserInfo storage user = userInfo[_userAddr];\\r\\n            \\r\\n            OrderInfo storage order = orderInfos[_userAddr][user.unfreezeIndex];\\r\\n            uint256 orderUnfreezeTime = getOrderUnfreezeTime(_userAddr, user.unfreezeIndex);\\r\\n            // below lv5, deposit once per cycle\\r\\n            if(user.level \\u003e 0 \\u0026\\u0026 user.level \\u003c 5) require(block.timestamp \\u003e= orderUnfreezeTime, \\\"freezing\\\");\\r\\n            if(order.isUnfreezed == false \\u0026\\u0026 block.timestamp \\u003e= orderUnfreezeTime \\u0026\\u0026 _amount \\u003e= order.amount){\\r\\n                order.isUnfreezed = true;\\r\\n                unfreezed = order.amount;\\r\\n                if(getCurDay()\\u003c=365){\\r\\n                rewards = order.amount.mul(dayRewardPercents).mul(dayPerCycle).div(timeStep).div(baseDividend);\\r\\n                }\\r\\n                else if(getCurDay()\\u003c=730)\\r\\n                {\\r\\n                    rewards = order.amount.mul(250).mul(dayPerCycle).div(timeStep).div(baseDividend);\\r\\n                }\\r\\n                else\\r\\n                {\\r\\n                    rewards = order.amount.mul(300).mul(dayPerCycle).div(timeStep).div(baseDividend);\\r\\n\\r\\n                }\\r\\n                // need to understanf this\\r\\n                if(isFreezing){\\r\\n                    if(user.totalFreezed \\u003e user.totalRevenue){\\r\\n                        uint256 leftCapital = user.totalFreezed.sub(user.totalRevenue);\\r\\n                        if(rewards \\u003e leftCapital){\\r\\n                            rewards = leftCapital;\\r\\n                        }\\r\\n                    }else{\\r\\n                        rewards = 0;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updateFreezeAndTeamDeposit(address _userAddr, uint256 _amount, uint256 _unfreezed) private {\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        if(_amount \\u003e _unfreezed){\\r\\n            uint256 incAmount = _amount.sub(_unfreezed);\\r\\n            user.totalFreezed = user.totalFreezed.add(incAmount);\\r\\n            address upline = user.referrer;\\r\\n            for(uint256 i = 0; i \\u003c invitePercents.length; i++){\\r\\n                if(upline != address(0)){\\r\\n                    UserInfo storage upUser = userInfo[upline];\\r\\n                    if(user.level == 0 \\u0026\\u0026 _userAddr != upline){\\r\\n                        upUser.teamNum = upUser.teamNum + 1;\\r\\n                        teamUsers[upline][i].push(_userAddr);\\r\\n                    }\\r\\n                    upUser.teamTotalDeposit = upUser.teamTotalDeposit.add(incAmount);\\r\\n                    if(upline == defaultRefer) break;\\r\\n                    upline = upUser.referrer;\\r\\n                }else{\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _addNewOrder(address _userAddr, uint256 _amount, uint256 _types, uint256 _startTime, bool _isMaxFreezing) private returns(bool isMaxFreezing){\\r\\n        uint256 addFreeze;\\r\\n        OrderInfo[] storage orders = orderInfos[_userAddr];\\r\\n        if(_isMaxFreezing){\\r\\n            isMaxFreezing = true;\\r\\n        }else{\\r\\n            if((freezedTimes \\u003e 0 \\u0026\\u0026 _types == 1) || (!isFreezing \\u0026\\u0026 _startTime \\u003c freezeTime[freezedTimes])){\\r\\n                isMaxFreezing = true;\\r\\n            }else{\\r\\n                addFreeze = (orders.length).mul(timeStep);\\r\\n                if(addFreeze \\u003e maxAddFreeze) isMaxFreezing = true;\\r\\n            }\\r\\n        }\\r\\n        uint256 unfreeze = isMaxFreezing ? block.timestamp.add(dayPerCycle).add(maxAddFreeze) : block.timestamp.add(dayPerCycle).add(addFreeze);\\r\\n        orders.push(OrderInfo(_amount, block.timestamp, unfreeze, false));\\r\\n    }\\r\\n\\r\\n\\r\\n    function _updateUserMax(address _userAddr, uint256 _amount, uint256 _userCurMax, uint256 _curCycle) internal {\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        if(_amount \\u003e user.maxDeposit) user.maxDeposit = _amount;\\r\\n        userCycleMax[_userAddr][_curCycle] = _userCurMax;\\r\\n        uint256 nextMaxDepositable;\\r\\n        if(_amount == _userCurMax){\\r\\n            uint256 curMaxDepositable = getCurMaxDepositable();\\r\\n            if(_userCurMax \\u003e= levelDeposit[4]){\\r\\n                nextMaxDepositable = curMaxDepositable;\\r\\n            }else{\\r\\n                if(_userCurMax \\u003e= levelDeposit[3]){\\r\\n                    nextMaxDepositable = levelDeposit[4];\\r\\n                }else if(_userCurMax \\u003e= levelDeposit[2]){\\r\\n                    nextMaxDepositable = levelDeposit[3];\\r\\n                }\\r\\n                else{\\r\\n                    nextMaxDepositable = levelDeposit[2];\\r\\n                }\\r\\n            }\\r\\n        }else{\\r\\n            nextMaxDepositable = _userCurMax;\\r\\n        }\\r\\n        userCycleMax[_userAddr][_curCycle + 1] = nextMaxDepositable;\\r\\n        user.maxDepositable = nextMaxDepositable;\\r\\n    }\\r\\n\\r\\n    function _updateLevel(address _userAddr) private {\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        for(uint256 i = user.level; i \\u003c levelDeposit.length; i++){\\r\\n            if(user.maxDeposit \\u003e= levelDeposit[i]){\\r\\n                if(i \\u003c 3){\\r\\n                    user.level = i + 1;\\r\\n                }else{\\r\\n                    (uint256 maxTeam, uint256 otherTeam, ) = getTeamDeposit(_userAddr);\\r\\n                    if(maxTeam \\u003e= levelInvite[i] \\u0026\\u0026 otherTeam \\u003e= levelInvite[i] \\u0026\\u0026 user.teamNum \\u003e= levelTeam[i]){\\r\\n                        user.level = i + 1;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw() external nonReentrant{\\r\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\r\\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\\r\\n        uint256 withdrawable;\\r\\n        uint256 incomeFee;\\r\\n        uint256 predictPoolFee;\\r\\n        uint256 split;\\r\\n        GasFeeInfo[msg.sender].remainigPoint+=Gasvalue;\\r\\n        require(blacklistAddress[msg.sender]==false,\\\"Not Allowed!\\\");\\r\\n        if(checkuserstatus(msg.sender)==true){\\r\\n        uint256 rewardsStatic = userRewards.statics.add(userRewards.invited).add(userRewards.bonusReleased).add(userRewards.predictWin);\\r\\n         incomeFee = rewardsStatic.mul(incomeFeePercents).div(baseDividend);\\r\\n        usdt.transfer(feeReceiver, incomeFee);\\r\\n         predictPoolFee = rewardsStatic.mul(predictPoolPercents).div(baseDividend);\\r\\n        predictPool = predictPool.add(predictPoolFee);\\r\\n        totalPredictPool = totalPredictPool.add(predictPoolFee);\\r\\n        uint256 leftReward = rewardsStatic.add(userRewards.l5Released).sub(incomeFee).sub(predictPoolFee);\\r\\n         split = leftReward.mul(splitPercents).div(baseDividend);\\r\\n         withdrawable = leftReward.sub(split);\\r\\n        uint256 capitals = userRewards.capitals;\\r\\n        userRewards.capitals = 0;\\r\\n        userRewards.statics = 0;\\r\\n        userRewards.invited = 0;\\r\\n        userRewards.bonusReleased = 0;\\r\\n        userRewards.l5Released = 0;\\r\\n        userRewards.predictWin = 0;\\r\\n        userRewards.split = userRewards.split.add(split);\\r\\n        userRewards.lastWithdaw = block.timestamp;\\r\\n        withdrawable = withdrawable.add(capitals);\\r\\n        usdt.transfer(msg.sender, withdrawable);\\r\\n        if(!isFreezing)\\r\\n         _setFreezeReward();\\r\\n        \\r\\n        emit Withdraw(msg.sender, incomeFee, predictPoolFee, split, withdrawable);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n        usdt.transfer(owner, withdrawable);\\r\\n        emit Withdraw(owner, incomeFee, predictPoolFee, split, withdrawable);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function predict(uint256 _amount) external nonReentrant{\\r\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\r\\n        require(userInfo[msg.sender].referrer != address(0), \\\"not register\\\");\\r\\n        require(_amount.mod(levelDeposit[0]) == 0, \\\"amount err\\\");\\r\\n        uint256 curDay = getCurDay();\\r\\n        require(userPredicts[curDay][msg.sender].length \\u003c dayPredictLimit, \\\"reached day limit\\\");\\r\\n        uint256 predictEnd = startTime.add(curDay.mul(timeStep)).add(predictDuration);\\r\\n        require(block.timestamp \\u003c predictEnd, \\\"today is over\\\");\\r\\n        GasFeeInfo[msg.sender].remainigPoint+=Gasvalue;\\r\\n        usdt.transferFrom(msg.sender, address(this), predictFee);\\r\\n        dayPredictors[curDay][_amount].push(msg.sender);\\r\\n        userPredicts[curDay][msg.sender].push(PredictInfo(block.timestamp, _amount));\\r\\n        if(isFreezing) _setFreezeReward();\\r\\n        emit Predict(block.timestamp, msg.sender, _amount);\\r\\n    }\\r\\n    \\r\\n\\r\\n    function transferBySplit(address _receiver, uint256 _amount) external nonReentrant{\\r\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\r\\n        uint256 minTransfer = levelDeposit[0].mul(2);\\r\\n        require(_amount \\u003e= minTransfer \\u0026\\u0026 _amount.mod(minTransfer) == 0, \\\"amount err\\\");\\r\\n        uint256 subBal = _amount.add(_amount.mul(transferFeePercents).div(baseDividend));\\r\\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\\r\\n        require(userRewards.split \\u003e= subBal, \\\"insufficient split\\\");\\r\\n        userRewards.split = userRewards.split.sub(subBal);\\r\\n        rewardInfo[_receiver].split = rewardInfo[_receiver].split.add(_amount);\\r\\n        emit TransferBySplit(msg.sender, subBal, _receiver, _amount);\\r\\n    }\\r\\n\\r\\n    function distributePredictPool() external nonReentrant{\\r\\n\\r\\n        if(block.timestamp \\u003e= lastDistribute.add(timeStep)){\\r\\n            uint256 curDay = getCurDay();\\r\\n            uint256 lastDay = curDay - 1;\\r\\n            uint256 totalReward;\\r\\n            if(predictPool \\u003e 0){\\r\\n                address[] memory winners = getPredictWinners(lastDay);\\r\\n                for(uint256 i = 0; i \\u003c winners.length; i++){\\r\\n                    if(winners[i] != address(0)){\\r\\n                        uint256 reward = predictPool.mul(predictWinnerPercents[i]).div(baseDividend);\\r\\n                        totalReward = totalReward.add(reward);\\r\\n                        rewardInfo[winners[i]].predictWin = rewardInfo[winners[i]].predictWin.add(reward);\\r\\n                        userInfo[winners[i]].totalRevenue = userInfo[winners[i]].totalRevenue.add(reward);\\r\\n                        totalWinners++;\\r\\n                    }else{\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n                dayPredictPool[lastDay] = predictPool;\\r\\n                predictPool = predictPool \\u003e totalReward ? predictPool.sub(totalReward) : 0;\\r\\n            }\\r\\n            lastDistribute = startTime.add(curDay.mul(timeStep));\\r\\n            emit DistributePredictPool(lastDay, totalReward, predictPool, lastDistribute);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n//used to check either contract balance reached the 5 defined milestone if yes then make it true\\r\\n    function _balActived() private {\\r\\n        uint256 bal = usdt.balanceOf(address(this));\\r\\n        for(uint256 i = balReached.length; i \\u003e 0; i--){\\r\\n            if(bal \\u003e= balReached[i - 1]){\\r\\n                balStatus[balReached[i - 1]] = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // use to freeze the reward on the basis of contract balance\\r\\n\\r\\n    function _setFreezeReward() private {\\r\\n        uint256 bal = usdt.balanceOf(address(this));\\r\\n        for(uint256 i = balReached.length; i \\u003e 0; i--){\\r\\n            if(balStatus[balReached[i - 1]]){\\r\\n\\r\\n                if(!isFreezing){\\r\\n                    if(bal \\u003c balFreeze[i - 1]){\\r\\n                        isFreezing = true;\\r\\n                        freezedTimes = freezedTimes + 1;\\r\\n                        freezeTime[freezedTimes] = block.timestamp;\\r\\n                    }\\r\\n                }else{\\r\\n                    if(bal \\u003e= balUnfreeze[i - 1]){\\r\\n                        isFreezing = false;\\r\\n                        unfreezeTime[freezedTimes] = block.timestamp;\\r\\n                    }\\r\\n                }\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getOrderUnfreezeTime(address _userAddr, uint256 _index) public view returns(uint256 orderUnfreezeTime) {\\r\\n        OrderInfo storage order = orderInfos[_userAddr][_index];\\r\\n        orderUnfreezeTime = order.unfreeze;\\r\\n        if(!isFreezing \\u0026\\u0026 !order.isUnfreezed \\u0026\\u0026 userInfo[_userAddr].startTime \\u003c freezeTime[freezedTimes]){\\r\\n            orderUnfreezeTime =  order.start.add(dayPerCycle).add(maxAddFreeze);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserCycleDepositable(address _userAddr, uint256 _cycle) public view returns(uint256 cycleMin, uint256 cycleMax) {\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        if(user.maxDeposit \\u003e 0)\\r\\n        {\\r\\n            cycleMin = user.maxDeposit;  //last max become now cycle minimum\\r\\n            cycleMax = userCycleMax[_userAddr][_cycle];\\r\\n\\r\\n            if(cycleMax == 0) \\r\\n            cycleMax = user.maxDepositable;\\r\\n            uint256 curMaxDepositable = getCurMaxDepositable();\\r\\n            if(isFreezing)\\r\\n            {\\r\\n                if(user.startTime \\u003c freezeTime[freezedTimes] \\u0026\\u0026 !isUnfreezedReward[_userAddr][freezedTimes])\\r\\n                {\\r\\n                    cycleMin = user.totalFreezed \\u003e user.totalRevenue ? cycleMin.mul(unfreezeWithoutIncomePercents).div(baseDividend) : cycleMin.mul(unfreezeWithIncomePercents).div(baseDividend);\\r\\n                    cycleMax = curMaxDepositable;\\r\\n                }\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                if(user.startTime \\u003c freezeTime[freezedTimes]) \\r\\n                cycleMax = curMaxDepositable;\\r\\n            }\\r\\n        }\\r\\n        //new user\\r\\n        else\\r\\n        {\\r\\n            cycleMin = levelDeposit[0];\\r\\n            cycleMax = levelDeposit[1];\\r\\n        }\\r\\n        if(cycleMin \\u003e cycleMax) cycleMin = cycleMax;\\r\\n    }\\r\\n\\r\\n    function getPredictWinners(uint256 _day) public view returns(address[] memory winners) {\\r\\n        uint256 steps = dayDeposits[_day].div(levelDeposit[0]);\\r\\n        uint256 maxWinners = predictWinnerPercents.length;\\r\\n        winners = new address[](maxWinners);\\r\\n        uint256 counter;\\r\\n        for(uint256 i = steps; i \\u003e= 0; i--){\\r\\n            uint256 winAmount = i.mul(levelDeposit[0]);\\r\\n            for(uint256 j = 0; j \\u003c dayPredictors[_day][winAmount].length; j++){\\r\\n                address predictUser = dayPredictors[_day][winAmount][j];\\r\\n                if(predictUser != address(0)){\\r\\n                    winners[counter] = predictUser;\\r\\n                    counter++;\\r\\n                    if(counter \\u003e= maxWinners) break;\\r\\n                }\\r\\n            }\\r\\n            if(counter \\u003e= maxWinners || i == 0 || steps.sub(i) \\u003e= maxSearchDepth) break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getTeamDeposit(address _userAddr) public view returns(uint256 maxTeam, uint256 otherTeam, uint256 totalTeam){\\r\\n        address[] memory directTeamUsers = teamUsers[_userAddr][0];\\r\\n        for(uint256 i = 0; i \\u003c directTeamUsers.length; i++){\\r\\n            UserInfo storage user = userInfo[directTeamUsers[i]];\\r\\n            uint256 userTotalTeam = user.teamTotalDeposit.add(user.totalFreezed);\\r\\n            totalTeam = totalTeam.add(userTotalTeam);\\r\\n            if(userTotalTeam \\u003e maxTeam) maxTeam = userTotalTeam;\\r\\n            if(i \\u003e= maxSearchDepth) break;\\r\\n        }\\r\\n        otherTeam = totalTeam.sub(maxTeam);\\r\\n    }\\r\\n\\r\\n    function getCurDay() public view returns(uint256) {\\r\\n        return (block.timestamp.sub(startTime)).div(timeStep);\\r\\n    }\\r\\n\\r\\n    function getCurCycle() public view returns(uint256) {\\r\\n        return (block.timestamp.sub(startTime)).div(dayPerCycle);\\r\\n    }\\r\\n\\r\\n    function getCurMaxDepositable() public view returns(uint256) {\\r\\n        return levelDeposit[5].mul(2**freezedTimes);\\r\\n    }\\r\\n\\r\\n\\r\\n    function setAdditionaldays(uint256 _day) public  onlyOwner {\\r\\n        Additionaldays = _day;\\r\\n    }\\r\\n        function getMaxDayNewbies(uint256 _day) public view returns(uint256) {\\r\\n        return initDayNewbies + _day.mul(incNumber).div(incInterval)+Additionaldays;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function getOrderLength(address _userAddr) public view returns(uint256) {\\r\\n        return orderInfos[_userAddr].length;\\r\\n    }\\r\\n\\r\\n    function getLatestDepositors(uint256 _length) public view returns(address[] memory latestDepositors) {\\r\\n        uint256 totalCount = depositors.length;\\r\\n        if(_length \\u003e totalCount) _length = totalCount;\\r\\n        latestDepositors = new address[](_length);\\r\\n        for(uint256 i = totalCount; i \\u003e totalCount - _length; i--){\\r\\n            latestDepositors[totalCount - i] = depositors[i - 1];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getTeamUsers(address _userAddr, uint256 _layer) public view returns(address[] memory) {\\r\\n        return teamUsers[_userAddr][_layer];\\r\\n    }\\r\\n\\r\\n    function getUserDayPredicts(address _userAddr, uint256 _day) public view returns(PredictInfo[] memory) {\\r\\n        return userPredicts[_day][_userAddr];\\r\\n    }\\r\\n\\r\\n    function getDayPredictors(uint256 _day, uint256 _number) external view returns(address[] memory) {\\r\\n        return dayPredictors[_day][_number];\\r\\n    }\\r\\n\\r\\n    function getDayInfos(uint256 _day) external view returns(address[] memory newbies, uint256 deposits, uint256 pool){\\r\\n        return (dayNewbies[_day], dayDeposits[_day], dayPredictPool[_day]);\\r\\n    }\\r\\n\\r\\n    function getBalStatus(uint256 _bal) external view returns(bool) {\\r\\n        return balStatus[_bal];\\r\\n    }\\r\\n\\r\\n    function getUserCycleMax(address _userAddr, uint256 _cycle) external view returns(uint256){\\r\\n        return userCycleMax[_userAddr][_cycle];\\r\\n    }\\r\\n\\r\\n    function getUserInfos(address _userAddr) external view returns(UserInfo memory user, RewardInfo memory reward, OrderInfo[] memory orders, bool unfreeze) {\\r\\n        user = userInfo[_userAddr];\\r\\n        reward = rewardInfo[_userAddr];\\r\\n        orders = orderInfos[_userAddr];\\r\\n        unfreeze = isUnfreezedReward[_userAddr][freezedTimes];\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function getContractInfos() external view returns(address[3] memory infos0, uint256[10] memory infos1, bool freezing) {\\r\\n        infos0[0] = address(usdt);\\r\\n        infos0[1] = feeReceiver;\\r\\n        infos0[2] = defaultRefer;\\r\\n        infos1[0] = startTime;\\r\\n        infos1[1] = lastDistribute;\\r\\n        infos1[2] = totalUsers;\\r\\n        infos1[3] = totalDeposit;\\r\\n        infos1[4] = predictPool;\\r\\n        infos1[5] = totalPredictPool;\\r\\n        infos1[6] = totalWinners;\\r\\n        infos1[7] = freezedTimes;\\r\\n        infos1[8] = freezeTime[freezedTimes];\\r\\n        infos1[9] = unfreezeTime[freezedTimes];\\r\\n        freezing = isFreezing;\\r\\n    }\\r\\n\\r\\n    function claimGasfee() public nonReentrant{\\r\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\r\\n       uint256 Gaspoints=GasFeeInfo[msg.sender].remainigPoint;\\r\\n        require(Gaspoints\\u003e0,\\\"No gas points\\\");\\r\\n        require(Gaspoints\\u003e= 1e6,\\\"error\\\");\\r\\n        GasFeeInfo[msg.sender].remainigPoint=0;\\r\\n        usdt.transfer(msg.sender, Gaspoints);\\r\\n    }\\r\\n\\r\\n    function setGassPoints(uint256 _value) external onlyOwner nonReentrant{\\r\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\r\\n        Gasvalue=_value;\\r\\n    }\\r\\n\\r\\n    function checkuserstatus(address _addr) public view returns(bool isActive){\\r\\n        UserInfo storage user = userInfo[_addr];\\r\\n        if(getOrderLength(_addr)\\u003e0)\\r\\n        {\\r\\n        uint256 orderUnfreezeTime =getOrderUnfreezeTime(_addr, user.unfreezeIndex);\\r\\n        if(block.timestamp\\u003eorderUnfreezeTime+50 days)\\r\\n        {\\r\\n        isActive=false;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n        isActive=true;\\r\\n        }\\r\\n        }\\r\\n        else{\\r\\n            isActive=false;\\r\\n        }\\r\\n        \\r\\n    }\\r\\n\\r\\n    function withdrawSpecialClubRewards() external nonReentrant{\\r\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\r\\n        require( SpecialClubInfo[msg.sender].isEligible==true \\u0026\\u0026 SpecialClubInfo[msg.sender].SpecialClubUsersCount\\u003e=2,\\\"not eligible\\\");\\r\\n        require(block.timestamp\\u003e=SpecialClubInfo[msg.sender].unlockedTime,\\\"avail after 1 week\\\");\\r\\n        (uint256 specialClubReward,bool stat)= checkSpecialClub(msg.sender);\\r\\n        require(stat == true,\\\"error\\\");\\r\\n        uint256 activetime= getOrderUnfreezeTime(msg.sender,userInfo[msg.sender].unfreezeIndex);\\r\\n        require(activetime \\u003e block.timestamp , \\\"error1\\\");\\r\\n\\r\\n        address add =specialrefaddress[msg.sender][0];\\r\\n        address add1 =specialrefaddress[msg.sender][1];\\r\\n        uint256 activetime1= getOrderUnfreezeTime(add,userInfo[add].unfreezeIndex);\\r\\n        uint256 activetime2= getOrderUnfreezeTime(add1,userInfo[add1].unfreezeIndex);\\r\\n        require(activetime1 \\u003e block.timestamp , \\\"error2\\\");\\r\\n        require(activetime2 \\u003e block.timestamp , \\\"error3\\\");\\r\\n\\r\\n        GasFeeInfo[msg.sender].remainigPoint+=Gasvalue;\\r\\n        usdt.transfer(msg.sender,specialClubReward);\\r\\n        SpecialClubInfo[msg.sender].unlockedTime=block.timestamp+ timeStep;\\r\\n        SpecialClubInfo[msg.sender].getreward = specialClubReward;\\r\\n        }\\r\\n    \\r\\n    function checkSpecialClub (address _addr ) public view returns(uint256 specialClubReward,bool statue)\\r\\n    {    uint256 i;\\r\\n         uint256 time = (block.timestamp.sub(SpecialClubInfo[_addr].timeTogetIn))/SpecialDays;\\r\\n        if(time \\u003c= 18)\\r\\n        {\\r\\n            i =0;\\r\\n        }\\r\\n        else if(time \\u003e= 18 \\u0026\\u0026 time \\u003c= 36)\\r\\n        {\\r\\n            i=1;\\r\\n        }\\r\\n        else if(time \\u003e= 36 \\u0026\\u0026 time \\u003c= 54)\\r\\n        {\\r\\n            i=2;\\r\\n        }\\r\\n        else if(time \\u003e= 54 \\u0026\\u0026 time \\u003c= 72)\\r\\n        {\\r\\n            i=3;\\r\\n        }\\r\\n        else if(time \\u003e= 72 \\u0026\\u0026 time \\u003c= 90)\\r\\n        {\\r\\n            i=4;\\r\\n        }\\r\\n        else if(time \\u003e=90 \\u0026\\u0026 time \\u003c= 108)\\r\\n        {\\r\\n            i=5;\\r\\n        }        \\r\\n        else if(time \\u003e= 108 \\u0026\\u0026 time \\u003c= 126)\\r\\n        {\\r\\n            i=6;\\r\\n        }\\r\\n        if(time \\u003e 0 \\u0026\\u0026 block.timestamp \\u003e SpecialClubInfo[_addr].unlockedTime )\\r\\n        {\\r\\n        uint256 unlockedtime=SpecialClubInfo[_addr].timeTogetIn+(SpecialDays*time) ;\\r\\n        uint256 Duringtime=SpecialClubInfo[_addr].timeTogetIn+(SpecialDays*time)+timeStep ;\\r\\n        specialClubReward=SpecialClubWinner[i];\\r\\n        \\r\\n        if (block.timestamp\\u003e=unlockedtime \\u0026\\u0026 SpecialClubInfo[_addr].isEligible==true \\u0026\\u0026block.timestamp \\u003c= Duringtime)\\r\\n        {\\r\\n             statue = true;\\r\\n        }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function InActivewithdraw(address _inActiveuser) external onlyOwner nonReentrant {\\r\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\r\\n        RewardInfo storage userRewards = rewardInfo[_inActiveuser];\\r\\n        uint256 withdrawable;\\r\\n        uint256 incomeFee;\\r\\n        uint256 predictPoolFee;\\r\\n        uint256 split;\\r\\n        require(checkuserstatus(_inActiveuser)==false,\\\"Not Allowed!\\\");\\r\\n        \\r\\n        blacklistAddress[_inActiveuser]=true;\\r\\n        inActiveuserdeposit(_inActiveuser);\\r\\n        uint256 rewardsStatic = userRewards.statics.add(userRewards.invited).add(userRewards.bonusReleased).add(userRewards.predictWin);\\r\\n         incomeFee = rewardsStatic.mul(incomeFeePercents).div(baseDividend);\\r\\n       \\r\\n         predictPoolFee = rewardsStatic.mul(predictPoolPercents).div(baseDividend);\\r\\n        predictPool = predictPool.add(predictPoolFee);\\r\\n        totalPredictPool = totalPredictPool.add(predictPoolFee);\\r\\n        uint256 leftReward = rewardsStatic.add(userRewards.l5Released).add(incomeFee).sub(predictPoolFee);\\r\\n         withdrawable = leftReward;\\r\\n        uint256 capitals = userRewards.capitals;\\r\\n        userRewards.capitals = 0;\\r\\n        userRewards.statics = 0;\\r\\n        userRewards.invited = 0;\\r\\n        userRewards.bonusReleased = 0;\\r\\n        userRewards.l5Released = 0;\\r\\n        userRewards.predictWin = 0;\\r\\n        userInfo[_inActiveuser].startTime = 0;\\r\\n        userInfo[_inActiveuser].totalRevenue = 0;\\r\\n        rewardInfo[_inActiveuser].bonusFreezed = 0;\\r\\n        userRewards.split = 0;\\r\\n        userRewards.lastWithdaw = block.timestamp;\\r\\n        withdrawable = withdrawable.add(capitals);\\r\\n        usdt.transfer(owner, withdrawable);\\r\\n        if(!isFreezing)\\r\\n         _setFreezeReward();\\r\\n        emit Withdraw(owner, incomeFee, predictPoolFee, split, withdrawable);\\r\\n}\\r\\n\\r\\nfunction inActiveuserdeposit(address _inactiveUser) private {\\r\\n        UserInfo storage user = userInfo[_inactiveUser];\\r\\n        RewardInfo storage userRewards = rewardInfo[_inactiveUser];\\r\\n        uint256 curCycle = getCurCycle();\\r\\n        uint256 _types=0;\\r\\n        (uint256 userCurMin, uint256 userCurMax) = getUserCycleDepositable(_inactiveUser, curCycle);\\r\\n    uint256 _amount=userCurMax-1e6;\\r\\n    if(isFreezing \\u0026\\u0026 !isUnfreezedReward[_inactiveUser][freezedTimes]) \\r\\n        isUnfreezedReward[_inactiveUser][freezedTimes] = true;\\r\\n        \\r\\n        uint256 curDay = getCurDay();\\r\\n        dayDeposits[curDay] = dayDeposits[curDay].add(_amount);\\r\\n        totalDeposit = totalDeposit.add(_amount);\\r\\n        depositors.push(_inactiveUser);\\r\\n\\r\\n        if(user.level == 0){\\r\\n            if(curDay \\u003c unlimitDay) \\r\\n            require(dayNewbies[curDay].length \\u003c getMaxDayNewbies(curDay), \\\"reach max\\\");\\r\\n            dayNewbies[curDay].push(_inactiveUser);\\r\\n            totalUsers = totalUsers + 1;\\r\\n            user.startTime = block.timestamp;\\r\\n            if(_types == 0) {\\r\\n                userRewards.bonusFreezed = _amount.mul(bonusPercents).div(baseDividend);\\r\\n                user.totalRevenue = user.totalRevenue.add(userRewards.bonusFreezed);\\r\\n            }\\r\\n        }\\r\\n        _updateUplineReward(_inactiveUser, _amount);\\r\\n        _unfreezeCapitalOrReward(_inactiveUser, _amount, _types);\\r\\n        bool isMaxFreezing = _addNewOrder(_inactiveUser, _amount, _types, user.startTime, user.isMaxFreezing);\\r\\n        user.isMaxFreezing = isMaxFreezing;\\r\\n        _updateUserMax(_inactiveUser, _amount, userCurMax, curCycle);\\r\\n        _updateLevel(_inactiveUser);\\r\\n        if(isFreezing) _setFreezeReward();\\r\\n}\\r\\n\\r\\n// _USDTADDR:\\r\\n// 0xc2132D05D31c914a87C6611C10748AEb04B58e8F\\r\\n// _DEFAULTREFER:\\r\\n// 0xACcBFa9D5AAe6CFe5EEda11C5B28d0aAEA96e8d5\\r\\n// _FEERECEIVER:\\r\\n// 0x896c7dE4F583704669393752B2204baB5EB84292\\r\\n\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        uint256 c = a + b;\\r\\n        if (c \\u003c a) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b \\u003e a) return (false, 0);\\r\\n        return (true, a - b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) return (true, 0);\\r\\n        uint256 c = a * b;\\r\\n        if (c / a != b) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a / b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a % b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) return 0;\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultRefer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"types\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFreezing\",\"type\":\"bool\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"DistributePredictPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Predict\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subBal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomeFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdraw\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Additionaldays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"GasFeeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remainigPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_inActiveuser\",\"type\":\"address\"}],\"name\":\"InActivewithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"SpecialClubInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"SpecialClubUsersCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEligible\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"timeTogetIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockedTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"getreward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklistAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkSpecialClub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"specialClubReward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"statue\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkuserstatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimGasfee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePredictPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bal\",\"type\":\"uint256\"}],\"name\":\"getBalStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractInfos\",\"outputs\":[{\"internalType\":\"address[3]\",\"name\":\"infos0\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[10]\",\"name\":\"infos1\",\"type\":\"uint256[10]\"},{\"internalType\":\"bool\",\"name\":\"freezing\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurMaxDepositable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getDayInfos\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"newbies\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getDayPredictors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"getLatestDepositors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"latestDepositors\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getMaxDayNewbies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getOrderUnfreezeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderUnfreezeTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getPredictWinners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"otherTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTeam\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getUserCycleDepositable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleMax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getUserCycleMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getUserDayPredicts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct Earnpassiveclub.PredictInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getUserInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreezeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isMaxFreezing\",\"type\":\"bool\"}],\"internalType\":\"struct Earnpassiveclub.UserInfo\",\"name\":\"user\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"capitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusReleased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l5Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l5Released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictWin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdaw\",\"type\":\"uint256\"}],\"internalType\":\"struct Earnpassiveclub.RewardInfo\",\"name\":\"reward\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"}],\"internalType\":\"struct Earnpassiveclub.OrderInfo[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"unfreeze\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"predict\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"setAdditionaldays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setGassPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawSpecialClubRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Earnpassiveclub", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f000000000000000000000000accbfa9d5aae6cfe5eeda11c5b28d0aaea96e8d5000000000000000000000000896c7de4f583704669393752b2204bab5eb842920000000000000000000000000000000000000000000000000000000064fc2600", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://72f834d9309676ad1717b0e88a8ac63d4cb61d607ef719949ca126e740bfd301"}