{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NWT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.9.0;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function name() external view returns (string memory);\\n\\n    function getOwner() external view returns (address);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address _owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ninterface IFactoryV2 {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address lpPair,\\n        uint\\n    );\\n\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address lpPair);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address lpPair);\\n}\\n\\ninterface IV2Pair {\\n    function factory() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function sync() external;\\n}\\n\\ninterface IRouter01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function getAmountsIn(\\n        uint amountOut,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IRouter02 is IRouter01 {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n}\\n\\ncontract TokenForTesting is IERC20 {\\n    mapping(address => uint256) public _refBalance;\\n    mapping(address => uint256) public _tokenBalance;\\n    mapping(address => bool) public lpPairs;\\n    mapping(address => mapping(address => uint256)) public _allowances;\\n    mapping(address => bool) public _liquidityHolders;\\n    mapping(address => bool) public _isExcludedFromProtection;\\n    mapping(address => bool) public _isExcludedFromFees;\\n    mapping(address => bool) public _isExcludedFromReflection;\\n    mapping(address => bool) public _isExcludedFromLimits;\\n    mapping(address => bool) public _isBlacklisted;\\n    address[] public _refExclusionList;\\n    mapping(address => bool) public presaleAddresses;\\n\\n    string private constant _name = \\\"TestToken_7\\\";\\n    string private constant _symbol = \\\"TST_7\\\";\\n    uint8 private constant _decimals = 9;\\n    uint256 private constant _tokenTotalSupply = 900_000_000 * 10 ** _decimals;\\n    uint256 private constant MAX = ~uint256(0);\\n    uint256 private _refTotal = (MAX - (MAX % _tokenTotalSupply));\\n\\n    struct Fees {\\n        uint16 buyFee;\\n        uint16 sellFee;\\n        uint16 transferFee;\\n    }\\n\\n    struct Ratios {\\n        uint16 reflection;\\n        uint16 liquidity;\\n        uint16 marketing;\\n        uint16 development;\\n        uint16 charity;\\n        uint16 buyback;\\n        uint16 totalSwap;\\n    }\\n\\n    Fees public _taxRates = Fees({buyFee: 400, sellFee: 500, transferFee: 0});\\n\\n    Ratios public _ratios =\\n        Ratios({\\n            reflection: 90 * 1, // 10%\\n            liquidity: 90 * 2, // 20%\\n            marketing: 90 * 2, // 20%\\n            development: 90 * 1, // 10%\\n            charity: 90 * 2, // 20%\\n            buyback: 90 * 2, // 20%\\n            totalSwap: 90 * (2 + 2 + 1 + 2 + 2)\\n        });\\n\\n    // maximum limit of taxes\\n    uint256 public constant maxBuyTaxes = 2000; // 20%\\n    uint256 public constant maxSellTaxes = 2000; // 20%\\n    uint256 public constant maxTransferTaxes = 2000; // 20%\\n    uint256 constant masterTaxDivisor = 10000;\\n\\n    bool public taxesAreLocked;\\n\\n    IRouter02 public dexRouter;\\n    address public lpPair;\\n    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\\n\\n    struct TaxWallets {\\n        address payable marketing;\\n        address payable development;\\n        address payable charity;\\n        address payable buyback;\\n    }\\n\\n    TaxWallets public _taxWallets =\\n        TaxWallets({\\n            marketing: payable(0xFa9558299aF1Cc79D2b5a4cBF2fdB688A2F98950),\\n            development: payable(0xF7064147826279bCcD2bf34ffdba59A240AAeAae),\\n            charity: payable(0x927ce8dD4a3Fc717aF61624C7B959710F8b8C791),\\n            buyback: payable(0x2C81d3F1881f34E3aA442c23E2e1142c5293575a)\\n        });\\n\\n    bool inSwap;\\n\\n    // is swapping ability enabled in contract?\\n    bool public contractSwapEnabled = false;\\n    //\\n    uint256 public swapThreshold;\\n    //\\n    uint256 public swapAmount;\\n\\n    // should enable price impacted swap ?\\n    bool public piContractSwapsEnabled;\\n    // price impact swap percent\\n    uint256 public piSwapPercent = 10;\\n\\n    uint256 private _maxTxAmount = (_tokenTotalSupply * 2) / 100; // 2%\\n    uint256 private _maxWalletSize = (_tokenTotalSupply * 2) / 100; // 2%\\n\\n    // is trading enabled?\\n    bool public tradingEnabled = false;\\n    // is liquidity added?\\n    bool public _hasLiqBeenAdded = false;\\n\\n    event ContractSwapEnabledUpdated(bool enabled);\\n    event AutoLiquify(uint256 amountCurrency, uint256 amountTokens);\\n\\n    modifier inSwapFlag() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    constructor() payable {\\n        _owner = msg.sender;\\n\\n        _refBalance[_owner] = _refTotal;\\n        emit Transfer(address(0), _owner, _tokenTotalSupply);\\n\\n        if (block.chainid == 137) {\\n            dexRouter = IRouter02(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);\\n        } else if (block.chainid == 80001) {\\n            dexRouter = IRouter02(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);\\n        } else if (block.chainid == 56) {\\n            dexRouter = IRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        } else if (block.chainid == 97) {\\n            dexRouter = IRouter02(0xD99D1c33F9fC3444f8101754aBC46c52416550D1);\\n        } else if (\\n            block.chainid == 1 ||\\n            block.chainid == 3 ||\\n            block.chainid == 4 ||\\n            block.chainid == 5\\n        ) {\\n            dexRouter = IRouter02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n            //Ropstein DAI 0xaD6D458402F60fD3Bd25163575031ACDce07538D\\n        } else if (block.chainid == 43114) {\\n            dexRouter = IRouter02(0x60aE616a2155Ee3d9A68541Ba4544862310933d4);\\n        } else if (block.chainid == 250) {\\n            dexRouter = IRouter02(0xF491e7B69E4244ad4002BC14e878a34207E38c29);\\n        } else {\\n            revert(\\\"Unsupported network\\\");\\n        }\\n\\n        _approve(_owner, address(dexRouter), type(uint256).max);\\n        _approve(address(this), address(dexRouter), type(uint256).max);\\n\\n        _isExcludedFromFees[_owner] = true;\\n        _isExcludedFromFees[address(this)] = true;\\n        _isExcludedFromFees[DEAD] = true;\\n        _liquidityHolders[_owner] = true;\\n    }\\n\\n    receive() external payable {}\\n\\n    address private _owner;\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Caller is not owner.\\\");\\n        _;\\n    }\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    function transferOwner(address newOwner) external onlyOwner {\\n        require(\\n            newOwner != address(0) && newOwner != DEAD,\\n            \\\"Can not transfer ownership to these addresses\\\"\\n        );\\n        setExcludedFromFees(_owner, false);\\n        setExcludedFromFees(newOwner, true);\\n\\n        if (balanceOf(_owner) > 0) {\\n            finalizeTransfer(\\n                _owner,\\n                newOwner,\\n                balanceOf(_owner),\\n                false,\\n                false,\\n                true\\n            );\\n        }\\n\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    function totalSupply() external pure override returns (uint256) {\\n        if (_tokenTotalSupply == 0) {\\n            revert();\\n        }\\n        return _tokenTotalSupply;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        if (_tokenTotalSupply == 0) {\\n            revert();\\n        }\\n        return _decimals;\\n    }\\n\\n    function symbol() external pure override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function name() external pure override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function getOwner() external view override returns (address) {\\n        return _owner;\\n    }\\n\\n    function allowance(\\n        address holder,\\n        address spender\\n    ) external view override returns (uint256) {\\n        return _allowances[holder][spender];\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        if (_isExcludedFromReflection[account]) return _tokenBalance[account];\\n        return tokenFromReflection(_refBalance[account]);\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function _approve(\\n        address sender,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(sender != address(0), \\\"ERC20: Zero Address\\\");\\n        require(spender != address(0), \\\"ERC20: Zero Address\\\");\\n\\n        _allowances[sender][spender] = amount;\\n        emit Approval(sender, spender, amount);\\n    }\\n\\n    function approveContractContingency() external onlyOwner returns (bool) {\\n        _approve(address(this), address(dexRouter), type(uint256).max);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\\n            _allowances[sender][msg.sender] -= amount;\\n        }\\n\\n        return _transfer(sender, recipient, amount);\\n    }\\n\\n    function setDexRouter(address newRouter) external onlyOwner {\\n        IRouter02 _newRouter = IRouter02(newRouter);\\n        address get_pair = IFactoryV2(_newRouter.factory()).getPair(\\n            address(this),\\n            _newRouter.WETH()\\n        );\\n        if (get_pair == address(0)) {\\n            lpPair = IFactoryV2(_newRouter.factory()).createPair(\\n                address(this),\\n                _newRouter.WETH()\\n            );\\n        } else {\\n            lpPair = get_pair;\\n        }\\n        dexRouter = _newRouter;\\n        lpPairs[lpPair] = true;\\n\\n        _approve(address(this), address(dexRouter), type(uint256).max);\\n    }\\n\\n    function setLpPair(address pair, bool enabled) external onlyOwner {\\n        if (!enabled) {\\n            lpPairs[pair] = false;\\n        } else {\\n            lpPairs[pair] = true;\\n        }\\n    }\\n\\n    function isExcludedFromFees(address account) external view returns (bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n    function isExcludedFromProtection(\\n        address account\\n    ) external view returns (bool) {\\n        return _isExcludedFromProtection[account];\\n    }\\n\\n    function isExcludedFromLimits(\\n        address account\\n    ) external view returns (bool) {\\n        return _isExcludedFromLimits[account];\\n    }\\n\\n    function setExcludedFromFees(\\n        address account,\\n        bool enabled\\n    ) public onlyOwner {\\n        _isExcludedFromFees[account] = enabled;\\n    }\\n\\n    function setExcludedFromProtection(\\n        address account,\\n        bool enabled\\n    ) external onlyOwner {\\n        _isExcludedFromProtection[account] = enabled;\\n    }\\n\\n    function setExcludedFromLimits(\\n        address account,\\n        bool enabled\\n    ) public onlyOwner {\\n        _isExcludedFromLimits[account] = enabled;\\n    }\\n\\n    function getCirculatingSupply() public view returns (uint256) {\\n        return (_tokenTotalSupply - (balanceOf(DEAD) + balanceOf(address(0))));\\n    }\\n\\n    function setBlacklistEnabled(\\n        address account,\\n        bool enabled\\n    ) external onlyOwner {\\n        _isBlacklisted[account] = enabled;\\n    }\\n\\n    function setBlacklistEnabledMultiple(\\n        address[] memory accounts,\\n        bool enabled\\n    ) external onlyOwner {\\n        for (uint16 i = 0; i < accounts.length; i++) {\\n            _isBlacklisted[accounts[i]] = enabled;\\n        }\\n    }\\n\\n    function isBlacklisted(address account) external view returns (bool) {\\n        return _isBlacklisted[account];\\n    }\\n\\n    function lockTaxes() external onlyOwner {\\n        taxesAreLocked = true;\\n    }\\n\\n    function setTaxes(\\n        uint16 buyFee,\\n        uint16 sellFee,\\n        uint16 transferFee\\n    ) external onlyOwner {\\n        require(!taxesAreLocked, \\\"Taxes are locked.\\\");\\n        require(\\n            buyFee <= maxBuyTaxes &&\\n                sellFee <= maxSellTaxes &&\\n                transferFee <= maxTransferTaxes,\\n            \\\"Cannot exceed maximums.\\\"\\n        );\\n        _taxRates.buyFee = buyFee;\\n        _taxRates.sellFee = sellFee;\\n        _taxRates.transferFee = transferFee;\\n    }\\n\\n    function setRatios(\\n        uint16 reflection,\\n        uint16 liquidity,\\n        uint16 charity,\\n        uint16 development,\\n        uint16 marketing,\\n        uint16 buyback\\n    ) external onlyOwner {\\n        _ratios.reflection = reflection;\\n        _ratios.liquidity = liquidity;\\n        _ratios.marketing = marketing;\\n        _ratios.charity = charity;\\n        _ratios.development = development;\\n        _ratios.buyback = buyback;\\n        _ratios.totalSwap =\\n            liquidity +\\n            marketing +\\n            charity +\\n            development +\\n            buyback;\\n        uint256 total = _taxRates.buyFee + _taxRates.sellFee;\\n        require(\\n            _ratios.totalSwap + _ratios.reflection <= total,\\n            \\\"Cannot exceed sum of buy and sell fees.\\\"\\n        );\\n    }\\n\\n    function setWallets(\\n        address payable marketing,\\n        address payable charity,\\n        address payable development,\\n        address payable buyback\\n    ) external onlyOwner {\\n        require(\\n            marketing != address(0) &&\\n                development != address(0) &&\\n                charity != address(0) &&\\n                buyback != address(0),\\n            \\\"Cannot be zero address.\\\"\\n        );\\n        _taxWallets.marketing = payable(marketing);\\n        _taxWallets.development = payable(development);\\n        _taxWallets.charity = payable(charity);\\n        _taxWallets.buyback = payable(buyback);\\n    }\\n\\n    function setMaxTxPercent(\\n        uint256 percent,\\n        uint256 divisor\\n    ) external onlyOwner {\\n        require(\\n            (_tokenTotalSupply * percent) / divisor >=\\n                ((_tokenTotalSupply * 5) / 1000),\\n            \\\"Max Transaction amt must be above 0.5% of total supply.\\\"\\n        );\\n        _maxTxAmount = (_tokenTotalSupply * percent) / divisor;\\n    }\\n\\n    function setMaxWalletSize(\\n        uint256 percent,\\n        uint256 divisor\\n    ) external onlyOwner {\\n        require(\\n            (_tokenTotalSupply * percent) / divisor >=\\n                (_tokenTotalSupply / 100),\\n            \\\"Max Wallet amt must be above 1% of total supply.\\\"\\n        );\\n        _maxWalletSize = (_tokenTotalSupply * percent) / divisor;\\n    }\\n\\n    function getMaxTX() external view returns (uint256) {\\n        return _maxTxAmount / (10 ** _decimals);\\n    }\\n\\n    function getMaxWallet() external view returns (uint256) {\\n        return _maxWalletSize / (10 ** _decimals);\\n    }\\n\\n    function getTokenAmountAtPriceImpact(\\n        uint256 priceImpactInHundreds\\n    ) external view returns (uint256) {\\n        return ((balanceOf(lpPair) * priceImpactInHundreds) / masterTaxDivisor);\\n    }\\n\\n    function setSwapSettings(\\n        uint256 thresholdPercent,\\n        uint256 thresholdDivisor,\\n        uint256 amountPercent,\\n        uint256 amountDivisor\\n    ) external onlyOwner {\\n        swapThreshold =\\n            (_tokenTotalSupply * thresholdPercent) /\\n            thresholdDivisor;\\n        swapAmount = (_tokenTotalSupply * amountPercent) / amountDivisor;\\n        require(\\n            swapThreshold <= swapAmount,\\n            \\\"Threshold cannot be above amount.\\\"\\n        );\\n        require(\\n            swapAmount <= (balanceOf(lpPair) * 150) / masterTaxDivisor,\\n            \\\"Cannot be above 1.5% of current PI.\\\"\\n        );\\n        require(\\n            swapAmount >= _tokenTotalSupply / 1_000_000,\\n            \\\"Cannot be lower than 0.00001% of total supply.\\\"\\n        );\\n        require(\\n            swapThreshold >= _tokenTotalSupply / 1_000_000,\\n            \\\"Cannot be lower than 0.00001% of total supply.\\\"\\n        );\\n    }\\n\\n    function setPriceImpactSwapAmount(\\n        uint256 priceImpactSwapPercent\\n    ) external onlyOwner {\\n        require(priceImpactSwapPercent <= 150, \\\"Cannot set above 1.5%.\\\");\\n        piSwapPercent = priceImpactSwapPercent;\\n    }\\n\\n    function setContractSwapEnabled(\\n        bool swapEnabled,\\n        bool priceImpactSwapEnabled\\n    ) external onlyOwner {\\n        contractSwapEnabled = swapEnabled;\\n        piContractSwapsEnabled = priceImpactSwapEnabled;\\n        emit ContractSwapEnabledUpdated(swapEnabled);\\n    }\\n\\n    function excludePresaleAddress(address presale) external onlyOwner {\\n        require(presale != address(this) && lpPair != presale, \\\"Just don't.\\\");\\n\\n        _liquidityHolders[presale] = true;\\n        presaleAddresses[presale] = true;\\n        setExcludedFromFees(presale, true);\\n        setExcludedFromReflection(presale, true);\\n        setExcludedFromLimits(presale, true);\\n    }\\n\\n    function _hasLimits(address from, address to) internal view returns (bool) {\\n        return\\n            from != _owner &&\\n            to != _owner &&\\n            tx.origin != _owner &&\\n            !_liquidityHolders[to] &&\\n            !_liquidityHolders[from] &&\\n            to != DEAD &&\\n            to != address(0) &&\\n            from != address(this);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(\\n            _isBlacklisted[from] == false,\\n            \\\"ERC20: transfer from blacklisted address\\\"\\n        );\\n        require(\\n            _isBlacklisted[to] == false,\\n            \\\"ERC20: transfer to blacklisted address\\\"\\n        );\\n\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n        bool buy = false;\\n        bool sell = false;\\n        bool other = false;\\n        if (lpPairs[from]) {\\n            buy = true;\\n        } else if (lpPairs[to]) {\\n            sell = true;\\n        } else {\\n            other = true;\\n        }\\n        if (_hasLimits(from, to)) {\\n            if (!tradingEnabled) {\\n                revert(\\\"Trading not yet enabled!\\\");\\n            }\\n            if (buy || sell) {\\n                if (\\n                    !_isExcludedFromLimits[from] && !_isExcludedFromLimits[to]\\n                ) {\\n                    require(\\n                        amount <= _maxTxAmount,\\n                        \\\"Transfer amount exceeds the maxTxAmount.\\\"\\n                    );\\n                }\\n            }\\n            if (to != address(dexRouter) && !sell) {\\n                if (!_isExcludedFromLimits[to] && !presaleAddresses[from]) {\\n                    require(\\n                        balanceOf(to) + amount <= _maxWalletSize,\\n                        \\\"Transfer amount exceeds the maxWalletSize.\\\"\\n                    );\\n                }\\n            }\\n        }\\n\\n        if (sell) {\\n            if (!inSwap) {\\n                if (\\n                    contractSwapEnabled &&\\n                    !presaleAddresses[to] &&\\n                    !presaleAddresses[from]\\n                ) {\\n                    uint256 contractTokenBalance = balanceOf(address(this));\\n                    if (contractTokenBalance >= swapThreshold) {\\n                        uint256 swapAmt = swapAmount;\\n                        if (piContractSwapsEnabled) {\\n                            swapAmt =\\n                                (balanceOf(lpPair) * piSwapPercent) /\\n                                masterTaxDivisor;\\n                        }\\n                        if (contractTokenBalance >= swapAmt) {\\n                            contractTokenBalance = swapAmt;\\n                        }\\n                        contractSwap(contractTokenBalance);\\n                    }\\n                }\\n            }\\n        }\\n        return finalizeTransfer(from, to, amount, buy, sell, other);\\n    }\\n\\n    function contractSwap(uint256 contractTokenBalance) internal inSwapFlag {\\n        Ratios memory ratios = _ratios;\\n        if (ratios.totalSwap == 0) {\\n            return;\\n        }\\n\\n        if (\\n            _allowances[address(this)][address(dexRouter)] != type(uint256).max\\n        ) {\\n            _allowances[address(this)][address(dexRouter)] = type(uint256).max;\\n        }\\n\\n        uint256 toLiquify = ((contractTokenBalance * ratios.liquidity) /\\n            ratios.totalSwap) / 2;\\n        uint256 swapAmt = contractTokenBalance - toLiquify;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = dexRouter.WETH();\\n\\n        try\\n            dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                swapAmt,\\n                0,\\n                path,\\n                address(this),\\n                block.timestamp\\n            )\\n        {} catch {\\n            return;\\n        }\\n\\n        uint256 amtBalance = address(this).balance;\\n        uint256 liquidityBalance = (amtBalance * toLiquify) / swapAmt;\\n\\n        if (toLiquify > 0) {\\n            try\\n                dexRouter.addLiquidityETH{value: liquidityBalance}(\\n                    address(this),\\n                    toLiquify,\\n                    0,\\n                    0,\\n                    DEAD,\\n                    block.timestamp\\n                )\\n            {\\n                emit AutoLiquify(liquidityBalance, toLiquify);\\n            } catch {\\n                return;\\n            }\\n        } // totalSwap = liquidity + dev + mar + char + buyback\\n\\n        amtBalance -= liquidityBalance;\\n        ratios.totalSwap -= ratios.liquidity;\\n        bool success;\\n        uint256 developmentBalance = (amtBalance * ratios.development) /\\n            ratios.totalSwap;\\n        uint256 marketingBalance = (amtBalance * ratios.marketing) /\\n            ratios.totalSwap;\\n        uint256 charityBalance = (amtBalance * ratios.charity) /\\n            ratios.totalSwap;\\n        uint256 buybackBalance = amtBalance -\\n            developmentBalance -\\n            marketingBalance -\\n            charityBalance;\\n        if (ratios.development > 0) {\\n            (success, ) = _taxWallets.development.call{\\n                value: developmentBalance,\\n                gas: 55000\\n            }(\\\"\\\");\\n        }\\n        if (ratios.marketing > 0) {\\n            (success, ) = _taxWallets.marketing.call{\\n                value: marketingBalance,\\n                gas: 55000\\n            }(\\\"\\\");\\n        }\\n        if (ratios.charity > 0) {\\n            (success, ) = _taxWallets.charity.call{\\n                value: charityBalance,\\n                gas: 55000\\n            }(\\\"\\\");\\n        }\\n        if (ratios.buyback > 0) {\\n            (success, ) = _taxWallets.buyback.call{\\n                value: buybackBalance,\\n                gas: 55000\\n            }(\\\"\\\");\\n        }\\n    }\\n\\n    function _checkLiquidityAdd(address from, address to) internal {\\n        require(!_hasLiqBeenAdded, \\\"Liquidity already added and marked.\\\");\\n        if (!_hasLimits(from, to) && to == lpPair) {\\n            _liquidityHolders[from] = true;\\n            _isExcludedFromFees[from] = true;\\n            _hasLiqBeenAdded = true;\\n            contractSwapEnabled = true;\\n            emit ContractSwapEnabledUpdated(true);\\n        }\\n    }\\n\\n    function enableTrading() public onlyOwner {\\n        require(!tradingEnabled, \\\"Trading already enabled!\\\");\\n        require(_hasLiqBeenAdded, \\\"Liquidity must be added.\\\");\\n        tradingEnabled = true;\\n        swapThreshold = (balanceOf(lpPair) * 10) / 10000;\\n        swapAmount = (balanceOf(lpPair) * 30) / 10000;\\n    }\\n\\n    function batchSender(\\n        address[] memory accounts,\\n        uint256[] memory amounts\\n    ) external onlyOwner {\\n        require(accounts.length == amounts.length, \\\"Lengths do not match.\\\");\\n        for (uint16 i = 0; i < accounts.length; i++) {\\n            require(\\n                balanceOf(msg.sender) >= amounts[i] * 10 ** _decimals,\\n                \\\"Not enough tokens.\\\"\\n            );\\n            finalizeTransfer(\\n                msg.sender,\\n                accounts[i],\\n                amounts[i] * 10 ** _decimals,\\n                false,\\n                false,\\n                true\\n            );\\n        }\\n    }\\n\\n    function isExcludedFromReflection(\\n        address account\\n    ) public view returns (bool) {\\n        return _isExcludedFromReflection[account];\\n    }\\n\\n    function setExcludedFromReflection(\\n        address account,\\n        bool enabled\\n    ) public onlyOwner {\\n        if (enabled) {\\n            if (_isExcludedFromReflection[account]) {\\n                return; // \\\"Account is already excluded.\\\"\\n            }\\n            if (_refBalance[account] > 0) {\\n                _tokenBalance[account] = tokenFromReflection(\\n                    _refBalance[account]\\n                );\\n            }\\n            _isExcludedFromReflection[account] = true;\\n            if (account != lpPair) {\\n                _refExclusionList.push(account);\\n            }\\n        } else if (!enabled) {\\n            if (!_isExcludedFromReflection[account]) {\\n                return; // \\\"Account is already excluded.\\\"\\n            }\\n            if (account == lpPair) {\\n                _refBalance[account] = _tokenBalance[account] * _getRate();\\n                _tokenBalance[account] = 0;\\n                _isExcludedFromReflection[account] = false;\\n            } else if (_refExclusionList.length == 1) {\\n                _refBalance[account] = _tokenBalance[account] * _getRate();\\n                _tokenBalance[account] = 0;\\n                _isExcludedFromReflection[account] = false;\\n                _refExclusionList.pop();\\n            } else {\\n                for (uint256 i = 0; i < _refExclusionList.length; i++) {\\n                    if (_refExclusionList[i] == account) {\\n                        _refExclusionList[i] = _refExclusionList[\\n                            _refExclusionList.length - 1\\n                        ];\\n                        _refBalance[account] =\\n                            _tokenBalance[account] *\\n                            _getRate();\\n                        _tokenBalance[account] = 0;\\n                        _isExcludedFromReflection[account] = false;\\n                        _refExclusionList.pop();\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function tokenFromReflection(\\n        uint256 rAmount\\n    ) public view returns (uint256) {\\n        require(\\n            rAmount <= _refTotal,\\n            \\\"Amount must be less than total reflections\\\"\\n        );\\n        uint256 currentRate = _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n    struct ExtraValues {\\n        uint256 tokenTransferAmount;\\n        uint256 tokenFee;\\n        uint256 tokenSwap;\\n        uint256 refTransferAmount;\\n        uint256 refAmount;\\n        uint256 refFee;\\n        uint256 currentRate;\\n    }\\n\\n    function finalizeTransfer(\\n        address from,\\n        address to,\\n        uint256 tAmount,\\n        bool buy,\\n        bool sell,\\n        bool other\\n    ) internal returns (bool) {\\n        bool takeFee = true;\\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\n            takeFee = false;\\n        }\\n\\n        ExtraValues memory values = takeTaxes(\\n            from,\\n            tAmount,\\n            takeFee,\\n            buy,\\n            sell\\n        );\\n\\n        _refBalance[from] = _refBalance[from] - values.refAmount;\\n        _refBalance[to] = _refBalance[to] + values.refTransferAmount;\\n\\n        if (_isExcludedFromReflection[from]) {\\n            _tokenBalance[from] = _tokenBalance[from] - tAmount;\\n        }\\n        if (_isExcludedFromReflection[to]) {\\n            _tokenBalance[to] = _tokenBalance[to] + values.tokenTransferAmount;\\n        }\\n\\n        if (values.refFee > 0 || values.tokenFee > 0) {\\n            _refTotal -= values.refFee;\\n        }\\n        emit Transfer(from, to, values.tokenTransferAmount);\\n        if (!_hasLiqBeenAdded) {\\n            _checkLiquidityAdd(from, to);\\n            if (\\n                !_hasLiqBeenAdded &&\\n                _hasLimits(from, to) &&\\n                !_isExcludedFromProtection[from] &&\\n                !_isExcludedFromProtection[to] &&\\n                !other\\n            ) {\\n                // can not\\n                revert(\\\"Pre-liquidity transfer protection.\\\");\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function takeTaxes(\\n        address from,\\n        uint256 tAmount,\\n        bool takeFee,\\n        bool buy,\\n        bool sell\\n    ) internal returns (ExtraValues memory) {\\n        ExtraValues memory values;\\n        Ratios memory ratios = _ratios;\\n        values.currentRate = _getRate();\\n\\n        values.refAmount = tAmount * values.currentRate;\\n\\n        uint256 total = ratios.totalSwap + ratios.reflection;\\n        if (total == 0) {\\n            takeFee = false;\\n        }\\n\\n        if (takeFee) {\\n            uint256 currentFee;\\n\\n            if (buy) {\\n                currentFee = _taxRates.buyFee;\\n            } else if (sell) {\\n                currentFee = _taxRates.sellFee;\\n            } else {\\n                currentFee = _taxRates.transferFee;\\n            }\\n\\n            uint256 feeAmount = (tAmount * currentFee) / masterTaxDivisor;\\n            values.tokenFee = (feeAmount * ratios.reflection) / total; // reflection fee\\n            values.tokenSwap = feeAmount - values.tokenFee;\\n            values.tokenTransferAmount =\\n                tAmount -\\n                (values.tokenFee + values.tokenSwap);\\n\\n            values.refFee = values.tokenFee * values.currentRate;\\n        } else {\\n            values.tokenTransferAmount = tAmount;\\n        }\\n\\n        if (values.tokenSwap > 0) {\\n            _refBalance[address(this)] += values.tokenSwap * values.currentRate;\\n            if (_isExcludedFromReflection[address(this)]) {\\n                _tokenBalance[address(this)] += values.tokenSwap;\\n            }\\n            emit Transfer(from, address(this), values.tokenSwap);\\n        }\\n\\n        values.refTransferAmount =\\n            values.refAmount -\\n            (values.refFee + (values.tokenSwap * values.currentRate));\\n        return values;\\n    }\\n\\n    function _getRate() internal view returns (uint256) {\\n        uint256 rTotal = _refTotal;\\n        uint256 tTotal = _tokenTotalSupply;\\n        uint256 rSupply = rTotal;\\n        uint256 tSupply = tTotal;\\n        if (_isExcludedFromReflection[lpPair]) {\\n            uint256 rLPOwned = _refBalance[lpPair];\\n            uint256 tLPOwned = _tokenBalance[lpPair];\\n            if (rLPOwned > rSupply || tLPOwned > tSupply)\\n                return rTotal / tTotal;\\n            rSupply -= rLPOwned;\\n            tSupply -= tLPOwned;\\n        }\\n        if (_refExclusionList.length > 0) {\\n            for (uint8 i = 0; i < _refExclusionList.length; i++) {\\n                uint256 rOwned = _refBalance[_refExclusionList[i]];\\n                uint256 tOwned = _tokenBalance[_refExclusionList[i]];\\n                if (rOwned > rSupply || tOwned > tSupply)\\n                    return rTotal / tTotal;\\n                rSupply = rSupply - rOwned;\\n                tSupply = tSupply - tOwned;\\n            }\\n        }\\n        if (rSupply < rTotal / tTotal) return rTotal / tTotal;\\n        return rSupply / tSupply;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountCurrency\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ContractSwapEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEAD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_hasLiqBeenAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromProtection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromReflection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_liquidityHolders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ratios\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"reflection\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidity\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"marketing\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"development\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"charity\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"buyback\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"totalSwap\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_refBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_refExclusionList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxRates\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"buyFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"sellFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"transferFee\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxWallets\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"marketing\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"development\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"charity\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"buyback\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approveContractContingency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractSwapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"presale\",\"type\":\"address\"}],\"name\":\"excludePresaleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxTX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceImpactInHundreds\",\"type\":\"uint256\"}],\"name\":\"getTokenAmountAtPriceImpact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromProtection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReflection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lpPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransferTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piContractSwapsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piSwapPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"presaleAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setBlacklistEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setBlacklistEnabledMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"swapEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"priceImpactSwapEnabled\",\"type\":\"bool\"}],\"name\":\"setContractSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setDexRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setExcludedFromLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setExcludedFromProtection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setExcludedFromReflection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setLpPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"setMaxTxPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceImpactSwapPercent\",\"type\":\"uint256\"}],\"name\":\"setPriceImpactSwapAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"reflection\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidity\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"charity\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"development\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"marketing\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"buyback\",\"type\":\"uint16\"}],\"name\":\"setRatios\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"thresholdPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"thresholdDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountDivisor\",\"type\":\"uint256\"}],\"name\":\"setSwapSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"buyFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"sellFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"transferFee\",\"type\":\"uint16\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"marketing\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"charity\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"development\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"buyback\",\"type\":\"address\"}],\"name\":\"setWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxesAreLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokenForTesting", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}