{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/upgradability/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.6;\\r\\n\\r\\n/**\\r\\n * Utility library of inline functions on addresses\\r\\n *\\r\\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\\r\\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\\r\\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\\r\\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\\r\\n */\\r\\nlibrary OpenZeppelinUpgradesAddress {\\r\\n  /**\\r\\n   * @notice Returns whether the target address is a contract\\r\\n   * @dev This function will return false if invoked during the constructor of a contract,\\r\\n   * as the code is not actually created until after the constructor finishes.\\r\\n   * @param account address of the account to check\\r\\n   * @return whether the target address is a contract\\r\\n   */\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    uint256 size;\\r\\n    // XXX Currently there is no better way to check if there is a contract in an address\\r\\n    // than to check the size of the code at that address.\\r\\n    // See https://ethereum.stackexchange.com/a/14016/36603\\r\\n    // for more details about how this works.\\r\\n    // TODO Check this again before the Serenity release, because all addresses will be\\r\\n    // contracts then.\\r\\n    assembly {\\r\\n      size := extcodesize(account)\\r\\n    }\\r\\n    return size > 0;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/upgradability/BaseUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nimport \\\"./Proxy.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./HasLogic.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title BaseUpgradeabilityProxy\\r\\n * @dev This contract implements a proxy that allows to change the\\r\\n * implementation address to which it will delegate.\\r\\n * Such a change is called an implementation upgrade.\\r\\n */\\r\\ncontract BaseUpgradeabilityProxy is Proxy {\\r\\n  /**\\r\\n   * @dev Emitted when the implementation is upgraded.\\r\\n   * @param implementation Address of the new implementation.\\r\\n   */\\r\\n  event Upgraded(address indexed implementation);\\r\\n\\r\\n  /**\\r\\n   * @dev Storage slot with the address of the current implementation.\\r\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\r\\n   * validated in the constructor.\\r\\n   */\\r\\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n\\r\\n  /**\\r\\n   * @dev Storing type of the proxy, 1 for managerLogic, 2 for pool.\\r\\n   */\\r\\n  bytes32 internal constant PROXY_TYPE = 0x1000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the current implementation.\\r\\n   * @return impl Address of the current implementation\\r\\n   */\\r\\n  function _implementation() internal view override returns (address) {\\r\\n    address factory;\\r\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n    assembly {\\r\\n      factory := sload(slot)\\r\\n    }\\r\\n\\r\\n    // Begin custom modification\\r\\n    if (factory == address(0x0)) return address(0x0); // If factory not initialized return empty\\r\\n\\r\\n    return HasLogic(factory).getLogic(_proxyType());\\r\\n  }\\r\\n\\r\\n  /// @notice Return the proxy type.\\r\\n  /// @return proxyType Return type of the proxy.\\r\\n  function _proxyType() internal view returns (uint8 proxyType) {\\r\\n    bytes32 slot = PROXY_TYPE;\\r\\n    assembly {\\r\\n      proxyType := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Upgrades the proxy to a new implementation.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function _upgradeTo(address newImplementation) internal {\\r\\n    _setImplementation(newImplementation);\\r\\n    emit Upgraded(newImplementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Sets the implementation address of the proxy.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function _setImplementation(address newImplementation) internal {\\r\\n    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \\\"Cannot set implementation to EOA\\\");\\r\\n\\r\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n\\r\\n    assembly {\\r\\n      sstore(slot, newImplementation)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Sets type of the proxy.\\r\\n   * @param proxyType Type of the proxy.\\r\\n   */\\r\\n  function _setProxyType(uint8 proxyType) internal {\\r\\n    bytes32 slot = PROXY_TYPE;\\r\\n\\r\\n    assembly {\\r\\n      sstore(slot, proxyType)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/upgradability/HasLogic.sol\": {\r\n      \"content\": \"//\\r\\n//        __  __    __  ________  _______    ______   ________\\r\\n//       /  |/  |  /  |/        |/       \\\\  /      \\\\ /        |\\r\\n//   ____$$ |$$ |  $$ |$$$$$$$$/ $$$$$$$  |/$$$$$$  |$$$$$$$$/\\r\\n//  /    $$ |$$ |__$$ |$$ |__    $$ |  $$ |$$ | _$$/ $$ |__\\r\\n// /$$$$$$$ |$$    $$ |$$    |   $$ |  $$ |$$ |/    |$$    |\\r\\n// $$ |  $$ |$$$$$$$$ |$$$$$/    $$ |  $$ |$$ |$$$$ |$$$$$/\\r\\n// $$ \\\\__$$ |$$ |  $$ |$$ |_____ $$ |__$$ |$$ \\\\__$$ |$$ |_____\\r\\n// $$    $$ |$$ |  $$ |$$       |$$    $$/ $$    $$/ $$       |\\r\\n//  $$$$$$$/ $$/   $$/ $$$$$$$$/ $$$$$$$/   $$$$$$/  $$$$$$$$/\\r\\n//\\r\\n// dHEDGE DAO - https://dhedge.org\\r\\n//\\r\\n// Copyright (c) 2021 dHEDGE DAO\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n// in the Software without restriction, including without limitation the rights\\r\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n// copies of the Software, and to permit persons to whom the Software is\\r\\n// furnished to do so, subject to the following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included in all\\r\\n// copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n//\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.6;\\r\\n\\r\\ninterface HasLogic {\\r\\n  function getLogic(uint8 _proxyType) external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/upgradability/InitializableUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nimport \\\"./BaseUpgradeabilityProxy.sol\\\";\\r\\nimport \\\"../utils/AddressHelper.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title InitializableUpgradeabilityProxy\\r\\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\\r\\n * implementation and init data.\\r\\n */\\r\\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\\r\\n  using AddressHelper for address;\\r\\n\\r\\n  /**\\r\\n   * @dev Contract initializer.\\r\\n   * @param _factory Address of the factory containing the implementation.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  function initialize(\\r\\n    address _factory,\\r\\n    bytes memory _data,\\r\\n    uint8 _proxyType\\r\\n  ) public payable {\\r\\n    require(_implementation() == address(0), \\\"Impl not zero\\\");\\r\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\r\\n    _setImplementation(_factory);\\r\\n    _setProxyType(_proxyType);\\r\\n    if (_data.length > 0) {\\r\\n      _implementation().tryAssemblyDelegateCall(_data);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/upgradability/Proxy.sol\": {\r\n      \"content\": \"//\\r\\n//        __  __    __  ________  _______    ______   ________\\r\\n//       /  |/  |  /  |/        |/       \\\\  /      \\\\ /        |\\r\\n//   ____$$ |$$ |  $$ |$$$$$$$$/ $$$$$$$  |/$$$$$$  |$$$$$$$$/\\r\\n//  /    $$ |$$ |__$$ |$$ |__    $$ |  $$ |$$ | _$$/ $$ |__\\r\\n// /$$$$$$$ |$$    $$ |$$    |   $$ |  $$ |$$ |/    |$$    |\\r\\n// $$ |  $$ |$$$$$$$$ |$$$$$/    $$ |  $$ |$$ |$$$$ |$$$$$/\\r\\n// $$ \\\\__$$ |$$ |  $$ |$$ |_____ $$ |__$$ |$$ \\\\__$$ |$$ |_____\\r\\n// $$    $$ |$$ |  $$ |$$       |$$    $$/ $$    $$/ $$       |\\r\\n//  $$$$$$$/ $$/   $$/ $$$$$$$$/ $$$$$$$/   $$$$$$/  $$$$$$$$/\\r\\n//\\r\\n// dHEDGE DAO - https://dhedge.org\\r\\n//\\r\\n// Copyright (c) 2021 dHEDGE DAO\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n// in the Software without restriction, including without limitation the rights\\r\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n// copies of the Software, and to permit persons to whom the Software is\\r\\n// furnished to do so, subject to the following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included in all\\r\\n// copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n//\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.6;\\r\\n\\r\\n/**\\r\\n * @title Proxy\\r\\n * @dev Implements delegation of calls to other contracts, with proper\\r\\n * forwarding of return values and bubbling of failures.\\r\\n * It defines a fallback function that delegates all calls to the address\\r\\n * returned by the abstract _implementation() internal function.\\r\\n */\\r\\nabstract contract Proxy {\\r\\n  /**\\r\\n   * @notice Fallback function.\\r\\n   * Implemented entirely in `_fallback`.\\r\\n   */\\r\\n  fallback() external payable {\\r\\n    _fallback();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Receive function.\\r\\n   * Implemented entirely in `_fallback`.\\r\\n   */\\r\\n  receive() external payable {\\r\\n    _fallback();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The Address of the implementation.\\r\\n   */\\r\\n  function _implementation() internal view virtual returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice Delegates execution to an implementation contract.\\r\\n   * This is a low level function that doesn't return to its internal call site.\\r\\n   * It will return to the external caller whatever the implementation returns.\\r\\n   * @param implementation Address to delegate.\\r\\n   */\\r\\n  function _delegate(address implementation) internal {\\r\\n    assembly {\\r\\n      // Copy msg.data. We take full control of memory in this inline assembly\\r\\n      // block because it will not return to Solidity code. We overwrite the\\r\\n      // Solidity scratch pad at memory position 0.\\r\\n      calldatacopy(0, 0, calldatasize())\\r\\n\\r\\n      // Call the implementation.\\r\\n      // out and outsize are 0 because we don't know the size yet.\\r\\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\r\\n\\r\\n      // Copy the returned data.\\r\\n      // Warning: OVM: Using RETURNDATASIZE or RETURNDATACOPY in user asm isn't guaranteed to work\\r\\n      returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n      switch result\\r\\n      // delegatecall returns 0 on error.\\r\\n      case 0 {\\r\\n        revert(0, returndatasize())\\r\\n      }\\r\\n      default {\\r\\n        return(0, returndatasize())\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Function that is run as the first thing in the fallback function.\\r\\n   * Can be redefined in derived contracts to add functionality.\\r\\n   * Redefinitions must call super._willFallback().\\r\\n   */\\r\\n  // solhint-disable-next-line no-empty-blocks\\r\\n  function _willFallback() internal virtual {}\\r\\n\\r\\n  /**\\r\\n   * @notice fallback implementation.\\r\\n   * Extracted to enable manual triggering.\\r\\n   */\\r\\n  function _fallback() internal {\\r\\n    _willFallback();\\r\\n    _delegate(_implementation());\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/AddressHelper.sol\": {\r\n      \"content\": \"//        __  __    __  ________  _______    ______   ________\\r\\n//       /  |/  |  /  |/        |/       \\\\  /      \\\\ /        |\\r\\n//   ____$$ |$$ |  $$ |$$$$$$$$/ $$$$$$$  |/$$$$$$  |$$$$$$$$/\\r\\n//  /    $$ |$$ |__$$ |$$ |__    $$ |  $$ |$$ | _$$/ $$ |__\\r\\n// /$$$$$$$ |$$    $$ |$$    |   $$ |  $$ |$$ |/    |$$    |\\r\\n// $$ |  $$ |$$$$$$$$ |$$$$$/    $$ |  $$ |$$ |$$$$ |$$$$$/\\r\\n// $$ \\\\__$$ |$$ |  $$ |$$ |_____ $$ |__$$ |$$ \\\\__$$ |$$ |_____\\r\\n// $$    $$ |$$ |  $$ |$$       |$$    $$/ $$    $$/ $$       |\\r\\n//  $$$$$$$/ $$/   $$/ $$$$$$$$/ $$$$$$$/   $$$$$$/  $$$$$$$$/\\r\\n//\\r\\n// dHEDGE DAO - https://dhedge.org\\r\\n//\\r\\n// Copyright (c) 2021 dHEDGE DAO\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n// in the Software without restriction, including without limitation the rights\\r\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n// copies of the Software, and to permit persons to whom the Software is\\r\\n// furnished to do so, subject to the following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included in all\\r\\n// copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n//\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\n// import \\\"./BytesLib.sol\\\";\\r\\n\\r\\npragma solidity 0.7.6;\\r\\n\\r\\n/**\\r\\n * @title A library for Address utils.\\r\\n */\\r\\nlibrary AddressHelper {\\r\\n  /**\\r\\n   * @notice try a contract call via assembly\\r\\n   * @param to the contract address\\r\\n   * @param data the call data\\r\\n   * @return success if the contract call is successful or not\\r\\n   */\\r\\n  function tryAssemblyCall(address to, bytes memory data) internal returns (bool success) {\\r\\n    assembly {\\r\\n      success := call(gas(), to, 0, add(data, 0x20), mload(data), 0, 0)\\r\\n      switch iszero(success)\\r\\n      case 1 {\\r\\n        let size := returndatasize()\\r\\n        returndatacopy(0x00, 0x00, size)\\r\\n        revert(0x00, size)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice try a contract delegatecall via assembly\\r\\n   * @param to the contract address\\r\\n   * @param data the call data\\r\\n   * @return success if the contract call is successful or not\\r\\n   */\\r\\n  function tryAssemblyDelegateCall(address to, bytes memory data) internal returns (bool success) {\\r\\n    assembly {\\r\\n      success := delegatecall(gas(), to, add(data, 0x20), mload(data), 0, 0)\\r\\n      switch iszero(success)\\r\\n      case 1 {\\r\\n        let size := returndatasize()\\r\\n        returndatacopy(0x00, 0x00, size)\\r\\n        revert(0x00, size)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // /**\\r\\n  //  * @notice try a contract call\\r\\n  //  * @param to the contract address\\r\\n  //  * @param data the call data\\r\\n  //  * @return success if the contract call is successful or not\\r\\n  //  */\\r\\n  // function tryCall(address to, bytes memory data) internal returns (bool) {\\r\\n  //   (bool success, bytes memory res) = to.call(data);\\r\\n\\r\\n  //   // Get the revert message of the call and revert with it if the call failed\\r\\n  //   require(success, _getRevertMsg(res));\\r\\n\\r\\n  //   return success;\\r\\n  // }\\r\\n\\r\\n  // /**\\r\\n  //  * @dev Get the revert message from a call\\r\\n  //  * @notice This is needed in order to get the human-readable revert message from a call\\r\\n  //  * @param response Response of the call\\r\\n  //  * @return Revert message string\\r\\n  //  */\\r\\n  // function _getRevertMsg(bytes memory response) internal pure returns (string memory) {\\r\\n  //     // If the response length is less than 68, then the transaction failed silently (without a revert message)\\r\\n  //     if (response.length < 68) return \\\"Transaction reverted silently\\\";\\r\\n  //     bytes memory revertData = response.slice(4, response.length - 4); // Remove the selector which is the first 4 bytes\\r\\n  //     return abi.decode(revertData, (string)); // All that remains is the revert string\\r\\n  // }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"_proxyType\",\"type\":\"uint8\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InitializableUpgradeabilityProxy", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "20", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}