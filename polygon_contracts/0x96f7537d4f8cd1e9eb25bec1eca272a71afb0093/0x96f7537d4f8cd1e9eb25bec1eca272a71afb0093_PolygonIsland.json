{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/polygon/polygonIsland/PolygonIsland.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.9;\\n\\nimport {ICoin, IToken, IGHGMetadata} from \\\"../../interfaces/Interfaces.sol\\\";\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {Pausable} from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport {RecoverableERC721Holder} from \\\"../../utils/RecoverableERC721Holder.sol\\\";\\n\\ncontract PolygonIsland is Ownable, Pausable, RecoverableERC721Holder {\\n\\n    ///// INTERFACES /////\\n    ICoin public wood;\\n    IToken public ships;\\n    IToken public goldhunter;\\n    IGHGMetadata public metadata;\\n    //////////////////////\\n    \\n    ///// STRUCTS /////\\n    struct RewardRate {\\n        uint start;\\n        uint128 ship;\\n        uint128 miner;\\n        uint128 pirateShip;\\n    }\\n\\n    struct Stake {\\n        uint start;\\n        uint16 tokenId;\\n        uint16 currentRewardRateIx;\\n    }\\n    //////////////////////\\n\\n    ///// CONTRACT VARIABLES /////\\n    // Global Stat Fields\\n    uint public pirateReward;\\n    uint public totalShipStaked;\\n    uint public totalWoodClaimed;\\n    uint public totalPirateStaked;\\n    uint public unaccountedRewards;\\n    uint public tokenStolenCounter;\\n    uint public totalGoldMinerStaked;\\n    \\n    // Contract Configuration\\n    bool public zeroClaim; // enables the ability to zero out all possible claims\\n    uint public taxPercent; // sets the tax percentage which miners/ships pay when claiming wood\\n    uint public stealPercent; // sets the chance of a Miner being stolen\\n    uint public penaltyPercent; // sets the chance of paying the max unclaim penalty\\n    uint public minTimeToExit; // sets the minimum amount of time a unit must wait from its last claim before it can be unstaked\\n    bool public bypassPirateSteal; // enables the ability to disable pirate stealing miners mechanic\\n    bool public bypassMinerUnstakePenalty; // enables bypassing the 50% chance of total loss of Wood when unstaking units\\n    RewardRate[] public rewardRates; // allows new mining reward rates to be paid out overtime while enabling historic claim\\n\\n    // Staking Mechanics\\n    mapping(uint => uint) public shipIndices;\\n    mapping(uint => uint) public pirateIndices;\\n    mapping(uint => uint) public goldMinerIndices;\\n    mapping(address => Stake[]) public goldMinerStake;\\n    mapping(address => Stake[]) public pirateStake;\\n    mapping(address => Stake[]) public shipStake;\\n\\n    // Steal Mechanics\\n    uint[] stakedPirateIds;\\n    mapping(uint => uint) stakedPirateIdsIndexes;\\n    mapping(uint => address) stakedPirateOwners;\\n    //////////////////////\\n\\n    ///// EVENTS /////\\n    event UnstakePenaltyPaid(uint16 tokenId, uint owed);\\n    event ShipClaimed(uint16 tokenId, uint earned, bool unstaked);\\n    event TokenStolen(address owner, uint16 tokenId, address thief);\\n    event PirateClaimed(uint16 tokenId, uint earned, bool unstaked);\\n    event LandTokenStaked(address owner, uint16 tokenId, uint value);\\n    event GoldMinerClaimed(uint16 tokenId, uint earned, bool unstaked);\\n    //////////////////////\\n    \\n    ///// CONSTRUCTOR /////\\n    constructor(\\n        address _metadata,\\n        address _ships,\\n        address _goldhunter,\\n        address _wood\\n    ) {\\n        metadata = IGHGMetadata(_metadata);\\n        ships = IToken(_ships);\\n        goldhunter = IToken(_goldhunter);\\n        wood = ICoin(_wood);\\n        \\n        rewardRates.push(\\n            RewardRate({\\n                start: block.timestamp,\\n                miner: 3000 ether,\\n                ship: 6000 ether,\\n                pirateShip: 9000 ether\\n            })\\n        );\\n\\n        taxPercent = 20;\\n        stealPercent = 5;\\n        penaltyPercent = 50;\\n        minTimeToExit = 2 days;\\n        zeroClaim = false;\\n        bypassMinerUnstakePenalty = false;\\n        bypassPirateSteal = false;\\n\\n        _pause();\\n    }\\n    //////////////////////\\n\\n    function getAccountGoldMiners(address user) external view returns (Stake[] memory) {\\n        return goldMinerStake[user];\\n    }\\n\\n    function getAccountPirates(address user) external view returns (Stake[] memory) {\\n        return pirateStake[user];\\n    }\\n\\n    function getAccountShips(address user) external view returns (Stake[] memory) {\\n        return shipStake[user];\\n    }\\n\\n    ///// OWNER FUNCTIONS /////\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    function setGHGMetadata(address _ghgMetadata) external onlyOwner {\\n        metadata = IGHGMetadata(_ghgMetadata);\\n    }\\n\\n    function setTaxPercent(uint _taxPercent) external onlyOwner {\\n        taxPercent = _taxPercent;\\n    }\\n\\n    function setStealPercent(uint _stealPercent) external onlyOwner {\\n        stealPercent = _stealPercent;\\n    }\\n\\n    function setPenaltyPercent(uint _penaltyPercent) external onlyOwner {\\n        penaltyPercent = _penaltyPercent;\\n    }\\n\\n    function setMinTimeToExit(uint _minTimeToExit) external onlyOwner {\\n        minTimeToExit = _minTimeToExit;\\n    }\\n\\n    function setZeroClaim(bool _zeroClaim) external onlyOwner {\\n        zeroClaim = _zeroClaim;\\n    }\\n\\n    function setBypassMinerUnstakePenalty(bool _bypassMinerUnstakePenalty) external onlyOwner {\\n        bypassMinerUnstakePenalty = _bypassMinerUnstakePenalty;\\n    }\\n\\n    function setBypassPirateSteal(bool _bypassPirateSteal) external onlyOwner {\\n        bypassPirateSteal = _bypassPirateSteal;\\n    }\\n\\n    // these parameters should be passed in Ether value and will be stored in Wei\\n    function pushRewardRate( \\n        uint128 _miner,\\n        uint128 _ship,\\n        uint128 _pirateShip\\n    ) external onlyOwner {\\n        rewardRates.push(RewardRate({\\n            miner: _miner * 1e18,\\n            ship: _ship * 1e18,\\n            pirateShip: _pirateShip * 1e18,\\n            start: block.timestamp\\n        }));\\n    }\\n    //////////////////////\\n\\n    ///// STAKING FUNCTIONS /////\\n    // This function can be called by any token owner, and used to stake tokens on behalf of the supplied address\\n    function stakeTokens(address _account, uint16[] calldata _goldhunterIds, uint16[] calldata _shipIds) external whenNotPaused {\\n        // Handle GoldHunters\\n        for(uint i = 0; i < _goldhunterIds.length; i++) {\\n            require(goldhunter.ownerOf(_goldhunterIds[i]) == msg.sender, \\\"ERROR: NFT Does Not Belong to Transaction Sender\\\");\\n            \\n            if (metadata.goldhunterIsPirate(_goldhunterIds[i])) {\\n                _stakePirate(_account, _goldhunterIds[i]);\\n            } else {\\n                _stakeGoldMiner(_account, _goldhunterIds[i]);\\n            }\\n\\n            goldhunter.safeTransferFrom(msg.sender, address(this), _goldhunterIds[i]);\\n        }\\n\\n        // Handle Ships\\n        for(uint i = 0; i < _shipIds.length; i++) {\\n            require(ships.ownerOf(_shipIds[i]) == msg.sender, \\\"ERROR: NFT Does Not Belong to Transaction Sender\\\");\\n            _stakeShip(_account, _shipIds[i]);\\n            ships.safeTransferFrom(msg.sender, address(this), _shipIds[i]);\\n        }\\n    }\\n\\n    function _stakeGoldMiner(address _account, uint16 _tokenId) internal {\\n        totalGoldMinerStaked += 1;\\n\\n        goldMinerIndices[_tokenId] = goldMinerStake[_account].length;\\n        goldMinerStake[_account].push(Stake({\\n            tokenId: _tokenId,\\n            currentRewardRateIx: uint16(rewardRates.length - 1),\\n            start: block.timestamp\\n        }));\\n\\n        emit LandTokenStaked(_account, _tokenId, block.timestamp);\\n    }\\n\\n    function _stakePirate(address _account, uint16 _tokenId) internal {\\n        totalPirateStaked += 1;\\n\\n        // Steal Mechanics\\n        stakedPirateIdsIndexes[_tokenId] = stakedPirateIds.length;\\n        stakedPirateIds.push(_tokenId);\\n        stakedPirateOwners[_tokenId] = _account;\\n\\n        // Stake Mechanics\\n        pirateIndices[_tokenId] = pirateStake[_account].length;\\n        pirateStake[_account].push(Stake({\\n            tokenId: _tokenId,\\n            currentRewardRateIx: uint16(rewardRates.length - 1),\\n            start: pirateReward\\n        }));\\n\\n        emit LandTokenStaked(_account, _tokenId, block.timestamp);\\n    }\\n\\n    function _stakeShip(address _account, uint16 _tokenId) internal {\\n        totalShipStaked += 1;\\n\\n        shipIndices[_tokenId] = shipStake[_account].length;\\n        shipStake[_account].push(Stake({\\n            tokenId: uint16(_tokenId),\\n            currentRewardRateIx: uint16(rewardRates.length - 1),\\n            start: block.timestamp\\n        }));\\n\\n        emit LandTokenStaked(_account, _tokenId, block.timestamp);\\n    }\\n    //////////////////////\\n\\n    ///// CLAIMING/UNSTAKING FUNCTIONS /////\\n    function claimFromTokens(uint16[] calldata _goldhunterIds, uint16[] calldata _shipIds, bool _unstake) external {\\n        uint owed = 0;\\n        \\n        for (uint i = 0; i < _goldhunterIds.length; i++) {\\n            if (metadata.goldhunterIsPirate(_goldhunterIds[i])) {\\n                owed += _claimFromPirate(_goldhunterIds[i], _unstake);\\n            } else {\\n                owed += _claimFromMiner(_goldhunterIds[i], _unstake);\\n            }\\n        }\\n\\n        for (uint i = 0; i < _shipIds.length; i++) {\\n            owed += _claimFromShip(_shipIds[i], _unstake);\\n        }\\n\\n        if (owed != 0) {\\n            totalWoodClaimed += owed;\\n            wood.mint(msg.sender, owed);\\n        }\\n    }\\n\\n    function _claimFromMiner(uint16 _tokenId, bool _unstake) internal returns (uint owed) {\\n        Stake memory stake = goldMinerStake[msg.sender][goldMinerIndices[_tokenId]];\\n        require(!(_unstake && block.timestamp - stake.start < minTimeToExit), \\\"ERROR: Must Wait 2 Days from Last Claim Before Unstaking\\\");\\n\\n        owed = zeroClaim ? 0 : getOwedToGoldhunter(msg.sender, _tokenId);\\n\\n        if (!_unstake) {\\n            _payTax((owed * taxPercent) / 100);\\n            owed = (owed * (100 - taxPercent)) / 100;\\n            goldMinerStake[msg.sender][goldMinerIndices[_tokenId]] = _getFullyClaimedStake(_tokenId, block.timestamp);\\n        } else {\\n            bool stolen = false;\\n            address luckyPirate;\\n            uint randomNumber = _getSomeRandomNumber(totalGoldMinerStaked + _tokenId, 100);\\n\\n            totalGoldMinerStaked -= 1;\\n\\n            if (randomNumber < stealPercent && _tokenId >= 10000 && !bypassPirateSteal) {\\n                luckyPirate = _randomPirateOwner(totalGoldMinerStaked + _tokenId);\\n                if (luckyPirate != address(0x0) && luckyPirate != msg.sender) {\\n                    _payTax(owed);\\n                    owed = 0;\\n                    stolen = true;\\n                    emit TokenStolen(msg.sender, _tokenId, luckyPirate);\\n                }\\n            }\\n\\n            if (randomNumber < penaltyPercent && !stolen && !bypassMinerUnstakePenalty) {\\n                _payTax(owed);\\n                owed = 0;\\n                emit UnstakePenaltyPaid(_tokenId, owed);\\n            }\\n            \\n            Stake memory lastStake = goldMinerStake[msg.sender][goldMinerStake[msg.sender].length - 1];\\n            goldMinerStake[msg.sender][goldMinerIndices[_tokenId]] = lastStake;\\n            goldMinerIndices[lastStake.tokenId] = goldMinerIndices[_tokenId];\\n            goldMinerStake[msg.sender].pop();\\n            delete goldMinerIndices[_tokenId];\\n\\n            if (!stolen) {\\n                goldhunter.safeTransferFrom(address(this), msg.sender, _tokenId);\\n            } else {\\n                tokenStolenCounter += 1;\\n                goldhunter.safeTransferFrom(address(this), luckyPirate, _tokenId);\\n            }      \\n        }\\n\\n        emit GoldMinerClaimed(_tokenId, owed, _unstake);\\n    }\\n\\n    function _claimFromPirate(uint16 _tokenId, bool _unstake) internal returns (uint owed) {\\n        owed = zeroClaim ? 0 : getOwedToGoldhunter(msg.sender, _tokenId);\\n\\n        if (_unstake == true) {\\n            totalPirateStaked -= 1;\\n\\n            Stake memory lastStake = pirateStake[msg.sender][pirateStake[msg.sender].length - 1];\\n            pirateStake[msg.sender][pirateIndices[_tokenId]] = lastStake;\\n            pirateIndices[lastStake.tokenId] = pirateIndices[_tokenId];\\n            pirateStake[msg.sender].pop();\\n            delete pirateIndices[_tokenId];\\n            _updateStakedPirateIds(_tokenId);\\n\\n            goldhunter.safeTransferFrom(address(this), msg.sender, _tokenId);\\n        } else {\\n            pirateStake[msg.sender][pirateIndices[_tokenId]] = _getFullyClaimedStake(_tokenId, pirateReward);\\n        }\\n        emit PirateClaimed(_tokenId, owed, _unstake);\\n    }\\n\\n    function _claimFromShip(uint16 _shipId, bool _unstake) internal returns (uint owed) {\\n        Stake memory stake = shipStake[msg.sender][shipIndices[_shipId]];\\n        require(!(_unstake && block.timestamp - stake.start < minTimeToExit), \\\"ERROR: Must Wait 2 Days from Last Claim Before Unstaking\\\");\\n    \\n        owed = zeroClaim ? 0 : getOwedToShip(msg.sender, _shipId);\\n\\n        _payTax((owed * taxPercent) / 100);\\n        owed = (owed * (100 - taxPercent)) / 100;\\n\\n        if (_unstake == true) {\\n            totalShipStaked -= 1;\\n\\n            Stake memory lastStake = shipStake[msg.sender][shipStake[msg.sender].length - 1];\\n            shipStake[msg.sender][shipIndices[_shipId]] = lastStake;\\n            shipIndices[lastStake.tokenId] = shipIndices[_shipId];\\n            shipStake[msg.sender].pop();\\n            delete shipIndices[_shipId];\\n\\n            ships.safeTransferFrom(address(this), msg.sender, _shipId);\\n        } else {\\n            shipStake[msg.sender][shipIndices[_shipId]] = _getFullyClaimedStake(_shipId, block.timestamp);\\n        }\\n\\n        emit ShipClaimed(_shipId, owed, _unstake);\\n    }\\n\\n    // Iterates through every rewardRate from the current position to the latest rewardRate and sums the results\\n    function getOwedToGoldhunter(address _owner, uint16 _tokenId) public view returns (uint owed) {\\n        if (metadata.goldhunterIsPirate(_tokenId)) {\\n            Stake memory stake = pirateStake[_owner][pirateIndices[_tokenId]];\\n            owed = pirateReward - stake.start;\\n        } else {\\n            Stake memory stake = goldMinerStake[_owner][goldMinerIndices[_tokenId]];\\n            uint _start = stake.start;\\n\\n            for(uint i = stake.currentRewardRateIx; i < rewardRates.length; i++) {\\n                if (i == rewardRates.length - 1) {\\n                    owed += ((block.timestamp - _start) * rewardRates[i].miner) / 1 days;\\n                } else {\\n                    owed += ((rewardRates[i+1].start - _start) * rewardRates[i].miner) / 1 days;\\n                    _start = rewardRates[i+1].start;\\n                }\\n            }\\n        }\\n    }\\n\\n    function getOwedToShip(address _owner, uint16 _shipId) public view returns (uint owed) {\\n        Stake memory stake = shipStake[_owner][shipIndices[_shipId]];\\n        uint _start = stake.start;\\n\\n        if (!metadata.shipIsPirate(_shipId)) {\\n            for(uint i = stake.currentRewardRateIx; i < rewardRates.length; i++) {\\n                if (i == rewardRates.length - 1) {\\n                    owed += ((block.timestamp - _start) * rewardRates[i].ship) / 1 days;\\n                } else {\\n                    uint nextStart = rewardRates[i+1].start;\\n                    owed += ((nextStart - _start) * rewardRates[i].ship) / 1 days;\\n                    _start = nextStart;\\n                }\\n            }\\n        } else {\\n            for(uint i = stake.currentRewardRateIx; i < rewardRates.length; i++) {\\n                if (i == rewardRates.length - 1) {\\n                    owed += ((block.timestamp - _start) * rewardRates[i].pirateShip) / 1 days;\\n                } else {\\n                    uint nextStart = rewardRates[i+1].start;\\n                    owed += ((nextStart - _start) * rewardRates[i].pirateShip) / 1 days;\\n                    _start = nextStart;\\n                }\\n            }\\n        }\\n    }\\n    //////////////////////\\n\\n    ///// INTERNAL HELPER FUNCTIONS /////\\n    function _getFullyClaimedStake(uint _tokenId, uint _start) internal view returns (Stake memory) {\\n        return Stake({\\n            tokenId: uint16(_tokenId),\\n            currentRewardRateIx: uint16(rewardRates.length - 1),\\n            start: _start\\n        });\\n    }\\n\\n    function _payTax(uint _amount) internal {\\n        if (totalPirateStaked != 0) {\\n            pirateReward += (_amount + unaccountedRewards) / totalPirateStaked;\\n            unaccountedRewards = 0;\\n        } else {\\n            unaccountedRewards += _amount;\\n        }\\n    }\\n\\n    function _updateStakedPirateIds(uint _tokenId) internal {\\n        uint unstakeIx = stakedPirateIdsIndexes[_tokenId];\\n        uint lastTokenId = stakedPirateIds[stakedPirateIds.length - 1];\\n\\n        stakedPirateIds[unstakeIx] = lastTokenId;\\n        stakedPirateIdsIndexes[lastTokenId] = unstakeIx;\\n        \\n        stakedPirateIds.pop();\\n        delete stakedPirateIdsIndexes[_tokenId];\\n        delete stakedPirateOwners[_tokenId];\\n    }\\n\\n    function _getSomeRandomNumber(uint _seed, uint _limit) internal view returns (uint) {\\n        return uint(\\n            keccak256(\\n                abi.encodePacked(\\n                    _seed,\\n                    blockhash(block.number - 1),\\n                    block.coinbase,\\n                    block.difficulty,\\n                    block.timestamp,\\n                    msg.sender\\n                )\\n            )\\n        ) % _limit;\\n    }\\n\\n    function _randomPirateOwner(uint _seed) internal view returns (address) {\\n        if (totalPirateStaked != 0) {\\n            return stakedPirateOwners[stakedPirateIds[_getSomeRandomNumber(_seed, stakedPirateIds.length)]];\\n        } else {\\n            return address(0x0);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.9;\\n\\ninterface ICoin {\\n    function mint(address account, uint amount) external;\\n    function burn(address _from, uint _amount) external;\\n    function balanceOf(address account) external returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\\ninterface IToken {\\n    function ownerOf(uint id) external view returns (address);\\n    function transferFrom(address from, address to, uint tokenId) external;\\n    function safeTransferFrom(address from, address to, uint tokenId) external; // ERC721\\n    function safeTransferFrom(address from, address to, uint tokenId, uint amount) external; // ERC1155\\n    function isApprovedForAll(address owner, address operator) external returns(bool);\\n    function setApprovalForAll(address operator, bool approved) external;\\n}\\n\\ninterface IGHGMetadata {\\n    ///// GENERIC GETTERS /////\\n    function getGoldhunterMetadata(uint16 _tokenId) external view returns (string memory);\\n    function getShipMetadata(uint16 _tokenId) external view returns (string memory);\\n    function getHouseMetadata(uint16 _tokenId) external view returns (string memory);\\n\\n    ///// TRAIT GETTERS - SHIPS /////\\n    function shipIsPirate(uint16 _tokenId) external view returns (bool);\\n    function shipIsCrossedTheOcean(uint16 _tokenId) external view returns (bool);\\n    function getShipBackground(uint16 _tokenId) external view returns (string memory);\\n    function getShipShip(uint16 _tokenId) external view returns (string memory);\\n    function getShipFlag(uint16 _tokenId) external view returns (string memory);\\n    function getShipMast(uint16 _tokenId) external view returns (string memory);\\n    function getShipAnchor(uint16 _tokenId) external view returns (string memory);\\n    function getShipSail(uint16 _tokenId) external view returns (string memory);\\n    function getShipWaves(uint16 _tokenId) external view returns (string memory);\\n\\n    ///// TRAIT GETTERS - HOUSES /////\\n    function getHouseBackground(uint16 _tokenId) external view returns (string memory);\\n    function getHouseType(uint16 _tokenId) external view returns (string memory);\\n    function getHouseWindow(uint16 _tokenId) external view returns (string memory);\\n    function getHouseDoor(uint16 _tokenId) external view returns (string memory);\\n    function getHouseRoof(uint16 _tokenId) external view returns (string memory);\\n    function getHouseForeground(uint16 _tokenId) external view returns (string memory);\\n\\n    ///// TRAIT GETTERS - GOLDHUNTERS /////\\n    function goldhunterIsCrossedTheOcean(uint16 _tokenId) external view returns (bool);\\n    function goldhunterIsPirate(uint16 _tokenId) external view returns (bool);\\n    function getGoldhunterIsGen0(uint16 _tokenId) external pure returns (bool);\\n    function getGoldhunterSkin(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterLegs(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterFeet(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterTshirt(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterHeadwear(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterMouth(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterNeck(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterSunglasses(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterTool(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterPegleg(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterHook(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterDress(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterFace(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterPatch(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterEars(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterHead(uint16 _tokenId) external view returns (string memory);\\n    function getGoldhunterArm(uint16 _tokenId) external view returns (string memory);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/RecoverableERC721Holder.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\npragma solidity ^0.8.0;\\n\\nimport {IToken} from \\\"../interfaces/Interfaces.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract RecoverableERC721Holder is Ownable, IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /**\\n     * @dev Allows for the safeTransfer of all ERC721 assets from this contract to a list of recipients\\n     */\\n    function emergencyTransferOut(address[] calldata _tokenAddressesToTransfer, address[] calldata _recipients, uint[] calldata _tokenIds) external onlyOwner {\\n        require((_tokenAddressesToTransfer.length == _tokenIds.length) && (_tokenIds.length == _recipients.length), \\\"ERROR: INVALID INPUT DATA - MISMATCHED LENGTHS\\\");\\n\\n        for(uint i = 0; i < _recipients.length; i++) {\\n            IToken(_tokenAddressesToTransfer[i]).safeTransferFrom(address(this), _recipients[i], _tokenIds[i]);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_metadata\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ships\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_goldhunter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wood\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"name\":\"GoldMinerClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LandTokenStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"name\":\"PirateClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"name\":\"ShipClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"thief\",\"type\":\"address\"}],\"name\":\"TokenStolen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"name\":\"UnstakePenaltyPaid\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bypassMinerUnstakePenalty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bypassPirateSteal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_goldhunterIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_shipIds\",\"type\":\"uint16[]\"},{\"internalType\":\"bool\",\"name\":\"_unstake\",\"type\":\"bool\"}],\"name\":\"claimFromTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenAddressesToTransfer\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"emergencyTransferOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAccountGoldMiners\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"currentRewardRateIx\",\"type\":\"uint16\"}],\"internalType\":\"struct PolygonIsland.Stake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAccountPirates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"currentRewardRateIx\",\"type\":\"uint16\"}],\"internalType\":\"struct PolygonIsland.Stake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAccountShips\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"currentRewardRateIx\",\"type\":\"uint16\"}],\"internalType\":\"struct PolygonIsland.Stake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"}],\"name\":\"getOwedToGoldhunter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_shipId\",\"type\":\"uint16\"}],\"name\":\"getOwedToShip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"goldMinerIndices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"goldMinerStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"currentRewardRateIx\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goldhunter\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"contract IGHGMetadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTimeToExit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pirateIndices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pirateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pirateStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"currentRewardRateIx\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_miner\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_ship\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_pirateShip\",\"type\":\"uint128\"}],\"name\":\"pushRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"ship\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"miner\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"pirateShip\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bypassMinerUnstakePenalty\",\"type\":\"bool\"}],\"name\":\"setBypassMinerUnstakePenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bypassPirateSteal\",\"type\":\"bool\"}],\"name\":\"setBypassPirateSteal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ghgMetadata\",\"type\":\"address\"}],\"name\":\"setGHGMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTimeToExit\",\"type\":\"uint256\"}],\"name\":\"setMinTimeToExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_penaltyPercent\",\"type\":\"uint256\"}],\"name\":\"setPenaltyPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stealPercent\",\"type\":\"uint256\"}],\"name\":\"setStealPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxPercent\",\"type\":\"uint256\"}],\"name\":\"setTaxPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_zeroClaim\",\"type\":\"bool\"}],\"name\":\"setZeroClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shipIndices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shipStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"currentRewardRateIx\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ships\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"_goldhunterIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_shipIds\",\"type\":\"uint16[]\"}],\"name\":\"stakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stealPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenStolenCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGoldMinerStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPirateStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShipStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWoodClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unaccountedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wood\",\"outputs\":[{\"internalType\":\"contract ICoin\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PolygonIsland", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000bf90c483e8a2e8435cb7fcfc5dc3165c45eaf631000000000000000000000000d26c4aac84bec285ed9c8ef56b62283f78d2105c000000000000000000000000ef3700275e147c69af6a2e27e1f384c821cfc6620000000000000000000000006910e3e129523c9576061334ca650ea4c4456a0b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}