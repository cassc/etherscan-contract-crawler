{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1337\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library to encode strings in Base64.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\\nlibrary Base64 {\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    function encode(\\n        bytes memory data,\\n        bool fileSafe,\\n        bool noPadding\\n    ) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                // Multiply by 4/3 rounded up.\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n                // Set `result` to point to the start of the free memory.\\n                result := mload(0x40)\\n\\n                // Store the table into the scratch space.\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\n                // We will rewrite the free memory pointer at `0x40` later with\\n                // the allocated size.\\n                // The magic constant 0x0230 will translate \\\"-_\\\" + \\\"+/\\\".\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n                mstore(0x3f, sub(\\\"ghijklmnopqrstuvwxyz0123456789-_\\\", mul(iszero(fileSafe), 0x0230)))\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, encodedLength)\\n\\n                // Run over the input, 3 bytes at a time.\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\\n                    \\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    // prettier-ignore\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n\\n                let r := mod(dataLength, 3)\\n\\n                switch noPadding\\n                case 0 {\\n                    // Offset `ptr` and pad with '='. We can simply write over the end.\\n                    mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\\n                    mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\\n                    // Write the length of the string.\\n                    mstore(result, encodedLength)\\n                }\\n                default {\\n                    // Write the length of the string.\\n                    mstore(result, sub(encodedLength, add(iszero(iszero(r)), eq(r, 1))))\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(end, 31), not(31)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, false, false)`.\\n    function encode(bytes memory data) internal pure returns (string memory result) {\\n        result = encode(data, false, false);\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\n    function encode(bytes memory data, bool fileSafe) internal pure returns (string memory result) {\\n        result = encode(data, fileSafe, false);\\n    }\\n\\n    /// @dev Encodes base64 encoded `data`.\\n    ///\\n    /// Supports:\\n    /// - RFC 4648 (both standard and file-safe mode).\\n    /// - RFC 3501 (63: ',').\\n    ///\\n    /// Does not support:\\n    /// - Line breaks.\\n    ///\\n    /// Note: For performance reasons,\\n    /// this function will NOT revert on invalid `data` inputs.\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\n    /// It is the user's responsibility to ensure that the `data`\\n    /// is a valid base64 encoded string.\\n    function decode(string memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                let end := add(data, dataLength)\\n                let decodedLength := mul(shr(2, dataLength), 3)\\n\\n                switch and(dataLength, 3)\\n                case 0 {\\n                    // If padded.\\n                    decodedLength := sub(\\n                        decodedLength,\\n                        add(eq(and(mload(end), 0xFF), 0x3d), eq(and(mload(end), 0xFFFF), 0x3d3d))\\n                    )\\n                }\\n                default {\\n                    // If non-padded.\\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\\n                }\\n\\n                result := mload(0x40)\\n\\n                // Write the length of the string.\\n                mstore(result, decodedLength)\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n\\n                // Load the table into the scratch space.\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\n                // `m` also doubles as the mask of the upper 6 bits.\\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\n                mstore(0x5b, m)\\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\n\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Read 4 bytes.\\n                    data := add(data, 4)\\n                    let input := mload(data)\\n\\n                    // Write 3 bytes.\\n                    mstore(ptr, or(\\n                        and(m, mload(byte(28, input))),\\n                        shr(6, or(\\n                            and(m, mload(byte(29, input))),\\n                            shr(6, or(\\n                                and(m, mload(byte(30, input))),\\n                                shr(6, mload(byte(31, input)))\\n                            ))\\n                        ))\\n                    ))\\n\\n                    ptr := add(ptr, 3)\\n                    \\n                    // prettier-ignore\\n                    if iszero(lt(data, end)) { break }\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 32 + 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(add(result, decodedLength), 63), not(31)))\\n\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/POAP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\n\\n/// @title Proof of Attendance Photo\\n/// @author Wink Photo\\n\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\nimport \\\"solady/src/utils/Base64.sol\\\";\\nimport \\\"solmate/src/auth/Owned.sol\\\";\\nimport \\\"solmate/src/tokens/ERC721.sol\\\";\\n\\nerror POAP_BadInput();\\nerror POAP_Forbidden();\\nerror POAP_Soulbound();\\n\\ncontract POAP is ERC721(\\\"Proof of Attendance Photo\\\", \\\"POAP\\\"), ERC2981, Owned {\\n    // The number of tokens that currently exists\\n    uint256 private totalSupply_;\\n\\n    // The number of collections that currently exists\\n    uint256 public numberOfCollections;\\n\\n    // Only the operator can mint tokens\\n    address private operator;\\n\\n    // Collection titles, expensive strings\\n    mapping(uint256 => string) private titles;\\n\\n    /**\\n     * @notice Packed metadata for collections\\n     *\\n     * - `soulbound`: tokens will be non-transferable if set to true\\n     * - `burnable`: tokens can be burned if set to true\\n     * - `royaltyReceiver`: see {ERC2981}\\n     * - `feeNumerator`: see {ERC2981}\\n     */\\n    struct Collection {\\n        bool soulbound;\\n        bool burnable;\\n        address royaltyReceiver;\\n        uint80 royaltyFraction;\\n    }\\n\\n    // Store collection metadata\\n    mapping(uint256 => Collection) private collections;\\n\\n    // Mapping tokens to collections\\n    mapping(uint256 => uint256) private collectionOfTokens;\\n\\n    /**\\n     * @notice Mapping tokens to IPFS CIDs\\n     * @dev We do not use bytes32 here since these are CIDv1 IDs. But yeah,\\n     * this is not cheap.\\n     */\\n    mapping(uint256 => string) private cids;\\n\\n    // Base URI\\n    string private baseURI = \\\"ipfs://\\\";\\n\\n    // External URL\\n    string private externalURL = \\\"https://wink.photo\\\";\\n\\n    // Metadata description\\n    string private description;\\n\\n    /**\\n     * @notice Constructooooooor\\n     */\\n    constructor(address _operator) Owned(msg.sender) {\\n        operator = _operator;\\n    }\\n\\n    /**\\n     * @notice Reverts if the queried token does not exist\\n     */\\n    modifier exists(uint256 _tokenId) {\\n        if (_ownerOf[_tokenId] == address(0)) revert POAP_BadInput();\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Reverts if the caller is not the operator\\n     */\\n    modifier onlyOperator() {\\n        if (msg.sender != operator) revert POAP_Forbidden();\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Update operator address\\n     */\\n    function setOperator(address _operator) external onlyOwner {\\n        if (_operator == address(0)) revert POAP_BadInput();\\n\\n        operator = _operator;\\n    }\\n\\n    /**\\n     * @notice See {ERC2981}\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n        public\\n        view\\n        override\\n        exists(_tokenId)\\n        returns (address, uint256)\\n    {\\n        uint256 collectionId = collectionOfTokens[_tokenId];\\n        Collection memory collection = collections[collectionId];\\n\\n        if (collection.royaltyReceiver == address(0)) {\\n            return (address(0), 0);\\n        } else {\\n            uint256 royaltyAmount = (_salePrice * collection.royaltyFraction) / _feeDenominator();\\n            return (collection.royaltyReceiver, royaltyAmount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Just in case\\n     */\\n    function setBaseURI(string calldata _baseURI) external onlyOwner {\\n        if (bytes(_baseURI).length == 0) revert POAP_BadInput();\\n\\n        baseURI = _baseURI;\\n    }\\n\\n    /**\\n     * @notice Update metadata {external_url}\\n     */\\n    function setExternalURL(string calldata _externalURL) external onlyOwner {\\n        externalURL = _externalURL;\\n    }\\n\\n    /**\\n     * @notice Update metadata {description}\\n     */\\n    function setDescription(string calldata _description) external onlyOwner {\\n        description = _description;\\n    }\\n\\n    /**\\n     * @notice Create a new collection\\n     */\\n    function createCollection(\\n        string calldata _title,\\n        bool _soulbound,\\n        bool _burnable,\\n        address _royaltyReceiver,\\n        uint80 _royaltyFraction\\n    ) external onlyOperator returns (uint256) {\\n        if (bytes(_title).length == 0) revert POAP_BadInput();\\n\\n        uint256 collectionId = ++numberOfCollections;\\n        titles[collectionId] = _title;\\n        collections[collectionId] = Collection({\\n            soulbound: _soulbound,\\n            burnable: _burnable,\\n            royaltyReceiver: _royaltyReceiver,\\n            royaltyFraction: _royaltyFraction\\n        });\\n\\n        return numberOfCollections;\\n    }\\n\\n    /**\\n     * @notice Update collection settings\\n     */\\n    function setCollection(\\n        uint256 _collectionId,\\n        string calldata _title,\\n        bool _soulbound,\\n        bool _burnable,\\n        address _royaltyReceiver,\\n        uint80 _royaltyFraction\\n    ) external onlyOperator {\\n        if (bytes(_title).length == 0) revert POAP_BadInput();\\n        if (bytes(titles[_collectionId]).length == 0) revert POAP_BadInput();\\n\\n        titles[_collectionId] = _title;\\n        collections[_collectionId] = Collection({\\n            soulbound: _soulbound,\\n            burnable: _burnable,\\n            royaltyReceiver: _royaltyReceiver,\\n            royaltyFraction: _royaltyFraction\\n        });\\n    }\\n\\n    /**\\n     * @notice Mint tokens with deterministic IDs\\n     */\\n    function mint(\\n        address _to,\\n        uint256 _tokenId,\\n        uint256 _collectionId,\\n        string calldata _cid\\n    ) external payable onlyOperator {\\n        if (bytes(titles[_collectionId]).length == 0) revert POAP_BadInput();\\n        if (_ownerOf[_tokenId] != address(0)) revert POAP_BadInput();\\n\\n        collectionOfTokens[_tokenId] = _collectionId;\\n        cids[_tokenId] = _cid;\\n        _safeMint(_to, _tokenId);\\n        totalSupply_++;\\n    }\\n\\n    /**\\n     * @notice See {ERC721}\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    ) public override {\\n        if (collections[collectionOfTokens[_tokenId]].soulbound) revert POAP_Soulbound();\\n\\n        ERC721.transferFrom(_from, _to, _tokenId);\\n    }\\n\\n    /**\\n     * @notice Burn a token if it's burnable\\n     */\\n    function burn(uint256 _tokenId) external exists(_tokenId) {\\n        if (msg.sender != _ownerOf[_tokenId]) revert POAP_Forbidden();\\n        if (!collections[collectionOfTokens[_tokenId]].burnable) revert POAP_Forbidden();\\n\\n        _ownerOf[_tokenId] = address(0);\\n        delete collectionOfTokens[_tokenId];\\n        delete cids[_tokenId];\\n        totalSupply_--;\\n\\n        emit Transfer(msg.sender, address(0), _tokenId);\\n    }\\n\\n    /**\\n     * @notice See {ERC721Metadata}\\n     */\\n    function tokenURI(uint256 _tokenId) public view override exists(_tokenId) returns (string memory) {\\n        string memory shortHash = _tokenShortHash(_tokenId);\\n        uint256 collectionId = collectionOfTokens[_tokenId];\\n        Collection memory c = collections[collectionId];\\n\\n        /* prettier-ignore */\\n        string memory encoded = Base64.encode(bytes(string(abi.encodePacked(\\n            /* solhint-disable */\\n            '{\\\"name\\\":\\\"', titles[collectionId], ' #', shortHash, '\\\",\\\"image\\\":\\\"', imageURL(_tokenId), '\\\",',\\n            '\\\"external_url\\\":\\\"', externalURL, '\\\",\\\"description\\\":\\\"', description, '\\\",',\\n            '\\\"attributes\\\":[{\\\"trait_type\\\":\\\"Collection\\\",\\\"value\\\":\\\"', titles[collectionId], '\\\"}',\\n            c.soulbound ? ',{\\\"value\\\":\\\"Soulbound\\\"}' : '', c.burnable ? ',{\\\"value\\\":\\\"Burnable\\\"}' : '', ']}'\\n            /* solhint-enable */\\n        ))));\\n\\n        return string(abi.encodePacked(\\\"data:application/json;base64,\\\", encoded));\\n    }\\n\\n    /**\\n     * @notice See {ERC721Enumerable}\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    /**\\n     * @notice Query a collection title\\n     */\\n    function getCollectionTitle(uint256 _collectionId) public view returns (string memory) {\\n        return titles[_collectionId];\\n    }\\n\\n    /**\\n     * @notice Query a collection title\\n     */\\n    function getCollection(uint256 _collectionId) public view returns (Collection memory) {\\n        return collections[_collectionId];\\n    }\\n\\n    /**\\n     * @notice See {ERC165}\\n     */\\n    function supportsInterface(bytes4 _interfaceId) public view override(ERC721, ERC2981) returns (bool) {\\n        return ERC721.supportsInterface(_interfaceId) || ERC2981.supportsInterface(_interfaceId);\\n    }\\n\\n    /**\\n     * @notice Convert bytes to its HEX representation in strings\\n     */\\n    function _bytesToHex(bytes memory buffer) internal pure returns (string memory) {\\n        bytes memory converted = new bytes(buffer.length * 2);\\n        bytes memory _base = \\\"0123456789abcdef\\\";\\n\\n        for (uint256 i = 0; i < buffer.length; i++) {\\n            converted[i * 2] = _base[uint8(buffer[i]) / _base.length];\\n            converted[i * 2 + 1] = _base[uint8(buffer[i]) % _base.length];\\n        }\\n\\n        return string(abi.encodePacked(\\\"0x\\\", converted));\\n    }\\n\\n    /**\\n     * @notice Returns URLs to access token images via IPFS\\n     */\\n    function imageURL(uint256 _tokenId) public view exists(_tokenId) returns (string memory) {\\n        if (bytes(cids[_tokenId]).length == 0) return \\\"\\\";\\n\\n        return string(abi.encodePacked(baseURI, cids[_tokenId]));\\n    }\\n\\n    /**\\n     * @notice Give tokens a short name\\n     */\\n    function _tokenShortHash(uint256 _tokenId) internal pure returns (string memory) {\\n        bytes memory tokenIdInBytes = new bytes(32);\\n\\n        assembly {\\n            mstore(add(tokenIdInBytes, 32), _tokenId)\\n        }\\n\\n        string memory hexString = _bytesToHex(tokenIdInBytes);\\n        bytes memory hexStringInBytes = bytes(hexString);\\n        bytes memory shortHash = new bytes(6);\\n\\n        for (uint256 i = 0; i < 6; i++) {\\n            shortHash[i] = hexStringInBytes[hexStringInBytes.length - 6 + i];\\n        }\\n\\n        return string(shortHash);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"POAP_BadInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"POAP_Forbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"POAP_Soulbound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_title\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_soulbound\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_burnable\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"_royaltyFraction\",\"type\":\"uint80\"}],\"name\":\"createCollection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collectionId\",\"type\":\"uint256\"}],\"name\":\"getCollection\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"soulbound\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"burnable\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"royaltyFraction\",\"type\":\"uint80\"}],\"internalType\":\"struct POAP.Collection\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collectionId\",\"type\":\"uint256\"}],\"name\":\"getCollectionTitle\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"imageURL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collectionId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_cid\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfCollections\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collectionId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_title\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_soulbound\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_burnable\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"_royaltyFraction\",\"type\":\"uint80\"}],\"name\":\"setCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"setDescription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_externalURL\",\"type\":\"string\"}],\"name\":\"setExternalURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "POAP", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1337", "ConstructorArguments": "0000000000000000000000006e08ffbe133cc982ed3faa345e812f1fa65a0af5", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}