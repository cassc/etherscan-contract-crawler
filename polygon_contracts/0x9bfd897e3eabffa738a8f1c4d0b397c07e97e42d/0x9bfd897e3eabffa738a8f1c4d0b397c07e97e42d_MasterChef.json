{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n\n// \n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary SafeMath16 {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint16 a, uint16 b) internal pure returns (uint16) {\n        uint16 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint16 a, uint16 b, string memory errorMessage) internal pure returns (uint16) {\n        require(b <= a, errorMessage);\n        uint16 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint16 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint16 a, uint16 b) internal pure returns (uint16) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint16 a, uint16 b, string memory errorMessage) internal pure returns (uint16) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint16 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint16 a, uint16 b) internal pure returns (uint16) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint16 a, uint16 b, string memory errorMessage) internal pure returns (uint16) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// \n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// \n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// \ninterface IBEP20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address _owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// \n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// \n/**\n * @title SafeBEP20\n * @dev Wrappers around BEP20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeBEP20 for IBEP20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeBEP20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IBEP20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IBEP20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IBEP20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IBEP20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeBEP20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IBEP20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IBEP20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeBEP20: decreased allowance below zero\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeBEP20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\");\n        }\n    }\n}\n\n// \n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2\u03c0.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n\n  /// @dev counter to allow mutex lock with only one SSTORE operation\n  uint256 private _guardCounter = 1;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * If you mark a function `nonReentrant`, you should also\n   * mark it `external`. Calling one `nonReentrant` function from\n   * another is not supported. Instead, you can implement a\n   * `private` function doing the actual work, and an `external`\n   * wrapper marked as `nonReentrant`.\n   */\n  modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n  }\n\n}\n\n// \n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n\n// \n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// \n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// \n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override virtual returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if(!hasRole(role, account)) {\n            revert(string(abi.encodePacked(\n                \"AccessControl: account \",\n                Strings.toHexString(uint160(account), 20),\n                \" is missing role \",\n                Strings.toHexString(uint256(role), 32)\n            )));\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n// \ncontract ReferralStorage is AccessControl {\n    using SafeMath for uint256;\n    \n    bytes32 public constant WRITE_ACCESS = keccak256(\"WRITE_ACCESS\");\n\n    /**\n     * @dev Max referral level depth\n     */\n    uint8 constant MAX_REFER_DEPTH = 3;\n\n    /**\n     * @dev The struct of account information\n     * @param referrer The referrer addresss\n     * @param reward The total referral reward of an address\n     * @param referredCount The total referral amount of an address\n     * @param lastActiveTimestamp The last active timestamp of an address\n     */\n    struct Account {\n        address payable referrer;\n        uint256 reward;\n        uint256 referredCount;\n        uint256 lastActiveTimestamp;\n        address[] referrals;\n    }\n    \n    struct ReferralsCount {\n        uint256 level_1;\n        uint256 level_2;\n        uint256 level_3;\n    }\n\n    event RegisteredReferer(address referee, address referrer);\n    event RegisteredRefererFailed(\n        address referee,\n        address referrer,\n        string reason\n    );\n\n    // Update value events\n    event UpdateTotalReward(address accountAddress, uint256 amount);\n    event UpdateLastActive(address referrer, uint256 timestamp);\n\n    mapping(address => Account) public accounts;\n    \n    address admin;\n    \n      /**\n     * @dev Throws if called by any account other than the admin.\n     */\n    modifier onlyAdmin() {\n        require(isAdmin(), \"Only Admin: caller is not the admin\");\n        _;\n    }\n    \n    modifier onlyWriters() {\n        require(hasRole(WRITE_ACCESS, _msgSender()), \"Only Writer: caller is not a writer\");\n        _;\n    }\n    \n    constructor() public {\n        // Admin of contract is by default the deployer\n        admin = _msgSender();\n    }\n\n    /**\n     * @dev Utils function for check whether an address has the referrer\n     */\n    function hasReferrer(address addr) public view returns (bool) {\n        return accounts[addr].referrer != address(0);\n    }\n\n    /**\n     * @dev Add an address as referrer\n     * @param referrer The address would set as referrer of msg.sender\n     * @return whether success to add upline\n     */\n    function addReferrer(address referee, address payable referrer, uint256 levels) external onlyWriters returns (bool) {\n        require(levels <= MAX_REFER_DEPTH, \"Levels: Greater dan max referral depth\");\n        \n        if (referrer == address(0)) {\n            emit RegisteredRefererFailed(\n                referee,\n                referrer,\n                \"Referrer cannot be 0x0 address\"\n            );\n            return false;\n        } else if (levels > 1 && isCircularReference(referrer, referee, levels)) {\n            emit RegisteredRefererFailed(\n                referee,\n                referrer,\n                \"Referee cannot be one of referrer uplines (circular referrer)\"\n            );\n            return false;\n        } else if (hasReferrer(referee)) {\n            emit RegisteredRefererFailed(\n                referee,\n                referrer,\n                \"Sender is already referred by someone else\"\n            );\n            return false;\n        }\n\n        Account storage userAccount = accounts[referee];\n        Account storage parentAccount = accounts[referrer];\n\n        userAccount.referrer = referrer;\n        userAccount.lastActiveTimestamp = getTime();\n        parentAccount.referredCount = parentAccount.referredCount.add(1);\n        parentAccount.referrals.push(referee);\n\n        emit RegisteredReferer(referee, referrer);\n        return true;\n    }\n\n    function isCircularReference(address referrer, address referee, uint256 levels)\n        internal\n        view\n        returns (bool)\n    {\n        address parent = referrer;\n\n        for (uint256 i; i < levels; i++) {\n            if (parent == address(0)) {\n                break;\n            }\n\n            if (parent == referee) {\n                return true;\n            }\n\n            parent = accounts[parent].referrer;\n        }\n\n        return false;\n    }\n    \n    function getReferralAccount(address referrer) external view returns (Account memory) {\n        return accounts[referrer];\n    }\n    \n    function getReferralCounts(address referrerAddress) external view returns (ReferralsCount memory) {\n        address[] memory referrals = getReferrals(referrerAddress);\n        ReferralsCount memory counts;\n        \n        if(referrals.length == 0) { return counts; }\n        \n        counts.level_1 = counts.level_1.add(referrals.length);\n        \n        for(uint256 i = 0; i < referrals.length; i++) {\n            address[] memory level2 = getReferrals(referrals[i]);\n            counts.level_2 = counts.level_2.add(level2.length);\n            \n            if(level2.length == 0) { continue; }\n            \n            for(uint256 j = 0; j < level2.length; j++) {\n                address[] memory level3 = getReferrals(level2[j]);\n                counts.level_3 = counts.level_3.add(level3.length);\n            }\n        }\n        \n        return counts;\n    }\n    \n    function getReferrals(address referrerAddress) internal view returns (address[] memory) {\n        return accounts[referrerAddress].referrals;\n    }\n    \n    function setAccountLastActive(address referrer) external onlyWriters {\n        uint256 time = getTime();\n        accounts[referrer].lastActiveTimestamp = time;\n        emit UpdateLastActive(referrer, time);\n    }\n\n    function setAccountReward(address accountAddress, uint256 _totalReward) external onlyWriters {\n        accounts[accountAddress].reward = _totalReward;\n        emit UpdateTotalReward(accountAddress, _totalReward);\n    }\n    \n    function addWriter(address _address) external onlyAdmin {\n        require(_address != address(0), \"_address: ZERO_ADDRESS\");\n        _setupRole(WRITE_ACCESS, _address);\n    }\n    \n    /**\n     * @dev Returns true if the caller is the current admin.\n     */\n    function isWriter() public view returns (bool) {\n        return hasRole(WRITE_ACCESS, _msgSender());\n    }\n    \n    function setAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"_newAdmin: ZERO_ADDRESS\");\n        admin = _newAdmin;\n    }\n    \n    /**\n     * @dev Returns true if the caller is the current admin.\n     */\n    function isAdmin() public view returns (bool) {\n        return _msgSender() == admin;\n    }\n    \n      /**\n   * @dev Get block timestamp with function for testing mock\n   */\n  function getTime() public view returns(uint256) {\n    return now; // solium-disable-line security/no-block-members\n  }\n}\n\n// \n/**\n * @dev Implementation of the {IBEP20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {BEP20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-BEP20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of BEP20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IBEP20-approve}.\n */\ncontract BEP20 is Context, IBEP20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external override view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() public override view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() public override view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() public override view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) public override view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {BEP20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-allowance}.\n     */\n    function allowance(address owner, address spender) public override view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {BEP20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {BEP20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\n     * the total supply.\n     *\n     * Requirements\n     *\n     * - `msg.sender` must be the token owner\n     */\n    function mint(uint256 amount) public onlyOwner returns (bool) {\n        _mint(_msgSender(), amount);\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"BEP20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"BEP20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"BEP20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(\n            account,\n            _msgSender(),\n            _allowances[account][_msgSender()].sub(amount, \"BEP20: burn amount exceeds allowance\")\n        );\n    }\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\n// \n// GemstoneToken with Governance.\ncontract GemstoneToken is BEP20 {\n    \n    using SafeMath for uint256;\n\n    // Transfer tax rate in basis points. (default 5%)\n    uint16 public transferTaxRate = 0;\n    // Burn rate % of transfer tax. (default 20% x 5% = 1% of total amount).\n    uint16 public burnRate = 20;\n    // Max transfer tax rate: 10%.\n    uint16 public constant MAXIMUM_TRANSFER_TAX_RATE = 1000;\n    // Track how many GEMS have been burned\n    uint256 public burnedAmount;\n\n    // Max transfer amount rate in basis points. (default is 0.5% of total supply)\n    uint16 public maxTransferAmountRate = 50;\n    // Addresses that excluded from antiWhale\n    mapping(address => bool) private _excludedFromAntiWhale;\n    // Automatic swap and liquify enabled\n    bool public swapAndLiquifyEnabled = false;\n    // Min amount to liquify. (default 500 Gemstones)\n    uint256 public minAmountToLiquify = 500 ether;\n    // The swap router, modifiable. Will be changed to GemstoneSwap's router when our own AMM release\n    IUniswapV2Router02 public GemstoneSwapRouter;\n    // The trading pair\n    address public GemstoneSwapPair;\n    // In swap and liquify\n    bool private _inSwapAndLiquify;\n\n    // The operator can only update the transfer tax rate\n    address private _operator;\n\n    // Events\n    event OperatorTransferred(address indexed previousOperator, address indexed newOperator);\n    event TransferTaxRateUpdated(address indexed operator, uint256 previousRate, uint256 newRate);\n    event BurnRateUpdated(address indexed operator, uint256 previousRate, uint256 newRate);\n    event MaxTransferAmountRateUpdated(address indexed operator, uint256 previousRate, uint256 newRate);\n    event SwapAndLiquifyEnabledUpdated(address indexed operator, bool enabled);\n    event MinAmountToLiquifyUpdated(address indexed operator, uint256 previousAmount, uint256 newAmount);\n    event GemstoneSwapRouterUpdated(address indexed operator, address indexed router, address indexed pair);\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiqudity);\n\n    modifier onlyOperator() {\n        require(_operator == msg.sender, \"operator: caller is not the operator\");\n        _;\n    }\n\n    modifier antiWhale(address sender, address recipient, uint256 amount) {\n        if (maxTransferAmount() > 0) {\n            if (!_excludedFromAntiWhale[sender] && !_excludedFromAntiWhale[recipient]) {\n                require(amount <= maxTransferAmount(), \"Gemstone::antiWhale: Transfer amount exceeds the maxTransferAmount\");\n            }\n        }\n        _;\n    }\n\n    modifier lockTheSwap {\n        _inSwapAndLiquify = true;\n        _;\n        _inSwapAndLiquify = false;\n    }\n\n    modifier transferTaxFree {\n        uint16 _transferTaxRate = transferTaxRate;\n        transferTaxRate = 0;\n        _;\n        transferTaxRate = _transferTaxRate;\n    }\n\n    /**\n     * @notice Constructs the GemstoneToken contract.\n     */\n    constructor() public BEP20(\"Gemstones\", \"GMS\") {\n        _operator = _msgSender();\n        emit OperatorTransferred(address(0), _operator);\n\n        _excludedFromAntiWhale[msg.sender] = true;\n        _excludedFromAntiWhale[address(0)] = true;\n        _excludedFromAntiWhale[address(this)] = true;\n    }\n\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\n    function mint(address _to, uint256 _amount) public onlyOwner {\n        _mint(_to, _amount);\n        _moveDelegates(address(0), _delegates[_to], _amount);\n    }\n\n    function _burn(address sender, uint256 amount) internal virtual override {\n        burnedAmount = burnedAmount.add(amount);\n        super._burn(sender, amount);\n    }\n\n    /// @dev overrides transfer function to meet tokenomics of Gemstone\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override antiWhale(sender, recipient, amount) {\n        // swap and liquify\n        if (\n            swapAndLiquifyEnabled == true\n            && _inSwapAndLiquify == false\n            && address(GemstoneSwapRouter) != address(0)\n            && GemstoneSwapPair != address(0)\n            && sender != GemstoneSwapPair\n            && sender != owner()\n        ) {\n            swapAndLiquify();\n        }\n\n        if (recipient == address(0)) {\n            _burn(sender, amount);\n        } else if(transferTaxRate == 0) {\n            super._transfer(sender, recipient, amount);\n        } else {\n            // default tax is 5% of every transfer\n            uint256 taxAmount = amount.mul(transferTaxRate).div(10000);\n            uint256 burnAmount = taxAmount.mul(burnRate).div(100);\n            uint256 liquidityAmount = taxAmount.sub(burnAmount);\n            require(taxAmount == burnAmount + liquidityAmount, \"Gemstone::transfer: Burn value invalid\");\n\n            // default 95% of transfer sent to recipient\n            uint256 sendAmount = amount.sub(taxAmount);\n            require(amount == sendAmount + taxAmount, \"Gemstone::transfer: Tax value invalid\");\n\n            _burn(sender, burnAmount);\n\n            super._transfer(sender, address(this), liquidityAmount);\n            super._transfer(sender, recipient, sendAmount);\n            amount = sendAmount;\n        }\n    }\n\n    /// @dev Swap and liquify\n    function swapAndLiquify() private lockTheSwap transferTaxFree {\n        uint256 contractTokenBalance = balanceOf(address(this));\n        uint256 maxTransferAmount = maxTransferAmount();\n        contractTokenBalance = contractTokenBalance > maxTransferAmount ? maxTransferAmount : contractTokenBalance;\n\n        if (contractTokenBalance >= minAmountToLiquify) {\n            // only min amount to liquify\n            uint256 liquifyAmount = minAmountToLiquify;\n\n            // split the liquify amount into halves\n            uint256 half = liquifyAmount.div(2);\n            uint256 otherHalf = liquifyAmount.sub(half);\n\n            // capture the contract's current ETH balance.\n            // this is so that we can capture exactly the amount of ETH that the\n            // swap creates, and not make the liquidity event include any ETH that\n            // has been manually sent to the contract\n            uint256 initialBalance = address(this).balance;\n\n            // swap tokens for ETH\n            swapTokensForEth(half);\n\n            // how much ETH did we just swap into?\n            uint256 newBalance = address(this).balance.sub(initialBalance);\n\n            // add liquidity\n            addLiquidity(otherHalf, newBalance);\n\n            emit SwapAndLiquify(half, newBalance, otherHalf);\n        }\n    }\n\n    /// @dev Swap tokens for eth\n    function swapTokensForEth(uint256 tokenAmount) private {\n        // generate the GemstoneSwap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = GemstoneSwapRouter.WETH();\n\n        _approve(address(this), address(GemstoneSwapRouter), tokenAmount);\n\n        // make the swap\n        GemstoneSwapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    /// @dev Add liquidity\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n        // approve token transfer to cover all possible scenarios\n        _approve(address(this), address(GemstoneSwapRouter), tokenAmount);\n\n        // add the liquidity\n        GemstoneSwapRouter.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            operator(),\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Returns the max transfer amount.\n     */\n    function maxTransferAmount() public view returns (uint256) {\n        return totalSupply().mul(maxTransferAmountRate).div(10000);\n    }\n\n    /**\n     * @dev Returns the address is excluded from antiWhale or not.\n     */\n    function isExcludedFromAntiWhale(address _account) public view returns (bool) {\n        return _excludedFromAntiWhale[_account];\n    }\n\n    // To receive BNB from GemstoneSwapRouter when swapping\n    receive() external payable {}\n\n    /**\n     * @dev Update the transfer tax rate.\n     * Can only be called by the current operator.\n     */\n    function updateTransferTaxRate(uint16 _transferTaxRate) public onlyOperator {\n        require(_transferTaxRate <= MAXIMUM_TRANSFER_TAX_RATE, \"Gemstone::updateTransferTaxRate: Transfer tax rate must not exceed the maximum rate.\");\n        emit TransferTaxRateUpdated(msg.sender, transferTaxRate, _transferTaxRate);\n        transferTaxRate = _transferTaxRate;\n    }\n\n    /**\n     * @dev Update the burn rate.\n     * Can only be called by the current operator.\n     */\n    function updateBurnRate(uint16 _burnRate) public onlyOperator {\n        require(_burnRate <= 100, \"Gemstone::updateBurnRate: Burn rate must not exceed the maximum rate.\");\n        emit BurnRateUpdated(msg.sender, burnRate, _burnRate);\n        burnRate = _burnRate;\n    }\n\n    /**\n     * @dev Update the max transfer amount rate.\n     * Can only be called by the current operator.\n     */\n    function updateMaxTransferAmountRate(uint16 _maxTransferAmountRate) public onlyOperator {\n        require(_maxTransferAmountRate <= 10000, \"Gemstone::updateMaxTransferAmountRate: Max transfer amount rate must not exceed the maximum rate.\");\n        emit MaxTransferAmountRateUpdated(msg.sender, maxTransferAmountRate, _maxTransferAmountRate);\n        maxTransferAmountRate = _maxTransferAmountRate;\n    }\n\n    /**\n     * @dev Update the min amount to liquify.\n     * Can only be called by the current operator.\n     */\n    function updateMinAmountToLiquify(uint256 _minAmount) public onlyOperator {\n        emit MinAmountToLiquifyUpdated(msg.sender, minAmountToLiquify, _minAmount);\n        minAmountToLiquify = _minAmount;\n    }\n\n    /**\n     * @dev Exclude or include an address from antiWhale.\n     * Can only be called by the current operator.\n     */\n    function setExcludedFromAntiWhale(address _account, bool _excluded) public onlyOperator {\n        _excludedFromAntiWhale[_account] = _excluded;\n    }\n\n    /**\n     * @dev Update the swapAndLiquifyEnabled.\n     * Can only be called by the current operator.\n     */\n    function updateSwapAndLiquifyEnabled(bool _enabled) public onlyOperator {\n        emit SwapAndLiquifyEnabledUpdated(msg.sender, _enabled);\n        swapAndLiquifyEnabled = _enabled;\n    }\n\n    /**\n     * @dev Update the swap router.\n     * Can only be called by the current operator.\n     */\n    function updateGemstoneSwapRouter(address _router) public onlyOperator {\n        GemstoneSwapRouter = IUniswapV2Router02(_router);\n        GemstoneSwapPair = IUniswapV2Factory(GemstoneSwapRouter.factory()).getPair(address(this), GemstoneSwapRouter.WETH());\n        require(GemstoneSwapPair != address(0), \"Gemstone::updateGemstoneSwapRouter: Invalid pair address.\");\n        emit GemstoneSwapRouterUpdated(msg.sender, address(GemstoneSwapRouter), GemstoneSwapPair);\n    }\n\n    /**\n     * @dev Returns the address of the current operator.\n     */\n    function operator() public view returns (address) {\n        return _operator;\n    }\n\n    /**\n     * @dev Transfers operator of the contract to a new account (`newOperator`).\n     * Can only be called by the current operator.\n     */\n    function transferOperator(address newOperator) public onlyOperator {\n        require(newOperator != address(0), \"Gemstone::transferOperator: new operator is the zero address\");\n        emit OperatorTransferred(_operator, newOperator);\n        _operator = newOperator;\n    }\n\n    // Copied and modified from YAM code:\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\n    // Which is copied and modified from COMPOUND:\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n    /// @dev A record of each accounts delegate\n    mapping (address => address) internal _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n      /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator)\n        external\n        view\n        returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n   /**\n    * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Gemstone::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Gemstone::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"Gemstone::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \"Gemstone::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n        internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying Gemstones (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n        internal\n    {\n        uint32 blockNumber = safe32(block.number, \"Gemstone::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n\n    function safeTransfer(address _to, uint256 _amount) external {\n        uint256 bal = balanceOf(address(msg.sender));\n        if (_amount > bal) {\n            _transfer(msg.sender, _to, bal);\n        } else {\n            _transfer(msg.sender, _to, _amount);\n        } \n    }\n\n    function safeTransferFrom(address _from, address _to, uint256 _amount) external {\n        uint256 bal = balanceOf(address(_from));\n        if (_amount > bal) {\n            transferFrom(_from, _to, bal);\n        } else {\n            transferFrom(_from, _to, _amount);\n        } \n    }\n}\n\n// \ncontract Referral is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Max referral level depth\n     */\n    uint8 constant MAX_REFER_DEPTH = 3;\n\n    /**\n     * @dev Max referee amount to bonus rate depth\n     */\n    uint8 constant MAX_REFEREE_BONUS_LEVEL = 3;\n    \n    /*\n     * @dev Minimum time before 'inactivity' can be triggered\n     */\n    uint256 constant MIN_ACTIVITY_TIMEOUT = 1 days;\n\n    /**\n     * @dev The struct of account information\n     * @param referrer The referrer addresss\n     * @param reward The total referral reward of an address\n     * @param referredCount The total referral amount of an address\n     * @param lastActiveTimestamp The last active timestamp of an address\n     */\n    struct Account {\n        address payable referrer;\n        uint256 reward;\n        uint256 referredCount;\n        uint256 lastActiveTimestamp;\n    }\n\n    /**\n     * @dev The struct of referee amount to bonus rate\n     * @param lowerBound The minial referee amount\n     * @param rate The bonus rate for each referee amount\n     */\n    struct RefereeBonusRate {\n        uint256 lowerBound;\n        uint256 rate;\n    }\n\n    event PaidReferral(address from, address to, uint256 amount, uint256 level);\n    event UpdatedUserLastActiveTime(address user, uint256 timestamp);\n    event SetOnlyRewardActiveReferrers(bool boolean);\n    event SetReferralDistribution(uint256[] levelRates);\n    event SetReferralPercentage(uint256 percentage);\n    event SetReferralsEnabled(bool enabled);\n\n    uint256[] levelRate;\n    uint256 decimals;\n    uint256 secondsUntilInactive;\n    bool onlyRewardActiveReferrers;\n    RefereeBonusRate[] refereeBonusRateMap;\n    ReferralStorage referralStorage;\n\n    uint16 public referralCutPercentage = 100; // 1% by default\n\n    GemstoneToken public gemstones;\n\n    // referralsEnabled by default\n    bool referralsEnabled = true;\n\n    /**\n     * @param _decimals The base decimals for float calc, for example 1000\n     * @param _secondsUntilInactive The seconds that a user does not update will be seen as inactive.\n     * @param _onlyRewardActiveReferrers The flag to enable not paying to inactive uplines.\n     * @param _levelRate The bonus rate for each level, which will divide by decimals too. The max depth is MAX_REFER_DEPTH.\n     * @param _refereeBonusRateMap The bonus rate mapping to each referree amount, which will divide by decimals too. The max depth is MAX_REFER_DEPTH.\n     * The map should be pass as [<lower amount>, <rate>, ....]. For example, you should pass [1, 250, 5, 500, 10, 1000] when decimals is 1000 for the following case.\n     *\n     *  25%     50%     100%\n     *   | ----- | ----- |----->\n     *  1ppl    5ppl    10ppl\n     *\n     * @notice refereeBonusRateMap's lower amount should be ascending\n     */\n    constructor(\n        GemstoneToken _gemstones,\n        uint256 _decimals,\n        uint256 _secondsUntilInactive,\n        bool _onlyRewardActiveReferrers,\n        uint256[] memory _levelRate,\n        uint256[] memory _refereeBonusRateMap,\n        ReferralStorage _referralStorage\n    ) public {\n        require(_levelRate.length > 0, \"Referral level should be at least one\");\n        require(\n            _levelRate.length <= MAX_REFER_DEPTH,\n            \"Exceeded max referral level depth\"\n        );\n        require(\n            _refereeBonusRateMap.length % 2 == 0,\n            \"Referee Bonus Rate Map should be pass as [<lower amount>, <rate>, ....]\"\n        );\n        require(\n            _refereeBonusRateMap.length / 2 <= MAX_REFEREE_BONUS_LEVEL,\n            \"Exceeded max referree bonus level depth\"\n        );\n        require(sum(_levelRate) <= _decimals, \"Total level rate exceeds 100%\");\n\n        gemstones = _gemstones;\n        decimals = _decimals;\n        secondsUntilInactive = _secondsUntilInactive;\n        onlyRewardActiveReferrers = _onlyRewardActiveReferrers;\n        levelRate = _levelRate;\n        referralStorage = _referralStorage;\n\n        // Set default referee amount rate as 1ppl -> 100% if rate map is empty.\n        if (_refereeBonusRateMap.length == 0) {\n            refereeBonusRateMap.push(RefereeBonusRate(1, decimals));\n            return;\n        }\n\n        for (uint256 i; i < _refereeBonusRateMap.length; i += 2) {\n            if (_refereeBonusRateMap[i + 1] > decimals) {\n                revert(\"One of referee bonus rate exceeds 100%\");\n            }\n            // Cause we can't pass struct or nested array without enabling experimental ABIEncoderV2, use array to simulate it\n            refereeBonusRateMap.push(\n                RefereeBonusRate(\n                    _refereeBonusRateMap[i],\n                    _refereeBonusRateMap[i + 1]\n                )\n            );\n        }\n    }\n\n    function sum(uint256[] memory data) public pure returns (uint256) {\n        uint256 S;\n        for (uint256 i; i < data.length; i++) {\n            S += data[i];\n        }\n        return S;\n    }\n\n    /**\n     * @dev Add an address as referrer\n     * @param referrer The address would set as referrer of msg.sender\n     * @return whether success to add upline\n     */\n    function addReferrer(address referee, address payable referrer)\n        internal\n        returns (bool)\n    {\n        require(referralsEnabled, \"Referral System Disabled\");\n        return referralStorage.addReferrer(referee, referrer, levelRate.length);\n    }\n\n    /**\n     * @dev Check if the caller has a referrer\n     */\n    function hasReferrer() public view returns (bool) {\n        return hasReferrer(msg.sender);\n    }\n\n    /**\n     * @dev Check whether a specific address has a referrer\n     * @param _address Address to check for\n     */\n    function hasReferrer(address _address) public view returns (bool) {\n        return referralStorage.hasReferrer(_address);\n    }\n\n    /**\n     * @dev Get block timestamp with function for testing mock\n     */\n    function getTime() public view returns (uint256) {\n        return now; // solium-disable-line security/no-block-members\n    }\n\n    /**\n     * @dev Given a user amount to calc in which rate period\n     * @param amount The number of referrees\n     */\n    function getRefereeBonusRate(uint256 amount) public view returns (uint256) {\n        uint256 rate = refereeBonusRateMap[0].rate;\n        for (uint256 i = 1; i < refereeBonusRateMap.length; i++) {\n            if (amount < refereeBonusRateMap[i].lowerBound) {\n                break;\n            }\n            rate = refereeBonusRateMap[i].rate;\n        }\n        return rate;\n    }\n\n    /**\n     * @dev This will calc and pay referral to uplines instantly\n     * @param value The number tokens will be calculated in referral process\n     * @return the total referral bonus paid\n     */\n    function payReferral(address referee, uint256 value)\n        internal\n        returns (uint256)\n    {\n        require(referralsEnabled, \"Referral System Disabled\");\n\n        // Get Account Reference\n        ReferralStorage.Account memory account = referralStorage.getReferralAccount(referee);\n        address accountAddress = referee;\n\n        uint256 totalReferal;\n\n        for (uint256 i; i < levelRate.length; i++) {\n            // If no address, break from loop\n            if (account.referrer == address(0)) {\n                break;\n            }\n\n            if (\n                (onlyRewardActiveReferrers &&\n                    isReferrerActive(account.referrer)) || !onlyRewardActiveReferrers\n            ) {\n\n                // Overwrite loop values with next 'level' of referral\n                accountAddress = account.referrer;\n                account = referralStorage.getReferralAccount(accountAddress);\n\n                // Calculations for referralcount/referrallevel\n                uint256 c = value;\n                c = c.mul(levelRate[i]).div(decimals);\n                c = c.mul(getRefereeBonusRate(account.referredCount)).div(\n                    decimals\n                );\n\n                // Transfer funds to Parent\n                gemstones.safeTransfer(accountAddress, c);\n\n                // Sum of how much paid to referrals alltogether\n                totalReferal = totalReferal.add(c);\n\n                // Update total Reward\n                referralStorage.setAccountReward(\n                    accountAddress,\n                    account.reward.add(c)\n                );\n\n                // Emit event\n                emit PaidReferral(referee, account.referrer, c, i + 1);\n            }\n        }\n\n        // Return total amount paid to referrals in chain\n        return totalReferal;\n    }\n\n    /**\n     * @dev Transfer Gemstones away from Referral contract if added by accident (not supposed to be called)\n     * @param _amount Amount to transfer away\n     */\n    function transferFunds(uint256 _amount) external onlyOwner {\n        gemstones.safeTransfer(owner(), _amount);\n    }\n\n    /**\n     * @dev Set the inactivity timer for Referrer payout\n     * @param _secondsUntilInactive Seconds until inactivty (min 1 day = 60 * 60 * 24)\n     */\n    function setSecondsUntilInactive(uint256 _secondsUntilInactive)\n        internal\n    {\n        require(_secondsUntilInactive >= MIN_ACTIVITY_TIMEOUT, \"setSecondsUntilInactive: MIN 1 Day\");\n        secondsUntilInactive = _secondsUntilInactive;\n    }\n\n    /**\n     * @dev Check whether the provided address is considered 'active'\n     * @param _accountAddress Boolean indicating whether referrer is 'active' on the platform\n     */\n    function isReferrerActive(address _accountAddress) public view returns (bool) {\n        ReferralStorage.Account memory account = referralStorage.getReferralAccount(_accountAddress);\n        return (account.lastActiveTimestamp.add(secondsUntilInactive) >= getTime());\n    }\n\n    /**\n     * @dev Enable or disable inactivity check for referral payout (if set to 'true', inactive referrals don't get paid)\n     * @param _onlyRewardActiveReferrers Boolean indicating whether referral payout is only paid out to active referrers (default: true)\n     */\n    function setOnlyRewardActiveReferrers(bool _onlyRewardActiveReferrers)\n        external onlyOwner\n    {\n        onlyRewardActiveReferrers = _onlyRewardActiveReferrers;\n        emit SetOnlyRewardActiveReferrers(onlyRewardActiveReferrers);\n    }\n\n    /**\n     * @dev Set the distribution of referral fee between levels (default => 1: 60%, 2: 30%, 3: 10%)\n     * @param _levelRate The distribution per level based on decimals variable in contract (default => [6000, 3000, 1000])\n     */\n    function setReferralDistribution(uint256[] memory _levelRate)\n        external\n        onlyOwner\n    {\n        require(_levelRate.length > 0, \"Referral level should be at least one\");\n        require(\n            _levelRate.length <= MAX_REFER_DEPTH,\n            \"Exceeded max referral level depth\"\n        );\n        require(sum(_levelRate) <= decimals, \"Total level rate exceeds 100%\");\n        \n        // Set the Level rate for ditribution per level\n        levelRate = _levelRate;\n        emit SetReferralDistribution(levelRate);\n    }\n\n    /**\n     * @dev Set the referral cut percentage (default: 1%)\n     * @param _percentage The referral cut percentage payout (default: 100 = 1%)\n     */\n    function setReferralPercentage(uint16 _percentage) external onlyOwner {\n      require(_percentage <= 1000, \"Ref %: MAX 10\");\n      referralCutPercentage = _percentage;\n      emit SetReferralPercentage(referralCutPercentage);\n    }\n\n    /**\n     * @dev Enable or disable the Referral payout\n     * @param _referralsEnabled Boolean indicating whether referral payout is enabled or not (default: true)\n     */\n    function setReferralsEnabled(bool _referralsEnabled) external onlyOwner {\n        referralsEnabled = _referralsEnabled;\n        emit SetReferralsEnabled(referralsEnabled);\n    }\n\n    /**\n     * @dev Read whether Referrals payout is enabled or not\n     * @return whether referral payout is enabled or not (default: true)\n     */\n    function isReferralsEnabled() public view returns (bool) {\n        return referralsEnabled;\n    }\n}\n\n// \n// MasterChef is the master of Gemstones. He can make Gemstones and he is a fair guy.\n//\n// Note that it's ownable and the owner wields tremendous power. The ownership\n// will be transferred to a governance smart contract once GEMSTONES is sufficiently\n// distributed and the community can show to govern itself.\n//\n// Have fun reading it. Hopefully it's bug-free. God bless.\ncontract MasterChef is Referral, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeMath16 for uint16;\n\n    using SafeBEP20 for IBEP20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount;     // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        uint256 rewardLockedUp;  // Reward locked up.\n        uint256 nextHarvestUntil; // When can the user harvest again.\n        uint256 lastdeposit;\n\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IBEP20 lpToken;           // Address of LP token contract.\n        uint256 allocPoint;       // How many allocation points assigned to this pool. GEMs to distribute per block.\n        uint256 lastRewardBlock;  // Last block number that GEMSTONEs distribution occurs.\n        uint256 accGemstonesPerShare; // Accumulated GEMs per share, times 1e12. See below.\n        uint16 depositFee;      // Deposit fee in basis points\n        uint256 harvestInterval;  // Harvest interval in seconds\n        uint256 earlyWithdrawalInterval;   // Early withdraw time in seconds\n        uint256 earlyWithdrawalFee;    // Early withdraw fee in percentage\n        uint16 harvestFee;              // harvest fee in percentage\n    }\n\n    // Fee address (non-gemstone tokens)\n    address public feeAddr;\n    // Gemstone fee address.\n    address public gemstoneFeeAddr;\n    \n    uint256 public totalLockedUpRewards;\n\n    uint256 public gemstonesPerBlock;\n    // Bonus muliplier for early gemstones makers.\n    uint256 public BONUS_MULTIPLIER = 1;\n    \n    // Max harvest interval: 14 days.\n    uint256 public constant MAXIMUM_HARVEST_INTERVAL = 14 days;\n    uint256 public constant MAXIMUM_EARLY_WITHDRAWAL_INTERVAL = 7 days;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    // Info of each user that stakes LP tokens.\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\n    // Mapping of existing coins added\n    mapping (address => bool) public lpTokensAdded;\n\n    // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint = 0;\n    // The block number when GEMSTONES mining starts.\n    uint256 public startBlock;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmissionRateUpdated(address indexed caller, uint256 previousAmount, uint256 newAmount);\n    event RewardLockedUp(address indexed user, uint256 indexed pid, uint256 amountLockedUp);\n\n    constructor(\n        GemstoneToken _gemstones,\n        address _gemstoneFeeAddress,\n        address _feeAddr,\n        uint256 _gemstonesPerBlock,\n        uint256 _startBlock,\n\n        /* Referral */\n        uint256 _decimals,\n        uint256 _secondsUntilInactive,\n        bool _onlyRewardActiveReferrers,\n        uint256[] memory _levelRate,\n        uint256[] memory _refereeBonusRateMap,\n        ReferralStorage _referralStorage\n    ) public Referral (\n        _gemstones,\n        _decimals,\n        _secondsUntilInactive,\n        _onlyRewardActiveReferrers,\n        _levelRate,\n        _refereeBonusRateMap,\n        _referralStorage\n    ) {\n        require(_feeAddr != address(0), \"_feeAddr: ZERO_ADDRESS\");\n\n        gemstones = _gemstones;\n        gemstoneFeeAddr = _gemstoneFeeAddress;\n        feeAddr = _feeAddr;\n        gemstonesPerBlock = _gemstonesPerBlock;\n        startBlock = _startBlock;\n    }\n\n    function updateMultiplier(uint256 multiplierNumber) public onlyOwner {\n        BONUS_MULTIPLIER = multiplierNumber;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    // Add a new lp to the pool. Can only be called by the owner.\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    function add(uint256 _allocPoint, IBEP20 _lpToken, uint16 _depositFee, uint256 _harvestInterval,uint256 _earlyWithdrawalInterval, uint16 _earlyWithdrawalFee, uint16 _harvestFee, bool _withUpdate) public onlyOwner {\n        require(!lpTokensAdded[address(_lpToken)], \"Add():: Token Already Added!\");\n        require(_earlyWithdrawalFee <= 1000, \"set: earlyWithdrawalFee MAX 10%\");\n        require(_depositFee <= 1000, \"set: depositfee MAX 10%\");\n        require(_harvestInterval <= MAXIMUM_HARVEST_INTERVAL, \"set: too high harvest interval\");\n        require(_earlyWithdrawalInterval <= MAXIMUM_EARLY_WITHDRAWAL_INTERVAL, \"set: too high earlyWithdrawal interval\");\n        \n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(PoolInfo({\n            lpToken: _lpToken,\n            allocPoint: _allocPoint,\n            lastRewardBlock: lastRewardBlock,\n            accGemstonesPerShare: 0,\n            depositFee: _depositFee,\n            harvestFee: _harvestFee,\n            harvestInterval: _harvestInterval,\n            earlyWithdrawalInterval: _earlyWithdrawalInterval,\n            earlyWithdrawalFee: _earlyWithdrawalFee\n        }));\n\n        lpTokensAdded[address(_lpToken)] = true;\n    }\n\n    // Update the given pool's GEMSTONES allocation point. Can only be called by the owner.\n    function set(uint256 _pid, uint256 _allocPoint, uint16 _depositFee, uint256 _harvestInterval,uint256 _earlyWithdrawalInterval, uint16 _earlyWithdrawalFee, bool _withUpdate) public onlyOwner {\n        require(_earlyWithdrawalFee <= 1000, \"set: earlyWithdrawalFee MAX 10%\");\n        require(_depositFee <= 1000, \"set: depositfee MAX 10%\");\n        require(_harvestInterval <= MAXIMUM_HARVEST_INTERVAL, \"set: too high harvest interval\");\n        require(_earlyWithdrawalInterval <= MAXIMUM_EARLY_WITHDRAWAL_INTERVAL, \"set: too high earlyWithdrawal interval\");\n\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\n        poolInfo[_pid].allocPoint = _allocPoint;\n        poolInfo[_pid].depositFee = _depositFee;\n        poolInfo[_pid].harvestInterval = _harvestInterval;\n        poolInfo[_pid].earlyWithdrawalInterval = _earlyWithdrawalInterval;\n        poolInfo[_pid].earlyWithdrawalFee = _earlyWithdrawalFee;\n\n    }\n\n    function getlastdeposit(uint256 _pid, address _user) external view returns (uint256) {\n        UserInfo storage user = userInfo[_pid][_user];\n        return user.lastdeposit;\n    }\n\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        return _to.sub(_from).mul(BONUS_MULTIPLIER);\n    }\n\n    // View function to see pending GEMSTONEs on frontend.\n    function pendingGemstones(uint256 _pid, address _user) external view returns (uint256) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accGemstonesPerShare = pool.accGemstonesPerShare;\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint256 gemstonesReward = multiplier.mul(gemstonesPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accGemstonesPerShare = accGemstonesPerShare.add(gemstonesReward.mul(1e12).div(lpSupply));\n        }\n        \n        uint256 pending = user.amount.mul(accGemstonesPerShare).div(1e12).sub(user.rewardDebt);\n        return pending.add(user.rewardLockedUp);\n\n    }\n    \n    // View function to see if user can harvest Gemstones.\n    function canHarvest(uint256 _pid, address _user) public view returns (bool) {\n        UserInfo storage user = userInfo[_pid][_user];\n        return block.timestamp >= user.nextHarvestUntil;\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0 || pool.allocPoint == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n\n        uint256 gemstonesReward = multiplier.mul(gemstonesPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        gemstones.mint(gemstoneFeeAddr, gemstonesReward.div(10));\n        gemstones.mint(address(this), gemstonesReward);\n        pool.accGemstonesPerShare = pool.accGemstonesPerShare.add(gemstonesReward.mul(1e12).div(lpSupply));\n        pool.lastRewardBlock = block.number; \n    }\n\n    function deposit(uint256 _pid, uint256 _amount, address _referrerAddress) public nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        \n        payOrLockupPendingGemstones(_pid);\n\n        // If the current user doesn't have a referrer yet, add the address\n        if (_referrerAddress != address(0) && _amount > 0 && isReferralsEnabled() && !hasReferrer(msg.sender)) {\n            addReferrer(msg.sender, payable(_referrerAddress));\n        }\n        \n        if (_amount > 0) {\n\n            // retrieve the balance of MC here for LP\n            uint256 beforeTransferBalance = pool.lpToken.balanceOf(address(this));\n\n            // transfer lp to masterchef\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n            \n            // check how much masterchef received\n            uint256 afterTransferBalance = pool.lpToken.balanceOf(address(this));\n            uint256 actualTransferAmount = afterTransferBalance.sub(beforeTransferBalance);\n\n            // set the actual received amount\n            _amount = actualTransferAmount;\n\n            user.lastdeposit=now;\n            referralStorage.setAccountLastActive(msg.sender);\n\n            if (pool.depositFee > 0) {\n                uint256 depositFee = _amount.mul(pool.depositFee).div(10000);\n                pool.lpToken.safeTransfer(feeAddr, depositFee);\n                user.amount = user.amount.add(_amount).sub(depositFee);\n            } else {\n                user.amount = user.amount.add(_amount);\n            }\n        }\n        user.rewardDebt = user.amount.mul(pool.accGemstonesPerShare).div(1e12);\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    // Withdraw LP tokens from MasterChef.\n    function withdraw(uint256 _pid, uint256 _amount) public nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: user doesnt have enough funds\");\n        updatePool(_pid);\n        \n        payOrLockupPendingGemstones(_pid);\n\n        if(_amount > 0) {\n            user.amount = user.amount.sub(_amount);\n            if(now > user.lastdeposit + pool.earlyWithdrawalInterval ){\n                pool.lpToken.safeTransfer(address(msg.sender), _amount);\n            }else{\n                uint256 fee = _amount.mul(pool.earlyWithdrawalFee).div(10000);\n                uint256 amountWithoutFee = _amount.sub(fee);\n                pool.lpToken.safeTransfer(address(msg.sender), amountWithoutFee);\n                pool.lpToken.safeTransfer(address(feeAddr), fee);\n             }\n        }\n\n        user.rewardDebt = user.amount.mul(pool.accGemstonesPerShare).div(1e12);\n        emit Withdraw(msg.sender, _pid, _amount);\n\n    }\n    \n    \n     function payOrLockupPendingGemstones(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n\n        if (user.nextHarvestUntil == 0) {\n            user.nextHarvestUntil = block.timestamp.add(pool.harvestInterval);\n        }\n\n        uint256 pending = user.amount.mul(pool.accGemstonesPerShare).div(1e12).sub(user.rewardDebt);\n        if (canHarvest(_pid, msg.sender)) {\n            uint256 totalRewards = pending.add(user.rewardLockedUp);\n\n            // reset lockup\n            totalLockedUpRewards = totalLockedUpRewards.sub(user.rewardLockedUp);\n            user.rewardLockedUp = 0;\n            user.nextHarvestUntil = block.timestamp.add(pool.harvestInterval);\n\n            uint256 fee = 0;\n\n            if(pool.harvestFee > 0){\n                fee = totalRewards.mul(pool.harvestFee).div(10000);\n            }\n\n            // Take referral cut from harvest -- either burn or distribute\n            uint256 referralCut = totalRewards.mul(referralCutPercentage).div(10000);\n            uint256 actualReward = totalRewards.sub(referralCut).sub(fee);\n\n            require(referralCut + actualReward + fee == totalRewards, \"Referral cut was not properly taken\");\n\n            // Transfer the 'actual' reward to the user\n            safeGemstonesTransfer(msg.sender, actualReward);\n\n            // Pay referral\n            uint256 paidToReferrals = 0;\n            \n            // If referral is enabled, and the user is referred\n            if(isReferralsEnabled() && hasReferrer(msg.sender)) {\n\n                // Pay the referral cut (note: 60% to first level, 30% to second level, 10% to 3rd)\n                paidToReferrals = payReferral(msg.sender, referralCut);\n                uint256 rest = referralCut.sub(paidToReferrals);\n                // transfer the rest (if any) to fee address (if not all 3 levels are present)\n                safeGemstonesTransfer(gemstoneFeeAddr, rest.add(fee));\n                \n            } else if(fee > 0 || referralCut > 0){\n                // Transfer to fee address\n                safeGemstonesTransfer(gemstoneFeeAddr, referralCut.add(fee));\n            }\n        }\n        else if (pending > 0) {\n            user.rewardLockedUp = user.rewardLockedUp.add(pending);\n            totalLockedUpRewards = totalLockedUpRewards.add(pending);\n            emit RewardLockedUp(msg.sender, _pid, pending);\n        }\n    }\n\n  \n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _pid) public nonReentrant {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 amount = user.amount;\n        user.amount = 0;\n        user.rewardDebt = 0;\n        user.rewardLockedUp = 0;\n        user.nextHarvestUntil = 0;\n        pool.lpToken.safeTransfer(address(msg.sender), amount);\n        emit EmergencyWithdraw(msg.sender, _pid, amount);\n    }\n\n    // Safe gemstones transfer function, just in case if rounding error causes pool to not have enough GEMSTONEs.\n    function safeGemstonesTransfer(address _to, uint256 _amount) internal {\n        uint256 bal = gemstones.balanceOf(address(this));\n        if (_amount > bal) {\n            gemstones.transfer(_to, bal);\n        } else {\n            gemstones.transfer(_to, _amount);\n        } \n    }\n\n    function setFeeAddress(address _feeAddr) public {\n        require(msg.sender == feeAddr, \"setFeeAddress: FORBIDDEN\");\n        require(_feeAddr != address(0), \"setFeeAddress: ZERO\");\n        feeAddr = _feeAddr;\n    }\n \n    function setGemstoneFeeAddress(address _gemstoneFeeAddr) public {\n        require(msg.sender == _gemstoneFeeAddr, \"setGemstoneFeeAddress: FORBIDDEN\");\n        require(_gemstoneFeeAddr != address(0), \"setGemstoneFeeAddress: ZERO\");\n        gemstoneFeeAddr = _gemstoneFeeAddr;\n    }\n    \n    function updateEmissionRate(uint256 _gemstonesPerBlock, bool _updateAllPools) public onlyOwner {\n        require(_gemstonesPerBlock < 15000000000000000000, \"updateEmissionRate: TOO HIGH\");\n        gemstonesPerBlock = _gemstonesPerBlock;\n\n        if(_updateAllPools) {\n            massUpdatePools();\n        }\n        \n        emit EmissionRateUpdated(msg.sender, gemstonesPerBlock, _gemstonesPerBlock);\n    }\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract GemstoneToken\",\"name\":\"_gemstones\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gemstoneFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gemstonesPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_secondsUntilInactive\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_onlyRewardActiveReferrers\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"_levelRate\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_refereeBonusRateMap\",\"type\":\"uint256[]\"},{\"internalType\":\"contract ReferralStorage\",\"name\":\"_referralStorage\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"EmissionRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"PaidReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLockedUp\",\"type\":\"uint256\"}],\"name\":\"RewardLockedUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"boolean\",\"type\":\"bool\"}],\"name\":\"SetOnlyRewardActiveReferrers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"levelRates\",\"type\":\"uint256[]\"}],\"name\":\"SetReferralDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"SetReferralPercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SetReferralsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdatedUserLastActiveTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONUS_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_EARLY_WITHDRAWAL_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_HARVEST_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IBEP20\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_depositFee\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_harvestInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earlyWithdrawalInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_earlyWithdrawalFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_harvestFee\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"canHarvest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrerAddress\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gemstoneFeeAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gemstones\",\"outputs\":[{\"internalType\":\"contract GemstoneToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gemstonesPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getRefereeBonusRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getlastdeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"hasReferrer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasReferrer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReferralsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accountAddress\",\"type\":\"address\"}],\"name\":\"isReferrerActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lpTokensAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingGemstones\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accGemstonesPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"depositFee\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"harvestInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earlyWithdrawalInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earlyWithdrawalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"harvestFee\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralCutPercentage\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_depositFee\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_harvestInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earlyWithdrawalInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_earlyWithdrawalFee\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAddr\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gemstoneFeeAddr\",\"type\":\"address\"}],\"name\":\"setGemstoneFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_onlyRewardActiveReferrers\",\"type\":\"bool\"}],\"name\":\"setOnlyRewardActiveReferrers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_levelRate\",\"type\":\"uint256[]\"}],\"name\":\"setReferralDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_percentage\",\"type\":\"uint16\"}],\"name\":\"setReferralPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_referralsEnabled\",\"type\":\"bool\"}],\"name\":\"setReferralsEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"}],\"name\":\"sum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedUpRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gemstonesPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_updateAllPools\",\"type\":\"bool\"}],\"name\":\"updateEmissionRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"multiplierNumber\",\"type\":\"uint256\"}],\"name\":\"updateMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextHarvestUntil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastdeposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MasterChef", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000d962a1a2a27b402e4d84772dea65ac8592eb6bf000000000000000000000000da10a9297374b8eefd65c746a5c85eaebe0c20db000000000000000000000000ebea75cbc8a7d0adf80478dcbd84c3d245727619000000000000000000000000000000000000000000000000a688906bd8b000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000001275000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000b49bf6a08f9746c5866dc9e1403fbde14901324b000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000017700000000000000000000000000000000000000000000000000000000000000bb800000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000002710", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}