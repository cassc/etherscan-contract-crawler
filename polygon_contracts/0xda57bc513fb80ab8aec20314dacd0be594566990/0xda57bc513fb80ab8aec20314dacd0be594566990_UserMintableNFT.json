{"SourceCode": "{\"Addresses.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\n/**\\r\\n * Utility library of inline functions on addresses\\r\\n */\\r\\nlibrary Address {\\r\\n  \\r\\n\\r\\n  /**\\r\\n   * Returns whether the target address is a contract\\r\\n   * @dev This function will return false if invoked during the constructor of a contract,\\r\\n   * as the code is not actually created until after the constructor finishes.\\r\\n   * @param account address to check\\r\\n   * @return whether the target address is a contract\\r\\n   */\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n      // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n      // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n      // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n      bytes32 codehash;\\r\\n      bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n      // solhint-disable-next-line no-inline-assembly\\r\\n      assembly { codehash := extcodehash(account) }\\r\\n      return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n  }\\r\\n\\r\\n}\"},\"BaseERC721.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./ERC721Token.sol\\\";\\r\\nimport \\\"./ERC20Interface.sol\\\";\\r\\nimport \\\"./Freezable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Base ERC721 token\\r\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\r\\n * This contract implements basic ERC721 token functionality with bulk functionalities\\r\\n */\\r\\ncontract BaseERC721 is ERC721Token, Freezable {\\r\\n\\r\\n  constructor(string memory name, string memory symbol, string memory _baseTokenURI) public  ERC721Token(name, symbol){\\r\\n    baseTokenURI = _baseTokenURI;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Updates the base URL of token\\r\\n   * Reverts if the sender is not owner\\r\\n   * @param _newURI New base URL\\r\\n   */\\r\\n  function updateBaseTokenURI(string memory _newURI)\\r\\n    public\\r\\n    onlyOwner\\r\\n    noEmergencyFreeze\\r\\n  {\\r\\n    baseTokenURI = _newURI;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Mints new token on blockchain\\r\\n   * Reverts if the sender is not operator with level 1\\r\\n   * @param _id Id of NFT to be minted\\r\\n   * @dev URI is not provided because URI will be deducted based on baseURL\\r\\n   */\\r\\n  function mint(uint256 _id, address _to)\\r\\n    public\\r\\n    onlyDeputyOrOwner\\r\\n    noEmergencyFreeze\\r\\n    returns (bool)\\r\\n  {\\r\\n    super._mint(_to, _id);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function bulkMint(uint[] memory _ids, address[] memory _users)\\r\\n    public\\r\\n    onlyDeputyOrOwner\\r\\n    noEmergencyFreeze\\r\\n    returns (bool)\\r\\n  {\\r\\n    require(_ids.length == _users.length, \\\"Invalid params\\\");\\r\\n    for(uint i=0; i\\u003c_ids.length; i++) {\\r\\n      super._mint(_users[i], _ids[i]);\\r\\n    }\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfer tokens (similar to ERC-20 transfer)\\r\\n   * Reverts if the sender is not owner of the NFT or approved\\r\\n   * @param _to address to which token is transferred\\r\\n   * @param _tokenId Id of NFT being transferred\\r\\n   */\\r\\n  function transfer(address _to, uint256 _tokenId)\\r\\n    public\\r\\n    noEmergencyFreeze\\r\\n    returns (bool)\\r\\n  {\\r\\n    safeTransferFrom(msg.sender, _to, _tokenId);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Burn an existing NFT\\r\\n   * @param _id Id of NFT to be burned\\r\\n   */\\r\\n  function burn(uint _id)\\r\\n    public\\r\\n    noEmergencyFreeze\\r\\n    returns (bool)\\r\\n  {\\r\\n    super._burn(msg.sender, _id);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  //////////////////////////////////////////\\r\\n  // PUBLICLY ACCESSIBLE METHODS (CONSTANT)\\r\\n  //////////////////////////////////////////\\r\\n\\r\\n}\"},\"CustomERC721.sol\":{\"content\":\"/**\\r\\n * This is custom ERC-721 token with some add on functionalities\\r\\n*/\\r\\n\\r\\npragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./BaseERC721.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title CustomERC721\\r\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\r\\n */\\r\\ncontract CustomERC721 is BaseERC721 {\\r\\n\\r\\n  // mapping for replay protection\\r\\n  mapping(address =\\u003e uint) private userNonce;\\r\\n\\r\\n  bool public isNormalUserAllowed; // can normal user access advanced features\\r\\n  \\r\\n  constructor(string memory name, string memory symbol, string memory baseURI) public BaseERC721(name, symbol, baseURI) {\\r\\n    isNormalUserAllowed = false;\\r\\n  }\\r\\n\\r\\n  modifier canAccessProvableFunctions() {\\r\\n    require(isNormalUserAllowed || msg.sender == owner || isDeputyOwner[msg.sender], \\\"Not allowed to access provable fns\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows normal users to call provable fns\\r\\n   * Reverts if the sender is not owner of contract\\r\\n   * @param _perm permission to users\\r\\n   */\\r\\n  function allowNormalUser(bool _perm)\\r\\n    public \\r\\n    onlyOwner\\r\\n  {\\r\\n    isNormalUserAllowed = _perm;\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * @dev Allows submitting already signed transaction\\r\\n   * Reverts if the signed data is incorrect\\r\\n   * @param message signed message by user\\r\\n   * @param r signature\\r\\n   * @param s signature\\r\\n   * @param v recovery id of signature\\r\\n   * @param spender address which is approved\\r\\n   * @param approved bool value for status of approval\\r\\n   * message should be hash(functionWord, contractAddress, nonce, fnParams)\\r\\n   */\\r\\n  function provable_setApprovalForAll(bytes32 message, bytes32 r, bytes32 s, uint8 v, address spender, bool approved)\\r\\n    public\\r\\n    noEmergencyFreeze\\r\\n    canAccessProvableFunctions\\r\\n  {\\r\\n    address signer = getSigner(message, r, s, v);\\r\\n    require (signer != address(0), \\\"Invalid signer\\\");\\r\\n\\r\\n    bytes32 proof = getMessageSetApprovalForAll(signer, spender, approved);\\r\\n    require(proof == message, \\\"Invalid proof\\\");\\r\\n\\r\\n    // perform the original set Approval\\r\\n    operatorApprovals[signer][spender] = approved;\\r\\n    emit ApprovalForAll(signer, spender, approved);\\r\\n    userNonce[signer] = userNonce[signer].add(1);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows submitting already signed transaction for NFT transfer\\r\\n   * Reverts if the signed data is incorrect\\r\\n   * @param message signed message by user\\r\\n   * @param r signature\\r\\n   * @param s signature\\r\\n   * @param v recovery id of signature\\r\\n   * @param to recipient address\\r\\n   * @param tokenId ID of NFT\\r\\n   * message should be hash(functionWord, contractAddress, nonce, fnParams)\\r\\n   */\\r\\n  function provable_transfer(bytes32 message, bytes32 r, bytes32 s, uint8 v, address to, uint tokenId)\\r\\n    public \\r\\n    noEmergencyFreeze\\r\\n    canAccessProvableFunctions\\r\\n  {\\r\\n    address signer = getSigner(message, r, s, v);\\r\\n    require (signer != address(0),\\\"Invalid signer\\\");\\r\\n\\r\\n    bytes32 proof = getMessageTransfer(signer, to, tokenId);\\r\\n    require (proof == message, \\\"Invalid proof\\\");\\r\\n    \\r\\n    // Execute original function\\r\\n    require(to != address(0), \\\"Zero address not allowed\\\");\\r\\n    clearApproval(signer, tokenId);\\r\\n    removeTokenFrom(signer, tokenId);\\r\\n    addTokenTo(to, tokenId);\\r\\n    emit Transfer(signer, to, tokenId);\\r\\n\\r\\n    // update state variables\\r\\n    userNonce[signer] = userNonce[signer].add(1);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Check signer of a message\\r\\n   * @param message signed message by user\\r\\n   * @param r signature\\r\\n   * @param s signature\\r\\n   * @param v recovery id of signature\\r\\n   * @return signer of message\\r\\n   */\\r\\n  function getSigner(bytes32 message, bytes32 r, bytes32 s,  uint8 v) public pure returns (address){\\r\\n    bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\r\\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, message));\\r\\n    address signer = ecrecover(prefixedHash,v,r,s);\\r\\n    return signer;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Get message to be signed for transfer\\r\\n   * @param signer of message\\r\\n   * @param to recipient address\\r\\n   * @param id NFT id\\r\\n   * @return hash of (functionWord, contractAddress, nonce, ...fnParams)\\r\\n   */\\r\\n  function getMessageTransfer(address signer, address to, uint id)\\r\\n    public\\r\\n    view\\r\\n    returns (bytes32) \\r\\n  {\\r\\n    return keccak256(abi.encodePacked(\\r\\n      bytes4(0xb483afd3),\\r\\n      address(this),\\r\\n      userNonce[signer],\\r\\n      to,\\r\\n      id\\r\\n    ));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Get message to be signed for set Approval\\r\\n   * @param signer of message\\r\\n   * @param spender address which is approved\\r\\n   * @param approved bool value for status of approval\\r\\n   * @return hash of (functionWord, contractAddress, nonce, ...fnParams)\\r\\n   */\\r\\n  function getMessageSetApprovalForAll(address signer, address spender, bool approved)\\r\\n    public \\r\\n    view \\r\\n    returns (bytes32)\\r\\n  {\\r\\n    bytes32 proof = keccak256(abi.encodePacked(\\r\\n      bytes4(0xbad4c8ea),\\r\\n      address(this),\\r\\n      userNonce[signer],\\r\\n      spender,\\r\\n      approved\\r\\n    ));\\r\\n    return proof;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * returns nonce of user to be used for next signing\\r\\n  */\\r\\n  function getUserNonce(address user) public view returns (uint) {\\r\\n    return userNonce[user];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Owner can transfer out any accidentally sent ERC20 tokens\\r\\n   * @param contractAddress ERC20 contract address\\r\\n   * @param to withdrawal address\\r\\n   * @param value no of tokens to be withdrawan\\r\\n   */\\r\\n  function transferAnyERC20Token(address contractAddress, address to,  uint value) public onlyOwner {\\r\\n    ERC20Interface(contractAddress).transfer(to, value);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Owner can transfer out any accidentally sent ERC721 tokens\\r\\n   * @param contractAddress ERC721 contract address\\r\\n   * @param to withdrawal address\\r\\n   * @param tokenId Id of 721 token\\r\\n   */\\r\\n  function withdrawAnyERC721Token(address contractAddress, address to, uint tokenId) public onlyOwner {\\r\\n    ERC721Basic(contractAddress).safeTransferFrom(address(this), to, tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Owner kill the smart contract\\r\\n   * @param message Confirmation message to prevent accidebtal calling\\r\\n   * @notice BE VERY CAREFULL BEFORE CALLING THIS FUNCTION\\r\\n   * Better pause the contract\\r\\n   * DO CALL \\\"transferAnyERC20Token\\\" before TO WITHDRAW ANY ERC-2O\\u0027s FROM CONTRACT\\r\\n   */\\r\\n  function kill(uint message) public onlyOwner {\\r\\n    require (message == 123456789987654321, \\\"Invalid code\\\");\\r\\n    // Transfer Eth to owner and terminate contract\\r\\n    selfdestruct(msg.sender);\\r\\n  }\\r\\n\\r\\n}\"},\"ERC165.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\n/**\\r\\n * @title ERC165\\r\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\r\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\r\\n */\\r\\ninterface ERC165 {\\r\\n\\r\\n  /**\\r\\n   * @notice Query if a contract implements an interface\\r\\n   * @param _interfaceId The interface identifier, as specified in ERC-165\\r\\n   * @dev Interface identification is specified in ERC-165. This function\\r\\n   * uses less than 30,000 gas.\\r\\n   */\\r\\n  function supportsInterface(bytes4 _interfaceId)\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n}\\r\\n\"},\"ERC20Interface.sol\":{\"content\":\"pragma solidity ^0.5.17;\\r\\n\\r\\ncontract ERC20Interface {\\r\\n  function transfer(address to, uint tokens) public returns (bool success);\\r\\n  function balanceOf(address _sender) public view returns (uint _bal);\\r\\n  function allowance(address tokenOwner, address spender) public view returns (uint remaining);\\r\\n  event Transfer(address indexed from, address indexed to, uint tokens);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n  function transferFrom(address from, address to, uint tokens) public returns (bool success);\\r\\n}\"},\"ERC721.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./ERC721Basic.sol\\\";\\r\\nimport \\\"./ERC721Enumerable.sol\\\";\\r\\nimport \\\"./ERC721Metadata.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\\r\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\r\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\\r\\n\\r\\n}\"},\"ERC721Basic.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./ERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC721 Non-Fungible Token Standard basic interface\\r\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\r\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721Basic is ERC165 {\\r\\n  event Transfer(\\r\\n    address indexed _from,\\r\\n    address indexed _to,\\r\\n    uint256 indexed _tokenId\\r\\n  );\\r\\n  event Approval(\\r\\n    address indexed _owner,\\r\\n    address indexed _approved,\\r\\n    uint256 indexed _tokenId\\r\\n  );\\r\\n  event ApprovalForAll(\\r\\n    address indexed _owner,\\r\\n    address indexed _operator,\\r\\n    bool _approved\\r\\n  );\\r\\n\\r\\n  function balanceOf(address _owner) public view returns (uint256 _balance);\\r\\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\\r\\n  function exists(uint256 _tokenId) public view returns (bool _exists);\\r\\n\\r\\n  function approve(address _to, uint256 _tokenId) public;\\r\\n  function getApproved(uint256 _tokenId)\\r\\n    public view returns (address _operator);\\r\\n\\r\\n  function setApprovalForAll(address _operator, bool _approved) public;\\r\\n  function isApprovedForAll(address _owner, address _operator)\\r\\n    public view returns (bool);\\r\\n\\r\\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\\r\\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\\r\\n    public;\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId,\\r\\n    bytes memory _data\\r\\n  )\\r\\n    public;\\r\\n}\"},\"ERC721BasicToken.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./SupportsInterfaceWithLookup.sol\\\";\\r\\nimport \\\"./ERC721Basic.sol\\\";\\r\\nimport \\\"./ERC721Receiver.sol\\\";\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Addresses.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\r\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\r\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {\\r\\n\\r\\n  bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd;\\r\\n  /*\\r\\n   * 0x80ac58cd ===\\r\\n   *   bytes4(keccak256(\\u0027balanceOf(address)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027ownerOf(uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027approve(address,uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027getApproved(uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027setApprovalForAll(address,bool)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027isApprovedForAll(address,address)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027transferFrom(address,address,uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256,bytes)\\u0027))\\r\\n   */\\r\\n\\r\\n  bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79;\\r\\n  /*\\r\\n   * 0x4f558e79 ===\\r\\n   *   bytes4(keccak256(\\u0027exists(uint256)\\u0027))\\r\\n   */\\r\\n\\r\\n  using SafeMath for uint256;\\r\\n  using Address for address;\\r\\n\\r\\n  // Equals to `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`\\r\\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\\r\\n  bytes4 private constant ERC721_RECEIVED = 0xf0b9e5ba;\\r\\n\\r\\n  // Mapping from token ID to owner\\r\\n  mapping (uint256 =\\u003e address) internal tokenOwner;\\r\\n\\r\\n  // Mapping from token ID to approved address\\r\\n  mapping (uint256 =\\u003e address) internal tokenApprovals;\\r\\n\\r\\n  // Mapping from owner to number of owned token\\r\\n  mapping (address =\\u003e uint256) internal ownedTokensCount;\\r\\n\\r\\n  // Mapping from owner to operator approvals\\r\\n  mapping (address =\\u003e mapping (address =\\u003e bool)) internal operatorApprovals;\\r\\n\\r\\n  /**\\r\\n   * @dev Guarantees msg.sender is owner of the given token\\r\\n   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\\r\\n   */\\r\\n  modifier onlyOwnerOf(uint256 _tokenId) {\\r\\n    require(ownerOf(_tokenId) == msg.sender, \\\"Only asset owner is allowed\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\\r\\n   * @param _tokenId uint256 ID of the token to validate\\r\\n   */\\r\\n  modifier canTransfer(uint256 _tokenId) {\\r\\n    require(isApprovedOrOwner(msg.sender, _tokenId), \\\"Can not transfer\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  constructor()\\r\\n    public\\r\\n  {\\r\\n    // register the supported interfaces to conform to ERC721 via ERC165\\r\\n    _registerInterface(InterfaceId_ERC721);\\r\\n    _registerInterface(InterfaceId_ERC721Exists);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the balance of the specified address\\r\\n   * @param _owner address to query the balance of\\r\\n   * @return uint256 representing the amount owned by the passed address\\r\\n   */\\r\\n  function balanceOf(address _owner) public view returns (uint256) {\\r\\n    require(_owner != address(0), \\\"Zero address not allowed\\\");\\r\\n    return ownedTokensCount[_owner];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the owner of the specified token ID\\r\\n   * @param _tokenId uint256 ID of the token to query the owner of\\r\\n   * @return owner address currently marked as the owner of the given token ID\\r\\n   */\\r\\n  function ownerOf(uint256 _tokenId) public view returns (address) {\\r\\n    address owner = tokenOwner[_tokenId];\\r\\n    require(owner != address(0), \\\"Zero address not allowed\\\");\\r\\n    return owner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns whether the specified token exists\\r\\n   * @param _tokenId uint256 ID of the token to query the existence of\\r\\n   * @return whether the token exists\\r\\n   */\\r\\n  function exists(uint256 _tokenId) public view returns (bool) {\\r\\n    address owner = tokenOwner[_tokenId];\\r\\n    return owner != address(0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Approves another address to transfer the given token ID\\r\\n   * The zero address indicates there is no approved address.\\r\\n   * There can only be one approved address per token at a given time.\\r\\n   * Can only be called by the token owner or an approved operator.\\r\\n   * @param _to address to be approved for the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be approved\\r\\n   */\\r\\n  function approve(address _to, uint256 _tokenId) public {\\r\\n    address owner = ownerOf(_tokenId);\\r\\n    require(_to != owner, \\\"Can not approve to self\\\");\\r\\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \\\"Not allowed to update approvals\\\");\\r\\n\\r\\n    tokenApprovals[_tokenId] = _to;\\r\\n    emit Approval(owner, _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the approved address for a token ID, or zero if no address set\\r\\n   * @param _tokenId uint256 ID of the token to query the approval of\\r\\n   * @return address currently approved for the given token ID\\r\\n   */\\r\\n  function getApproved(uint256 _tokenId) public view returns (address) {\\r\\n    return tokenApprovals[_tokenId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets or unsets the approval of a given operator\\r\\n   * An operator is allowed to transfer all tokens of the sender on their behalf\\r\\n   * @param _to operator address to set the approval\\r\\n   * @param _approved representing the status of the approval to be set\\r\\n   */\\r\\n  function setApprovalForAll(address _to, bool _approved) public {\\r\\n    require(_to != msg.sender, \\\"Can not approve to self\\\");\\r\\n    operatorApprovals[msg.sender][_to] = _approved;\\r\\n    emit ApprovalForAll(msg.sender, _to, _approved);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Tells whether an operator is approved by a given owner\\r\\n   * @param _owner owner address which you want to query the approval of\\r\\n   * @param _operator operator address which you want to query the approval of\\r\\n   * @return bool whether the given operator is approved by the given owner\\r\\n   */\\r\\n  function isApprovedForAll(\\r\\n    address _owner,\\r\\n    address _operator\\r\\n  )\\r\\n    public\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    return operatorApprovals[_owner][_operator];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers the ownership of a given token ID to another address\\r\\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\\r\\n   * Requires the msg sender to be the owner, approved, or operator\\r\\n   * @param _from current owner of the token\\r\\n   * @param _to address to receive the ownership of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n  */\\r\\n  function transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    public\\r\\n    canTransfer(_tokenId)\\r\\n  \\r\\n  {\\r\\n    require(_from != address(0), \\\"Zero address not allowed\\\");\\r\\n    require(_to != address(0), \\\"Zero address not allowed\\\");\\r\\n\\r\\n    clearApproval(_from, _tokenId);\\r\\n    removeTokenFrom(_from, _tokenId);\\r\\n    addTokenTo(_to, _tokenId);\\r\\n\\r\\n    emit Transfer(_from, _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers the ownership of a given token ID to another address\\r\\n   * If the target address is a contract, it must implement `onERC721Received`,\\r\\n   * which is called upon a safe transfer, and return the magic value\\r\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`; otherwise,\\r\\n   * the transfer is reverted.\\r\\n   *\\r\\n   * Requires the msg sender to be the owner, approved, or operator\\r\\n   * @param _from current owner of the token\\r\\n   * @param _to address to receive the ownership of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n  */\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    public\\r\\n    canTransfer(_tokenId)\\r\\n  \\r\\n  {\\r\\n    // solium-disable-next-line arg-overflow\\r\\n    safeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers the ownership of a given token ID to another address\\r\\n   * If the target address is a contract, it must implement `onERC721Received`,\\r\\n   * which is called upon a safe transfer, and return the magic value\\r\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`; otherwise,\\r\\n   * the transfer is reverted.\\r\\n   * Requires the msg sender to be the owner, approved, or operator\\r\\n   * @param _from current owner of the token\\r\\n   * @param _to address to receive the ownership of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n   * @param _data bytes data to send along with a safe transfer check\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId,\\r\\n    bytes memory _data\\r\\n  )\\r\\n    public\\r\\n    canTransfer(_tokenId)\\r\\n  {\\r\\n    transferFrom(_from, _to, _tokenId);\\r\\n    // solium-disable-next-line arg-overflow\\r\\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data), \\\"Safe Transfer failed\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns whether the given spender can transfer a given token ID\\r\\n   * @param _spender address of the spender to query\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n   * @return bool whether the msg.sender is approved for the given token ID,\\r\\n   *  is an operator of the owner, or is the owner of the token\\r\\n   */\\r\\n  function isApprovedOrOwner(\\r\\n    address _spender,\\r\\n    uint256 _tokenId\\r\\n  )\\r\\n    internal\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    address owner = ownerOf(_tokenId);\\r\\n    // Disable solium check because of\\r\\n    // https://github.com/duaraghav8/Solium/issues/175\\r\\n    // solium-disable-next-line operator-whitespace\\r\\n    return (\\r\\n      _spender == owner ||\\r\\n      getApproved(_tokenId) == _spender ||\\r\\n      isApprovedForAll(owner, _spender)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to mint a new token\\r\\n   * Reverts if the given token ID already exists\\r\\n   * @param _to The address that will own the minted token\\r\\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\\r\\n   */\\r\\n  function _mint(address _to, uint256 _tokenId) internal {\\r\\n    require(_to != address(0), \\\"Zero address not allowed\\\");\\r\\n    addTokenTo(_to, _tokenId);\\r\\n    emit Transfer(address(0), _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to burn a specific token\\r\\n   * Reverts if the token does not exist\\r\\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\\r\\n   */\\r\\n  function _burn(address _owner, uint256 _tokenId) internal {\\r\\n    clearApproval(_owner, _tokenId);\\r\\n    removeTokenFrom(_owner, _tokenId);\\r\\n    emit Transfer(_owner, address(0), _tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to clear current approval of a given token ID\\r\\n   * Reverts if the given address is not indeed the owner of the token\\r\\n   * @param _owner owner of the token\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n   */\\r\\n  function clearApproval(address _owner, uint256 _tokenId) internal {\\r\\n    require(ownerOf(_tokenId) == _owner, \\\"Asset does not belong to given owmer\\\");\\r\\n    if (tokenApprovals[_tokenId] != address(0)) {\\r\\n      tokenApprovals[_tokenId] = address(0);\\r\\n      emit Approval(_owner, address(0), _tokenId);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to add a token ID to the list of a given address\\r\\n   * @param _to address representing the new owner of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\\r\\n   */\\r\\n  function addTokenTo(address _to, uint256 _tokenId) internal {\\r\\n    require(tokenOwner[_tokenId] == address(0), \\\"Asset already exists\\\");\\r\\n    tokenOwner[_tokenId] = _to;\\r\\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to remove a token ID from the list of a given address\\r\\n   * @param _from address representing the previous owner of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\\r\\n   */\\r\\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\\r\\n    require(ownerOf(_tokenId) == _from, \\\"Asset does not belong to given owmer\\\");\\r\\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\\r\\n    tokenOwner[_tokenId] = address(0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to invoke `onERC721Received` on a target address\\r\\n   * The call is not executed if the target address is not a contract\\r\\n   * @param _from address representing the previous owner of the given token ID\\r\\n   * @param _to target address that will receive the tokens\\r\\n   * @param _tokenId uint256 ID of the token to be transferred\\r\\n   * @param _data bytes optional data to send along with the call\\r\\n   * @return whether the call correctly returned the expected magic value\\r\\n   */\\r\\n  function checkAndCallSafeTransfer(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _tokenId,\\r\\n    bytes memory _data\\r\\n  )\\r\\n    internal\\r\\n    returns (bool)\\r\\n  {\\r\\n    if (!_to.isContract()) {\\r\\n      return true;\\r\\n    }\\r\\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(\\r\\n      _from, _tokenId, _data);\\r\\n    return (retval == ERC721_RECEIVED);\\r\\n  }\\r\\n}\"},\"ERC721Enumerable.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./ERC721Basic.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\r\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\r\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721Enumerable is ERC721Basic {\\r\\n  function totalSupply() public view returns (uint256);\\r\\n  function tokenOfOwnerByIndex(\\r\\n    address _owner,\\r\\n    uint256 _index\\r\\n  )\\r\\n    public\\r\\n    view\\r\\n    returns (uint256 _tokenId);\\r\\n\\r\\n  function tokenByIndex(uint256 _index) public view returns (uint256);\\r\\n}\"},\"ERC721Metadata.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./ERC721Basic.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata \\r\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\r\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721Metadata is ERC721Basic {\\r\\n  function name() external view returns (string memory _name);\\r\\n  function symbol() external view returns (string memory _symbol);\\r\\n  function tokenURI(uint256 _tokenId) public view returns (string memory);\\r\\n}\"},\"ERC721Receiver.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ncontract ERC721Receiver {\\r\\n  /**\\r\\n   * @dev Magic value to be returned upon successful reception of an NFT\\r\\n   *  Equals to `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`,\\r\\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\\r\\n   */\\r\\n  bytes4 internal constant ERC721_RECEIVED = 0xf0b9e5ba;\\r\\n\\r\\n  /**\\r\\n   * @notice Handle the receipt of an NFT\\r\\n   * @dev The ERC721 smart contract calls this function on the recipient\\r\\n   * after a `safetransfer`. This function MAY throw to revert and reject the\\r\\n   * transfer. This function MUST use 50,000 gas or less. Return of other\\r\\n   * than the magic value MUST result in the transaction being reverted.\\r\\n   * Note: the contract address is always the message sender.\\r\\n   * @param _from The sending address\\r\\n   * @param _tokenId The NFT identifier which is being transfered\\r\\n   * @param _data Additional data with no specified format\\r\\n   * @return `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`\\r\\n   */\\r\\n  function onERC721Received(\\r\\n    address _from,\\r\\n    uint256 _tokenId,\\r\\n    bytes memory _data\\r\\n  )\\r\\n    public\\r\\n    returns(bytes4);\\r\\n}\"},\"ERC721Token.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./ERC721.sol\\\";\\r\\nimport \\\"./ERC721BasicToken.sol\\\";\\r\\nimport \\\"./SupportsInterfaceWithLookup.sol\\\";\\r\\nimport \\\"./Strings.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Full ERC721 Token\\r\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\r\\n * This implementation includes all the required and some optional functionality of the ERC721 standard\\r\\n * Moreover, it includes approve all functionality using operator terminology\\r\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\\r\\n\\r\\n  bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63;\\r\\n  /**\\r\\n   * 0x780e9d63 ===\\r\\n   *   bytes4(keccak256(\\u0027totalSupply()\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027tokenOfOwnerByIndex(address,uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027tokenByIndex(uint256)\\u0027))\\r\\n   */\\r\\n\\r\\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\\r\\n  /**\\r\\n   * 0x5b5e139f ===\\r\\n   *   bytes4(keccak256(\\u0027name()\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027symbol()\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027tokenURI(uint256)\\u0027))\\r\\n   */\\r\\n\\r\\n  // Token name\\r\\n  string internal name_;\\r\\n\\r\\n  // Token symbol\\r\\n  string internal symbol_;\\r\\n\\r\\n  // to store base URL\\r\\n  string internal baseTokenURI;\\r\\n\\r\\n  // Mapping from owner to list of owned token IDs\\r\\n  mapping(address =\\u003e uint256[]) internal ownedTokens;\\r\\n\\r\\n  // Mapping from token ID to index of the owner tokens list\\r\\n  mapping(uint256 =\\u003e uint256) internal ownedTokensIndex;\\r\\n\\r\\n  // Array with all token ids, used for enumeration\\r\\n  uint256[] internal allTokens;\\r\\n\\r\\n  // Mapping from token id to position in the allTokens array\\r\\n  mapping(uint256 =\\u003e uint256) internal allTokensIndex;\\r\\n\\r\\n  /**\\r\\n   * @dev Constructor function\\r\\n   */\\r\\n  constructor(string memory _name, string memory _symbol) public {\\r\\n    name_ = _name;\\r\\n    symbol_ = _symbol;\\r\\n\\r\\n    // register the supported interfaces to conform to ERC721 via ERC165\\r\\n    _registerInterface(InterfaceId_ERC721Enumerable);\\r\\n    _registerInterface(InterfaceId_ERC721Metadata);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the token name\\r\\n   * @return string representing the token name\\r\\n   */\\r\\n  function name() external view returns (string memory) {\\r\\n    return name_;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the token symbol\\r\\n   * @return string representing the token symbol\\r\\n   */\\r\\n  function symbol() external view returns (string memory) {\\r\\n    return symbol_;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns an URI for a given token ID\\r\\n   * Throws if the token ID does not exist. May return an empty string.\\r\\n   * @param _tokenId uint256 ID of the token to query\\r\\n   */\\r\\n  function tokenURI(uint256 _tokenId) public view returns (string memory) {\\r\\n    require(exists(_tokenId), \\\"Asset does not exist\\\");\\r\\n    return string(abi.encodePacked(baseTokenURI, Strings.toString(_tokenId)));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\\r\\n   * @param _owner address owning the tokens list to be accessed\\r\\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\\r\\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\\r\\n   */\\r\\n  function tokenOfOwnerByIndex(\\r\\n    address _owner,\\r\\n    uint256 _index\\r\\n  )\\r\\n    public\\r\\n    view\\r\\n    returns (uint256)\\r\\n  {\\r\\n    require(_index \\u003c balanceOf(_owner), \\\"Invalid index\\\");\\r\\n    return ownedTokens[_owner][_index];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the total amount of tokens stored by the contract\\r\\n   * @return uint256 representing the total amount of tokens\\r\\n   */\\r\\n  function totalSupply() public view returns (uint256) {\\r\\n    return allTokens.length;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the token ID at a given index of all the tokens in this contract\\r\\n   * Reverts if the index is greater or equal to the total number of tokens\\r\\n   * @param _index uint256 representing the index to be accessed of the tokens list\\r\\n   * @return uint256 token ID at the given index of the tokens list\\r\\n   */\\r\\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\\r\\n    require(_index \\u003c totalSupply(), \\\"Invalid index\\\");\\r\\n    return allTokens[_index];\\r\\n  }\\r\\n\\r\\n  // @dev This function is not needed as token URI will be created automatically based in base URL\\r\\n  // /**\\r\\n  //  * @dev Internal function to set the token URI for a given token\\r\\n  //  * Reverts if the token ID does not exist\\r\\n  //  * @param _tokenId uint256 ID of the token to set its URI\\r\\n  //  * @param _uri string URI to assign\\r\\n  //  */\\r\\n  // function _setTokenURI(uint256 _tokenId, string memory _uri) internal {\\r\\n  //   require(exists(_tokenId));\\r\\n  //   tokenURI[_tokenId] = _uri;\\r\\n  // }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to add a token ID to the list of a given address\\r\\n   * @param _to address representing the new owner of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\\r\\n   */\\r\\n  function addTokenTo(address _to, uint256 _tokenId) internal {\\r\\n    super.addTokenTo(_to, _tokenId);\\r\\n    uint256 length = ownedTokens[_to].length;\\r\\n    ownedTokens[_to].push(_tokenId);\\r\\n    ownedTokensIndex[_tokenId] = length;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to remove a token ID from the list of a given address\\r\\n   * @param _from address representing the previous owner of the given token ID\\r\\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\\r\\n   */\\r\\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\\r\\n    super.removeTokenFrom(_from, _tokenId);\\r\\n\\r\\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\\r\\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\\r\\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\\r\\n\\r\\n    ownedTokens[_from][tokenIndex] = lastToken;\\r\\n    ownedTokens[_from][lastTokenIndex] = 0;\\r\\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\\r\\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\\r\\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\\r\\n\\r\\n    ownedTokens[_from].length--;\\r\\n    ownedTokensIndex[_tokenId] = 0;\\r\\n    ownedTokensIndex[lastToken] = tokenIndex;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to mint a new token\\r\\n   * Reverts if the given token ID already exists\\r\\n   * @param _to address the beneficiary that will own the minted token\\r\\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\\r\\n   */\\r\\n  function _mint(address _to, uint256 _tokenId) internal {\\r\\n    super._mint(_to, _tokenId);\\r\\n\\r\\n    allTokensIndex[_tokenId] = allTokens.length;\\r\\n    allTokens.push(_tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to burn a specific token\\r\\n   * Reverts if the token does not exist\\r\\n   * @param _owner owner of the token to burn\\r\\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\\r\\n   */\\r\\n  function _burn(address _owner, uint256 _tokenId) internal {\\r\\n    super._burn(_owner, _tokenId);\\r\\n\\r\\n    // Clear metadata (if any)\\r\\n    // if (bytes(tokenURI[_tokenId]).length != 0) {\\r\\n    //   delete tokenURIs[_tokenId];\\r\\n    // }\\r\\n\\r\\n    // Reorg all tokens array\\r\\n    uint256 tokenIndex = allTokensIndex[_tokenId];\\r\\n    uint256 lastTokenIndex = allTokens.length.sub(1);\\r\\n    uint256 lastToken = allTokens[lastTokenIndex];\\r\\n\\r\\n    allTokens[tokenIndex] = lastToken;\\r\\n    allTokens[lastTokenIndex] = 0;\\r\\n\\r\\n    allTokens.length--;\\r\\n    allTokensIndex[_tokenId] = 0;\\r\\n    allTokensIndex[lastToken] = tokenIndex;\\r\\n  }\\r\\n}\"},\"Freezable.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./Ownership.sol\\\";\\r\\n\\r\\ncontract Freezable is Ownership {\\r\\n    \\r\\n    mapping (address =\\u003e bool) frozen;\\r\\n    bool public emergencyFreeze = false;\\r\\n\\r\\n    event Freezed(address targetAddress, bool frozen);\\r\\n    event EmerygencyFreezed(bool emergencyFreezeStatus);\\r\\n\\r\\n    modifier unfreezed(address _account) { \\r\\n        require(!frozen[_account]);\\r\\n        _;  \\r\\n    }\\r\\n    \\r\\n    modifier noEmergencyFreeze() { \\r\\n        require(!emergencyFreeze);\\r\\n        _; \\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Freeze account - onlyOwner\\r\\n    // ------------------------------------------------------------------------\\r\\n    function freezeAccount (address _target, bool _freeze) public onlyOwner returns(bool) {\\r\\n        frozen[_target] = _freeze;\\r\\n        emit Freezed(_target, _freeze);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Emerygency freeze - onlyOwner\\r\\n    // ------------------------------------------------------------------------\\r\\n    function emergencyFreezeAllAccounts (bool _freeze) public onlyOwner returns(bool) {\\r\\n        emergencyFreeze = _freeze;\\r\\n        emit EmerygencyFreezed(_freeze);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Get Freeze Status : Constant\\r\\n    // ------------------------------------------------------------------------\\r\\n    function isFreezed(address _targetAddress) public view returns (bool) {\\r\\n        return frozen[_targetAddress]; \\r\\n    }\\r\\n\\r\\n}\"},\"Ownership.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\ncontract Ownership {\\r\\n\\r\\n  address public owner;\\r\\n  address[] public deputyOwners;\\r\\n\\r\\n  mapping(address =\\u003e bool) public isDeputyOwner;\\r\\n\\r\\n  event OwnershipUpdated(address oldOwner, address newOwner);\\r\\n  event DeputyOwnerUpdated(address _do, bool _isAdded);\\r\\n\\r\\n  constructor() public {\\r\\n    owner = msg.sender;\\r\\n    deputyOwners = [msg.sender];\\r\\n  }\\r\\n\\r\\n  modifier onlyOwner() {\\r\\n    require(msg.sender == owner, \\\"Not owner\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier onlyDeputyOrOwner() {\\r\\n    require(msg.sender == owner || isDeputyOwner[msg.sender], \\\"Only owner or deputy owner is allowed\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Transfer the ownership to some other address.\\r\\n   * new owner can not be a zero address.\\r\\n   * Only owner can call this function\\r\\n   * @param _newOwner Address to which ownership is being transferred\\r\\n   */\\r\\n  function updateOwner(address _newOwner)\\r\\n    public\\r\\n    onlyOwner\\r\\n  {\\r\\n    require(_newOwner != address(0x0), \\\"Invalid address\\\");\\r\\n    owner = _newOwner;\\r\\n    emit OwnershipUpdated(msg.sender, owner);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Add new deputy owner.\\r\\n    * Only Owner can call this function\\r\\n    * New Deputy should not be zero address\\r\\n    * New Deputy should not be be already exisitng\\r\\n    * emit DeputyOwnerUdpatd event\\r\\n    * @param _newDO Address of new deputy owner\\r\\n   */\\r\\n  function addDeputyOwner(address _newDO)\\r\\n    public\\r\\n    onlyOwner\\r\\n  {\\r\\n    require(!isDeputyOwner[_newDO], \\\"Deputy Owner already exists\\\");\\r\\n    require(_newDO != address(0), \\\"Zero address not allowed\\\");\\r\\n    deputyOwners.push(_newDO);\\r\\n    isDeputyOwner[_newDO] = true;\\r\\n    emit DeputyOwnerUpdated(_newDO, true);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Remove an existing deputy owner.\\r\\n    * Only Owner can call this function\\r\\n    * Given address should be a deputy owner\\r\\n    * emit DeputyOwnerUdpatd event\\r\\n    * @param _existingDO Address of existing deputy owner\\r\\n   */\\r\\n  function removeDeputyOwner(address _existingDO)\\r\\n    public\\r\\n    onlyOwner\\r\\n  {\\r\\n    require(isDeputyOwner[_existingDO], \\\"Deputy Owner does not exits\\\");\\r\\n    uint existingId;\\r\\n    for(uint i=0; i\\u003cdeputyOwners.length; i++) {\\r\\n      if(deputyOwners[i] == _existingDO) existingId=i;\\r\\n    }\\r\\n\\r\\n    // swap this with last element\\r\\n    deputyOwners[existingId] = deputyOwners[deputyOwners.length-1];\\r\\n    delete deputyOwners[deputyOwners.length-1];\\r\\n    deputyOwners.length--;\\r\\n    isDeputyOwner[_existingDO] = false;\\r\\n    emit DeputyOwnerUpdated(_existingDO, false);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Renounce the ownership.\\r\\n   * This will leave the contract without any owner.\\r\\n   * Only owner can call this function\\r\\n   * @param _validationCode A code to prevent aaccidental calling of this function\\r\\n   */\\r\\n  function renounceOwnership(uint _validationCode)\\r\\n    public\\r\\n    onlyOwner\\r\\n  {\\r\\n    require(_validationCode == 123456789, \\\"Invalid code\\\");\\r\\n    owner = address(0);\\r\\n    emit OwnershipUpdated(msg.sender, owner);\\r\\n  }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.17;\\r\\n\\r\\nlibrary SafeMath {\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint256 c = a * b;\\r\\n    assert(c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n    return c;\\r\\n  }\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    assert(b \\u003c= a);\\r\\n    return a - b;\\r\\n  }\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    assert(c \\u003e= a \\u0026\\u0026 c\\u003e=b);\\r\\n    return c;\\r\\n  }\\r\\n}\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        uint256 index = digits - 1;\\r\\n        temp = value;\\r\\n        while (temp != 0) {\\r\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\r\\n            temp /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\"},\"SupportsInterfaceWithLookup.sol\":{\"content\":\"pragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./ERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SupportsInterfaceWithLookup\\r\\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\\r\\n * @dev Implements ERC165 using a lookup table.\\r\\n */\\r\\ncontract SupportsInterfaceWithLookup is ERC165 {\\r\\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\\r\\n  /**\\r\\n   * 0x01ffc9a7 ===\\r\\n   *   bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027))\\r\\n   */\\r\\n\\r\\n  /**\\r\\n   * @dev a mapping of interface id to whether or not it\\u0027s supported\\r\\n   */\\r\\n  mapping(bytes4 =\\u003e bool) internal supportedInterfaces;\\r\\n\\r\\n  /**\\r\\n   * @dev A contract implementing SupportsInterfaceWithLookup\\r\\n   * implement ERC165 itself\\r\\n   */\\r\\n  constructor()\\r\\n    public\\r\\n  {\\r\\n    _registerInterface(InterfaceId_ERC165);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev implement supportsInterface(bytes4) using a lookup table\\r\\n   */\\r\\n  function supportsInterface(bytes4 _interfaceId)\\r\\n    external\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    return supportedInterfaces[_interfaceId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev private method for registering an interface\\r\\n   */\\r\\n  function _registerInterface(bytes4 _interfaceId)\\r\\n    internal\\r\\n  {\\r\\n    require(_interfaceId != 0xffffffff);\\r\\n    supportedInterfaces[_interfaceId] = true;\\r\\n  }\\r\\n}\"},\"UserMintableNFT.sol\":{\"content\":\"/**\\r\\n * This is enhancement over custom NFT allowing users to mint tokens approved by admin\\r\\n * This contract will be used as enhanced version of NFT (v2)\\r\\n*/\\r\\n\\r\\npragma solidity 0.5.17;\\r\\n\\r\\nimport \\\"./CustomERC721.sol\\\";\\r\\n\\r\\ncontract UserMintableNFT is CustomERC721 {\\r\\n\\r\\n  mapping(address =\\u003e mapping(uint =\\u003e bool)) isNonceUsed;\\r\\n\\r\\n  constructor(string memory name, string memory symbol, string memory baseURI) public CustomERC721(name, symbol, baseURI)\\r\\n  {\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows anyone to mint token signed by admin\\r\\n   * Reverts if admin has not signed for `tokenId` or `to`\\r\\n   * @param r signature\\r\\n   * @param s signature\\r\\n   * @param v recovery id of signature\\r\\n   * @param tokenId tokenId to be minted\\r\\n   * @param to address to which tokens needs to be minted\\r\\n   * @param _signerNonce non-sequential nonce of signer to avoid replay protection\\r\\n   * @return bool true when operation is successful\\r\\n\\r\\n   */\\r\\n  function userMint(\\r\\n    bytes32 r, bytes32 s, uint8 v,\\r\\n    uint256 tokenId,\\r\\n    address to,\\r\\n    uint256 _signerNonce\\r\\n  )\\r\\n    public\\r\\n    noEmergencyFreeze\\r\\n    returns (bool)\\r\\n  {\\r\\n    \\r\\n    bytes32 message = keccak256(abi.encodePacked(\\r\\n      bytes4(0x8cd49589), // Keccak-256 hash of \\\"userMint\\\"\\r\\n      address(this),\\r\\n      _signerNonce,\\r\\n      to,\\r\\n      tokenId\\r\\n    ));\\r\\n    address signer = getSigner(message, r, s, v);\\r\\n    require(signer == owner || isDeputyOwner[signer], \\\"Admin should sign message\\\");\\r\\n    require(isNonceUsed[signer][_signerNonce], \\\"nonce already used\\\");\\r\\n    super._mint(to, tokenId);\\r\\n    isNonceUsed[signer][_signerNonce] = true;\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows anyone to mint tokens signed by admin\\r\\n   * Reverts if admin has not signed for `tokenIds` or `to`\\r\\n   * @param r signature\\r\\n   * @param s signature\\r\\n   * @param v recovery id of signature\\r\\n   * @param tokenIds tokenIds to be minted\\r\\n   * @param to address to which tokens needs to be minted\\r\\n   * @param _signerNonce non-sequential nonce of signer to avoid replay protection\\r\\n   * @return bool true when operation is successful\\r\\n   */\\r\\n  function userBulkMint(\\r\\n    bytes32 r, bytes32 s, uint8 v,\\r\\n    uint256[] memory tokenIds,\\r\\n    address to,\\r\\n    uint256 _signerNonce\\r\\n  )\\r\\n    public\\r\\n    noEmergencyFreeze\\r\\n    returns (bool)\\r\\n  {\\r\\n    bytes32 message = keccak256(abi.encodePacked(\\r\\n      bytes4(0x5827c1ff), // Keccak-256 hash of \\\"userBulkMint\\\"\\r\\n      address(this),\\r\\n      _signerNonce,\\r\\n      to,\\r\\n      tokenIds\\r\\n    ));\\r\\n    address signer = getSigner(message, r, s, v);\\r\\n    require(signer == owner || isDeputyOwner[signer], \\\"Admin should sign message\\\");\\r\\n    require(isNonceUsed[signer][_signerNonce], \\\"nonce already used\\\");\\r\\n    for(uint256 i=0; i\\u003ctokenIds.length; i++) {\\r\\n      super._mint(to, tokenIds[i]);\\r\\n    }\\r\\n    isNonceUsed[signer][_signerNonce] = true;\\r\\n    return true;\\r\\n  }\\r\\n  \\r\\n}\\r\\n\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_do\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isAdded\",\"type\":\"bool\"}],\"name\":\"DeputyOwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"emergencyFreezeStatus\",\"type\":\"bool\"}],\"name\":\"EmerygencyFreezed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"Freezed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC165\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDO\",\"type\":\"address\"}],\"name\":\"addDeputyOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_perm\",\"type\":\"bool\"}],\"name\":\"allowNormalUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"bulkMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deputyOwners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergencyFreeze\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"emergencyFreezeAllAccounts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"getMessageSetApprovalForAll\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getMessageTransfer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"getSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDeputyOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetAddress\",\"type\":\"address\"}],\"name\":\"isFreezed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isNormalUserAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"message\",\"type\":\"uint256\"}],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"provable_setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"provable_transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_existingDO\",\"type\":\"address\"}],\"name\":\"removeDeputyOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_validationCode\",\"type\":\"uint256\"}],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newURI\",\"type\":\"string\"}],\"name\":\"updateBaseTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_signerNonce\",\"type\":\"uint256\"}],\"name\":\"userBulkMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_signerNonce\",\"type\":\"uint256\"}],\"name\":\"userMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawAnyERC721Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UserMintableNFT", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000019446f63746f722057686f202d20576f726c64732041706172740000000000000000000000000000000000000000000000000000000000000000000000000000044457574100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003968747470733a2f2f646f63746f7277686f2d776f726c647361706172742e636f6d2f647277686f2f61737365742f64657461696c732f69642f00000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://4d2badfcb522c45cd317df3a7766cccc8e25cc4a4847f7c78c88f3702501316c"}