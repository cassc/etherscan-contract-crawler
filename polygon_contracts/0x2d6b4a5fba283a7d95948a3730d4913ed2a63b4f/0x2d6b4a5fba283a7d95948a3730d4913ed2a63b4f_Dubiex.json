{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Dubiex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./DubiexLib.sol\\\";\\n\\ncontract Dubiex is ReentrancyGuard, ERC721Holder {\\n    using SafeERC20 for IERC20;\\n\\n    // This is a empty order to workaround:\\n    // \\\"This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour\\\"\\n    // In places where we need to return a zero-initialized storage order.\\n    DubiexLib.PackedOrderBookItem private _emptyOrder;\\n\\n    address private immutable _prps;\\n    address private immutable _dubi;\\n\\n    // Security mechanism which anyone can enable if the total supply of PRPS or DUBI should ever go >= 1 billion\\n    bool private _killSwitchOn;\\n\\n    function activateKillSwitch() public {\\n        require(!_killSwitchOn, \\\"Dubiex: kill switch already on\\\");\\n\\n        uint256 oneBillion = 1000000000 * 1 ether;\\n\\n        uint256 totalPrpsSupply = IERC20(_prps).totalSupply();\\n        uint256 totalDubiSupply = IERC20(_dubi).totalSupply();\\n\\n        require(\\n            totalPrpsSupply >= oneBillion || totalDubiSupply >= oneBillion,\\n            \\\"Dubiex: total supply too low\\\"\\n        );\\n        _killSwitchOn = true;\\n    }\\n\\n    constructor(address prps, address dubi) ReentrancyGuard() {\\n        _prps = prps;\\n        _dubi = dubi;\\n    }\\n\\n    event MadeOrder(\\n        uint32 id,\\n        address maker,\\n        DubiexLib.OrderPair orderPair,\\n        // uint96 makerValue, uint96 takerValue, uint32 orderPairAlias, uint32 padding\\n        uint256 packedData\\n    );\\n\\n    event TookOrder(\\n        uint32 id,\\n        address maker,\\n        address taker,\\n        // uint96 makerValue, uint96 takerValue, uint32 orderPairAlias, uint32 padding\\n        uint256 packedData\\n    );\\n    event CanceledOrder(address maker, uint32 id);\\n\\n    event UpdatedOrder(address maker, uint32 id, uint256 updatedRatioWei);\\n\\n    /**\\n     * @dev Order pair aliases are generated by incrementing a number. Although the counter\\n     * is using 32 bits, we do not support more than 2**28 = 268_435_456 pairs for technical reasons.\\n     */\\n    uint32 private _orderPairAliasCounter;\\n\\n    /**\\n     * @dev A mapping of order pair alias to a packed order pair.\\n     */\\n    mapping(uint32 => DubiexLib.PackedOrderPair) private _orderPairsByAlias;\\n    /**\\n     * @dev A reverse mapping of order pair hash to an order pair alias. Required to check if\\n     * a given pair already exists when creating an order where the full pair information are\\n     * provided instead of an alias. I.e.\\n     * MakeOrder {\\n     *    ...\\n     *    makerCurrencyType: ...,\\n     *    takerCurrencyType: ...,\\n     *    makerContractAddress: ...,\\n     *    takerContractAddress: ...,\\n     * }\\n     *\\n     * The hash of these four fields is used as the key of the mapping.\\n     */\\n    mapping(bytes32 => uint32) private _orderPairAliasesByHash;\\n\\n    /**\\n     * @dev Mapping of address to a counter for order ids.\\n     */\\n    mapping(address => uint32) private _counters;\\n\\n    /**\\n     * @dev Mapping of orderKey (keccak256(abi.encode(maker, orderId))) to packed order book items.\\n     */\\n    mapping(bytes32 => DubiexLib.PackedOrderBookItem) private _packedOrders;\\n\\n    /**\\n     * @dev Get an order by id. If the id doesn't exist (e.g. got cancelled / filled), a default order is returned.\\n     * The caller should therefore check the id of the returned item. Any non-zero value means the order exists.\\n     */\\n    function getOrder(address maker, uint32 id)\\n        public\\n        view\\n        returns (DubiexLib.PrettyOrderBookItem memory)\\n    {\\n        bytes32 key = DubiexLib.getOrderKey(maker, id);\\n        DubiexLib.PackedOrderBookItem storage _packed = _packedOrders[key];\\n        if (_packed.packedData == 0) {\\n            DubiexLib.PrettyOrderBookItem memory empty;\\n            return empty;\\n        }\\n\\n        DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib\\n            .unpackOrderBookItem(_packed.packedData);\\n\\n        DubiexLib.PrettyOrderBookItem memory pretty;\\n        pretty.id = _unpacked.id;\\n        pretty.makerValue = _unpacked.makerValue;\\n        pretty.takerValue = _unpacked.takerValue;\\n\\n        pretty.orderPairAlias = _unpacked.orderPairAlias;\\n        pretty.pair = getOrderPairByAlias(_unpacked.orderPairAlias);\\n\\n        pretty.flags = _unpacked.flags;\\n\\n        return pretty;\\n    }\\n\\n    /**\\n     * @dev Get an order pair by alias.\\n     */\\n    function getOrderPairByAlias(uint32 orderPairAlias)\\n        public\\n        view\\n        returns (DubiexLib.OrderPair memory)\\n    {\\n        DubiexLib.OrderPair memory orderPair;\\n\\n        DubiexLib.PackedOrderPair storage packedOrderPair = _orderPairsByAlias[\\n            orderPairAlias\\n        ];\\n\\n        (\\n            address makerContractAddress,\\n            DubiexLib.CurrencyType makerCurrencyType\\n        ) = DubiexLib.unpackOrderPairAddressType(packedOrderPair.makerPair);\\n\\n        (\\n            address takerContractAddress,\\n            DubiexLib.CurrencyType takerCurrencyType\\n        ) = DubiexLib.unpackOrderPairAddressType(packedOrderPair.takerPair);\\n\\n        orderPair.makerContractAddress = makerContractAddress;\\n        orderPair.makerCurrencyType = makerCurrencyType;\\n        orderPair.takerContractAddress = takerContractAddress;\\n        orderPair.takerCurrencyType = takerCurrencyType;\\n\\n        return orderPair;\\n    }\\n\\n    /**\\n     * @dev Get an order pair by it's hash.\\n     */\\n    function getOrderPairByHash(bytes32 orderPairHash)\\n        public\\n        view\\n        returns (DubiexLib.OrderPair memory)\\n    {\\n        uint32 orderPairAlias = _orderPairAliasesByHash[orderPairHash];\\n        return getOrderPairByAlias(orderPairAlias);\\n    }\\n\\n    /**\\n     * @dev Get an order pair alias by it's hash.\\n     */\\n    function getOrderPairAliasByHash(bytes32 orderPairHash)\\n        public\\n        view\\n        returns (uint32)\\n    {\\n        return _orderPairAliasesByHash[orderPairHash];\\n    }\\n\\n    /**\\n     * @dev Make a single order. Reverts on failure.\\n     *\\n     * If an `orderId` is provided, an already existing order will be updated\\n     * according to `updatedWeiRatio`. For efficiency reasons, the id of the updated order\\n     * remains the same. Taker orders provide a minimum ratio to protect themselves against\\n     * front-running by the maker.\\n     *\\n     * Returns the assigned order id.\\n     */\\n    function makeOrder(DubiexLib.MakeOrderInput memory input)\\n        external\\n        payable\\n        nonReentrant\\n        returns (uint32)\\n    {\\n        require(!_killSwitchOn, \\\"Dubiex: kill switch on\\\");\\n\\n        uint256 excessEth = msg.value;\\n        uint32 orderId;\\n\\n        (orderId, excessEth) = _makeOrderInternal({\\n            input: input,\\n            maker: payable(msg.sender),\\n            excessEth: excessEth,\\n            revertOnUpdateError: true\\n        });\\n\\n        _refundExcessEth(excessEth);\\n\\n        return orderId;\\n    }\\n\\n    /**\\n     * @dev Create multiple orders at once. The transaction won't revert if any make order fails, but\\n     * silently ignore it. Returns an array of order ids where each item corresponds to an input\\n     * at the same index and non-zero values indicate success.\\n     */\\n    function makeOrders(DubiexLib.MakeOrderInput[] memory inputs)\\n        external\\n        payable\\n        nonReentrant\\n        returns (uint32[] memory)\\n    {\\n        require(!_killSwitchOn, \\\"Dubiex: kill switch on\\\");\\n        require(inputs.length > 0, \\\"Dubiex: empty inputs\\\");\\n\\n        uint32[] memory orderIds = new uint32[](inputs.length);\\n\\n        uint256 excessEth = msg.value;\\n\\n        for (uint256 i = 0; i < inputs.length; i++) {\\n            uint32 orderId;\\n\\n            (orderId, excessEth) = _makeOrderInternal({\\n                input: inputs[i],\\n                maker: payable(msg.sender),\\n                excessEth: excessEth,\\n                revertOnUpdateError: false\\n            });\\n\\n            orderIds[i] = orderId;\\n        }\\n\\n        _refundExcessEth(excessEth);\\n\\n        return orderIds;\\n    }\\n\\n    /**\\n     * @dev Take a single order. Reverts on failure.\\n     */\\n    function takeOrder(DubiexLib.TakeOrderInput calldata input)\\n        external\\n        payable\\n        nonReentrant\\n    {\\n        require(!_killSwitchOn, \\\"Dubiex: kill switch on\\\");\\n\\n        uint256 excessEth = msg.value;\\n\\n        (, excessEth, ) = _takeOrderInternal({\\n            input: input,\\n            taker: payable(msg.sender),\\n            excessEth: excessEth,\\n            revertOnError: true\\n        });\\n\\n        _refundExcessEth(excessEth);\\n    }\\n\\n    /**\\n     * @dev Take multiple orders at once. The transaction won't revert if any take order fails, but\\n     * silently ignore it. Check the logs in the receipt to see if any failed.\\n     *\\n     * See `takeOrder` for more information about the opt-in.\\n     *\\n     * @param inputs the take order inputs\\n     */\\n    function takeOrders(DubiexLib.TakeOrderInput[] calldata inputs)\\n        external\\n        payable\\n        nonReentrant\\n        returns (bool[] memory)\\n    {\\n        require(!_killSwitchOn, \\\"Dubiex: kill switch on\\\");\\n        require(inputs.length > 0, \\\"Dubiex: empty inputs\\\");\\n\\n        bool[] memory result = new bool[](inputs.length);\\n\\n        uint256 excessEth = msg.value;\\n\\n        for (uint256 i = 0; i < inputs.length; i++) {\\n            bool success;\\n            (success, excessEth, ) = _takeOrderInternal({\\n                input: inputs[i],\\n                taker: payable(msg.sender),\\n                excessEth: excessEth,\\n                revertOnError: false\\n            });\\n\\n            result[i] = success;\\n        }\\n\\n        _refundExcessEth(excessEth);\\n\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Cancel a single order.\\n     */\\n    function cancelOrder(DubiexLib.CancelOrderInput memory input)\\n        external\\n        nonReentrant\\n    {\\n        _cancelOrderInternal({\\n            maker: input.maker,\\n            id: input.id,\\n            revertOnError: true,\\n            isKillSwitchOn: _killSwitchOn\\n        });\\n    }\\n\\n    /**\\n     * @dev Cancel multiple orders at once. It will not revert on error, but ignore failed\\n     * orders silently. Check the logs in the receipt to see if any failed.\\n     *\\n     * @return Array of booleans with `ids.length` items where each item corresponds to an id\\n     * at the same index and `true` indicate success.\\n     */\\n    function cancelOrders(DubiexLib.CancelOrderInput[] calldata inputs)\\n        external\\n        nonReentrant\\n        returns (bool[] memory)\\n    {\\n        require(inputs.length > 0, \\\"Dubiex: empty inputs\\\");\\n\\n        bool[] memory result = new bool[](inputs.length);\\n\\n        bool isKillSwitchOn = _killSwitchOn;\\n\\n        for (uint256 i = 0; i < inputs.length; i++) {\\n            result[i] = _cancelOrderInternal({\\n                maker: inputs[i].maker,\\n                id: inputs[i].id,\\n                revertOnError: false,\\n                isKillSwitchOn: isKillSwitchOn\\n            });\\n        }\\n\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Create a new single order.\\n     *\\n     * @return the assigned order id\\n     */\\n    function _makeOrderInternal(\\n        DubiexLib.MakeOrderInput memory input,\\n        address payable maker,\\n        uint256 excessEth,\\n        bool revertOnUpdateError\\n    ) private returns (uint32, uint256) {\\n        require(\\n            maker != address(this) && maker != address(0),\\n            \\\"Dubiex: unexpected maker\\\"\\n        );\\n\\n        // An explicit id means an existing order should be updated.\\n        if (input.orderId > 0) {\\n            return (\\n                _updateOrder(\\n                    maker,\\n                    input.orderId,\\n                    input.updatedRatioWei,\\n                    revertOnUpdateError\\n                ),\\n                // Update order never uses eth, so we refund everything in case something was mistakenly sent\\n                excessEth\\n            );\\n        }\\n\\n        // Reverts if the input is invalid\\n        require(input.makerValue > 0, \\\"Dubiex: zero makerValue\\\");\\n        require(input.takerValue > 0, \\\"Dubiex: zero takerValue\\\");\\n\\n        // Reverts if the order pair is incompatible\\n        uint32 orderPairAlias = _getOrCreateOrderPairAlias(input.pair);\\n\\n        // Deposit the makerValue, which will fail if no approval has been given\\n        // or the maker hasn't enough funds.\\n        // NOTE(reentrancy): safe, because we are using `nonReentrant` for makeOrder(s).\\n        bool deposited;\\n\\n        (deposited, excessEth) = _transfer({\\n            from: maker,\\n            to: payable(address(this)),\\n            value: input.makerValue,\\n            valueContractAddress: input.pair.makerContractAddress,\\n            valueCurrencyType: input.pair.makerCurrencyType,\\n            excessEth: excessEth\\n        });\\n\\n        require(deposited, \\\"Dubiex: failed to deposit\\\");\\n\\n        // Create the orderbook item\\n        DubiexLib.PackedOrderBookItem memory _packed;\\n\\n        DubiexLib.UnpackedOrderBookItem memory _unpacked;\\n        _unpacked.id = _getNextOrderId(maker);\\n        _unpacked.makerValue = input.makerValue;\\n        _unpacked.takerValue = input.takerValue;\\n        _unpacked.orderPairAlias = orderPairAlias;\\n        _unpacked.flags.isMakerERC721 =\\n            input.pair.makerCurrencyType == DubiexLib.CurrencyType.ERC721;\\n        _unpacked.flags.isTakerERC721 =\\n            input.pair.takerCurrencyType == DubiexLib.CurrencyType.ERC721;\\n\\n        // Pack unpacked data and write to storage\\n        _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);\\n\\n        bytes32 key = DubiexLib.getOrderKey(maker, _unpacked.id);\\n        _packedOrders[key] = _packed;\\n\\n        // Emit event and done\\n\\n        uint256 packedData;\\n        packedData |= input.makerValue;\\n        packedData |= uint256(input.takerValue) << 96;\\n        packedData |= uint256(orderPairAlias) << (96 + 96);\\n\\n        emit MadeOrder(_unpacked.id, maker, input.pair, packedData);\\n\\n        return (_unpacked.id, excessEth);\\n    }\\n\\n    /**\\n     * @dev Take a make order.\\n     * @param input the take order input.\\n     * @param taker address of the taker\\n     * @param revertOnError whether to revert on errors or not. True, when taking a single order.\\n     *\\n     */\\n    function _takeOrderInternal(\\n        address payable taker,\\n        DubiexLib.TakeOrderInput memory input,\\n        uint256 excessEth,\\n        bool revertOnError\\n    )\\n        private\\n        returns (\\n            bool,\\n            uint256,\\n            DubiexLib.CurrencyType\\n        )\\n    {\\n        (\\n            bytes32 _orderKey,\\n            DubiexLib.PackedOrderBookItem storage _packed,\\n            DubiexLib.UnpackedOrderBookItem memory _unpacked\\n        ) = _assertTakeOrderInput(input, revertOnError);\\n\\n        // Order doesn't exist or input is invalid.\\n        if (_unpacked.id == 0) {\\n            // Only gets here if 'revertOnError' is false\\n            return (false, excessEth, DubiexLib.CurrencyType.NULL);\\n        }\\n\\n        // Get the actual makerValue, which might just be a fraction of the total\\n        // `takerValue` of the `_makeOrder`.\\n        //\\n        // makerValue = how much of the order will be filled\\n        // takerValue = how much the user is going to pay for it\\n        (uint96 _makerValue, uint96 _takerValue) = _calculateMakerAndTakerValue(\\n            _unpacked,\\n            input.takerValue,\\n            input.maxTakerMakerRatio\\n        );\\n        if (_makerValue == 0 || _takerValue == 0) {\\n            if (revertOnError) {\\n                revert(\\\"Dubiex: invalid takerValue\\\");\\n            }\\n\\n            return (false, excessEth, DubiexLib.CurrencyType.NULL);\\n        }\\n\\n        // Transfer from taker to maker\\n        excessEth = _transferFromTakerToMaker(\\n            taker,\\n            input.maker,\\n            _takerValue,\\n            _unpacked.pair,\\n            excessEth\\n        );\\n\\n        // Transfer from maker to taker\\n        if (\\n            !_transferFromContractToTaker(taker, _makerValue, _unpacked.pair, 0)\\n        ) {\\n            if (revertOnError) {\\n                revert(\\\"Dubiex: bad transfer to taker\\\");\\n            }\\n\\n            return (false, excessEth, DubiexLib.CurrencyType.NULL);\\n        }\\n\\n        // If filled, the order can be deleted (without having to update the maker/taker value)\\n        if (_unpacked.makerValue - _makerValue == 0) {\\n            // Delete the filled order\\n            delete _packedOrders[_orderKey];\\n        } else {\\n            // Not filled yet, so update original make order\\n            _unpacked.makerValue -= _makerValue;\\n            _unpacked.takerValue -= _takerValue;\\n\\n            // Write updated item to storage\\n            _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);\\n        }\\n\\n        // NOTE: We write the new taker/maker value to the in-memory struct\\n        // and pass it to a function that emits 'TookOrder' to avoid the 'Stack too deep' error\\n        _unpacked.makerValue = _makerValue;\\n        _unpacked.takerValue = _takerValue;\\n\\n        return _emitTookOrder(input.maker, taker, _unpacked, excessEth);\\n    }\\n\\n    /**\\n     * @dev Emit 'TookOrder' in a separate function to avoid the 'Stack too deep' error\\n     */\\n    function _emitTookOrder(\\n        address maker,\\n        address taker,\\n        DubiexLib.UnpackedOrderBookItem memory unpacked,\\n        uint256 excessEth\\n    )\\n        private\\n        returns (\\n            bool,\\n            uint256,\\n            DubiexLib.CurrencyType\\n        )\\n    {\\n        uint256 packedData;\\n        packedData |= unpacked.makerValue;\\n        packedData |= uint256(unpacked.takerValue) << 96;\\n        packedData |= uint256(unpacked.orderPairAlias) << (96 + 96);\\n\\n        emit TookOrder(unpacked.id, maker, taker, packedData);\\n\\n        return (true, excessEth, unpacked.pair.takerCurrencyType);\\n    }\\n\\n    function _cancelOrderInternal(\\n        address payable maker,\\n        uint32 id,\\n        bool revertOnError,\\n        bool isKillSwitchOn\\n    ) private returns (bool) {\\n        // Anyone can cancel any order if the kill switch is on, otherwise `msg.sender` must be the maker.\\n        if (!isKillSwitchOn) {\\n            require(maker == msg.sender, \\\"Dubiex: msg.sender must be maker\\\");\\n        }\\n\\n        if (!revertOnError && !_orderExists(maker, id)) {\\n            return false;\\n        }\\n\\n        // Get the make order (reverts if order doesn't exist)\\n        (\\n            bytes32 _orderKey,\\n            ,\\n            DubiexLib.UnpackedOrderBookItem memory unpacked\\n        ) = _safeGetOrder(maker, id, DubiexLib.OrderPairReadStrategy.MAKER);\\n\\n        // Transfer remaining `makerValue` back to maker, by assuming the taker role with the maker.\\n\\n        if (\\n            !_transferFromContractToTaker({\\n                taker: maker,\\n                makerValue: unpacked.makerValue,\\n                pair: unpacked.pair,\\n                excessEth: 0\\n            })\\n        ) {\\n            return false;\\n        }\\n\\n        // Delete the cancelled order\\n        delete _packedOrders[_orderKey];\\n\\n        emit CanceledOrder(maker, id);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update the `takerValue` of an order using the given `updatedRatioWei`\\n     * @param maker the maker of the order to update\\n     * @param orderId the id of the existing order\\n     * @param updatedRatioWei the new ratio in wei\\n     */\\n    function _updateOrder(\\n        address maker,\\n        uint32 orderId,\\n        uint128 updatedRatioWei,\\n        bool revertOnUpdateError\\n    ) private returns (uint32) {\\n        (\\n            ,\\n            DubiexLib.PackedOrderBookItem storage _packed,\\n            DubiexLib.UnpackedOrderBookItem memory _unpacked\\n        ) = _getOrder(maker, orderId, DubiexLib.OrderPairReadStrategy.SKIP);\\n\\n        // Order doesn't exist\\n        if (_unpacked.id == 0) {\\n            if (revertOnUpdateError) {\\n                revert(\\\"Dubiex: order does not exist\\\");\\n            }\\n\\n            return 0;\\n        }\\n\\n        // We don't prevent reverts here, even if `revertOnUpdateError` is false since\\n        // they are user errors unlike a non-existing order which a user has no control over.\\n\\n        require(updatedRatioWei > 0, \\\"Dubiex: ratio is 0\\\");\\n\\n        require(\\n            !_unpacked.flags.isMakerERC721 && !_unpacked.flags.isTakerERC721,\\n            \\\"Dubiex: cannot update ERC721\\\"\\n        );\\n\\n        // Update the existing order with the new ratio to the takerValue.\\n        // The makerValue stays untouched.\\n\\n        uint256 updatedTakerValue = (uint256(_unpacked.makerValue) *\\n            uint256(updatedRatioWei)) / 1 ether;\\n\\n        require(updatedTakerValue < 2**96, \\\"Dubiex: takerValue overflow\\\");\\n\\n        _unpacked.takerValue = uint96(updatedTakerValue);\\n        _packed.packedData = DubiexLib.packOrderBookItem(_unpacked);\\n\\n        emit UpdatedOrder(maker, orderId, updatedRatioWei);\\n\\n        return orderId;\\n    }\\n\\n    // If both returned values are > 0, then the provided `takerValue` and `maxTakerMakerRatio` are valid.\\n    function _calculateMakerAndTakerValue(\\n        DubiexLib.UnpackedOrderBookItem memory _unpacked, // storage item\\n        uint96 takerValue, // input.takerValue,\\n        uint256 maxTakerMakerRatio // input.maxTakerMakerRatio\\n    ) private pure returns (uint96, uint96) {\\n        uint256 calculatedMakerValue = _unpacked.makerValue;\\n        uint256 calculatedTakerValue = takerValue;\\n\\n        // ERC721 cannot be bought/sold partially, therefore the `takerValue` must match the requested\\n        // value exactly.\\n        if (\\n            _unpacked.pair.makerCurrencyType == DubiexLib.CurrencyType.ERC721 ||\\n            _unpacked.pair.takerCurrencyType == DubiexLib.CurrencyType.ERC721\\n        ) {\\n            if (takerValue != _unpacked.takerValue) {\\n                return (0, 0);\\n            }\\n\\n            // The order gets filled completely, so we use the values as is.\\n        } else {\\n            // Calculate the current takerMakerValue ratio and compare it to `maxTakerMakerRatio`.\\n            // If it is higher then the order will not be taken.\\n            uint256 takerMakerRatio = (uint256(_unpacked.takerValue) *\\n                1 ether) / _unpacked.makerValue;\\n\\n            if (takerMakerRatio > maxTakerMakerRatio) {\\n                return (0, 0);\\n            }\\n\\n            // don't pay more than needed\\n            // input.takerValue = min(input.takerValue, _unpacked.takerValue)\\n            //\\n            if (calculatedTakerValue > _unpacked.takerValue) {\\n                calculatedTakerValue = _unpacked.takerValue;\\n            }\\n\\n            // Calculate actual makerValue for ETH/ERC20 trades which might only get partially filled by the\\n            // takerValue. Since we don't have decimals, we need to multiply by 10^18 and divide by it again at the end\\n            // to not lose any information.\\n            calculatedMakerValue *= 1 ether;\\n            calculatedMakerValue *= calculatedTakerValue;\\n            calculatedMakerValue /= _unpacked.takerValue;\\n            calculatedMakerValue /= 1 ether;\\n\\n            // EXAMPLE\\n            //\\n            // seller 10 prps for 5 dubi\\n            // buyer  8 prps for 4 dubi\\n            //\\n            // order:\\n            //   maker=10 (prps)\\n            //   taker=5  (dubi)\\n            //\\n            // input:\\n            //   taker=4\\n            //   maxTakerMakerRatio=2\\n            //\\n            // takeRatio = 5 / 4  (we're going to buy 80% of the order)\\n            // makerV = 10 * takeRatio\\n        }\\n\\n        // Sanity checks\\n        assert(\\n            calculatedMakerValue < 2**96 &&\\n                calculatedMakerValue <= _unpacked.makerValue\\n        );\\n        assert(\\n            calculatedTakerValue < 2**96 &&\\n                calculatedTakerValue <= _unpacked.takerValue\\n        );\\n\\n        return (uint96(calculatedMakerValue), uint96(calculatedTakerValue));\\n    }\\n\\n    /**\\n     * @dev Assert a take order input and return the order. If a zero-order is returned,\\n     * then it does not exist and it is up to the caller how to handle it.\\n     */\\n    function _assertTakeOrderInput(\\n        DubiexLib.TakeOrderInput memory input,\\n        bool revertOnError\\n    )\\n        private\\n        view\\n        returns (\\n            bytes32,\\n            DubiexLib.PackedOrderBookItem storage,\\n            DubiexLib.UnpackedOrderBookItem memory\\n        )\\n    {\\n        (\\n            bytes32 key,\\n            DubiexLib.PackedOrderBookItem storage packed,\\n            DubiexLib.UnpackedOrderBookItem memory unpacked\\n        ) = _getOrder(\\n                input.maker,\\n                input.id,\\n                DubiexLib.OrderPairReadStrategy.FULL\\n            );\\n\\n        bool validTakerValue = input.takerValue > 0;\\n        bool orderExists = unpacked.id > 0;\\n        if (revertOnError) {\\n            require(validTakerValue, \\\"Dubiex: zero takerValue\\\");\\n\\n            require(orderExists, \\\"Dubiex: order does not exist\\\");\\n        } else {\\n            if (!validTakerValue || !orderExists) {\\n                DubiexLib.UnpackedOrderBookItem memory emptyUnpacked;\\n                return (bytes32(0), _emptyOrder, emptyUnpacked);\\n            }\\n        }\\n\\n        return (key, packed, unpacked);\\n    }\\n\\n    function _orderExists(address maker, uint32 id)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        bytes32 key = DubiexLib.getOrderKey(maker, id);\\n\\n        DubiexLib.PackedOrderBookItem storage _packed = _packedOrders[key];\\n        if (_packed.packedData == 0) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    function _refundExcessEth(uint256 excessEth) private {\\n        // Sanity check\\n        assert(msg.value >= excessEth);\\n\\n        if (excessEth > 0) {\\n            payable(msg.sender).transfer(excessEth);\\n        }\\n    }\\n\\n    // Transfer `takerValue` to `maker`.\\n    function _transferFromTakerToMaker(\\n        address payable taker,\\n        address payable maker,\\n        uint96 takerValue,\\n        DubiexLib.OrderPair memory pair,\\n        uint256 excessEth\\n    ) private returns (uint256) {\\n        bool success;\\n        (success, excessEth) = _transfer(\\n            taker,\\n            maker,\\n            takerValue,\\n            pair.takerContractAddress,\\n            pair.takerCurrencyType,\\n            excessEth\\n        );\\n\\n        require(success, \\\"Dubiex: bad transfer to maker\\\");\\n\\n        return excessEth;\\n    }\\n\\n    // Transfer `makerValue` to `taker`\\n    function _transferFromContractToTaker(\\n        address payable taker,\\n        uint96 makerValue,\\n        DubiexLib.OrderPair memory pair,\\n        uint256 excessEth\\n    ) private returns (bool) {\\n        (bool success, ) = _transfer(\\n            payable(address(this)),\\n            taker,\\n            makerValue,\\n            pair.makerContractAddress,\\n            pair.makerCurrencyType,\\n            excessEth\\n        );\\n\\n        return success;\\n    }\\n\\n    function _transfer(\\n        address payable from,\\n        address payable to,\\n        uint256 value,\\n        address valueContractAddress,\\n        DubiexLib.CurrencyType valueCurrencyType,\\n        uint256 excessEth\\n    ) private returns (bool, uint256) {\\n        if (valueCurrencyType == DubiexLib.CurrencyType.ETH) {\\n            // Eth is a bit special, because it's not a token. Therefore we need to ensure\\n            // that the taker/maker sent enough eth (`excessEth` >= `value`) and also that\\n            // he is refunded at the end of the transaction properly.\\n            if (from != address(this)) {\\n                if (excessEth < value) {\\n                    return (false, excessEth);\\n                }\\n\\n                // Got enough eth, but maybe too much, so we subtract the value from the excessEth. This is important\\n                // to refund the sender correctly e.g. he mistakenly sent too much or the order\\n                // was partially filled while his transaction was pending.\\n                excessEth -= value;\\n            }\\n\\n            // Not a deposit, so transfer eth owned by this contract to maker or taker\\n            if (to != address(this)) {\\n                // https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\\n                // https://ethereum.stackexchange.com/questions/78124/is-transfer-still-safe-after-the-istanbul-update\\n                // solhint-disable-next-line avoid-low-level-calls\\n                (bool success, ) = to.call{value: value}(\\\"\\\");\\n                return (success, excessEth);\\n            }\\n\\n            return (true, excessEth);\\n        }\\n\\n        if (valueCurrencyType == DubiexLib.CurrencyType.ERC20) {\\n            IERC20 erc20 = IERC20(valueContractAddress);\\n\\n            if (from == address(this)) {\\n                // If sending own tokens, use `safeTransfer` because Dubiex doesn't have any allowance\\n                // for itself which would cause `safeTransferFrom` to fail.\\n                erc20.safeTransfer(to, value);\\n            } else {\\n                erc20.safeTransferFrom(from, to, value);\\n            }\\n\\n            return (true, excessEth);\\n        }\\n\\n        if (valueCurrencyType == DubiexLib.CurrencyType.ERC721) {\\n            IERC721 erc721 = IERC721(valueContractAddress);\\n            erc721.safeTransferFrom(from, to, value, \\\"\\\");\\n            return (true, excessEth);\\n        }\\n\\n        revert(\\\"Dubiex: unexpected currency type\\\");\\n    }\\n\\n    /**\\n     * @dev Validates that the given contract address and currency type are compatible.\\n     * @param currencyType type of the currency\\n     * @param contractAddress the contract address associated with currency\\n     */\\n    function _validateCurrencyType(\\n        DubiexLib.CurrencyType currencyType,\\n        address contractAddress\\n    ) private returns (bool) {\\n        if (currencyType == DubiexLib.CurrencyType.ETH) {\\n            require(\\n                contractAddress == address(0),\\n                \\\"Dubiex: expected zero address\\\"\\n            );\\n            return true;\\n        }\\n\\n        if (currencyType == DubiexLib.CurrencyType.ERC721) {\\n            // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n            //\\n            // `contractAddress` must implement the ERC721 standard. According to the ERC721 standard\\n            // every compliant token is also expected to use ERC165 for that.\\n            require(\\n                IERC165(contractAddress).supportsInterface(\\n                    type(IERC721).interfaceId\\n                ),\\n                \\\"Dubiex: not ERC721 compliant\\\"\\n            );\\n            return true;\\n        }\\n\\n        if (currencyType == DubiexLib.CurrencyType.ERC20) {\\n            // Using `call` is our last-resort to check if the given contract implements\\n            // ERC721, since we can't just call `supportsInterface` directly without reverting\\n            // if `contractAddress` doesn't implement it. Unlike above, where we want an ERC721,\\n            // so reverting is fine for non-ERC721 contracts.\\n            //\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, bytes memory result) = contractAddress.call(\\n                abi.encodeWithSelector(\\n                    IERC165.supportsInterface.selector,\\n                    type(IERC721).interfaceId\\n                )\\n            );\\n\\n            // The call above must either fail (success = false) or if it succeeds,\\n            // return false.\\n            bool isERC721 = false;\\n            if (result.length > 0) {\\n                isERC721 = abi.decode(result, (bool));\\n            }\\n\\n            require(!success || !isERC721, \\\"Dubiex: ERC20 implements ERC721\\\");\\n\\n            // Lastly, we heuristically check if it responds to `balanceOf`.\\n            // If it succeeds, we assume it is an ERC20.\\n            result = Address.functionCall(\\n                contractAddress,\\n                abi.encodeWithSelector(\\n                    IERC20.balanceOf.selector,\\n                    contractAddress\\n                )\\n            );\\n            require(result.length > 0, \\\"Dubiex: not ERC20 compliant\\\");\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Increment the order id counter and return the new id.\\n     */\\n    function _getNextOrderId(address account) private returns (uint32) {\\n        uint32 currentId = _counters[account];\\n\\n        uint32 nextId = currentId + 1;\\n        _counters[account] = nextId;\\n\\n        return nextId;\\n    }\\n\\n    /**\\n     * @dev Get or create order pair alias from the given order pair.\\n     */\\n    function _getOrCreateOrderPairAlias(DubiexLib.OrderPair memory pair)\\n        private\\n        returns (uint32)\\n    {\\n        // Some legacy applications might still be using the BOOSTED_ERC20 type. It is fully\\n        // superseded by ERC20.\\n        if (pair.makerCurrencyType == DubiexLib.CurrencyType.BOOSTED_ERC20) {\\n            pair.makerCurrencyType = DubiexLib.CurrencyType.ERC20;\\n        }\\n\\n        if (pair.takerCurrencyType == DubiexLib.CurrencyType.BOOSTED_ERC20) {\\n            pair.takerCurrencyType = DubiexLib.CurrencyType.ERC20;\\n        }\\n\\n        bytes32 orderPairHash = keccak256(\\n            abi.encode(\\n                pair.makerContractAddress,\\n                pair.takerContractAddress,\\n                pair.makerCurrencyType,\\n                pair.takerCurrencyType\\n            )\\n        );\\n\\n        uint32 orderPairAlias = _orderPairAliasesByHash[orderPairHash];\\n        // If it doesn't exist yet, we create it (which makes the make order for the caller a bit more expensive).\\n        if (orderPairAlias == 0) {\\n            require(\\n                _validateCurrencyType(\\n                    pair.makerCurrencyType,\\n                    pair.makerContractAddress\\n                ),\\n                \\\"Dubiex: maker pair mismatch\\\"\\n            );\\n            require(\\n                _validateCurrencyType(\\n                    pair.takerCurrencyType,\\n                    pair.takerContractAddress\\n                ),\\n                \\\"Dubiex: taker pair mismatch\\\"\\n            );\\n\\n            require(\\n                pair.takerContractAddress != pair.makerContractAddress,\\n                \\\"Dubiex: order pair equal\\\"\\n            );\\n\\n            uint32 orderPairAliasCounter = _orderPairAliasCounter;\\n            orderPairAliasCounter++;\\n            // uint28.max = 2**28-1 = 268435455\\n            assert(orderPairAliasCounter < 268435455);\\n\\n            orderPairAlias = orderPairAliasCounter;\\n\\n            _orderPairAliasCounter = orderPairAliasCounter;\\n\\n            // Write mappings\\n            _orderPairAliasesByHash[orderPairHash] = orderPairAlias;\\n            _orderPairsByAlias[orderPairAlias] = DubiexLib.packOrderPair(pair);\\n        }\\n\\n        return orderPairAlias;\\n    }\\n\\n    function _safeGetOrderPairByAlias(\\n        uint32 orderPairAlias,\\n        DubiexLib.OrderPairReadStrategy strategy\\n    ) private view returns (DubiexLib.OrderPair memory) {\\n        DubiexLib.OrderPair memory _unpackedOrderPair;\\n\\n        if (strategy == DubiexLib.OrderPairReadStrategy.SKIP) {\\n            return _unpackedOrderPair;\\n        }\\n\\n        DubiexLib.PackedOrderPair storage _pairStorage = _orderPairsByAlias[\\n            orderPairAlias\\n        ];\\n\\n        // Read only maker info if requested\\n        if (\\n            strategy == DubiexLib.OrderPairReadStrategy.MAKER ||\\n            strategy == DubiexLib.OrderPairReadStrategy.FULL\\n        ) {\\n            (\\n                address makerContractAddress,\\n                DubiexLib.CurrencyType makerCurrencyType\\n            ) = DubiexLib.unpackOrderPairAddressType(_pairStorage.makerPair);\\n            _unpackedOrderPair.makerContractAddress = makerContractAddress;\\n            _unpackedOrderPair.makerCurrencyType = makerCurrencyType;\\n\\n            require(\\n                _unpackedOrderPair.makerCurrencyType !=\\n                    DubiexLib.CurrencyType.NULL,\\n                \\\"Dubiex: maker pair not found\\\"\\n            );\\n        }\\n\\n        // Read only taker info if requested\\n        if (\\n            strategy == DubiexLib.OrderPairReadStrategy.TAKER ||\\n            strategy == DubiexLib.OrderPairReadStrategy.FULL\\n        ) {\\n            (\\n                address takerContractAddress,\\n                DubiexLib.CurrencyType takerCurrencyType\\n            ) = DubiexLib.unpackOrderPairAddressType(_pairStorage.takerPair);\\n            _unpackedOrderPair.takerContractAddress = takerContractAddress;\\n            _unpackedOrderPair.takerCurrencyType = takerCurrencyType;\\n\\n            require(\\n                _unpackedOrderPair.takerCurrencyType !=\\n                    DubiexLib.CurrencyType.NULL,\\n                \\\"Dubiex: taker not found\\\"\\n            );\\n        }\\n\\n        return _unpackedOrderPair;\\n    }\\n\\n    /**\\n     * @dev Returns the order from `account` with the given id from storage\\n     * plus it's order key.\\n     *\\n     * If it cannot be found, then this function reverts, because we expect the\\n     * caller to operate on existing orders.\\n     */\\n    function _safeGetOrder(\\n        address account,\\n        uint32 id,\\n        DubiexLib.OrderPairReadStrategy strategy\\n    )\\n        private\\n        view\\n        returns (\\n            bytes32,\\n            DubiexLib.PackedOrderBookItem storage,\\n            DubiexLib.UnpackedOrderBookItem memory\\n        )\\n    {\\n        bytes32 key = DubiexLib.getOrderKey(account, id);\\n        DubiexLib.PackedOrderBookItem storage _packed = _packedOrders[key];\\n\\n        uint256 packedData = _packed.packedData;\\n        require(packedData > 0, \\\"Dubiex: order does not exist\\\");\\n\\n        DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib\\n            .unpackOrderBookItem(packedData);\\n\\n        _unpacked.pair = _safeGetOrderPairByAlias(\\n            _unpacked.orderPairAlias,\\n            strategy\\n        );\\n\\n        return (key, _packed, _unpacked);\\n    }\\n\\n    /**\\n     * @dev Returns the order from `account` with the given id from storage\\n     * plus it's order key.\\n     *\\n     * If it cannot be found, then this function does not revert and it's up to the\\n     * caller to decide.\\n     */\\n    function _getOrder(\\n        address account,\\n        uint32 id,\\n        DubiexLib.OrderPairReadStrategy strategy\\n    )\\n        private\\n        view\\n        returns (\\n            bytes32,\\n            DubiexLib.PackedOrderBookItem storage,\\n            DubiexLib.UnpackedOrderBookItem memory\\n        )\\n    {\\n        bytes32 key = DubiexLib.getOrderKey(account, id);\\n        DubiexLib.PackedOrderBookItem storage _packed = _packedOrders[key];\\n\\n        uint256 packedData = _packed.packedData;\\n        if (packedData == 0) {\\n            DubiexLib.UnpackedOrderBookItem memory __unpacked;\\n            return (bytes32(0), _emptyOrder, __unpacked);\\n        }\\n\\n        DubiexLib.UnpackedOrderBookItem memory _unpacked = DubiexLib\\n            .unpackOrderBookItem(packedData);\\n\\n        // Read the order pair with the given strategy\\n        // NOTE: This cannot revert when the order exists.\\n        _unpacked.pair = _safeGetOrderPairByAlias(\\n            _unpacked.orderPairAlias,\\n            strategy\\n        );\\n\\n        return (key, _packed, _unpacked);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: bad allowance\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DubiexLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.12;\\n\\n// keccak256(abi.encode(maker, orderId))\\ntype OrderKey is bytes32;\\n\\nlibrary DubiexLib {\\n    enum CurrencyType {\\n        NULL,\\n        ETH,\\n        ERC20,\\n        BOOSTED_ERC20, // LEGACY: only kept to not break existing applications, it's an alias for CurrencyType.ERC20\\n        ERC721\\n    }\\n\\n    // Enum is used to read only a specific part of the order pair from\\n    // storage, since it is a bad idea to always perform 4 SLOADs.\\n    enum OrderPairReadStrategy {\\n        SKIP,\\n        MAKER,\\n        TAKER,\\n        FULL\\n    }\\n\\n    struct OrderPair {\\n        address makerContractAddress;\\n        CurrencyType makerCurrencyType;\\n        address takerContractAddress;\\n        CurrencyType takerCurrencyType;\\n    }\\n\\n    // To reduce the number of reads, the order pairs\\n    // are stored packed and on read unpacked as required.\\n    // Also see `OrderPair` and `OrderPairReadStrategy`.\\n    struct PackedOrderPair {\\n        // 20 bytes address + 1 byte currency type\\n        uint168 makerPair;\\n        // 20 bytes address + 1 byte currency type\\n        uint168 takerPair;\\n    }\\n\\n    struct PackedOrderBookItem {\\n        // Serialized `UnpackedOrderBookItem`\\n        uint256 packedData;\\n    }\\n\\n    struct UnpackedOrderBookItem {\\n        uint32 id;\\n        uint96 makerValue;\\n        uint96 takerValue;\\n        uint32 orderPairAlias;\\n        // The resolved pair based on the order pair alias\\n        OrderPair pair;\\n        OrderFlags flags;\\n    }\\n\\n    // Struct that contains all unpacked data and the additional almost-always zero fields from\\n    // the packed order bookt item - returned from `getOrder()` to be more user-friendly to consume.\\n    struct PrettyOrderBookItem {\\n        uint32 id;\\n        uint96 makerValue;\\n        uint96 takerValue;\\n        uint32 orderPairAlias;\\n        OrderPair pair;\\n        OrderFlags flags;\\n    }\\n\\n    struct OrderFlags {\\n        bool isMakerERC721;\\n        bool isTakerERC721;\\n    }\\n\\n    function packOrderBookItem(UnpackedOrderBookItem memory _unpacked)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        // Bitpacking saves gas on read/write:\\n\\n        // 61287 gas\\n        // struct Item1 {\\n        //     uint256 word1;\\n        //     uint256 word2;\\n        // }\\n\\n        // // 62198 gas\\n        // struct Item2 {\\n        //     uint256 word1;\\n        //     uint128 a;\\n        //     uint128 b;\\n        // }\\n\\n        // // 62374 gas\\n        // struct Item3 {\\n        //     uint256 word1;\\n        //     uint64 a;\\n        //     uint64 b;\\n        //     uint64 c;\\n        //     uint64 d;\\n        // }\\n\\n        uint256 packedData;\\n        uint256 offset;\\n\\n        // 1) Set first 32 bits to id\\n        uint32 id = _unpacked.id;\\n        packedData |= id;\\n        offset += 32;\\n\\n        // 2) Set next 96 bits to maker value\\n        uint96 makerValue = _unpacked.makerValue;\\n        packedData |= uint256(makerValue) << offset;\\n        offset += 96;\\n\\n        // 3) Set next 96 bits to taker value\\n        uint96 takerValue = _unpacked.takerValue;\\n        packedData |= uint256(takerValue) << offset;\\n        offset += 96;\\n\\n        // 4) Set next 28 bits to order pair alias\\n        // Since it is stored in a uint32 AND it with a bitmask where the first 28 bits are 1\\n        uint32 orderPairAlias = _unpacked.orderPairAlias;\\n        uint32 orderPairAliasMask = (1 << 28) - 1;\\n        packedData |= uint256(orderPairAlias & orderPairAliasMask) << offset;\\n        offset += 28;\\n\\n        // 5) Set remaining bits to flags\\n        OrderFlags memory flags = _unpacked.flags;\\n        if (flags.isMakerERC721) {\\n            // Maker currency type is ERC721\\n            packedData |= 1 << (offset + 0);\\n        }\\n\\n        if (flags.isTakerERC721) {\\n            // Taker currency type is ERC721\\n            packedData |= 1 << (offset + 1);\\n        }\\n\\n        offset += 2;\\n\\n        // 2 bits unused\\n        assert(offset == 254);\\n\\n        return packedData;\\n    }\\n\\n    function unpackOrderBookItem(uint256 packedData)\\n        internal\\n        pure\\n        returns (UnpackedOrderBookItem memory)\\n    {\\n        assert(packedData > 0);\\n\\n        UnpackedOrderBookItem memory _unpacked;\\n        uint256 offset;\\n\\n        // 1) Read id from the first 32 bits\\n        _unpacked.id = uint32(packedData >> offset);\\n        offset += 32;\\n\\n        // 2) Read maker value from next 96 bits\\n        _unpacked.makerValue = uint96(packedData >> offset);\\n        offset += 96;\\n\\n        // 3) Read taker value from next 96 bits\\n        _unpacked.takerValue = uint96(packedData >> offset);\\n        offset += 96;\\n\\n        // 4) Read order pair alias from next 28 bits\\n        uint32 orderPairAlias = uint32(packedData >> offset);\\n        uint32 orderPairAliasMask = (1 << 28) - 1;\\n        _unpacked.orderPairAlias = orderPairAlias & orderPairAliasMask;\\n        offset += 28;\\n\\n        // NOTE: the caller still needs to read the order pair from storage\\n        // with the unpacked alias\\n\\n        // 5) Read order flags from remaining bits\\n        OrderFlags memory flags = _unpacked.flags;\\n\\n        flags.isMakerERC721 = (packedData >> (offset + 0)) & 1 == 1;\\n        flags.isTakerERC721 = (packedData >> (offset + 1)) & 1 == 1;\\n\\n        offset += 2;\\n\\n        // 2 bits unused\\n\\n        assert(offset == 254);\\n\\n        return _unpacked;\\n    }\\n\\n    function packOrderPair(OrderPair memory unpacked)\\n        internal\\n        pure\\n        returns (PackedOrderPair memory)\\n    {\\n        uint168 packedMaker = uint160(unpacked.makerContractAddress);\\n        packedMaker |= uint168(unpacked.makerCurrencyType) << 160;\\n\\n        uint168 packedTaker = uint160(unpacked.takerContractAddress);\\n        packedTaker |= uint168(unpacked.takerCurrencyType) << 160;\\n\\n        return PackedOrderPair(packedMaker, packedTaker);\\n    }\\n\\n    function unpackOrderPairAddressType(uint168 packed)\\n        internal\\n        pure\\n        returns (address, CurrencyType)\\n    {\\n        // The first 20 bytes of order pair are used for the maker address\\n        address unpackedAddress = address(uint160(packed));\\n        // The next 8 bits for the maker currency type\\n        CurrencyType unpackedCurrencyType = CurrencyType(uint8(packed >> 160));\\n\\n        return (unpackedAddress, unpackedCurrencyType);\\n    }\\n\\n    struct MakeOrderInput {\\n        uint96 makerValue;\\n        uint96 takerValue;\\n        OrderPair pair;\\n        // An id of an existing order can be optionally provided to\\n        // update the makerValue-takerValue ratio with a single call as opposed to cancel-then-make-new-order.\\n        uint32 orderId;\\n        // When calling make order using an existing order id, the `updatedRatio` will be applied on\\n        // the `makerValue` to calculate the new `takerValue`.\\n        uint128 updatedRatioWei;\\n    }\\n\\n    struct TakeOrderInput {\\n        uint32 id;\\n        address payable maker;\\n        uint96 takerValue;\\n        // The expected max taker maker ratio of the order to take.\\n        uint256 maxTakerMakerRatio;\\n    }\\n\\n    struct CancelOrderInput {\\n        uint32 id;\\n        address payable maker;\\n    }\\n\\n    function getOrderKey(\\n        address maker,\\n        uint32 orderId\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(maker, orderId));\\n    }    \\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prps\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dubi\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"}],\"name\":\"CanceledOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"makerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"makerCurrencyType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"takerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"takerCurrencyType\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct DubiexLib.OrderPair\",\"name\":\"orderPair\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packedData\",\"type\":\"uint256\"}],\"name\":\"MadeOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packedData\",\"type\":\"uint256\"}],\"name\":\"TookOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedRatioWei\",\"type\":\"uint256\"}],\"name\":\"UpdatedOrder\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activateKillSwitch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"address payable\",\"name\":\"maker\",\"type\":\"address\"}],\"internalType\":\"struct DubiexLib.CancelOrderInput\",\"name\":\"input\",\"type\":\"tuple\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"address payable\",\"name\":\"maker\",\"type\":\"address\"}],\"internalType\":\"struct DubiexLib.CancelOrderInput[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"}],\"name\":\"cancelOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"}],\"name\":\"getOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"makerValue\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"takerValue\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"orderPairAlias\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"makerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"makerCurrencyType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"takerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"takerCurrencyType\",\"type\":\"uint8\"}],\"internalType\":\"struct DubiexLib.OrderPair\",\"name\":\"pair\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isMakerERC721\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isTakerERC721\",\"type\":\"bool\"}],\"internalType\":\"struct DubiexLib.OrderFlags\",\"name\":\"flags\",\"type\":\"tuple\"}],\"internalType\":\"struct DubiexLib.PrettyOrderBookItem\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderPairHash\",\"type\":\"bytes32\"}],\"name\":\"getOrderPairAliasByHash\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"orderPairAlias\",\"type\":\"uint32\"}],\"name\":\"getOrderPairByAlias\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"makerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"makerCurrencyType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"takerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"takerCurrencyType\",\"type\":\"uint8\"}],\"internalType\":\"struct DubiexLib.OrderPair\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderPairHash\",\"type\":\"bytes32\"}],\"name\":\"getOrderPairByHash\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"makerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"makerCurrencyType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"takerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"takerCurrencyType\",\"type\":\"uint8\"}],\"internalType\":\"struct DubiexLib.OrderPair\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"makerValue\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"takerValue\",\"type\":\"uint96\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"makerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"makerCurrencyType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"takerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"takerCurrencyType\",\"type\":\"uint8\"}],\"internalType\":\"struct DubiexLib.OrderPair\",\"name\":\"pair\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"orderId\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"updatedRatioWei\",\"type\":\"uint128\"}],\"internalType\":\"struct DubiexLib.MakeOrderInput\",\"name\":\"input\",\"type\":\"tuple\"}],\"name\":\"makeOrder\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"makerValue\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"takerValue\",\"type\":\"uint96\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"makerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"makerCurrencyType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"takerContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DubiexLib.CurrencyType\",\"name\":\"takerCurrencyType\",\"type\":\"uint8\"}],\"internalType\":\"struct DubiexLib.OrderPair\",\"name\":\"pair\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"orderId\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"updatedRatioWei\",\"type\":\"uint128\"}],\"internalType\":\"struct DubiexLib.MakeOrderInput[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"}],\"name\":\"makeOrders\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"address payable\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"takerValue\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"maxTakerMakerRatio\",\"type\":\"uint256\"}],\"internalType\":\"struct DubiexLib.TakeOrderInput\",\"name\":\"input\",\"type\":\"tuple\"}],\"name\":\"takeOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"address payable\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"takerValue\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"maxTakerMakerRatio\",\"type\":\"uint256\"}],\"internalType\":\"struct DubiexLib.TakeOrderInput[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"}],\"name\":\"takeOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Dubiex", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000972999c58bbce63a2e398d4ed3bde414b8349eb3000000000000000000000000950e1561b7a7deb1a32a6419fd435410daf851b0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}