{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/diamond/Diamond.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\nimport \\\"../facets/task-executor/TaskExecutorLib.sol\\\";\\nimport \\\"./IAppRegistry.sol\\\";\\nimport \\\"./IAuthz.sol\\\";\\nimport \\\"./IDiamond.sol\\\";\\nimport \\\"./IDiamondInitializer.sol\\\";\\nimport \\\"./IDiamondFacet.sol\\\";\\nimport \\\"./FacetManager.sol\\\";\\n\\n/// @author Kam Amini <kam@qomet.tech>\\n///\\n/// @notice Use at your own risk\\nlibrary DiamondInfo {\\n    string public constant VERSION = \\\"3.1.0\\\";\\n}\\n\\ncontract Diamond is IDiamond, IDiamondInitializer {\\n\\n    string private _name;\\n    string private _detailsURI;\\n\\n    event FreezeAuthz();\\n    event AppInstall(address appRegistry, string name, string version);\\n    event AppRegistrySet(address appRegistry);\\n\\n    struct Authz {\\n        bool frozen;\\n        address source;\\n        string domain;\\n        uint256[] acceptedResults;\\n        string hashSalt;\\n    }\\n    Authz private _authz;\\n\\n    bytes4[] private _defaultSupportingInterfceIds;\\n\\n    address private _appRegistry;\\n\\n    address private _initializer;\\n    bool private _initialized;\\n\\n    modifier mustBeInitialized {\\n        require(_initialized, \\\"DMND:NI\\\");\\n        _;\\n    }\\n\\n    modifier notFrozenAuthz {\\n        require(!_authz.frozen, \\\"DMND:AFRZN\\\");\\n        _;\\n    }\\n\\n    modifier mutatorAuthz {\\n        _authorizeCall(msg.sender, address(this), msg.sig, true);\\n        _;\\n    }\\n\\n    modifier getterAuthz {\\n        _authorizeCall(msg.sender, address(this), msg.sig, false);\\n        _;\\n    }\\n\\n    constructor(\\n        bytes4[] memory defaultSupportingInterfceIds,\\n        address initializer\\n    ) {\\n        _initialized = false;\\n        _authz.hashSalt = \\\"Dwt2wb1d976h\\\";\\n        _authz.acceptedResults.push(AuthzLib.ACCEPT_ACTION);\\n        _defaultSupportingInterfceIds = defaultSupportingInterfceIds;\\n        _initializer = initializer;\\n    }\\n\\n    function initialize(\\n        string memory name,\\n        address taskManager,\\n        address appRegistry,\\n        address authzSource,\\n        string memory authzDomain,\\n        string[][2] memory defaultApps, // [0] > names, [1] > versions\\n        address[] memory defaultFacets,\\n        string[][2] memory defaultFuncSigsToProtectOrUnprotect, // [0] > protect, [1] > unprotect\\n        address[] memory defaultFacetsToFreeze,\\n        bool[3] memory instantLockAndFreezes // [0] > lock, [1] > freeze-authz, [2] > freeze-diamond\\n    ) external override {\\n        require(!_initialized, \\\"DMND:AI\\\");\\n        require(msg.sender == _initializer, \\\"DMND:WI\\\");\\n        _name = name;\\n        TaskExecutorLib._initialize(taskManager);\\n        __setAppRegistry(appRegistry);\\n        __setAuthzSource(authzSource);\\n        _authz.domain = authzDomain;\\n        require(defaultApps[0].length == defaultApps[1].length, \\\"DMND:WL\\\");\\n        for (uint256 i = 0; i < defaultApps[0].length; i++) {\\n            __installApp(\\n                defaultApps[0][i], // name\\n                defaultApps[1][i], // version\\n                false // don't delete current facets\\n            );\\n        }\\n        // install default facets\\n        for (uint256 i = 0; i < defaultFacets.length; i++) {\\n            FacetManagerLib._addFacet(defaultFacets[i]);\\n        }\\n        // protect default functions\\n        for (uint256 i = 0; i < defaultFuncSigsToProtectOrUnprotect[0].length; i++) {\\n            FacetManagerLib._protectFuncSig(\\n                defaultFuncSigsToProtectOrUnprotect[0][i],\\n                true // protect\\n            );\\n        }\\n        // unprotect default functions\\n        for (uint256 i = 0; i < defaultFuncSigsToProtectOrUnprotect[1].length; i++) {\\n            FacetManagerLib._protectFuncSig(\\n                defaultFuncSigsToProtectOrUnprotect[1][i],\\n                false // unprotect\\n            );\\n        }\\n        // lock the diamond if asked for\\n        if (instantLockAndFreezes[0]) {\\n            FacetManagerLib._setLocked(true);\\n        }\\n        // freeze facets\\n        for (uint256 i = 0; i < defaultFacetsToFreeze.length; i++) {\\n            FacetManagerLib._freezeFacet(defaultFacetsToFreeze[i]);\\n        }\\n        // freeze the authz settings if asked for\\n        if (instantLockAndFreezes[1]) {\\n            _authz.frozen = true;\\n        }\\n        // freeze the diamond if asked for\\n        if (instantLockAndFreezes[2]) {\\n            FacetManagerLib._freezeDiamond();\\n        }\\n        _initialized = true;\\n    }\\n\\n\\n    function supportsInterface(bytes4 interfaceId)\\n      public view override getterAuthz virtual returns (bool) {\\n        // Querying for IDiamond must always return true\\n        if (\\n            interfaceId == 0xd4bbd4bb ||\\n            interfaceId == type(IDiamond).interfaceId\\n        ) {\\n            return true;\\n        }\\n        // Querying for IDiamondFacet must always return false\\n        if (interfaceId == type(IDiamondFacet).interfaceId) {\\n            return false;\\n        }\\n        // Always return true\\n        if (interfaceId == type(IERC165).interfaceId) {\\n            return true;\\n        }\\n        address[] memory facets = FacetManagerLib._getFacets();\\n        for (uint256 i = 0; i < facets.length; i++) {\\n            address facet = facets[i];\\n            if (!FacetManagerLib._isFacetDeleted(facet) &&\\n                IDiamondFacet(facet).supportsInterface(interfaceId)) {\\n                return true;\\n            }\\n        }\\n        for (uint256 i = 0; i < _defaultSupportingInterfceIds.length; i++) {\\n            if (interfaceId == _defaultSupportingInterfceIds[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function isInitialized() external view returns (bool) {\\n        return _initialized;\\n    }\\n\\n    function getDiamondName()\\n    external view virtual override mustBeInitialized getterAuthz returns (string memory) {\\n        return _name;\\n    }\\n\\n    function getDiamondVersion()\\n    external view virtual override mustBeInitialized getterAuthz  returns (string memory) {\\n        return DiamondInfo.VERSION;\\n    }\\n\\n    function setDiamondName(string memory name) external mustBeInitialized mutatorAuthz {\\n        _name = name;\\n    }\\n\\n    function getDetailsURI()\\n    external view mustBeInitialized getterAuthz returns (string memory) {\\n        return _detailsURI;\\n    }\\n\\n    function setDetailsURI(string memory detailsURI) external mustBeInitialized mutatorAuthz {\\n        _detailsURI = detailsURI;\\n    }\\n\\n    function getTaskManager() external view mustBeInitialized getterAuthz returns (address) {\\n        return TaskExecutorLib._getTaskManager(\\\"DEFAULT\\\");\\n    }\\n\\n    function getAuthzSource() external view mustBeInitialized getterAuthz returns (address) {\\n        return _authz.source;\\n    }\\n\\n    function setAuthzSource(\\n        address authzSource\\n    ) external mustBeInitialized notFrozenAuthz mutatorAuthz {\\n        __setAuthzSource(authzSource);\\n    }\\n\\n    function getAuthzDomain() external view mustBeInitialized getterAuthz returns (string memory) {\\n        return _authz.domain;\\n    }\\n\\n    function setAuthzDomain(\\n        string memory authzDomain\\n    ) external mustBeInitialized notFrozenAuthz mutatorAuthz {\\n        require(bytes(authzDomain).length > 0, \\\"DMND:ED\\\");\\n        _authz.domain = authzDomain;\\n    }\\n\\n    function getAcceptedAuthzResults()\\n    external view mustBeInitialized getterAuthz returns (uint256[] memory) {\\n        return _authz.acceptedResults;\\n    }\\n\\n    function setAcceptedAuthzResults(\\n        uint256[] memory acceptedAuthzResults\\n    ) external mustBeInitialized notFrozenAuthz mutatorAuthz {\\n        require(acceptedAuthzResults.length > 0, \\\"DMND:EA\\\");\\n        _authz.acceptedResults = acceptedAuthzResults;\\n    }\\n\\n    function getAppRegistry() external view mustBeInitialized getterAuthz returns (address) {\\n        return _appRegistry;\\n    }\\n\\n    function setAppRegistry(address appRegistry) external mustBeInitialized mutatorAuthz {\\n        __setAppRegistry(appRegistry);\\n    }\\n\\n    function isDiamondFrozen() external view mustBeInitialized getterAuthz returns (bool) {\\n        return FacetManagerLib._isDiamondFrozen();\\n    }\\n\\n    function freezeDiamond(\\n        string memory taskManagerKey,\\n        uint256 adminTaskId\\n    ) external mustBeInitialized mutatorAuthz {\\n        FacetManagerLib._freezeDiamond();\\n        TaskExecutorLib._executeAdminTask(taskManagerKey, adminTaskId);\\n    }\\n\\n    function isFacetFrozen(address facet)\\n    external view mustBeInitialized getterAuthz returns (bool) {\\n        return FacetManagerLib._isFacetFrozen(facet);\\n    }\\n\\n    function freezeFacet(\\n        string memory taskManagerKey,\\n        uint256 adminTaskId,\\n        address facet\\n    ) external mustBeInitialized mutatorAuthz {\\n        FacetManagerLib._freezeFacet(facet);\\n        TaskExecutorLib._executeAdminTask(taskManagerKey, adminTaskId);\\n    }\\n\\n    function isAuthzFrozen() external view mustBeInitialized getterAuthz returns (bool) {\\n        return _authz.frozen;\\n    }\\n\\n    function freezeAuthz(\\n        string memory taskManagerKey,\\n        uint256 adminTaskId\\n    ) external mustBeInitialized notFrozenAuthz mutatorAuthz {\\n        _authz.frozen = true;\\n        emit FreezeAuthz();\\n        TaskExecutorLib._executeAdminTask(taskManagerKey, adminTaskId);\\n    }\\n\\n    function isDiamondLocked() external view mustBeInitialized getterAuthz returns (bool) {\\n        return FacetManagerLib._isDiamondLocked();\\n    }\\n\\n    function setLocked(\\n        string memory taskManagerKey,\\n        uint256 taskId,\\n        bool locked\\n    ) external mustBeInitialized mutatorAuthz {\\n        FacetManagerLib._setLocked(locked);\\n        TaskExecutorLib._executeTask(taskManagerKey, taskId);\\n    }\\n\\n    function getFacets()\\n    external view override mustBeInitialized getterAuthz returns (address[] memory) {\\n        return FacetManagerLib._getFacets();\\n    }\\n\\n    function resolve(string[] memory funcSigs)\\n    external view mustBeInitialized getterAuthz returns (address[] memory) {\\n        return FacetManagerLib._resolve(funcSigs);\\n    }\\n\\n    function areFuncSigsProtected(\\n        string[] memory funcSigs\\n    ) external view mustBeInitialized getterAuthz returns (bool[] memory) {\\n        return FacetManagerLib._areFuncSigsProtected(funcSigs);\\n    }\\n\\n    function protectFuncSig(string memory funcSig, bool protect)\\n    external mustBeInitialized notFrozenAuthz mutatorAuthz {\\n        FacetManagerLib._protectFuncSig(funcSig, protect);\\n    }\\n\\n    function addFacets(address[] memory facets) external mustBeInitialized mutatorAuthz {\\n        FacetManagerLib._addFacets(facets);\\n    }\\n\\n    function deleteFacets(address[] memory facets) external mustBeInitialized mutatorAuthz {\\n        FacetManagerLib._deleteFacets(facets);\\n    }\\n\\n    function replaceFacets(\\n        address[] memory toBeDeletedFacets,\\n        address[] memory toBeAddedFacets\\n    ) external mustBeInitialized mutatorAuthz {\\n        FacetManagerLib._replaceFacets(toBeDeletedFacets, toBeAddedFacets);\\n    }\\n\\n    function deleteAllFacets() external mustBeInitialized mutatorAuthz {\\n        FacetManagerLib._deleteAllFacets();\\n    }\\n\\n    function installApp(\\n        string memory appName,\\n        string memory appVersion,\\n        bool deleteCurrentFacets\\n    ) external mustBeInitialized mutatorAuthz {\\n        __installApp(appName, appVersion, deleteCurrentFacets);\\n    }\\n\\n    function overrideFuncSigs(\\n        string[] memory funcSigs,\\n        address[] memory facets\\n    ) external mustBeInitialized mutatorAuthz {\\n        FacetManagerLib._overrideFuncSigs(funcSigs, facets);\\n    }\\n\\n    function getOverridenFuncSigs()\\n    external view mustBeInitialized getterAuthz returns (string[] memory) {\\n        return FacetManagerLib._getOverridenFuncSigs();\\n    }\\n\\n    function tryAuthorizeCall(\\n        address caller,\\n        string memory funcSig\\n    ) external view mustBeInitialized getterAuthz {\\n        address facet = FacetManagerLib._findFacet(msg.sig);\\n        bytes4 funcSelector = FacetManagerLib._getSelector(funcSig);\\n        _authorizeCall(caller, facet, funcSelector, false);\\n    }\\n\\n    function _authorizeCall(\\n        address caller,\\n        address facet,\\n        bytes4 funcSelector,\\n        bool treatAsProtected\\n    ) internal view {\\n        if (!treatAsProtected && !FacetManagerLib._isSelectorProtected(funcSelector)) {\\n            return;\\n        }\\n        require(_authz.source != address(0), \\\"DMND:ZA\\\");\\n        bytes32 domainHash = keccak256(abi.encodePacked(_authz.hashSalt, _authz.domain));\\n        bytes32 callerHash = keccak256(abi.encodePacked(_authz.hashSalt, caller));\\n        bytes32[] memory targets = new bytes32[](3);\\n        targets[0] = keccak256(abi.encodePacked(_authz.hashSalt, address(this)));\\n        targets[1] = keccak256(abi.encodePacked(_authz.hashSalt, facet));\\n        targets[2] = keccak256(abi.encodePacked(_authz.hashSalt, funcSelector));\\n        uint256[] memory ops = new uint256[](1);\\n        ops[0] = AuthzLib.CALL_OP;\\n        uint256[] memory results = IAuthz(_authz.source)\\n            .authorize(\\n                domainHash,\\n                callerHash,\\n                targets,\\n                ops\\n            );\\n        for (uint256 i = 0; i < _authz.acceptedResults.length; i++) {\\n            for (uint256 j = 0; j < results.length; j++) {\\n                if (_authz.acceptedResults[i] == results[j]) {\\n                    return;\\n                }\\n            }\\n        }\\n        revert(\\\"DMND:NAUTH\\\");\\n    }\\n\\n    function __setAuthzSource(address authzSource) private {\\n        require(authzSource != address(0), \\\"DMND:ZA\\\");\\n        require(\\n            IERC165(authzSource).supportsInterface(type(IAuthz).interfaceId),\\n            \\\"DMND:IAS\\\"\\n        );\\n        _authz.source = authzSource;\\n    }\\n\\n    function __setAppRegistry(address appRegistry) private {\\n        if (appRegistry != address(0)) {\\n            require(\\n                IERC165(appRegistry).supportsInterface(type(IAppRegistry).interfaceId),\\n                \\\"DMND:IAR\\\"\\n            );\\n        }\\n        _appRegistry = appRegistry;\\n        emit AppRegistrySet(_appRegistry);\\n    }\\n\\n    function __installApp(\\n        string memory appName,\\n        string memory appVersion,\\n        bool deleteCurrentFacets\\n    ) private {\\n        require(_appRegistry != address(0), \\\"DMND:ZAR\\\");\\n        if (deleteCurrentFacets) {\\n            FacetManagerLib._deleteAllFacets();\\n        }\\n        address[] memory appFacets =\\n            IAppRegistry(_appRegistry).getAppFacets(appName, appVersion);\\n        for (uint256 i = 0; i < appFacets.length; i++) {\\n            FacetManagerLib._addFacet(appFacets[i]);\\n        }\\n        if (appFacets.length > 0) {\\n            emit AppInstall(_appRegistry, appName, appVersion);\\n        }\\n    }\\n\\n    /* solhint-disable no-complex-fallback */\\n    fallback() external payable {\\n        require(_initialized, \\\"DMND:NI\\\");\\n        address facet = FacetManagerLib._findFacet(msg.sig);\\n        _authorizeCall(msg.sender, facet, msg.sig, false);\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n        }\\n        /* solhint-enable no-inline-assembly */\\n    }\\n\\n    /* solhint-disable no-empty-blocks */\\n    receive() external payable {}\\n    /* solhint-enable no-empty-blocks */\\n}\\n\"\r\n    },\r\n    \"contracts/facets/task-executor/TaskExecutorLib.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\nimport \\\"./TaskExecutorInternal.sol\\\";\\n\\nlibrary TaskExecutorLib {\\n\\n    function _initialize(\\n        address newTaskManager\\n    ) internal {\\n        TaskExecutorInternal._initialize(newTaskManager);\\n    }\\n\\n    function _getTaskManager(\\n        string memory taskManagerKey\\n    ) internal view returns (address) {\\n        return TaskExecutorInternal._getTaskManager(taskManagerKey);\\n    }\\n\\n    function _executeTask(\\n        string memory key,\\n        uint256 taskId\\n    ) internal {\\n        TaskExecutorInternal._executeTask(key, taskId);\\n    }\\n\\n    function _executeAdminTask(\\n        string memory key,\\n        uint256 adminTaskId\\n    ) internal {\\n        TaskExecutorInternal._executeAdminTask(key, adminTaskId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/IAppRegistry.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\n/// @author Kam Amini <kam@qomet.tech>\\n///\\n/// @notice Use at your own risk\\ninterface IAppRegistry {\\n\\n    function getAppFacets(\\n        string memory appName,\\n        string memory appVersion\\n    ) external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/IAuthz.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\nlibrary AuthzLib {\\n\\n    uint256 public constant ROLE_AUTHZ_DIAMOND_ADMIN = uint256(keccak256(bytes(\\\"ROLE_AUTHZ_DIAMOND_ADMIN\\\")));\\n    uint256 public constant ROLE_AUTHZ_ADMIN = uint256(keccak256(bytes(\\\"ROLE_AUTHZ_ADMIN\\\")));\\n\\n    bytes32 constant public GLOBAL_DOMAIN_ID = keccak256(abi.encodePacked(\\\"global\\\"));\\n    bytes32 constant public MATCH_ALL_WILDCARD_HASH = keccak256(abi.encodePacked(\\\"*\\\"));\\n\\n    // operations\\n    uint256 constant public CALL_OP = 5000;\\n    uint256 constant public MATCH_ALL_WILDCARD_OP = 9999;\\n\\n    // actions\\n    uint256 constant public ACCEPT_ACTION = 1;\\n    uint256 constant public REJECT_ACTION = 100;\\n}\\n\\n/// @author Kam Amini <kam@qomet.tech>\\n///\\n/// @notice Use at your own risk\\ninterface IAuthz {\\n\\n    function authorize(\\n        bytes32 domainHash,\\n        bytes32 identityHash,\\n        bytes32[] memory targets,\\n        uint256[] memory ops\\n    ) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/IDiamond.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\nlibrary DiamondLib {\\n    uint256 public constant ROLE_DIAMOND_ADMIN = uint256(keccak256(bytes(\\\"ROLE_DIAMOND_ADMIN\\\")));\\n}\\n\\n/// @author Kam Amini <kam@qomet.tech>\\n///\\n/// @notice Use at your own risk\\ninterface IDiamond is IERC165 {\\n\\n    function getDiamondName() external view returns (string memory);\\n\\n    function getDiamondVersion() external view returns (string memory);\\n\\n    function getFacets() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/IDiamondInitializer.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\n/// @author Kam Amini <kam@qomet.tech>\\n///\\n/// @notice Use at your own risk\\ninterface IDiamondInitializer {\\n\\n    function initialize(\\n        string memory name,\\n        address taskManager,\\n        address appRegistry,\\n        address authzSource,\\n        string memory authzDomain,\\n        string[][2] memory defaultApps, // [0] > names, [1] > versions\\n        address[] memory defaultFacets,\\n        string[][2] memory defaultFuncSigsToProtectOrUnprotect, // [0] > protect, [1] > unprotect\\n        address[] memory defaultFacetsToFreeze,\\n        bool[3] memory instantLockAndFreezes // [0] > lock, [1] > freeze-authz, [2] > freeze-diamond\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/IDiamondFacet.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\n/// @author Kam Amini <kam@qomet.tech>\\n///\\n/// @notice Use at your own risk\\ninterface IDiamondFacet is IERC165 {\\n\\n    // NOTE: The override MUST remain 'pure'.\\n    function getFacetName() external pure returns (string memory);\\n\\n    // NOTE: The override MUST remain 'pure'.\\n    function getFacetVersion() external pure returns (string memory);\\n\\n    // NOTE: The override MUST remain 'pure'.\\n    function getFacetPI() external pure returns (string[] memory);\\n\\n    // NOTE: The override MUST remain 'pure'.\\n    function getFacetProtectedPI() external pure returns (string[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/FacetManager.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\nimport \\\"./IDiamondFacet.sol\\\";\\n\\n/// @author Kam Amini <kam@arteq.io>\\n///\\n/// @notice Use at your own risk. Just got the basic\\n///         idea from: https://github.com/solidstate-network/solidstate-solidity\\nlibrary FacetManagerStorage {\\n\\n    struct Layout {\\n        // true if diamond is frozen meaning it cannot be changed anymore.\\n        // ATTENTION! once frozen, one WILL NEVER be able to undo that.\\n        bool diamondFrozen;\\n        // true if diamond is locked, meaning it cannot be changed anymore.\\n        // diamonds can be unlocked.\\n        bool diamondLocked;\\n        // list of facet addersses\\n        address[] facets;\\n        mapping(address => uint256) facetsIndex;\\n        // facet address > true if marked as deleted\\n        mapping(address => bool) deletedFacets;\\n        // function selector > facet address\\n        mapping(bytes4 => address) selectorToFacetMap;\\n        // list of overriden function signatures\\n        string[] overridenFuncSigs;\\n        mapping(string => uint256) overridenFuncSigsIndex;\\n        // facet address > true if frozen\\n        mapping(address => bool) frozenFacets;\\n        // function signature > true if protected\\n        mapping(bytes4 => bool) protectedSelectorMap;\\n        // Extra fields (reserved for future)\\n        mapping(bytes32 => bytes) extra;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256(\\\"qomet-tech.contracts.diamond.facet-manager.storage\\\");\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 slot = STORAGE_SLOT;\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            s.slot := slot\\n        }\\n        /* solhint-enable no-inline-assembly */\\n    }\\n}\\n\\nlibrary FacetManagerLib {\\n\\n    event FacetAdd(address facet);\\n    event FacetDelete(address facet);\\n    event FreezeDiamond();\\n    event SetLocked(bool locked);\\n    event FuncSigOverride(string funcSig, address facet);\\n    event ProtectFuncSig(string funcSig, bool protect);\\n\\n    function _isDiamondFrozen() internal view returns (bool) {\\n        return __s().diamondFrozen;\\n    }\\n\\n    function _freezeDiamond() internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        __s().diamondFrozen = true;\\n        emit FreezeDiamond();\\n    }\\n\\n    function _isFacetFrozen(address facet) internal view returns (bool) {\\n        return __s().frozenFacets[facet];\\n    }\\n\\n    function _freezeFacet(address facet) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(facet != address(0), \\\"FMLIB:ZF\\\");\\n        require(!__s().frozenFacets[facet], \\\"FMLIB:FAF\\\");\\n        __s().frozenFacets[facet] = true;\\n    }\\n\\n    function _isDiamondLocked() internal view returns (bool) {\\n        return __s().diamondLocked;\\n    }\\n\\n    function _setLocked(bool locked) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        __s().diamondLocked = locked;\\n        emit SetLocked(locked);\\n    }\\n\\n    function _getFacets() internal view returns (address[] memory) {\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < __s().facets.length; i++) {\\n            if (!__s().deletedFacets[__s().facets[i]]) {\\n                count += 1;\\n            }\\n        }\\n        address[] memory facets = new address[](count);\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < __s().facets.length; i++) {\\n            if (!__s().deletedFacets[__s().facets[i]]) {\\n                facets[index] = __s().facets[i];\\n                index += 1;\\n            }\\n        }\\n        return facets;\\n    }\\n\\n    function _resolve(string[] memory funcSigs) internal view returns (address[] memory) {\\n        address[] memory facets = new address[](funcSigs.length);\\n        for (uint256 i = 0; i < funcSigs.length; i++) {\\n            string memory funcSig = funcSigs[i];\\n            bytes4 selector = _getSelector(funcSig);\\n            facets[i] = __s().selectorToFacetMap[selector];\\n            if (__s().deletedFacets[facets[i]]) {\\n                facets[i] = address(0);\\n            }\\n        }\\n        return facets;\\n    }\\n\\n    function _areFuncSigsProtected(\\n        string[] memory funcSigs\\n    ) internal view returns (bool[] memory) {\\n        bool[] memory results = new bool[](funcSigs.length);\\n        for (uint256 i = 0; i < funcSigs.length; i++) {\\n            string memory funcSig = funcSigs[i];\\n            bytes4 selector = _getSelector(funcSig);\\n            results[i] = __s().protectedSelectorMap[selector];\\n        }\\n        return results;\\n    }\\n\\n    function _protectFuncSig(\\n        string memory funcSig,\\n        bool protect\\n    ) internal {\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        __protectFuncSig(funcSig, protect);\\n    }\\n\\n    function _isSelectorProtected(bytes4 funcSelector) internal view returns (bool) {\\n        return __s().protectedSelectorMap[funcSelector];\\n    }\\n\\n    function _addFacets(address[] memory facets) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        require(facets.length > 0, \\\"FMLIB:ZL\\\");\\n        for (uint256 i = 0; i < facets.length; i++) {\\n            _addFacet(facets[i]);\\n        }\\n    }\\n\\n    function _deleteFacets(address[] memory facets) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        require(facets.length > 0, \\\"FMLIB:ZL\\\");\\n        for (uint256 i = 0; i < facets.length; i++) {\\n            __deleteFacet(facets[i]);\\n        }\\n    }\\n\\n    function _replaceFacets(\\n        address[] memory toBeDeletedFacets,\\n        address[] memory toBeAddedFacets\\n    ) internal {\\n        _deleteFacets(toBeDeletedFacets);\\n        _addFacets(toBeAddedFacets);\\n    }\\n\\n    function _isFacetDeleted(address facet) internal view returns (bool) {\\n        return __s().deletedFacets[facet];\\n    }\\n\\n    function _deleteAllFacets() internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        for (uint256 i = 0; i < __s().facets.length; i++) {\\n            __deleteFacet(__s().facets[i]);\\n        }\\n    }\\n\\n    function _overrideFuncSigs(\\n        string[] memory funcSigs,\\n        address[] memory facets\\n    ) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        __overrideFuncSigs(funcSigs, facets);\\n    }\\n\\n    function _getOverridenFuncSigs() internal view returns (string[] memory) {\\n        return __s().overridenFuncSigs;\\n    }\\n\\n    function _findFacet(bytes4 selector) internal view returns (address) {\\n        address facet = __s().selectorToFacetMap[selector];\\n        require(facet != address(0), \\\"FMLIB:FNF\\\");\\n        require(!__s().deletedFacets[facet], \\\"FMLIB:FREM\\\");\\n        return facet;\\n    }\\n\\n    function _addFacet(address facet) internal {\\n        require(!__s().diamondFrozen, \\\"FMLIB:DFRZN\\\");\\n        require(!__s().diamondLocked, \\\"FMLIB:LCKD\\\");\\n        require(facet != address(0), \\\"FMLIB:ZF\\\");\\n        require(\\n            IDiamondFacet(facet).supportsInterface(type(IDiamondFacet).interfaceId),\\n            \\\"FMLIB:IF\\\"\\n        );\\n        string[] memory funcSigs = IDiamondFacet(facet).getFacetPI();\\n        for (uint256 i = 0; i < funcSigs.length; i++) {\\n            string memory funcSig = funcSigs[i];\\n            bytes4 selector = _getSelector(funcSig);\\n            address currentFacet = __s().selectorToFacetMap[selector];\\n            if (currentFacet != address(0)) {\\n                // current facet must not be frozen\\n                require(!__s().frozenFacets[currentFacet], \\\"FMLIB:FF\\\");\\n            }\\n            __s().selectorToFacetMap[selector] = facet;\\n            __protectFuncSig(funcSig, false);\\n        }\\n        string[] memory protectedFuncSigs = IDiamondFacet(facet).getFacetProtectedPI();\\n        for (uint256 i = 0; i < protectedFuncSigs.length; i++) {\\n            string memory protectedFuncSig = protectedFuncSigs[i];\\n            __protectFuncSig(protectedFuncSig, true);\\n        }\\n        __s().deletedFacets[facet] = false;\\n        // update facets array\\n        if (__s().facetsIndex[facet] == 0) {\\n            __s().facets.push(facet);\\n            __s().facetsIndex[facet] = __s().facets.length;\\n        }\\n        emit FacetAdd(facet);\\n    }\\n\\n    function _getSelector(string memory funcSig) internal pure returns (bytes4) {\\n        bytes memory funcSigBytes = bytes(funcSig);\\n        for (uint256 i = 0; i < funcSigBytes.length; i++) {\\n            bytes1 b = funcSigBytes[i];\\n            if (\\n                !(b >= 0x30 && b <= 0x39) && // [0-9]\\n                !(b >= 0x41 && b <= 0x5a) && // [A-Z]\\n                !(b >= 0x61 && b <= 0x7a) && // [a-z]\\n                 b != 0x24 && // $\\n                 b != 0x5f && // _\\n                 b != 0x2c && // ,\\n                 b != 0x28 && // (\\n                 b != 0x29 && // )\\n                 b != 0x5b && // [\\n                 b != 0x5d    // ]\\n            ) {\\n                revert(\\\"FMLIB:IFS\\\");\\n            }\\n        }\\n        return bytes4(keccak256(bytes(funcSig)));\\n    }\\n\\n    function __deleteFacet(address facet) private {\\n        require(facet != address(0), \\\"FMLIB:ZF\\\");\\n        require(!__s().frozenFacets[facet], \\\"FMLIB:FF\\\");\\n        __s().deletedFacets[facet] = true;\\n        emit FacetDelete(facet);\\n    }\\n\\n    function __overrideFuncSigs(\\n        string[] memory funcSigs,\\n        address[] memory facets\\n    ) private {\\n        require(funcSigs.length > 0, \\\"FMLIB:ZL\\\");\\n        require(funcSigs.length == facets.length, \\\"FMLIB:IL\\\");\\n        for (uint i = 0; i < funcSigs.length; i++) {\\n            string memory funcSig = funcSigs[i];\\n            address facet = facets[i];\\n            bytes4 selector = _getSelector(funcSig);\\n            address currentFacet = __s().selectorToFacetMap[selector];\\n            if (currentFacet != address(0)) {\\n                // current facet must not be frozen\\n                require(!__s().frozenFacets[currentFacet], \\\"FMLIB:FF\\\");\\n            }\\n            __s().selectorToFacetMap[selector] = facet;\\n            __s().deletedFacets[facet] = false;\\n            if (__s().overridenFuncSigsIndex[funcSig] == 0) {\\n                __s().overridenFuncSigs.push(funcSig);\\n                __s().overridenFuncSigsIndex[funcSig] = __s().overridenFuncSigs.length;\\n            }\\n            emit FuncSigOverride(funcSig, facet);\\n        }\\n    }\\n\\n    function __protectFuncSig(string memory funcSig, bool protect) private {\\n        bytes4 selector = _getSelector(funcSig);\\n        bool oldValue = __s().protectedSelectorMap[selector];\\n        __s().protectedSelectorMap[selector] = protect;\\n        if (oldValue != protect) {\\n            emit ProtectFuncSig(funcSig, protect);\\n        }\\n    }\\n\\n    function __s() private pure returns (FacetManagerStorage.Layout storage) {\\n        return FacetManagerStorage.layout();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/task-executor/TaskExecutorInternal.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"../hasher/HasherLib.sol\\\";\\nimport \\\"./ITaskExecutor.sol\\\";\\nimport \\\"./TaskExecutorStorage.sol\\\";\\n\\nlibrary TaskExecutorInternal {\\n\\n    event TaskManagerSet (\\n        string key,\\n        address taskManager\\n    );\\n\\n    function _initialize(\\n        address newTaskManager\\n    ) internal {\\n        require(!__s().initialized, \\\"TFI:AI\\\");\\n        __setTaskManager(\\\"DEFAULT\\\", newTaskManager);\\n        __s().initialized = true;\\n    }\\n\\n    function _getTaskManagerKeys() internal view returns (string[] memory) {\\n        return __s().keys;\\n    }\\n\\n    function _getTaskManager(string memory key) internal view returns (address) {\\n        bytes32 keyHash = HasherLib._hashStr(key);\\n        require(__s().keysIndex[keyHash] > 0, \\\"TFI:KNF\\\");\\n        return __s().taskManagers[keyHash];\\n    }\\n\\n    function _setTaskManager(\\n        uint256 adminTaskId,\\n        string memory key,\\n        address newTaskManager\\n    ) internal {\\n        require(__s().initialized, \\\"TFI:NI\\\");\\n        bytes32 keyHash = HasherLib._hashStr(key);\\n        address oldTaskManager = __s().taskManagers[keyHash];\\n        __setTaskManager(key, newTaskManager);\\n        if (oldTaskManager != address(0)) {\\n            ITaskExecutor(oldTaskManager).executeAdminTask(msg.sender, adminTaskId);\\n        } else {\\n            address defaultTaskManager = _getTaskManager(\\\"DEFAULT\\\");\\n            require(defaultTaskManager != address(0), \\\"TFI:ZDTM\\\");\\n            ITaskExecutor(defaultTaskManager).executeAdminTask(msg.sender, adminTaskId);\\n        }\\n    }\\n\\n    function _executeTask(\\n        string memory key,\\n        uint256 taskId\\n    ) internal {\\n        require(__s().initialized, \\\"TFI:NI\\\");\\n        address taskManager = _getTaskManager(key);\\n        require(taskManager != address(0), \\\"TFI:ZTM\\\");\\n        ITaskExecutor(taskManager).executeTask(msg.sender, taskId);\\n    }\\n\\n    function _executeAdminTask(\\n        string memory key,\\n        uint256 adminTaskId\\n    ) internal {\\n        require(__s().initialized, \\\"TFI:NI\\\");\\n        address taskManager = _getTaskManager(key);\\n        require(taskManager != address(0), \\\"TFI:ZTM\\\");\\n        ITaskExecutor(taskManager).executeAdminTask(msg.sender, adminTaskId);\\n    }\\n\\n    function __setTaskManager(\\n        string memory key,\\n        address newTaskManager\\n    ) internal {\\n        require(newTaskManager != address(0), \\\"TFI:ZA\\\");\\n        require(IERC165(newTaskManager).supportsInterface(type(ITaskExecutor).interfaceId),\\n            \\\"TFI:IC\\\");\\n        bytes32 keyHash = HasherLib._hashStr(key);\\n        if (__s().keysIndex[keyHash] == 0) {\\n            __s().keys.push(key);\\n            __s().keysIndex[keyHash] = __s().keys.length;\\n        }\\n        __s().taskManagers[keyHash] = newTaskManager;\\n        emit TaskManagerSet(key, newTaskManager);\\n    }\\n\\n    function __s() private pure returns (TaskExecutorStorage.Layout storage) {\\n        return TaskExecutorStorage.layout();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"contracts/facets/hasher/HasherLib.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\nlibrary HasherLib {\\n\\n    function _hashAddress(address addr) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(addr));\\n    }\\n\\n    function _hashStr(string memory str) internal pure returns (bytes32) {\\n        return keccak256(bytes(str));\\n    }\\n\\n    function _hashInt(uint256 num) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"INT\\\", num));\\n    }\\n\\n    function _hashAccount(address account) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"ACCOUNT\\\", account));\\n    }\\n\\n    function _hashVault(address vault) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"VAULT\\\", vault));\\n    }\\n\\n    function _hashReserveId(uint256 reserveId) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"RESERVEID\\\", reserveId));\\n    }\\n\\n    function _hashContract(address contractAddr) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"CONTRACT\\\", contractAddr));\\n    }\\n\\n    function _hashTokenId(uint256 tokenId) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"TOKENID\\\", tokenId));\\n    }\\n\\n    function _hashRole(string memory roleName) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"ROLE\\\", roleName));\\n    }\\n\\n    function _hashLedgerId(uint256 ledgerId) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"LEDGERID\\\", ledgerId));\\n    }\\n\\n    function _mixHash2(\\n        bytes32 d1,\\n        bytes32 d2\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"MIX2_\\\", d1, d2));\\n    }\\n\\n    function _mixHash3(\\n        bytes32 d1,\\n        bytes32 d2,\\n        bytes32 d3\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"MIX3_\\\", d1, d2, d3));\\n    }\\n\\n    function _mixHash4(\\n        bytes32 d1,\\n        bytes32 d2,\\n        bytes32 d3,\\n        bytes32 d4\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"MIX4_\\\", d1, d2, d3, d4));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/task-executor/ITaskExecutor.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\n/// @author Kam Amini <kam@qomet.tech>\\n///\\n/// @notice Use at your own risk\\ninterface ITaskExecutor {\\n\\n    event TaskExecuted(address finalizer, address executor, uint256 taskId);\\n\\n    function executeTask(address executor, uint256 taskId) external;\\n\\n    function executeAdminTask(address executor, uint256 taskId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/facets/task-executor/TaskExecutorStorage.sol\": {\r\n      \"content\": \"/*\\n * This file is part of the Qomet Technologies contracts (https://github.com/qomet-tech/contracts).\\n * Copyright (c) 2022 Qomet Technologies (https://qomet.tech)\\n *\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU General Public License as published by\\n * the Free Software Foundation, version 3.\\n *\\n * This program is distributed in the hope that it will be useful, but\\n * WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n * General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\\n */\\n// SPDX-License-Identifier: GNU General Public License v3.0\\n\\npragma solidity 0.8.1;\\n\\n/// @author Kam Amini <kam@arteq.io>\\n///\\n/// @notice Use at your own risk. Just got the basic\\n///         idea from: https://github.com/solidstate-network/solidstate-solidity\\nlibrary TaskExecutorStorage {\\n\\n    struct Layout {\\n        // list of the keys\\n        string[] keys;\\n        mapping(bytes32 => uint256) keysIndex;\\n        // keccak256(key) > task manager address\\n        mapping(bytes32 => address) taskManagers;\\n        // true if default task manager has been set\\n        bool initialized;\\n        mapping(bytes32 => bytes) extra;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256(\\\"qomet-tech.contracts.facets.task-finalizer.storage\\\");\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 slot = STORAGE_SLOT;\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            s.slot := slot\\n        }\\n        /* solhint-enable no-inline-assembly */\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"defaultSupportingInterfceIds\",\"type\":\"bytes4[]\"},{\"internalType\":\"address\",\"name\":\"initializer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"appRegistry\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"AppInstall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"appRegistry\",\"type\":\"address\"}],\"name\":\"AppRegistrySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeAuthz\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"facets\",\"type\":\"address[]\"}],\"name\":\"addFacets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"funcSigs\",\"type\":\"string[]\"}],\"name\":\"areFuncSigsProtected\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deleteAllFacets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"facets\",\"type\":\"address[]\"}],\"name\":\"deleteFacets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskManagerKey\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"adminTaskId\",\"type\":\"uint256\"}],\"name\":\"freezeAuthz\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskManagerKey\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"adminTaskId\",\"type\":\"uint256\"}],\"name\":\"freezeDiamond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskManagerKey\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"adminTaskId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"freezeFacet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAcceptedAuthzResults\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAppRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthzDomain\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthzSource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDetailsURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDiamondName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDiamondVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFacets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOverridenFuncSigs\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTaskManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"taskManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"appRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"authzSource\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"authzDomain\",\"type\":\"string\"},{\"internalType\":\"string[][2]\",\"name\":\"defaultApps\",\"type\":\"string[][2]\"},{\"internalType\":\"address[]\",\"name\":\"defaultFacets\",\"type\":\"address[]\"},{\"internalType\":\"string[][2]\",\"name\":\"defaultFuncSigsToProtectOrUnprotect\",\"type\":\"string[][2]\"},{\"internalType\":\"address[]\",\"name\":\"defaultFacetsToFreeze\",\"type\":\"address[]\"},{\"internalType\":\"bool[3]\",\"name\":\"instantLockAndFreezes\",\"type\":\"bool[3]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"appName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"appVersion\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"deleteCurrentFacets\",\"type\":\"bool\"}],\"name\":\"installApp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAuthzFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDiamondFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDiamondLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"isFacetFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"funcSigs\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"facets\",\"type\":\"address[]\"}],\"name\":\"overrideFuncSigs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"funcSig\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"protect\",\"type\":\"bool\"}],\"name\":\"protectFuncSig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"toBeDeletedFacets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"toBeAddedFacets\",\"type\":\"address[]\"}],\"name\":\"replaceFacets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"funcSigs\",\"type\":\"string[]\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"acceptedAuthzResults\",\"type\":\"uint256[]\"}],\"name\":\"setAcceptedAuthzResults\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"appRegistry\",\"type\":\"address\"}],\"name\":\"setAppRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"authzDomain\",\"type\":\"string\"}],\"name\":\"setAuthzDomain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authzSource\",\"type\":\"address\"}],\"name\":\"setAuthzSource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"detailsURI\",\"type\":\"string\"}],\"name\":\"setDetailsURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setDiamondName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taskManagerKey\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"taskId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"setLocked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"funcSig\",\"type\":\"string\"}],\"name\":\"tryAuthorizeCall\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Diamond", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000393f7974f9a1c63e1d9d5d98c124a0914302faac0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}