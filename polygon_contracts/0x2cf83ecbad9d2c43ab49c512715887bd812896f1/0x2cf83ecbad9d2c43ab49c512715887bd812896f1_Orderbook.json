{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Orderbook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.20;\\n\\nimport {IOrderbook} from \\\"./interfaces/IOrderbook.sol\\\";\\nimport {IERC721} from \\\"./interfaces/IERC721.sol\\\";\\nimport {IERC2981} from \\\"./interfaces/IERC2981.sol\\\";\\nimport {IERC20} from \\\"@0xsequence/erc-1155/contracts/interfaces/IERC20.sol\\\";\\nimport {IERC1155} from \\\"@0xsequence/erc-1155/contracts/interfaces/IERC1155.sol\\\";\\nimport {TransferHelper} from \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\ncontract Orderbook is IOrderbook, ReentrancyGuard {\\n  mapping(bytes32 => Order) internal _orders;\\n\\n  /**\\n   * Creates an order.\\n   * @param request The requested order's details.\\n   * @return orderId The ID of the order.\\n   */\\n  function createOrder(OrderRequest memory request) external nonReentrant returns (bytes32 orderId) {\\n    return _createOrder(request);\\n  }\\n\\n  /**\\n   * Creates orders.\\n   * @param requests The requested orders' details.\\n   * @return orderIds The IDs of the orders.\\n   */\\n  function createOrderBatch(OrderRequest[] memory requests) external nonReentrant returns (bytes32[] memory orderIds) {\\n    orderIds = new bytes32[](requests.length);\\n    for (uint256 i; i < requests.length; i++) {\\n      orderIds[i] = _createOrder(requests[i]);\\n    }\\n  }\\n\\n  /**\\n   * Performs creation of an order.\\n   * @param request The requested order's details.\\n   * @return orderId The ID of the order.\\n   */\\n  function _createOrder(OrderRequest memory request) internal returns (bytes32 orderId) {\\n    uint256 quantity = request.quantity;\\n    address tokenContract = request.tokenContract;\\n\\n    if (request.pricePerToken == 0) {\\n      revert InvalidPrice();\\n    }\\n    // solhint-disable-next-line not-rely-on-time\\n    if (request.expiry <= block.timestamp) {\\n      revert InvalidExpiry();\\n    }\\n\\n    if (request.isListing) {\\n      // Check valid token for listing\\n      if (!_hasApprovedTokens(request.isERC1155, tokenContract, request.tokenId, quantity, msg.sender)) {\\n        revert InvalidTokenApproval(tokenContract, request.tokenId, quantity, msg.sender);\\n      }\\n    } else {\\n      // Check approved currency for offer\\n      uint256 total = quantity * request.pricePerToken;\\n      if (!_hasApprovedCurrency(request.currency, total, msg.sender)) {\\n        revert InvalidCurrencyApproval(request.currency, total, msg.sender);\\n      }\\n      // Check quantity. Covered by _hasApprovedTokens for listings\\n      if ((request.isERC1155 && quantity == 0) || (!request.isERC1155 && quantity != 1)) {\\n        revert InvalidQuantity();\\n      }\\n    }\\n\\n    Order memory order = Order({\\n      isListing: request.isListing,\\n      isERC1155: request.isERC1155,\\n      creator: msg.sender,\\n      tokenContract: tokenContract,\\n      tokenId: request.tokenId,\\n      quantity: quantity,\\n      currency: request.currency,\\n      pricePerToken: request.pricePerToken,\\n      expiry: request.expiry\\n    });\\n    orderId = hashOrder(order);\\n\\n    if (_orders[orderId].creator != address(0)) {\\n      // Collision\\n      revert InvalidOrderId(orderId);\\n    }\\n    _orders[orderId] = order;\\n\\n    emit OrderCreated(\\n      orderId,\\n      tokenContract,\\n      request.tokenId,\\n      request.isListing,\\n      quantity,\\n      request.currency,\\n      request.pricePerToken,\\n      request.expiry\\n      );\\n\\n    return orderId;\\n  }\\n\\n  /**\\n   * Accepts an order.\\n   * @param orderId The ID of the order.\\n   * @param quantity The quantity of tokens to accept.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeReceivers The addresses to send the additional fees to.\\n   */\\n  function acceptOrder(\\n    bytes32 orderId,\\n    uint256 quantity,\\n    uint256[] memory additionalFees,\\n    address[] memory additionalFeeReceivers\\n  )\\n    external\\n    nonReentrant\\n  {\\n    _acceptOrder(orderId, quantity, additionalFees, additionalFeeReceivers);\\n  }\\n\\n  /**\\n   * Accepts orders.\\n   * @param orderIds The IDs of the orders.\\n   * @param quantities The quantities of tokens to accept.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeReceivers The addresses to send the additional fees to.\\n   * @dev Additional fees are applied to each order.\\n   */\\n  function acceptOrderBatch(\\n    bytes32[] memory orderIds,\\n    uint256[] memory quantities,\\n    uint256[] memory additionalFees,\\n    address[] memory additionalFeeReceivers\\n  )\\n    external\\n    nonReentrant\\n  {\\n    if (orderIds.length != quantities.length) {\\n      revert InvalidBatchRequest();\\n    }\\n\\n    for (uint256 i; i < orderIds.length; i++) {\\n      _acceptOrder(orderIds[i], quantities[i], additionalFees, additionalFeeReceivers);\\n    }\\n  }\\n\\n  /**\\n   * Performs acceptance of an order.\\n   * @param orderId The ID of the order.\\n   * @param quantity The quantity of tokens to accept.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeReceivers The addresses to send the additional fees to.\\n   */\\n  function _acceptOrder(\\n    bytes32 orderId,\\n    uint256 quantity,\\n    uint256[] memory additionalFees,\\n    address[] memory additionalFeeReceivers\\n  )\\n    internal\\n  {\\n    Order memory order = _orders[orderId];\\n    if (order.creator == address(0)) {\\n      // Order cancelled, completed or never existed\\n      revert InvalidOrderId(orderId);\\n    }\\n    if (quantity == 0 || quantity > order.quantity) {\\n      revert InvalidQuantity();\\n    }\\n    if (_isExpired(order)) {\\n      revert InvalidExpiry();\\n    }\\n    if (additionalFees.length != additionalFeeReceivers.length) {\\n      revert InvalidAdditionalFees();\\n    }\\n\\n    // Update order state\\n    if (order.quantity == quantity) {\\n      // Refund some gas\\n      delete _orders[orderId];\\n    } else {\\n      _orders[orderId].quantity -= quantity;\\n    }\\n    address tokenContract = order.tokenContract;\\n\\n    // Calculate payables\\n    uint256 remainingCost = order.pricePerToken * quantity;\\n    (address royaltyRecipient, uint256 royaltyAmount) = getRoyaltyInfo(tokenContract, order.tokenId, remainingCost);\\n\\n    address currencyReceiver = order.isListing ? order.creator : msg.sender;\\n    address tokenReceiver = order.isListing ? msg.sender : order.creator;\\n\\n    if (royaltyAmount > 0) {\\n      if (order.isListing) {\\n        // Royalties are paid by the maker. This reduces the cost for listings.\\n        // Underflow prevents fees > cost\\n        remainingCost -= royaltyAmount;\\n      } else if (royaltyAmount > remainingCost) {\\n        // Royalty cannot exceed cost\\n        revert InvalidRoyalty();\\n      }\\n      // Transfer royalties\\n      TransferHelper.safeTransferFrom(order.currency, tokenReceiver, royaltyRecipient, royaltyAmount);\\n    }\\n\\n    // Transfer additional fees\\n    uint256 totalFees;\\n    for (uint256 i; i < additionalFees.length; i++) {\\n      uint256 fee = additionalFees[i];\\n      address feeReceiver = additionalFeeReceivers[i];\\n      if (feeReceiver == address(0) || fee == 0) {\\n        revert InvalidAdditionalFees();\\n      }\\n      totalFees += fee;\\n      TransferHelper.safeTransferFrom(order.currency, tokenReceiver, feeReceiver, fee);\\n    }\\n    if (!order.isListing) {\\n      // Fees are paid by the taker. This reduces the cost for offers.\\n      // Underflow prevents fees > cost\\n      remainingCost -= totalFees;\\n    } else if (totalFees > remainingCost) {\\n      // Fees cannot exceed cost - royalties\\n      revert InvalidAdditionalFees();\\n    }\\n\\n    // Transfer currency\\n    TransferHelper.safeTransferFrom(order.currency, tokenReceiver, currencyReceiver, remainingCost);\\n\\n    // Transfer token\\n    if (order.isERC1155) {\\n      IERC1155(tokenContract).safeTransferFrom(currencyReceiver, tokenReceiver, order.tokenId, quantity, \\\"\\\");\\n    } else {\\n      IERC721(tokenContract).transferFrom(currencyReceiver, tokenReceiver, order.tokenId);\\n    }\\n\\n    emit OrderAccepted(orderId, msg.sender, tokenContract, quantity, _orders[orderId].quantity);\\n  }\\n\\n  /**\\n   * Cancels an order.\\n   * @param orderId The ID of the order.\\n   */\\n  function cancelOrder(bytes32 orderId) external nonReentrant {\\n    _cancelOrder(orderId);\\n  }\\n\\n  /**\\n   * Cancels orders.\\n   * @param orderIds The IDs of the orders.\\n   */\\n  function cancelOrderBatch(bytes32[] memory orderIds) external nonReentrant {\\n    for (uint256 i; i < orderIds.length; i++) {\\n      _cancelOrder(orderIds[i]);\\n    }\\n  }\\n\\n  /**\\n   * Performs cancellation of an order.\\n   * @param orderId The ID of the order.\\n   */\\n  function _cancelOrder(bytes32 orderId) internal {\\n    Order storage order = _orders[orderId];\\n    if (order.creator != msg.sender) {\\n      revert InvalidOrderId(orderId);\\n    }\\n    address tokenContract = order.tokenContract;\\n\\n    // Refund some gas\\n    delete _orders[orderId];\\n\\n    emit OrderCancelled(orderId, tokenContract);\\n  }\\n\\n  /**\\n   * Deterministically create the orderId for the given order.\\n   * @param order The order.\\n   * @return orderId The ID of the order.\\n   */\\n  function hashOrder(Order memory order) public pure returns (bytes32 orderId) {\\n    return keccak256(\\n      abi.encodePacked(\\n        order.creator,\\n        order.isListing,\\n        order.isERC1155,\\n        order.tokenContract,\\n        order.tokenId,\\n        order.quantity,\\n        order.expiry,\\n        order.currency,\\n        order.pricePerToken\\n      )\\n    );\\n  }\\n\\n  /**\\n   * Gets an order.\\n   * @param orderId The ID of the order.\\n   * @return order The order.\\n   */\\n  function getOrder(bytes32 orderId) external view returns (Order memory order) {\\n    return _orders[orderId];\\n  }\\n\\n  /**\\n   * Gets orders.\\n   * @param orderIds The IDs of the orders.\\n   * @return orders The orders.\\n   */\\n  function getOrderBatch(bytes32[] memory orderIds) external view returns (Order[] memory orders) {\\n    orders = new Order[](orderIds.length);\\n    for (uint256 i; i < orderIds.length; i++) {\\n      orders[i] = _orders[orderIds[i]];\\n    }\\n  }\\n\\n  /**\\n   * Checks if an order is valid.\\n   * @param orderId The ID of the order.\\n   * @param quantity The amount of tokens to exchange. 0 is assumed to be the order's available quantity.\\n   * @return valid The validity of the order.\\n   * @return order The order.\\n   * @notice An order is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isOrderValid(bytes32 orderId, uint256 quantity) public view returns (bool valid, Order memory order) {\\n    order = _orders[orderId];\\n    if (quantity == 0) {\\n      // 0 is assumed to be max quantity\\n      quantity = order.quantity;\\n    }\\n    valid = order.creator != address(0) && !_isExpired(order) && quantity <= order.quantity;\\n    if (valid) {\\n      if (order.isListing) {\\n        valid = _hasApprovedTokens(order.isERC1155, order.tokenContract, order.tokenId, quantity, order.creator);\\n      } else {\\n        // Add royalty\\n        uint256 cost = order.pricePerToken * quantity;\\n        (, uint256 royaltyAmount) = getRoyaltyInfo(order.tokenContract, order.tokenId, cost);\\n        valid = _hasApprovedCurrency(order.currency, cost + royaltyAmount, order.creator);\\n      }\\n    }\\n    return (valid, order);\\n  }\\n\\n  /**\\n   * Checks if orders are valid.\\n   * @param orderIds The IDs of the orders.\\n   * @param quantities The amount of tokens to exchange per order. 0 is assumed to be the order's available quantity.\\n   * @return valid The validities of the orders.\\n   * @return orders The orders.\\n   * @notice An order is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isOrderValidBatch(bytes32[] memory orderIds, uint256[] memory quantities)\\n    external\\n    view\\n    returns (bool[] memory valid, Order[] memory orders)\\n  {\\n    valid = new bool[](orderIds.length);\\n    orders = new Order[](orderIds.length);\\n    for (uint256 i; i < orderIds.length; i++) {\\n      (valid[i], orders[i]) = isOrderValid(orderIds[i], quantities[i]);\\n    }\\n  }\\n\\n  /**\\n   * Checks if a order has expired.\\n   * @param order The order to check.\\n   * @return isExpired True if the order has expired.\\n   */\\n  function _isExpired(Order memory order) internal view returns (bool isExpired) {\\n    // solhint-disable-next-line not-rely-on-time\\n    return order.expiry <= block.timestamp;\\n  }\\n\\n  /**\\n   * Will return how much of currency need to be paid for the royalty.\\n   * @param tokenContract Address of the erc-1155 token being traded\\n   * @param tokenId ID of the erc-1155 token being traded\\n   * @param cost Amount of currency sent/received for the trade\\n   * @return recipient Address that will be able to claim the royalty\\n   * @return royalty Amount of currency that will be sent to royalty recipient\\n   */\\n  function getRoyaltyInfo(address tokenContract, uint256 tokenId, uint256 cost)\\n    public\\n    view\\n    returns (address recipient, uint256 royalty)\\n  {\\n    try IERC2981(address(tokenContract)).royaltyInfo(tokenId, cost) returns (address _r, uint256 _c) {\\n      return (_r, _c);\\n    } catch {} // solhint-disable-line no-empty-blocks\\n    return (address(0), 0);\\n  }\\n\\n  /**\\n   * Checks if the amount of currency is approved for transfer exceeds the given amount.\\n   * @param currency The address of the currency.\\n   * @param amount The amount of currency.\\n   * @param owner The address of the owner of the currency.\\n   * @return isValid True if the amount of currency is sufficient and approved for transfer.\\n   */\\n  function _hasApprovedCurrency(address currency, uint256 amount, address owner) internal view returns (bool isValid) {\\n    return IERC20(currency).balanceOf(owner) >= amount && IERC20(currency).allowance(owner, address(this)) >= amount;\\n  }\\n\\n  /**\\n   * Checks if a token contract is ERC1155 or ERC721 and if the token is owned and approved for transfer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens to list.\\n   * @param owner The address of the owner of the token.\\n   * @return isValid True if the token is owned and approved for transfer.\\n   * @dev Returns false if the token contract is not ERC1155 or ERC721.\\n   */\\n  function _hasApprovedTokens(bool isERC1155, address tokenContract, uint256 tokenId, uint256 quantity, address owner)\\n    internal\\n    view\\n    returns (bool isValid)\\n  {\\n    address orderbook = address(this);\\n\\n    if (isERC1155) {\\n      // ERC1155\\n      return quantity > 0 && IERC1155(tokenContract).balanceOf(owner, tokenId) >= quantity\\n        && IERC1155(tokenContract).isApprovedForAll(owner, orderbook);\\n    }\\n\\n    // ERC721\\n    address tokenOwner;\\n    address operator;\\n\\n    try IERC721(tokenContract).ownerOf(tokenId) returns (address _tokenOwner) {\\n      tokenOwner = _tokenOwner;\\n\\n      try IERC721(tokenContract).getApproved(tokenId) returns (address _operator) {\\n        operator = _operator;\\n      } catch {} // solhint-disable-line no-empty-blocks\\n    } catch {} // solhint-disable-line no-empty-blocks\\n\\n    return quantity == 1 && owner == tokenOwner\\n      && (operator == orderbook || IERC721(tokenContract).isApprovedForAll(owner, orderbook));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOrderbook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.20;\\n\\ninterface IOrderbookStorage {\\n  /**\\n   * Order request parameters.\\n   * @param isListing True if the order is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the order.\\n   * @param currency The address of the currency.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct OrderRequest {\\n    bool isListing; // True if the order is a listing, false if it is an offer.\\n    bool isERC1155; // True if the token is an ERC1155 token, false if it is an ERC721 token.\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n\\n  /**\\n   * Order parameters.\\n   * @param creator The address of the order creator.\\n   * @param isListing True if the order is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the order.\\n   * @param currency The address of the currency.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct Order {\\n    address creator;\\n    bool isListing;\\n    bool isERC1155;\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n}\\n\\ninterface IOrderbookFunctions is IOrderbookStorage {\\n  /**\\n   * Creates an order.\\n   * @param request The requested order's details.\\n   * @return orderId The ID of the order.\\n   * @notice A listing is when the maker is selling tokens for currency.\\n   * @notice An offer is when the maker is buying tokens with currency.\\n   */\\n  function createOrder(OrderRequest memory request) external returns (bytes32 orderId);\\n\\n  /**\\n   * Creates orders.\\n   * @param requests The requested orders' details.\\n   * @return orderIds The IDs of the orders.\\n   */\\n  function createOrderBatch(OrderRequest[] memory requests) external returns (bytes32[] memory orderIds);\\n\\n  /**\\n   * Accepts an order.\\n   * @param orderId The ID of the order.\\n   * @param quantity The quantity of tokens to accept.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeReceivers The addresses to send the additional fees to.\\n   */\\n  function acceptOrder(\\n    bytes32 orderId,\\n    uint256 quantity,\\n    uint256[] memory additionalFees,\\n    address[] memory additionalFeeReceivers\\n  )\\n    external;\\n\\n  /**\\n   * Accepts orders.\\n   * @param orderIds The IDs of the orders.\\n   * @param quantities The quantities of tokens to accept.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeReceivers The addresses to send the additional fees to.\\n   */\\n  function acceptOrderBatch(\\n    bytes32[] memory orderIds,\\n    uint256[] memory quantities,\\n    uint256[] memory additionalFees,\\n    address[] memory additionalFeeReceivers\\n  )\\n    external;\\n\\n  /**\\n   * Cancels an order.\\n   * @param orderId The ID of the order.\\n   */\\n  function cancelOrder(bytes32 orderId) external;\\n\\n  /**\\n   * Cancels orders.\\n   * @param orderIds The IDs of the orders.\\n   */\\n  function cancelOrderBatch(bytes32[] memory orderIds) external;\\n\\n  /**\\n   * Gets an order.\\n   * @param orderId The ID of the order.\\n   * @return order The order.\\n   */\\n  function getOrder(bytes32 orderId) external view returns (Order memory order);\\n\\n  /**\\n   * Gets orders.\\n   * @param orderIds The IDs of the orders.\\n   * @return orders The orders.\\n   */\\n  function getOrderBatch(bytes32[] memory orderIds) external view returns (Order[] memory orders);\\n\\n  /**\\n   * Checks if an order is valid.\\n   * @param orderId The ID of the order.\\n   * @param quantity The amount of tokens to exchange. 0 is assumed to be the order's available quantity.\\n   * @return valid The validity of the order.\\n   * @return order The order.\\n   * @notice An order is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isOrderValid(bytes32 orderId, uint256 quantity) external view returns (bool valid, Order memory order);\\n\\n  /**\\n   * Checks if orders are valid.\\n   * @param orderIds The IDs of the orders.\\n   * @param quantities The amount of tokens to exchange per order. 0 is assumed to be the order's available quantity.\\n   * @return valid The validities of the orders.\\n   * @return orders The orders.\\n   * @notice An order is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isOrderValidBatch(bytes32[] memory orderIds, uint256[] memory quantities)\\n    external\\n    view\\n    returns (bool[] memory valid, Order[] memory orders);\\n}\\n\\ninterface IOrderbookSignals {\\n  //\\n  // Events\\n  //\\n\\n  /// Emitted when an Order is created.\\n  event OrderCreated(\\n    bytes32 indexed orderId,\\n    address indexed tokenContract,\\n    uint256 indexed tokenId,\\n    bool isListing,\\n    uint256 quantity,\\n    address currency,\\n    uint256 pricePerToken,\\n    uint256 expiry\\n  );\\n\\n  /// Emitted when an Order is accepted.\\n  event OrderAccepted(\\n    bytes32 indexed orderId,\\n    address indexed buyer,\\n    address indexed tokenContract,\\n    uint256 quantity,\\n    uint256 quantityRemaining\\n  );\\n\\n  /// Emitted when an Order is cancelled.\\n  event OrderCancelled(bytes32 indexed orderId, address indexed tokenContract);\\n\\n  //\\n  // Errors\\n  //\\n\\n  /// Thrown when the token approval is invalid.\\n  error InvalidTokenApproval(address tokenContract, uint256 tokenId, uint256 quantity, address owner);\\n\\n  /// Thrown when the currency approval is invalid.\\n  error InvalidCurrencyApproval(address currency, uint256 quantity, address owner);\\n\\n  /// Thrown when order id is invalid.\\n  error InvalidOrderId(bytes32 orderId);\\n\\n  /// Thrown when the parameters of a batch accept request are invalid.\\n  error InvalidBatchRequest();\\n\\n  /// Thrown when quantity is invalid.\\n  error InvalidQuantity();\\n\\n  /// Thrown when price is invalid.\\n  error InvalidPrice();\\n\\n  /// Thrown when royalty is invalid.\\n  error InvalidRoyalty();\\n\\n  /// Thrown when expiry is invalid.\\n  error InvalidExpiry();\\n\\n  /// Thrown when the additional fees are invalid.\\n  error InvalidAdditionalFees();\\n}\\n\\n// solhint-disable-next-line no-empty-blocks\\ninterface IOrderbook is IOrderbookFunctions, IOrderbookSignals {}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.20;\\n\\ninterface IERC721 {\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  function balanceOf(address _owner) external view returns (uint256 balance);\\n  function ownerOf(uint256 _tokenId) external view returns (address owner);\\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\\n  function transferFrom(address _from, address _to, uint256 _tokenId) external;\\n  function approve(address _to, uint256 _tokenId) external;\\n  function getApproved(uint256 _tokenId) external view returns (address operator);\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.20;\\n\\nimport {IERC165} from \\\"@0xsequence/erc-1155/contracts/interfaces/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard\\n */\\ninterface IERC2981 is IERC165 {\\n  /**\\n   * @notice Called with the sale price to determine how much royalty\\n   * is owed and to whom.\\n   * @param _tokenId - the NFT asset queried for royalty information\\n   * @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n   * @return receiver - address of who should be sent the royalty payment\\n   * @return royaltyAmount - the royalty payment amount for _salePrice\\n   */\\n  function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n    external\\n    view\\n    returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"lib/0xsequence/erc-1155/src/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title ERC20 interface\\r\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\r\\n */\\r\\ninterface IERC20 {\\r\\n  function transfer(address to, uint256 value) external returns (bool);\\r\\n  function approve(address spender, uint256 value) external returns (bool);\\r\\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function balanceOf(address who) external view returns (uint256);\\r\\n  function allowance(address owner, address spender) external view returns (uint256);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/0xsequence/erc-1155/src/contracts/interfaces/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity ^0.8.0;\\r\\nimport './IERC165.sol';\\r\\n\\r\\n\\r\\ninterface IERC1155 is IERC165 {\\r\\n\\r\\n  /****************************************|\\r\\n  |                 Events                 |\\r\\n  |_______________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\r\\n   *   Operator MUST be msg.sender\\r\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\r\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\r\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\r\\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\r\\n   */\\r\\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\\r\\n\\r\\n  /**\\r\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\r\\n   *   Operator MUST be msg.sender\\r\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\r\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\r\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\r\\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\r\\n   */\\r\\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\\r\\n\\r\\n  /**\\r\\n   * @dev MUST emit when an approval is updated\\r\\n   */\\r\\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n\\r\\n\\r\\n  /****************************************|\\r\\n  |                Functions               |\\r\\n  |_______________________________________*/\\r\\n\\r\\n  /**\\r\\n    * @notice Transfers amount of an _id from the _from address to the _to address specified\\r\\n    * @dev MUST emit TransferSingle event on success\\r\\n    * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\r\\n    * MUST throw if `_to` is the zero address\\r\\n    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\\r\\n    * MUST throw on any other error\\r\\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n    * @param _from    Source address\\r\\n    * @param _to      Target address\\r\\n    * @param _id      ID of the token type\\r\\n    * @param _amount  Transfered amount\\r\\n    * @param _data    Additional data with no specified format, sent in call to `_to`\\r\\n    */\\r\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\\r\\n\\r\\n  /**\\r\\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\r\\n    * @dev MUST emit TransferBatch event on success\\r\\n    * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\r\\n    * MUST throw if `_to` is the zero address\\r\\n    * MUST throw if length of `_ids` is not the same as length of `_amounts`\\r\\n    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\\r\\n    * MUST throw on any other error\\r\\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\\r\\n    * @param _from     Source addresses\\r\\n    * @param _to       Target addresses\\r\\n    * @param _ids      IDs of each token type\\r\\n    * @param _amounts  Transfer amounts per token type\\r\\n    * @param _data     Additional data with no specified format, sent in call to `_to`\\r\\n  */\\r\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Get the balance of an account's Tokens\\r\\n   * @param _owner  The address of the token holder\\r\\n   * @param _id     ID of the Token\\r\\n   * @return        The _owner's balance of the Token type requested\\r\\n   */\\r\\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @notice Get the balance of multiple account/token pairs\\r\\n   * @param _owners The addresses of the token holders\\r\\n   * @param _ids    ID of the Tokens\\r\\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\r\\n   */\\r\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\\r\\n\\r\\n  /**\\r\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller's tokens\\r\\n   * @dev MUST emit the ApprovalForAll event on success\\r\\n   * @param _operator  Address to add to the set of authorized operators\\r\\n   * @param _approved  True if the operator is approved, false to revoke approval\\r\\n   */\\r\\n  function setApprovalForAll(address _operator, bool _approved) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Queries the approval status of an operator for a given owner\\r\\n   * @param _owner     The owner of the Tokens\\r\\n   * @param _operator  Address of authorized operator\\r\\n   * @return isOperator True if the operator is approved, false if not\\r\\n   */\\r\\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/uniswap-lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper::safeApprove: approve failed'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper::safeTransfer: transfer failed'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper::transferFrom: transferFrom failed'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler's defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant NOT_ENTERED = 1;\\r\\n    uint256 private constant ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    /**\\r\\n     * @dev Unauthorized reentrant call.\\r\\n     */\\r\\n    error ReentrancyGuardReentrantCall();\\r\\n\\r\\n    constructor() {\\r\\n        _status = NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\r\\n        if (_status == ENTERED) {\\r\\n            revert ReentrancyGuardReentrantCall();\\r\\n        }\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\r\\n     * `nonReentrant` function in the call stack.\\r\\n     */\\r\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\r\\n        return _status == ENTERED;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/0xsequence/erc-1155/src/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC165\\r\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\r\\n */\\r\\ninterface IERC165 {\\r\\n\\r\\n    /**\\r\\n     * @notice Query if a contract implements an interface\\r\\n     * @dev Interface identification is specified in ERC-165. This function\\r\\n     * uses less than 30,000 gas\\r\\n     * @param _interfaceId The interface identifier, as specified in ERC-165\\r\\n     */\\r\\n    function supportsInterface(bytes4 _interfaceId)\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"0xsequence/=lib/0xsequence/\",\r\n      \"@0xsequence/erc-1155/=lib/0xsequence/erc-1155/src/\",\r\n      \"@0xsequence/erc20-meta-token/=lib/0xsequence/erc20-meta-token/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin/contracts/\",\r\n      \"@uniswap/lib/=lib/uniswap-lib/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin/\",\r\n      \"uniswap-lib/=lib/uniswap-lib/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"InvalidAdditionalFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBatchRequest\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"InvalidCurrencyApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidExpiry\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderId\",\"type\":\"bytes32\"}],\"name\":\"InvalidOrderId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRoyalty\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"InvalidTokenApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orderId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantityRemaining\",\"type\":\"uint256\"}],\"name\":\"OrderAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orderId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orderId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"OrderCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"additionalFees\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"additionalFeeReceivers\",\"type\":\"address[]\"}],\"name\":\"acceptOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"orderIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"additionalFees\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"additionalFeeReceivers\",\"type\":\"address[]\"}],\"name\":\"acceptOrderBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderId\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"orderIds\",\"type\":\"bytes32[]\"}],\"name\":\"cancelOrderBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderbookStorage.OrderRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"createOrder\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderbookStorage.OrderRequest[]\",\"name\":\"requests\",\"type\":\"tuple[]\"}],\"name\":\"createOrderBatch\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"orderIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderId\",\"type\":\"bytes32\"}],\"name\":\"getOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderbookStorage.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"orderIds\",\"type\":\"bytes32[]\"}],\"name\":\"getOrderBatch\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderbookStorage.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderbookStorage.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"hashOrder\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderId\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"isOrderValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderbookStorage.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"orderIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"}],\"name\":\"isOrderValidBatch\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"valid\",\"type\":\"bool[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct IOrderbookStorage.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Orderbook", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}