{"SourceCode": "// // PrivateLoop\r\n// // SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface AggregatorV3Interface {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function description() external view returns (string memory);\r\n\r\n    function version() external view returns (uint256);\r\n\r\n    function getRoundData(\r\n        uint80 _roundId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}\r\n\r\ncontract EIP712Helper {\r\n    constructor() {}\r\n\r\n    function buildTypeHash() public pure returns (bytes32 hash) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"Subscription(\",\r\n                    \"address payer,\",\r\n                    \"address receiver,\",\r\n                    \"uint128 amountUSD,\",\r\n                    \"address paymentToken,\",\r\n                    \"uint256 startDate,\",\r\n                    \"uint256 endDate,\",\r\n                    \"uint256 minPayoutFrequency,\",\r\n                    \"uint256 partnerID\"\r\n                    \")\"\r\n                )\r\n            );\r\n    }\r\n}\r\n\r\n/// @dev Helpers for moving tokens around.\r\nabstract contract FixinTokenSpender {\r\n    // Mask of the lower 20 bytes of a bytes32.\r\n    uint256 private constant ADDRESS_MASK =\r\n        0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /// @dev Transfers ERC20 tokens from `owner` to `to`.\r\n    /// @param token The token to spend.\r\n    /// @param owner The owner of the tokens.\r\n    /// @param to The recipient of the tokens.\r\n    /// @param amount The amount of `token` to transfer.\r\n    function _transferERC20TokensFrom(\r\n        IERC20TokenV06 token,\r\n        address owner,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        require(\r\n            address(token) != address(this),\r\n            \"FixinTokenSpender/CANNOT_INVOKE_SELF\"\r\n        );\r\n\r\n        assembly {\r\n            let ptr := mload(0x40) // free memory pointer\r\n\r\n            // selector for transferFrom(address,address,uint256)\r\n            mstore(\r\n                ptr,\r\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\r\n            )\r\n            mstore(add(ptr, 0x04), and(owner, ADDRESS_MASK))\r\n            mstore(add(ptr, 0x24), and(to, ADDRESS_MASK))\r\n            mstore(add(ptr, 0x44), amount)\r\n\r\n            let success := call(\r\n                gas(),\r\n                and(token, ADDRESS_MASK),\r\n                0,\r\n                ptr,\r\n                0x64,\r\n                ptr,\r\n                32\r\n            )\r\n\r\n            let rdsize := returndatasize()\r\n\r\n            // Check for ERC20 success. ERC20 tokens should return a boolean,\r\n            // but some don't. We accept 0-length return data as success, or at\r\n            // least 32 bytes that starts with a 32-byte boolean true.\r\n            success := and(\r\n                success, // call itself succeeded\r\n                or(\r\n                    iszero(rdsize), // no return data, or\r\n                    and(\r\n                        iszero(lt(rdsize, 32)), // at least 32 bytes\r\n                        eq(mload(ptr), 1) // starts with uint256(1)\r\n                    )\r\n                )\r\n            )\r\n\r\n            if iszero(success) {\r\n                returndatacopy(ptr, 0, rdsize)\r\n                revert(ptr, rdsize)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers ERC20 tokens from ourselves to `to`.\r\n    /// @param token The token to spend.\r\n    /// @param to The recipient of the tokens.\r\n    /// @param amount The amount of `token` to transfer.\r\n    function _transferERC20Tokens(\r\n        IERC20TokenV06 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        require(\r\n            address(token) != address(this),\r\n            \"FixinTokenSpender/CANNOT_INVOKE_SELF\"\r\n        );\r\n\r\n        assembly {\r\n            let ptr := mload(0x40) // free memory pointer\r\n\r\n            // selector for transfer(address,uint256)\r\n            mstore(\r\n                ptr,\r\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\r\n            )\r\n            mstore(add(ptr, 0x04), and(to, ADDRESS_MASK))\r\n            mstore(add(ptr, 0x24), amount)\r\n\r\n            let success := call(\r\n                gas(),\r\n                and(token, ADDRESS_MASK),\r\n                0,\r\n                ptr,\r\n                0x44,\r\n                ptr,\r\n                32\r\n            )\r\n\r\n            let rdsize := returndatasize()\r\n\r\n            // Check for ERC20 success. ERC20 tokens should return a boolean,\r\n            // but some don't. We accept 0-length return data as success, or at\r\n            // least 32 bytes that starts with a 32-byte boolean true.\r\n            success := and(\r\n                success, // call itself succeeded\r\n                or(\r\n                    iszero(rdsize), // no return data, or\r\n                    and(\r\n                        iszero(lt(rdsize, 32)), // at least 32 bytes\r\n                        eq(mload(ptr), 1) // starts with uint256(1)\r\n                    )\r\n                )\r\n            )\r\n\r\n            if iszero(success) {\r\n                returndatacopy(ptr, 0, rdsize)\r\n                revert(ptr, rdsize)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers some amount of ETH to the given recipient and\r\n    ///      reverts if the transfer fails.\r\n    /// @param recipient The recipient of the ETH.\r\n    /// @param amount The amount of ETH to transfer.\r\n    function _transferEth(address payable recipient, uint256 amount) internal {\r\n        if (amount > 0) {\r\n            (bool success, ) = recipient.call{value: amount}(\"\");\r\n            require(success, \"FixinTokenSpender::_transferEth/TRANSFER_FAILED\");\r\n        }\r\n    }\r\n\r\n    /// @dev Gets the maximum amount of an ERC20 token `token` that can be\r\n    ///      pulled from `owner` by this address.\r\n    /// @param token The token to spend.\r\n    /// @param owner The owner of the tokens.\r\n    /// @return amount The amount of tokens that can be pulled.\r\n    function _getSpendableERC20BalanceOf(\r\n        IERC20TokenV06 token,\r\n        address owner\r\n    ) internal view returns (uint256) {\r\n        return\r\n            LibSafeMathV06.min256(\r\n                token.allowance(owner, address(this)),\r\n                token.balanceOf(owner)\r\n            );\r\n    }\r\n}\r\n\r\ninterface IERC20TokenV06 {\r\n    // solhint-disable no-simple-event-func-name\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /// @dev send `value` token to `to` from `msg.sender`\r\n    /// @param to The address of the recipient\r\n    /// @param value The amount of token to be transferred\r\n    /// @return True if transfer was successful\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /// @dev send `value` token to `to` from `from` on the condition it is approved by `from`\r\n    /// @param from The address of the sender\r\n    /// @param to The address of the recipient\r\n    /// @param value The amount of token to be transferred\r\n    /// @return True if transfer was successful\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    /// @dev `msg.sender` approves `spender` to spend `value` tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param value The amount of wei to be approved for transfer\r\n    /// @return Always true if the call has enough gas to complete execution\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /// @dev Query total supply of token\r\n    /// @return Total supply of token\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @dev Get the balance of `owner`.\r\n    /// @param owner The address from which the balance will be retrieved\r\n    /// @return Balance of owner\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /// @dev Get the allowance for `spender` to spend from `owner`.\r\n    /// @param owner The address of the account owning tokens\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /// @dev Get the number of decimals this token has.\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nlibrary LibSafeMathV06 {\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        if (c / a != b) {\r\n            revert(\"MULTIPLICATION_OVERFLOW\");\r\n        }\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b == 0) {\r\n            revert(\"DIVISION_BY_ZERO\");\r\n        }\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b > a) {\r\n            revert(\"SUBTRACTION_UNDERFLOW\");\r\n        }\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) {\r\n            revert(\"ADDITION_OVERFLOW\");\r\n        }\r\n        return c;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function safeMul128(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint128 c = a * b;\r\n        if (c / a != b) {\r\n            revert(\"MULTIPLICATION_OVERFLOW\");\r\n        }\r\n        return c;\r\n    }\r\n\r\n    function safeDiv128(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        if (b == 0) {\r\n            revert(\"DIVISION_BY_ZERO\");\r\n        }\r\n        uint128 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub128(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        if (b > a) {\r\n            revert(\"SUBTRACTION_UNDERFLOW\");\r\n        }\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd128(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        uint128 c = a + b;\r\n        if (c < a) {\r\n            revert(\"ADDITION_OVERFLOW\");\r\n        }\r\n        return c;\r\n    }\r\n\r\n    function max128(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min128(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function safeDowncastToUint128(uint256 a) internal pure returns (uint128) {\r\n        if (a > type(uint128).max) {\r\n            revert(\"VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT128\");\r\n        }\r\n        return uint128(a);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract SubscriptionManager is FixinTokenSpender, Ownable {\r\n    /// @dev Name of this contract\r\n    string private constant CONTRACT_NAME = \"SubscriptionManager\";\r\n    /// @dev Version of this contract\r\n    string private constant VERSION = \"1\";\r\n    /// @dev Domain hash separator\r\n    bytes32 private immutable EIP712_DOMAIN_SEPARATOR;\r\n    /// @dev Type hash of subscription\r\n    bytes32 private immutable TYPE_HASH;\r\n\r\n    /// @dev Minimal protocol fee in cents\r\n    uint16 public immutable MIN_PROTOCOL_FEE;\r\n\r\n    /// @dev Protocol percentage in BPS (0.01%), limit is 2.55%\r\n    uint8 public feePercentage = 0;\r\n\r\n    /// @dev Mapping the last payment dates of subscriptions\r\n    mapping(bytes32 => uint256) subscriptionHashToLastPaidDate;\r\n\r\n    /// @dev Whitelist of payment tokens\r\n    mapping(address => bool) public allowedTokenAddresses;\r\n\r\n    /// @dev Exclusive upper limit on ECDSA signatures 'R' values\r\n    ///      The valid range is given by fig (282) of the yellow paper\r\n    uint256 private constant ECDSA_SIGNATURE_R_LIMIT =\r\n        uint256(\r\n            0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\r\n        );\r\n    /// @dev Exclusive upper limit on ECDSA signatures 'S' values\r\n    ///      The valid range is given by fig (283) of the yellow paper\r\n    uint256 private constant ECDSA_SIGNATURE_S_LIMIT =\r\n        ECDSA_SIGNATURE_R_LIMIT / 2 + 1;\r\n\r\n    /// @dev Allowed signature types\r\n    enum SignatureType {\r\n        EIP712\r\n    }\r\n\r\n    /// @dev Encoded EC signature\r\n    struct Signature {\r\n        // How to validate the signature.\r\n        SignatureType signatureType;\r\n        // EC Signature data.\r\n        uint8 v;\r\n        // EC Signature data.\r\n        bytes32 r;\r\n        // EC Signature data.\r\n        bytes32 s;\r\n    }\r\n\r\n    /// @dev Subscription struct\r\n    struct Subscription {\r\n        address payer;\r\n        address receiver;\r\n        uint128 amountUSD;\r\n        IERC20TokenV06 paymentToken;\r\n        uint256 startDate;\r\n        uint256 endDate;\r\n        uint256 minPayoutFrequency;\r\n        uint256 partnerID;\r\n    }\r\n\r\n    /// @dev Event of a successful payment\r\n    event paymentMade(\r\n        bytes32 subscriptionHash,\r\n        address receiver,\r\n        uint128 amountUSD,\r\n        uint256 amountToken,\r\n        address paymentToken,\r\n        uint256 startDate,\r\n        uint256 endDate,\r\n        uint256 minPayoutFrequency,\r\n        uint256 partnerID\r\n    );\r\n\r\n    constructor(\r\n        //Allowed payment tokens\r\n        address[] memory tokenAddresses,\r\n        //Minimal protocol fee in cents (USD)\r\n        uint16 minProtocolFee\r\n    ) {\r\n        {\r\n            // Compute `EIP712_DOMAIN_SEPARATOR`\r\n            uint256 chainId;\r\n            assembly {\r\n                chainId := chainid()\r\n            }\r\n            EIP712_DOMAIN_SEPARATOR = keccak256(\r\n                abi.encode(\r\n                    keccak256(\r\n                        \"EIP712Domain(\"\r\n                        \"string name,\"\r\n                        \"string version,\"\r\n                        \"uint256 chainId,\"\r\n                        \"address verifyingContract\"\r\n                        \")\"\r\n                    ),\r\n                    keccak256(bytes(CONTRACT_NAME)),\r\n                    keccak256(bytes(VERSION)),\r\n                    chainId,\r\n                    address(this)\r\n                )\r\n            );\r\n\r\n            //Compute type hash of subscription struct\r\n            TYPE_HASH = keccak256(\r\n                abi.encodePacked(\r\n                    \"Subscription(\",\r\n                    \"address payer,\",\r\n                    \"address receiver,\",\r\n                    \"uint128 amountUSD,\",\r\n                    \"address paymentToken,\",\r\n                    \"uint256 startDate,\",\r\n                    \"uint256 endDate,\",\r\n                    \"uint256 minPayoutFrequency,\",\r\n                    \"uint256 partnerID\"\r\n                    \")\"\r\n                )\r\n            );\r\n\r\n            //Set minimal protocol fee in cents (USD)\r\n            MIN_PROTOCOL_FEE = minProtocolFee;\r\n\r\n            //Predefine mapping of token address with chainlink addresses. This mapping couldn't be changed in the future\r\n            require(\r\n                tokenAddresses.length > 0,\r\n                \"Allowed list of payment tokens is empty\"\r\n            );\r\n            for (uint i = 0; i < tokenAddresses.length; i++) {\r\n                allowedTokenAddresses[tokenAddresses[i]] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev     The function will charge off according to the specified subscription\r\n     * @param   subscription  Subscription struct\r\n     * @param   signature  EIP-712 signature of payer\r\n     */\r\n    function makePayment(\r\n        Subscription memory subscription,\r\n        Signature memory signature\r\n    ) external {\r\n        // 1. Check order validity and get order info\r\n        bytes32 subscriptionHash = _checkSubscriptionValidity(\r\n            subscription,\r\n            signature\r\n        );\r\n\r\n        // 2. Check if the payment token exists in the whitelist\r\n        require(\r\n            allowedTokenAddresses[address(subscription.paymentToken)] == true,\r\n            \"Payment in the specific token is not allowed\"\r\n        );\r\n\r\n        // 3. Update payment status\r\n        subscriptionHashToLastPaidDate[subscriptionHash] = block.timestamp;\r\n\r\n        // 4. Remember taker balance before payment\r\n        uint256 payerBalanceBefore = subscription.paymentToken.balanceOf(\r\n            subscription.payer\r\n        );\r\n\r\n        // 5. Calculate amount in payment token\r\n        // Minus 2 is used to convert amountUSD from cents to dollars\r\n        require(\r\n            IERC20TokenV06(subscription.paymentToken).decimals() >= 2,\r\n            \"The decimals of payment token should be greater than 2\"\r\n        );\r\n        uint256 amountPaymentToken;\r\n        {\r\n            // Calculate protocol fee in cents (USD)\r\n            uint feeRelative = LibSafeMathV06.safeMul(\r\n                subscription.amountUSD,\r\n                feePercentage\r\n            ) / 10000;\r\n            uint fee = LibSafeMathV06.max256(MIN_PROTOCOL_FEE, feeRelative);\r\n            // Calculate payment amount\r\n            uint256 amountUSDMinusFee = LibSafeMathV06.safeSub(\r\n                subscription.amountUSD,\r\n                fee\r\n            );\r\n\r\n            // Cast to token's decimals. Minus two for converting from cents to USD\r\n            // Cast to token's decimals. Minus two for converting from cents to USD\r\n            uint multiplicar = 10 **\r\n                (IERC20TokenV06(subscription.paymentToken).decimals() - 2);\r\n            amountPaymentToken = LibSafeMathV06.safeMul(\r\n                amountUSDMinusFee,\r\n                multiplicar\r\n            );\r\n            uint256 amountFeeToken = LibSafeMathV06.safeMul(fee, multiplicar);\r\n            // 6. Perform required transfers\r\n            _transferERC20TokensFrom(\r\n                subscription.paymentToken,\r\n                subscription.payer,\r\n                subscription.receiver,\r\n                amountPaymentToken\r\n            );\r\n            _transferERC20TokensFrom(\r\n                subscription.paymentToken,\r\n                subscription.payer,\r\n                owner(),\r\n                amountFeeToken\r\n            );\r\n        }\r\n        // 7. Check balance after order is filled\r\n        require(\r\n            payerBalanceBefore >\r\n                subscription.paymentToken.balanceOf(subscription.payer),\r\n            \"Balance of payer hasn't decreased\"\r\n        );\r\n\r\n        emit paymentMade(\r\n            subscriptionHash,\r\n            subscription.receiver,\r\n            subscription.amountUSD,\r\n            amountPaymentToken,\r\n            address(subscription.paymentToken),\r\n            subscription.startDate,\r\n            subscription.endDate,\r\n            subscription.minPayoutFrequency,\r\n            subscription.partnerID\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev     Sets protocol fee\r\n     * @param   _feePercentage  Fee in BPS (0.01%)\r\n     */\r\n    function setFee(uint8 _feePercentage) public onlyOwner {\r\n        feePercentage = _feePercentage;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the domain separator hash of the smart contract\r\n     * @return  hash  Domain separator hash\r\n     */\r\n    function getDomainSeparatorHash() public view returns (bytes32 hash) {\r\n        return EIP712_DOMAIN_SEPARATOR;\r\n    }\r\n\r\n    /**\r\n     * @dev     Returns the type hash of the subscription struct\r\n     * @return  typeHash  Type hash\r\n     */\r\n    function getTypeHash() public view returns (bytes32 typeHash) {\r\n        return TYPE_HASH;\r\n    }\r\n\r\n    /**\r\n     * @dev     Computes struct hash of subscription\r\n     * @param   subscription  Subscription struct\r\n     * @return  structHash  Hash of subscription\r\n     */\r\n    function _getSubscriptionStructHash(\r\n        Subscription memory subscription\r\n    ) internal view returns (bytes32 structHash) {\r\n        // The struct hash of subscription is:\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    TYPE_HASH,\r\n                    subscription.payer,\r\n                    subscription.receiver,\r\n                    subscription.amountUSD,\r\n                    subscription.paymentToken,\r\n                    subscription.startDate,\r\n                    subscription.endDate,\r\n                    subscription.minPayoutFrequency,\r\n                    subscription.partnerID\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev     Validate the signature and retrive the signer of a signature\r\n     * @param   hash  Hash that was signed\r\n     * @param   signature EIP-712 signature\r\n     * @return  recovered  Recovered signer address\r\n     */\r\n    function _getSignerOfHash(\r\n        bytes32 hash,\r\n        Signature memory signature\r\n    ) internal pure returns (address recovered) {\r\n        require(\r\n            signature.signatureType == SignatureType.EIP712,\r\n            \"Only EIP712 signature is supported\"\r\n        );\r\n        // Ensure this is a signature type that can be validated against a hash.\r\n        // Ensure the r and s are within malleability limits.\r\n        if (\r\n            uint256(signature.r) >= ECDSA_SIGNATURE_R_LIMIT ||\r\n            uint256(signature.s) >= ECDSA_SIGNATURE_S_LIMIT\r\n        ) {\r\n            revert(\"Bad signature data\");\r\n        }\r\n        recovered = ecrecover(hash, signature.v, signature.r, signature.s);\r\n        // `recovered` can be null if the signature values are out of range.\r\n        require(recovered != address(0), \"Bad signature\");\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev     Checks the validity of the subscription\r\n     * @param   subscription  Subscription struct\r\n     * @param   signature  EIP-712 signature of payer\r\n     * @return  subscriptionHash  Returns subscription hash if the subscription is valid\r\n     */\r\n    function _checkSubscriptionValidity(\r\n        Subscription memory subscription,\r\n        Signature memory signature\r\n    ) internal view returns (bytes32 subscriptionHash) {\r\n        subscriptionHash = _getSubscriptionStructHash(subscription);\r\n\r\n        // 1. Check that subscription is alive\r\n        require(\r\n            subscription.startDate <= block.timestamp,\r\n            \"The subscription hasn't started yet\"\r\n        );\r\n        require(\r\n            subscription.endDate >= block.timestamp,\r\n            \"The subscription has expired\"\r\n        );\r\n\r\n        // 2. Check that the previous payment was earlier than the payment frequency\r\n        uint256 timeAfterLastPayment = LibSafeMathV06.safeSub(\r\n            block.timestamp,\r\n            subscriptionHashToLastPaidDate[subscriptionHash]\r\n        );\r\n        require(\r\n            timeAfterLastPayment >= subscription.minPayoutFrequency,\r\n            \"The time between payments is less than allowed\"\r\n        );\r\n\r\n        // 3. Check that signature is valid for the subscription\r\n        address signerOfHash = _getSignerOfHash(\r\n            _getEIP712Hash(subscriptionHash),\r\n            signature\r\n        );\r\n\r\n        require(\r\n            subscription.payer == signerOfHash,\r\n            \"Signer of subscription is not the payer\"\r\n        );\r\n\r\n        return subscriptionHash;\r\n    }\r\n\r\n    /**\r\n     * @dev     Returns EIP712 hash of a subscription struct hash\r\n     * @param   structHash  Struct hash\r\n     * @return  eip712Hash  EIP712 hashs\r\n     */\r\n    function _getEIP712Hash(\r\n        bytes32 structHash\r\n    ) internal view returns (bytes32 eip712Hash) {\r\n        return\r\n            //hex\"1901\" is the EIP-712 signature type identifier\r\n            keccak256(\r\n                abi.encodePacked(hex\"1901\", EIP712_DOMAIN_SEPARATOR, structHash)\r\n            );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint16\",\"name\":\"minProtocolFee\",\"type\":\"uint16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"subscriptionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amountUSD\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPayoutFrequency\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"partnerID\",\"type\":\"uint256\"}],\"name\":\"paymentMade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_PROTOCOL_FEE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedTokenAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDomainSeparatorHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTypeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"typeHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amountUSD\",\"type\":\"uint128\"},{\"internalType\":\"contract IERC20TokenV06\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPayoutFrequency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partnerID\",\"type\":\"uint256\"}],\"internalType\":\"struct SubscriptionManager.Subscription\",\"name\":\"subscription\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum SubscriptionManager.SignatureType\",\"name\":\"signatureType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct SubscriptionManager.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"makePayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_feePercentage\",\"type\":\"uint8\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SubscriptionManager", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "10000000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f0000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000008f3cf7ad23cd3cadbd9735aff958023239c6a0630000000000000000000000002e1ad108ff1d8c782fcbbb89aad783ac49586756", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://11aaa9f8d907c9222f471249826c966103825b15f2762f049d4a86af93ac30c3"}