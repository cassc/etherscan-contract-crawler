{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LQTY/TokenStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\nimport \\\"../Dependencies/BaseMath.sol\\\";\\nimport \\\"../Dependencies/SafeMath.sol\\\";\\nimport \\\"../Dependencies/Ownable.sol\\\";\\nimport \\\"../Dependencies/IERC20.sol\\\";\\nimport \\\"../Interfaces/ITokenStaking.sol\\\";\\nimport \\\"../Interfaces/ILQTYStaking.sol\\\";\\nimport \\\"../utils/SafeToken.sol\\\";\\n\\n\\ncontract ClaimAndUpdate is ITokenStaking, Ownable, BaseMath {\\n    using SafeMath for uint;\\n\\n    // --- Data ---\\n    string constant public NAME = \\\"ClaimAndUpdate\\\";\\n    address constant public GAS_TOKEN_ADDR = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    ILQTYStaking public PYQStaking;\\n\\n    uint256 public PYQrewardUnit;\\n\\n    address public PYQToken;\\n    address[] public feeTokens;\\n    mapping (address => uint256) public lastStakes;\\n    mapping (address => address) public feeTokenMap;\\n\\n    mapping (address => bool) public isTM;  // is valid trove manager\\n    mapping (address => bool) public isBO;  // is valid borrower operation\\n    mapping (address => bool) public isAP;  // is valid active pool\\n\\n    mapping (address => uint256) public feePerTokenStaked;\\n    mapping (address => mapping(address => uint256)) public snapshots;\\n\\n    \\n    event StakerStakeUpdated(address user, uint newStake);\\n    \\n    // --- Functions ---\\n\\n    function setAddresses\\n    (\\n        address _pyqStaking,\\n        address _pyqToken,\\n        address _borrowingFeeToken,\\n        address _redeemingFeeToken,\\n        address _troveManager,\\n        address _borrowerOperation,\\n        address _activePool\\n    )\\n        external\\n        onlyOwner\\n        override\\n    {\\n        PYQStaking = ILQTYStaking(_pyqStaking);\\n        PYQToken = _pyqToken;\\n        \\n        feeTokenMap[_pyqToken] = _pyqToken;\\n        feeTokens.push(_pyqToken);\\n        \\n        _addNewAsset(\\n            _borrowingFeeToken,\\n            _redeemingFeeToken,\\n            _troveManager,\\n            _borrowerOperation,\\n            _activePool\\n        );\\n    }\\n\\n\\n    function addNewAsset(\\n        address _borrowingFeeToken,\\n        address _redeemingFeeToken,\\n        address _troveManager,\\n        address _borrowerOperation,\\n        address _activePool\\n    )\\n        external\\n        onlyOwner\\n        override\\n    {\\n        _addNewAsset(\\n            _borrowingFeeToken,\\n            _redeemingFeeToken,\\n            _troveManager,\\n            _borrowerOperation,\\n            _activePool\\n        );\\n    }\\n\\n    function _addNewAsset(\\n        address _borrowingFeeToken,\\n        address _redeemingFeeToken,\\n        address _troveManager,\\n        address _borrowerOperation,\\n        address _activePool\\n    ) internal {\\n\\n        isTM[_troveManager] = true;\\n        isBO[_borrowerOperation] = true;\\n        isAP[_activePool] = true;\\n\\n        feeTokenMap[_troveManager] = _redeemingFeeToken;\\n        feeTokenMap[_borrowerOperation] = _borrowingFeeToken;\\n\\n        feeTokens.push(_redeemingFeeToken);\\n        feeTokens.push(_borrowingFeeToken);\\n\\n        emit NewAssetTokenAddress(\\n            _troveManager, _borrowerOperation, _activePool, _redeemingFeeToken, _borrowingFeeToken\\n        );\\n    }\\n\\n    function updatePYQReward(uint _pyqRewardUnit) external onlyOwner {\\n        PYQrewardUnit = _pyqRewardUnit;\\n    }\\n\\n    function PYQRewardLeft() public view returns (uint256) {\\n        return IERC20(PYQToken).balanceOf(address(this));\\n    }\\n\\n    function updateUserStake(address[] memory _users) external override {\\n        uint rewards;\\n        \\n        uint length = _users.length;\\n        for (uint i = 0; i < length; i++) {\\n            address user = _users[i];\\n            uint256 currentStake = _stakes(user);\\n            uint256 lastStake = lastStakes[user];\\n            if (currentStake != lastStake) {\\n                _claim(user);\\n                rewards = rewards.add(PYQrewardUnit);\\n            }\\n        }\\n\\n        uint totalRewards = PYQRewardLeft();\\n        rewards = rewards < totalRewards ? rewards : totalRewards;\\n        \\n        if (rewards > 0) {\\n            SafeToken.safeTransfer(PYQToken, msg.sender, rewards);\\n        }      \\n    }\\n    \\n    function claim() external override {\\n        _claim(msg.sender);\\n    }\\n\\n    function _claim(address _user) internal {\\n        uint256 currentStake = _stakes(_user);\\n        uint256 lastStake = lastStakes[_user];\\n        \\n        if (lastStake > 0) {\\n            _sendRewards(_user);\\n        }\\n        \\n        _updateUserSnapshots(_user); \\n        \\n        if (currentStake != lastStake) {\\n            lastStakes[_user] = currentStake;\\n            emit StakerStakeUpdated(_user, currentStake);\\n        }     \\n    }\\n\\n    function _sendRewards(address _user) internal {\\n        uint feeTokenCounts = feeTokens.length;\\n        for (uint i = 0 ; i < feeTokenCounts; i++) {\\n            address feeToken = feeTokens[i];\\n            uint tokenGain = _getPendingGain(feeToken, _user);\\n            _transferOut(feeToken, _user, tokenGain);\\n            emit StakingGainsWithdrawn(_user, feeToken, tokenGain);\\n        } \\n    }\\n\\n    function _updateUserSnapshots(address _user) internal {\\n        uint feeTokenCounts = feeTokens.length;\\n        for (uint i = 0 ; i < feeTokenCounts; i++) {\\n            address feeToken = feeTokens[i];\\n            uint256 newFeePerTokenStaked = feePerTokenStaked[feeToken];\\n            snapshots[_user][feeToken] = newFeePerTokenStaked;\\n            emit StakerSnapshotsUpdated(_user, feeToken, newFeePerTokenStaked);\\n        }\\n    }\\n\\n    // --- Reward-per-unit-staked increase functions. Called by Liquity core contracts ---\\n    function increaseBorrowingFee(uint _fee) external override {\\n\\n        _requireCallerIsValidBorrowerOperations();\\n\\n        uint borrowingFeePerTokenStaked;\\n        uint totalTokenStaked = _totalLQTYStaked();\\n        address feeToken = feeTokenMap[msg.sender];\\n        \\n        if (totalTokenStaked > 0) {\\n            borrowingFeePerTokenStaked = _fee.mul(DECIMAL_PRECISION).div(totalTokenStaked);\\n        }\\n\\n        uint newFeePerTokenStaked = feePerTokenStaked[feeToken].add(borrowingFeePerTokenStaked);\\n        feePerTokenStaked[feeToken] = newFeePerTokenStaked;\\n\\n        emit TokenFeeUpdated(feeToken, _fee, newFeePerTokenStaked);\\n    }\\n\\n    function increaseRedeemingFee(uint _fee) external override {\\n        _requireCallerIsValidTroveManager();\\n\\n        uint redeemingFeePerTokenStaked;\\n        uint totalTokenStaked = _totalLQTYStaked();\\n        address feeToken = feeTokenMap[msg.sender];\\n\\n        if (totalTokenStaked > 0) {\\n            redeemingFeePerTokenStaked = _fee.mul(DECIMAL_PRECISION).div(totalTokenStaked);\\n        }\\n\\n        uint newFeePerTokenStaked = feePerTokenStaked[feeToken].add(redeemingFeePerTokenStaked);\\n        feePerTokenStaked[feeToken] = newFeePerTokenStaked;\\n\\n        emit TokenFeeUpdated(feeToken, _fee, newFeePerTokenStaked);\\n    }\\n\\n    function increaseTransferFee(uint _fee) external override {\\n\\n        _requireCallerIsStakeToken();\\n\\n        uint transferFeePerTokenStaked;\\n        uint totalTokenStaked = _totalLQTYStaked();\\n        address feeToken = feeTokenMap[msg.sender];\\n\\n        if (totalTokenStaked > 0) {\\n            transferFeePerTokenStaked = _fee.mul(DECIMAL_PRECISION).div(totalTokenStaked);\\n        }\\n\\n        uint newFeePerTokenStaked = feePerTokenStaked[feeToken].add(transferFeePerTokenStaked);\\n        feePerTokenStaked[feeToken] = newFeePerTokenStaked;\\n\\n        emit TokenFeeUpdated(feeToken, _fee, newFeePerTokenStaked);\\n    }\\n\\n    // --- Pending reward functions ---\\n\\n    function getPendingGain(address _token, address _user) external view override returns (uint) {\\n        return _getPendingGain(_token, _user);\\n    }\\n\\n    function _getPendingGain(address _token, address _user) internal view returns (uint) {\\n        uint currentStake = _stakes(_user);\\n        uint lastStake = lastStakes[_user];\\n        uint stake = currentStake < lastStake ? currentStake: lastStake;\\n        \\n        uint feePerTokenStakedSnapshot = snapshots[_user][_token];\\n        uint tokenGain = stake.mul(feePerTokenStaked[_token].sub(feePerTokenStakedSnapshot)).div(DECIMAL_PRECISION);\\n        return tokenGain;\\n    }\\n\\n    function getFeeTokens() external view returns (address[] memory) {\\n        return feeTokens;\\n    }\\n\\n    // --- PYQStaking view function --\\n\\n    function _stakes(address _user) internal view returns (uint) {\\n        return PYQStaking.stakes(_user);\\n    }\\n\\n    function _totalLQTYStaked() internal view returns (uint) {\\n        return PYQStaking.totalLQTYStaked();\\n    }\\n\\n    // --- Internal helper functions ---\\n\\n    function _transferOut(address _token, address _user, uint _amount) internal {\\n        if (_amount > 0) {\\n            if (_token == GAS_TOKEN_ADDR) {\\n                _sendETHToUser(_user, _amount);\\n            } else {\\n                SafeToken.safeTransfer(_token, _user, _amount);\\n            }\\n        }\\n    }\\n\\n    function _sendETHToUser(address _user, uint _fee) internal {\\n        emit EtherSent(_user, _fee);\\n        (bool success, ) = payable(_user).call{value: _fee}(\\\"\\\");\\n        require(success, \\\"failed to send accumulated ETH fee\\\");\\n    }\\n\\n    // --- 'require' functions ---\\n\\n    function _requireCallerIsValidBorrowerOperations() internal view {\\n        require(isBO[msg.sender], \\\"caller is not valid borrowerOperation\\\");\\n    }\\n\\n    function _requireCallerIsValidTroveManager() internal view {\\n        require(isTM[msg.sender], \\\"caller is not valid troveManager\\\");\\n    }\\n\\n    function _requireCallerIsValidActivePool() internal view {\\n        require(isAP[msg.sender], \\\"caller is not valid ActivePool\\\");\\n    }\\n\\n    function _requireCallerIsStakeToken() internal view {\\n        require(msg.sender == PYQToken, \\\"caller is not stake token\\\");\\n    }\\n\\n    function _requireNonZeroAmount(uint _amount) internal pure {\\n        require(_amount > 0, 'amount must be non-zero');\\n    }\\n\\n    function _requireUserHasStake(uint currentStake) internal pure {\\n        require(currentStake > 0, 'user must have a non-zero stake');\\n    }\\n\\n    receive() external payable {\\n        _requireCallerIsValidActivePool();\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/utils/SafeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\ninterface ERC20Interface {\\n  function balanceOf(address user) external view returns (uint256);\\n}\\n\\nlibrary SafeToken {\\n  function myBalance(address token) internal view returns (uint256) {\\n    return ERC20Interface(token).balanceOf(address(this));\\n  }\\n\\n  function balanceOf(address token, address user) internal view returns (uint256) {\\n    return ERC20Interface(token).balanceOf(user);\\n  }\\n\\n  function safeApprove(address token, address to, uint256 value) internal {\\n    // bytes4(keccak256(bytes('approve(address,uint256)')));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeApprove\\\");\\n  }\\n\\n  function safeTransfer(address token, address to, uint256 value) internal {\\n    // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeTransfer\\\");\\n  }\\n\\n  function safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n    // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeTransferFrom\\\");\\n  }\\n\\n  function safeTransferETH(address to, uint256 value) internal {\\n    // solhint-disable-next-line no-call-value\\n    (bool success, ) = to.call{value: value}(new bytes(0));\\n    require(success, \\\"!safeTransferETH\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"/contracts/Interfaces/ITokenStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\ninterface ITokenStaking {\\n\\n    // --- Events --\\n    \\n    event StakeTokenAddress(address stakeTokenAddress);\\n    event StableTokenAddress(address stableTokenAddress);\\n    \\n    event NewAssetTokenAddress(\\n        address trovemanager, address borrowerOperation, \\n        address activePool, address redeemingFeeToken, address borrowingFeeToken\\n    );\\n\\n    event StakeChanged(address indexed staker, uint newStake);\\n    event StakingGainsWithdrawn(address indexed staker, address indexed feeToken, uint gain);\\n    event totalTokenStakedUpdated(uint totalTokenStaked);\\n    event EtherSent(address account, uint amount);\\n\\n    event TokenFeeUpdated(address indexed feeToken, uint fee, uint feePerTokenStaked);\\n    event StakerSnapshotsUpdated(address staker, address token, uint feePerTokenStaked);\\n\\n    // --- Functions ---\\n\\n    function setAddresses\\n    (\\n        address _pyqStaking,\\n        address _stakeToken,\\n        address _borrowingFeeToken,\\n        address _redeemingFeeToken, \\n        address _troveManager,\\n        address _borrowerOperation,\\n        address _activaPool\\n    )  external ;\\n\\n    function addNewAsset(\\n        address _borrowingFeeToken,\\n        address _redeemingFeeToken, \\n        address _troveManager,\\n        address _borrowerOperation,\\n        address _activaPool\\n    ) external;\\n\\n\\n    function claim() external;\\n    function updateUserStake(address[] calldata _users) external;\\n    function increaseBorrowingFee(uint _fee) external; \\n    function increaseRedeemingFee(uint _fee) external;  \\n    function increaseTransferFee(uint _fee) external;  \\n    function getPendingGain(address _token, address _user) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"/contracts/Interfaces/ILQTYStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\ninterface ILQTYStaking {\\n    function stakes(address _user) external view returns (uint);\\n    function totalLQTYStaked() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"/contracts/Dependencies/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n/**\\n * Based on OpenZeppelin's SafeMath:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\\n *\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Dependencies/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n/**\\n * Based on OpenZeppelin's Ownable contract:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n *\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     *\\n     * NOTE: This function is not safe, as it doesn\u2019t check owner is calling it.\\n     * Make sure you check it before calling it.\\n     */\\n    function _renounceOwnership() internal {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Dependencies/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n/**\\n * Based on the OpenZeppelin IER20 interface:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\\n *\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    \\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"/contracts/Dependencies/BaseMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\n\\ncontract BaseMath {\\n    uint constant public DECIMAL_PRECISION = 1e18;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trovemanager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowerOperation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"activePool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"redeemingFeeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowingFeeToken\",\"type\":\"address\"}],\"name\":\"NewAssetTokenAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stableTokenAddress\",\"type\":\"address\"}],\"name\":\"StableTokenAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStake\",\"type\":\"uint256\"}],\"name\":\"StakeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakeTokenAddress\",\"type\":\"address\"}],\"name\":\"StakeTokenAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePerTokenStaked\",\"type\":\"uint256\"}],\"name\":\"StakerSnapshotsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStake\",\"type\":\"uint256\"}],\"name\":\"StakerStakeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gain\",\"type\":\"uint256\"}],\"name\":\"StakingGainsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePerTokenStaked\",\"type\":\"uint256\"}],\"name\":\"TokenFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalTokenStaked\",\"type\":\"uint256\"}],\"name\":\"totalTokenStakedUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMAL_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_TOKEN_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PYQRewardLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PYQStaking\",\"outputs\":[{\"internalType\":\"contract ILQTYStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PYQToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PYQrewardUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrowingFeeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_redeemingFeeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_troveManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowerOperation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_activePool\",\"type\":\"address\"}],\"name\":\"addNewAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feePerTokenStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeTokenMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getPendingGain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"increaseBorrowingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"increaseRedeemingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"increaseTransferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBO\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTM\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pyqStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pyqToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowingFeeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_redeemingFeeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_troveManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowerOperation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_activePool\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"snapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pyqRewardUnit\",\"type\":\"uint256\"}],\"name\":\"updatePYQReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"updateUserStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ClaimAndUpdate", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}