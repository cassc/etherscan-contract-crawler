{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ITest1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface ITest1 {\\r\\n    function getBaseProvider(address token) external view returns (address);\\r\\n\\r\\n    function getRandomProvider(address token, uint256 randomWord) external returns (address);\\r\\n\\r\\n    function getUserBalance(address account, address token) external view returns (uint256);\\r\\n\\r\\n    function getTotalFunds(address token) external view returns (uint256);\\r\\n\\r\\n    function getUserTips(address account, address token) external view returns (uint256);\\r\\n\\r\\n    function getTotalUserTips(address token) external view returns (uint256);\\r\\n\\r\\n    function getUserStaked(address account, address token) external view returns (uint256);\\r\\n\\r\\n    function getTotalStakes(address token) external view returns (uint256);\\r\\n\\r\\n    function getDepositerHLBalance(address depositer, address token) external view returns (uint256);\\r\\n\\r\\n    function getTotalHL(address token) external view returns (uint256);\\r\\n\\r\\n    function getProviderPayout(address account, address token) external view returns (uint256);\\r\\n\\r\\n    function getTotalPayout(address token) external view returns (uint256);\\r\\n\\r\\n    function getBalancedStatus(address token) external view returns (bool);\\r\\n\\r\\n    function setCoreOwnership(address newOwner) external;\\r\\n\\r\\n    function disableCoreOwnership(address owwner) external;\\r\\n\\r\\n    function setTrustedForwarder(address trustedForwarder) external;\\r\\n\\r\\n    function addTokens(address token) external;\\r\\n\\r\\n    function disableToken(address token) external;\\r\\n\\r\\n    function setBaseProvider(address account, address token) external;\\r\\n\\r\\n    function handleBalance(address bettor, address token, uint256 amount, uint256 operator) external;\\r\\n\\r\\n    function handleUserTips(address bettor, address token, uint256 amount, uint256 operator) external;\\r\\n\\r\\n    function handleStakes(address bettor, address token, uint256 amount, uint256 operator) external;\\r\\n\\r\\n    function handleHL(address bettor, address token, uint256 amount, uint256 operator) external;\\r\\n\\r\\n    function handlePayout(address bettor, address token, uint256 amount, uint256 operator) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Test4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"./ITest1.sol\\\";\\r\\n\\r\\ncontract Test4 is ReentrancyGuard {\\r\\n    /* Type Declarations */\\r\\n    enum BetStatus {\\r\\n        Active, //0\\r\\n        Loss, //1\\r\\n        Win, //2\\r\\n        Suspended //3\\r\\n    }\\r\\n\\r\\n    struct BetSlip {\\r\\n        bytes32 betkey;\\r\\n        address bettor;\\r\\n        address token;\\r\\n        uint256 totalStake;\\r\\n        uint256 totalPayout;\\r\\n        address provider;\\r\\n        bytes32 odds;\\r\\n        bytes32 stake;\\r\\n        bytes32 payout;\\r\\n    }\\r\\n\\r\\n    /* State Variables */\\r\\n\\r\\n    /* Ops Contract Variables */\\r\\n\\r\\n    address private s_opsOwner;\\r\\n    ITest1 private immutable i_core;\\r\\n    uint256 private s_randomWord;\\r\\n    bool private betAllowed = true;\\r\\n\\r\\n    mapping(bytes32 => bool) private s_placeBetKey;\\r\\n    mapping(address => bool) private s_settleSigner;\\r\\n\\r\\n    mapping(bytes32 => BetSlip) private s_keyToBetSlip;\\r\\n    mapping(bytes32 => mapping(uint8 => bool)) private isSettled;\\r\\n\\r\\n    event TransferOpsOwnership(address indexed oldOwner, address indexed newOwner);\\r\\n\\r\\n    event BetPlaced(bytes32 indexed betkey, address indexed bettor, address indexed token, uint256 totalStake, uint256 totalPayout, bytes32 odds, bytes32 stake, bytes32 payout);\\r\\n\\r\\n    event BetSettled(bytes32 indexed betkey, uint8 indexed betOrder, address indexed bettor, address token, BetStatus BetStatus, bytes32 odds, uint256 stake, uint256 payout);\\r\\n\\r\\n    // mapping(uint256 => address) private betIdToProvider;\\r\\n\\r\\n    constructor(address owner, address payable core) {\\r\\n        s_opsOwner = owner;\\r\\n        i_core = ITest1(core);\\r\\n    }\\r\\n\\r\\n    modifier onlyOpsOwner() {\\r\\n        if (msg.sender != s_opsOwner) {\\r\\n            revert(\\\"Operations__OnlyOwnerMethod\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlySettleSigner() {\\r\\n        if (!s_settleSigner[msg.sender]) {\\r\\n            revert(\\\"Operations__OnlySignerMethod\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier isBetAllowed() {\\r\\n        if (!betAllowed) {\\r\\n            revert(\\\"Bets Disabled\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /* State Changing Methods */\\r\\n    function transferOpsOwnership(address _newOwner) public onlyOpsOwner {\\r\\n        _transferOpsOwnership(_newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOpsOwnership(address _newOwner) internal {\\r\\n        require(_newOwner != address(0), \\\"Incorect address\\\");\\r\\n        address oldOwner = s_opsOwner;\\r\\n        s_opsOwner = _newOwner;\\r\\n        emit TransferOpsOwnership(oldOwner, _newOwner);\\r\\n    }\\r\\n\\r\\n    function setCoreOwnershipInOps(address newOwner) public onlyOpsOwner {\\r\\n        i_core.setCoreOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function disableCoreOwnershipInOps(address owner) public onlyOpsOwner {\\r\\n        i_core.disableCoreOwnership(owner);\\r\\n    }\\r\\n\\r\\n    function setCoreTrustedForwarder(address trustedForwarder) public onlyOpsOwner {\\r\\n        i_core.setTrustedForwarder(trustedForwarder);\\r\\n    }\\r\\n\\r\\n    function addTokensToCore(address token) public onlyOpsOwner {\\r\\n        i_core.addTokens(token);\\r\\n    }\\r\\n\\r\\n    function disableCoreToken(address token) public onlyOpsOwner {\\r\\n        i_core.disableToken(token);\\r\\n    }\\r\\n\\r\\n    function setBaseProviderInCore(address account, address token) public onlyOpsOwner {\\r\\n        i_core.setBaseProvider(account, token);\\r\\n    }\\r\\n\\r\\n    function setSettleSigner(address account, bool status) public onlyOpsOwner {\\r\\n        s_settleSigner[account] = status;\\r\\n    }\\r\\n\\r\\n    function modifyAllowBet(bool status) public onlyOpsOwner {\\r\\n        betAllowed = status;\\r\\n    }\\r\\n\\r\\n    function placeBet(address token, uint256 totalStake, uint256 totalPayout, bytes32[4] calldata betDetails, uint256[2] calldata operator) public nonReentrant isBetAllowed {\\r\\n        address provider = i_core.getBaseProvider(token);\\r\\n        uint256 tips = i_core.getUserTips(msg.sender, token);\\r\\n        uint256 bal = i_core.getUserBalance(msg.sender, token);\\r\\n        uint256 tipsToSubtract;\\r\\n        if (s_placeBetKey[betDetails[3]] == true) revert(\\\"Operations__BetKeyUsed\\\");\\r\\n        if (totalPayout > i_core.getTotalHL(token)) revert(\\\"Operations__InsufficientHL\\\");\\r\\n        if (totalPayout > i_core.getDepositerHLBalance(provider, token)) revert(\\\"Insuffcient House Liquidity\\\");\\r\\n        if (totalStake > tips + bal) revert(\\\"Operations__StakeMorethanbal\\\");\\r\\n        s_placeBetKey[betDetails[3]] = true;\\r\\n        s_keyToBetSlip[betDetails[3]] = BetSlip(betDetails[3], msg.sender, token, totalStake, totalPayout, provider, betDetails[0], betDetails[1], betDetails[2]);\\r\\n        emit BetPlaced(betDetails[3], msg.sender, token, totalStake, totalPayout, betDetails[0], betDetails[1], betDetails[2]);\\r\\n        if (tips > 0) {\\r\\n            tipsToSubtract = (tips >= totalStake) ? totalStake : tips;\\r\\n            uint256 stakeLeft = totalStake - tipsToSubtract;\\r\\n            i_core.handleUserTips(msg.sender, token, tipsToSubtract, 0);\\r\\n            if (stakeLeft > 0) i_core.handleBalance(msg.sender, token, stakeLeft, 0);\\r\\n        } else {\\r\\n            i_core.handleBalance(msg.sender, token, totalStake, 0);\\r\\n        }\\r\\n        i_core.handleStakes(msg.sender, token, totalStake, 1);\\r\\n        i_core.handleHL(provider, token, totalPayout, operator[0]);\\r\\n        i_core.handlePayout(provider, token, totalPayout, operator[1]);\\r\\n        if (!i_core.getBalancedStatus(token)) revert(\\\"Operations__ContractIsNotBalanced\\\");\\r\\n    }\\r\\n\\r\\n    // function placeBet(address token, uint256 totalStake, uint256 totalPayout, bytes32[4] calldata betDetails, bool[4] calldata controls, uint256[2] calldata operator, bool callOracle) public {\\r\\n    //     if (s_placeBetKey[betDetails[3]] == true) revert(\\\"Operations__BetKeyUsed\\\");\\r\\n    //     if (totalPayout > i_core.getTotalHL(token)) revert(\\\"Operations__InsufficientHL\\\");\\r\\n    //     address provider = i_core.getBaseProvider(token);\\r\\n    //     require(totalPayout <= i_core.getDepositerHLBalance(provider, token), \\\"Insuffcient House Liquidity\\\");\\r\\n    //     s_placeBetKey[betDetails[3]] = true;\\r\\n    //     if (controls[0]) {\\r\\n    //         if (totalStake <= i_core.getUserTips(msg.sender, token)) {\\r\\n    //             i_core.handleUserTips(msg.sender, token, totalStake, 0);\\r\\n    //         } else {\\r\\n    //             if (totalStake > i_core.getUserBalance(msg.sender, token)) revert(\\\"Operations__StakeMorethanbal\\\");\\r\\n    //             i_core.handleBalance(msg.sender, token, totalStake, 0);\\r\\n    //         }\\r\\n    //     }\\r\\n    //     if (controls[1]) i_core.handleStakes(msg.sender, token, totalStake, 1);\\r\\n    //     if (controls[2]) i_core.handleHL(provider, token, totalPayout, operator[0]);\\r\\n    //     if (controls[3]) i_core.handlePayout(provider, token, totalPayout, operator[1]);\\r\\n    //     if (!i_core.getBalancedStatus(token)) revert(\\\"Operations__ContractIsNotBalanced\\\");\\r\\n    //     s_keyToBetSlip[betDetails[3]] = BetSlip(betDetails[3], msg.sender, token, totalStake, totalPayout, provider, betDetails[0], betDetails[1], betDetails[2]);\\r\\n    //     emit BetPlaced(betDetails[3], msg.sender, token, totalStake, totalPayout, betDetails[0], betDetails[1], betDetails[2]);\\r\\n    // }\\r\\n\\r\\n    function handleLoss(bytes32 betkey, uint8 betOrder, uint256 stake, uint256 payout, uint256 hl, bytes32 odds, bool[3] calldata controls, uint256[2] calldata operators) public onlySettleSigner {\\r\\n        BetSlip storage betSlip = s_keyToBetSlip[betkey];\\r\\n        if (betkey != betSlip.betkey || betkey == 0) revert(\\\"Operations__InvalidBetId\\\");\\r\\n        if (isSettled[betkey][betOrder] == true) revert(\\\"Already settled\\\");\\r\\n        if (stake > i_core.getUserStaked(betSlip.bettor, betSlip.token)) revert(\\\"Operations__InsufficentStakes\\\");\\r\\n        if (stake > i_core.getTotalStakes(betSlip.token)) revert(\\\"Operations__InsufficentStakes\\\");\\r\\n        if (payout > i_core.getProviderPayout(betSlip.provider, betSlip.token)) revert(\\\"Operations__InsufficentPayouts\\\");\\r\\n        if (payout > i_core.getTotalPayout(betSlip.token)) revert(\\\"Operations__InsufficentPayouts\\\");\\r\\n        isSettled[betkey][betOrder] = true;\\r\\n        emit BetSettled(betSlip.betkey, betOrder, betSlip.bettor, betSlip.token, BetStatus.Loss, odds, stake, payout);\\r\\n        if (controls[0]) i_core.handleStakes(betSlip.bettor, betSlip.token, stake, 0);\\r\\n        if (controls[1]) i_core.handleHL(betSlip.provider, betSlip.token, hl, operators[0]);\\r\\n        if (controls[2]) i_core.handlePayout(betSlip.provider, betSlip.token, payout, operators[1]);\\r\\n        if (!i_core.getBalancedStatus(betSlip.token)) revert(\\\"Operations__ContractIsNotBalanced\\\");\\r\\n    }\\r\\n\\r\\n    function handleWin(bytes32 betkey, uint8 betOrder, uint256 stake, uint256 payout, bytes32 odds) public onlySettleSigner {\\r\\n        BetSlip storage betSlip = s_keyToBetSlip[betkey];\\r\\n        if (betkey != betSlip.betkey || betkey == 0) revert(\\\"Operations__InvalidBetId\\\");\\r\\n        if (isSettled[betkey][betOrder] == true) revert(\\\"Already settled\\\");\\r\\n        if (stake > i_core.getUserStaked(betSlip.bettor, betSlip.token)) revert(\\\"Operations__InsufficentStakes\\\");\\r\\n        if (stake > i_core.getTotalStakes(betSlip.token)) revert(\\\"Operations__InsufficentStakes\\\");\\r\\n        if (payout > i_core.getProviderPayout(betSlip.provider, betSlip.token)) revert(\\\"Operations__InsufficentPayouts\\\");\\r\\n        if (payout > i_core.getTotalPayout(betSlip.token)) revert(\\\"Operations__InsufficentPayouts\\\");\\r\\n        isSettled[betkey][betOrder] = true;\\r\\n        emit BetSettled(betSlip.betkey, betOrder, betSlip.bettor, betSlip.token, BetStatus.Win, odds, stake, payout);\\r\\n        i_core.handleBalance(betSlip.bettor, betSlip.token, stake + payout, 1);\\r\\n        i_core.handleStakes(betSlip.bettor, betSlip.token, stake, 0);\\r\\n        i_core.handlePayout(betSlip.provider, betSlip.token, payout, 0);\\r\\n        if (!i_core.getBalancedStatus(betSlip.token)) revert(\\\"Operations__ContractIsNotBalanced\\\");\\r\\n    }\\r\\n\\r\\n    function handleSuspension(\\r\\n        bytes32 betkey,\\r\\n        uint8 betOrder,\\r\\n        uint256 stake,\\r\\n        uint256 hl,\\r\\n        uint256 payout,\\r\\n        bytes32 odds,\\r\\n        bool[2] calldata controls,\\r\\n        uint256[2] calldata operators\\r\\n    ) public onlySettleSigner {\\r\\n        BetSlip storage betSlip = s_keyToBetSlip[betkey];\\r\\n        if (betkey != betSlip.betkey || betkey == 0) revert(\\\"Operations__InvalidBetId\\\");\\r\\n        if (isSettled[betkey][betOrder] == true) revert(\\\"Already settled\\\");\\r\\n        if (stake > i_core.getUserStaked(betSlip.bettor, betSlip.token)) revert(\\\"Operations__InsufficentStakes\\\");\\r\\n        if (stake > i_core.getTotalStakes(betSlip.token)) revert(\\\"Operations__InsufficentStakes\\\");\\r\\n        isSettled[betkey][betOrder] = true;\\r\\n        emit BetSettled(betSlip.betkey, betOrder, betSlip.bettor, betSlip.token, BetStatus.Suspended, odds, stake, payout);\\r\\n        i_core.handleBalance(betSlip.bettor, betSlip.token, stake, 1);\\r\\n        i_core.handleStakes(betSlip.bettor, betSlip.token, stake, 0);\\r\\n        if (controls[0]) {\\r\\n            if (payout > i_core.getProviderPayout(betSlip.provider, betSlip.token)) revert(\\\"Operations__InsufficentPayouts\\\");\\r\\n            if (payout > i_core.getTotalPayout(betSlip.token)) revert(\\\"Operations__InsufficentPayouts\\\");\\r\\n            i_core.handleHL(betSlip.provider, betSlip.token, hl, operators[0]); //1\\r\\n        }\\r\\n        if (controls[1]) {\\r\\n            if (payout > i_core.getProviderPayout(betSlip.provider, betSlip.token)) revert(\\\"Operations__InsufficentPayouts\\\");\\r\\n            if (payout > i_core.getTotalPayout(betSlip.token)) revert(\\\"Operations__InsufficentPayouts\\\");\\r\\n            i_core.handlePayout(betSlip.provider, betSlip.token, payout, operators[1]); //0\\r\\n        }\\r\\n        if (!i_core.getBalancedStatus(betSlip.token)) {\\r\\n            revert(\\\"Operations__ContractIsNotBalanced\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*Gettor Functions */\\r\\n    function getOpsOwner() public view returns (address) {\\r\\n        return s_opsOwner;\\r\\n    }\\r\\n\\r\\n    function getSettleSigner(address setlleSigner) public view returns (bool) {\\r\\n        return (s_settleSigner[setlleSigner]);\\r\\n    }\\r\\n\\r\\n    function getBet(bytes32 betkey) public view returns (BetSlip memory) {\\r\\n        return s_keyToBetSlip[betkey];\\r\\n    }\\r\\n\\r\\n    function getIsSettled(bytes32 betkey, uint8 betOrder) public view returns (bool) {\\r\\n        return isSettled[betkey][betOrder];\\r\\n    }\\r\\n\\r\\n    function getIsBetAllowed() public view returns (bool) {\\r\\n        return betAllowed;\\r\\n    }\\r\\n}\\r\\n\\r\\n///\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"core\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"betkey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bettor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"odds\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"stake\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"payout\",\"type\":\"bytes32\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"betkey\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"betOrder\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bettor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Test4.BetStatus\",\"name\":\"BetStatus\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"odds\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"BetSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"TransferOpsOwnership\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addTokensToCore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"disableCoreOwnershipInOps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"disableCoreToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"betkey\",\"type\":\"bytes32\"}],\"name\":\"getBet\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"betkey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"bettor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayout\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"odds\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"stake\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"payout\",\"type\":\"bytes32\"}],\"internalType\":\"struct Test4.BetSlip\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIsBetAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"betkey\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"betOrder\",\"type\":\"uint8\"}],\"name\":\"getIsSettled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpsOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"setlleSigner\",\"type\":\"address\"}],\"name\":\"getSettleSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"betkey\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"betOrder\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hl\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"odds\",\"type\":\"bytes32\"},{\"internalType\":\"bool[3]\",\"name\":\"controls\",\"type\":\"bool[3]\"},{\"internalType\":\"uint256[2]\",\"name\":\"operators\",\"type\":\"uint256[2]\"}],\"name\":\"handleLoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"betkey\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"betOrder\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"odds\",\"type\":\"bytes32\"},{\"internalType\":\"bool[2]\",\"name\":\"controls\",\"type\":\"bool[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"operators\",\"type\":\"uint256[2]\"}],\"name\":\"handleSuspension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"betkey\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"betOrder\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"odds\",\"type\":\"bytes32\"}],\"name\":\"handleWin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"modifyAllowBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayout\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[4]\",\"name\":\"betDetails\",\"type\":\"bytes32[4]\"},{\"internalType\":\"uint256[2]\",\"name\":\"operator\",\"type\":\"uint256[2]\"}],\"name\":\"placeBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setBaseProviderInCore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setCoreOwnershipInOps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trustedForwarder\",\"type\":\"address\"}],\"name\":\"setCoreTrustedForwarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setSettleSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOpsOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Test4", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000b8d69eabe08648abc51d3c2156fe0930362bec620000000000000000000000007c401171b160021d40f38bd87d14c0aa6de0eae8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}