{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DotCoinBurner.sol\": {\r\n      \"content\": \"// @author Unstoppable Domains, Inc.\\n// @date October 26th, 2022\\n\\npragma solidity ^0.8.0;\\n\\nimport './IUNSRegistry.sol';\\n\\ncontract DotCoinBurner {\\n    /**\\n     * @dev .coin tld namehash\\n     *\\n     * `namehash` = uint256(keccak256(abi.encodePacked(uint256(0x0), keccak256(abi.encodePacked('coin')))))\\n     */\\n    uint256 private constant _DOT_COIN_TLD = 0x7674e7282552c15f203b9c4a6025aeaf28176ef7f5451b280f9bada3f8bc98e2;\\n    address private constant _BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\\n    IUNSRegistry private immutable _unsRegistry;\\n\\n    event BatchCompleted(uint256 indexed first, uint256 indexed last);\\n\\n    constructor(IUNSRegistry unsRegistry) {\\n        _unsRegistry = unsRegistry;\\n    }\\n\\n    function burnAll(uint256[] calldata labelHashes) external {\\n        for (uint256 i = 0; i < labelHashes.length; i++) {\\n            uint256 tokenId = uint256(keccak256(abi.encode(_DOT_COIN_TLD, labelHashes[i])));\\n            _unsRegistry.transferFrom(_unsRegistry.ownerOf(tokenId), _BURN_ADDRESS, tokenId);\\n        }\\n\\n        if (labelHashes.length > 0) {\\n            emit BatchCompleted(\\n                uint256(keccak256(abi.encode(_DOT_COIN_TLD, labelHashes[0]))),\\n                uint256(keccak256(abi.encode(_DOT_COIN_TLD, labelHashes[labelHashes.length - 1])))\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IUNSRegistry.sol\": {\r\n      \"content\": \"// @author Unstoppable Domains, Inc.\\n// @date June 16th, 2021\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol';\\n\\nimport './IERC1967.sol';\\nimport './IRecordStorage.sol';\\nimport './IReverseRegistry.sol';\\nimport './IRootRegistry.sol';\\nimport './IChildRegistry.sol';\\n\\ninterface IUNSRegistry is\\n    IERC1967,\\n    IERC721MetadataUpgradeable,\\n    IERC721ReceiverUpgradeable,\\n    IRecordStorage,\\n    IReverseRegistry,\\n    IRootRegistry,\\n    IChildRegistry\\n{\\n    event NewURI(uint256 indexed tokenId, string uri);\\n\\n    event NewURIPrefix(string prefix);\\n\\n    /**\\n     * @dev Function to set the token URI Prefix for all tokens.\\n     * @param prefix string URI to assign\\n     */\\n    function setTokenURIPrefix(string calldata prefix) external;\\n\\n    /**\\n     * @dev Returns whether the given spender can transfer a given token ID.\\n     * @param spender address of the spender to query\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @return bool whether the msg.sender is approved for the given token ID,\\n     * is an operator of the owner, or is the owner of the token\\n     */\\n    function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\\n\\n    /**\\n     * @dev Gets the resolver of the specified token ID.\\n     * @param tokenId uint256 ID of the token to query the resolver of\\n     * @return address currently marked as the resolver of the given token ID\\n     */\\n    function resolverOf(uint256 tokenId) external view returns (address);\\n\\n    /**\\n     * @dev Provides namehashe of the provided domain labels.\\n     * @param labels array of domain labels splitted by '.' (for `aaa.bbb.crypto` it will be [`aaa`, `bbb`, `crypto`])\\n     */\\n    function namehash(string[] calldata labels) external pure returns (uint256);\\n\\n    /**\\n     * @dev Existence of token.\\n     * @param tokenId uint256 ID of the token\\n     */\\n    function exists(uint256 tokenId) external view override returns (bool);\\n\\n    /**\\n     * @dev Transfer domain ownership without resetting domain records.\\n     * @param to address of new domain owner\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function setOwner(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) external;\\n\\n    /**\\n     * @dev Mints root token.\\n     * @param tokenId id of TLD token.\\n     * @param uri TLD URI.\\n     */\\n    function mintTLD(uint256 tokenId, string calldata uri) external;\\n\\n    /**\\n     * @dev mints token with records\\n     * @param to address to mint the new SLD or subdomain to\\n     * @param labels array of SLD or subdomain name labels splitted by '.' to mint.\\n     * @param keys New record keys\\n     * @param values New record values\\n     */\\n    function mintWithRecords(\\n        address to,\\n        string[] calldata labels,\\n        string[] calldata keys,\\n        string[] calldata values\\n    ) external;\\n\\n    /**\\n     * @dev unlock token with records\\n     * @param to address to unlock the token to\\n     * @param tokenId id of the token.\\n     * @param keys New record keys\\n     * @param values New record values\\n     */\\n    function unlockWithRecords(\\n        address to,\\n        uint256 tokenId,\\n        string[] calldata keys,\\n        string[] calldata values\\n    ) external;\\n\\n    /**\\n     * @dev Stores CNS registry address.\\n     * It's one-time operation required to set CNS registry address.\\n     * UNS registry allows to receive ERC721 tokens only from CNS registry,\\n     * by supporting ERC721Receiver interface.\\n     * @param registry address of CNS registry contract\\n     */\\n    function setCNSRegistry(address registry) external;\\n\\n    /**\\n     * @dev Adds ProxyReader address\\n     * @param addr address of ProxyReader\\n     */\\n    function addProxyReader(address addr) external;\\n\\n    /**\\n     * @dev Marks tokens as upgraded.\\n     * @param tokenIds[] list of tokenIds to mark upgraded\\n     */\\n    function upgradeAll(uint256[] calldata tokenIds) external;\\n\\n    /**\\n     * @dev Burn TLD tokens.\\n     * @param tokenId TLD tokenId to burn\\n     */\\n    function burnTLDL1(uint256 tokenId) external;\\n\\n    /**\\n     * @dev Burn TLD tokens.\\n     * @param tokenId TLD tokenId to burn\\n     */\\n    function moveTLDOwnershipL2(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IERC1967.sol\": {\r\n      \"content\": \"// @author Unstoppable Domains, Inc.\\n// @date December 22nd, 2021\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n}\\n\"\r\n    },\r\n    \"contracts/IRecordStorage.sol\": {\r\n      \"content\": \"// @author Unstoppable Domains, Inc.\\n// @date June 16th, 2021\\n\\npragma solidity ^0.8.0;\\n\\nimport './IRecordReader.sol';\\n\\ninterface IRecordStorage is IRecordReader {\\n    event Set(uint256 indexed tokenId, string indexed keyIndex, string indexed valueIndex, string key, string value);\\n\\n    event NewKey(uint256 indexed tokenId, string indexed keyIndex, string key);\\n\\n    event ResetRecords(uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Set record by key\\n     * @param key The key set the value of\\n     * @param value The value to set key to\\n     * @param tokenId ERC-721 token id to set\\n     */\\n    function set(\\n        string calldata key,\\n        string calldata value,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Set records by keys\\n     * @param keys The keys set the values of\\n     * @param values Records values\\n     * @param tokenId ERC-721 token id of the domain\\n     */\\n    function setMany(\\n        string[] memory keys,\\n        string[] memory values,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Set record by key hash\\n     * @param keyHash The key hash set the value of\\n     * @param value The value to set key to\\n     * @param tokenId ERC-721 token id to set\\n     */\\n    function setByHash(\\n        uint256 keyHash,\\n        string calldata value,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Set records by key hashes\\n     * @param keyHashes The key hashes set the values of\\n     * @param values Records values\\n     * @param tokenId ERC-721 token id of the domain\\n     */\\n    function setManyByHash(\\n        uint256[] calldata keyHashes,\\n        string[] calldata values,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Reset all domain records and set new ones\\n     * @param keys New record keys\\n     * @param values New record values\\n     * @param tokenId ERC-721 token id of the domain\\n     */\\n    function reconfigure(\\n        string[] memory keys,\\n        string[] memory values,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Function to reset all existing records on a domain.\\n     * @param tokenId ERC-721 token id to set.\\n     */\\n    function reset(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IReverseRegistry.sol\": {\r\n      \"content\": \"// @author Unstoppable Domains, Inc.\\n// @date March 29th, 2022\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Reverse registry interface\\n */\\ninterface IReverseRegistry {\\n    /**\\n     * @dev Emitted when the reverse record is set.\\n     */\\n    event SetReverse(address indexed addr, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when the reverse record is removed.\\n     */\\n    event RemoveReverse(address indexed addr);\\n\\n    /**\\n     * @dev Sets the reverse record associated with the calling account.\\n     * @param tokenId The token to set for this address.\\n     */\\n    function setReverse(uint256 tokenId) external;\\n\\n    /**\\n     * @dev Removes the reverse record associated with the calling account.\\n     */\\n    function removeReverse() external;\\n\\n    /**\\n     * @dev Returns the reverse record for a given account's reverse record.\\n     * @param addr The address of the reverse record.\\n     * @return tokenId The token associated with the address.\\n     */\\n    function reverseOf(address addr) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/IRootRegistry.sol\": {\r\n      \"content\": \"// @author Unstoppable Domains, Inc.\\n// @date December 21st, 2021\\n\\npragma solidity ^0.8.0;\\n\\nimport './@maticnetwork/IMintableERC721.sol';\\n\\ninterface IRootRegistry is IMintableERC721 {\\n    /**\\n     * @dev Stores RootChainManager address.\\n     * It's one-time operation required to set RootChainManager address.\\n     * RootChainManager is a contract responsible for bridging Ethereum\\n     * and Polygon networks.\\n     * @param rootChainManager address of RootChainManager contract\\n     */\\n    function setRootChainManager(address rootChainManager) external;\\n\\n    /**\\n     * @dev Deposits token to Polygon through RootChainManager contract.\\n     * @param tokenId id of token\\n     */\\n    function depositToPolygon(uint256 tokenId) external;\\n\\n    /**\\n     * @dev Exit from Polygon through RootChainManager contract.\\n     *      It withdraws token with records update.\\n     * @param tokenId id of token\\n     * @param keys New record keys\\n     * @param values New record values\\n     */\\n    function withdrawFromPolygon(\\n        bytes calldata inputData,\\n        uint256 tokenId,\\n        string[] calldata keys,\\n        string[] calldata values\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IChildRegistry.sol\": {\r\n      \"content\": \"// @author Unstoppable Domains, Inc.\\n// @date December 21st, 2021\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\\n\\nimport './@maticnetwork/IChildToken.sol';\\n\\ninterface IChildRegistry is IERC721Upgradeable, IChildToken {\\n    event WithdrawnBatch(address indexed user, uint256[] tokenIds);\\n\\n    /**\\n     * @notice called when user wants to withdraw token back to root chain\\n     * @dev Should handle withraw by burning user's token.\\n     * This transaction will be verified when exiting on root chain\\n     * @param tokenId tokenId to withdraw\\n     */\\n    function withdraw(uint256 tokenId) external;\\n\\n    /**\\n     * @notice called when user wants to withdraw multiple tokens back to root chain\\n     * @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\\n     * @param tokenIds tokenId list to withdraw\\n     */\\n    function withdrawBatch(uint256[] calldata tokenIds) external;\\n\\n    /**\\n     * @notice called when user wants to withdraw token back to root chain with token URI\\n     * @dev Should handle withraw by burning user's token.\\n     * This transaction will be verified when exiting on root chain\\n     * @param tokenId tokenId to withdraw\\n     */\\n    function withdrawWithMetadata(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/IRecordReader.sol\": {\r\n      \"content\": \"// @author Unstoppable Domains, Inc.\\n// @date June 16th, 2021\\n\\npragma solidity ^0.8.0;\\n\\ninterface IRecordReader {\\n    /**\\n     * @dev Function to get record.\\n     * @param key The key to query the value of.\\n     * @param tokenId The token id to fetch.\\n     * @return The value string.\\n     */\\n    function get(string calldata key, uint256 tokenId) external view returns (string memory);\\n\\n    /**\\n     * @dev Function to get multiple record.\\n     * @param keys The keys to query the value of.\\n     * @param tokenId The token id to fetch.\\n     * @return The values.\\n     */\\n    function getMany(string[] calldata keys, uint256 tokenId) external view returns (string[] memory);\\n\\n    /**\\n     * @dev Function get value by provied key hash.\\n     * @param keyHash The key to query the value of.\\n     * @param tokenId The token id to set.\\n     */\\n    function getByHash(uint256 keyHash, uint256 tokenId) external view returns (string memory key, string memory value);\\n\\n    /**\\n     * @dev Function get values by provied key hashes.\\n     * @param keyHashes The key to query the value of.\\n     * @param tokenId The token id to set.\\n     */\\n    function getManyByHash(uint256[] calldata keyHashes, uint256 tokenId)\\n        external\\n        view\\n        returns (string[] memory keys, string[] memory values);\\n}\\n\"\r\n    },\r\n    \"contracts/@maticnetwork/IMintableERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\\n\\ninterface IMintableERC721 is IERC721Upgradeable {\\n    /**\\n     * @notice called by predicate contract to mint tokens while withdrawing\\n     * @dev Should be callable only by MintableERC721Predicate\\n     * Make sure minting is done only by this function\\n     * @param user user address for whom token is being minted\\n     * @param tokenId tokenId being minted\\n     */\\n    function mint(address user, uint256 tokenId) external;\\n\\n    /**\\n     * @notice called by predicate contract to mint tokens while withdrawing with metadata from L2\\n     * @dev Should be callable only by MintableERC721Predicate\\n     * Make sure minting is only done either by this function/ \ud83d\udc46\\n     * @param user user address for whom token is being minted\\n     * @param tokenId tokenId being minted\\n     * @param metaData Associated token metadata, to be decoded & set using `setTokenMetadata`\\n     */\\n    function mint(address user, uint256 tokenId, bytes calldata metaData) external;\\n\\n    /**\\n     * @notice check if token already exists, return true if it does exist\\n     * @dev this check will be used by the predicate to determine if the token needs to be minted or transfered\\n     * @param tokenId tokenId being checked\\n     */\\n    function exists(uint256 tokenId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/@maticnetwork/IChildToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface IChildToken {\\n    /**\\n     * @notice called when token is deposited on root chain\\n     * @dev Should be callable only by ChildChainManager\\n     * Should handle deposit by minting the required tokenId for user\\n     * Make sure minting is done only by this function\\n     * @param user user address for whom deposit is being done\\n     * @param depositData abi encoded tokenId\\n     */\\n    function deposit(address user, bytes calldata depositData) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IUNSRegistry\",\"name\":\"unsRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"first\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"last\",\"type\":\"uint256\"}],\"name\":\"BatchCompleted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"labelHashes\",\"type\":\"uint256[]\"}],\"name\":\"burnAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DotCoinBurner", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a9a6a3626993d487d2dbda3173cf58ca1a9d9e9f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}