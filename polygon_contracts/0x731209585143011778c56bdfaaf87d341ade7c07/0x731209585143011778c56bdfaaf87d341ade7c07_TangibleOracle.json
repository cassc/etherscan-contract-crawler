{"SourceCode": "// File: @chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface AutomationCompatibleInterface {\r\n  /**\r\n   * @notice method that is simulated by the keepers to see if any work actually\r\n   * needs to be performed. This method does does not actually need to be\r\n   * executable, and since it is only ever simulated it can consume lots of gas.\r\n   * @dev To ensure that it is never called, you may want to add the\r\n   * cannotExecute modifier from KeeperBase to your implementation of this\r\n   * method.\r\n   * @param checkData specified in the upkeep registration so it is always the\r\n   * same for a registered upkeep. This can easily be broken down into specific\r\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\r\n   * same contract and easily differentiated by the contract.\r\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\r\n   * performUpkeep or not.\r\n   * @return performData bytes that the keeper should call performUpkeep with, if\r\n   * upkeep is needed. If you would like to encode data to decode later, try\r\n   * `abi.encode`.\r\n   */\r\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\r\n\r\n  /**\r\n   * @notice method that is actually executed by the keepers, via the registry.\r\n   * The data returned by the checkUpkeep simulation will be passed into\r\n   * this method to actually be executed.\r\n   * @dev The input to this method should not be trusted, and the caller of the\r\n   * method should not even be restricted to any single registry. Anyone should\r\n   * be able call it, and the input should be validated, there is no guarantee\r\n   * that the data passed in is the performData returned from checkUpkeep. This\r\n   * could happen due to malicious keepers, racing keepers, or simply a state\r\n   * change while the performUpkeep transaction is waiting for confirmation.\r\n   * Always validate the data passed in.\r\n   * @param performData is the data which was passed back from the checkData\r\n   * simulation. If it is encoded, it can easily be decoded into other types by\r\n   * calling `abi.decode`. This data should not be trusted, and should be\r\n   * validated against the contract's current state.\r\n   */\r\n  function performUpkeep(bytes calldata performData) external;\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface OwnableInterface {\r\n  function owner() external returns (address);\r\n\r\n  function transferOwnership(address recipient) external;\r\n\r\n  function acceptOwnership() external;\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\r\n  address private s_owner;\r\n  address private s_pendingOwner;\r\n\r\n  event OwnershipTransferRequested(address indexed from, address indexed to);\r\n  event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n  constructor(address newOwner, address pendingOwner) {\r\n    require(newOwner != address(0), \"Cannot set owner to zero\");\r\n\r\n    s_owner = newOwner;\r\n    if (pendingOwner != address(0)) {\r\n      _transferOwnership(pendingOwner);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an owner to begin transferring ownership to a new address,\r\n   * pending.\r\n   */\r\n  function transferOwnership(address to) public override onlyOwner {\r\n    _transferOwnership(to);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an ownership transfer to be completed by the recipient.\r\n   */\r\n  function acceptOwnership() external override {\r\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\r\n\r\n    address oldOwner = s_owner;\r\n    s_owner = msg.sender;\r\n    s_pendingOwner = address(0);\r\n\r\n    emit OwnershipTransferred(oldOwner, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the current owner\r\n   */\r\n  function owner() public view override returns (address) {\r\n    return s_owner;\r\n  }\r\n\r\n  /**\r\n   * @notice validate, transfer ownership, and emit relevant events\r\n   */\r\n  function _transferOwnership(address to) private {\r\n    require(to != msg.sender, \"Cannot transfer to self\");\r\n\r\n    s_pendingOwner = to;\r\n\r\n    emit OwnershipTransferRequested(s_owner, to);\r\n  }\r\n\r\n  /**\r\n   * @notice validate access\r\n   */\r\n  function _validateOwnership() internal view {\r\n    require(msg.sender == s_owner, \"Only callable by owner\");\r\n  }\r\n\r\n  /**\r\n   * @notice Reverts if called by anyone other than the contract owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    _validateOwnership();\r\n    _;\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/ConfirmedOwner.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\r\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/vendor/ENSResolver.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract ENSResolver {\r\n  function addr(bytes32 node) public view virtual returns (address);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface PointerInterface {\r\n  function getAddress() external view returns (address);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface OracleInterface {\r\n  function fulfillOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration,\r\n    bytes32 data\r\n  ) external returns (bool);\r\n\r\n  function isAuthorizedSender(address node) external view returns (bool);\r\n\r\n  function withdraw(address recipient, uint256 amount) external;\r\n\r\n  function withdrawable() external view returns (uint256);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ChainlinkRequestInterface {\r\n  function oracleRequest(\r\n    address sender,\r\n    uint256 requestPrice,\r\n    bytes32 serviceAgreementID,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  function cancelOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration\r\n  ) external;\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\r\n  function operatorRequest(\r\n    address sender,\r\n    uint256 payment,\r\n    bytes32 specId,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  function fulfillOracleRequest2(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration,\r\n    bytes calldata data\r\n  ) external returns (bool);\r\n\r\n  function ownerTransferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  ) external returns (bool success);\r\n\r\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\r\n\r\n  function getAuthorizedSenders() external returns (address[] memory);\r\n\r\n  function setAuthorizedSenders(address[] calldata senders) external;\r\n\r\n  function getForwarder() external returns (address);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n\r\n  function name() external view returns (string memory tokenName);\r\n\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n\r\n  function transferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  ) external returns (bool success);\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external returns (bool success);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ENSInterface {\r\n  // Logged when the owner of a node assigns a new owner to a subnode.\r\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n  // Logged when the owner of a node transfers ownership to a new account.\r\n  event Transfer(bytes32 indexed node, address owner);\r\n\r\n  // Logged when the resolver for a node changes.\r\n  event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n  // Logged when the TTL of a node changes\r\n  event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n  function setSubnodeOwner(\r\n    bytes32 node,\r\n    bytes32 label,\r\n    address owner\r\n  ) external;\r\n\r\n  function setResolver(bytes32 node, address resolver) external;\r\n\r\n  function setOwner(bytes32 node, address owner) external;\r\n\r\n  function setTTL(bytes32 node, uint64 ttl) external;\r\n\r\n  function owner(bytes32 node) external view returns (address);\r\n\r\n  function resolver(bytes32 node) external view returns (address);\r\n\r\n  function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev A library for working with mutable byte buffers in Solidity.\r\n *\r\n * Byte buffers are mutable and expandable, and provide a variety of primitives\r\n * for writing to them. At any time you can fetch a bytes object containing the\r\n * current contents of the buffer. The bytes object should not be stored between\r\n * operations, as it may change due to resizing of the buffer.\r\n */\r\nlibrary BufferChainlink {\r\n  /**\r\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\r\n   *      a capacity. The capacity may be longer than the current value, in\r\n   *      which case it can be extended without the need to allocate more memory.\r\n   */\r\n  struct buffer {\r\n    bytes buf;\r\n    uint256 capacity;\r\n  }\r\n\r\n  /**\r\n   * @dev Initializes a buffer with an initial capacity.\r\n   * @param buf The buffer to initialize.\r\n   * @param capacity The number of bytes of space to allocate the buffer.\r\n   * @return The buffer, for chaining.\r\n   */\r\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\r\n    if (capacity % 32 != 0) {\r\n      capacity += 32 - (capacity % 32);\r\n    }\r\n    // Allocate space for the buffer data\r\n    buf.capacity = capacity;\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      mstore(buf, ptr)\r\n      mstore(ptr, 0)\r\n      mstore(0x40, add(32, add(ptr, capacity)))\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Initializes a new buffer from an existing bytes object.\r\n   *      Changes to the buffer may mutate the original value.\r\n   * @param b The bytes object to initialize the buffer with.\r\n   * @return A new buffer.\r\n   */\r\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\r\n    buffer memory buf;\r\n    buf.buf = b;\r\n    buf.capacity = b.length;\r\n    return buf;\r\n  }\r\n\r\n  function resize(buffer memory buf, uint256 capacity) private pure {\r\n    bytes memory oldbuf = buf.buf;\r\n    init(buf, capacity);\r\n    append(buf, oldbuf);\r\n  }\r\n\r\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\r\n    if (a > b) {\r\n      return a;\r\n    }\r\n    return b;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets buffer length to 0.\r\n   * @param buf The buffer to truncate.\r\n   * @return The original buffer, for chaining..\r\n   */\r\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\r\n    assembly {\r\n      let bufptr := mload(buf)\r\n      mstore(bufptr, 0)\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param off The start offset to write to.\r\n   * @param data The data to append.\r\n   * @param len The number of bytes to copy.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function write(\r\n    buffer memory buf,\r\n    uint256 off,\r\n    bytes memory data,\r\n    uint256 len\r\n  ) internal pure returns (buffer memory) {\r\n    require(len <= data.length);\r\n\r\n    if (off + len > buf.capacity) {\r\n      resize(buf, max(buf.capacity, len + off) * 2);\r\n    }\r\n\r\n    uint256 dest;\r\n    uint256 src;\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Length of existing buffer data\r\n      let buflen := mload(bufptr)\r\n      // Start address = buffer address + offset + sizeof(buffer length)\r\n      dest := add(add(bufptr, 32), off)\r\n      // Update buffer length if we're extending it\r\n      if gt(add(len, off), buflen) {\r\n        mstore(bufptr, add(len, off))\r\n      }\r\n      src := add(data, 32)\r\n    }\r\n\r\n    // Copy word-length chunks while possible\r\n    for (; len >= 32; len -= 32) {\r\n      assembly {\r\n        mstore(dest, mload(src))\r\n      }\r\n      dest += 32;\r\n      src += 32;\r\n    }\r\n\r\n    // Copy remaining bytes\r\n    unchecked {\r\n      uint256 mask = (256**(32 - len)) - 1;\r\n      assembly {\r\n        let srcpart := and(mload(src), not(mask))\r\n        let destpart := and(mload(dest), mask)\r\n        mstore(dest, or(destpart, srcpart))\r\n      }\r\n    }\r\n\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @param len The number of bytes to copy.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function append(\r\n    buffer memory buf,\r\n    bytes memory data,\r\n    uint256 len\r\n  ) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, len);\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, data.length);\r\n  }\r\n\r\n  /**\r\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\r\n   *      capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param off The offset to write the byte at.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function writeUint8(\r\n    buffer memory buf,\r\n    uint256 off,\r\n    uint8 data\r\n  ) internal pure returns (buffer memory) {\r\n    if (off >= buf.capacity) {\r\n      resize(buf, buf.capacity * 2);\r\n    }\r\n\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Length of existing buffer data\r\n      let buflen := mload(bufptr)\r\n      // Address = buffer address + sizeof(buffer length) + off\r\n      let dest := add(add(bufptr, off), 32)\r\n      mstore8(dest, data)\r\n      // Update buffer length if we extended it\r\n      if eq(off, buflen) {\r\n        mstore(bufptr, add(buflen, 1))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\r\n   *      capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\r\n    return writeUint8(buf, buf.buf.length, data);\r\n  }\r\n\r\n  /**\r\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\r\n   *      exceed the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param off The offset to write at.\r\n   * @param data The data to append.\r\n   * @param len The number of bytes to write (left-aligned).\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function write(\r\n    buffer memory buf,\r\n    uint256 off,\r\n    bytes32 data,\r\n    uint256 len\r\n  ) private pure returns (buffer memory) {\r\n    if (len + off > buf.capacity) {\r\n      resize(buf, (len + off) * 2);\r\n    }\r\n\r\n    unchecked {\r\n      uint256 mask = (256**len) - 1;\r\n      // Right-align data\r\n      data = data >> (8 * (32 - len));\r\n      assembly {\r\n        // Memory address of the buffer data\r\n        let bufptr := mload(buf)\r\n        // Address = buffer address + sizeof(buffer length) + off + len\r\n        let dest := add(add(bufptr, off), len)\r\n        mstore(dest, or(and(mload(dest), not(mask)), data))\r\n        // Update buffer length if we extended it\r\n        if gt(add(off, len), mload(bufptr)) {\r\n          mstore(bufptr, add(off, len))\r\n        }\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\r\n   *      capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param off The offset to write at.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function writeBytes20(\r\n    buffer memory buf,\r\n    uint256 off,\r\n    bytes20 data\r\n  ) internal pure returns (buffer memory) {\r\n    return write(buf, off, bytes32(data), 20);\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chhaining.\r\n   */\r\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, bytes32(data), 20);\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, 32);\r\n  }\r\n\r\n  /**\r\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param off The offset to write at.\r\n   * @param data The data to append.\r\n   * @param len The number of bytes to write (right-aligned).\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function writeInt(\r\n    buffer memory buf,\r\n    uint256 off,\r\n    uint256 data,\r\n    uint256 len\r\n  ) private pure returns (buffer memory) {\r\n    if (len + off > buf.capacity) {\r\n      resize(buf, (len + off) * 2);\r\n    }\r\n\r\n    uint256 mask = (256**len) - 1;\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Address = buffer address + off + sizeof(buffer length) + len\r\n      let dest := add(add(bufptr, off), len)\r\n      mstore(dest, or(and(mload(dest), not(mask)), data))\r\n      // Update buffer length if we extended it\r\n      if gt(add(off, len), mload(bufptr)) {\r\n        mstore(bufptr, add(off, len))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n   * exceed the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @return The original buffer.\r\n   */\r\n  function appendInt(\r\n    buffer memory buf,\r\n    uint256 data,\r\n    uint256 len\r\n  ) internal pure returns (buffer memory) {\r\n    return writeInt(buf, buf.buf.length, data, len);\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol\r\n\r\n\r\npragma solidity >=0.4.19;\r\n\r\n\r\nlibrary CBORChainlink {\r\n  using BufferChainlink for BufferChainlink.buffer;\r\n\r\n  uint8 private constant MAJOR_TYPE_INT = 0;\r\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n  uint8 private constant MAJOR_TYPE_STRING = 3;\r\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n  uint8 private constant MAJOR_TYPE_MAP = 5;\r\n  uint8 private constant MAJOR_TYPE_TAG = 6;\r\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\r\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\r\n\r\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\r\n    if(value <= 23) {\r\n      buf.appendUint8(uint8((major << 5) | value));\r\n    } else if (value <= 0xFF) {\r\n      buf.appendUint8(uint8((major << 5) | 24));\r\n      buf.appendInt(value, 1);\r\n    } else if (value <= 0xFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 25));\r\n      buf.appendInt(value, 2);\r\n    } else if (value <= 0xFFFFFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 26));\r\n      buf.appendInt(value, 4);\r\n    } else {\r\n      buf.appendUint8(uint8((major << 5) | 27));\r\n      buf.appendInt(value, 8);\r\n    }\r\n  }\r\n\r\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\r\n    buf.appendUint8(uint8((major << 5) | 31));\r\n  }\r\n\r\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\r\n    if(value > 0xFFFFFFFFFFFFFFFF) {\r\n      encodeBigNum(buf, value);\r\n    } else {\r\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\r\n    }\r\n  }\r\n\r\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\r\n    if(value < -0x10000000000000000) {\r\n      encodeSignedBigNum(buf, value);\r\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\r\n      encodeBigNum(buf, uint(value));\r\n    } else if(value >= 0) {\r\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\r\n    } else {\r\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\r\n    }\r\n  }\r\n\r\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\r\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\r\n    buf.append(value);\r\n  }\r\n\r\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\r\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\r\n    encodeBytes(buf, abi.encode(value));\r\n  }\r\n\r\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\r\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\r\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\r\n  }\r\n\r\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\r\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\r\n    buf.append(bytes(value));\r\n  }\r\n\r\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\r\n  }\r\n\r\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\r\n  }\r\n\r\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/Chainlink.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title Library for common Chainlink functions\r\n * @dev Uses imported CBOR library for encoding to buffer\r\n */\r\nlibrary Chainlink {\r\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\r\n\r\n  using CBORChainlink for BufferChainlink.buffer;\r\n\r\n  struct Request {\r\n    bytes32 id;\r\n    address callbackAddress;\r\n    bytes4 callbackFunctionId;\r\n    uint256 nonce;\r\n    BufferChainlink.buffer buf;\r\n  }\r\n\r\n  /**\r\n   * @notice Initializes a Chainlink request\r\n   * @dev Sets the ID, callback address, and callback function signature on the request\r\n   * @param self The uninitialized request\r\n   * @param jobId The Job Specification ID\r\n   * @param callbackAddr The callback address\r\n   * @param callbackFunc The callback function signature\r\n   * @return The initialized request\r\n   */\r\n  function initialize(\r\n    Request memory self,\r\n    bytes32 jobId,\r\n    address callbackAddr,\r\n    bytes4 callbackFunc\r\n  ) internal pure returns (Chainlink.Request memory) {\r\n    BufferChainlink.init(self.buf, defaultBufferSize);\r\n    self.id = jobId;\r\n    self.callbackAddress = callbackAddr;\r\n    self.callbackFunctionId = callbackFunc;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\r\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\r\n   * @param self The initialized request\r\n   * @param data The CBOR data\r\n   */\r\n  function setBuffer(Request memory self, bytes memory data) internal pure {\r\n    BufferChainlink.init(self.buf, data.length);\r\n    BufferChainlink.append(self.buf, data);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a string value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The string value to add\r\n   */\r\n  function add(\r\n    Request memory self,\r\n    string memory key,\r\n    string memory value\r\n  ) internal pure {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeString(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a bytes value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The bytes value to add\r\n   */\r\n  function addBytes(\r\n    Request memory self,\r\n    string memory key,\r\n    bytes memory value\r\n  ) internal pure {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeBytes(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a int256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The int256 value to add\r\n   */\r\n  function addInt(\r\n    Request memory self,\r\n    string memory key,\r\n    int256 value\r\n  ) internal pure {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeInt(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a uint256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The uint256 value to add\r\n   */\r\n  function addUint(\r\n    Request memory self,\r\n    string memory key,\r\n    uint256 value\r\n  ) internal pure {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeUInt(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds an array of strings to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param values The array of string values to add\r\n   */\r\n  function addStringArray(\r\n    Request memory self,\r\n    string memory key,\r\n    string[] memory values\r\n  ) internal pure {\r\n    self.buf.encodeString(key);\r\n    self.buf.startArray();\r\n    for (uint256 i = 0; i < values.length; i++) {\r\n      self.buf.encodeString(values[i]);\r\n    }\r\n    self.buf.endSequence();\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/ChainlinkClient.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title The ChainlinkClient contract\r\n * @notice Contract writers can inherit this contract in order to create requests for the\r\n * Chainlink network\r\n */\r\nabstract contract ChainlinkClient {\r\n  using Chainlink for Chainlink.Request;\r\n\r\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\r\n  uint256 private constant AMOUNT_OVERRIDE = 0;\r\n  address private constant SENDER_OVERRIDE = address(0);\r\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\r\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\r\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\r\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\r\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\r\n\r\n  ENSInterface private s_ens;\r\n  bytes32 private s_ensNode;\r\n  LinkTokenInterface private s_link;\r\n  OperatorInterface private s_oracle;\r\n  uint256 private s_requestCount = 1;\r\n  mapping(bytes32 => address) private s_pendingRequests;\r\n\r\n  event ChainlinkRequested(bytes32 indexed id);\r\n  event ChainlinkFulfilled(bytes32 indexed id);\r\n  event ChainlinkCancelled(bytes32 indexed id);\r\n\r\n  /**\r\n   * @notice Creates a request that can hold additional parameters\r\n   * @param specId The Job Specification ID that the request will be created for\r\n   * @param callbackAddr address to operate the callback on\r\n   * @param callbackFunctionSignature function signature to use for the callback\r\n   * @return A Chainlink Request struct in memory\r\n   */\r\n  function buildChainlinkRequest(\r\n    bytes32 specId,\r\n    address callbackAddr,\r\n    bytes4 callbackFunctionSignature\r\n  ) internal pure returns (Chainlink.Request memory) {\r\n    Chainlink.Request memory req;\r\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a request that can hold additional parameters\r\n   * @param specId The Job Specification ID that the request will be created for\r\n   * @param callbackFunctionSignature function signature to use for the callback\r\n   * @return A Chainlink Request struct in memory\r\n   */\r\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\r\n    internal\r\n    view\r\n    returns (Chainlink.Request memory)\r\n  {\r\n    Chainlink.Request memory req;\r\n    return req.initialize(specId, address(this), callbackFunctionSignature);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the stored oracle address\r\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\r\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the specified oracle address\r\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\r\n   * send LINK which creates a request on the target oracle contract.\r\n   * Emits ChainlinkRequested event.\r\n   * @param oracleAddress The address of the oracle for the request\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendChainlinkRequestTo(\r\n    address oracleAddress,\r\n    Chainlink.Request memory req,\r\n    uint256 payment\r\n  ) internal returns (bytes32 requestId) {\r\n    uint256 nonce = s_requestCount;\r\n    s_requestCount = nonce + 1;\r\n    bytes memory encodedRequest = abi.encodeWithSelector(\r\n      ChainlinkRequestInterface.oracleRequest.selector,\r\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\r\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\r\n      req.id,\r\n      address(this),\r\n      req.callbackFunctionId,\r\n      nonce,\r\n      ORACLE_ARGS_VERSION,\r\n      req.buf.buf\r\n    );\r\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the stored oracle address\r\n   * @dev This function supports multi-word response\r\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\r\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the specified oracle address\r\n   * @dev This function supports multi-word response\r\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\r\n   * send LINK which creates a request on the target oracle contract.\r\n   * Emits ChainlinkRequested event.\r\n   * @param oracleAddress The address of the oracle for the request\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendOperatorRequestTo(\r\n    address oracleAddress,\r\n    Chainlink.Request memory req,\r\n    uint256 payment\r\n  ) internal returns (bytes32 requestId) {\r\n    uint256 nonce = s_requestCount;\r\n    s_requestCount = nonce + 1;\r\n    bytes memory encodedRequest = abi.encodeWithSelector(\r\n      OperatorInterface.operatorRequest.selector,\r\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\r\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\r\n      req.id,\r\n      req.callbackFunctionId,\r\n      nonce,\r\n      OPERATOR_ARGS_VERSION,\r\n      req.buf.buf\r\n    );\r\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\r\n  }\r\n\r\n  /**\r\n   * @notice Make a request to an oracle\r\n   * @param oracleAddress The address of the oracle for the request\r\n   * @param nonce used to generate the request ID\r\n   * @param payment The amount of LINK to send for the request\r\n   * @param encodedRequest data encoded for request type specific format\r\n   * @return requestId The request ID\r\n   */\r\n  function _rawRequest(\r\n    address oracleAddress,\r\n    uint256 nonce,\r\n    uint256 payment,\r\n    bytes memory encodedRequest\r\n  ) private returns (bytes32 requestId) {\r\n    requestId = keccak256(abi.encodePacked(this, nonce));\r\n    s_pendingRequests[requestId] = oracleAddress;\r\n    emit ChainlinkRequested(requestId);\r\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\r\n  }\r\n\r\n  /**\r\n   * @notice Allows a request to be cancelled if it has not been fulfilled\r\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\r\n   * Deletes the request from the `pendingRequests` mapping.\r\n   * Emits ChainlinkCancelled event.\r\n   * @param requestId The request ID\r\n   * @param payment The amount of LINK sent for the request\r\n   * @param callbackFunc The callback function specified for the request\r\n   * @param expiration The time of the expiration for the request\r\n   */\r\n  function cancelChainlinkRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    bytes4 callbackFunc,\r\n    uint256 expiration\r\n  ) internal {\r\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\r\n    delete s_pendingRequests[requestId];\r\n    emit ChainlinkCancelled(requestId);\r\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\r\n  }\r\n\r\n  /**\r\n   * @notice the next request count to be used in generating a nonce\r\n   * @dev starts at 1 in order to ensure consistent gas cost\r\n   * @return returns the next request count to be used in a nonce\r\n   */\r\n  function getNextRequestCount() internal view returns (uint256) {\r\n    return s_requestCount;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle address\r\n   * @param oracleAddress The address of the oracle contract\r\n   */\r\n  function setChainlinkOracle(address oracleAddress) internal {\r\n    s_oracle = OperatorInterface(oracleAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the LINK token address\r\n   * @param linkAddress The address of the LINK token contract\r\n   */\r\n  function setChainlinkToken(address linkAddress) internal {\r\n    s_link = LinkTokenInterface(linkAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the Chainlink token address for the public\r\n   * network as given by the Pointer contract\r\n   */\r\n  function setPublicChainlinkToken() internal {\r\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the LINK token\r\n   * @return The address of the LINK token\r\n   */\r\n  function chainlinkTokenAddress() internal view returns (address) {\r\n    return address(s_link);\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the oracle contract\r\n   * @return The address of the oracle contract\r\n   */\r\n  function chainlinkOracleAddress() internal view returns (address) {\r\n    return address(s_oracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows for a request which was created on another contract to be fulfilled\r\n   * on this contract\r\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\r\n   * @param requestId The request ID used for the response\r\n   */\r\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\r\n    s_pendingRequests[requestId] = oracleAddress;\r\n  }\r\n\r\n\r\n\r\n\r\n  /**\r\n   * @notice Ensures that the fulfillment is valid for this contract\r\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\r\n   * @param requestId The request ID for fulfillment\r\n   */\r\n  function validateChainlinkCallback(bytes32 requestId)\r\n    internal\r\n    recordChainlinkFulfillment(requestId)\r\n  // solhint-disable-next-line no-empty-blocks\r\n  {\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the sender is not the oracle of the request.\r\n   * Emits ChainlinkFulfilled event.\r\n   * @param requestId The request ID for fulfillment\r\n   */\r\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\r\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\r\n    delete s_pendingRequests[requestId];\r\n    emit ChainlinkFulfilled(requestId);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the request is already pending\r\n   * @param requestId The request ID for fulfillment\r\n   */\r\n  modifier notPendingRequest(bytes32 requestId) {\r\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\r\n    _;\r\n  }\r\n}\r\n\r\n// File: TangibleOracle.sol\r\n\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TangibleOracle\r\n * @dev A contract acting as an oracle for storing and updating data related to tangible items.\r\n */\r\ncontract TangibleOracle is\r\n    ChainlinkClient,\r\n    ConfirmedOwner,\r\n    AutomationCompatibleInterface\r\n{\r\n    using Chainlink for Chainlink.Request;\r\n\r\n    struct Data {\r\n        uint256 fingerprint;\r\n        uint256 weSellAt;\r\n        uint256 lockedAmount;\r\n        uint256 weSellAtStock;\r\n        uint16 currency;\r\n        uint16 location;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    uint256[] public fingerprints;\r\n    mapping(uint256 => Data) public fingerprintData;\r\n\r\n    uint256 public latestPrices;\r\n\r\n    // Chainlink variables\r\n    bytes32 private jobIdUpdate = \"23c0d4ab09ac480e9540b4c358ef3b69\";\r\n    bytes32 private jobIdStockUpdate = \"9358543bb16e4da29a2f3e34541c4fad\";\r\n    uint256 private fee = 0;\r\n    address private oracle = 0x0f0D6357F00664cdDD394e368b313A0BC979CF58;\r\n    address private submitter = 0x21e7B58F3Aee2A6F9B8D59599C2607962d01cAC4;\r\n    address private tangibleWrapper = address(0);\r\n    address private tangibleMultiSig = address(0);\r\n\r\n    // Chainlink Automation variables\r\n    uint256 public lastUpdateTime;\r\n    uint256 public updateInterval;\r\n\r\n    // Events\r\n    event PriceUpdated(\r\n        uint256 indexed fingerprint,\r\n        uint256 sellAtOld,\r\n        uint256 sellAtNew,\r\n        uint256 oldTimestamp,\r\n        uint256 newTimestamp\r\n    );\r\n\r\n    event StockUpdated(\r\n        uint256 indexed fingerprint,\r\n        uint256 sellAtStockOld,\r\n        uint256 sellAtStockNew,\r\n        uint256 oldTimestamp,\r\n        uint256 newTimestamp\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting Chainlink parameters and initializing timestamps.\r\n     */\r\n    constructor() ConfirmedOwner(msg.sender) {\r\n        setChainlinkToken(0xb0897686c545045aFc77CF20eC7A532E3120E0F1);\r\n        setChainlinkOracle(oracle);\r\n        lastUpdateTime = block.timestamp;\r\n        updateInterval = 60 * 60; // Set this value to your desired update interval in seconds\r\n    }\r\n\r\n    /**\r\n     * @dev Writes new item data to the contract.\r\n     */\r\n    function createItem(\r\n        uint256 fingerprint,\r\n        uint256 weSellAt,\r\n        uint256 lockedAmount,\r\n        uint256 weSellAtStock,\r\n        uint16 currency,\r\n        uint16 location\r\n    ) public authorizeChainlink {\r\n        require(!fingerprintExists(fingerprint), \"Fingerprint already exists\");\r\n        fingerprints.push(fingerprint);\r\n        fingerprintData[fingerprint] = Data({\r\n            fingerprint: fingerprint,\r\n            weSellAt: weSellAt,\r\n            lockedAmount: lockedAmount,\r\n            weSellAtStock: weSellAtStock,\r\n            currency: currency,\r\n            location: location,\r\n            timestamp: block.timestamp\r\n        });\r\n        // Emit PriceUpdated event\r\n        emit PriceUpdated(fingerprint, 0, weSellAt, 0, block.timestamp);\r\n        latestPrices++;\r\n        lastUpdateTime = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a fingerprint already exists in the contract.\r\n     */\r\n    function fingerprintExists(uint256 fingerprint) public view returns (bool) {\r\n        return fingerprintData[fingerprint].fingerprint != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates existing item data in the contract.\r\n     */\r\n    function updateItem(\r\n        uint256 fingerprint,\r\n        uint256 weSellAt,\r\n        uint256 lockedAmount\r\n    ) public authorizeChainlink {\r\n        Data storage data = fingerprintData[fingerprint];\r\n        uint256 oldWeSellAt = data.weSellAt;\r\n        uint256 oldTimestamp = data.timestamp;\r\n\r\n        data.fingerprint = fingerprint;\r\n        data.weSellAt = weSellAt;\r\n        data.lockedAmount = lockedAmount;\r\n        data.timestamp = block.timestamp;\r\n\r\n        // Emit PriceUpdated event\r\n        emit PriceUpdated(\r\n            fingerprint,\r\n            oldWeSellAt,\r\n            weSellAt,\r\n            oldTimestamp,\r\n            block.timestamp\r\n        );\r\n        latestPrices++;\r\n        lastUpdateTime = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves current contract data.\r\n     */\r\n    function oracleDataAll() public view returns (Data[] memory) {\r\n        Data[] memory allFingerprintsData = new Data[](fingerprints.length);\r\n        for (uint256 i = 0; i < fingerprints.length; i++) {\r\n            allFingerprintsData[i] = fingerprintData[fingerprints[i]];\r\n        }\r\n        return allFingerprintsData;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the `weSellAtStock` value of an existing fingerprint.\r\n     */\r\n    function updateStock(\r\n        uint256 fingerprint,\r\n        uint256 weSellAtStock\r\n    ) public authorizeChainlink {\r\n        Data storage data = fingerprintData[fingerprint];\r\n        uint256 oldWeSellAtStock = data.weSellAtStock;\r\n        uint256 oldTimestamp = data.timestamp;\r\n\r\n        data.fingerprint = fingerprint;\r\n        data.weSellAtStock = weSellAtStock;\r\n        data.timestamp = block.timestamp;\r\n\r\n        // Emit StockUpdated event\r\n        emit StockUpdated(\r\n            fingerprint,\r\n            oldWeSellAtStock,\r\n            weSellAtStock,\r\n            oldTimestamp,\r\n            block.timestamp\r\n        );\r\n        latestPrices++;\r\n        lastUpdateTime = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves all fingerprints stored in the contract.\r\n     */\r\n    function getFingerprintsAll() public view returns (uint256[] memory) {\r\n        return fingerprints;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of fingerprints stored in the contract.\r\n     */\r\n    function getFingerprintsLength() public view returns (uint256) {\r\n        return fingerprints.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Decreases the stock by 1 for the given fingerprint. Triggered by Tangible\r\n     */\r\n    function decrementStock(\r\n        uint256 fingerprint\r\n    ) external authorizeTangibleWrapper {\r\n        Data storage data = fingerprintData[fingerprint];\r\n        data.weSellAtStock--;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves data for multiple fingerprints in a batch.\r\n     */\r\n    function oracleDataBatch(\r\n        uint256[] calldata _fingerprints\r\n    ) public view returns (Data[] memory) {\r\n        Data[] memory batchData = new Data[](_fingerprints.length);\r\n        for (uint256 i = 0; i < _fingerprints.length; i++) {\r\n            batchData[i] = fingerprintData[_fingerprints[i]];\r\n        }\r\n        return batchData;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimal places for the oracle.\r\n     */\r\n    function getDecimals() public pure returns (uint8) {\r\n        return 3;\r\n    }\r\n\r\n    /**\r\n     * Chainlink request functions\r\n     */\r\n\r\n    /**\r\n     * @dev Creates a Chainlink request to trigger an oracle run.\r\n     */\r\n    function requestUpdate() internal returns (bytes32 requestId) {\r\n        Chainlink.Request memory req = buildChainlinkRequest(\r\n            jobIdUpdate,\r\n            address(this),\r\n            0\r\n        );\r\n        // Sends the request\r\n        return sendChainlinkRequest(req, fee);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a Chainlink request to manually trigger an oracle run.\r\n     */\r\n    function requestManualUpdate()\r\n        public\r\n        authorizeTangibleMultiSig\r\n        returns (bytes32 requestId)\r\n    {\r\n        Chainlink.Request memory req = buildChainlinkRequest(\r\n            jobIdUpdate,\r\n            address(this),\r\n            0\r\n        );\r\n        // Sends the request\r\n        return sendChainlinkRequest(req, fee);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a Chainlink request to manually trigger an oracle `weSellAtStock` update run.\r\n     */\r\n    function requestStockUpdate(\r\n        uint256 fingerprint\r\n    ) public authorizeTangibleMultiSig returns (bytes32 requestId) {\r\n        Chainlink.Request memory req = buildChainlinkRequest(\r\n            jobIdStockUpdate,\r\n            address(this),\r\n            0\r\n        );\r\n        req.addUint(\"fingerprint\", fingerprint);\r\n        return sendChainlinkRequest(req, fee);\r\n    }\r\n\r\n    /**\r\n     * @dev Chainlink admin functions\r\n     */\r\n\r\n    function setOracleAddress(address _oracle) public authorizeChainlink {\r\n        oracle = _oracle;\r\n        setChainlinkOracle(_oracle);\r\n    }\r\n\r\n    function setSubmitterAddress(address _submitter) public authorizeChainlink {\r\n        submitter = _submitter;\r\n    }\r\n\r\n    function setTangibleWrapperAddress(\r\n        address _tangibleWrapper\r\n    ) public authorizeChainlink {\r\n        tangibleWrapper = _tangibleWrapper;\r\n    }\r\n\r\n    function setTangibleMultiSig(\r\n        address _tangibleMultiSig\r\n    ) public authorizeChainlink {\r\n        tangibleMultiSig = _tangibleMultiSig;\r\n    }\r\n\r\n    modifier authorizeChainlink() {\r\n        require(\r\n            msg.sender == submitter || msg.sender == owner(),\r\n            \"Caller is not the Chainlink\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier authorizeTangibleWrapper() {\r\n        require(\r\n            msg.sender == tangibleWrapper || msg.sender == owner(),\r\n            \"Caller is not tangibleWrapper or Chainlink\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier authorizeTangibleMultiSig() {\r\n        require(\r\n            msg.sender == tangibleMultiSig || msg.sender == owner(),\r\n            \"Caller is not tangibleMultiSig or Chainlink\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Chainlink Automation functions\r\n     */\r\n\r\n    function checkUpkeep(\r\n        bytes calldata /* checkData */\r\n    ) external view override returns (bool upkeepNeeded, bytes memory ) {\r\n        upkeepNeeded = (block.timestamp - lastUpdateTime) >= updateInterval;\r\n    }\r\n\r\n    function performUpkeep(bytes calldata) external override {\r\n        if ((block.timestamp - lastUpdateTime) >= updateInterval) {\r\n            lastUpdateTime = block.timestamp;\r\n            requestUpdate();\r\n        }\r\n    }\r\n\r\n    function setUpdateInterval(\r\n        uint256 _updateInterval\r\n    ) public authorizeChainlink {\r\n        updateInterval = _updateInterval;\r\n    }\r\n\r\n    /**\r\n     * Manual Emergency Intervention\r\n     */\r\n    function resetData() public authorizeChainlink {\r\n        for (uint256 i = 0; i < fingerprints.length; i++) {\r\n            uint256 fingerprint = fingerprints[i];\r\n            delete fingerprintData[fingerprint];\r\n        }\r\n        delete fingerprints;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fingerprint\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAtOld\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAtNew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimestamp\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fingerprint\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAtStockOld\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAtStockNew\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTimestamp\",\"type\":\"uint256\"}],\"name\":\"StockUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fingerprint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weSellAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weSellAtStock\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"currency\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"location\",\"type\":\"uint16\"}],\"name\":\"createItem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fingerprint\",\"type\":\"uint256\"}],\"name\":\"decrementStock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fingerprintData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fingerprint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weSellAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weSellAtStock\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"currency\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"location\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fingerprint\",\"type\":\"uint256\"}],\"name\":\"fingerprintExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fingerprints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFingerprintsAll\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFingerprintsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleDataAll\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fingerprint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weSellAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weSellAtStock\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"currency\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"location\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct TangibleOracle.Data[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_fingerprints\",\"type\":\"uint256[]\"}],\"name\":\"oracleDataBatch\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fingerprint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weSellAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weSellAtStock\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"currency\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"location\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct TangibleOracle.Data[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestManualUpdate\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fingerprint\",\"type\":\"uint256\"}],\"name\":\"requestStockUpdate\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_submitter\",\"type\":\"address\"}],\"name\":\"setSubmitterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tangibleMultiSig\",\"type\":\"address\"}],\"name\":\"setTangibleMultiSig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tangibleWrapper\",\"type\":\"address\"}],\"name\":\"setTangibleWrapperAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_updateInterval\",\"type\":\"uint256\"}],\"name\":\"setUpdateInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fingerprint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weSellAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"}],\"name\":\"updateItem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fingerprint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weSellAtStock\",\"type\":\"uint256\"}],\"name\":\"updateStock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TangibleOracle", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d39d7454200524f3de3789a3a351c0f677684cd0c4c933c7073302c0b19b4881"}