{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IDestination.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.14;\\n\\nimport {LiqRequest} from \\\"../types/socketTypes.sol\\\";\\n\\ninterface IDestination {\\n    function directDeposit(\\n        address srcSender,\\n        LiqRequest memory liqData,\\n        uint256[] memory vaultIds,\\n        uint256[] memory amounts\\n    ) external payable returns (uint256[] memory dstAmounts);\\n\\n    function directWithdraw(\\n        address srcSender,\\n        uint256[] memory vaultIds,\\n        uint256[] memory amounts,\\n        LiqRequest memory _liqData\\n    ) external payable;\\n\\n    function stateSync(bytes memory _payload) external payable;\\n\\n    function safeGasParam() external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ISource.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.14;\\n\\ninterface IController {\\n    function chainId() external returns (uint16);\\n\\n    function totalTransactions() external returns (uint256);\\n\\n    function stateSync(bytes memory _payload) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/layerzero/IStateHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.14;\\n\\ninterface IStateHandler {\\n    function dispatchState(\\n        uint16 dstChainId,\\n        bytes memory data,\\n        bytes memory adapterParam\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/RouterPatch.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: Apache-2.0\\n */\\npragma solidity ^0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\n\\nimport {IStateHandler} from \\\"./interface/layerzero/IStateHandler.sol\\\";\\nimport {IController} from \\\"./interface/ISource.sol\\\";\\nimport {IDestination} from \\\"./interface/IDestination.sol\\\";\\n\\nimport {StateReq, InitData, StateData, TransactionType, CallbackType} from \\\"./types/lzTypes.sol\\\";\\nimport {LiqRequest} from \\\"./types/socketTypes.sol\\\";\\n\\ncontract RouterPatch is ERC1155Holder {\\n    address public constant ROUTER_ADDRESS =\\n        0xfF3aFb7d847AeD8f2540f7b5042F693242e01ebD;\\n    address public constant STATE_ADDRESS =\\n        0x908da814cc9725616D410b2978E88fF2fb9482eE;\\n    address public constant DESTINATION_ADDRESS =\\n        0xc8884edE1ae44bDfF60da4B9c542C34A69648A87;\\n\\n    uint256 public totalTransactions;\\n    uint16 public chainId;\\n\\n    /* ================ Mapping =================== */\\n    mapping(uint256 => StateData) public txHistory;\\n\\n    /* ================ Events =================== */\\n    event Initiated(uint256 txId, address fromToken, uint256 fromAmount);\\n    event Completed(uint256 txId);\\n\\n    constructor(uint16 chainId_) {\\n        chainId = chainId_;\\n        totalTransactions = IController(ROUTER_ADDRESS).totalTransactions();\\n    }\\n\\n    receive() external payable {}\\n\\n    function withdraw(\\n        StateReq[] calldata _stateReq,\\n        LiqRequest[] calldata _liqReq\\n    ) external payable {\\n        address sender = msg.sender;\\n        uint256 l1 = _stateReq.length;\\n        uint256 l2 = _liqReq.length;\\n\\n        require(l1 == l2, \\\"Router: Invalid Input Length\\\");\\n        if (l1 > 1) {\\n            for (uint256 i = 0; i < l1; ++i) {\\n                singleWithdrawal(_stateReq[i], sender);\\n            }\\n        } else {\\n            singleWithdrawal(_stateReq[0], sender);\\n        }\\n\\n        // refunding any unused gas fees.\\n        payable(sender).transfer(address(this).balance);\\n    }\\n\\n    function singleWithdrawal(StateReq calldata _stateData, address sender)\\n        internal\\n    {\\n        uint16 dstChainId = _stateData.dstChainId;\\n        require(dstChainId != 0, \\\"Router: Invalid Destination Chain\\\");\\n\\n        /// burn is not exposed externally; TBD: whether to move them here and burn.\\n        IERC1155(ROUTER_ADDRESS).safeBatchTransferFrom(\\n            sender,\\n            address(this),\\n            _stateData.vaultIds,\\n            _stateData.amounts,\\n            \\\"0x\\\"\\n        );\\n\\n        totalTransactions++;\\n\\n        /// generating a dummy request - that will override user's inbound req\\n        LiqRequest memory data = LiqRequest(\\n            0,\\n            \\\"\\\",\\n            address(0),\\n            address(0),\\n            0,\\n            0\\n        );\\n\\n        InitData memory initData = InitData(\\n            chainId,\\n            _stateData.dstChainId,\\n            sender,\\n            _stateData.vaultIds,\\n            _stateData.amounts,\\n            _stateData.maxSlippage,\\n            totalTransactions,\\n            abi.encode(data)\\n        );\\n\\n        StateData memory info = StateData(\\n            TransactionType.WITHDRAW,\\n            CallbackType.INIT,\\n            abi.encode(initData)\\n        );\\n\\n        txHistory[totalTransactions] = info;\\n\\n        if (chainId == dstChainId) {\\n            /// @dev srcSuperDestination can only transfer tokens back to this SuperRouter\\n            /// @dev to allow bridging somewhere else requires arch change\\n            IDestination(DESTINATION_ADDRESS).directWithdraw(\\n                sender,\\n                _stateData.vaultIds,\\n                _stateData.amounts,\\n                data\\n            );\\n\\n            emit Completed(totalTransactions);\\n        } else {\\n            /// @dev _liqReq should have path encoded for withdraw to SuperRouter on chain different than chainId\\n            /// @dev construct txData in this fashion: from FTM SOURCE send message to BSC DESTINATION\\n            /// @dev so that BSC DISPATCHTOKENS sends tokens to AVAX receiver (EOA/contract/user-specified)\\n            /// @dev sync could be a problem, how long Socket path stays vaild vs. how fast we bridge/receive on Dst\\n            IStateHandler(STATE_ADDRESS).dispatchState{\\n                value: _stateData.msgValue\\n            }(dstChainId, abi.encode(info), _stateData.adapterParam);\\n        }\\n\\n        emit Initiated(totalTransactions, address(0), 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/types/lzTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.14;\\n\\n/// @notice We should optimize those types more\\nenum TransactionType {\\n    DEPOSIT,\\n    WITHDRAW\\n}\\n\\nenum CallbackType {\\n    INIT,\\n    RETURN\\n}\\n\\nenum PayloadState {\\n    STORED,\\n    UPDATED,\\n    PROCESSED\\n}\\n\\nstruct StateReq {\\n    uint16 dstChainId;\\n    uint256[] amounts;\\n    uint256[] vaultIds;\\n    uint256[] maxSlippage;\\n    bytes adapterParam;\\n    uint256 msgValue;\\n}\\n\\n// [[\\\"106\\\", [\\\"8720\\\"], [\\\"4311413\\\"], [\\\"1000\\\"], \\\"0x000100000000000000000000000000000000000000000000000000000000004c4b40\\\", \\\"1548277010953360\\\"]]\\n// [[\\\"0\\\", \\\"0x\\\", \\\"0x0000000000000000000000000000000000000000\\\", \\\"0x0000000000000000000000000000000000000000\\\", \\\"0\\\", \\\"0\\\"]]\\n\\n// [\\\"0xbb906bc787fbc9207e254ff87be398f4e86ea39f\\\"][\\\"0xA36c9FEB786A79E60E5583622D1Fb42294003411\\\"] = true\\n// [{operator: \\\"0xA36c9FEB786A79E60E5583622D1Fb42294003411\\\"}]\\n\\n/// Created during deposit by contract from Liq+StateReqs\\n/// @dev using this for communication between src & dst transfers\\nstruct StateData {\\n    TransactionType txType;\\n    CallbackType flag;\\n    bytes params;\\n}\\n\\nstruct InitData {\\n    uint16 srcChainId;\\n    uint16 dstChainId;\\n    address user;\\n    uint256[] vaultIds;\\n    uint256[] amounts;\\n    uint256[] maxSlippage;\\n    uint256 txId;\\n    bytes liqData;\\n}\\n\\nstruct ReturnData {\\n    bool status;\\n    uint16 srcChainId;\\n    uint16 dstChainId;\\n    uint256 txId;\\n    uint256[] amounts;\\n}\\n\"\r\n    },\r\n    \"contracts/types/socketTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.14;\\n\\nstruct LiqRequest {\\n    uint8 bridgeId;\\n    bytes txData;\\n    address token;\\n    address allowanceTarget; /// @dev should check with socket.\\n    uint256 amount;\\n    uint256 nativeAmount;\\n}\\n\\nstruct BridgeRequest {\\n    uint256 id;\\n    uint256 optionalNativeAmount;\\n    address inputToken;\\n    bytes data;\\n}\\n\\nstruct MiddlewareRequest {\\n    uint256 id;\\n    uint256 optionalNativeAmount;\\n    address inputToken;\\n    bytes data;\\n}\\n\\nstruct UserRequest {\\n    address receiverAddress;\\n    uint256 toChainId;\\n    uint256 amount;\\n    MiddlewareRequest middlewareRequest;\\n    BridgeRequest bridgeRequest;\\n}\\n\\nstruct LiqStruct {\\n    address inputToken;\\n    address bridge;\\n    UserRequest socketInfo;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId_\",\"type\":\"uint16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"}],\"name\":\"Completed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"}],\"name\":\"Initiated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DESTINATION_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROUTER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STATE_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"txHistory\",\"outputs\":[{\"internalType\":\"enum TransactionType\",\"name\":\"txType\",\"type\":\"uint8\"},{\"internalType\":\"enum CallbackType\",\"name\":\"flag\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"vaultIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxSlippage\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"adapterParam\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"msgValue\",\"type\":\"uint256\"}],\"internalType\":\"struct StateReq[]\",\"name\":\"_stateReq\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct LiqRequest[]\",\"name\":\"_liqReq\",\"type\":\"tuple[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RouterPatch", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}