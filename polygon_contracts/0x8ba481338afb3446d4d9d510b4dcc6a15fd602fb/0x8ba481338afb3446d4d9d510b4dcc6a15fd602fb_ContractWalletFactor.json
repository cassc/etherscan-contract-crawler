{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/metatx/ERC2771Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\nabstract contract ERC2771Context is Context {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable _trustedForwarder;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(address trustedForwarder) {\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual override returns (address sender) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return super._msgSender();\\n        }\\n    }\\n\\n    function _msgData() internal view virtual override returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return super._msgData();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/access/OwnerPool.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @title OwnerPool contract for managing multiple owners\\n *\\n * @author FORCO LLC\\n */\\nabstract contract OwnerPool is Context {\\n  event OwnerAdded(address indexed ownerAddress);\\n  event OwnerRemoved(address indexed ownerAddress);\\n\\n  // Map of owner and their active state\\n  mapping(address => bool) internal _owner;\\n\\n  /**\\n   * @dev Add new owner[s]\\n   *\\n   * @param _newOwnerList address[]\\n   */\\n  function addOwnerBatch(\\n    address[] calldata _newOwnerList\\n  ) public virtual onlyOwners {\\n    for (uint256 idx = 0; idx < _newOwnerList.length; idx++) {\\n      _addOwner(_newOwnerList[idx]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Add new owner\\n   *\\n   * @param _newOwner address\\n   */\\n  function addOwner(address _newOwner) public virtual onlyOwners {\\n    _addOwner(_newOwner);\\n  }\\n\\n  /**\\n   * @dev [internal] Add new owner[s]\\n   *\\n   * @param _newOwnerList address[]\\n   */\\n  function _addOwnerBatch(address[] memory _newOwnerList) internal virtual {\\n    for (uint256 idx = 0; idx < _newOwnerList.length; idx++) {\\n      _addOwner(_newOwnerList[idx]);\\n    }\\n  }\\n\\n  /**\\n   * @dev [internal] Add new owner\\n   *\\n   * @param _newOwner address\\n   */\\n  function _addOwner(address _newOwner) internal virtual {\\n    require(\\n      _newOwner != address(0),\\n      \\\"Owner:addOwner newOwner is the zero address\\\"\\n    );\\n\\n    _owner[_newOwner] = true;\\n    emit OwnerAdded(_newOwner);\\n  }\\n\\n  /**\\n   * @dev Removes an owner\\n   *\\n   * @param _ownerToRemove address\\n   */\\n  function removeOwner(address _ownerToRemove) public virtual onlyOwners {\\n    _removeOwner(_ownerToRemove);\\n  }\\n\\n  /**\\n   * @dev [internal] Removes an owner\\n   *\\n   * @param _ownerToRemove address\\n   */\\n  function _removeOwner(address _ownerToRemove) internal virtual {\\n    require(\\n      _owner[_ownerToRemove],\\n      \\\"Owner:removeOwner trying to remove non existing Owner\\\"\\n    );\\n\\n    delete _owner[_ownerToRemove];\\n    emit OwnerRemoved(_ownerToRemove);\\n  }\\n\\n  /**\\n   * @dev Check is an address is owner\\n   *\\n   * @param _addressToCheck address\\n   */\\n  function isOwner(address _addressToCheck) public view virtual returns (bool) {\\n    return _owner[_addressToCheck];\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than Owner.\\n   */\\n  modifier onlyOwners() {\\n    require(_owner[_msgSender()], \\\"Owner:onlyOwners caller is not an Owner\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contract-wallet/ContractWallet.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/metatx/ERC2771Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\nimport \\\"../access/OwnerPool.sol\\\";\\nimport \\\"../interfaces/IContractWallet.sol\\\";\\n\\n/**\\n * @title ContractWallet contract for managing ERC20, ERC721, ERC1155\\n *\\n * @author FORCO LLC\\n */\\ncontract ContractWallet is\\n  OwnerPool,\\n  ERC2771Context,\\n  ERC165,\\n  ERC721Holder,\\n  ERC1155Holder,\\n  IContractWallet\\n{\\n  string private _metaDataURI;\\n\\n  /**\\n   * @dev constructor\\n   *\\n   * @param metaDataURI string memory\\n   * @param initialOwners address[] memory\\n   * @param trustedForwarder address\\n   */\\n  constructor(\\n    string memory metaDataURI,\\n    address[] memory initialOwners,\\n    address trustedForwarder\\n  ) ERC2771Context(trustedForwarder) {\\n    _addOwnerBatch(initialOwners);\\n    _metaDataURI = metaDataURI;\\n  }\\n\\n  /**\\n   * @dev [override] supportsInterface\\n   *\\n   * @param _interfaceId bytes4\\n   */\\n  function supportsInterface(\\n    bytes4 _interfaceId\\n  ) public view override(ERC165, IERC165, ERC1155Receiver) returns (bool) {\\n    return\\n      _interfaceId == type(IContractWallet).interfaceId ||\\n      super.supportsInterface(_interfaceId);\\n  }\\n\\n  /**\\n   * @dev [override] _msgSender\\n   */\\n  function _msgSender()\\n    internal\\n    view\\n    virtual\\n    override(Context, ERC2771Context)\\n    returns (address)\\n  {\\n    return ERC2771Context._msgSender();\\n  }\\n\\n  /**\\n   * @dev [override] _msgData\\n   */\\n  function _msgData()\\n    internal\\n    view\\n    virtual\\n    override(Context, ERC2771Context)\\n    returns (bytes calldata)\\n  {\\n    return ERC2771Context._msgData();\\n  }\\n\\n  /**\\n   * @dev To support acceptance of ETH with msg.data\\n   */\\n  fallback() external payable override {\\n    if (msg.value > 0) {\\n      emit NativeTokenReceived(_msgSender(), msg.value);\\n    }\\n  }\\n\\n  /**\\n   * @dev To support acceptance of ETH without msg.data\\n   */\\n  receive() external payable override {\\n    if (msg.value > 0) {\\n      emit NativeTokenReceived(_msgSender(), msg.value);\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IContractWallet.transfer}\\n   *\\n   * Requirement\\n   * - onlyOwners can call\\n   */\\n  function transfer(\\n    AssetType assetType,\\n    address contractAddress,\\n    uint256 tokenId,\\n    uint256 amount,\\n    address to\\n  ) external override onlyOwners {\\n    if (assetType == AssetType.NATIVE_TOKEN) {\\n      // NATIVE_TOKEN\\n      require(\\n        amount > 0,\\n        \\\"ContractWallet:transfer Native Token zero amount transfer\\\"\\n      );\\n      require(\\n        to != address(0),\\n        \\\"ContractWallet:transfer Native Token zero transfer to address\\\"\\n      );\\n\\n      payable(to).transfer(amount);\\n      emit NativeTokenTransferred(to, amount);\\n    } else if (assetType == AssetType.ERC20) {\\n      // ERC20\\n      bool success = IERC20(contractAddress).transfer(to, amount);\\n      require(success, \\\"ContractWallet:transfer ERC20 transfer failed\\\");\\n    } else if (assetType == AssetType.ERC721) {\\n      // ERC721\\n      IERC721(contractAddress).safeTransferFrom(address(this), to, tokenId);\\n    } else if (assetType == AssetType.ERC1155) {\\n      // ERC1155\\n      IERC1155(contractAddress).safeTransferFrom(\\n        address(this),\\n        to,\\n        tokenId,\\n        amount,\\n        bytes(\\\"\\\")\\n      );\\n    } else {\\n      revert(\\\"ContractWallet:transfer unsupported assetType\\\");\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IContractWallet.approve}\\n   *\\n   * Requirement\\n   * - onlyOwners can call\\n   */\\n  function approve(\\n    AssetType assetType,\\n    address contractAddress,\\n    uint256 tokenId,\\n    uint256 amount,\\n    address operator\\n  ) external override onlyOwners {\\n    if (assetType == AssetType.ERC20) {\\n      // ERC20\\n      bool success = IERC20(contractAddress).approve(operator, amount);\\n      require(success, \\\"ContractWallet:approve ERC20 approve failed\\\");\\n    } else if (assetType == AssetType.ERC721) {\\n      // ERC721\\n      IERC721(contractAddress).approve(operator, tokenId);\\n    } else {\\n      revert(\\\"ContractWallet:approve unsupported assetType\\\");\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IContractWallet.setApprovalForAll}\\n   *\\n   * Requirement\\n   * - onlyOwners can call\\n   */\\n  function setApprovalForAll(\\n    AssetType assetType,\\n    address contractAddress,\\n    address operator,\\n    bool approved\\n  ) external override onlyOwners {\\n    if (assetType == AssetType.ERC721) {\\n      // ERC721\\n      IERC721(contractAddress).setApprovalForAll(operator, approved);\\n    } else if (assetType == AssetType.ERC1155) {\\n      // ERC1155\\n      IERC1155(contractAddress).setApprovalForAll(operator, approved);\\n    } else {\\n      revert(\\\"ContractWallet:setApprovalForAll unsupported assetType\\\");\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IContractWallet.allowance}\\n   */\\n  function allowance(\\n    AssetType assetType,\\n    address contractAddress,\\n    address operator\\n  ) external view override returns (uint256) {\\n    if (assetType == AssetType.ERC20) {\\n      // ERC20\\n      return IERC20(contractAddress).allowance(address(this), operator);\\n    } else {\\n      revert(\\\"ContractWallet:allowance unsupported assetType\\\");\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IContractWallet.isApprovedForAll}\\n   */\\n  function isApprovedForAll(\\n    AssetType assetType,\\n    address contractAddress,\\n    address operator\\n  ) external view override returns (bool) {\\n    if (assetType == AssetType.ERC721) {\\n      // ERC721\\n      return IERC721(contractAddress).isApprovedForAll(address(this), operator);\\n    } else if (assetType == AssetType.ERC1155) {\\n      // ERC1155\\n      return\\n        IERC1155(contractAddress).isApprovedForAll(address(this), operator);\\n    } else {\\n      revert(\\\"ContractWallet:isApprovedForAll unsupported assetType\\\");\\n    }\\n  }\\n\\n  /**\\n   * @dev See {IContractWallet.balance}\\n   */\\n  function balance(\\n    AssetType assetType,\\n    address contractAddress,\\n    uint256 tokenId\\n  ) external view override returns (uint256) {\\n    if (assetType == AssetType.ERC20) {\\n      // ERC20\\n      return IERC20(contractAddress).balanceOf(address(this));\\n    } else if (assetType == AssetType.ERC721) {\\n      // ERC721\\n      return IERC721(contractAddress).balanceOf(address(this));\\n    } else if (assetType == AssetType.ERC1155) {\\n      // ERC1155\\n      return IERC1155(contractAddress).balanceOf(address(this), tokenId);\\n    } else {\\n      revert(\\\"ContractWallet:transfer unsupported assetType\\\");\\n    }\\n  }\\n\\n  /**\\n   * @dev setMetadataURI\\n   *\\n   * @param metaDataURI string memory\\n   *\\n   * Requirement\\n   * - onlyOwners can call\\n   */\\n  function setMetadataURI(\\n    string memory metaDataURI\\n  ) external override onlyOwners {\\n    _metaDataURI = metaDataURI;\\n  }\\n\\n  /**\\n   * @dev get metadataURI\\n   */\\n  function metadataURI() external view override returns (string memory) {\\n    return _metaDataURI;\\n  }\\n\\n  /**\\n   * @dev See {IContractWallet.execute}\\n   *\\n   * Requirement\\n   * - onlyOwners can call\\n   */\\n  function execute(\\n    Request calldata req\\n  ) external payable override onlyOwners returns (bool, bytes memory) {\\n    require(\\n      msg.value >= req.value,\\n      \\\"ContractWallet:execute not enough ETH sent\\\"\\n    );\\n\\n    (bool success, bytes memory returnData) = req.to.call{\\n      gas: req.gas,\\n      value: req.value\\n    }(abi.encodePacked(req.data));\\n\\n    if (success == false) {\\n      if (returnData.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n          let returndata_size := mload(returnData)\\n          revert(add(32, returnData), returndata_size)\\n        }\\n      } else {\\n        revert(\\\"ContractWallet:execute failed to execute\\\");\\n      }\\n    }\\n\\n    // Validate that the caller has sent enough gas for the call.\\n    // See https://ronan.eth.link/blog/ethereum-gas-dangers/\\n    if (gasleft() <= req.gas / 63) {\\n      // We explicitly trigger invalid opcode to consume all gas and bubble-up the effects, since\\n      // neither revert or assert consume all gas since Solidity 0.8.0\\n      // https://docs.soliditylang.org/en/v0.8.0/control-structures.html#panic-via-assert-and-error-via-require\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        invalid()\\n      }\\n    }\\n\\n    return (success, returnData);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/contract-wallet/ContractWalletFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/metatx/ERC2771Context.sol\\\";\\nimport \\\"./ContractWallet.sol\\\";\\nimport \\\"../access/OwnerPool.sol\\\";\\n\\n/**\\n * @title ContractWalletFactory contract to create ContractWallet contract\\n *\\n * @author FORCO LLC\\n */\\ncontract ContractWalletFactory is OwnerPool, ERC2771Context {\\n  // Event will be fired with new SBT collection is deployed\\n  event ContractWalletCreated(\\n    IContractWallet indexed contractAddress,\\n    address indexed masterOwner\\n  );\\n\\n  // Map of owner and its created SBT collection\\n  mapping(address => IContractWallet[]) private _contracts;\\n  address private _trustedForwarder;\\n\\n  /**\\n   * @dev constructor\\n   *\\n   * @param trustedForwarder_ address\\n   */\\n  constructor(address trustedForwarder_) ERC2771Context(trustedForwarder_) {\\n    _trustedForwarder = trustedForwarder_;\\n    _addOwner(_msgSender());\\n  }\\n\\n  /**\\n   * @dev [override] _msgSender\\n   */\\n  function _msgSender()\\n    internal\\n    view\\n    virtual\\n    override(Context, ERC2771Context)\\n    returns (address)\\n  {\\n    return ERC2771Context._msgSender();\\n  }\\n\\n  /**\\n   * @dev [override] _msgData\\n   */\\n  function _msgData()\\n    internal\\n    view\\n    virtual\\n    override(Context, ERC2771Context)\\n    returns (bytes calldata)\\n  {\\n    return ERC2771Context._msgData();\\n  }\\n\\n  /**\\n   * @dev Create and deploy new ContractWallet contract\\n   *\\n   * @param metaDataURI string memory\\n   * @param initialOwners address[] memory\\n   */\\n  function createContractWallet(\\n    string memory metaDataURI,\\n    address[] memory initialOwners\\n  ) external onlyOwners {\\n    require(\\n      initialOwners.length != 0,\\n      \\\"ContractWalletFactory:createContractWallet zero initialOwners\\\"\\n    );\\n    address masterOwner = initialOwners[0];\\n\\n    ContractWallet cwContract = new ContractWallet(\\n      metaDataURI,\\n      initialOwners,\\n      _trustedForwarder\\n    );\\n\\n    IContractWallet[] storage ownerContracts = _contracts[masterOwner];\\n    ownerContracts.push(IContractWallet(cwContract));\\n\\n    emit ContractWalletCreated(IContractWallet(cwContract), masterOwner);\\n  }\\n\\n  /**\\n   * @dev Get the list of SBT collection deployed by the respective owner\\n   *\\n   * @param owner_ address\\n   */\\n  function getContractByOwner(\\n    address owner_\\n  ) external view returns (IContractWallet[] memory) {\\n    return _contracts[owner_];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IContractWallet.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\n\\n/**\\n * @title Interfact for ContractWallet\\n *\\n * @author FORCO LLC\\n */\\ninterface IContractWallet is IERC721Receiver, IERC1155Receiver {\\n  // Supported AssetType\\n  enum AssetType {\\n    NATIVE_TOKEN,\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n  }\\n\\n  // Event will be fired when ETH/Native Token is received in\\n  event NativeTokenReceived(address indexed sender, uint256 amount);\\n  // Event will be fired when ETH/Native Token is transferred out\\n  event NativeTokenTransferred(address indexed receiver, uint256 amount);\\n\\n  // To support acceptance of ETH with msg.data\\n  fallback() external payable;\\n\\n  // To support acceptance of ETH without msg.data\\n  receive() external payable;\\n\\n  /**\\n   * @dev Transfer from the implementing contract for [ERC20|ERC721|ERC1155]\\n   *\\n   * @param assetType AssetType\\n   * @param contractAddress address\\n   * @param tokenId uint256\\n   * @param amount uint256\\n   * @param to address\\n   */\\n  function transfer(\\n    AssetType assetType,\\n    address contractAddress,\\n    uint256 tokenId,\\n    uint256 amount,\\n    address to\\n  ) external;\\n\\n  /**\\n   * @dev Approve operator for [ERC20|ERC721]\\n   *\\n   * @param assetType AssetType\\n   * @param contractAddress address\\n   * @param tokenId uint256\\n   * @param amount uint256\\n   * @param operator address\\n   */\\n  function approve(\\n    AssetType assetType,\\n    address contractAddress,\\n    uint256 tokenId,\\n    uint256 amount,\\n    address operator\\n  ) external;\\n\\n  /**\\n   * @dev Set setApprovalForAll for [ERC721|ERC1155]\\n   *\\n   * @param assetType AssetType\\n   * @param contractAddress address\\n   * @param operator address\\n   * @param approved bool\\n   */\\n  function setApprovalForAll(\\n    AssetType assetType,\\n    address contractAddress,\\n    address operator,\\n    bool approved\\n  ) external;\\n\\n  /**\\n   * @dev Get allowance of operator for the implementing contract for [ERC20]\\n   *\\n   * @param assetType AssetType\\n   * @param contractAddress address\\n   * @param operator address\\n   */\\n  function allowance(\\n    AssetType assetType,\\n    address contractAddress,\\n    address operator\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Get isApprovedForAll of operator for [ERC721|ERC1155]\\n   *\\n   * @param assetType AssetType\\n   * @param contractAddress address\\n   * @param operator address\\n   */\\n  function isApprovedForAll(\\n    AssetType assetType,\\n    address contractAddress,\\n    address operator\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Get balanceOf stored in the implementing contract for [ERC20|ERC721|ERC1155]\\n   *\\n   * @param assetType AssetType\\n   * @param contractAddress address\\n   * @param tokenId uint256\\n   */\\n  function balance(\\n    AssetType assetType,\\n    address contractAddress,\\n    uint256 tokenId\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev setMetadataURI\\n   *\\n   * @param metaDataURI string memory\\n   */\\n  function setMetadataURI(string memory metaDataURI) external;\\n\\n  /**\\n   * @dev Get metadataURI\\n   *\\n   * @return string memory metadataURI\\n   */\\n  function metadataURI() external view returns (string memory);\\n\\n  struct Request {\\n    address to;\\n    uint256 value;\\n    uint256 gas;\\n    bytes data;\\n  }\\n\\n  /**\\n   * @dev Execute a function\\n   *\\n   * @param req Request calldata\\n   * @return bool status of call\\n   * @return bytes memory retuned value\\n   */\\n  function execute(\\n    Request calldata req\\n  ) external payable returns (bool, bytes memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trustedForwarder_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IContractWallet\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"masterOwner\",\"type\":\"address\"}],\"name\":\"ContractWalletCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newOwnerList\",\"type\":\"address[]\"}],\"name\":\"addOwnerBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"metaDataURI\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"initialOwners\",\"type\":\"address[]\"}],\"name\":\"createContractWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"getContractByOwner\",\"outputs\":[{\"internalType\":\"contract IContractWallet[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressToCheck\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ownerToRemove\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ContractWalletFactory", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000730d139498e53577d2c6630464ab7ce7cb9e0fc6", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}