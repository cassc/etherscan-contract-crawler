{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/balancer/BPoolProxy.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./ISwap.sol\\\";\\nimport \\\"../interfaces/IXToken.sol\\\";\\nimport \\\"../interfaces/IXTokenWrapper.sol\\\";\\nimport \\\"../interfaces/IBPool.sol\\\";\\nimport \\\"../interfaces/IBRegistry.sol\\\";\\nimport \\\"../interfaces/IProtocolFee.sol\\\";\\nimport \\\"../interfaces/IUTokenPriceFeed.sol\\\";\\n\\n/**\\n * @title BPoolProxy\\n * @author Protofire\\n * @dev Forwarding proxy that allows users to batch execute swaps and join/exit pools.\\n * User should interact with pools through this contracts as it is the one that charge\\n * the protocol swap fee, and wrap/unwrap pool tokens into/from xPoolToken.\\n *\\n * This code is based on Balancer ExchangeProxy contract\\n * https://docs.balancer.finance/smart-contracts/exchange-proxy\\n * (https://etherscan.io/address/0x3E66B66Fd1d0b02fDa6C811Da9E0547970DB2f21#code)\\n */\\ncontract BPoolProxy is Ownable, ISwap, ERC1155Holder {\\n    using SafeMath for uint256;\\n\\n    struct Pool {\\n        address pool;\\n        uint256 tokenBalanceIn;\\n        uint256 tokenWeightIn;\\n        uint256 tokenBalanceOut;\\n        uint256 tokenWeightOut;\\n        uint256 swapFee;\\n        uint256 effectiveLiquidity;\\n    }\\n\\n    uint256 private constant BONE = 10**18;\\n\\n    /// @dev Address of BRegistry\\n    IBRegistry public registry;\\n    /// @dev Address of ProtocolFee module\\n    IProtocolFee public protocolFee;\\n    /// @dev Address of XTokenWrapper\\n    IXTokenWrapper public xTokenWrapper;\\n    /// @dev Address of Utitlity Token Price Feed - Used as feature flag for discounted fee\\n    IUTokenPriceFeed public utilityTokenFeed;\\n    /// @dev Address who receives fees\\n    address public feeReceiver;\\n    /// @dev Address Utitlity Token - Used as feature flag for discounted fee\\n    address public utilityToken;\\n\\n    /**\\n     * @dev Emitted when `joinPool` function is executed.\\n     */\\n    event JoinPool(address liquidityProvider, address bpool, uint256 shares);\\n\\n    /**\\n     * @dev Emitted when `exitPool` function is executed.\\n     */\\n    event ExitPool(address iquidityProvider, address bpool, uint256 shares);\\n\\n    /**\\n     * @dev Emitted when `registry` address is set.\\n     */\\n    event RegistrySet(address registry);\\n\\n    /**\\n     * @dev Emitted when `protocolFee` address is set.\\n     */\\n    event ProtocolFeeSet(address protocolFee);\\n\\n    /**\\n     * @dev Emitted when `feeReceiver` address is set.\\n     */\\n    event FeeReceiverSet(address feeReceiver);\\n\\n    /**\\n     * @dev Emitted when `xTokenWrapper` address is set.\\n     */\\n    event XTokenWrapperSet(address xTokenWrapper);\\n\\n    /**\\n     * @dev Emitted when `utilityToken` address is set.\\n     */\\n    event UtilityTokenSet(address utilityToken);\\n\\n    /**\\n     * @dev Emitted when `utilityTokenFeed` address is set.\\n     */\\n    event UtilityTokenFeedSet(address utilityTokenFeed);\\n\\n    /**\\n     * @dev Sets the values for {registry}, {protocolFee}, {feeReceiver},\\n     * {xTokenWrapper}, {utilityToken} and {utilityTokenFeed}.\\n     *\\n     * Sets ownership to the account that deploys the contract.\\n     *\\n     */\\n    constructor(\\n        address _registry,\\n        address _protocolFee,\\n        address _feeReceiver,\\n        address _xTokenWrapper,\\n        address _utilityToken,\\n        address _utilityTokenFeed\\n    ) {\\n        _setRegistry(_registry);\\n        _setProtocolFee(_protocolFee);\\n        _setFeeReceiver(_feeReceiver);\\n        _setXTokenWrapper(_xTokenWrapper);\\n        _setUtilityToken(_utilityToken);\\n        _setUtilityTokenFeed(_utilityTokenFeed);\\n    }\\n\\n    /**\\n     * @dev Sets `_registry` as the new registry.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner.\\n     * - `_registry` should not be the zero address.\\n     *\\n     * @param _registry The address of the registry.\\n     */\\n    function setRegistry(address _registry) external onlyOwner {\\n        _setRegistry(_registry);\\n    }\\n\\n    /**\\n     * @dev Sets `_protocolFee` as the new protocolFee.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner.\\n     * - `_protocolFee` should not be the zero address.\\n     *\\n     * @param _protocolFee The address of the protocolFee.\\n     */\\n    function setProtocolFee(address _protocolFee) external onlyOwner {\\n        _setProtocolFee(_protocolFee);\\n    }\\n\\n    /**\\n     * @dev Sets `_feeReceiver` as the new feeReceiver.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner.\\n     * - `_feeReceiver` should not be the zero address.\\n     *\\n     * @param _feeReceiver The address of the feeReceiver.\\n     */\\n    function setFeeReceiver(address _feeReceiver) external onlyOwner {\\n        _setFeeReceiver(_feeReceiver);\\n    }\\n\\n    /**\\n     * @dev Sets `_xTokenWrapper` as the new xTokenWrapper.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner.\\n     * - `_xTokenWrapper` should not be the zero address.\\n     *\\n     * @param _xTokenWrapper The address of the xTokenWrapper.\\n     */\\n    function setXTokenWrapper(address _xTokenWrapper) external onlyOwner {\\n        _setXTokenWrapper(_xTokenWrapper);\\n    }\\n\\n    /**\\n     * @dev Sets `_utilityToken` as the new utilityToken.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner.\\n     *\\n     * @param _utilityToken The address of the utilityToken.\\n     */\\n    function setUtilityToken(address _utilityToken) external onlyOwner {\\n        _setUtilityToken(_utilityToken);\\n    }\\n\\n    /**\\n     * @dev Sets `_utilityTokenFeed` as the new utilityTokenFeed.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner.\\n     *\\n     * @param _utilityTokenFeed The address of the utilityTokenFeed.\\n     */\\n    function setUtilityTokenFeed(address _utilityTokenFeed) external onlyOwner {\\n        _setUtilityTokenFeed(_utilityTokenFeed);\\n    }\\n\\n    /**\\n     * @dev Sets `_registry` as the new registry.\\n     *\\n     * Requirements:\\n     *\\n     * - `_registry` should not be the zero address.\\n     *\\n     * @param _registry The address of the registry.\\n     */\\n    function _setRegistry(address _registry) internal {\\n        require(_registry != address(0), \\\"registry is the zero address\\\");\\n        emit RegistrySet(_registry);\\n        registry = IBRegistry(_registry);\\n    }\\n\\n    /**\\n     * @dev Sets `_protocolFee` as the new protocolFee.\\n     *\\n     * Requirements:\\n     *\\n     * - `_protocolFee` should not be the zero address.\\n     *\\n     * @param _protocolFee The address of the protocolFee.\\n     */\\n    function _setProtocolFee(address _protocolFee) internal {\\n        require(_protocolFee != address(0), \\\"protocolFee is the zero address\\\");\\n        emit ProtocolFeeSet(_protocolFee);\\n        protocolFee = IProtocolFee(_protocolFee);\\n    }\\n\\n    /**\\n     * @dev Sets `_feeReceiver` as the new feeReceiver.\\n     *\\n     * Requirements:\\n     *\\n     * - `_feeReceiver` should not be the zero address.\\n     *\\n     * @param _feeReceiver The address of the feeReceiver.\\n     */\\n    function _setFeeReceiver(address _feeReceiver) internal {\\n        require(_feeReceiver != address(0), \\\"feeReceiver is the zero address\\\");\\n        emit FeeReceiverSet(_feeReceiver);\\n        feeReceiver = _feeReceiver;\\n    }\\n\\n    /**\\n     * @dev Sets `_xTokenWrapper` as the new xTokenWrapper.\\n     *\\n     * Requirements:\\n     *\\n     * - `_xTokenWrapper` should not be the zero address.\\n     *\\n     * @param _xTokenWrapper The address of the xTokenWrapper.\\n     */\\n    function _setXTokenWrapper(address _xTokenWrapper) internal {\\n        require(_xTokenWrapper != address(0), \\\"xTokenWrapper is the zero address\\\");\\n        emit XTokenWrapperSet(_xTokenWrapper);\\n        xTokenWrapper = IXTokenWrapper(_xTokenWrapper);\\n    }\\n\\n    /**\\n     * @dev Sets `_utilityToken` as the new utilityToken.\\n     *\\n     * @param _utilityToken The address of the utilityToken.\\n     */\\n    function _setUtilityToken(address _utilityToken) internal {\\n        emit UtilityTokenSet(_utilityToken);\\n        utilityToken = _utilityToken;\\n    }\\n\\n    /**\\n     * @dev Sets `_utilityTokenFeed` as the new utilityTokenFeed.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the owner.\\n     *\\n     * @param _utilityTokenFeed The address of the utilityTokenFeed.\\n     */\\n    function _setUtilityTokenFeed(address _utilityTokenFeed) internal {\\n        emit UtilityTokenFeedSet(_utilityTokenFeed);\\n        utilityTokenFeed = IUTokenPriceFeed(_utilityTokenFeed);\\n    }\\n\\n    /**\\n     * @dev Execute single-hop swaps for swapExactIn trade type. Used for swaps\\n     * returned from viewSplit function and legacy off-chain SOR.\\n     *\\n     * @param swaps Array of single-hop swaps.\\n     * @param tokenIn Input token.\\n     * @param tokenOut Output token.\\n     * @param totalAmountIn Total amount of tokenIn.\\n     * @param minTotalAmountOut Minumum amount of tokenOut.\\n     * @param useUtilityToken Flag to determine if the protocol swap fee is paid using UtilityToken or TokenIn.\\n     */\\n    function batchSwapExactIn(\\n        Swap[] memory swaps,\\n        IXToken tokenIn,\\n        IXToken tokenOut,\\n        uint256 totalAmountIn,\\n        uint256 minTotalAmountOut,\\n        bool useUtilityToken\\n    ) public returns (uint256 totalAmountOut) {\\n        transferFrom(tokenIn, totalAmountIn);\\n\\n        for (uint256 i = 0; i < swaps.length; i++) {\\n            Swap memory swap = swaps[i];\\n            IXToken swapTokenIn = IXToken(swap.tokenIn);\\n            IBPool pool = IBPool(swap.pool);\\n\\n            if (swapTokenIn.allowance(address(this), swap.pool) > 0) {\\n                swapTokenIn.approve(swap.pool, 0);\\n            }\\n            swapTokenIn.approve(swap.pool, swap.swapAmount);\\n\\n            (uint256 tokenAmountOut, ) =\\n                pool.swapExactAmountIn(\\n                    swap.tokenIn,\\n                    swap.swapAmount,\\n                    swap.tokenOut,\\n                    swap.limitReturnAmount,\\n                    swap.maxPrice\\n                );\\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\\n        }\\n\\n        require(totalAmountOut >= minTotalAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        transferFeeFrom(tokenIn, protocolFee.batchFee(swaps, totalAmountIn), useUtilityToken);\\n\\n        transfer(tokenOut, totalAmountOut);\\n        transfer(tokenIn, getBalance(tokenIn));\\n    }\\n\\n    /**\\n     * @dev Execute single-hop swaps for swapExactOut trade type. Used for swaps\\n     * returned from viewSplit function and legacy off-chain SOR.\\n     *\\n     * @param swaps Array of single-hop swaps.\\n     * @param tokenIn Input token.\\n     * @param tokenOut Output token.\\n     * @param maxTotalAmountIn Maximum total amount of tokenIn.\\n     * @param useUtilityToken Flag to determine if the protocol swap fee is paid using UtilityToken or TokenIn.\\n     */\\n    function batchSwapExactOut(\\n        Swap[] memory swaps,\\n        IXToken tokenIn,\\n        IXToken tokenOut,\\n        uint256 maxTotalAmountIn,\\n        bool useUtilityToken\\n    ) public returns (uint256 totalAmountIn) {\\n        transferFrom(tokenIn, maxTotalAmountIn);\\n\\n        for (uint256 i = 0; i < swaps.length; i++) {\\n            Swap memory swap = swaps[i];\\n            IXToken swapTokenIn = IXToken(swap.tokenIn);\\n            IBPool pool = IBPool(swap.pool);\\n\\n            if (swapTokenIn.allowance(address(this), swap.pool) > 0) {\\n                swapTokenIn.approve(swap.pool, 0);\\n            }\\n            swapTokenIn.approve(swap.pool, swap.limitReturnAmount);\\n\\n            (uint256 tokenAmountIn, ) =\\n                pool.swapExactAmountOut(\\n                    swap.tokenIn,\\n                    swap.limitReturnAmount,\\n                    swap.tokenOut,\\n                    swap.swapAmount,\\n                    swap.maxPrice\\n                );\\n            totalAmountIn = tokenAmountIn.add(totalAmountIn);\\n        }\\n        require(totalAmountIn <= maxTotalAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        transferFeeFrom(tokenIn, protocolFee.batchFee(swaps, totalAmountIn), useUtilityToken);\\n\\n        transfer(tokenOut, getBalance(tokenOut));\\n        transfer(tokenIn, getBalance(tokenIn));\\n    }\\n\\n    /**\\n     * @dev Execute multi-hop swaps returned from off-chain SOR for swapExactIn trade type.\\n     *\\n     * @param swapSequences multi-hop swaps sequence.\\n     * @param tokenIn Input token.\\n     * @param tokenOut Output token.\\n     * @param totalAmountIn Total amount of tokenIn.\\n     * @param minTotalAmountOut Minumum amount of tokenOut.\\n     * @param useUtilityToken Flag to determine if the protocol swap fee is paid using UtilityToken or TokenIn.\\n     */\\n    function multihopBatchSwapExactIn(\\n        Swap[][] memory swapSequences,\\n        IXToken tokenIn,\\n        IXToken tokenOut,\\n        uint256 totalAmountIn,\\n        uint256 minTotalAmountOut,\\n        bool useUtilityToken\\n    ) external returns (uint256 totalAmountOut) {\\n        transferFrom(tokenIn, totalAmountIn);\\n\\n        for (uint256 i = 0; i < swapSequences.length; i++) {\\n            uint256 tokenAmountOut;\\n            for (uint256 k = 0; k < swapSequences[i].length; k++) {\\n                Swap memory swap = swapSequences[i][k];\\n                IXToken swapTokenIn = IXToken(swap.tokenIn);\\n                if (k == 1) {\\n                    // Makes sure that on the second swap the output of the first was used\\n                    // so there is not intermediate token leftover\\n                    swap.swapAmount = tokenAmountOut;\\n                }\\n\\n                IBPool pool = IBPool(swap.pool);\\n                if (swapTokenIn.allowance(address(this), swap.pool) > 0) {\\n                    swapTokenIn.approve(swap.pool, 0);\\n                }\\n                swapTokenIn.approve(swap.pool, swap.swapAmount);\\n                (tokenAmountOut, ) = pool.swapExactAmountIn(\\n                    swap.tokenIn,\\n                    swap.swapAmount,\\n                    swap.tokenOut,\\n                    swap.limitReturnAmount,\\n                    swap.maxPrice\\n                );\\n            }\\n            // This takes the amountOut of the last swap\\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\\n        }\\n\\n        require(totalAmountOut >= minTotalAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        transferFeeFrom(tokenIn, protocolFee.multihopBatch(swapSequences, totalAmountIn), useUtilityToken);\\n\\n        transfer(tokenOut, totalAmountOut);\\n        transfer(tokenIn, getBalance(tokenIn));\\n    }\\n\\n    /**\\n     * @dev Execute multi-hop swaps returned from off-chain SOR for swapExactOut trade type.\\n     *\\n     * @param swapSequences multi-hop swaps sequence.\\n     * @param tokenIn Input token.\\n     * @param tokenOut Output token.\\n     * @param maxTotalAmountIn Maximum total amount of tokenIn.\\n     * @param useUtilityToken Flag to determine if the protocol swap fee is paid using UtilityToken or TokenIn.\\n     */\\n    function multihopBatchSwapExactOut(\\n        Swap[][] memory swapSequences,\\n        IXToken tokenIn,\\n        IXToken tokenOut,\\n        uint256 maxTotalAmountIn,\\n        bool useUtilityToken\\n    ) external returns (uint256 totalAmountIn) {\\n        transferFrom(tokenIn, maxTotalAmountIn);\\n\\n        for (uint256 i = 0; i < swapSequences.length; i++) {\\n            uint256 tokenAmountInFirstSwap;\\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\\n            if (swapSequences[i].length == 1) {\\n                Swap memory swap = swapSequences[i][0];\\n                IXToken swapTokenIn = IXToken(swap.tokenIn);\\n\\n                IBPool pool = IBPool(swap.pool);\\n                if (swapTokenIn.allowance(address(this), swap.pool) > 0) {\\n                    swapTokenIn.approve(swap.pool, 0);\\n                }\\n                swapTokenIn.approve(swap.pool, swap.limitReturnAmount);\\n\\n                (tokenAmountInFirstSwap, ) = pool.swapExactAmountOut(\\n                    swap.tokenIn,\\n                    swap.limitReturnAmount,\\n                    swap.tokenOut,\\n                    swap.swapAmount,\\n                    swap.maxPrice\\n                );\\n            } else {\\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\\n                // of token C. But first we need to buy B with A so we can then buy C with B\\n                // To get the exact amount of C we then first need to calculate how much B we'll need:\\n                uint256 intermediateTokenAmount; // This would be token B as described above\\n                Swap memory secondSwap = swapSequences[i][1];\\n                IBPool poolSecondSwap = IBPool(secondSwap.pool);\\n                intermediateTokenAmount = poolSecondSwap.calcInGivenOut(\\n                    poolSecondSwap.getBalance(secondSwap.tokenIn),\\n                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenIn),\\n                    poolSecondSwap.getBalance(secondSwap.tokenOut),\\n                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenOut),\\n                    secondSwap.swapAmount,\\n                    poolSecondSwap.getSwapFee()\\n                );\\n\\n                //// Buy intermediateTokenAmount of token B with A in the first pool\\n                Swap memory firstSwap = swapSequences[i][0];\\n                IXToken firstswapTokenIn = IXToken(firstSwap.tokenIn);\\n                IBPool poolFirstSwap = IBPool(firstSwap.pool);\\n                if (firstswapTokenIn.allowance(address(this), firstSwap.pool) < uint256(-1)) {\\n                    firstswapTokenIn.approve(firstSwap.pool, uint256(-1));\\n                }\\n\\n                (tokenAmountInFirstSwap, ) = poolFirstSwap.swapExactAmountOut(\\n                    firstSwap.tokenIn,\\n                    firstSwap.limitReturnAmount,\\n                    firstSwap.tokenOut,\\n                    intermediateTokenAmount, // This is the amount of token B we need\\n                    firstSwap.maxPrice\\n                );\\n\\n                //// Buy the final amount of token C desired\\n                IXToken secondswapTokenIn = IXToken(secondSwap.tokenIn);\\n                if (secondswapTokenIn.allowance(address(this), secondSwap.pool) < uint256(-1)) {\\n                    secondswapTokenIn.approve(secondSwap.pool, uint256(-1));\\n                }\\n\\n                poolSecondSwap.swapExactAmountOut(\\n                    secondSwap.tokenIn,\\n                    secondSwap.limitReturnAmount,\\n                    secondSwap.tokenOut,\\n                    secondSwap.swapAmount,\\n                    secondSwap.maxPrice\\n                );\\n            }\\n            totalAmountIn = tokenAmountInFirstSwap.add(totalAmountIn);\\n        }\\n\\n        require(totalAmountIn <= maxTotalAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        transferFeeFrom(tokenIn, protocolFee.multihopBatch(swapSequences, totalAmountIn), useUtilityToken);\\n\\n        transfer(tokenOut, getBalance(tokenOut));\\n        transfer(tokenIn, getBalance(tokenIn));\\n    }\\n\\n    /**\\n     * @dev Used for swaps returned from viewSplit function.\\n     *\\n     * @param tokenIn Input token.\\n     * @param tokenOut Output token.\\n     * @param totalAmountIn Total amount of tokenIn.\\n     * @param minTotalAmountOut Minumum amount of tokenOut.\\n     * @param nPools Maximum mumber of pools.\\n     * @param useUtilityToken Flag to determine if the protocol swap fee is paid using UtilityToken or TokenIn.\\n     */\\n    function smartSwapExactIn(\\n        IXToken tokenIn,\\n        IXToken tokenOut,\\n        uint256 totalAmountIn,\\n        uint256 minTotalAmountOut,\\n        uint256 nPools,\\n        bool useUtilityToken\\n    ) external returns (uint256 totalAmountOut) {\\n        Swap[] memory swaps;\\n        uint256 totalOutput;\\n        (swaps, totalOutput) = viewSplitExactIn(address(tokenIn), address(tokenOut), totalAmountIn, nPools);\\n\\n        require(totalOutput >= minTotalAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        totalAmountOut = batchSwapExactIn(swaps, tokenIn, tokenOut, totalAmountIn, minTotalAmountOut, useUtilityToken);\\n    }\\n\\n    /**\\n     * @dev Used for swaps returned from viewSplit function.\\n     *\\n     * @param tokenIn Input token.\\n     * @param tokenOut Output token.\\n     * @param maxTotalAmountIn Maximum total amount of tokenIn.\\n     * @param nPools Maximum mumber of pools.\\n     * @param useUtilityToken Flag to determine if the protocol swap fee is paid using UtilityToken or TokenIn.\\n     */\\n    function smartSwapExactOut(\\n        IXToken tokenIn,\\n        IXToken tokenOut,\\n        uint256 totalAmountOut,\\n        uint256 maxTotalAmountIn,\\n        uint256 nPools,\\n        bool useUtilityToken\\n    ) external returns (uint256 totalAmountIn) {\\n        Swap[] memory swaps;\\n        uint256 totalInput;\\n        (swaps, totalInput) = viewSplitExactOut(address(tokenIn), address(tokenOut), totalAmountOut, nPools);\\n\\n        require(totalInput <= maxTotalAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        totalAmountIn = batchSwapExactOut(swaps, tokenIn, tokenOut, maxTotalAmountIn, useUtilityToken);\\n    }\\n\\n    /**\\n     * @dev Join the `pool`, getting `poolAmountOut` pool tokens. This will pull some of each of the currently\\n     * trading tokens in the pool, meaning you must have called approve for each token for this pool. These\\n     * values are limited by the array of `maxAmountsIn` in the order of the pool tokens.\\n     *\\n     * @param pool Pool address.\\n     * @param poolAmountOut Exact pool amount out.\\n     * @param maxAmountsIn Maximum amounts in.\\n     */\\n    function joinPool(\\n        address pool,\\n        uint256 poolAmountOut,\\n        uint256[] calldata maxAmountsIn\\n    ) external {\\n        address[] memory tokens = IBPool(pool).getCurrentTokens();\\n\\n        // pull xTokens\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            transferFrom(IXToken(tokens[i]), maxAmountsIn[i]);\\n            IXToken(tokens[i]).approve(pool, maxAmountsIn[i]);\\n        }\\n\\n        IBPool(pool).joinPool(poolAmountOut, maxAmountsIn);\\n\\n        // push remaining xTokens\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            transfer(IXToken(tokens[i]), getBalance(IXToken(tokens[i])));\\n        }\\n\\n        // Wrap balancer liquidity tokens into its representing xToken\\n        IBPool(pool).approve(address(xTokenWrapper), poolAmountOut);\\n        require(xTokenWrapper.wrap(pool, poolAmountOut), \\\"ERR_WRAP_POOL\\\");\\n\\n        transfer(IXToken(xTokenWrapper.tokenToXToken(pool)), poolAmountOut);\\n\\n        emit JoinPool(msg.sender, pool, poolAmountOut);\\n    }\\n\\n    /**\\n     * @dev Exit the pool, paying poolAmountIn pool tokens and getting some of each of the currently trading\\n     * tokens in return. These values are limited by the array of minAmountsOut in the order of the pool tokens.\\n     *\\n     * @param pool Pool address.\\n     * @param poolAmountIn Exact pool amount int.\\n     * @param minAmountsOut Minumum amounts out.\\n     */\\n    function exitPool(\\n        address pool,\\n        uint256 poolAmountIn,\\n        uint256[] calldata minAmountsOut\\n    ) external {\\n        address wrappedLPT = xTokenWrapper.tokenToXToken(pool);\\n\\n        // pull wrapped liquitity tokens\\n        transferFrom(IXToken(wrappedLPT), poolAmountIn);\\n\\n        // unwrap wrapped liquitity tokens\\n        require(xTokenWrapper.unwrap(wrappedLPT, poolAmountIn), \\\"ERR_UNWRAP_POOL\\\");\\n\\n        // LPT do not need to be approved when exit\\n        IBPool(pool).exitPool(poolAmountIn, minAmountsOut);\\n\\n        // push xTokens\\n        address[] memory tokens = IBPool(pool).getCurrentTokens();\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            transfer(IXToken(tokens[i]), getBalance(IXToken(tokens[i])));\\n        }\\n\\n        emit ExitPool(msg.sender, pool, poolAmountIn);\\n    }\\n\\n    /**\\n     * @dev Pay `tokenAmountIn` of token `tokenIn` to join the pool, getting `poolAmountOut` of the pool shares.\\n     *\\n     * @param pool Pool address.\\n     * @param tokenIn Input token.\\n     * @param tokenAmountIn Exact amount of tokenIn to pay.\\n     * @param minPoolAmountOut Minumum amount of pool shares to get.\\n     */\\n    function joinswapExternAmountIn(\\n        address pool,\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        uint256 minPoolAmountOut\\n    ) external returns (uint256 poolAmountOut) {\\n        // pull xToken\\n        transferFrom(IXToken(tokenIn), tokenAmountIn);\\n        IXToken(tokenIn).approve(pool, tokenAmountIn);\\n\\n        poolAmountOut = IBPool(pool).joinswapExternAmountIn(tokenIn, tokenAmountIn, minPoolAmountOut);\\n\\n        // Wrap balancer liquidity tokens into its representing xToken\\n        IBPool(pool).approve(address(xTokenWrapper), poolAmountOut);\\n        require(xTokenWrapper.wrap(pool, poolAmountOut), \\\"ERR_WRAP_POOL\\\");\\n\\n        transfer(IXToken(xTokenWrapper.tokenToXToken(pool)), poolAmountOut);\\n\\n        emit JoinPool(msg.sender, pool, poolAmountOut);\\n    }\\n\\n    /**\\n     * @dev Specify `poolAmountOut` pool shares that you want to get, and a token `tokenIn` to pay with.\\n     * This costs `tokenAmountIn` tokens (these went into the pool).\\n     *\\n     * @param pool Pool address.\\n     * @param tokenIn Input token.\\n     * @param poolAmountOut Exact amount of pool shares to get.\\n     * @param maxAmountIn Minumum amount of tokenIn to pay.\\n     */\\n    function joinswapPoolAmountOut(\\n        address pool,\\n        address tokenIn,\\n        uint256 poolAmountOut,\\n        uint256 maxAmountIn\\n    ) external returns (uint256 tokenAmountIn) {\\n        // pull xToken\\n        transferFrom(IXToken(tokenIn), maxAmountIn);\\n        IXToken(tokenIn).approve(pool, maxAmountIn);\\n\\n        tokenAmountIn = IBPool(pool).joinswapPoolAmountOut(tokenIn, poolAmountOut, maxAmountIn);\\n\\n        // push remaining xTokens\\n        transfer(IXToken(tokenIn), getBalance(IXToken(tokenIn)));\\n\\n        // Wrap balancer liquidity tokens into its representing xToken\\n        IBPool(pool).approve(address(xTokenWrapper), poolAmountOut);\\n        require(xTokenWrapper.wrap(pool, poolAmountOut), \\\"ERR_WRAP_POOL\\\");\\n\\n        transfer(IXToken(xTokenWrapper.tokenToXToken(pool)), poolAmountOut);\\n\\n        emit JoinPool(msg.sender, pool, poolAmountOut);\\n    }\\n\\n    /**\\n     * @dev Pay `poolAmountIn` pool shares into the pool, getting `tokenAmountOut` of the given\\n     * token `tokenOut` out of the pool.\\n     *\\n     * @param pool Pool address.\\n     * @param tokenOut Input token.\\n     * @param poolAmountIn Exact amount of pool shares to pay.\\n     * @param minAmountOut Minumum amount of tokenIn to get.\\n     */\\n    function exitswapPoolAmountIn(\\n        address pool,\\n        address tokenOut,\\n        uint256 poolAmountIn,\\n        uint256 minAmountOut\\n    ) external returns (uint256 tokenAmountOut) {\\n        address wrappedLPT = xTokenWrapper.tokenToXToken(pool);\\n\\n        // pull wrapped liquitity tokens\\n        transferFrom(IXToken(wrappedLPT), poolAmountIn);\\n\\n        // unwrap wrapped liquitity tokens\\n        require(xTokenWrapper.unwrap(wrappedLPT, poolAmountIn), \\\"ERR_UNWRAP_POOL\\\");\\n\\n        // LPT do not need to be approved when exit\\n        tokenAmountOut = IBPool(pool).exitswapPoolAmountIn(tokenOut, poolAmountIn, minAmountOut);\\n\\n        // push xToken\\n        transfer(IXToken(tokenOut), tokenAmountOut);\\n\\n        emit ExitPool(msg.sender, pool, poolAmountIn);\\n    }\\n\\n    /**\\n     * @dev Specify tokenAmountOut of token tokenOut that you want to get out of the pool.\\n     * This costs poolAmountIn pool shares (these went into the pool).\\n     *\\n     * @param pool Pool address.\\n     * @param tokenOut Input token.\\n     * @param tokenAmountOut Exact amount of of tokenIn to get.\\n     * @param maxPoolAmountIn Maximum amount of pool shares to pay.\\n     */\\n    function exitswapExternAmountOut(\\n        address pool,\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 maxPoolAmountIn\\n    ) external returns (uint256 poolAmountIn) {\\n        address wrappedLPT = xTokenWrapper.tokenToXToken(pool);\\n\\n        // pull wrapped liquitity tokens\\n        transferFrom(IXToken(wrappedLPT), maxPoolAmountIn);\\n\\n        // unwrap wrapped liquitity tokens\\n        require(xTokenWrapper.unwrap(wrappedLPT, maxPoolAmountIn), \\\"ERR_UNWRAP_POOL\\\");\\n\\n        // LPT do not need to be approved when exit\\n        poolAmountIn = IBPool(pool).exitswapExternAmountOut(tokenOut, tokenAmountOut, maxPoolAmountIn);\\n\\n        // push xToken\\n        transfer(IXToken(tokenOut), tokenAmountOut);\\n\\n        uint256 remainingLPT = maxPoolAmountIn.sub(poolAmountIn);\\n        if (remainingLPT > 0) {\\n            // Wrap remaining balancer liquidity tokens into its representing xToken\\n            IBPool(pool).approve(address(xTokenWrapper), remainingLPT);\\n            require(xTokenWrapper.wrap(pool, remainingLPT), \\\"ERR_WRAP_POOL\\\");\\n\\n            transfer(IXToken(wrappedLPT), remainingLPT);\\n        }\\n\\n        emit ExitPool(msg.sender, pool, poolAmountIn);\\n    }\\n\\n    /**\\n     * @dev View function that calculates most optimal swaps (exactIn swap type) across a max of nPools.\\n     * Returns an array of `Swaps` and the total amount out for swap.\\n     *\\n     * @param tokenIn Input token.\\n     * @param tokenOut Output token.\\n     * @param swapAmount Amount of tokenIn.\\n     * @param nPools Maximum mumber of pools.\\n     */\\n    function viewSplitExactIn(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 swapAmount,\\n        uint256 nPools\\n    ) public view returns (Swap[] memory swaps, uint256 totalOutput) {\\n        address[] memory poolAddresses = registry.getBestPoolsWithLimit(tokenIn, tokenOut, nPools);\\n\\n        Pool[] memory pools = new Pool[](poolAddresses.length);\\n        uint256 sumEffectiveLiquidity;\\n        for (uint256 i = 0; i < poolAddresses.length; i++) {\\n            pools[i] = getPoolData(tokenIn, tokenOut, poolAddresses[i]);\\n            sumEffectiveLiquidity = sumEffectiveLiquidity.add(pools[i].effectiveLiquidity);\\n        }\\n\\n        uint256[] memory bestInputAmounts = new uint256[](pools.length);\\n        uint256 totalInputAmount;\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            bestInputAmounts[i] = swapAmount.mul(pools[i].effectiveLiquidity).div(sumEffectiveLiquidity);\\n            totalInputAmount = totalInputAmount.add(bestInputAmounts[i]);\\n        }\\n\\n        if (totalInputAmount < swapAmount) {\\n            bestInputAmounts[0] = bestInputAmounts[0].add(swapAmount.sub(totalInputAmount));\\n        } else {\\n            bestInputAmounts[0] = bestInputAmounts[0].sub(totalInputAmount.sub(swapAmount));\\n        }\\n\\n        swaps = new Swap[](pools.length);\\n\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            swaps[i] = Swap({\\n                pool: pools[i].pool,\\n                tokenIn: tokenIn,\\n                tokenOut: tokenOut,\\n                swapAmount: bestInputAmounts[i],\\n                limitReturnAmount: 0,\\n                maxPrice: uint256(-1)\\n            });\\n        }\\n\\n        totalOutput = calcTotalOutExactIn(bestInputAmounts, pools);\\n\\n        return (swaps, totalOutput);\\n    }\\n\\n    /**\\n     * @dev View function that calculates most optimal swaps (exactOut swap type) across a max of nPools.\\n     * Returns an array of Swaps and the total amount in for swap.\\n     *\\n     * @param tokenIn Input token.\\n     * @param tokenOut Output token.\\n     * @param swapAmount Amount of tokenIn.\\n     * @param nPools Maximum mumber of pools.\\n     */\\n    function viewSplitExactOut(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 swapAmount,\\n        uint256 nPools\\n    ) public view returns (Swap[] memory swaps, uint256 totalInput) {\\n        address[] memory poolAddresses = registry.getBestPoolsWithLimit(tokenIn, tokenOut, nPools);\\n\\n        Pool[] memory pools = new Pool[](poolAddresses.length);\\n        uint256 sumEffectiveLiquidity;\\n        for (uint256 i = 0; i < poolAddresses.length; i++) {\\n            pools[i] = getPoolData(tokenIn, tokenOut, poolAddresses[i]);\\n            sumEffectiveLiquidity = sumEffectiveLiquidity.add(pools[i].effectiveLiquidity);\\n        }\\n\\n        uint256[] memory bestInputAmounts = new uint256[](pools.length);\\n        uint256 totalInputAmount;\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            bestInputAmounts[i] = swapAmount.mul(pools[i].effectiveLiquidity).div(sumEffectiveLiquidity);\\n            totalInputAmount = totalInputAmount.add(bestInputAmounts[i]);\\n        }\\n\\n        if (totalInputAmount < swapAmount) {\\n            bestInputAmounts[0] = bestInputAmounts[0].add(swapAmount.sub(totalInputAmount));\\n        } else {\\n            bestInputAmounts[0] = bestInputAmounts[0].sub(totalInputAmount.sub(swapAmount));\\n        }\\n\\n        swaps = new Swap[](pools.length);\\n\\n        for (uint256 i = 0; i < pools.length; i++) {\\n            swaps[i] = Swap({\\n                pool: pools[i].pool,\\n                tokenIn: tokenIn,\\n                tokenOut: tokenOut,\\n                swapAmount: bestInputAmounts[i],\\n                limitReturnAmount: uint256(-1),\\n                maxPrice: uint256(-1)\\n            });\\n        }\\n\\n        totalInput = calcTotalOutExactOut(bestInputAmounts, pools);\\n\\n        return (swaps, totalInput);\\n    }\\n\\n    function getPoolData(\\n        address tokenIn,\\n        address tokenOut,\\n        address poolAddress\\n    ) internal view returns (Pool memory) {\\n        IBPool pool = IBPool(poolAddress);\\n        uint256 tokenBalanceIn = pool.getBalance(tokenIn);\\n        uint256 tokenBalanceOut = pool.getBalance(tokenOut);\\n        uint256 tokenWeightIn = pool.getDenormalizedWeight(tokenIn);\\n        uint256 tokenWeightOut = pool.getDenormalizedWeight(tokenOut);\\n        uint256 swapFee = pool.getSwapFee();\\n\\n        uint256 effectiveLiquidity = calcEffectiveLiquidity(tokenWeightIn, tokenBalanceOut, tokenWeightOut);\\n        Pool memory returnPool =\\n            Pool({\\n                pool: poolAddress,\\n                tokenBalanceIn: tokenBalanceIn,\\n                tokenWeightIn: tokenWeightIn,\\n                tokenBalanceOut: tokenBalanceOut,\\n                tokenWeightOut: tokenWeightOut,\\n                swapFee: swapFee,\\n                effectiveLiquidity: effectiveLiquidity\\n            });\\n\\n        return returnPool;\\n    }\\n\\n    function calcEffectiveLiquidity(\\n        uint256 tokenWeightIn,\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut\\n    ) internal pure returns (uint256 effectiveLiquidity) {\\n        // Bo * wi/(wi+wo)\\n        effectiveLiquidity = tokenWeightIn.mul(BONE).div(tokenWeightOut.add(tokenWeightIn)).mul(tokenBalanceOut).div(\\n            BONE\\n        );\\n\\n        return effectiveLiquidity;\\n    }\\n\\n    function calcTotalOutExactIn(uint256[] memory bestInputAmounts, Pool[] memory bestPools)\\n        internal\\n        pure\\n        returns (uint256 totalOutput)\\n    {\\n        totalOutput = 0;\\n        for (uint256 i = 0; i < bestInputAmounts.length; i++) {\\n            uint256 output =\\n                IBPool(bestPools[i].pool).calcOutGivenIn(\\n                    bestPools[i].tokenBalanceIn,\\n                    bestPools[i].tokenWeightIn,\\n                    bestPools[i].tokenBalanceOut,\\n                    bestPools[i].tokenWeightOut,\\n                    bestInputAmounts[i],\\n                    bestPools[i].swapFee\\n                );\\n\\n            totalOutput = totalOutput.add(output);\\n        }\\n        return totalOutput;\\n    }\\n\\n    function calcTotalOutExactOut(uint256[] memory bestInputAmounts, Pool[] memory bestPools)\\n        internal\\n        pure\\n        returns (uint256 totalOutput)\\n    {\\n        totalOutput = 0;\\n        for (uint256 i = 0; i < bestInputAmounts.length; i++) {\\n            uint256 output =\\n                IBPool(bestPools[i].pool).calcInGivenOut(\\n                    bestPools[i].tokenBalanceIn,\\n                    bestPools[i].tokenWeightIn,\\n                    bestPools[i].tokenBalanceOut,\\n                    bestPools[i].tokenWeightOut,\\n                    bestInputAmounts[i],\\n                    bestPools[i].swapFee\\n                );\\n\\n            totalOutput = totalOutput.add(output);\\n        }\\n        return totalOutput;\\n    }\\n\\n    /**\\n     * @dev Trtansfers `token` from the sender to this conteract.\\n     *\\n     */\\n    function transferFrom(IXToken token, uint256 amount) internal {\\n        require(token.transferFrom(msg.sender, address(this), amount), \\\"ERR_TRANSFER_FAILED\\\");\\n    }\\n\\n    /**\\n     * @dev Trtansfers protocol swap fee from the sender to this `feeReceiver`.\\n     *\\n     */\\n    function transferFeeFrom(\\n        IXToken token,\\n        uint256 amount,\\n        bool useUtitlityToken\\n    ) internal {\\n        if (useUtitlityToken && utilityToken != address(0) && address(utilityTokenFeed) != address(0)) {\\n            uint256 discountedFee = utilityTokenFeed.calculateAmount(address(token), amount.div(2));\\n\\n            if (discountedFee > 0) {\\n                require(\\n                    IERC20(utilityToken).transferFrom(msg.sender, feeReceiver, discountedFee),\\n                    \\\"ERR_FEE_UTILITY_TRANSFER_FAILED\\\"\\n                );\\n            } else {\\n                require(token.transferFrom(msg.sender, feeReceiver, amount), \\\"ERR_FEE_TRANSFER_FAILED\\\");\\n            }\\n        } else {\\n            require(token.transferFrom(msg.sender, feeReceiver, amount), \\\"ERR_FEE_TRANSFER_FAILED\\\");\\n        }\\n    }\\n\\n    function getBalance(IXToken token) internal view returns (uint256) {\\n        return token.balanceOf(address(this));\\n    }\\n\\n    function transfer(IXToken token, uint256 amount) internal {\\n        require(token.transfer(msg.sender, amount), \\\"ERR_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/balancer/ISwap.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\ninterface ISwap {\\n    struct Swap {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 swapAmount; // tokenInAmount / tokenOutAmount\\n        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\\n        uint256 maxPrice;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IXToken.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title IXToken\\n * @author Protofire\\n * @dev XToken Interface.\\n *\\n */\\ninterface IXToken is IERC20 {\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @dev Returns to normal state.\\n     */\\n    function unpause() external;\\n\\n    /**\\n     * @dev Sets authorization.\\n     *\\n     */\\n    function setAuthorization(address authorization_) external;\\n\\n    /**\\n     * @dev Sets operationsRegistry.\\n     *\\n     */\\n    function setOperationsRegistry(address operationsRegistry_) external;\\n\\n    /**\\n     * @dev Sets kya.\\n     *\\n     */\\n    function setKya(string memory kya_) external;\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     */\\n    function mint(address account, uint256 amount) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     */\\n    function burnFrom(address account, uint256 amount) external;\\n\\n    /**\\n     * @dev Grant role to the specified account\\n     *\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IXTokenWrapper.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\n\\n/**\\n * @title IXTokenWrapper\\n * @author Protofire\\n * @dev XTokenWrapper Interface.\\n *\\n */\\ninterface IXTokenWrapper is IERC1155Receiver {\\n    /**\\n     * @dev Token to xToken registry.\\n     */\\n    function tokenToXToken(address _token) external view returns (address);\\n\\n    /**\\n     * @dev xToken to Token registry.\\n     */\\n    function xTokenToToken(address _xToken) external view returns (address);\\n\\n    /**\\n     * @dev Wraps `_token` into its associated xToken.\\n     *\\n     */\\n    function wrap(address _token, uint256 _amount) external payable returns (bool);\\n\\n    /**\\n     * @dev Unwraps `_xToken`.\\n     *\\n     */\\n    function unwrap(address _xToken, uint256 _amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBPool.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title IBPool\\n * @author Protofire\\n * @dev Balancer BPool contract interface.\\n *\\n */\\ninterface IBPool {\\n    function isPublicSwap() external view returns (bool);\\n\\n    function isFinalized() external view returns (bool);\\n\\n    function isBound(address t) external view returns (bool);\\n\\n    function getNumTokens() external view returns (uint256);\\n\\n    function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n    function getFinalTokens() external view returns (address[] memory tokens);\\n\\n    function getDenormalizedWeight(address token) external view returns (uint256);\\n\\n    function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n    function getNormalizedWeight(address token) external view returns (uint256);\\n\\n    function getBalance(address token) external view returns (uint256);\\n\\n    function getSwapFee() external view returns (uint256);\\n\\n    function getController() external view returns (address);\\n\\n    function setSwapFee(uint256 swapFee) external;\\n\\n    function setController(address manager) external;\\n\\n    function setPublicSwap(bool public_) external;\\n\\n    function finalize() external;\\n\\n    function bind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) external;\\n\\n    function rebind(\\n        address token,\\n        uint256 balance,\\n        uint256 denorm\\n    ) external;\\n\\n    function unbind(address token) external;\\n\\n    function gulp(address token) external;\\n\\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\\n\\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\\n\\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        address tokenOut,\\n        uint256 minAmountOut,\\n        uint256 maxPrice\\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint256 maxAmountIn,\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 maxPrice\\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\\n\\n    function joinswapExternAmountIn(\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        uint256 minPoolAmountOut\\n    ) external returns (uint256 poolAmountOut);\\n\\n    function joinswapPoolAmountOut(\\n        address tokenIn,\\n        uint256 poolAmountOut,\\n        uint256 maxAmountIn\\n    ) external returns (uint256 tokenAmountIn);\\n\\n    function exitswapPoolAmountIn(\\n        address tokenOut,\\n        uint256 poolAmountIn,\\n        uint256 minAmountOut\\n    ) external returns (uint256 tokenAmountOut);\\n\\n    function exitswapExternAmountOut(\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 maxPoolAmountIn\\n    ) external returns (uint256 poolAmountIn);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address whom) external view returns (uint256);\\n\\n    function allowance(address src, address dst) external view returns (uint256);\\n\\n    function approve(address dst, uint256 amt) external returns (bool);\\n\\n    function transfer(address dst, uint256 amt) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amt\\n    ) external returns (bool);\\n\\n    function calcSpotPrice(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 spotPrice);\\n\\n    function calcOutGivenIn(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 tokenAmountIn,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountOut);\\n\\n    function calcInGivenOut(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 tokenAmountOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountIn);\\n\\n    function calcPoolOutGivenSingleIn(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 tokenAmountIn,\\n        uint256 swapFee\\n    ) external pure returns (uint256 poolAmountOut);\\n\\n    function calcSingleInGivenPoolOut(\\n        uint256 tokenBalanceIn,\\n        uint256 tokenWeightIn,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 poolAmountOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountIn);\\n\\n    function calcSingleOutGivenPoolIn(\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 poolAmountIn,\\n        uint256 swapFee\\n    ) external pure returns (uint256 tokenAmountOut);\\n\\n    function calcPoolInGivenSingleOut(\\n        uint256 tokenBalanceOut,\\n        uint256 tokenWeightOut,\\n        uint256 poolSupply,\\n        uint256 totalWeight,\\n        uint256 tokenAmountOut,\\n        uint256 swapFee\\n    ) external pure returns (uint256 poolAmountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title IBRegistry\\n * @author Protofire\\n * @dev Balancer BRegistry contract interface.\\n *\\n */\\n\\ninterface IBRegistry {\\n    function getBestPoolsWithLimit(\\n        address,\\n        address,\\n        uint256\\n    ) external view returns (address[] memory);\\n\\n    function addPoolPair(\\n        address,\\n        address,\\n        address\\n    ) external returns (uint256);\\n\\n    function sortPools(address[] calldata, uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProtocolFee.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../balancer/ISwap.sol\\\";\\n\\n/**\\n * @title IProtocolFee\\n * @author Protofire\\n * @dev ProtocolFee interface.\\n *\\n */\\ninterface IProtocolFee is ISwap {\\n    function batchFee(Swap[] memory swaps, uint256 amountIn) external view returns (uint256);\\n\\n    function multihopBatch(Swap[][] memory swapSequences, uint256 amountIn) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUTokenPriceFeed.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title IUtilTokenPriceFeed\\n * @author Protofire\\n * @dev Interface to be implemented by any UtilityToken price feed logic contract used in the protocol.\\n *\\n */\\ninterface IUTokenPriceFeed {\\n    /**\\n     * @dev Gets the price a `_asset` in UtilityToken.\\n     *\\n     * @param _asset address of asset to get the price.\\n     */\\n    function getPrice(address _asset) external returns (uint256);\\n\\n    /**\\n     * @dev Gets how many UtilityToken represents the `_amount` of `_asset`.\\n     *\\n     * @param _asset address of asset to get the amount.\\n     * @param _amount amount of `_asset`.\\n     */\\n    function calculateAmount(address _asset, uint256 _amount) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    constructor() {\\n        _registerInterface(\\n            ERC1155Receiver(0).onERC1155Received.selector ^\\n            ERC1155Receiver(0).onERC1155BatchReceived.selector\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocolFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xTokenWrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_utilityToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_utilityTokenFeed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"iquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bpool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"ExitPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"}],\"name\":\"FeeReceiverSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bpool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"JoinPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"protocolFee\",\"type\":\"address\"}],\"name\":\"ProtocolFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"RegistrySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"utilityTokenFeed\",\"type\":\"address\"}],\"name\":\"UtilityTokenFeedSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"utilityToken\",\"type\":\"address\"}],\"name\":\"UtilityTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"xTokenWrapper\",\"type\":\"address\"}],\"name\":\"XTokenWrapperSet\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwap.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IXToken\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IXToken\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTotalAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useUtilityToken\",\"type\":\"bool\"}],\"name\":\"batchSwapExactIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwap.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IXToken\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IXToken\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useUtilityToken\",\"type\":\"bool\"}],\"name\":\"batchSwapExactOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPoolAmountIn\",\"type\":\"uint256\"}],\"name\":\"exitswapExternAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"exitswapPoolAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"joinswapExternAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"}],\"name\":\"joinswapPoolAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwap.Swap[][]\",\"name\":\"swapSequences\",\"type\":\"tuple[][]\"},{\"internalType\":\"contract IXToken\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IXToken\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTotalAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useUtilityToken\",\"type\":\"bool\"}],\"name\":\"multihopBatchSwapExactIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwap.Swap[][]\",\"name\":\"swapSequences\",\"type\":\"tuple[][]\"},{\"internalType\":\"contract IXToken\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IXToken\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useUtilityToken\",\"type\":\"bool\"}],\"name\":\"multihopBatchSwapExactOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"contract IProtocolFee\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IBRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolFee\",\"type\":\"address\"}],\"name\":\"setProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_utilityToken\",\"type\":\"address\"}],\"name\":\"setUtilityToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_utilityTokenFeed\",\"type\":\"address\"}],\"name\":\"setUtilityTokenFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_xTokenWrapper\",\"type\":\"address\"}],\"name\":\"setXTokenWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IXToken\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IXToken\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTotalAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nPools\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useUtilityToken\",\"type\":\"bool\"}],\"name\":\"smartSwapExactIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IXToken\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IXToken\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nPools\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useUtilityToken\",\"type\":\"bool\"}],\"name\":\"smartSwapExactOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"utilityToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"utilityTokenFeed\",\"outputs\":[{\"internalType\":\"contract IUTokenPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nPools\",\"type\":\"uint256\"}],\"name\":\"viewSplitExactIn\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwap.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nPools\",\"type\":\"uint256\"}],\"name\":\"viewSplitExactOut\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwap.Swap[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"totalInput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xTokenWrapper\",\"outputs\":[{\"internalType\":\"contract IXTokenWrapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BPoolProxy", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000329d3bd0f32c5b889b03af87c5ed96ac0f22d3c8000000000000000000000000cfe212b0b818f62c17e3f8d0bc3221d1bab63d2a0000000000000000000000001dee90df6cdd8a7da3510fb5b0305efe572396410000000000000000000000006cdde4ed9165405c1914b229d3cd4ac9c354c33100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}