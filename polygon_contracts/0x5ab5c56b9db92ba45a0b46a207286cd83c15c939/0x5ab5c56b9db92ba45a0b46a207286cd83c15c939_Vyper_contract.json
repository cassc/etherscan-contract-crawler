{"SourceCode": "# @version 0.2.16\r\n\"\"\"\r\n@title \"Zap\" Depositer for permissionless factory metapools\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2021 - all rights reserved\r\n\"\"\"\r\n\r\ninterface ERC20:\r\n    def approve(_spender: address, _amount: uint256): nonpayable\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\ninterface CurveMeta:\r\n    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256, _receiver: address) -> uint256: nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]): nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256, _receiver: address) -> uint256: nonpayable\r\n    def remove_liquidity_imbalance(amounts: uint256[N_COINS], max_burn_amount: uint256) -> uint256: nonpayable\r\n    def exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256, receiver: address) -> uint256: nonpayable\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256: view\r\n    def coins(i: uint256) -> address: view\r\n\r\ninterface CurveBase:\r\n    def add_liquidity(amounts: uint256[BASE_N_COINS], min_mint_amount: uint256, use_underlying: bool): nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[BASE_N_COINS], use_underlying: bool): nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256, use_underlying: bool): nonpayable\r\n    def remove_liquidity_imbalance(amounts: uint256[BASE_N_COINS], max_burn_amount: uint256, use_underlying: bool): nonpayable\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[BASE_N_COINS], deposit: bool) -> uint256: view\r\n    def coins(i: uint256) -> address: view\r\n    def fee() -> uint256: view\r\n\r\ninterface LendingPool:\r\n    def withdraw(_underlying_asset: address, _amount: uint256, _receiver: address): nonpayable\r\n\r\n\r\nBASE_N_COINS: constant(int128) = 3\r\nBASE_POOL: constant(address) = 0x445FE580eF8d70FF569aB36e80c647af338db351\r\nBASE_LP_TOKEN: constant(address) = 0xE7a24EF0C5e95Ffb0f6684b813A78F2a3AD7D171\r\nBASE_COINS: constant(address[BASE_N_COINS]) = [0x27F8D03b3a2196956ED754baDc28D73be8830A6e, 0x1a13F4Ca1d028320A707D99520AbFefca3998b7F, 0x60D55F02A771d515e077c9C2403a1ef324885CeC]\r\nUNDERLYING_COINS: constant(address[BASE_N_COINS]) = [0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063, 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174, 0xc2132D05D31c914a87C6611C10748AEb04B58e8F]\r\n\r\nLENDING_POOL: constant(address) = 0x8dFf5E27EA6b7AC08EbFdf9eB090F32ee9a30fcf\r\n\r\nN_COINS: constant(int128) = 2\r\nMAX_COIN: constant(int128) = N_COINS-1\r\nN_ALL_COINS: constant(int128) = N_COINS + BASE_N_COINS - 1\r\n\r\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\r\nFEE_IMPRECISION: constant(uint256) = 100 * 10 ** 8  # % of the fee\r\n\r\n\r\n# coin -> pool -> is approved to transfer?\r\nis_approved: HashMap[address, HashMap[address, bool]]\r\n\r\n\r\n@external\r\ndef __init__():\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    \"\"\"\r\n    for coin in BASE_COINS:\r\n        ERC20(coin).approve(BASE_POOL, MAX_UINT256)\r\n    for coin in UNDERLYING_COINS:\r\n        ERC20(coin).approve(BASE_POOL, MAX_UINT256)\r\n\r\n\r\n@external\r\ndef add_liquidity(\r\n    _pool: address,\r\n    _deposit_amounts: uint256[N_ALL_COINS],\r\n    _min_mint_amount: uint256,\r\n    _receiver: address = msg.sender,\r\n    _use_underlying: bool = True\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Wrap underlying coins and deposit them into `_pool`\r\n    @param _pool Address of the pool to deposit into\r\n    @param _deposit_amounts List of amounts of underlying coins to deposit\r\n    @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit\r\n    @param _receiver Address that receives the LP tokens\r\n    @param _use_underlying Flag determining the usage of underlying coins for deposit\r\n    @return Amount of LP tokens received by depositing\r\n    \"\"\"\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    deposit_base: bool = False\r\n    base_coins: address[BASE_N_COINS] = empty(address[BASE_N_COINS])\r\n    if _use_underlying:\r\n        base_coins = UNDERLYING_COINS\r\n    else:\r\n        base_coins = BASE_COINS\r\n\r\n    if _deposit_amounts[0] != 0:\r\n        coin: address = CurveMeta(_pool).coins(0)\r\n        if not self.is_approved[coin][_pool]:\r\n            ERC20(coin).approve(_pool, MAX_UINT256)\r\n            self.is_approved[coin][_pool] = True\r\n        response: Bytes[32] = raw_call(\r\n            coin,\r\n            _abi_encode(\r\n                msg.sender,\r\n                self,\r\n                _deposit_amounts[0],\r\n                method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n        # handle fee on transfer\r\n        meta_amounts[0] = ERC20(coin).balanceOf(self)\r\n\r\n    for i in range(1, N_ALL_COINS):\r\n        amount: uint256 = _deposit_amounts[i]\r\n        if amount == 0:\r\n            continue\r\n        deposit_base = True\r\n        base_idx: uint256 = i - 1\r\n        coin: address = base_coins[base_idx]\r\n\r\n        response: Bytes[32] = raw_call(\r\n            coin,\r\n            _abi_encode(\r\n                msg.sender,\r\n                self,\r\n                amount,\r\n                method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n        # Handle potential transfer fees (i.e. Tether/renBTC)\r\n        base_amounts[base_idx] = ERC20(coin).balanceOf(self)\r\n\r\n    # Deposit to the base pool\r\n    if deposit_base:\r\n        coin: address = BASE_LP_TOKEN\r\n        CurveBase(BASE_POOL).add_liquidity(base_amounts, 0, _use_underlying)\r\n        meta_amounts[MAX_COIN] = ERC20(coin).balanceOf(self)\r\n        if not self.is_approved[coin][_pool]:\r\n            ERC20(coin).approve(_pool, MAX_UINT256)\r\n            self.is_approved[coin][_pool] = True\r\n\r\n    # Deposit to the meta pool\r\n    return CurveMeta(_pool).add_liquidity(meta_amounts, _min_mint_amount, _receiver)\r\n\r\n\r\n@external\r\ndef remove_liquidity(\r\n    _pool: address,\r\n    _burn_amount: uint256,\r\n    _min_amounts: uint256[N_ALL_COINS],\r\n    _receiver: address = msg.sender,\r\n    _use_underlying: bool = True\r\n) -> uint256[N_ALL_COINS]:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap coins from the pool\r\n    @dev Withdrawal amounts are based on current deposit ratios\r\n    @param _pool Address of the pool to deposit into\r\n    @param _burn_amount Quantity of LP tokens to burn in the withdrawal\r\n    @param _min_amounts Minimum amounts of underlying coins to receive\r\n    @param _receiver Address that receives the LP tokens\r\n    @return List of amounts of underlying coins that were withdrawn\r\n    \"\"\"\r\n    response: Bytes[32] = raw_call(\r\n        _pool,\r\n        _abi_encode(\r\n            msg.sender,\r\n            self,\r\n            _burn_amount,\r\n            method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    min_amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    amounts: uint256[N_ALL_COINS] = empty(uint256[N_ALL_COINS])\r\n\r\n    # Withdraw from meta\r\n    meta_received: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    CurveMeta(_pool).remove_liquidity(_burn_amount, [_min_amounts[0], convert(0, uint256)])\r\n\r\n    coins: address[N_COINS] = empty(address[N_COINS])\r\n    for i in range(N_COINS):\r\n        coin: address = CurveMeta(_pool).coins(i)\r\n        coins[i] = coin\r\n        # Handle fee on transfer for the first coin\r\n        meta_received[i] = ERC20(coin).balanceOf(self)\r\n\r\n    # Withdraw from base\r\n    for i in range(BASE_N_COINS):\r\n        min_amounts_base[i] = _min_amounts[MAX_COIN+i]\r\n    CurveBase(BASE_POOL).remove_liquidity(meta_received[MAX_COIN], min_amounts_base, _use_underlying)\r\n\r\n    # Transfer all coins out\r\n    response = raw_call(\r\n        coins[0],  # metapool coin 0\r\n        _abi_encode(\r\n            _receiver,\r\n            meta_received[0],\r\n            method_id=method_id(\"transfer(address,uint256)\"),\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    amounts[0] = meta_received[0]\r\n\r\n    base_coins: address[BASE_N_COINS] = empty(address[BASE_N_COINS])\r\n    if _use_underlying:\r\n        base_coins = UNDERLYING_COINS\r\n    else:\r\n        base_coins = BASE_COINS\r\n    for i in range(1, N_ALL_COINS):\r\n        coin: address = base_coins[i-1]\r\n        # handle potential fee on transfer\r\n        amounts[i] = ERC20(coin).balanceOf(self)\r\n        response = raw_call(\r\n            coin,\r\n            _abi_encode(\r\n                _receiver,\r\n                amounts[i],\r\n                method_id=method_id(\"transfer(address,uint256)\"),\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n\r\n    return amounts\r\n\r\n\r\n@external\r\ndef remove_liquidity_one_coin(\r\n    _pool: address,\r\n    _burn_amount: uint256,\r\n    i: int128,\r\n    _min_amount: uint256,\r\n    _receiver: address = msg.sender,\r\n    _use_underlying: bool = True,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap a single coin from the pool\r\n    @param _pool Address of the pool to deposit into\r\n    @param _burn_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @param _min_amount Minimum amount of underlying coin to receive\r\n    @param _receiver Address that receives the LP tokens\r\n    @return Amount of underlying coin received\r\n    \"\"\"\r\n    response: Bytes[32] = raw_call(\r\n        _pool,\r\n        _abi_encode(\r\n            msg.sender,\r\n            self,\r\n            _burn_amount,\r\n            method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n\r\n    coin_amount: uint256 = 0\r\n    if i == 0:\r\n        coin_amount = CurveMeta(_pool).remove_liquidity_one_coin(_burn_amount, i, _min_amount, _receiver)\r\n    else:\r\n        base_coins: address[BASE_N_COINS] = empty(address[BASE_N_COINS])\r\n        if _use_underlying:\r\n            base_coins = UNDERLYING_COINS\r\n        else:\r\n            base_coins = BASE_COINS\r\n        coin: address = base_coins[i - MAX_COIN]\r\n        # Withdraw a base pool coin\r\n        coin_amount = CurveMeta(_pool).remove_liquidity_one_coin(_burn_amount, MAX_COIN, 0, self)\r\n        CurveBase(BASE_POOL).remove_liquidity_one_coin(coin_amount, i-MAX_COIN, _min_amount, _use_underlying)\r\n        coin_amount = ERC20(coin).balanceOf(self)\r\n        response = raw_call(\r\n            coin,\r\n            _abi_encode(\r\n                _receiver,\r\n                coin_amount,\r\n                method_id=method_id(\"transfer(address,uint256)\"),\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n\r\n    return coin_amount\r\n\r\n\r\n@external\r\ndef remove_liquidity_imbalance(\r\n    _pool: address,\r\n    _amounts: uint256[N_ALL_COINS],\r\n    _max_burn_amount: uint256,\r\n    _receiver: address = msg.sender,\r\n    _use_underlying: bool = True\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw coins from the pool in an imbalanced amount\r\n    @param _pool Address of the pool to deposit into\r\n    @param _amounts List of amounts of underlying coins to withdraw\r\n    @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal\r\n    @param _receiver Address that receives the LP tokens\r\n    @return Actual amount of the LP token burned in the withdrawal\r\n    \"\"\"\r\n    fee: uint256 = CurveBase(BASE_POOL).fee() * BASE_N_COINS / (4 * (BASE_N_COINS - 1))\r\n    fee += fee * FEE_IMPRECISION / FEE_DENOMINATOR  # Overcharge to account for imprecision\r\n\r\n    # Transfer the LP token in\r\n    response: Bytes[32] = raw_call(\r\n        _pool,\r\n        _abi_encode(\r\n            msg.sender,\r\n            self,\r\n            _max_burn_amount,\r\n            method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    withdraw_base: bool = False\r\n    amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    amounts_meta: uint256[N_COINS] = empty(uint256[N_COINS])\r\n\r\n    # determine amounts to withdraw from base pool\r\n    for i in range(BASE_N_COINS):\r\n        amount: uint256 = _amounts[MAX_COIN + i]\r\n        if amount != 0:\r\n            amounts_base[i] = amount\r\n            withdraw_base = True\r\n\r\n    # determine amounts to withdraw from metapool\r\n    amounts_meta[0] = _amounts[0]\r\n    if withdraw_base:\r\n        amounts_meta[MAX_COIN] = CurveBase(BASE_POOL).calc_token_amount(amounts_base, False)\r\n        amounts_meta[MAX_COIN] += amounts_meta[MAX_COIN] * fee / FEE_DENOMINATOR + 1\r\n\r\n    # withdraw from metapool and return the remaining LP tokens\r\n    burn_amount: uint256 = CurveMeta(_pool).remove_liquidity_imbalance(amounts_meta, _max_burn_amount)\r\n    response = raw_call(\r\n        _pool,\r\n        _abi_encode(\r\n            msg.sender,\r\n            _max_burn_amount - burn_amount,\r\n            method_id=method_id(\"transfer(address,uint256)\"),\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n\r\n    # withdraw from base pool\r\n    if withdraw_base:\r\n        CurveBase(BASE_POOL).remove_liquidity_imbalance(amounts_base, amounts_meta[MAX_COIN], _use_underlying)\r\n        coin: address = BASE_LP_TOKEN\r\n        leftover: uint256 = ERC20(coin).balanceOf(self)\r\n\r\n        if leftover > 0:\r\n            # if some base pool LP tokens remain, re-deposit them for the caller\r\n            if not self.is_approved[coin][_pool]:\r\n                ERC20(coin).approve(_pool, MAX_UINT256)\r\n                self.is_approved[coin][_pool] = True\r\n            burn_amount -= CurveMeta(_pool).add_liquidity([convert(0, uint256), leftover], 0, msg.sender)\r\n\r\n        # transfer withdrawn base pool tokens to caller\r\n        base_coins: address[BASE_N_COINS] = empty(address[BASE_N_COINS])\r\n        if _use_underlying:\r\n            base_coins = UNDERLYING_COINS\r\n        else:\r\n            base_coins = BASE_COINS\r\n\r\n        for i in range(BASE_N_COINS):\r\n            response = raw_call(\r\n                base_coins[i],\r\n                _abi_encode(\r\n                    _receiver,\r\n                    ERC20(base_coins[i]).balanceOf(self),  # handle potential transfer fees\r\n                    method_id=method_id(\"transfer(address,uint256)\"),\r\n                ),\r\n                max_outsize=32\r\n            )\r\n            if len(response) != 0:\r\n                assert convert(response, bool)\r\n\r\n\r\n    # transfer withdrawn metapool tokens to caller\r\n    if _amounts[0] > 0:\r\n        coin: address = CurveMeta(_pool).coins(0)\r\n        response = raw_call(\r\n            coin,\r\n            _abi_encode(\r\n                _receiver,\r\n                ERC20(coin).balanceOf(self),  # handle potential fees\r\n                method_id=method_id(\"transfer(address,uint256)\"),\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n\r\n    return burn_amount\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(_pool: address, _token_amount: uint256, i: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount received when withdrawing and unwrapping a single coin\r\n    @param _pool Address of the pool to deposit into\r\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the underlying coin to withdraw\r\n    @return Amount of coin received\r\n    \"\"\"\r\n    if i < MAX_COIN:\r\n        return CurveMeta(_pool).calc_withdraw_one_coin(_token_amount, i)\r\n    else:\r\n        _base_tokens: uint256 = CurveMeta(_pool).calc_withdraw_one_coin(_token_amount, MAX_COIN)\r\n        return CurveBase(BASE_POOL).calc_withdraw_one_coin(_base_tokens, i-MAX_COIN)\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(_pool: address, _amounts: uint256[N_ALL_COINS], _is_deposit: bool) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate addition or reduction in token supply from a deposit or withdrawal\r\n    @dev This calculation accounts for slippage, but not fees.\r\n         Needed to prevent front-running, not for precise calculations!\r\n    @param _pool Address of the pool to deposit into\r\n    @param _amounts Amount of each underlying coin being deposited\r\n    @param _is_deposit set True for deposits, False for withdrawals\r\n    @return Expected amount of LP tokens received\r\n    \"\"\"\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n\r\n    meta_amounts[0] = _amounts[0]\r\n    for i in range(BASE_N_COINS):\r\n        base_amounts[i] = _amounts[i + MAX_COIN]\r\n\r\n    base_tokens: uint256 = CurveBase(BASE_POOL).calc_token_amount(base_amounts, _is_deposit)\r\n    meta_amounts[MAX_COIN] = base_tokens\r\n\r\n    return CurveMeta(_pool).calc_token_amount(meta_amounts, _is_deposit)\r\n\r\n\r\n@external\r\ndef exchange_underlying(\r\n    _pool: address,\r\n    _i: int128,\r\n    _j: int128,\r\n    _dx: uint256,\r\n    _min_dy: uint256,\r\n    _receiver: address = msg.sender,\r\n    _use_underlying: bool = True\r\n) -> uint256:\r\n\r\n    base_coins: address[BASE_N_COINS] = BASE_COINS\r\n    underlying_coins: address[BASE_N_COINS] = UNDERLYING_COINS\r\n\r\n    input_coin: address = ZERO_ADDRESS\r\n    should_wrap: bool = False\r\n\r\n    if _i == 0:\r\n        input_coin = CurveMeta(_pool).coins(0)\r\n        # approve the input coin for exchange\r\n        if not self.is_approved[input_coin][_pool]:\r\n            ERC20(input_coin).approve(_pool, MAX_UINT256)\r\n            self.is_approved[input_coin][_pool] = True\r\n    else:\r\n        base_i: int128 = _i - MAX_COIN\r\n        base_coin: address = base_coins[base_i]\r\n        if _use_underlying:\r\n            underlying_coin: address = underlying_coins[base_i]\r\n            # if the base and underlying coin are equal we can't wrap\r\n            should_wrap = base_coin != underlying_coin\r\n            input_coin = underlying_coin\r\n        else:\r\n            input_coin = base_coin\r\n\r\n        # approve the base coin to be exchanged irregardless of underlying/base status\r\n        if not self.is_approved[base_coin][_pool]:\r\n            ERC20(base_coin).approve(_pool, MAX_UINT256)\r\n            self.is_approved[base_coin][_pool] = True\r\n\r\n    response: Bytes[32] = raw_call(\r\n        input_coin,\r\n        _abi_encode(\r\n            msg.sender,\r\n            self,\r\n            _dx,\r\n            method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    # we are using base coins so this will work simply\r\n    if not _use_underlying:\r\n        return CurveMeta(_pool).exchange_underlying(_i, _j, _dx, _min_dy, _receiver)\r\n    \r\n    # we are using underlying so we potentially have to wrap\r\n    if should_wrap:\r\n        # approve for wrapping\r\n        if not self.is_approved[input_coin][LENDING_POOL]:\r\n            ERC20(input_coin).approve(LENDING_POOL, MAX_UINT256)\r\n            self.is_approved[input_coin][LENDING_POOL] = True\r\n        raw_call(\r\n            LENDING_POOL,\r\n            # deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode)\r\n            _abi_encode(input_coin, _dx, self, convert(0, uint256), method_id=method_id(\"deposit(address,uint256,address,uint16)\"))\r\n        )\r\n    dy: uint256 = CurveMeta(_pool).exchange_underlying(_i, _j, _dx, _min_dy, self)\r\n\r\n    # need to potentially unwrap now\r\n    output_coin: address = ZERO_ADDRESS\r\n\r\n    if _j == 0:\r\n        # we don't wrap the 0th token\r\n        output_coin = CurveMeta(_pool).coins(0)\r\n        should_wrap = False\r\n    else:\r\n        # we for sure are operating on underlying coins\r\n        base_j: int128 = _j - MAX_COIN\r\n        base_coin: address = base_coins[base_j]\r\n        underlying_coin: address = underlying_coins[base_j]\r\n        # if the base and underlying coin are equal we can't wrap\r\n        should_wrap = base_coin != underlying_coin\r\n        output_coin = underlying_coin\r\n    \r\n    if should_wrap:\r\n        LendingPool(LENDING_POOL).withdraw(output_coin, dy, _receiver)\r\n    else:\r\n        response = raw_call(\r\n            output_coin,\r\n            _abi_encode(_receiver, dy, method_id=method_id(\"transfer(address,uint256)\")),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n    return dy", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_deposit_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_deposit_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_deposit_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_use_underlying\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[4]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_use_underlying\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_use_underlying\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_use_underlying\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":5753},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_is_deposit\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":6666},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_i\",\"type\":\"int128\"},{\"name\":\"_j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_i\",\"type\":\"int128\"},{\"name\":\"_j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_i\",\"type\":\"int128\"},{\"name\":\"_j\",\"type\":\"int128\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_use_underlying\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.2.16", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}