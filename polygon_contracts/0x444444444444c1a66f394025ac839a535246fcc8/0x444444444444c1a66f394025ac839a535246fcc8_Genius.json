{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n// Genius is NOT LICENSED FOR COPYING.\r\n// Genius (C) 2022. All Rights Reserved.\r\n//\r\n// Telegram: https://t.me/genicrypto\r\n// Twitter: https://twitter.com/genicrypto\r\n// White Paper: https://geni.to/smartcontract\r\n//\r\n// First DAPP: https://start.geni.app\r\n// Community Website: https://thegeniustoken.com\r\n// Data and Analytics: https://geni.best\r\n// Development Telegram: https://t.me/genicryptodev\r\n//\r\n// Buy $GENI here:\r\n// * Ethereum: https://geni.to/ethereum\r\n// * Binance: https://geni.to/binance\r\n// * Polygon: https://geni.to/polygon\r\n// * Avalanche: https://geni.to/avalanche\r\n//\r\n// Third-Party Security Reviews:\r\n// * Gleipnir: https://www.gleipnirsecurity.com/_files/ugd/a4dd88_02edf4a4aeef4e6d950db85175488ebb.pdf\r\n// * CertiK: https://www.certik.com/projects/genius\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Counters.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/ERC20.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/cryptography/ECDSA.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        } else if (error == RecoverError.InvalidSignatureV) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature` or error string. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     *\r\n     * Documentation for signature generation:\r\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\r\n        // Check the signature length\r\n        // - case 65: r,s,v signature (standard)\r\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return tryRecover(hash, v, r, s);\r\n        } else if (signature.length == 64) {\r\n            bytes32 r;\r\n            bytes32 vs;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                vs := mload(add(signature, 0x40))\r\n            }\r\n            return tryRecover(hash, r, vs);\r\n        } else {\r\n            return (address(0), RecoverError.InvalidSignatureLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\r\n     *\r\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address, RecoverError) {\r\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n        return tryRecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address, RecoverError) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n        if (v != 27 && v != 28) {\r\n            return (address(0), RecoverError.InvalidSignatureV);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Typed Data, created from a\r\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n     * to the one signed with the\r\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n     * JSON-RPC method as part of EIP-712.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/cryptography/draft-EIP712.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\r\n *\r\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\r\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\r\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\r\n *\r\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\r\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\r\n * ({_hashTypedDataV4}).\r\n *\r\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\r\n * the chain id to protect against replay attacks on an eventual fork of the chain.\r\n *\r\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\r\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\r\n *\r\n * _Available since v3.4._\r\n */\r\nabstract contract EIP712 {\r\n    /* solhint-disable var-name-mixedcase */\r\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\r\n    // invalidate the cached domain separator if the chain id changes.\r\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\r\n    uint256 private immutable _CACHED_CHAIN_ID;\r\n    address private immutable _CACHED_THIS;\r\n\r\n    bytes32 private immutable _HASHED_NAME;\r\n    bytes32 private immutable _HASHED_VERSION;\r\n    bytes32 private immutable _TYPE_HASH;\r\n\r\n    /* solhint-enable var-name-mixedcase */\r\n\r\n    /**\r\n     * @dev Initializes the domain separator and parameter caches.\r\n     *\r\n     * The meaning of `name` and `version` is specified in\r\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\r\n     *\r\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\r\n     * - `version`: the current major version of the signing domain.\r\n     *\r\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\r\n     * contract upgrade].\r\n     */\r\n    constructor(string memory name, string memory version) {\r\n        bytes32 hashedName = keccak256(bytes(name));\r\n        bytes32 hashedVersion = keccak256(bytes(version));\r\n        bytes32 typeHash = keccak256(\r\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n        );\r\n        _HASHED_NAME = hashedName;\r\n        _HASHED_VERSION = hashedVersion;\r\n        _CACHED_CHAIN_ID = block.chainid;\r\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\r\n        _CACHED_THIS = address(this);\r\n        _TYPE_HASH = typeHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the domain separator for the current chain.\r\n     */\r\n    function _domainSeparatorV4() internal view returns (bytes32) {\r\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\r\n            return _CACHED_DOMAIN_SEPARATOR;\r\n        } else {\r\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\r\n        }\r\n    }\r\n\r\n    function _buildDomainSeparator(\r\n        bytes32 typeHash,\r\n        bytes32 nameHash,\r\n        bytes32 versionHash\r\n    ) private view returns (bytes32) {\r\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\r\n     * function returns the hash of the fully encoded EIP712 message for this domain.\r\n     *\r\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\r\n     *\r\n     * ```solidity\r\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\r\n     *     keccak256(\"Mail(address to,string contents)\"),\r\n     *     mailTo,\r\n     *     keccak256(bytes(mailContents))\r\n     * )));\r\n     * address signer = ECDSA.recover(digest, signature);\r\n     * ```\r\n     */\r\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\r\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n *\r\n * _Available since v3.4._\r\n */\r\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\r\n    using Counters for Counters.Counter;\r\n\r\n    mapping(address => Counters.Counter) private _nonces;\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    bytes32 private constant _PERMIT_TYPEHASH =\r\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    /**\r\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\r\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\r\n     * to reserve a slot.\r\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\r\n     */\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\r\n\r\n    /**\r\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\r\n     *\r\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\r\n     */\r\n    constructor(string memory name) EIP712(name, \"1\") {}\r\n\r\n    /**\r\n     * @dev See {IERC20Permit-permit}.\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual override {\r\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\r\n\r\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\r\n\r\n        bytes32 hash = _hashTypedDataV4(structHash);\r\n\r\n        address signer = ECDSA.recover(hash, v, r, s);\r\n        require(signer == owner, \"ERC20Permit: invalid signature\");\r\n\r\n        _approve(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Permit-nonces}.\r\n     */\r\n    function nonces(address owner) public view virtual override returns (uint256) {\r\n        return _nonces[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\r\n        return _domainSeparatorV4();\r\n    }\r\n\r\n    /**\r\n     * @dev \"Consume a nonce\": return the current value and increment.\r\n     *\r\n     * _Available since v4.1._\r\n     */\r\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\r\n        Counters.Counter storage nonce = _nonces[owner];\r\n        current = nonce.current();\r\n        nonce.increment();\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/cryptography/MerkleProof.sol@v4.6.0\r\n\r\n// License: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/cryptography/MerkleProof.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Trees proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n *\r\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n * hashing, or use a hash function other than keccak256 for hashing leaves.\r\n * This is because the concatenation of a sorted pair of internal nodes in\r\n * the merkle tree could be reinterpreted as a leaf value.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Utilities.sol\r\n\r\n// License: UNLICENSED\r\n// Genius is NOT LICENSED FOR COPYING.\r\n// Genius (C) 2022. All Rights Reserved.\r\npragma solidity 0.8.4;\r\n\r\ninterface IPenalty {\r\n    function setMinersContract(address _minersAddress) external;\r\n    function increasePenaltyCounter(uint256 principal) external;\r\n    function redistribution(bool minerPolicy, uint256 principalPenalties, uint256 rewardPenalties) external\r\n        returns (uint256 oaReceivingAmount, uint256 redistributedPenalties);\r\n    function decMinerPopulation(uint256 genitos) external;\r\n    function incMinerPopulation(uint256 genitos) external;\r\n    function getMaxOrder() external view returns (uint256 maxOrder);\r\n    function counter() external view returns (uint256);\r\n    function calcLemClaimed(Utilities.MinerCache memory miner) external view returns(uint256);\r\n    function endMinerPenalties(Utilities.MinerCache calldata miner, uint256 servedDays,\r\n        uint256 currentGeniusDay, uint256 rewards) external\r\n        returns (Utilities.PenaltyData memory ptData);\r\n    function minerWeight(uint256 weight) external view returns (uint256);\r\n}\r\n\r\ninterface IGeniusAuction {\r\n    struct AuctionCache {\r\n        uint256 totalBids;\r\n        uint256 firstBid;\r\n        address highestBidder;\r\n        uint256 minerIndex;\r\n        uint256 highestBid;\r\n        address owner;\r\n        bool active;\r\n        uint256 end;\r\n    }\r\n\r\n    function getGeniusAuctionState(address owner, uint256 minerIndex)\r\n        external\r\n        returns (AuctionCache memory);\r\n\r\n    function cancelAuction(address owner, uint256 minerIndex) external;\r\n\r\n    function verifyAuctionNoBid(address owner, uint256 minerIndex)\r\n        external\r\n        returns (bool);\r\n\r\n    function setPenaltyAddress(address panlty) external;\r\n\r\n    function setMinersContract(address _minersAddress) external;\r\n\r\n    function setCalendarContract(address _calendarAddress) external;\r\n\r\n    function setGnftContract(address _gnftAddress) external;\r\n\r\n}\r\n\r\ninterface IStabilityPool {\r\n\r\n    struct CollateralMiner {\r\n        address collateralToken;\r\n    }\r\n\r\n    function getMinerColAddress(address owner, uint256 minerIndex) external returns (address);\r\n\r\n    function clearGeniusDebt(\r\n        Utilities.MinerCache calldata miner,\r\n        address minerOwner,\r\n        uint256 minerIndex,\r\n        address beneficiary,\r\n        uint256 currentGeniusDay,\r\n        bool benevolent\r\n    ) external returns (uint256);\r\n\r\n    function settleGeniusDebt(address beneficiary, address token,\r\n        uint256 amount, uint256 settlementFeeDays, bool mintNft) external returns (uint256);\r\n\r\n    function setOaGrantor(address grantor) external;\r\n\r\n    function setOaBeneficiary(address beneficiary) external;\r\n\r\n    function genitosRequiredToClear(address collateralAddress, uint256 principal) external returns (uint256);\r\n\r\n    function setPenaltyContract(address penaltyContract) external;\r\n\r\n    function setMinersContract(address minersContract) external;\r\n\r\n    function setGnftContract(address _gnftAddress) external;\r\n\r\n    function setAuctionContract(address auctionAddress) external;\r\n}\r\n\r\ninterface IGeniusCalendar {\r\n    struct GeniusDaySummaryStore {\r\n        uint256 newInflation;\r\n        uint256 redistribution;\r\n        uint256 basicShares;\r\n        uint256 advShares;\r\n    }\r\n\r\n    function getDaySummary(uint256 localGeniusDay)\r\n        external\r\n        view\r\n        returns (GeniusDaySummaryStore memory summary);\r\n\r\n    function makeGeniusDaySummary(uint256 _summarizeLimit) external;\r\n\r\n    function decreaseBurnedSupply(uint256 _amount) external;\r\n\r\n    function increaseBurnedSupply(uint256 _amount) external;\r\n\r\n    function burnedSupply() external view returns (uint256);\r\n\r\n    function calcDayBasicPayout(uint256 _geniusDay)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calcDayAdvPayout(uint256 _geniusDay, uint256 _basicPayout)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function decAdvShares(uint256 _amount) external;\r\n\r\n    function decBasicShares(uint256 _amount) external;\r\n\r\n    function shareRate() external view returns (uint256);\r\n\r\n    function localSummarizeGeniusDay(\r\n        uint256 _summarizeLimit,\r\n        address _summarizer,\r\n        bool mintNft\r\n    ) external returns(uint256 itCount);\r\n\r\n    function local10daySummary(uint256 _summarizeLimit, address _summarizer, bool mintNft) external returns(uint256 itCount);\r\n\r\n    function local100daySummary(uint256 _summarizeLimit, address _summarizer, bool mintNft) external returns(uint256 itCount);\r\n\r\n    function local1000daySummary(uint256 _summarizeLimit, address _summarizer, bool mintNft) external returns(uint256 itCount);\r\n\r\n    function incAdvSharesNext(uint256 _amount) external;\r\n\r\n    function incBasicSharesNext(uint256 _amount) external;\r\n\r\n    function geniusDay() external view returns (uint256);\r\n\r\n    function setShareRate(uint256 _shareRate) external;\r\n\r\n    function minerTotalPps(uint256 startDay, uint256 lastServedDay, bool minerPolicy) external view returns(uint256);\r\n\r\n    function setPenaltyContract(address _penaltyAddress) external;\r\n\r\n    function setMinersContract(address _minersAddress) external;\r\n\r\n    function setHexodusContract(address _hexodus) external;\r\n\r\n    function incDailyPenalties(uint256 _amount) external;\r\n\r\n    function setGnftContract(address _gnftAddress) external;\r\n\r\n    function summarizeServedDays(address beneficiary, uint256 startDay,\r\n        uint256 promiseDays, bool mintNft) external;\r\n}\r\n\r\ninterface IMiners {\r\n    function minerStore(address owner, uint256 minerIndex) external view returns(Utilities.MinerCache memory miner);\r\n    function minerStoreLength(address owner) external view returns (uint256 length);\r\n    function getMiners(address owner) external view returns(Utilities.MinerCache[] memory miners);\r\n    function setMinerEnded(address owner, uint256 minerIndex, uint256 ended) external;\r\n    function setMinerStoreLemClaimDay(address owner, uint256 minerIndex, uint256 lemClaimDay) external;\r\n    function setHexodusContract(address _hexodus) external;\r\n    function setGnftContract(address _gnftAddress) external;\r\n    function checkMinerForEnd(\r\n        Utilities.MinerCache memory miner,\r\n        address owner,\r\n        uint256 minerIndex,\r\n        uint256 currentDay,\r\n        uint256 servedDays\r\n    ) external;\r\n}\r\n\r\ninterface IGnft {\r\n    function mintNft(address to, uint256 nextSalt) external;\r\n}\r\n\r\n\r\ncontract Utilities {\r\n\r\n    // Revert Errors\r\n    error NoClaimExists();\r\n    error CannotShutdown();\r\n    error UnauthorizedLostBonusClaiming();\r\n\r\n    /** PHI Constants\r\n     * @notice all of the above constants (PHI & GENIUS_RATIO) have 21 decimals of precision\r\n     */\r\n    /* ~ CONSTANTS ~ */\r\n    // PHI = 1.618033988749894848205\r\n    uint256 internal constant PHI = 1618033988749894848204586834;\r\n    // PHI^-2 = 0.38196601125010515179541316563436188227969082019424\r\n    uint256 internal constant PHI_NPOW_2 = 381966011250105151795413165;\r\n    // PHI^-3 = 0.23606797749978969640917366873127623544061835961153\r\n    uint256 internal constant PHI_NPOW_3 = 236067977499789696409173668;\r\n    // PHI^-3.5 = 0.18558516575586807029616916594610619486184991016702\r\n    uint256 internal constant PHI_NPOW_35 = 185585165755868070296169165;\r\n    // PHI^2 = 2.6180339887498948482045868343656381177203091798058\r\n    uint256 internal constant PHI_POW_2 = 2618033988749894848204586834;\r\n    // PHI^PHI = 2.1784575679375991473725457028712458518070433016933\r\n    uint256 internal constant PHI_POW_PHI = 2178457567937599147372545702;\r\n\r\n    uint256 internal constant PHI_PRECISION = 1000000000000000000000000000;\r\n\r\n    uint256 internal constant GENIUS_PRECISION = 1000000000;\r\n\r\n    address internal constant LGENI_OA = 0x66eCa275200015DCD0C2Eaa6E48d4eED3092cDD6;\r\n\r\n    uint8 internal constant GENIUS_DECIMALS = 9;\r\n\r\n    // Tue Dec 13 2022 20:44:06 GMT+0000\r\n    // Tue Dec 13 2022 13:44:06 GMT-0700 (Mountain Standard Time)\r\n    // Tue Dec 13 2022 14:44:06 PM CST GMT-0600 (Central Standard)\r\n    uint256 public constant LAUNCH_TIMESTAMP = 1670964246;\r\n\r\n    // 10 ** 18\r\n    uint256 internal constant SHARE_PRECISION = 1000000000000000000;\r\n\r\n    // Penalty Counter Precision: 10 ** 12\r\n    uint256 internal constant PENALTY_COUNTER_PRECISION = 1000000000000;\r\n\r\n    // claims root for airdrop\r\n    /** @notice MAKE CONSTANT FOR PRODUCTION */\r\n    bytes32 internal constant MERKLE_ROOT =\r\n        0xcad71776a60b1a4ca80bfa5452bfc50beeb645b7f64e97f5c464ef45a41d548d;\r\n\r\n    /* ~ Variables ~ */\r\n\r\n    uint256 public advLockedSupply;\r\n    uint256 public basicLockedSupply;\r\n\r\n    address public stabilityPoolAddress;\r\n    IStabilityPool stabilityPoolContract;\r\n\r\n    address public auctionAddress;\r\n    IGeniusAuction auctionHouse;\r\n\r\n    address public calendarAddress;\r\n    IGeniusCalendar calendar;\r\n\r\n    address public penaltyAddress;\r\n    IPenalty penaltyContract;\r\n\r\n    address public minersAddress;\r\n    IMiners minersContract;\r\n\r\n    address public hexodusAddress;\r\n    address public gnftAddress;\r\n    IGnft _gnftContract;\r\n\r\n    // Origin Address Wallet\r\n    address public oaGrantor;\r\n    address public oaBeneficiary;\r\n\r\n    /** Sacrifice merkle claims tracker */\r\n    mapping(address => bool) public claimed;\r\n\r\n    uint256 public oaMintableBalance;\r\n\r\n    /* ~ DATA STRUCTS ~ */\r\n    struct MinerCache {\r\n        bool policy;\r\n        bool auctioned;\r\n        bool exodus;\r\n        uint256 startDay;\r\n        uint256 promiseDays;\r\n        uint256 lemClaimDay;\r\n        uint256 rewardShares;\r\n        uint256 penaltyDelta;\r\n        bool nonTransferable;\r\n        uint256 ended;\r\n        uint256 principal; // in genitos (10^9)\r\n        uint256 debtIssueRate;\r\n    }\r\n\r\n    struct PenaltyData {\r\n        uint256 eemRewardFee;\r\n        uint256 eemPrincipalFee;\r\n        uint256 eemPenalty;\r\n        uint256 lemRewardFee;\r\n        uint256 lemPrincipalFee;\r\n        uint256 lemPenalty;\r\n    }\r\n\r\n    /* ~ EVENTS STRUCTS ~ */\r\n    event Claim(\r\n        address sender,\r\n        address claimant,\r\n        uint256 amount\r\n    );\r\n\r\n    event LemRewardsClaim(\r\n        address indexed executorRewardAddress,\r\n        address owner,\r\n        uint256 minerIndex,\r\n        uint256 executorReward\r\n    );\r\n\r\n    /**\r\n     * @param  owner        the account that owned the miner at the time of end.\r\n     * @param  minerIndex   the account's index for the miner struct.\r\n     * @param  benevolence  whether this \"end\" action was for community\r\n     *                      benevolence.\r\n     *\r\n     * @param  principalPayout    The amount of Principal that was returned to\r\n     *                            the owner minus principal penalties.\r\n     * @param  totalMinerRewards  The total amount of rewards--will always be\r\n     *                            the Total PPS multiplied by the Shares.\r\n     * @param  rewardsPayout      The actual amount of rewards paid to the owner\r\n     *                            minus penalties on the rewards.\r\n     * @param  penaltyToMiners    From ending, this amount of penalties was\r\n     *                            redistributed to other Advanced Miners.\r\n     */\r\n    event EndMiner(address indexed owner, uint256 minerIndex, bool benevolence,\r\n        uint256 principalPayout, uint256 totalMinerRewards,\r\n        uint256 rewardsPayout, uint256 penaltyToMiners, Utilities.MinerCache miner);\r\n\r\n    event ShutdownMiner(address indexed minerAddress, uint256 minerIndex,\r\n        address indexed executorRewardAddress, uint256 executorReward,\r\n        uint256 performanceRewards, uint256 redistributedPenalties,\r\n        uint256 toOa, uint256 burnedForever, Utilities.MinerCache miner);\r\n\r\n    event ChangeOaGrantor(address newOaGrantor, uint256 updated);\r\n\r\n    event ChangeOaBeneficiary(address newOaBeneficiary, uint256 updated);\r\n}\r\n\r\n\r\n// File contracts/Genius.sol\r\n\r\n// License: UNLICENSED\r\n// Genius is NOT LICENSED FOR COPYING.\r\n// Genius (C) 2022. All Rights Reserved.\r\npragma solidity 0.8.4;\r\n\r\n\r\n\r\n\r\n\r\ncontract Genius is ERC20, ERC20Permit, Utilities, ReentrancyGuard {\r\n\r\n    error ErrorNullAddress();\r\n    error ErrorUnauthorized();\r\n    error ErrorCannotReleaseShares();\r\n    error ErrorCannotReleaseAuctionedShares();\r\n    error ErrorNotLaunchedYet();\r\n\r\n    struct ShutdownDataCache {\r\n        uint256 principalToRedistribute;\r\n        uint256 rewardsToRedistribute;\r\n        uint256 txPrincipalRewards;\r\n        uint256 txPerformanceRewards;\r\n    }\r\n\r\n    constructor(\r\n        address _oaGrantor,\r\n        address _oaBeneficiary\r\n    ) ERC20(\"Genius\", \"GENI\") ERC20Permit(\"Genius\") {\r\n        if (_oaGrantor == address(0) || _oaBeneficiary == address(0)) {\r\n            revert ErrorNullAddress();\r\n        }\r\n        oaGrantor = _oaGrantor;\r\n        oaBeneficiary = _oaBeneficiary;\r\n        _mint(address(this), 240000000000000000000);\r\n    }\r\n\r\n    /**\r\n     * @notice public facing pure, returns decimal precision value of genius\r\n     */\r\n    function decimals() public pure override returns (uint8) {\r\n        return GENIUS_DECIMALS;\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by oaGrantor, set oaBeneficiary address\r\n     */\r\n    function changeOaBeneficiary(address _oaBeneficiary) external {\r\n        if (_oaBeneficiary == address(0)) revert ErrorNullAddress();\r\n        if (msg.sender != oaGrantor) revert ErrorUnauthorized();\r\n        oaBeneficiary = _oaBeneficiary;\r\n        stabilityPoolContract.setOaBeneficiary(_oaBeneficiary);\r\n        emit ChangeOaBeneficiary(_oaBeneficiary, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by oaGrantor, change oaGrantor\r\n     */\r\n    function changeOaGrantor(address _newOaGrantor) external {\r\n        if (_newOaGrantor == address(0)) revert ErrorNullAddress();\r\n        if (msg.sender != oaGrantor) revert ErrorUnauthorized();\r\n        oaGrantor = _newOaGrantor;\r\n        stabilityPoolContract.setOaGrantor(_newOaGrantor);\r\n        emit ChangeOaGrantor(_newOaGrantor, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice public facing, shielded. Only OA can set the auction.\r\n     * @notice auction house must be set before auction functions are operable\r\n     */\r\n    function setAuctionContract(address _auction) external {\r\n// NOTE: OA Grantor check removed because deployment will include these \"set\"\r\n// functions.  The actual gate that will prevent the Auction Contract being\r\n// set again is the requirement that auctionAddress is not yet set.\r\n//        require(msg.sender == oaGrantor && auctionAddress == address(0), \"u\");\r\n        if (_auction == address(0)) revert ErrorNullAddress();\r\n        if (auctionAddress != address(0)) revert ErrorUnauthorized();\r\n        auctionAddress = _auction;\r\n        auctionHouse = IGeniusAuction(_auction);\r\n        stabilityPoolContract.setAuctionContract(_auction);\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by oaGrantor, set stability pool address (only callable once)\r\n     */\r\n    function setStabilityPoolAddress(address _stabilityPool) external {\r\n// NOTE: this prevents Stability Pool from being set again AFTER deployment\r\n// by ensuring that the contract address has not already been set.\r\n//        require(msg.sender == oaGrantor && stabilityPoolAddress == address(0), \"u\");\r\n        if (_stabilityPool == address(0)) revert ErrorNullAddress();\r\n        if (stabilityPoolAddress != address(0)) revert ErrorUnauthorized();\r\n        stabilityPoolAddress = _stabilityPool;\r\n        stabilityPoolContract = IStabilityPool(_stabilityPool);\r\n        // NOTE: to prevent a circular dependency, the OA Grantor will need to\r\n        // call this separately.\r\n        //auctionHouse.setStabilityContract(_stabilityPool);\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by oaGrantor, set calendar address and calls setters on calendar and auction (only callable once)\r\n     */\r\n    function setCalendarContract(address _calendar) external {\r\n// NOTE: this prevents Calendar from being set again AFTER deployment by\r\n// ensuring that the contract address has not already been set.\r\n        if (_calendar == address(0)) revert ErrorNullAddress();\r\n        if (calendarAddress != address(0)) revert ErrorUnauthorized();\r\n        calendarAddress = _calendar;\r\n        calendar = IGeniusCalendar(_calendar);\r\n        auctionHouse.setCalendarContract(_calendar);\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by oaGrantor, set penalty address and calls setters on calendar, stability pool and auction (only callable once)\r\n     */\r\n    function setPenaltyContract(address _pcAddress) external {\r\n// NOTE: this prevents Penalty from being set again AFTER deployment by\r\n// ensuring that the contract address has not already been set.  The deploy\r\n// scripts manage and ensure that this is set at launch.\r\n        if (_pcAddress == address(0)) revert ErrorNullAddress();\r\n        if (penaltyAddress != address(0)) revert ErrorUnauthorized();\r\n//        require(\r\n//            msg.sender == oaGrantor &&\r\n//            penaltyAddress == address(0) &&\r\n//            calendarAddress != address(0) &&\r\n//            stabilityPoolAddress != address(0) &&\r\n//            auctionAddress != address(0)\r\n//        , \"u\");\r\n\r\n// NOTE: combining these saves 0.111 KB.\r\n//        require(msg.sender == oaGrantor && penaltyAddress == address(0), \"u\");\r\n//        require(calendarAddress != address(0), \"1\");\r\n//        require(stabilityPoolAddress != address(0), \"2\");\r\n//        require(auctionAddress != address(0), \"3\");\r\n        penaltyContract = IPenalty(_pcAddress);\r\n        penaltyAddress = _pcAddress;\r\n        calendar.setPenaltyContract(_pcAddress);\r\n        stabilityPoolContract.setPenaltyContract(_pcAddress);\r\n        auctionHouse.setPenaltyAddress(_pcAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by oaGrantor, sets miners address and calls setters on auction, calendar and stability pool (only callable once)\r\n     */\r\n    function setMinersContract(address _minersAddress) external {\r\n// NOTE: this prevents Miners from being set again AFTER deployment by\r\n// ensuring that the contract address has not already been set.  The deploy\r\n// scripts manage and ensure that this is set at launch.\r\n//        require(msg.sender == oaGrantor && minersAddress == address(0), \"u\");\r\n        if (_minersAddress == address(0)) revert ErrorNullAddress();\r\n        if (minersAddress != address(0)) revert ErrorUnauthorized();\r\n        minersAddress = _minersAddress;\r\n        minersContract = IMiners(_minersAddress);\r\n        auctionHouse.setMinersContract(_minersAddress);\r\n        calendar.setMinersContract(_minersAddress);\r\n        stabilityPoolContract.setMinersContract(_minersAddress);\r\n        penaltyContract.setMinersContract(_minersAddress);\r\n    }\r\n\r\n    function setHexodusContract(address _hexodus) external {\r\n        if (_hexodus == address(0)) revert ErrorNullAddress();\r\n        if (msg.sender != oaGrantor || hexodusAddress != address(0)) {\r\n            revert ErrorUnauthorized();\r\n        }\r\n        hexodusAddress = _hexodus;\r\n        minersContract.setHexodusContract(_hexodus);\r\n        calendar.setHexodusContract(_hexodus);\r\n    }\r\n\r\n    /**\r\n     * @notice set up Genius NFT controller\r\n     * @dev allowed only by OA grantor or deployer\r\n     * @param _gnftAddress address of genius NFT controller\r\n     */\r\n    function setGnftContract(address _gnftAddress) external {\r\n// NOTE: GNFT will be launched after the core Genius contracts, and therefore,\r\n// it is necessary to also gate the setting of GNFT's address by limiting this\r\n// action to the OA Grantor.\r\n        if (_gnftAddress == address(0)) revert ErrorNullAddress();\r\n        if (msg.sender != oaGrantor || gnftAddress != address(0)) {\r\n            revert ErrorUnauthorized();\r\n        }\r\n        gnftAddress = _gnftAddress;\r\n        _gnftContract = IGnft(_gnftAddress);\r\n\r\n        auctionHouse.setGnftContract(_gnftAddress);\r\n        calendar.setGnftContract(_gnftAddress);\r\n        minersContract.setGnftContract(_gnftAddress);\r\n        stabilityPoolContract.setGnftContract(_gnftAddress);\r\n    }\r\n\r\n    function _currentGeniusDay() internal view returns (uint256) {\r\n        if (block.timestamp < LAUNCH_TIMESTAMP) revert ErrorNotLaunchedYet();\r\n        unchecked {\r\n            return (block.timestamp - LAUNCH_TIMESTAMP) / 1 days;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING VIEW, view function that returns the total reserved supply accounting\r\n     */\r\n    function reserveSupply() external view returns (uint256) {\r\n        unchecked {\r\n            return totalSupply() + calendar.burnedSupply() + advLockedSupply + basicLockedSupply;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Claims for initial GENI distribution\r\n     * @param destination is the claimant, based on off chain data\r\n     * @param amount claimant's amount of GENI to distribute\r\n     * @param merkleProof array of hashes up the merkleTree\r\n     * @param mintNft  The EOA's preference of whether or not to spend gas for\r\n     *                 the chance of minting an NFT.\r\n     */\r\n    function claimGenius(\r\n        address destination,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof,\r\n        bool mintNft\r\n    ) external nonReentrant {\r\n//        require(canClaim(destination, amount, merkleProof), \"I\");\r\n        if (!canClaim(destination, amount, merkleProof)) {\r\n            revert NoClaimExists();\r\n        }\r\n\r\n        claimed[destination] = true;\r\n\r\n        if (destination == msg.sender || _currentGeniusDay() < 181 ||\r\n            (block.timestamp < LAUNCH_TIMESTAMP && destination == LGENI_OA))\r\n        {\r\n            ERC20(address(this)).transfer(destination, amount);\r\n            if (mintNft) {\r\n                _gnftContract.mintNft(destination, 0);\r\n            }\r\n            emit Claim(msg.sender, destination, amount);\r\n            return;\r\n        }\r\n\r\n        // Sender may get an NFT if they opted-into minting :)\r\n        if (mintNft && _probability(msg.sender, PHI_NPOW_2, PHI_PRECISION, 0, 0)) {\r\n            _gnftContract.mintNft(msg.sender, 1);\r\n        }\r\n\r\n        unchecked {\r\n            // the msg.sender will receive 100 GENI, and the remainder goes to the\r\n            // lazy owner of the claim :)\r\n            ERC20(address(this)).transfer(msg.sender, 100000000000);\r\n            ERC20(address(this)).transfer(destination, amount - 100000000000);\r\n        }\r\n        emit Claim(msg.sender, destination, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev helper for validating if an address has GENI to claim\r\n     * @return true if claimant has not already claimed and the data is valid, false otherwise\r\n     */\r\n    function canClaim(\r\n        address destination,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof\r\n    ) public view returns (bool) {\r\n        bytes32 node = keccak256(abi.encodePacked(destination, amount));\r\n        return\r\n            !claimed[destination] &&\r\n            MerkleProof.verify(merkleProof, MERKLE_ROOT, node);\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by auction contract.  Mints Genius token.\r\n     */\r\n    function mint(address owner, uint256 amount) external {\r\n        if (msg.sender != auctionAddress) revert ErrorUnauthorized();\r\n        _mint(owner, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by stability pool, auction, miners, or hexodus.\r\n     *      Burns Genius token.\r\n     */\r\n    function burn(address owner, uint256 amount) external {\r\n        if (\r\n            msg.sender != stabilityPoolAddress &&\r\n            msg.sender != auctionAddress &&\r\n            msg.sender != minersAddress &&\r\n            msg.sender != hexodusAddress\r\n        ) {\r\n            revert ErrorUnauthorized();\r\n        }\r\n        _burn(owner, amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev INTERNAL, calculates new share rate based on eem payout\r\n     */\r\n    function _newShareRate(MinerCache memory miner, uint256 neemPayout) internal view returns(uint256 newShareRate) {\r\n        unchecked {\r\n            newShareRate = (neemPayout * PHI_PRECISION +\r\n                _min(\r\n                    neemPayout * PHI_POW_PHI,\r\n                    (neemPayout *\r\n                        _min(\r\n                            4444 * PHI_PRECISION,\r\n                            _ceiling(\r\n                                miner.promiseDays *\r\n                                    (PHI_PRECISION + PHI_NPOW_3),\r\n                                PHI_PRECISION\r\n                            ) - PHI_PRECISION\r\n                        )) /\r\n                        1456\r\n                ) +\r\n                neemPayout * _min(neemPayout * PHI_PRECISION, PHI * 10**17) / 10**18) /\r\n                miner.rewardShares /\r\n                PHI_PRECISION;\r\n            return newShareRate;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev manage share rate calculations for end miner functionality\r\n     */\r\n    function _manageSystemShares(\r\n        MinerCache memory miner,\r\n        uint256 currentGeniusDay,\r\n        uint256 eemPenalty,\r\n        uint256 lemPenalty,\r\n        uint256 rewards\r\n    ) internal {\r\n        if (miner.lemClaimDay == 0) {\r\n            if (!miner.policy) {\r\n                calendar.decBasicShares(miner.rewardShares);\r\n            } else {\r\n                calendar.decAdvShares(miner.rewardShares);\r\n            }\r\n        }\r\n        unchecked {\r\n            uint256 neemPayout = miner.principal + rewards -\r\n                (currentGeniusDay < miner.startDay + miner.promiseDays ? eemPenalty : 0);\r\n    //        uint256 neemPayout = _neemPayout(\r\n    //            miner.principal,\r\n    //            rewards,\r\n    //            currentGeniusDay,\r\n    //            miner.startDay + miner.promiseDays,\r\n    //            eemPenalty\r\n    //        ); // NEEMP - Non-Early End Mining Payout\r\n\r\n            if (neemPayout >= miner.principal) {\r\n                // calculate new Share Rate\r\n                calendar.setShareRate(_newShareRate(miner, neemPayout));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev send collateral miner payouts for ended miners\r\n     */\r\n    function _manageCollateralMinerPayouts(\r\n        address owner,\r\n        uint256 netPrincipalPayout,\r\n        uint256 netRewardsPayout,\r\n        bool benevolence\r\n    ) internal {\r\n        if (!benevolence) {\r\n            // if net principal payout > 0:\r\n            //      mint ( principal + rewards )\r\n            if (netPrincipalPayout > 0) {\r\n                unchecked {\r\n                    _mint(owner, netPrincipalPayout + netRewardsPayout);\r\n                }\r\n            }\r\n\r\n            // if net rewards payout > 0:\r\n            //      decrease burned supply ( net rewards payout )\r\n            if (netRewardsPayout > 0) {\r\n                calendar.decreaseBurnedSupply(netRewardsPayout);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev send miner payouts foe ended miners\r\n     */\r\n    function _manageMinerPayouts(\r\n        MinerCache memory miner,\r\n        address owner,\r\n        uint256 eemPrincipalFee,\r\n        uint256 lemPrincipalFee,\r\n        uint256 eemRewardFee,\r\n        uint256 lemRewardFee,\r\n        uint256 rewards,\r\n        bool benevolence\r\n    ) internal returns (uint256 netPrincipalPayout, uint256 netRewardsPayout) {\r\n        unchecked {\r\n            uint256 principalPenalties = _max(eemPrincipalFee, lemPrincipalFee + penaltyContract.calcLemClaimed(miner));\r\n            uint256 rewardPenalties = _max(eemRewardFee, lemRewardFee);\r\n            netPrincipalPayout = miner.principal > principalPenalties ? miner.principal - principalPenalties : 0;\r\n            netRewardsPayout = rewards > rewardPenalties ? rewards - rewardPenalties : 0;\r\n\r\n            if (miner.lemClaimDay == 0) {\r\n                // NOTE: the Release Shares function is responsible for moving the\r\n                // entire principal out of the Locked Supply--because that principal\r\n                // is no-longer \"locked\".  However, when LEM Claim Day is not set,\r\n                // then the Release Shares function was not called, and the miner's\r\n                // principal must be completely removed from the locked supply.\r\n\r\n                if (miner.policy) {\r\n                    // NOTE: the Principal Penalties will STILL be removed from\r\n                    // the locked supply.  In other words, the entire principal\r\n                    // must be removed.  The Lucid Chart specs were wrong;\r\n                    // remove the entire supply.\r\n                    advLockedSupply -= miner.principal;\r\n                } else {\r\n                    // NOTE: the entire principal should be removed from any of\r\n                    // the Locked supplies because the principal is no-longer\r\n                    // \"locked\".  Of course, any principal that does not get\r\n                    // \"minted\" to the EOA or OA will need to be added to the\r\n                    // Burned Supply.\r\n                    basicLockedSupply -= miner.principal;\r\n                }\r\n\r\n                if (netRewardsPayout > 0 && !benevolence) {\r\n                    calendar.decreaseBurnedSupply(netRewardsPayout);\r\n                }\r\n\r\n                // NOTE: if this is Benevolence, then is the entire principal must\r\n                // be moved over to the Burned Supply.\r\n                if (benevolence) {\r\n                    calendar.increaseBurnedSupply(miner.principal);\r\n                }\r\n                else {\r\n                    // But when the miner was not ended benevolently, then we will\r\n                    // increase the burned supply by only the principal penalties,\r\n                    // which *will not* include the LEM Claim Reward.  That reward\r\n                    // will not be included in the 'principalPenalties' calculation\r\n                    // because the lemClaimDay property is 0 :)\r\n                    calendar.increaseBurnedSupply(principalPenalties);\r\n                }\r\n            } else {\r\n                // WARNING: in this scope, the shares were released by the Release\r\n                // Shares function, and therefore, all principal (minus the LEM\r\n                // Claim Reward) was already moved over to the Burned Supply.\r\n\r\n                // THEREFORE: we will not increase the Burned Supply here.  We will\r\n                // only decrease the burned supply by the amount of principal and\r\n                // rewards that get removed from the Burned Supply.\r\n\r\n                // NOTE: When a non-collateral miner ends, if the shares were\r\n                // released, like in this conditional scope, then the entire\r\n                // principal was already unlocked and moved over to the burned\r\n                // supply.  Therefore, we need to remove any principal (and rewards)\r\n                // that will be minted out of the Burned Supply.\r\n                calendar.decreaseBurnedSupply(netPrincipalPayout + netRewardsPayout);\r\n            }\r\n\r\n            // NOTE: all \"penalized principal\" must move over to the Burned Supply,\r\n            // except for the LEM Claim Reward, because that was given to the EOA\r\n            // that called the Release Shares function.  Furthermore, the payout\r\n            // accounting is handled automatically by _mint -- Total Supply will be\r\n            // increased, and the amount increased was already removed, or not added\r\n            // to, the Burned Supply in the scope, above.\r\n\r\n            if (!benevolence && netPrincipalPayout + netRewardsPayout > 0) {\r\n                _mint(owner, netPrincipalPayout + netRewardsPayout);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev extended logic for endMiner() function\r\n     * @param  owner  the owner of the miner -- it is the responsibility of the\r\n     *                external functions that call this function to provide end\r\n     *                user security.  Only the msg sender can end a miner.\r\n     * @param  minerIndex   miner index\r\n     * @param  rewards      all performance rewards earned during this miner's\r\n     *                      serving period.\r\n     * @param  benevolence  is this miner ending for the sake of benevolence?\r\n     *                      then anything minted will be burned.\r\n     * @param  mintNft      end user opt-in to spend gas and possibly get an NFT\r\n     */\r\n    function _endMinerDeep(address owner, uint256 minerIndex, uint256 rewards, bool benevolence, bool mintNft) internal\r\n        returns (\r\n            uint256 netPrincipalPayout, uint256 netRewardsPayout, uint256 penaltyToMiners\r\n        ) {\r\n        MinerCache memory miner = minersContract.minerStore(owner, minerIndex);\r\n        unchecked {\r\n            uint256 currentGeniusDay = _currentGeniusDay();\r\n            uint256 servedDays = (\r\n                currentGeniusDay < (miner.startDay + miner.promiseDays)\r\n                    ? currentGeniusDay\r\n                    : (miner.startDay + miner.promiseDays)\r\n                ) - miner.startDay;\r\n\r\n            // EM_03\r\n            PenaltyData memory ptData = penaltyContract.endMinerPenalties(miner, servedDays, currentGeniusDay, rewards);\r\n\r\n            // EM_04\r\n            if (servedDays < miner.promiseDays) {\r\n                // @dev miner is ending early.\r\n                penaltyToMiners = _redistribution(miner, rewards, ptData.eemPrincipalFee, ptData.eemRewardFee);\r\n\r\n                if (mintNft) {\r\n                    if (_probability(owner, PHI / (miner.policy ? 10 : 100),\r\n                        PHI_PRECISION, miner.principal, 0))\r\n                    {\r\n                        _gnftContract.mintNft(owner, 1);\r\n                    }\r\n                    else if (benevolence &&\r\n                        _probability(owner, PHI_PRECISION, PHI_PRECISION, miner.principal, 2))\r\n                    {\r\n                        _gnftContract.mintNft(owner, 1);\r\n                    }\r\n                }\r\n            } else {\r\n                if (currentGeniusDay > miner.startDay + miner.promiseDays + 7) {\r\n                    // @dev miner ended late and will serve late penalties.\r\n                    penaltyToMiners = _redistribution(miner, rewards, ptData.lemPrincipalFee, ptData.lemRewardFee);\r\n\r\n                    if (mintNft) {\r\n                        bool minted = false;\r\n                        if (benevolence) {\r\n                            if (_probability(owner, PHI / 10, PHI_PRECISION, miner.principal, 10)) {\r\n                                _gnftContract.mintNft(owner, 11);\r\n                                minted = true;\r\n                            }\r\n                        }\r\n\r\n                        if (!minted) {\r\n                            if (_probability(owner, PHI / (miner.policy ? 10 : 100),\r\n                                PHI_PRECISION, miner.principal, 0))\r\n                            {\r\n                                _gnftContract.mintNft(owner, 1);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    // @dev miner ended on time, as promised by the EOA.\r\n\r\n                    // if the EOA opted-in to mint an NFT...\r\n                    if (mintNft) {\r\n                        // if this miner had 90 or more promise days...\r\n                        if (miner.promiseDays > 89) {\r\n                            // NOTE: if someone created a BASIC miner w/ 89 Promise\r\n                            // Days on Day 0, then they get a free day and free NFT\r\n                            // ...lucky!! :D\r\n                            if (_probability(owner, PHI_PRECISION, PHI_PRECISION,\r\n                                miner.principal, 0))\r\n                            {\r\n                                _gnftContract.mintNft(owner, 1);\r\n                            }\r\n\r\n                            // ALSO NOTE: if this end is a result of benevolence,\r\n                            // then there will be another round of chance.\r\n                            if (benevolence) {\r\n                                if (_probability(owner, PHI_PRECISION, PHI_PRECISION,\r\n                                    miner.principal, 3))\r\n                                {\r\n                                    _gnftContract.mintNft(owner, 4);\r\n                                }\r\n                            }\r\n                        }\r\n                        else if (_probability(owner, PHI / 100, PHI_PRECISION,\r\n                            miner.principal, 0))\r\n                        {\r\n                            // Promise days will be < 90, and therefore this must be a\r\n                            // Basic Miner.\r\n                            _gnftContract.mintNft(owner, 1);\r\n                        }\r\n                        else if (benevolence && _probability(\r\n                            owner, PHI_PRECISION, PHI_PRECISION, miner.principal, 20))\r\n                        {\r\n                            // if this condition is met, then this is a basic miner\r\n                            // that was Proof Of Benevolence'd.\r\n                            _gnftContract.mintNft(owner, 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // EM_05 Manage System Shares\r\n            _manageSystemShares(\r\n                miner,\r\n                currentGeniusDay,\r\n                ptData.eemPenalty,\r\n                ptData.lemPenalty,\r\n                rewards\r\n            );\r\n\r\n            if (miner.debtIssueRate > 0) {\r\n                // EM_06B Manage Collateral Payouts\r\n                (netPrincipalPayout, netRewardsPayout) = _manageCollateralPayouts(\r\n                    miner, owner, minerIndex, rewards,\r\n                    ptData.lemPrincipalFee, ptData.lemRewardFee, benevolence);\r\n            } else {\r\n                // EM_06A Manage Payouts\r\n                // uint256 principalPenalties = _max(eemPrincipalFee, lemPrincipalFee + lemClaimed);\r\n                // address localOwner = owner;\r\n                uint256 rewards = rewards;\r\n                bool benevolence = benevolence;\r\n                (netPrincipalPayout, netRewardsPayout) = _manageMinerPayouts(\r\n                    miner,\r\n                    owner,\r\n                    ptData.eemPrincipalFee,\r\n                    ptData.lemPrincipalFee,\r\n                    ptData.eemRewardFee,\r\n                    ptData.lemRewardFee,\r\n                    rewards,\r\n                    benevolence\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function _manageCollateralPayouts(\r\n        MinerCache memory _miner,\r\n        address _owner,\r\n        uint256 _minerIndex,\r\n        uint256 _rewards,\r\n        uint256 _principalPenalties,\r\n        uint256 _rewardPenalties,\r\n        bool _benevolence\r\n    ) internal returns (uint256 netPrincipalPayout, uint256 netRewardsPayout) {\r\n\r\n        unchecked {\r\n            uint256 rewardPenalties = _min(_rewards, _principalPenalties + _rewardPenalties);\r\n            uint256 currentGeniusDay = _currentGeniusDay();\r\n\r\n            // EM_06B\r\n            if (_miner.lemClaimDay == 0) {\r\n                advLockedSupply -= _miner.principal;\r\n            }\r\n\r\n            /*\r\n                Utilities.MinerCache calldata miner,\r\n                address minerOwner,\r\n                uint256 minerIndex,\r\n                address beneficiary,\r\n                uint256 currentGeniusDay,\r\n                bool benevolent\r\n            */\r\n            address owner = _owner;\r\n            uint256 minerSettlementAmount = stabilityPoolContract.clearGeniusDebt(\r\n                _miner, owner, _minerIndex, owner,\r\n                currentGeniusDay, _benevolence);\r\n    //        netPrincipalPayout = availablePrincipal > minerSettlementAmount ? availablePrincipal - minerSettlementAmount : 0;\r\n            netPrincipalPayout = _miner.principal > minerSettlementAmount ?\r\n                _miner.principal - minerSettlementAmount : 0;\r\n\r\n            // NOTE: _rewardPenalties is what was passed as a parameter, it is NOT\r\n            // the recalculated local variable.  Use the local variable that was a\r\n            // recalculation of the Reward Penalties.\r\n            netRewardsPayout = _rewards - rewardPenalties;\r\n            _manageCollateralMinerPayouts(owner, netPrincipalPayout, netRewardsPayout, _benevolence);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev handle miner end functionalities\r\n     * @param  minerIndex   index of the miner\r\n     * @param  benevolence  is the miner benevolenced?\r\n     * @param  mintNft      end user opt-in to spend gas and possibly get an NFT\r\n     */\r\n    function endMiner(\r\n        uint256 minerIndex,\r\n        bool benevolence,\r\n        bool mintNft\r\n    ) external nonReentrant {\r\n        MinerCache memory miner = minersContract.minerStore(msg.sender, minerIndex);\r\n        unchecked {\r\n            uint256 currentGeniusDay = _currentGeniusDay();\r\n\r\n            // Promise End Day = miner.startDay + miner.promiseDays\r\n            // Served Days = MIN(Current Genius Day, Promise End Day) - miner.startDay\r\n            // NOTE: if the miner index is invalid, then the \"servedDays\" value will\r\n            // result in 0.\r\n            uint256 servedDays = (\r\n                currentGeniusDay < (miner.startDay + miner.promiseDays)\r\n                    ? currentGeniusDay\r\n                    : (miner.startDay + miner.promiseDays)\r\n            ) - miner.startDay;\r\n\r\n            // Start EM_01\r\n            minersContract.checkMinerForEnd(\r\n                miner,\r\n                msg.sender,\r\n                minerIndex,\r\n                currentGeniusDay,\r\n                servedDays\r\n            );\r\n\r\n            // Start Phase EM_02 Summarize Served Days\r\n            //uint256 lastServedDay = miner.startDay + servedDays - 1;\r\n            uint256 lastSummarizedDay = calendar.geniusDay() - 1;\r\n\r\n            // if the miner is ending early OR the miner is ending beyond the grace period...\r\n            if (servedDays < miner.promiseDays || miner.startDay + miner.promiseDays + 7 <= currentGeniusDay) {\r\n                //calendar.localSummarizeGeniusDay(_currentGeniusDay() - lastServedDay, msg.sender);\r\n                //calendar.localSummarizeGeniusDay(_currentGeniusDay() - (miner.startDay + servedDays - 1), msg.sender);\r\n\r\n                calendar.localSummarizeGeniusDay(0, msg.sender, mintNft);\r\n                calendar.local10daySummary(0, msg.sender, mintNft);\r\n                calendar.local100daySummary(0, msg.sender, mintNft);\r\n                calendar.local1000daySummary(0, msg.sender, mintNft);\r\n            }\r\n            else {\r\n                // NOTE: when the miner ends \"on-time\", we won't catch-up and\r\n                // summarize every single day, 10-day, 100-day, and 1,000-day\r\n                // period summary.  Instead, since the owner of the miner was a\r\n                // \"good end user\" and did the \"good thing\" by ending on-time, we\r\n                // will only summarize the days and periods that enclose the days\r\n                // served.\r\n                //\r\n                // Therefore, we must do this before we calculate the Total PPS and\r\n                // rewards:\r\n                //\r\n                // 1) summarize all single-day summaries: only summarize the served\r\n                //    days that have not yet been summarized.\r\n                //if (lastServedDay > lastSummarizedDay) {\r\n                uint256 lastServedDay = miner.startDay + servedDays - 1;\r\n                if (lastServedDay > lastSummarizedDay) {\r\n                    //calendar.localSummarizeGeniusDay(lastServedDay - lastSummarizedDay, msg.sender);\r\n                    calendar.localSummarizeGeniusDay(\r\n                        lastServedDay - lastSummarizedDay,\r\n                        msg.sender,\r\n                        mintNft\r\n                    );\r\n                }\r\n\r\n                // 2) Summarize all full 10-day periods within the SERVED DAYS.\r\n                //    Therefore, if the miner served all days (including) 100-415\r\n                //    and we realize that the only 10-day summaries that exist are\r\n                //    for all days prior to 390, then we must create the 10-day\r\n                //    summary for 390-399 (index 39) and 400-409 (index 40).\r\n                //    Summary 410-419 (index 41) WILL NOT BE CREATED because the\r\n                //    miner did not serve the entire period of days 410-419; that\r\n                //    miner only served days 410-415.  We also won't summarize the\r\n                //    index 41 to save the end user gas :)  And because the end user\r\n                //    does not need index 41 to calculate their Total PPS.\r\n                    // Dai Proving the calculation of index and full period\r\n                    // Summaring example and index and period change\r\n                    // startDay = 0, servedDays = 10, lastServedDay = 9 =>\r\n                    //      10summary index 0, period 1\r\n                    //      100summary index 0, period 1\r\n                    //      1000summary index 0, period 1\r\n                    // startDay = 0, servedDays = 100, lastServedDay = 99 =>\r\n                    //      10summary index 9, period 10\r\n                    //      100summary index 9, period 0\r\n                    //      1000summary index 9, period 0\r\n                    // ... ...\r\n                    // start day = 100, servedDays = 316 lastServedDay = startDay + servedDays - 1 = 415 =>\r\n                    //      10summary index 41, period 42\r\n                    //      100summary index 4, period 5\r\n                    //      1000summary index 0, period 0\r\n                    // Generalizing....\r\n                    // maxXIndex = (miner.startDay +servedDays - 1) / X-days;\r\n                    // maxXPeriod = max10Index + 1 = (miner.startDay +servedDays - 1) / X-days + 1;\r\n                    // actualXPeriod = maxXPeriod - 1 = (miner.startDay +servedDays - 1) / X-days + 1 - 1 = (miner.startDay +servedDays - 1) / X-days\r\n                    calendar.local10daySummary(lastServedDay / 10, msg.sender, mintNft);\r\n\r\n                // 3) Just like with the 10-day periods, we must summarize all\r\n                //    100-day periods that the miner needs to calculate the Total\r\n                //    PPS / rewards, properly.\r\n                    calendar.local100daySummary(lastServedDay / 100, msg.sender, mintNft);\r\n\r\n                // 4) And then, finally, we must make sure that all 1,000-day\r\n                //    periods within the SERVED DAYS are summarized.\r\n                    calendar.local1000daySummary(lastServedDay / 1000, msg.sender, mintNft);\r\n            }\r\n\r\n            //calendar.minerTotalPps(miner.startDay, lastServedDay, miner.policy)\r\n            uint256 totalMinerPps = calendar.minerTotalPps(miner.startDay, (miner.startDay + servedDays - 1), miner.policy);\r\n            uint256 rewards = miner.rewardShares * totalMinerPps / SHARE_PRECISION;\r\n\r\n            // End Phase EM_02\r\n            (\r\n                uint256 netPrincipalPayout,\r\n                uint256 netRewardsPayout,\r\n                uint256 penaltyToMiners\r\n            )\r\n            = _endMinerDeep(msg.sender, minerIndex, rewards, benevolence, mintNft);\r\n            MinerCache memory miner2 = miner;\r\n            emit EndMiner(msg.sender, minerIndex, benevolence,\r\n                netPrincipalPayout, rewards,\r\n                netRewardsPayout, penaltyToMiners, miner2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev calculates late end mining penalties\r\n     */\r\n    function _penaltiesLem(\r\n        uint256 geniusDay,\r\n        uint256 promiseEndDay,\r\n        uint256 principal,\r\n        uint256 penalties,\r\n        bool policy\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 lateDays = geniusDay - promiseEndDay - 7;\r\n            uint256 min;\r\n\r\n            if (!policy) {\r\n                uint256 ceil = (principal * PHI * 100) / (7 * PHI_PRECISION);\r\n                ceil =\r\n                    ((ceil + GENIUS_PRECISION) - GENIUS_PRECISION) *\r\n                    GENIUS_PRECISION;\r\n                min = ceil > principal ? principal : ceil;\r\n            } else {\r\n                uint256 ceil = (principal * PHI_POW_2 * 100) / (7 * PHI_PRECISION);\r\n                ceil =\r\n                    ((ceil + GENIUS_PRECISION) - GENIUS_PRECISION) *\r\n                    GENIUS_PRECISION;\r\n                min = ceil > principal ? principal : ceil;\r\n            }\r\n            return (penalties / 1000) - (lateDays * min);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev mint amount stored in oaMintableBalance to the oaBeneficiary\r\n     */\r\n    function claimLostMintBonus() external nonReentrant {\r\n// NOTE: converting this to a revert saves ... only 2 bytes :(\r\n//        require(\r\n//            msg.sender == oaGrantor &&\r\n//            _currentGeniusDay() > 31 &&\r\n//            oaMintableBalance > 0\r\n//        , \"u\");\r\n        if (msg.sender != oaGrantor ||\r\n            _currentGeniusDay() < 32 ||\r\n            oaMintableBalance == 0)\r\n        {\r\n            revert UnauthorizedLostBonusClaiming();\r\n        }\r\n\r\n// NOTE: combining these saves 0.039 KB\r\n//        require(msg.sender == oaGrantor, \"u\");\r\n//        require(_currentGeniusDay() > 31 && oaMintableBalance > 0, \"o\");\r\n        _mint(oaBeneficiary, oaMintableBalance);\r\n        oaMintableBalance = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by miners, increase oaMintableBalance\r\n     */\r\n    function incOaMintableBalance(uint256 bonusLostForever) external {\r\n        if (msg.sender != minersAddress) revert ErrorUnauthorized();\r\n        oaMintableBalance += bonusLostForever;\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING, executes releaseShares core functionality (releases shares from pool)\r\n     * @param  owner    owner of the miner that has the shares to be released.\r\n     * @param  minerId  the INDEX of the owner's miner\r\n     * @param  mintNft  end user opt-in to spend gas and possibly get an NFT\r\n     */\r\n    function releaseShares(address owner, uint256 minerId, bool mintNft) external nonReentrant {\r\n        /*\r\n            Inspect the lucid chart spec carefully, and be sure to update the flow and implementation of the RED TEXT AREAS.\r\n            https://lucid.app/lucidchart/f1a1439e-e956-4a2c-be2f-e5dba66cc6a5/edit?view_items=0ccNMa7ilC91&invitationId=inv_5b23c2b2-e19b-434c-b6a4-9fcc5f90496c#\r\n\r\n            For accounting references, check out the \"Release Shares Burning Principal\" sub-sheet.\r\n            https://docs.google.com/spreadsheets/d/16JXDzM2PwEOQD-324uwTPVYQbhWbUWnavtKcusaWjzs/edit?usp=sharing\r\n         */\r\n        // Require: Miner Ended is False\r\n        MinerCache memory miner = minersContract.minerStore(owner, minerId);\r\n        unchecked {\r\n    // NOTE: combining the 3 requires below saves 0.078 KB.\r\n    //        require(miner.ended == 0, \"f\");\r\n\r\n            // Require: Miner LEM Claim Day == 0\r\n    //        require(miner.lemClaimDay == 0, \"L\");\r\n\r\n            uint256 promiseEndDay = miner.startDay + miner.promiseDays;\r\n            uint256 cgd = _currentGeniusDay();\r\n\r\n            // Require: CGD >= Promise End Day\r\n    //        require(cgd >= promiseEndDay, \"E\");\r\n            if (miner.auctioned && miner.nonTransferable) {\r\n                revert ErrorCannotReleaseAuctionedShares();\r\n            }\r\n            if (\r\n                miner.ended > 0 ||\r\n                miner.lemClaimDay > 0 ||\r\n                cgd < promiseEndDay ||\r\n                miner.promiseDays == 0\r\n            ) {\r\n                revert ErrorCannotReleaseShares();\r\n            }\r\n\r\n            // Set the Miner LEM Claim Day to CGD\r\n            minersContract.setMinerStoreLemClaimDay(owner, minerId, cgd);\r\n\r\n            // Calculate Daily Late Fee\r\n            uint256 ceil;\r\n            if (miner.policy) {\r\n                // Need to consider PHI precision\r\n                ceil = _ceiling(miner.principal * PHI_POW_2 / 7 / 100, PHI_PRECISION) / PHI_PRECISION;\r\n            } else {\r\n                // Need to consider PHI precision\r\n                ceil = _ceiling(miner.principal * PHI / 7 / 100, PHI_PRECISION) / PHI_PRECISION;\r\n            }\r\n\r\n            // Calculate the LEM Release Reward\r\n\r\n            // lemReleaseReward = MIN(principal, lateDayCount * dailyLateFee)\r\n            // NOTE: dailyLateFee = MIN(principal, CEILING(calculation here))\r\n            uint256 lemReleaseReward = _min(miner.principal, (cgd > promiseEndDay + 7 ? cgd - promiseEndDay - 7 : 0)\r\n                * _min(miner.principal, ceil));\r\n\r\n            // Check if the miner is under auction and the auction has zero bids.\r\n            if (miner.auctioned) {\r\n                if (auctionHouse.verifyAuctionNoBid(owner, minerId)) {\r\n                    auctionHouse.cancelAuction(owner, minerId);\r\n                }\r\n            }\r\n\r\n            // Enforce that at least the first day of the miner was summarized.\r\n            // This prevents a possible underflow when removing the shares from the\r\n            // calendar's share pool.\r\n            uint256 gDay = calendar.geniusDay();\r\n            if (gDay < miner.startDay + 1) {\r\n                calendar.localSummarizeGeniusDay(miner.startDay + 1 - gDay, msg.sender, mintNft);\r\n            }\r\n\r\n            if (miner.policy) {\r\n                advLockedSupply -= miner.principal;\r\n                calendar.decAdvShares(miner.rewardShares);\r\n            } else {\r\n                basicLockedSupply -= miner.principal;\r\n                calendar.decBasicShares(miner.rewardShares);\r\n            }\r\n\r\n            uint256 minerSettlementAmount;\r\n            if (miner.debtIssueRate > 0) {\r\n                if (lemReleaseReward > 0) {\r\n                    address colToken = stabilityPoolContract.getMinerColAddress(owner, minerId);\r\n                    minerSettlementAmount =\r\n                        stabilityPoolContract.settleGeniusDebt(msg.sender, colToken, lemReleaseReward, cgd - miner.startDay, false);\r\n                    lemReleaseReward = _min(minerSettlementAmount, lemReleaseReward);\r\n                }\r\n            } else {\r\n                calendar.increaseBurnedSupply(miner.principal > lemReleaseReward ? miner.principal - lemReleaseReward : 0);\r\n                if (lemReleaseReward > 0) {\r\n                    _mint(msg.sender, lemReleaseReward);\r\n                }\r\n            }\r\n\r\n            if (mintNft && _probability(msg.sender, PHI_NPOW_3, PHI_PRECISION, 0, 0)) {\r\n                _gnftContract.mintNft(msg.sender, 1);\r\n            }\r\n\r\n            // By checking the event param, we can have people know that if there is no debt to settle, they actually get no reward.\r\n            emit LemRewardsClaim(msg.sender, owner, minerId, lemReleaseReward);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev round up or ceil a number with the precision specified.\r\n     * @param a number to be rounded up or ceiled\r\n     * @param m precision (10^x, where x >= 0) of ceiling the number\r\n     * @return ceiled value\r\n     */\r\n    function _ceiling(uint256 a, uint256 m) internal pure returns (uint256) {\r\n        //return ((a + m - 1) / m) * m;\r\n        unchecked {\r\n            return (a / m + (a % m == 0 ? 0 : 1)) * m;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev compare two numbers and return smaller one.\r\n     * @param a number a\r\n     * @param b number b\r\n     * @return smaller value\r\n     */\r\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev compare two numbers and return greater one.\r\n     * @param a number a\r\n     * @param b number b\r\n     * @return greater value\r\n     */\r\n    function _max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev PUBLIC FACING, executes shutdownMiner core functionality\r\n     * @param owner owner of the miner\r\n     * @param minerId ID(index) of the miner\r\n     */\r\n    function shutdownMiner(address owner, uint256 minerId, bool mintNft)\r\n        external nonReentrant\r\n    {\r\n        MinerCache memory miner = minersContract.minerStore(owner, minerId);\r\n        unchecked {\r\n            // First Late Day = Start Day + Promise Days + 7\r\n            uint256 forcedShutdownDay = miner.policy ?\r\n                miner.startDay + miner.promiseDays + 275 :\r\n                miner.startDay + miner.promiseDays + 440;\r\n\r\n            if (\r\n                _currentGeniusDay() < forcedShutdownDay ||\r\n                miner.ended > 0 ||\r\n                miner.auctioned ||\r\n                miner.promiseDays == 0\r\n            ) {\r\n                revert CannotShutdown();\r\n            }\r\n\r\n            ShutdownDataCache memory shutdownData =\r\n                _shutdownMiner(miner, owner, minerId, forcedShutdownDay, mintNft);\r\n\r\n            if (mintNft && _probability(msg.sender, PHI_NPOW_3, PHI_PRECISION, 0, 0)) {\r\n                _gnftContract.mintNft(msg.sender, 1);\r\n            }\r\n\r\n            _mintTokenToOa(owner, minerId, shutdownData.principalToRedistribute,\r\n                shutdownData.rewardsToRedistribute, shutdownData.txPrincipalRewards,\r\n                shutdownData.txPerformanceRewards, miner);\r\n        }\r\n    }\r\n\r\n    function _shutdownMiner(\r\n        MinerCache memory miner,\r\n        address owner,\r\n        uint256 minerId,\r\n        uint256 forcedShutdownDay,\r\n        bool mintNft\r\n    ) private returns (ShutdownDataCache memory shutdownData) {\r\n        // Set Miner \"ended\" to the current time\r\n        minersContract.setMinerEnded(owner, minerId, block.timestamp);\r\n        miner.ended = block.timestamp;\r\n        penaltyContract.decMinerPopulation(miner.principal);\r\n        uint256 lemClaimed = penaltyContract.calcLemClaimed(miner);\r\n\r\n        // Before we calculate the rewards, we need to be sure that all\r\n        // SERVED DAYS are Summarized.\r\n        //\r\n        // Then we must make sure all 10-day periods within the SERVED DAYS\r\n        // are also summarized.\r\n        //\r\n        // Then we must make sure all 100-day periods within the SERVED DAYS\r\n        // are summarized.\r\n        //\r\n        // And then, finally, we must make sure that all 1,000-day periods\r\n        // within the SERVED DAYS are summarized.\r\n        calendar.summarizeServedDays(msg.sender, miner.startDay,\r\n            miner.promiseDays, mintNft);\r\n        unchecked {\r\n            uint256 netPrincipal = miner.principal > lemClaimed ? miner.principal - lemClaimed : 0;\r\n            uint256 rewards = miner.rewardShares *\r\n                calendar.minerTotalPps(miner.startDay, miner.startDay + miner.promiseDays - 1, miner.policy)\r\n                / SHARE_PRECISION;\r\n            uint256 netPayout = netPrincipal + rewards;\r\n\r\n            // Start Phase EM_04\r\n            _manageShutdownMinerShares(miner, forcedShutdownDay, rewards);\r\n            // End Phase EM_04\r\n\r\n            uint256 maxTxRewards = netPayout * PHI_NPOW_3 / PHI_PRECISION;\r\n            shutdownData.txPrincipalRewards = _min(netPrincipal, maxTxRewards);\r\n\r\n            if (miner.debtIssueRate > 0) {\r\n                /*\r\n                    Utilities.MinerCache calldata miner,\r\n                    address minerOwner,\r\n                    uint256 minerIndex,\r\n                    address beneficiary,\r\n                    uint256 currentGeniusDay,\r\n                    bool benevolent\r\n                */\r\n\r\n                MinerCache memory miner2  = miner;\r\n                bool mintNft2 = mintNft;\r\n                address owner2 = owner;\r\n                uint256 minerId2 = minerId;\r\n\r\n                uint256 txSettledRewards = stabilityPoolContract.settleGeniusDebt(\r\n                    msg.sender,\r\n                    stabilityPoolContract.getMinerColAddress(owner2, minerId2),\r\n                    shutdownData.txPrincipalRewards,\r\n                    _currentGeniusDay() - miner2.startDay,\r\n                    mintNft2\r\n                );\r\n\r\n                uint256 minerDebtCleared = stabilityPoolContract.clearGeniusDebt(\r\n                    miner2, owner2, minerId2, address(0),\r\n                    _currentGeniusDay(), true);\r\n\r\n                shutdownData.txPerformanceRewards = maxTxRewards > txSettledRewards ? maxTxRewards - txSettledRewards : 0;\r\n                shutdownData.txPrincipalRewards -= txSettledRewards;\r\n                // shutdownData.principalToRedistribute = netPrincipal - txSettledRewards - minerDebtCleared -\r\n                // (shutdownData.txPrincipalRewards - txSettledRewards)\r\n                // = netPrincipal - minerDebtCleared - shutdownData.txPrincipalRewards\r\n                // it might be underflow\r\n                uint256 totalSub = txSettledRewards + minerDebtCleared + shutdownData.txPrincipalRewards;\r\n                if (netPrincipal > totalSub) {\r\n                    shutdownData.principalToRedistribute = netPrincipal - totalSub;\r\n                    calendar.increaseBurnedSupply(shutdownData.principalToRedistribute);\r\n                } else {\r\n                    shutdownData.principalToRedistribute = 0;\r\n                }\r\n                shutdownData.rewardsToRedistribute = rewards > shutdownData.txPerformanceRewards ? rewards - shutdownData.txPerformanceRewards : 0;\r\n\r\n                if (miner2.lemClaimDay == 0) {\r\n                    if (miner2.policy) {\r\n                        advLockedSupply -= miner2.principal;\r\n                    } else {\r\n                        basicLockedSupply -= miner2.principal;\r\n                    }\r\n                }\r\n            } else { // Debt Issue Rate == 0\r\n                shutdownData.txPerformanceRewards = maxTxRewards > netPrincipal ? maxTxRewards - netPrincipal : 0;\r\n                shutdownData.principalToRedistribute = netPrincipal > shutdownData.txPrincipalRewards ? netPrincipal - shutdownData.txPrincipalRewards : 0;\r\n                shutdownData.rewardsToRedistribute = rewards > shutdownData.txPerformanceRewards ? rewards - shutdownData.txPerformanceRewards : 0;\r\n\r\n                if (miner.lemClaimDay == 0)  {\r\n                    calendar.increaseBurnedSupply(miner.principal);\r\n                    if (miner.policy) {\r\n                        advLockedSupply -= miner.principal;\r\n                    } else {\r\n                        basicLockedSupply -= miner.principal;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function _mintTokenToOa(\r\n        address owner,\r\n        uint256 minerId,\r\n        uint256 principalToRedistribute,\r\n        uint256 rewardsToRedistribute,\r\n        uint256 txPrincipalRewards,\r\n        uint256 txPerformanceRewards,\r\n        MinerCache memory miner\r\n    ) private {\r\n        unchecked {\r\n            uint256 totalPenalties = principalToRedistribute + rewardsToRedistribute;\r\n            uint256 redistributedPenalties = totalPenalties * PHI_PRECISION / PHI;\r\n            calendar.incDailyPenalties(redistributedPenalties);\r\n            uint256 toOa = totalPenalties - redistributedPenalties - (totalPenalties * PHI_NPOW_3 / PHI_PRECISION);\r\n            uint256 resurrection = toOa + txPrincipalRewards + txPerformanceRewards;\r\n\r\n            if (resurrection > 0) {\r\n                calendar.decreaseBurnedSupply(resurrection);\r\n            }\r\n\r\n            if (toOa > 0) {\r\n                _mint(oaBeneficiary, toOa);\r\n            }\r\n\r\n            // we will not check if txPerf + txPrinc is > 0 because if this is the\r\n            // case, then the miner was likely a stale, \"dust\" miner with not much\r\n            // principal and likely zero earnings.\r\n            _mint(msg.sender, txPerformanceRewards + txPrincipalRewards);\r\n\r\n            emit ShutdownMiner(owner, minerId, msg.sender,\r\n                txPrincipalRewards, txPerformanceRewards,\r\n                redistributedPenalties, toOa, (totalPenalties * PHI_NPOW_3 / PHI_PRECISION),\r\n                miner\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev INTERNAL, helper function used in shutdownMiner()\r\n     */\r\n    function _manageShutdownMinerShares(\r\n        MinerCache memory miner, uint256 forcedShutdownDay, uint256 rewards\r\n    ) internal {\r\n        if (miner.lemClaimDay == 0) {\r\n            if (!miner.policy) {\r\n                calendar.decBasicShares(miner.rewardShares);\r\n            } else {\r\n                calendar.decAdvShares(miner.rewardShares);\r\n            }\r\n        }\r\n        unchecked {\r\n            calendar.setShareRate(_newShareRate(miner, miner.principal + rewards));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by calendar, mint summary rewards calculated by\r\n     * summarize functions in calendar.\r\n     */\r\n    function mintSummaryReward(address _to, uint256 _amount) external {\r\n        if (msg.sender != calendarAddress) {\r\n            revert ErrorUnauthorized();\r\n        }\r\n        _mint(_to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by Penalty contract, advLockedSupply accounting.\r\n     */\r\n    function decAdvLockedSupply(uint256 _amount) external {\r\n        if (msg.sender != penaltyAddress) revert ErrorUnauthorized();\r\n        unchecked { advLockedSupply -= _amount; }\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by Penalty contract, basicLockedSupply accounting.\r\n     */\r\n    function decBasicLockedSupply(uint256 _amount) external {\r\n        if (msg.sender != penaltyAddress) revert ErrorUnauthorized();\r\n        unchecked { basicLockedSupply -= _amount; }\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by Miners contract, advLockedSupply accounting.\r\n     */\r\n    function incAdvLockedSupply(uint256 _amount) external {\r\n        if (msg.sender != minersAddress) revert ErrorUnauthorized();\r\n        unchecked { advLockedSupply += _amount; }\r\n    }\r\n\r\n    /**\r\n     * @dev only callable by Miners contract, basicLockedSupply accounting.\r\n     */\r\n    function incBasicLockedSupply(uint256 _amount) external {\r\n        if (msg.sender != minersAddress) revert ErrorUnauthorized();\r\n        unchecked { basicLockedSupply += _amount; }\r\n    }\r\n\r\n    /**\r\n     * @dev only called by the End Miner functionality; this redistributes\r\n     * fees incurrred for ending the miner.\r\n     * @param rewards the performance earnings of the miner.\r\n     * @param principalPenalties penalties applied to the principal.\r\n     * @param rewardPenalties penalties applied to the rewards.\r\n     * @return redistributedPenalties the amount of penalties that will be\r\n     * redistributed to Advanced Miners that are currently active.\r\n     */\r\n    function _redistribution(\r\n        MinerCache memory miner,\r\n        uint256 rewards,\r\n        uint256 principalPenalties,\r\n        uint256 rewardPenalties\r\n    ) internal returns (uint256 redistributedPenalties) {\r\n        unchecked {\r\n            uint256 totalPenalties;\r\n            if (miner.debtIssueRate > 0) {\r\n                totalPenalties = _min(rewards, principalPenalties + rewardPenalties);\r\n                rewardPenalties = totalPenalties;\r\n                principalPenalties = 0;\r\n            } else {\r\n                if (miner.lemClaimDay == 0) {\r\n                    if (miner.policy) {\r\n                        advLockedSupply -= principalPenalties;\r\n                    } else {\r\n                        basicLockedSupply -= principalPenalties;\r\n                    }\r\n                    calendar.increaseBurnedSupply(principalPenalties);\r\n                }\r\n                totalPenalties = principalPenalties + rewardPenalties;\r\n            }\r\n\r\n            redistributedPenalties = totalPenalties * PHI_PRECISION / PHI;\r\n            calendar.incDailyPenalties(redistributedPenalties);\r\n            uint256 oaReceivingAmount = totalPenalties - redistributedPenalties\r\n                - totalPenalties * PHI_NPOW_3 / PHI_PRECISION;\r\n\r\n            _mint(oaBeneficiary, oaReceivingAmount);\r\n            calendar.decreaseBurnedSupply(oaReceivingAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev   Calculates a secure-ish random 256-bit number for GENFTs.\r\n     *        These are the motivations and purposes behind each parameter to\r\n     *        calculate the random number:\r\n     *\r\n     *        1. salt: each function that initially invokes the first\r\n     *           _probability / _random functions will originate with its own\r\n     *           unique 'salt'.  This is to ensure that when multiple functions\r\n     *           are called by the EOA within the same transaction, the EOA will\r\n     *           have equally-random chances to yield a completely different\r\n     *           GENFT.  The block timestamp is added to salt to make it more\r\n     *           difficult for an end user to predict which GENFT they'll mint.\r\n     *\r\n     *        2. blockhash: the only EOAs that can reasonably use this to their\r\n     *           advantage without adding significant costs for the transaction,\r\n     *           such as the capital required to create a miner with a weight of\r\n     *           1 or greater, are EOAs that run the function to \"claim\" their\r\n     *           sacrifie tokens and EOAs that run the function to summarize\r\n     *           a Genius Calendar period.  That is because these functions have\r\n     *           a 100% chance to mint a GENFT.\r\n     *\r\n     *           However, the \"claim\" function can only be run once per EOA that\r\n     *           participated in the Genius Sacrifice Event.  Therefore, this\r\n     *           will not be useful for the EOA, even if they have the ability\r\n     *           to influence the block hash.  See: https://sacrifice.to\r\n     *\r\n     *           In regards to the Calendar summarize functions, the EOA cannot\r\n     *           waste time figuring out their best chances because if they are\r\n     *           not the first EOA to run the function, then they lose the\r\n     *           ability to run the function for the day/period.\r\n     *\r\n     *           For every other function, the EOA is prevented from spamming\r\n     *           these functions not only from the blockchain's gas fee, but\r\n     *           spam is additional prevented because every other function\r\n     *           has one of the following qualities:\r\n     *              a. It is a \"first-come, first-to-benefit\" function, e.g. the\r\n     *                 functions to claimAuction, releaseShares, etc.\r\n     *              b. The function is necessary for \"cleaning up\" or updating\r\n     *                 Genius' environment, active shares, etc., and therefore,\r\n     *                 the EOA should be rewarded as they wish.\r\n     *              c. The EOA had to have input something of value to the\r\n     *                 network, i.e. they had to put up a significant, non-dust\r\n     *                 amount of GENI capital, which ultimately benefitted the\r\n     *                 Genius end users.\r\n     *\r\n     *           Therefore, if it is worth it for the EOA to exert the position-\r\n     *           ing and effort to influence random numbers for their purpose,\r\n     *           then this action is also not guaranteed, and its repeated\r\n     *           action is designed to benefit the Genius end user.  Since the\r\n     *           purpose of GENFTs is purely as collectibles and *not* for\r\n     *           significant financial value, it is perfectly acceptable for\r\n     *           EOAs to \"game\" the possibilities of yielding the GENFT that\r\n     *           they desire.\r\n     *\r\n     *        3. account: used so that different EOAs running the same GENFT\r\n     *           minting functions within the same block will not generate the\r\n     *           same GENFTs.  Likewise, if different accounts are unpacking\r\n     *           booster/ultimate packs within the same transaction, this will\r\n     *           ensure that the end users do not unpack the same GENFTs.\r\n     *\r\n     *        Finally, it should be noted that the GENFT controller prevents\r\n     *        EOAs from minting GENFTs with the same randomization salt or\r\n     *        unpacking to mint multiple GENFTs within the same block.  This is\r\n     *        done to prevent the end user from duplicating multiple copies of\r\n     *        the same GENFTs.\r\n     *\r\n     * @param account address used to generate a random number\r\n     * @param salt  when multiple random numbers are necessary, this is used\r\n     *                to add some randomness.  This is important because within\r\n     *                a single transaction, the random number will be exactly\r\n     *                the same without this _salt.\r\n     */\r\n    function _random(address account, uint256 salt) internal view returns (uint256) {\r\n        unchecked {\r\n            return uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        salt + block.timestamp,\r\n                        blockhash(block.number),\r\n                        account\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev     You tell the function the \"probability\" that something will\r\n     *          happen, and this function tells you if it happened :)\r\n     * @param   account address used for the calculation\r\n     * @param   chances How many chances of successes will there be out of the entire...\r\n     * @param   totals ...range of precision totals?\r\n     * @param   weight will the weight be based on?  Use \"0\" for no weight.\r\n     * @param   nonce \"nonce\" so that if this function is called multiple times\r\n     *          within a transaction, the random number will be different each\r\n     *          time this function is invoked.\r\n     * @return  Whether the probability test was succcessful :)\r\n     */\r\n    function _probability(address account, uint256 chances, uint256 totals, uint256 weight, uint256 nonce)\r\n        internal view returns (bool)\r\n    {\r\n        unchecked {\r\n            // STEP 1: increase the weight of the chances if necessary.\r\n            if (weight > 0) {\r\n                chances = chances * penaltyContract.minerWeight(weight)\r\n                    / PENALTY_COUNTER_PRECISION;\r\n            }\r\n\r\n            if (chances >= totals) {\r\n                return true;\r\n            }\r\n\r\n            // NOTE: beyond this point, chances < totals, and therefore, it is not\r\n            // possible for chances to be equal to or greater than totals, resulting\r\n            // in an overflow.\r\n\r\n            // STEP 2: Find a random number between 0 and the totals.\r\n            uint256 random = _random(account, nonce) % totals;\r\n\r\n            // STEP 3: Is the random number within the probability range of chance?\r\n            // The minimum that (totals - chances) will be is 1, so therefore, if\r\n            // the random number is 0, then the return value will be false.  In the\r\n            // situation where this is a \"1 in X\" chance, \"random\" must be 0 in\r\n            // order for the logical expression (below) to be true.\r\n            return random >= totals - chances;\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oaGrantor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oaBeneficiary\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CannotShutdown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorCannotReleaseAuctionedShares\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorCannotReleaseShares\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorNotLaunchedYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorNullAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrorUnauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoClaimExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedLostBonusClaiming\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOaBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updated\",\"type\":\"uint256\"}],\"name\":\"ChangeOaBeneficiary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOaGrantor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updated\",\"type\":\"uint256\"}],\"name\":\"ChangeOaGrantor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minerIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"benevolence\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principalPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalMinerRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardsPayout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penaltyToMiners\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"policy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"auctioned\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exodus\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"promiseDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lemClaimDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyDelta\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"nonTransferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ended\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtIssueRate\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Utilities.MinerCache\",\"name\":\"miner\",\"type\":\"tuple\"}],\"name\":\"EndMiner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorRewardAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minerIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executorReward\",\"type\":\"uint256\"}],\"name\":\"LemRewardsClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minerIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorRewardAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executorReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"performanceRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redistributedPenalties\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toOa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnedForever\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"policy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"auctioned\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exodus\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"promiseDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lemClaimDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyDelta\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"nonTransferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ended\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtIssueRate\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Utilities.MinerCache\",\"name\":\"miner\",\"type\":\"tuple\"}],\"name\":\"ShutdownMiner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAUNCH_TIMESTAMP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"advLockedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basicLockedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calendarAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"canClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oaBeneficiary\",\"type\":\"address\"}],\"name\":\"changeOaBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOaGrantor\",\"type\":\"address\"}],\"name\":\"changeOaGrantor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool\",\"name\":\"mintNft\",\"type\":\"bool\"}],\"name\":\"claimGenius\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimLostMintBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"decAdvLockedSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"decBasicLockedSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minerIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"benevolence\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"mintNft\",\"type\":\"bool\"}],\"name\":\"endMiner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gnftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hexodusAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"incAdvLockedSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"incBasicLockedSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusLostForever\",\"type\":\"uint256\"}],\"name\":\"incOaMintableBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minersAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintSummaryReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oaBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oaGrantor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oaMintableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minerId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"mintNft\",\"type\":\"bool\"}],\"name\":\"releaseShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_auction\",\"type\":\"address\"}],\"name\":\"setAuctionContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_calendar\",\"type\":\"address\"}],\"name\":\"setCalendarContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gnftAddress\",\"type\":\"address\"}],\"name\":\"setGnftContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hexodus\",\"type\":\"address\"}],\"name\":\"setHexodusContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minersAddress\",\"type\":\"address\"}],\"name\":\"setMinersContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pcAddress\",\"type\":\"address\"}],\"name\":\"setPenaltyContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stabilityPool\",\"type\":\"address\"}],\"name\":\"setStabilityPoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minerId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"mintNft\",\"type\":\"bool\"}],\"name\":\"shutdownMiner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stabilityPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Genius", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000dca40b6fb95e9c1c4511f7758bc6f3aec7474444000000000000000000000000f2ebcc36ecbbf57bcf7d7531fe24f137afc4c555", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cf7fec9b990305171b472ea11addeeab57dabb8532cd6cde4b8907984b8c9518"}