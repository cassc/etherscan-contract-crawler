{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@reality.eth/contracts/development/contracts/RealityETH_ERC20-3.0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.10;\\n\\nimport './BalanceHolder_ERC20.sol';\\n\\ncontract RealityETH_ERC20_v3_0 is BalanceHolder_ERC20 {\\n\\n    address constant NULL_ADDRESS = address(0);\\n\\n    // History hash when no history is created, or history has been cleared\\n    bytes32 constant NULL_HASH = bytes32(0);\\n\\n    // An unitinalized finalize_ts for a question will indicate an unanswered question.\\n    uint32 constant UNANSWERED = 0;\\n\\n    // An unanswered reveal_ts for a commitment will indicate that it does not exist.\\n    uint256 constant COMMITMENT_NON_EXISTENT = 0;\\n\\n    // Commit->reveal timeout is 1/8 of the question timeout (rounded down).\\n    uint32 constant COMMITMENT_TIMEOUT_RATIO = 8;\\n\\n    // Proportion withheld when you claim an earlier bond.\\n    uint256 constant BOND_CLAIM_FEE_PROPORTION = 40; // One 40th ie 2.5%\\n\\n    // Special value representing a question that was answered too soon.\\n    // bytes32(-2). By convention we use bytes32(-1) for \\\"invalid\\\", although the contract does not handle this.\\n    bytes32 constant UNRESOLVED_ANSWER = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe;\\n\\n    event LogSetQuestionFee(\\n        address arbitrator,\\n        uint256 amount\\n    );\\n\\n    event LogNewTemplate(\\n        uint256 indexed template_id,\\n        address indexed user, \\n        string question_text\\n    );\\n\\n    event LogNewQuestion(\\n        bytes32 indexed question_id,\\n        address indexed user, \\n        uint256 template_id,\\n        string question,\\n        bytes32 indexed content_hash,\\n        address arbitrator, \\n        uint32 timeout,\\n        uint32 opening_ts,\\n        uint256 nonce,\\n        uint256 created\\n    );\\n\\n    event LogMinimumBond(\\n        bytes32 indexed question_id,\\n        uint256 min_bond\\n    );\\n\\n    event LogFundAnswerBounty(\\n        bytes32 indexed question_id,\\n        uint256 bounty_added,\\n        uint256 bounty,\\n        address indexed user \\n    );\\n\\n    event LogNewAnswer(\\n        bytes32 answer,\\n        bytes32 indexed question_id,\\n        bytes32 history_hash,\\n        address indexed user,\\n        uint256 bond,\\n        uint256 ts,\\n        bool is_commitment\\n    );\\n\\n    event LogAnswerReveal(\\n        bytes32 indexed question_id, \\n        address indexed user, \\n        bytes32 indexed answer_hash, \\n        bytes32 answer, \\n        uint256 nonce, \\n        uint256 bond\\n    );\\n\\n    event LogNotifyOfArbitrationRequest(\\n        bytes32 indexed question_id,\\n        address indexed user \\n    );\\n\\n    event LogCancelArbitration(\\n        bytes32 indexed question_id\\n    );\\n\\n    event LogFinalize(\\n        bytes32 indexed question_id,\\n        bytes32 indexed answer\\n    );\\n\\n    event LogClaim(\\n        bytes32 indexed question_id,\\n        address indexed user,\\n        uint256 amount\\n    );\\n\\n    event LogReopenQuestion(\\n        bytes32 indexed question_id,\\n        bytes32 indexed reopened_question_id\\n    );\\n\\n    struct Question {\\n        bytes32 content_hash;\\n        address arbitrator;\\n        uint32 opening_ts;\\n        uint32 timeout;\\n        uint32 finalize_ts;\\n        bool is_pending_arbitration;\\n        uint256 bounty;\\n        bytes32 best_answer;\\n        bytes32 history_hash;\\n        uint256 bond;\\n        uint256 min_bond;\\n    }\\n\\n    // Stored in a mapping indexed by commitment_id, a hash of commitment hash, question, bond. \\n    struct Commitment {\\n        uint32 reveal_ts;\\n        bool is_revealed;\\n        bytes32 revealed_answer;\\n    }\\n\\n    // Only used when claiming more bonds than fits into a transaction\\n    // Stored in a mapping indexed by question_id.\\n    struct Claim {\\n        address payee;\\n        uint256 last_bond;\\n        uint256 queued_funds;\\n    }\\n\\n    uint256 nextTemplateID = 0;\\n    mapping(uint256 => uint256) public templates;\\n    mapping(uint256 => bytes32) public template_hashes;\\n    mapping(bytes32 => Question) public questions;\\n    mapping(bytes32 => Claim) public question_claims;\\n    mapping(bytes32 => Commitment) public commitments;\\n    mapping(address => uint256) public arbitrator_question_fees; \\n    mapping(bytes32 => bytes32) public reopened_questions;\\n    mapping(bytes32 => bool) public reopener_questions;\\n\\n\\n    modifier onlyArbitrator(bytes32 question_id) {\\n        require(msg.sender == questions[question_id].arbitrator, \\\"msg.sender must be arbitrator\\\");\\n        _;\\n    }\\n\\n    modifier stateAny() {\\n        _;\\n    }\\n\\n    modifier stateNotCreated(bytes32 question_id) {\\n        require(questions[question_id].timeout == 0, \\\"question must not exist\\\");\\n        _;\\n    }\\n\\n    modifier stateOpen(bytes32 question_id) {\\n        require(questions[question_id].timeout > 0, \\\"question must exist\\\");\\n        require(!questions[question_id].is_pending_arbitration, \\\"question must not be pending arbitration\\\");\\n        uint32 finalize_ts = questions[question_id].finalize_ts;\\n        require(finalize_ts == UNANSWERED || finalize_ts > uint32(block.timestamp), \\\"finalization deadline must not have passed\\\");\\n        uint32 opening_ts = questions[question_id].opening_ts;\\n        require(opening_ts == 0 || opening_ts <= uint32(block.timestamp), \\\"opening date must have passed\\\"); \\n        _;\\n    }\\n\\n    modifier statePendingArbitration(bytes32 question_id) {\\n        require(questions[question_id].is_pending_arbitration, \\\"question must be pending arbitration\\\");\\n        _;\\n    }\\n\\n    modifier stateOpenOrPendingArbitration(bytes32 question_id) {\\n        require(questions[question_id].timeout > 0, \\\"question must exist\\\");\\n        uint32 finalize_ts = questions[question_id].finalize_ts;\\n        require(finalize_ts == UNANSWERED || finalize_ts > uint32(block.timestamp), \\\"finalization dealine must not have passed\\\");\\n        uint32 opening_ts = questions[question_id].opening_ts;\\n        require(opening_ts == 0 || opening_ts <= uint32(block.timestamp), \\\"opening date must have passed\\\"); \\n        _;\\n    }\\n\\n    modifier stateFinalized(bytes32 question_id) {\\n        require(isFinalized(question_id), \\\"question must be finalized\\\");\\n        _;\\n    }\\n\\n    modifier bondMustDoubleAndMatchMinimum(bytes32 question_id, uint256 tokens) {\\n        require(tokens > 0, \\\"bond must be positive\\\"); \\n        uint256 current_bond = questions[question_id].bond;\\n        if (current_bond == 0) {\\n            require(tokens >= (questions[question_id].min_bond), \\\"bond must exceed the minimum\\\");\\n        } else {\\n            require(tokens >= (current_bond * 2), \\\"bond must be double at least previous bond\\\");\\n        }\\n        _;\\n    }\\n\\n    modifier previousBondMustNotBeatMaxPrevious(bytes32 question_id, uint256 max_previous) {\\n        if (max_previous > 0) {\\n            require(questions[question_id].bond <= max_previous, \\\"bond must exceed max_previous\\\");\\n        }\\n        _;\\n    }\\n\\n    /// @notice Constructor, sets up some initial templates\\n    /// @dev Creates some generalized templates for different question types used in the DApp.\\n    constructor() {\\n        createTemplate('{\\\"title\\\": \\\"%s\\\", \\\"type\\\": \\\"bool\\\", \\\"category\\\": \\\"%s\\\", \\\"lang\\\": \\\"%s\\\"}');\\n        createTemplate('{\\\"title\\\": \\\"%s\\\", \\\"type\\\": \\\"uint\\\", \\\"decimals\\\": 18, \\\"category\\\": \\\"%s\\\", \\\"lang\\\": \\\"%s\\\"}');\\n        createTemplate('{\\\"title\\\": \\\"%s\\\", \\\"type\\\": \\\"single-select\\\", \\\"outcomes\\\": [%s], \\\"category\\\": \\\"%s\\\", \\\"lang\\\": \\\"%s\\\"}');\\n        createTemplate('{\\\"title\\\": \\\"%s\\\", \\\"type\\\": \\\"multiple-select\\\", \\\"outcomes\\\": [%s], \\\"category\\\": \\\"%s\\\", \\\"lang\\\": \\\"%s\\\"}');\\n        createTemplate('{\\\"title\\\": \\\"%s\\\", \\\"type\\\": \\\"datetime\\\", \\\"category\\\": \\\"%s\\\", \\\"lang\\\": \\\"%s\\\"}');\\n    }\\n\\n    /// @notice Set the address of the ERC20 token that will be used for bonds.\\n    /// @dev Should not be used with ERC20-like token contracts that implement callbacks like ERC777 that could cause re-entrancy issues\\n    /// @param _token The ERC20 token that will be used for bonds.\\n    function setToken(IERC20 _token) \\n    public\\n    {\\n        require(token == IERC20(address(0x0)), \\\"Token can only be initialized once\\\");\\n        token = _token;\\n    }\\n\\n    /// @notice Function for arbitrator to set an optional per-question fee. \\n    /// @dev The per-question fee, charged when a question is asked, is intended as an anti-spam measure.\\n    /// @param fee The fee to be charged by the arbitrator when a question is asked\\n    function setQuestionFee(uint256 fee) \\n        stateAny() \\n    external {\\n        arbitrator_question_fees[msg.sender] = fee;\\n        emit LogSetQuestionFee(msg.sender, fee);\\n    }\\n\\n    /// @notice Create a reusable template, which should be a JSON document.\\n    /// Placeholders should use gettext() syntax, eg %s.\\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\\n    /// @param content The template content\\n    /// @return The ID of the newly-created template, which is created sequentially.\\n    function createTemplate(string memory content) \\n        stateAny()\\n    public returns (uint256) {\\n        uint256 id = nextTemplateID;\\n        templates[id] = block.number;\\n        template_hashes[id] = keccak256(abi.encodePacked(content));\\n        emit LogNewTemplate(id, msg.sender, content);\\n        nextTemplateID = id + 1;\\n        return id;\\n    }\\n\\n    /// @notice Create a new reusable template and use it to ask a question\\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\\n    /// @param content The template content\\n    /// @param question A string containing the parameters that will be passed into the template to make the question\\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\\n    /// @return The ID of the newly-created template, which is created sequentially.\\n    function createTemplateAndAskQuestion(\\n        string memory content, \\n        string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce \\n    ) \\n        // stateNotCreated is enforced by the internal _askQuestion\\n    public returns (bytes32) {\\n        uint256 template_id = createTemplate(content);\\n        return askQuestion(template_id, question, arbitrator, timeout, opening_ts, nonce);\\n    }\\n\\n    /// @notice Ask a new question without a bounty and return the ID\\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\\n    /// @dev Calling without the token param will only work if there is no arbitrator-set question fee.\\n    /// @dev This has the same function signature as askQuestion() in the non-ERC20 version, which is optionally payable.\\n    /// @param template_id The ID number of the template the question will use\\n    /// @param question A string containing the parameters that will be passed into the template to make the question\\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\\n    /// @return The ID of the newly-created question, created deterministically.\\n    function askQuestion(uint256 template_id, string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce) \\n        // stateNotCreated is enforced by the internal _askQuestion\\n    public returns (bytes32) {\\n\\n        require(templates[template_id] > 0, \\\"template must exist\\\");\\n\\n        bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));\\n        bytes32 question_id = keccak256(abi.encodePacked(content_hash, arbitrator, timeout, uint256(0), address(this), msg.sender, nonce));\\n\\n        // We emit this event here because _askQuestion doesn't need to know the unhashed question. Other events are emitted by _askQuestion.\\n        emit LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, block.timestamp);\\n        _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts, 0, 0);\\n\\n        return question_id;\\n    }\\n\\n    /// @notice Ask a new question with a bounty and return the ID\\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\\n    /// @param template_id The ID number of the template the question will use\\n    /// @param question A string containing the parameters that will be passed into the template to make the question\\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\\n    /// @param tokens The combined initial question bounty and question fee\\n    /// @return The ID of the newly-created question, created deterministically.\\n    function askQuestionERC20(uint256 template_id, string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 tokens) \\n        // stateNotCreated is enforced by the internal _askQuestion\\n    public returns (bytes32) {\\n\\n        _deductTokensOrRevert(tokens);\\n\\n        require(templates[template_id] > 0, \\\"template must exist\\\");\\n\\n        bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));\\n        bytes32 question_id = keccak256(abi.encodePacked(content_hash, arbitrator, timeout, uint256(0), address(this), msg.sender, nonce));\\n\\n        // We emit this event here because _askQuestion doesn't need to know the unhashed question. Other events are emitted by _askQuestion.\\n        emit LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, block.timestamp);\\n        _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts, 0, tokens);\\n\\n        return question_id;\\n    }\\n\\n    /// @notice Ask a new question and return the ID\\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\\n    /// @param template_id The ID number of the template the question will use\\n    /// @param question A string containing the parameters that will be passed into the template to make the question\\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\\n    /// @param min_bond The minimum bond that may be used for an answer.\\n    /// @param tokens Number of tokens sent\\n    /// @return The ID of the newly-created question, created deterministically.\\n    function askQuestionWithMinBondERC20(uint256 template_id, string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 min_bond, uint256 tokens) \\n        // stateNotCreated is enforced by the internal _askQuestion\\n    public returns (bytes32) {\\n\\n        _deductTokensOrRevert(tokens);\\n\\n        require(templates[template_id] > 0, \\\"template must exist\\\");\\n\\n        bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));\\n        bytes32 question_id = keccak256(abi.encodePacked(content_hash, arbitrator, timeout, min_bond, address(this), msg.sender, nonce));\\n\\n        // We emit this event here because _askQuestion doesn't need to know the unhashed question.\\n        // Other events are emitted by _askQuestion.\\n        emit LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, block.timestamp);\\n        _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts, min_bond, tokens);\\n\\n        return question_id;\\n    }\\n\\n    function _deductTokensOrRevert(uint256 tokens) \\n    internal {\\n \\n        if (tokens == 0) {\\n            return;\\n        }\\n\\n        uint256 bal = balanceOf[msg.sender];\\n\\n        // Deduct any tokens you have in your internal balance first\\n        if (bal > 0) {\\n            if (bal >= tokens) {\\n                balanceOf[msg.sender] = bal - tokens;\\n                return;\\n            } else {\\n                tokens = tokens - bal;\\n                balanceOf[msg.sender] = 0;\\n            }\\n        }\\n        // Now we need to charge the rest from \\n        require(token.transferFrom(msg.sender, address(this), tokens), \\\"Transfer of tokens failed, insufficient approved balance?\\\");\\n        return;\\n\\n    }\\n\\n    function _askQuestion(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 min_bond, uint256 tokens) \\n        stateNotCreated(question_id)\\n    internal {\\n\\n        // A timeout of 0 makes no sense, and we will use this to check existence\\n        require(timeout > 0, \\\"timeout must be positive\\\"); \\n        require(timeout < 365 days, \\\"timeout must be less than 365 days\\\"); \\n\\n        uint256 bounty = tokens;\\n\\n        // The arbitrator can set a fee for asking a question. \\n        // This is intended as an anti-spam defence.\\n        // The fee is waived if the arbitrator is asking the question.\\n        // This allows them to set an impossibly high fee and make users proxy the question through them.\\n        // This would allow more sophisticated pricing, question whitelisting etc.\\n        if (arbitrator != NULL_ADDRESS && msg.sender != arbitrator) {\\n            uint256 question_fee = arbitrator_question_fees[arbitrator];\\n            require(bounty >= question_fee, \\\"Tokens provided must cover question fee\\\"); \\n            bounty = bounty - question_fee;\\n            balanceOf[arbitrator] = balanceOf[arbitrator] + question_fee;\\n        }\\n\\n        questions[question_id].content_hash = content_hash;\\n        questions[question_id].arbitrator = arbitrator;\\n        questions[question_id].opening_ts = opening_ts;\\n        questions[question_id].timeout = timeout;\\n\\n        if (bounty > 0) {\\n            questions[question_id].bounty = bounty;\\n            emit LogFundAnswerBounty(question_id, bounty, bounty, msg.sender);\\n        }\\n\\n        if (min_bond > 0) {\\n            questions[question_id].min_bond = min_bond;\\n            emit LogMinimumBond(question_id, min_bond);\\n        }\\n\\n    }\\n\\n    /// @notice Add funds to the bounty for a question\\n    /// @dev Add bounty funds after the initial question creation. Can be done any time until the question is finalized.\\n    /// @param question_id The ID of the question you wish to fund\\n    /// @param tokens The number of tokens to fund\\n    function fundAnswerBountyERC20(bytes32 question_id, uint256 tokens) \\n        stateOpen(question_id)\\n    external {\\n        _deductTokensOrRevert(tokens);\\n        questions[question_id].bounty = questions[question_id].bounty + tokens;\\n        emit LogFundAnswerBounty(question_id, tokens, questions[question_id].bounty, msg.sender);\\n    }\\n\\n    /// @notice Submit an answer for a question.\\n    /// @dev Adds the answer to the history and updates the current \\\"best\\\" answer.\\n    /// May be subject to front-running attacks; Substitute submitAnswerCommitment()->submitAnswerReveal() to prevent them.\\n    /// @param question_id The ID of the question\\n    /// @param answer The answer, encoded into bytes32\\n    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\\n    /// @param tokens The amount of tokens to submit\\n    function submitAnswerERC20(bytes32 question_id, bytes32 answer, uint256 max_previous, uint256 tokens) \\n        stateOpen(question_id)\\n        bondMustDoubleAndMatchMinimum(question_id, tokens)\\n        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\\n    external {\\n        _deductTokensOrRevert(tokens);\\n        _addAnswerToHistory(question_id, answer, msg.sender, tokens, false);\\n        _updateCurrentAnswer(question_id, answer);\\n    }\\n\\n    /// @notice Submit an answer for a question, crediting it to the specified account.\\n    /// @dev Adds the answer to the history and updates the current \\\"best\\\" answer.\\n    /// May be subject to front-running attacks; Substitute submitAnswerCommitment()->submitAnswerReveal() to prevent them.\\n    /// @param question_id The ID of the question\\n    /// @param answer The answer, encoded into bytes32\\n    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\\n    /// @param answerer The account to which the answer should be credited\\n    /// @param tokens Number of tokens sent\\n    function submitAnswerForERC20(bytes32 question_id, bytes32 answer, uint256 max_previous, address answerer, uint256 tokens)\\n        stateOpen(question_id)\\n        bondMustDoubleAndMatchMinimum(question_id, tokens)\\n        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\\n    external {\\n        _deductTokensOrRevert(tokens);\\n        require(answerer != NULL_ADDRESS, \\\"answerer must be non-zero\\\");\\n        _addAnswerToHistory(question_id, answer, answerer, tokens, false);\\n        _updateCurrentAnswer(question_id, answer);\\n    }\\n\\n    // @notice Verify and store a commitment, including an appropriate timeout\\n    // @param question_id The ID of the question to store\\n    // @param commitment The ID of the commitment\\n    function _storeCommitment(bytes32 question_id, bytes32 commitment_id) \\n    internal\\n    {\\n        require(commitments[commitment_id].reveal_ts == COMMITMENT_NON_EXISTENT, \\\"commitment must not already exist\\\");\\n\\n        uint32 commitment_timeout = questions[question_id].timeout / COMMITMENT_TIMEOUT_RATIO;\\n        commitments[commitment_id].reveal_ts = uint32(block.timestamp) + commitment_timeout;\\n    }\\n\\n    /// @notice Submit the hash of an answer, laying your claim to that answer if you reveal it in a subsequent transaction.\\n    /// @dev Creates a hash, commitment_id, uniquely identifying this answer, to this question, with this bond.\\n    /// The commitment_id is stored in the answer history where the answer would normally go.\\n    /// Does not update the current best answer - this is left to the later submitAnswerReveal() transaction.\\n    /// @param question_id The ID of the question\\n    /// @param answer_hash The hash of your answer, plus a nonce that you will later reveal\\n    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\\n    /// @param _answerer If specified, the address to be given as the question answerer. Defaults to the sender.\\n    /// @param tokens Number of tokens sent\\n    /// @dev Specifying the answerer is useful if you want to delegate the commit-and-reveal to a third-party.\\n    function submitAnswerCommitmentERC20(bytes32 question_id, bytes32 answer_hash, uint256 max_previous, address _answerer, uint256 tokens) \\n        stateOpen(question_id)\\n        bondMustDoubleAndMatchMinimum(question_id, tokens)\\n        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\\n    external {\\n\\n        _deductTokensOrRevert(tokens);\\n\\n        bytes32 commitment_id = keccak256(abi.encodePacked(question_id, answer_hash, tokens));\\n        address answerer = (_answerer == NULL_ADDRESS) ? msg.sender : _answerer;\\n\\n        _storeCommitment(question_id, commitment_id);\\n        _addAnswerToHistory(question_id, commitment_id, answerer, tokens, true);\\n\\n    }\\n\\n    /// @notice Submit the answer whose hash you sent in a previous submitAnswerCommitment() transaction\\n    /// @dev Checks the parameters supplied recreate an existing commitment, and stores the revealed answer\\n    /// Updates the current answer unless someone has since supplied a new answer with a higher bond\\n    /// msg.sender is intentionally not restricted to the user who originally sent the commitment; \\n    /// For example, the user may want to provide the answer+nonce to a third-party service and let them send the tx\\n    /// NB If we are pending arbitration, it will be up to the arbitrator to wait and see any outstanding reveal is sent\\n    /// @param question_id The ID of the question\\n    /// @param answer The answer, encoded as bytes32\\n    /// @param nonce The nonce that, combined with the answer, recreates the answer_hash you gave in submitAnswerCommitment()\\n    /// @param bond The bond that you paid in your submitAnswerCommitment() transaction\\n    function submitAnswerReveal(bytes32 question_id, bytes32 answer, uint256 nonce, uint256 bond) \\n        stateOpenOrPendingArbitration(question_id)\\n    external {\\n\\n        bytes32 answer_hash = keccak256(abi.encodePacked(answer, nonce));\\n        bytes32 commitment_id = keccak256(abi.encodePacked(question_id, answer_hash, bond));\\n\\n        require(!commitments[commitment_id].is_revealed, \\\"commitment must not have been revealed yet\\\");\\n        require(commitments[commitment_id].reveal_ts > uint32(block.timestamp), \\\"reveal deadline must not have passed\\\");\\n\\n        commitments[commitment_id].revealed_answer = answer;\\n        commitments[commitment_id].is_revealed = true;\\n\\n        if (bond == questions[question_id].bond) {\\n            _updateCurrentAnswer(question_id, answer);\\n        }\\n\\n        emit LogAnswerReveal(question_id, msg.sender, answer_hash, answer, nonce, bond);\\n\\n    }\\n\\n    function _addAnswerToHistory(bytes32 question_id, bytes32 answer_or_commitment_id, address answerer, uint256 bond, bool is_commitment) \\n    internal \\n    {\\n        bytes32 new_history_hash = keccak256(abi.encodePacked(questions[question_id].history_hash, answer_or_commitment_id, bond, answerer, is_commitment));\\n\\n        // Update the current bond level, if there's a bond (ie anything except arbitration)\\n        if (bond > 0) {\\n            questions[question_id].bond = bond;\\n        }\\n        questions[question_id].history_hash = new_history_hash;\\n\\n        emit LogNewAnswer(answer_or_commitment_id, question_id, new_history_hash, answerer, bond, block.timestamp, is_commitment);\\n    }\\n\\n    function _updateCurrentAnswer(bytes32 question_id, bytes32 answer)\\n    internal {\\n        questions[question_id].best_answer = answer;\\n        questions[question_id].finalize_ts = uint32(block.timestamp) + questions[question_id].timeout;\\n    }\\n\\n    // Like _updateCurrentAnswer but without advancing the timeout\\n    function _updateCurrentAnswerByArbitrator(bytes32 question_id, bytes32 answer)\\n    internal {\\n        questions[question_id].best_answer = answer;\\n        questions[question_id].finalize_ts = uint32(block.timestamp);\\n    }\\n\\n    /// @notice Notify the contract that the arbitrator has been paid for a question, freezing it pending their decision.\\n    /// @dev The arbitrator contract is trusted to only call this if they've been paid, and tell us who paid them.\\n    /// @param question_id The ID of the question\\n    /// @param requester The account that requested arbitration\\n    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\\n    function notifyOfArbitrationRequest(bytes32 question_id, address requester, uint256 max_previous) \\n        onlyArbitrator(question_id)\\n        stateOpen(question_id)\\n        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\\n    external {\\n        require(questions[question_id].finalize_ts > UNANSWERED, \\\"Question must already have an answer when arbitration is requested\\\");\\n        questions[question_id].is_pending_arbitration = true;\\n        emit LogNotifyOfArbitrationRequest(question_id, requester);\\n    }\\n\\n    /// @notice Cancel a previously-requested arbitration and extend the timeout\\n    /// @dev Useful when doing arbitration across chains that can't be requested atomically\\n    /// @param question_id The ID of the question\\n    function cancelArbitration(bytes32 question_id) \\n        onlyArbitrator(question_id)\\n        statePendingArbitration(question_id)\\n    external {\\n        questions[question_id].is_pending_arbitration = false;\\n        questions[question_id].finalize_ts = uint32(block.timestamp) + questions[question_id].timeout;\\n        emit LogCancelArbitration(question_id);\\n    }\\n\\n    /// @notice Submit the answer for a question, for use by the arbitrator.\\n    /// @dev Doesn't require (or allow) a bond.\\n    /// If the current final answer is correct, the account should be whoever submitted it.\\n    /// If the current final answer is wrong, the account should be whoever paid for arbitration.\\n    /// However, the answerer stipulations are not enforced by the contract.\\n    /// @param question_id The ID of the question\\n    /// @param answer The answer, encoded into bytes32\\n    /// @param answerer The account credited with this answer for the purpose of bond claims\\n    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) \\n        onlyArbitrator(question_id)\\n        statePendingArbitration(question_id)\\n    public {\\n\\n        require(answerer != NULL_ADDRESS, \\\"answerer must be provided\\\");\\n        emit LogFinalize(question_id, answer);\\n\\n        questions[question_id].is_pending_arbitration = false;\\n        _addAnswerToHistory(question_id, answer, answerer, 0, false);\\n        _updateCurrentAnswerByArbitrator(question_id, answer);\\n    }\\n\\n    /// @notice Submit the answer for a question, for use by the arbitrator, working out the appropriate winner based on the last answer details.\\n    /// @dev Doesn't require (or allow) a bond.\\n    /// @param question_id The ID of the question\\n    /// @param answer The answer, encoded into bytes32\\n    /// @param payee_if_wrong The account to by credited as winner if the last answer given is wrong, usually the account that paid the arbitrator\\n    /// @param last_history_hash The history hash before the final one\\n    /// @param last_answer_or_commitment_id The last answer given, or the commitment ID if it was a commitment.\\n    /// @param last_answerer The address that supplied the last answer\\n    function assignWinnerAndSubmitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address payee_if_wrong, bytes32 last_history_hash, bytes32 last_answer_or_commitment_id, address last_answerer) \\n    external {\\n        bool is_commitment = _verifyHistoryInputOrRevert(questions[question_id].history_hash, last_history_hash, last_answer_or_commitment_id, questions[question_id].bond, last_answerer);\\n\\n        address payee;\\n        // If the last answer is an unrevealed commit, it's always wrong.\\n        // For anything else, the last answer was set as the \\\"best answer\\\" in submitAnswer or submitAnswerReveal.\\n        if (is_commitment && !commitments[last_answer_or_commitment_id].is_revealed) {\\n            require(commitments[last_answer_or_commitment_id].reveal_ts < uint32(block.timestamp), \\\"You must wait for the reveal deadline before finalizing\\\");\\n            payee = payee_if_wrong;\\n        } else {\\n            payee = (questions[question_id].best_answer == answer) ? last_answerer : payee_if_wrong;\\n        }\\n        submitAnswerByArbitrator(question_id, answer, payee);\\n    }\\n\\n\\n    /// @notice Report whether the answer to the specified question is finalized\\n    /// @param question_id The ID of the question\\n    /// @return Return true if finalized\\n    function isFinalized(bytes32 question_id) \\n    view public returns (bool) {\\n        uint32 finalize_ts = questions[question_id].finalize_ts;\\n        return ( !questions[question_id].is_pending_arbitration && (finalize_ts > UNANSWERED) && (finalize_ts <= uint32(block.timestamp)) );\\n    }\\n\\n    /// @notice (Deprecated) Return the final answer to the specified question, or revert if there isn't one\\n    /// @param question_id The ID of the question\\n    /// @return The answer formatted as a bytes32\\n    function getFinalAnswer(bytes32 question_id) \\n        stateFinalized(question_id)\\n    external view returns (bytes32) {\\n        return questions[question_id].best_answer;\\n    }\\n\\n    /// @notice Return the final answer to the specified question, or revert if there isn't one\\n    /// @param question_id The ID of the question\\n    /// @return The answer formatted as a bytes32\\n    function resultFor(bytes32 question_id) \\n        stateFinalized(question_id)\\n    public view returns (bytes32) {\\n        return questions[question_id].best_answer;\\n    }\\n\\n    /// @notice Returns whether the question was answered before it had an answer, ie resolved to UNRESOLVED_ANSWER\\n    /// @param question_id The ID of the question \\n    function isSettledTooSoon(bytes32 question_id)\\n    public view returns(bool) {\\n        return (resultFor(question_id) == UNRESOLVED_ANSWER);\\n    }\\n\\n    /// @notice Like resultFor(), but errors out if settled too soon, or returns the result of a replacement if it was reopened at the right time and settled\\n    /// @param question_id The ID of the question \\n    function resultForOnceSettled(bytes32 question_id)\\n    external view returns(bytes32) {\\n        bytes32 result = resultFor(question_id);\\n        if (result == UNRESOLVED_ANSWER) {\\n            // Try the replacement\\n            bytes32 replacement_id = reopened_questions[question_id];\\n            require(replacement_id != bytes32(0x0), \\\"Question was settled too soon and has not been reopened\\\");\\n            // We only try one layer down rather than recursing to keep the gas costs predictable\\n            result = resultFor(replacement_id);\\n            require(result != UNRESOLVED_ANSWER, \\\"Question replacement was settled too soon and has not been reopened\\\");\\n        }\\n        return result;\\n    }\\n\\n    /// @notice Asks a new question reopening a previously-asked question that was settled too soon\\n    /// @dev A special version of askQuestion() that replaces a previous question that was settled too soon\\n    /// @param template_id The ID number of the template the question will use\\n    /// @param question A string containing the parameters that will be passed into the template to make the question\\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\\n    /// @param min_bond The minimum bond that can be used to provide the first answer.\\n    /// @param reopens_question_id The ID of the question this reopens\\n    /// @param tokens The number of tokens you want to use as an additional question reward for the reopened question.\\n    /// @return The ID of the newly-created question, created deterministically.\\n    function reopenQuestionERC20(uint256 template_id, string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 min_bond, bytes32 reopens_question_id, uint256 tokens)\\n        // stateNotCreated is enforced by the internal _askQuestion\\n    public returns (bytes32) {\\n\\n        // _deductTokensOrRevert will be called when we call askQuestionWithMinBondERC20\\n\\n        require(isSettledTooSoon(reopens_question_id), \\\"You can only reopen questions that resolved as settled too soon\\\");\\n\\n        bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));\\n\\n        // A reopening must exactly match the original question, except for the nonce and the creator\\n        require(content_hash == questions[reopens_question_id].content_hash, \\\"content hash mismatch\\\");\\n        require(arbitrator == questions[reopens_question_id].arbitrator, \\\"arbitrator mismatch\\\");\\n        require(timeout == questions[reopens_question_id].timeout, \\\"timeout mismatch\\\");\\n        require(opening_ts == questions[reopens_question_id].opening_ts , \\\"opening_ts mismatch\\\");\\n        require(min_bond == questions[reopens_question_id].min_bond, \\\"min_bond mismatch\\\");\\n\\n        // If the the question was itself reopening some previous question, you'll have to re-reopen the previous question first.\\n        // This ensures the bounty can be passed on to the next attempt of the original question.\\n        require(!reopener_questions[reopens_question_id], \\\"Question is already reopening a previous question\\\");\\n\\n        // A question can only be reopened once, unless the reopening was also settled too soon in which case it can be replaced\\n        bytes32 existing_reopen_question_id = reopened_questions[reopens_question_id];\\n\\n        // Normally when we reopen a question we will take its bounty and pass it on to the reopened version.\\n        bytes32 take_bounty_from_question_id = reopens_question_id;\\n        // If the question has already been reopened but was again settled too soon, we can transfer its bounty to the next attempt.\\n        if (existing_reopen_question_id != bytes32(0)) {\\n            require(isSettledTooSoon(existing_reopen_question_id), \\\"Question has already been reopened\\\");\\n            // We'll overwrite the reopening with our new question and move the bounty.\\n            // Once that's done we'll detach the failed reopener and you'll be able to reopen that too if you really want, but without the bounty.\\n            reopener_questions[existing_reopen_question_id] = false;\\n            take_bounty_from_question_id = existing_reopen_question_id;\\n        }\\n\\n        bytes32 question_id = askQuestionWithMinBondERC20(template_id, question, arbitrator, timeout, opening_ts, nonce, min_bond, tokens);\\n\\n        reopened_questions[reopens_question_id] = question_id;\\n        reopener_questions[question_id] = true;\\n\\n        questions[question_id].bounty = questions[take_bounty_from_question_id].bounty + questions[question_id].bounty;\\n        questions[take_bounty_from_question_id].bounty = 0;\\n\\n        emit LogReopenQuestion(question_id, reopens_question_id);\\n\\n        return question_id;\\n    }\\n\\n    /// @notice Return the final answer to the specified question, provided it matches the specified criteria.\\n    /// @dev Reverts if the question is not finalized, or if it does not match the specified criteria.\\n    /// @param question_id The ID of the question\\n    /// @param content_hash The hash of the question content (template ID + opening time + question parameter string)\\n    /// @param arbitrator The arbitrator chosen for the question (regardless of whether they are asked to arbitrate)\\n    /// @param min_timeout The timeout set in the initial question settings must be this high or higher\\n    /// @param min_bond The bond sent with the final answer must be this high or higher\\n    /// @return The answer formatted as a bytes32\\n    function getFinalAnswerIfMatches(\\n        bytes32 question_id, \\n        bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond\\n    ) \\n        stateFinalized(question_id)\\n    external view returns (bytes32) {\\n        require(content_hash == questions[question_id].content_hash, \\\"content hash must match\\\");\\n        require(arbitrator == questions[question_id].arbitrator, \\\"arbitrator must match\\\");\\n        require(min_timeout <= questions[question_id].timeout, \\\"timeout must be long enough\\\");\\n        require(min_bond <= questions[question_id].bond, \\\"bond must be high enough\\\");\\n        return questions[question_id].best_answer;\\n    }\\n\\n    /// @notice Assigns the winnings (bounty and bonds) to everyone who gave the accepted answer\\n    /// Caller must provide the answer history, in reverse order\\n    /// @dev Works up the chain and assign bonds to the person who gave the right answer\\n    /// If someone gave the winning answer earlier, they must get paid from the higher bond\\n    /// That means we can't pay out the bond added at n until we have looked at n-1\\n    /// The first answer is authenticated by checking against the stored history_hash.\\n    /// One of the inputs to history_hash is the history_hash before it, so we use that to authenticate the next entry, etc\\n    /// Once we get to a null hash we'll know we're done and there are no more answers.\\n    /// Usually you would call the whole thing in a single transaction, but if not then the data is persisted to pick up later.\\n    /// @param question_id The ID of the question\\n    /// @param history_hashes Second-last-to-first, the hash of each history entry. (Final one should be empty).\\n    /// @param addrs Last-to-first, the address of each answerer or commitment sender\\n    /// @param bonds Last-to-first, the bond supplied with each answer or commitment\\n    /// @param answers Last-to-first, each answer supplied, or commitment ID if the answer was supplied with commit->reveal\\n    function claimWinnings(\\n        bytes32 question_id, \\n        bytes32[] memory history_hashes, address[] memory addrs, uint256[] memory bonds, bytes32[] memory answers\\n    ) \\n        stateFinalized(question_id)\\n    public {\\n\\n        require(history_hashes.length > 0, \\\"at least one history hash entry must be provided\\\");\\n\\n        // These are only set if we split our claim over multiple transactions.\\n        address payee = question_claims[question_id].payee; \\n        uint256 last_bond = question_claims[question_id].last_bond; \\n        uint256 queued_funds = question_claims[question_id].queued_funds; \\n\\n        // Starts as the hash of the final answer submitted. It'll be cleared when we're done.\\n        // If we're splitting the claim over multiple transactions, it'll be the hash where we left off last time\\n        bytes32 last_history_hash = questions[question_id].history_hash;\\n\\n        bytes32 best_answer = questions[question_id].best_answer;\\n\\n        uint256 i;\\n        for (i = 0; i < history_hashes.length; i++) {\\n        \\n            // Check input against the history hash, and see which of 2 possible values of is_commitment fits.\\n            bool is_commitment = _verifyHistoryInputOrRevert(last_history_hash, history_hashes[i], answers[i], bonds[i], addrs[i]);\\n            \\n            queued_funds = queued_funds + last_bond; \\n            (queued_funds, payee) = _processHistoryItem(\\n                question_id, best_answer, queued_funds, payee, \\n                addrs[i], bonds[i], answers[i], is_commitment);\\n \\n            // Line the bond up for next time, when it will be added to somebody's queued_funds\\n            last_bond = bonds[i];\\n\\n            // Burn (just leave in contract balance) a fraction of all bonds except the final one.\\n            // This creates a cost to increasing your own bond, which could be used to delay resolution maliciously\\n            if (last_bond != questions[question_id].bond) {\\n                last_bond = last_bond - last_bond / BOND_CLAIM_FEE_PROPORTION;\\n            }\\n\\n            last_history_hash = history_hashes[i];\\n\\n        }\\n \\n        if (last_history_hash != NULL_HASH) {\\n            // We haven't yet got to the null hash (1st answer), ie the caller didn't supply the full answer chain.\\n            // Persist the details so we can pick up later where we left off later.\\n\\n            // If we know who to pay we can go ahead and pay them out, only keeping back last_bond\\n            // (We always know who to pay unless all we saw were unrevealed commits)\\n            if (payee != NULL_ADDRESS) {\\n                _payPayee(question_id, payee, queued_funds);\\n                queued_funds = 0;\\n            }\\n\\n            question_claims[question_id].payee = payee;\\n            question_claims[question_id].last_bond = last_bond;\\n            question_claims[question_id].queued_funds = queued_funds;\\n        } else {\\n            // There is nothing left below us so the payee can keep what remains\\n            _payPayee(question_id, payee, queued_funds + last_bond);\\n            delete question_claims[question_id];\\n        }\\n\\n        questions[question_id].history_hash = last_history_hash;\\n\\n    }\\n\\n    function _payPayee(bytes32 question_id, address payee, uint256 value) \\n    internal {\\n        balanceOf[payee] = balanceOf[payee] + value;\\n        emit LogClaim(question_id, payee, value);\\n    }\\n\\n    function _verifyHistoryInputOrRevert(\\n        bytes32 last_history_hash,\\n        bytes32 history_hash, bytes32 answer, uint256 bond, address addr\\n    )\\n    internal pure returns (bool) {\\n        if (last_history_hash == keccak256(abi.encodePacked(history_hash, answer, bond, addr, true)) ) {\\n            return true;\\n        }\\n        if (last_history_hash == keccak256(abi.encodePacked(history_hash, answer, bond, addr, false)) ) {\\n            return false;\\n        } \\n        revert(\\\"History input provided did not match the expected hash\\\");\\n    }\\n\\n    function _processHistoryItem(\\n        bytes32 question_id, bytes32 best_answer, \\n        uint256 queued_funds, address payee, \\n        address addr, uint256 bond, bytes32 answer, bool is_commitment\\n    )\\n    internal returns (uint256, address) {\\n\\n        // For commit-and-reveal, the answer history holds the commitment ID instead of the answer.\\n        // We look at the referenced commitment ID and switch in the actual answer.\\n        if (is_commitment) {\\n            bytes32 commitment_id = answer;\\n            // If it's a commit but it hasn't been revealed, it will always be considered wrong.\\n            if (!commitments[commitment_id].is_revealed) {\\n                delete commitments[commitment_id];\\n                return (queued_funds, payee);\\n            } else {\\n                answer = commitments[commitment_id].revealed_answer;\\n                delete commitments[commitment_id];\\n            }\\n        }\\n\\n        if (answer == best_answer) {\\n\\n            if (payee == NULL_ADDRESS) {\\n\\n                // The entry is for the first payee we come to, ie the winner.\\n                // They get the question bounty.\\n                payee = addr;\\n\\n                if (best_answer != UNRESOLVED_ANSWER && questions[question_id].bounty > 0) {\\n                    _payPayee(question_id, payee, questions[question_id].bounty);\\n                    questions[question_id].bounty = 0;\\n                }\\n\\n            } else if (addr != payee) {\\n\\n                // Answerer has changed, ie we found someone lower down who needs to be paid\\n\\n                // The lower answerer will take over receiving bonds from higher answerer.\\n                // They should also be paid the takeover fee, which is set at a rate equivalent to their bond. \\n                // (This is our arbitrary rule, to give consistent right-answerers a defence against high-rollers.)\\n\\n                // There should be enough for the fee, but if not, take what we have.\\n                // There's an edge case involving weird arbitrator behaviour where we may be short.\\n                uint256 answer_takeover_fee = (queued_funds >= bond) ? bond : queued_funds;\\n                // Settle up with the old (higher-bonded) payee\\n                _payPayee(question_id, payee, queued_funds - answer_takeover_fee);\\n\\n                // Now start queued_funds again for the new (lower-bonded) payee\\n                payee = addr;\\n                queued_funds = answer_takeover_fee;\\n\\n            }\\n\\n        }\\n\\n        return (queued_funds, payee);\\n\\n    }\\n\\n    /// @notice Convenience function to assign bounties/bonds for multiple questions in one go, then withdraw all your funds.\\n    /// Caller must provide the answer history for each question, in reverse order\\n    /// @dev Can be called by anyone to assign bonds/bounties, but funds are only withdrawn for the user making the call.\\n    /// @param question_ids The IDs of the questions you want to claim for\\n    /// @param lengths The number of history entries you will supply for each question ID\\n    /// @param hist_hashes In a single list for all supplied questions, the hash of each history entry.\\n    /// @param addrs In a single list for all supplied questions, the address of each answerer or commitment sender\\n    /// @param bonds In a single list for all supplied questions, the bond supplied with each answer or commitment\\n    /// @param answers In a single list for all supplied questions, each answer supplied, or commitment ID \\n    function claimMultipleAndWithdrawBalance(\\n        bytes32[] memory question_ids, uint256[] memory lengths, \\n        bytes32[] memory hist_hashes, address[] memory addrs, uint256[] memory bonds, bytes32[] memory answers\\n    ) \\n        stateAny() // The finalization checks are done in the claimWinnings function\\n    public {\\n        \\n        uint256 qi;\\n        uint256 i;\\n        for (qi = 0; qi < question_ids.length; qi++) {\\n            bytes32 qid = question_ids[qi];\\n            uint256 ln = lengths[qi];\\n            bytes32[] memory hh = new bytes32[](ln);\\n            address[] memory ad = new address[](ln);\\n            uint256[] memory bo = new uint256[](ln);\\n            bytes32[] memory an = new bytes32[](ln);\\n            uint256 j;\\n            for (j = 0; j < ln; j++) {\\n                hh[j] = hist_hashes[i];\\n                ad[j] = addrs[i];\\n                bo[j] = bonds[i];\\n                an[j] = answers[i];\\n                i++;\\n            }\\n            claimWinnings(qid, hh, ad, bo, an);\\n        }\\n        withdraw();\\n    }\\n\\n    /// @notice Returns the questions's content hash, identifying the question content\\n    /// @param question_id The ID of the question \\n    function getContentHash(bytes32 question_id) \\n    public view returns(bytes32) {\\n        return questions[question_id].content_hash;\\n    }\\n\\n    /// @notice Returns the arbitrator address for the question\\n    /// @param question_id The ID of the question \\n    function getArbitrator(bytes32 question_id) \\n    public view returns(address) {\\n        return questions[question_id].arbitrator;\\n    }\\n\\n    /// @notice Returns the timestamp when the question can first be answered\\n    /// @param question_id The ID of the question \\n    function getOpeningTS(bytes32 question_id) \\n    public view returns(uint32) {\\n        return questions[question_id].opening_ts;\\n    }\\n\\n    /// @notice Returns the timeout in seconds used after each answer\\n    /// @param question_id The ID of the question \\n    function getTimeout(bytes32 question_id) \\n    public view returns(uint32) {\\n        return questions[question_id].timeout;\\n    }\\n\\n    /// @notice Returns the timestamp at which the question will be/was finalized\\n    /// @param question_id The ID of the question \\n    function getFinalizeTS(bytes32 question_id) \\n    public view returns(uint32) {\\n        return questions[question_id].finalize_ts;\\n    }\\n\\n    /// @notice Returns whether the question is pending arbitration\\n    /// @param question_id The ID of the question \\n    function isPendingArbitration(bytes32 question_id) \\n    public view returns(bool) {\\n        return questions[question_id].is_pending_arbitration;\\n    }\\n\\n    /// @notice Returns the current total unclaimed bounty\\n    /// @dev Set back to zero once the bounty has been claimed\\n    /// @param question_id The ID of the question \\n    function getBounty(bytes32 question_id) \\n    public view returns(uint256) {\\n        return questions[question_id].bounty;\\n    }\\n\\n    /// @notice Returns the current best answer\\n    /// @param question_id The ID of the question \\n    function getBestAnswer(bytes32 question_id) \\n    public view returns(bytes32) {\\n        return questions[question_id].best_answer;\\n    }\\n\\n    /// @notice Returns the history hash of the question \\n    /// @param question_id The ID of the question \\n    /// @dev Updated on each answer, then rewound as each is claimed\\n    function getHistoryHash(bytes32 question_id) \\n    public view returns(bytes32) {\\n        return questions[question_id].history_hash;\\n    }\\n\\n    /// @notice Returns the highest bond posted so far for a question\\n    /// @param question_id The ID of the question \\n    function getBond(bytes32 question_id) \\n    public view returns(uint256) {\\n        return questions[question_id].bond;\\n    }\\n\\n    /// @notice Returns the minimum bond that can answer the question\\n    /// @param question_id The ID of the question\\n    function getMinBond(bytes32 question_id)\\n    public view returns(uint256) {\\n        return questions[question_id].min_bond;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@reality.eth/contracts/development/contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.10;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function decimals() external returns (uint8); \\n\\n    function name() external returns (string memory); \\n\\n    function symbol() external returns (string memory); \\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@reality.eth/contracts/development/contracts/IBalanceHolder_ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.10;\\n\\nimport './IERC20.sol';\\n\\ninterface IBalanceHolder_ERC20 {\\n  function withdraw (  ) external;\\n  function balanceOf ( address ) external view returns ( uint256 );\\n  function token ( ) external view returns ( IERC20 );\\n}\\n\"\r\n    },\r\n    \"@reality.eth/contracts/development/contracts/BalanceHolder_ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.10;\\n\\nimport './IERC20.sol';\\nimport './IBalanceHolder_ERC20.sol';\\n\\ncontract BalanceHolder_ERC20 is IBalanceHolder_ERC20 {\\n\\n    IERC20 public token;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    event LogWithdraw(\\n        address indexed user,\\n        uint256 amount\\n    );\\n\\n    function withdraw() \\n    public {\\n        uint256 bal = balanceOf[msg.sender];\\n        balanceOf[msg.sender] = 0;\\n        require(token.transfer(msg.sender, bal));\\n        emit LogWithdraw(msg.sender, bal);\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"answer_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"}],\"name\":\"LogAnswerReveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"LogCancelArbitration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"}],\"name\":\"LogFinalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bounty_added\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LogFundAnswerBounty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"min_bond\",\"type\":\"uint256\"}],\"name\":\"LogMinimumBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"history_hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"is_commitment\",\"type\":\"bool\"}],\"name\":\"LogNewAnswer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"template_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"content_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"created\",\"type\":\"uint256\"}],\"name\":\"LogNewQuestion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"template_id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"question_text\",\"type\":\"string\"}],\"name\":\"LogNewTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LogNotifyOfArbitrationRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"reopened_question_id\",\"type\":\"bytes32\"}],\"name\":\"LogReopenQuestion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogSetQuestionFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"arbitrator_question_fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"template_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"askQuestion\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"template_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"askQuestionERC20\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"template_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_bond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"askQuestionWithMinBondERC20\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"payee_if_wrong\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"last_history_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"last_answer_or_commitment_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"last_answerer\",\"type\":\"address\"}],\"name\":\"assignWinnerAndSubmitAnswerByArbitrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"cancelArbitration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"question_ids\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"lengths\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"hist_hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bonds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"answers\",\"type\":\"bytes32[]\"}],\"name\":\"claimMultipleAndWithdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"history_hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bonds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"answers\",\"type\":\"bytes32[]\"}],\"name\":\"claimWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"reveal_ts\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"is_revealed\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"revealed_answer\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"content\",\"type\":\"string\"}],\"name\":\"createTemplate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"content\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"createTemplateAndAskQuestion\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"fundAnswerBountyERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getArbitrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getBestAnswer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getBounty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getContentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getFinalAnswer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"content_hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"min_timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"min_bond\",\"type\":\"uint256\"}],\"name\":\"getFinalAnswerIfMatches\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getFinalizeTS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getHistoryHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getMinBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getOpeningTS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getTimeout\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"isPendingArbitration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"isSettledTooSoon\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"max_previous\",\"type\":\"uint256\"}],\"name\":\"notifyOfArbitrationRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"question_claims\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"last_bond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"queued_funds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"questions\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"content_hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"finalize_ts\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"is_pending_arbitration\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"best_answer\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"history_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_bond\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"template_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_bond\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"reopens_question_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"reopenQuestionERC20\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"reopened_questions\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"reopener_questions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"resultFor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"resultForOnceSettled\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setQuestionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"answerer\",\"type\":\"address\"}],\"name\":\"submitAnswerByArbitrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"max_previous\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_answerer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"submitAnswerCommitmentERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"max_previous\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"submitAnswerERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"max_previous\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"answerer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"submitAnswerForERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"}],\"name\":\"submitAnswerReveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"template_hashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"templates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RealityETH_ERC20_v3_0", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}