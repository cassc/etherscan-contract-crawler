{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@opengsn/contracts/src/interfaces/IERC2771Recipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title The ERC-2771 Recipient Base Abstract Class - Declarations\\n *\\n * @notice A contract must implement this interface in order to support relayed transaction.\\n *\\n * @notice It is recommended that your contract inherits from the ERC2771Recipient contract.\\n */\\nabstract contract IERC2771Recipient {\\n\\n    /**\\n     * :warning: **Warning** :warning: The Forwarder can have a full control over your Recipient. Only trust verified Forwarder.\\n     * @param forwarder The address of the Forwarder contract that is being used.\\n     * @return isTrustedForwarder `true` if the Forwarder is trusted to forward relayed transactions by this Recipient.\\n     */\\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\\n\\n    /**\\n     * @notice Use this method the contract anywhere instead of msg.sender to support relayed transactions.\\n     * @return sender The real sender of this call.\\n     * For a call that came through the Forwarder the real sender is extracted from the last 20 bytes of the `msg.data`.\\n     * Otherwise simply returns `msg.sender`.\\n     */\\n    function _msgSender() internal virtual view returns (address);\\n\\n    /**\\n     * @notice Use this method in the contract instead of `msg.data` when difference matters (hashing, signature, etc.)\\n     * @return data The real `msg.data` of this call.\\n     * For a call that came through the Forwarder, the real sender address was appended as the last 20 bytes\\n     * of the `msg.data` - so this method will strip those 20 bytes off.\\n     * Otherwise (if the call was made directly and not through the forwarder) simply returns `msg.data`.\\n     */\\n    function _msgData() internal virtual view returns (bytes calldata);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n// Used for calculating decimal-point percentages (10000 = 100%)\\r\\nuint256 constant PERCENTAGE_RANGE = 10000;\\r\\n\\r\\n// Pauser Role - Can pause the game\\r\\nbytes32 constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\r\\n\\r\\n// Minter Role - Can mint items, NFTs, and ERC20 currency\\r\\nbytes32 constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\r\\n\\r\\n// Manager Role - Can manage the shop, loot tables, and other game data\\r\\nbytes32 constant MANAGER_ROLE = keccak256(\\\"MANAGER_ROLE\\\");\\r\\n\\r\\n// Game Logic Contract - Contract that executes game logic and accesses other systems\\r\\nbytes32 constant GAME_LOGIC_CONTRACT_ROLE = keccak256(\\r\\n    \\\"GAME_LOGIC_CONTRACT_ROLE\\\"\\r\\n);\\r\\n\\r\\n// Game Currency Contract - Allowlisted currency ERC20 contract\\r\\nbytes32 constant GAME_CURRENCY_CONTRACT_ROLE = keccak256(\\r\\n    \\\"GAME_CURRENCY_CONTRACT_ROLE\\\"\\r\\n);\\r\\n\\r\\n// Game NFT Contract - Allowlisted game NFT ERC721 contract\\r\\nbytes32 constant GAME_NFT_CONTRACT_ROLE = keccak256(\\\"GAME_NFT_CONTRACT_ROLE\\\");\\r\\n\\r\\n// Game Items Contract - Allowlist game items ERC1155 contract\\r\\nbytes32 constant GAME_ITEMS_CONTRACT_ROLE = keccak256(\\r\\n    \\\"GAME_ITEMS_CONTRACT_ROLE\\\"\\r\\n);\\r\\n\\r\\n// Depositor role - used by Polygon bridge to mint on child chain\\r\\nbytes32 constant DEPOSITOR_ROLE = keccak256(\\\"DEPOSITOR_ROLE\\\");\\r\\n\\r\\n// Randomizer role - Used by the randomizer contract to callback\\r\\nbytes32 constant RANDOMIZER_ROLE = keccak256(\\\"RANDOMIZER_ROLE\\\");\\r\\n\\r\\n// Trusted forwarder role - Used by meta transactions to verify trusted forwader(s)\\r\\nbytes32 constant TRUSTED_FORWARDER_ROLE = keccak256(\\\"TRUSTED_FORWARDER_ROLE\\\");\\r\\n\\r\\n// =====\\r\\n// All of the possible traits in the system\\r\\n// =====\\r\\n\\r\\n// Generation of a token\\r\\nuint256 constant GENERATION_TRAIT_ID = uint256(keccak256(\\\"generation\\\"));\\r\\n\\r\\n// XP for a token\\r\\nuint256 constant XP_TRAIT_ID = uint256(keccak256(\\\"xp\\\"));\\r\\n\\r\\n// Current level of a token\\r\\nuint256 constant LEVEL_TRAIT_ID = uint256(keccak256(\\\"level\\\"));\\r\\n\\r\\n// Whether or not a token is a pirate\\r\\nuint256 constant IS_PIRATE_TRAIT_ID = uint256(keccak256(\\\"is_pirate\\\"));\\r\\n\\r\\n// Rank of the ship\\r\\nuint256 constant SHIP_RANK_TRAIT_ID = uint256(keccak256(\\\"ship_rank\\\"));\\r\\n\\r\\n// Image hash of token's image, used for verifiable / fair drops\\r\\nuint256 constant IMAGE_HASH_TRAIT_ID = uint256(keccak256(\\\"image_hash\\\"));\\r\\n\\r\\n// Name of a token\\r\\nuint256 constant NAME_TRAIT_ID = uint256(keccak256(\\\"name_trait\\\"));\\r\\n\\r\\n// Description of a token\\r\\nuint256 constant DESCRIPTION_TRAIT_ID = uint256(keccak256(\\\"description_trait\\\"));\\r\\n\\r\\n// General rarity for a token (corresponds to IGameRarity)\\r\\nuint256 constant RARITY_TRAIT_ID = uint256(keccak256(\\\"rarity\\\"));\\r\\n\\r\\n// The character's affinity for a specific element\\r\\nuint256 constant ELEMENTAL_AFFINITY_TRAIT_ID = uint256(\\r\\n    keccak256(\\\"elemental_affinity\\\")\\r\\n);\\r\\n\\r\\n// The character's dice rolls\\r\\nuint256 constant DICE_ROLL_1_TRAIT_ID = uint256(keccak256(\\\"dice_roll_1\\\"));\\r\\nuint256 constant DICE_ROLL_2_TRAIT_ID = uint256(keccak256(\\\"dice_roll_2\\\"));\\r\\n\\r\\n// The character's star sign (astrology)\\r\\nuint256 constant STAR_SIGN_TRAIT_ID = uint256(keccak256(\\\"star_sign\\\"));\\r\\n\\r\\n// Image for the token\\r\\nuint256 constant IMAGE_TRAIT_ID = uint256(keccak256(\\\"image_trait\\\"));\\r\\n\\r\\n// How much energy the token provides if used\\r\\nuint256 constant ENERGY_PROVIDED_TRAIT_ID = uint256(\\r\\n    keccak256(\\\"energy_provided\\\")\\r\\n);\\r\\n\\r\\n// Whether a given token is soulbound, meaning it is unable to be transferred\\r\\nuint256 constant SOULBOUND_TRAIT_ID = uint256(keccak256(\\\"soulbound\\\"));\\r\\n\\r\\n// ------\\r\\n// Avatar Profile Picture related traits\\r\\n\\r\\n// If an avatar is a 1 of 1, this is their only trait\\r\\nuint256 constant PROFILE_IS_LEGENDARY_TRAIT_ID = uint256(\\r\\n    keccak256(\\\"profile_is_legendary\\\")\\r\\n);\\r\\n\\r\\n// Avatar's archetype -- possible values: Human (including Druid, Mage, Berserker, Crusty), Robot, Animal, Zombie, Vampire, Ghost\\r\\nuint256 constant PROFILE_CHARACTER_TYPE = uint256(\\r\\n    keccak256(\\\"profile_character_type\\\")\\r\\n);\\r\\n\\r\\n// Avatar's profile picture's background image\\r\\nuint256 constant PROFILE_BACKGROUND_TRAIT_ID = uint256(\\r\\n    keccak256(\\\"profile_background\\\")\\r\\n);\\r\\n\\r\\n// Avatar's eye style\\r\\nuint256 constant PROFILE_EYES_TRAIT_ID = uint256(keccak256(\\\"profile_eyes\\\"));\\r\\n\\r\\n// Avatar's facial hair type\\r\\nuint256 constant PROFILE_FACIAL_HAIR_TRAIT_ID = uint256(\\r\\n    keccak256(\\\"profile_facial_hair\\\")\\r\\n);\\r\\n\\r\\n// Avatar's hair style\\r\\nuint256 constant PROFILE_HAIR_TRAIT_ID = uint256(keccak256(\\\"profile_hair\\\"));\\r\\n\\r\\n// Avatar's skin color\\r\\nuint256 constant PROFILE_SKIN_TRAIT_ID = uint256(keccak256(\\\"profile_skin\\\"));\\r\\n\\r\\n// Avatar's coat color\\r\\nuint256 constant PROFILE_COAT_TRAIT_ID = uint256(keccak256(\\\"profile_coat\\\"));\\r\\n\\r\\n// Avatar's earring(s) type\\r\\nuint256 constant PROFILE_EARRING_TRAIT_ID = uint256(\\r\\n    keccak256(\\\"profile_facial_hair\\\")\\r\\n);\\r\\n\\r\\n// Avatar's eye covering\\r\\nuint256 constant PROFILE_EYE_COVERING_TRAIT_ID = uint256(\\r\\n    keccak256(\\\"profile_eye_covering\\\")\\r\\n);\\r\\n\\r\\n// Avatar's headwear\\r\\nuint256 constant PROFILE_HEADWEAR_TRAIT_ID = uint256(\\r\\n    keccak256(\\\"profile_headwear\\\")\\r\\n);\\r\\n\\r\\n// Avatar's (Mages only) gem color\\r\\nuint256 constant PROFILE_MAGE_GEM_TRAIT_ID = uint256(\\r\\n    keccak256(\\\"profile_mage_gem\\\")\\r\\n);\\r\\n\"\r\n    },\r\n    \"contracts/GameRegistryConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\nimport \\\"@opengsn/contracts/src/interfaces/IERC2771Recipient.sol\\\";\\r\\n\\r\\nimport {IGameRegistry} from \\\"./interfaces/IGameRegistry.sol\\\";\\r\\nimport {ISystem} from \\\"./interfaces/ISystem.sol\\\";\\r\\n\\r\\nimport {TRUSTED_FORWARDER_ROLE} from \\\"./Constants.sol\\\";\\r\\n\\r\\nimport {ITraitsProvider, ID as TRAITS_PROVIDER_ID} from \\\"./interfaces/ITraitsProvider.sol\\\";\\r\\nimport {ILockingSystem, ID as LOCKING_SYSTEM_ID} from \\\"./locking/ILockingSystem.sol\\\";\\r\\nimport {IRandomizer, IRandomizerCallback, ID as RANDOMIZER_ID} from \\\"./randomizer/IRandomizer.sol\\\";\\r\\nimport {ILootSystem, ID as LOOT_SYSTEM_ID} from \\\"./loot/ILootSystem.sol\\\";\\r\\n\\r\\n/** @title Contract that lets a child contract access the GameRegistry contract */\\r\\nabstract contract GameRegistryConsumer is\\r\\n    ISystem,\\r\\n    Ownable,\\r\\n    IERC2771Recipient,\\r\\n    IRandomizerCallback\\r\\n{\\r\\n    /// @notice Whether or not the contract is paused\\r\\n    bool private _paused;\\r\\n\\r\\n    /// @notice Id for the system/component\\r\\n    uint256 private _id;\\r\\n\\r\\n    /// @notice Read access contract\\r\\n    IGameRegistry private _gameRegistry;\\r\\n\\r\\n    /** EVENTS **/\\r\\n\\r\\n    /// @dev Emitted when the pause is triggered by `account`.\\r\\n    event Paused(address account);\\r\\n\\r\\n    /// @dev Emitted when the pause is lifted by `account`.\\r\\n    event Unpaused(address account);\\r\\n\\r\\n    /** ERRORS **/\\r\\n\\r\\n    /// @notice Not authorized to perform action\\r\\n    error MissingRole(address account, bytes32 expectedRole);\\r\\n\\r\\n    /** MODIFIERS **/\\r\\n\\r\\n    // Modifier to verify a user has the appropriate role to call a given function\\r\\n    modifier onlyRole(bytes32 role) {\\r\\n        _checkRole(role, _msgSender());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        _requireNotPaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        _requirePaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /** ERRORS **/\\r\\n\\r\\n    /// @notice gameRegistryAddress does not implement IGameRegistry\\r\\n    error InvalidGameRegistry();\\r\\n\\r\\n    /** SETUP **/\\r\\n\\r\\n    /** Sets the GameRegistry contract address for this contract  */\\r\\n    constructor(address gameRegistryAddress, uint256 id) {\\r\\n        _gameRegistry = IGameRegistry(gameRegistryAddress);\\r\\n        _id = id;\\r\\n\\r\\n        if (gameRegistryAddress == address(0)) {\\r\\n            revert InvalidGameRegistry();\\r\\n        }\\r\\n\\r\\n        _paused = true;\\r\\n    }\\r\\n\\r\\n    /** EXTERNAL **/\\r\\n\\r\\n    /** @return ID for this system */\\r\\n    function getId() public view override returns (uint256) {\\r\\n        return _id;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Pause/Unpause the contract\\r\\n     *\\r\\n     * @param shouldPause Whether or pause or unpause\\r\\n     */\\r\\n    function setPaused(bool shouldPause) external onlyOwner {\\r\\n        if (shouldPause) {\\r\\n            _pause();\\r\\n        } else {\\r\\n            _unpause();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the contract OR the GameRegistry is paused, and false otherwise.\\r\\n     */\\r\\n    function paused() public view virtual returns (bool) {\\r\\n        return _paused || _gameRegistry.paused();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Sets the GameRegistry contract address for this contract\\r\\n     *\\r\\n     * @param gameRegistryAddress  Address for the GameRegistry contract\\r\\n     */\\r\\n    function setGameRegistry(address gameRegistryAddress) external onlyOwner {\\r\\n        _gameRegistry = IGameRegistry(gameRegistryAddress);\\r\\n\\r\\n        if (gameRegistryAddress == address(0)) {\\r\\n            revert InvalidGameRegistry();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** @return GameRegistry contract for this contract */\\r\\n    function getGameRegistry() external view returns (IGameRegistry) {\\r\\n        return _gameRegistry;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function _hasAccessRole(bytes32 role, address account)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _gameRegistry.hasAccessRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with a standard message if `account` is missing `role`.\\r\\n     *\\r\\n     * The format of the revert reason is given by the following regular expression:\\r\\n     *\\r\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\r\\n     */\\r\\n    function _checkRole(bytes32 role, address account) internal view {\\r\\n        if (!_gameRegistry.hasAccessRole(role, account)) {\\r\\n            revert MissingRole(account, role);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** Returns the traits provider for this contract */\\r\\n    function _traitsProvider() internal view returns (ITraitsProvider) {\\r\\n        return ITraitsProvider(_getSystem(TRAITS_PROVIDER_ID));\\r\\n    }\\r\\n\\r\\n    /** @return Interface to the LockingSystem */\\r\\n    function _lockingSystem() internal view returns (ILockingSystem) {\\r\\n        return ILockingSystem(_gameRegistry.getSystem(LOCKING_SYSTEM_ID));\\r\\n    }\\r\\n\\r\\n    /** @return Interface to the LootSystem */\\r\\n    function _lootSystem() internal view returns (ILootSystem) {\\r\\n        return ILootSystem(_gameRegistry.getSystem(LOOT_SYSTEM_ID));\\r\\n    }\\r\\n\\r\\n    /** @return Interface to the Randomizer */\\r\\n    function _randomizer() internal view returns (IRandomizer) {\\r\\n        return IRandomizer(_gameRegistry.getSystem(RANDOMIZER_ID));\\r\\n    }\\r\\n\\r\\n    /** @return Address for a given system */\\r\\n    function _getSystem(uint256 systemId) internal view returns (address) {\\r\\n        return _gameRegistry.getSystem(systemId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Requests randomness from the game's Randomizer contract\\r\\n     *\\r\\n     * @param numWords Number of words to request from the VRF\\r\\n     *\\r\\n     * @return Id of the randomness request\\r\\n     */\\r\\n    function _requestRandomWords(uint32 numWords) internal returns (uint256) {\\r\\n        return\\r\\n            _randomizer().requestRandomWords(\\r\\n                IRandomizerCallback(this),\\r\\n                numWords\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Callback for when a random number request has returned with random words\\r\\n     *\\r\\n     * @param requestId     Id of the request\\r\\n     * @param randomWords   Random words\\r\\n     */\\r\\n    function fulfillRandomWordsCallback(\\r\\n        uint256 requestId,\\r\\n        uint256[] memory randomWords\\r\\n    ) external virtual override {\\r\\n        // Do nothing by default\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the Player address for the Operator account\\r\\n     * @param operatorAccount address of the Operator account to retrieve the player for\\r\\n     */\\r\\n    function _getPlayerAccount(address operatorAccount)\\r\\n        internal\\r\\n        view\\r\\n        returns (address playerAccount)\\r\\n    {\\r\\n        return _gameRegistry.getPlayerAccount(operatorAccount);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IERC2771Recipient\\r\\n    function isTrustedForwarder(address forwarder)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        return\\r\\n            address(_gameRegistry) != address(0) &&\\r\\n            _hasAccessRole(TRUSTED_FORWARDER_ROLE, forwarder);\\r\\n    }\\r\\n\\r\\n    /** INTERNAL **/\\r\\n\\r\\n    /// @inheritdoc IERC2771Recipient\\r\\n    function _msgSender()\\r\\n        internal\\r\\n        view\\r\\n        virtual\\r\\n        override(Context, IERC2771Recipient)\\r\\n        returns (address ret)\\r\\n    {\\r\\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\\r\\n            assembly {\\r\\n                ret := shr(96, calldataload(sub(calldatasize(), 20)))\\r\\n            }\\r\\n        } else {\\r\\n            ret = msg.sender;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IERC2771Recipient\\r\\n    function _msgData()\\r\\n        internal\\r\\n        view\\r\\n        virtual\\r\\n        override(Context, IERC2771Recipient)\\r\\n        returns (bytes calldata ret)\\r\\n    {\\r\\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\\r\\n            return msg.data[0:msg.data.length - 20];\\r\\n        } else {\\r\\n            return msg.data;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** PAUSABLE **/\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the contract is paused.\\r\\n     */\\r\\n    function _requireNotPaused() internal view virtual {\\r\\n        require(!paused(), \\\"Pausable: paused\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the contract is not paused.\\r\\n     */\\r\\n    function _requirePaused() internal view virtual {\\r\\n        require(paused(), \\\"Pausable: not paused\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers stopped state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    function _pause() internal virtual {\\r\\n        require(_paused == false, \\\"Pausable: not paused\\\");\\r\\n        _paused = true;\\r\\n        emit Paused(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns to normal state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    function _unpause() internal virtual {\\r\\n        require(_paused == true, \\\"Pausable: not paused\\\");\\r\\n        _paused = false;\\r\\n        emit Unpaused(_msgSender());\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IGameRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\n\\r\\n// @title Interface the game's ACL / Management Layer\\r\\ninterface IGameRegistry is IERC165 {\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function hasAccessRole(bytes32 role, address account)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    /** @return Whether or not the registry is paused */\\r\\n    function paused() external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * Registers a system by id\\r\\n     *\\r\\n     * @param systemId          Id of the system\\r\\n     * @param systemAddress     Address of the system contract\\r\\n     */\\r\\n    function registerSystem(uint256 systemId, address systemAddress) external;\\r\\n\\r\\n    /** @return System based on an id */\\r\\n    function getSystem(uint256 systemId) external view returns (address);\\r\\n\\r\\n    /** @return Authorized Player account for an address\\r\\n     * @param operatorAddress   Address of the Operator account\\r\\n     */\\r\\n    function getPlayerAccount(address operatorAddress)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ISystem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * Defines a system the game engine\\r\\n */\\r\\ninterface ISystem {\\r\\n    /** @return The ID for the system. Ex: a uint256 casted keccak256 hash */\\r\\n    function getId() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ITraitsProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\n\\r\\nuint256 constant ID = uint256(keccak256(\\\"game.piratenation.traitsprovider\\\"));\\r\\n\\r\\n// Enum describing how the trait can be modified\\r\\nenum TraitBehavior {\\r\\n    NOT_INITIALIZED, // Trait has not been initialized\\r\\n    UNRESTRICTED, // Trait can be changed unrestricted\\r\\n    IMMUTABLE, // Trait can only be set once and then never changed\\r\\n    INCREMENT_ONLY, // Trait can only be incremented\\r\\n    DECREMENT_ONLY // Trait can only be decremented\\r\\n}\\r\\n\\r\\n// Type of data to allow in the trait\\r\\nenum TraitDataType {\\r\\n    NOT_INITIALIZED, // Trait has not been initialized\\r\\n    INT, // int256 data type\\r\\n    UINT, // uint128 data type\\r\\n    BOOL, // bool data type\\r\\n    STRING // string data type\\r\\n}\\r\\n\\r\\n// Holds metadata for a given trait type\\r\\nstruct TraitMetadata {\\r\\n    // Name of the trait, used in tokenURIs\\r\\n    string name;\\r\\n    // How the trait can be modified\\r\\n    TraitBehavior behavior;\\r\\n    // Trait type\\r\\n    TraitDataType dataType;\\r\\n    // Whether or not the trait is a top-level property and should not be in the attribute array\\r\\n    bool isTopLevelProperty;\\r\\n}\\r\\n\\r\\n// Used to pass traits around for URI generation\\r\\nstruct TokenURITrait {\\r\\n    string name;\\r\\n    bytes value;\\r\\n    TraitDataType dataType;\\r\\n    bool isTopLevelProperty;\\r\\n}\\r\\n\\r\\n/** @title Provides a set of traits to a set of ERC721/ERC1155 contracts */\\r\\ninterface ITraitsProvider is IERC165 {\\r\\n    /**\\r\\n     * Sets the value for the string trait of a token, also checks to make sure trait can be modified\\r\\n     *\\r\\n     * @param tokenContract  Address of the token's contract\\r\\n     * @param tokenId        NFT tokenId or ERC1155 token type id\\r\\n     * @param traitId        Id of the trait to modify\\r\\n     * @param value          New value for the given trait\\r\\n     */\\r\\n    function setTraitString(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId,\\r\\n        string calldata value\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Sets several string traits for a given token\\r\\n     *\\r\\n     * @param tokenContract Address of the token's contract\\r\\n     * @param tokenIds       Ids of the token to set traits for\\r\\n     * @param traitIds       Ids of traits to set\\r\\n     * @param values         Values of traits to set\\r\\n     */\\r\\n    function batchSetTraitString(\\r\\n        address tokenContract,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata traitIds,\\r\\n        string[] calldata values\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Sets the value for the uint256 trait of a token, also checks to make sure trait can be modified\\r\\n     *\\r\\n     * @param tokenContract  Address of the token's contract\\r\\n     * @param tokenId        NFT tokenId or ERC1155 token type id\\r\\n     * @param traitId        Id of the trait to modify\\r\\n     * @param value          New value for the given trait\\r\\n     */\\r\\n    function setTraitUint256(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId,\\r\\n        uint256 value\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Sets several uint256 traits for a given token\\r\\n     *\\r\\n     * @param tokenContract Address of the token's contract\\r\\n     * @param tokenIds       Ids of the token to set traits for\\r\\n     * @param traitIds       Ids of traits to set\\r\\n     * @param values         Values of traits to set\\r\\n     */\\r\\n    function batchSetTraitUint256(\\r\\n        address tokenContract,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata traitIds,\\r\\n        uint256[] calldata values\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Sets the value for the int256 trait of a token, also checks to make sure trait can be modified\\r\\n     *\\r\\n     * @param tokenContract  Address of the token's contract\\r\\n     * @param tokenId        NFT tokenId or ERC1155 token type id\\r\\n     * @param traitId        Id of the trait to modify\\r\\n     * @param value          New value for the given trait\\r\\n     */\\r\\n    function setTraitInt256(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId,\\r\\n        int256 value\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Sets several int256 traits for a given token\\r\\n     *\\r\\n     * @param tokenContract Address of the token's contract\\r\\n     * @param tokenIds       Ids of the token to set traits for\\r\\n     * @param traitIds       Ids of traits to set\\r\\n     * @param values         Values of traits to set\\r\\n     */\\r\\n    function batchSetTraitInt256(\\r\\n        address tokenContract,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata traitIds,\\r\\n        int256[] calldata values\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Sets the value for the bool trait of a token, also checks to make sure trait can be modified\\r\\n     *\\r\\n     * @param tokenContract  Address of the token's contract\\r\\n     * @param tokenId        NFT tokenId or ERC1155 token type id\\r\\n     * @param traitId        Id of the trait to modify\\r\\n     * @param value          New value for the given trait\\r\\n     */\\r\\n    function setTraitBool(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId,\\r\\n        bool value\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Sets several bool traits for a given token\\r\\n     *\\r\\n     * @param tokenContract Address of the token's contract\\r\\n     * @param tokenIds       Ids of the token to set traits for\\r\\n     * @param traitIds       Ids of traits to set\\r\\n     * @param values         Values of traits to set\\r\\n     */\\r\\n    function batchSetTraitBool(\\r\\n        address tokenContract,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata traitIds,\\r\\n        bool[] calldata values\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Increments the trait for a token by the given amount\\r\\n     *\\r\\n     * @param tokenContract  Address of the token's contract\\r\\n     * @param tokenId        NFT tokenId or ERC1155 token type id\\r\\n     * @param traitId        Id of the trait to modify\\r\\n     * @param amount         Amount to increment trait by\\r\\n     */\\r\\n    function incrementTrait(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Decrements the trait for a token by the given amount\\r\\n     *\\r\\n     * @param tokenContract  Address of the token's contract\\r\\n     * @param tokenId        NFT tokenId or ERC1155 token type id\\r\\n     * @param traitId        Id of the trait to modify\\r\\n     * @param amount         Amount to decrement trait by\\r\\n     */\\r\\n    function decrementTrait(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Returns the trait data for a given token\\r\\n     *\\r\\n     * @param tokenContract  Address of the token's contract\\r\\n     * @param tokenId        NFT tokenId or ERC1155 token type id\\r\\n     *\\r\\n     * @return A struct containing all traits for the token\\r\\n     */\\r\\n    function getTraitIds(address tokenContract, uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * Retrieves a raw abi-encoded byte data for the given trait\\r\\n     *\\r\\n     * @param tokenContract   Token contract (ERC721 or ERC1155)\\r\\n     * @param tokenId         Id of the NFT or token type\\r\\n     * @param traitId         Id of the trait to retrieve\\r\\n     *\\r\\n     * @return The value of the trait if it exists, reverts if the trait has not been set or is of a different type.\\r\\n     */\\r\\n    function getTraitBytes(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId\\r\\n    ) external view returns (bytes memory);\\r\\n\\r\\n    /**\\r\\n     * Retrieves a int256 trait for the given token\\r\\n     *\\r\\n     * @param tokenContract   Token contract (ERC721 or ERC1155)\\r\\n     * @param tokenId         Id of the NFT or token type\\r\\n     * @param traitId         Id of the trait to retrieve\\r\\n     *\\r\\n     * @return The value of the trait if it exists, reverts if the trait has not been set or is of a different type.\\r\\n     */\\r\\n    function getTraitInt256(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId\\r\\n    ) external view returns (int256);\\r\\n\\r\\n    /**\\r\\n     * Retrieves a uint256 trait for the given token\\r\\n     *\\r\\n     * @param tokenContract   Token contract (ERC721 or ERC1155)\\r\\n     * @param tokenId         Id of the NFT or token type\\r\\n     * @param traitId         Id of the trait to retrieve\\r\\n     *\\r\\n     * @return The value of the trait if it exists, reverts if the trait has not been set or is of a different type.\\r\\n     */\\r\\n    function getTraitUint256(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * Retrieves a bool trait for the given token\\r\\n     *\\r\\n     * @param tokenContract   Token contract (ERC721 or ERC1155)\\r\\n     * @param tokenId         Id of the NFT or token type\\r\\n     * @param traitId         Id of the trait to retrieve\\r\\n     *\\r\\n     * @return The value of the trait if it exists, reverts if the trait has not been set or is of a different type.\\r\\n     */\\r\\n    function getTraitBool(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * Retrieves a string trait for the given token\\r\\n     *\\r\\n     * @param tokenContract   Token contract (ERC721 or ERC1155)\\r\\n     * @param tokenId         Id of the NFT or token type\\r\\n     * @param traitId         Id of the trait to retrieve\\r\\n     *\\r\\n     * @return The value of the trait if it exists, reverts if the trait has not been set or is of a different type.\\r\\n     */\\r\\n    function getTraitString(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId\\r\\n    ) external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * Returns whether or not the given token has a trait\\r\\n     *\\r\\n     * @param tokenContract  Address of the token's contract\\r\\n     * @param tokenId        NFT tokenId or ERC1155 token type id\\r\\n     * @param traitId        Id of the trait to retrieve\\r\\n     *\\r\\n     * @return Whether or not the token has the trait\\r\\n     */\\r\\n    function hasTrait(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 traitId\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @param traitId  Id of the trait to get metadata for\\r\\n     * @return Metadata for the given trait\\r\\n     */\\r\\n    function getTraitMetadata(uint256 traitId)\\r\\n        external\\r\\n        view\\r\\n        returns (TraitMetadata memory);\\r\\n\\r\\n    /**\\r\\n     * Generate a tokenURI based on a set of global properties and traits\\r\\n     *\\r\\n     * @param tokenContract     Address of the token contract\\r\\n     * @param tokenId           Id of the token to generate traits for\\r\\n     *\\r\\n     * @return base64-encoded fully-formed tokenURI\\r\\n     */\\r\\n    function generateTokenURI(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        TokenURITrait[] memory extraTraits\\r\\n    ) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/locking/ILockingSystem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\n\\r\\nuint256 constant ID = uint256(keccak256(\\\"game.piratenation.lockingsystem\\\"));\\r\\n\\r\\n/// @title Interface for the LockingSystem that allows tokens to be locked by the game to prevent transfer\\r\\ninterface ILockingSystem is IERC165 {\\r\\n    /**\\r\\n     * Whether or not an NFT is locked\\r\\n     *\\r\\n     * @param tokenContract Token contract address\\r\\n     * @param tokenId       Id of the token\\r\\n     */\\r\\n    function isNFTLocked(address tokenContract, uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n     * Amount of token locked in the system by a given owner\\r\\n     *\\r\\n     * @param account   \\t  Token owner\\r\\n     * @param tokenContract\\tToken contract address\\r\\n     * @param tokenId       Id of the token\\r\\n     *\\r\\n     * @return Number of tokens locked\\r\\n     */\\r\\n    function itemAmountLocked(\\r\\n        address account,\\r\\n        address tokenContract,\\r\\n        uint256 tokenId\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * Amount of tokens available for unlock\\r\\n     *\\r\\n     * @param account       Token owner\\r\\n     * @param tokenContract Token contract address\\r\\n     * @param tokenId       Id of the token\\r\\n     *\\r\\n     * @return Number of tokens locked\\r\\n     */\\r\\n    function itemAmountUnlocked(\\r\\n        address account,\\r\\n        address tokenContract,\\r\\n        uint256 tokenId\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * Whether or not the given items can be transferred\\r\\n     *\\r\\n     * @param account   \\t    Token owner\\r\\n     * @param tokenContract\\t    Token contract address\\r\\n     * @param ids               Ids of the tokens\\r\\n     * @param amounts           Amounts of the tokens\\r\\n     *\\r\\n     * @return Whether or not the given items can be transferred\\r\\n     */\\r\\n    function canTransferItems(\\r\\n        address account,\\r\\n        address tokenContract,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts\\r\\n    ) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * Lets the game add a reservation to a given NFT, this prevents the NFT from being unlocked\\r\\n     *\\r\\n     * @param tokenContract   Token contract address\\r\\n     * @param tokenId         Token id to reserve\\r\\n     * @param exclusive       Whether or not the reservation is exclusive. Exclusive reservations prevent other reservations from using the tokens by removing them from the pool.\\r\\n     * @param data            Data determined by the reserver, can be used to identify the source of the reservation for display in UI\\r\\n     */\\r\\n    function addNFTReservation(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        bool exclusive,\\r\\n        uint32 data\\r\\n    ) external returns (uint32);\\r\\n\\r\\n    /**\\r\\n     * Lets the game remove a reservation from a given token\\r\\n     *\\r\\n     * @param tokenContract Token contract\\r\\n     * @param tokenId       Id of the token\\r\\n     * @param reservationId Id of the reservation to remove\\r\\n     */\\r\\n    function removeNFTReservation(\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint32 reservationId\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Lets the game add a reservation to a given token, this prevents the token from being unlocked\\r\\n     *\\r\\n     * @param account  \\t\\t\\t    Owner of the token to reserver\\r\\n     * @param tokenContract   Token contract address\\r\\n     * @param tokenId  \\t\\t\\t\\tToken id to reserve\\r\\n     * @param amount \\t\\t\\t\\t\\tNumber of tokens to reserve (1 for NFTs, >=1 for ERC1155)\\r\\n     * @param exclusive\\t\\t\\t\\tWhether or not the reservation is exclusive. Exclusive reservations prevent other reservations from using the tokens by removing them from the pool.\\r\\n     * @param data            Data determined by the reserver, can be used to identify the source of the reservation for display in UI\\r\\n     */\\r\\n    function addItemReservation(\\r\\n        address account,\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount,\\r\\n        bool exclusive,\\r\\n        uint32 data\\r\\n    ) external returns (uint32);\\r\\n\\r\\n    /**\\r\\n     * Lets the game remove a reservation from a given token\\r\\n     *\\r\\n     * @param account   \\t\\t\\tOwner to remove reservation from\\r\\n     * @param tokenContract\\tToken contract\\r\\n     * @param tokenId  \\t\\t\\tId of the token\\r\\n     * @param reservationId Id of the reservation to remove\\r\\n     */\\r\\n    function removeItemReservation(\\r\\n        address account,\\r\\n        address tokenContract,\\r\\n        uint256 tokenId,\\r\\n        uint32 reservationId\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/loot/ILootSystem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\n\\r\\nuint256 constant ID = uint256(keccak256(\\\"game.piratenation.lootsystem\\\"));\\r\\n\\r\\n/// @title Interface for the LootSystem that gives player loot (tokens, XP, etc) for playing the game\\r\\ninterface ILootSystem is IERC165 {\\r\\n    // Type of loot\\r\\n    enum LootType {\\r\\n        UNDEFINED,\\r\\n        ERC20,\\r\\n        ERC721,\\r\\n        ERC1155,\\r\\n        LOOT_TABLE\\r\\n    }\\r\\n\\r\\n    // Individual loot to grant\\r\\n    struct Loot {\\r\\n        // Type of fulfillment (ERC721, ERC1155, ERC20, LOOT_TABLE)\\r\\n        LootType lootType;\\r\\n        // Contract to grant tokens from\\r\\n        address tokenContract;\\r\\n        // Id of the token to grant (ERC1155/LOOT TABLE types only)\\r\\n        uint256 lootId;\\r\\n        // Amount of token to grant (XP, ERC20, ERC1155)\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Grants the given user loot(s), calls VRF to ensure it's truly random\\r\\n     *\\r\\n     * @param to          Address to grant loot to\\r\\n     * @param loots       Loots to grant\\r\\n     */\\r\\n    function grantLoot(address to, Loot[] calldata loots) external;\\r\\n\\r\\n    /**\\r\\n     * Grants the given user loot(s), calls VRF to ensure it's truly random\\r\\n     *\\r\\n     * @param to          Address to grant loot to\\r\\n     * @param loots       Loots to grant\\r\\n     * @param randomWord  Optional random word to skip VRF callback if we already have words generated / are in a VRF callback\\r\\n     */\\r\\n    function grantLootWithRandomWord(\\r\\n        address to,\\r\\n        Loot[] calldata loots,\\r\\n        uint256 randomWord\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * Validate that loots are properly formed. Reverts if the loots are not valid\\r\\n     *\\r\\n     * @param loots Loots to validate\\r\\n     * @return needsVRF Whether or not the loots specified require VRF to generate\\r\\n     */\\r\\n    function validateLoots(Loot[] calldata loots)\\r\\n        external\\r\\n        view\\r\\n        returns (bool needsVRF);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/randomizer/IRandomizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\n\\r\\nimport {IRandomizerCallback} from \\\"./IRandomizerCallback.sol\\\";\\r\\n\\r\\nuint256 constant ID = uint256(keccak256(\\\"game.piratenation.randomizer\\\"));\\r\\n\\r\\ninterface IRandomizer is IERC165 {\\r\\n    /**\\r\\n     * Starts a VRF random number request\\r\\n     *\\r\\n     * @param callbackAddress Address to callback with the random numbers\\r\\n     * @param numWords        Number of words to request from VRF\\r\\n     *\\r\\n     * @return requestId for the random number, will be passed to the callback contract\\r\\n     */\\r\\n    function requestRandomWords(\\r\\n        IRandomizerCallback callbackAddress,\\r\\n        uint32 numWords\\r\\n    ) external returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/randomizer/IRandomizerCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\n\\r\\ninterface IRandomizerCallback {\\r\\n    /**\\r\\n     * Callback for when the Chainlink request returns\\r\\n     *\\r\\n     * @param requestId     Id of the random word request\\r\\n     * @param randomWords   Random words that were generated by the VRF\\r\\n     */\\r\\n    function fulfillRandomWordsCallback(\\r\\n        uint256 requestId,\\r\\n        uint256[] memory randomWords\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/tokens/goldtoken/GoldToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\n\\r\\nimport {MINTER_ROLE} from \\\"../../Constants.sol\\\";\\r\\n\\r\\nimport {IGoldToken, ID} from \\\"./IGoldToken.sol\\\";\\r\\nimport {GameRegistryConsumer} from \\\"../../GameRegistryConsumer.sol\\\";\\r\\n\\r\\n/** @title In-game Currency: Gold */\\r\\ncontract GoldToken is IGoldToken, GameRegistryConsumer, ERC20 {\\r\\n    constructor(address gameRegistryAddress)\\r\\n        ERC20(\\\"Pirate Gold\\\", \\\"PGLD\\\")\\r\\n        GameRegistryConsumer(gameRegistryAddress, ID)\\r\\n    {\\r\\n        // Do nothing\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Mint token to recipient\\r\\n     *\\r\\n     * @param to      The recipient of the token\\r\\n     * @param amount  The amount of token to mint\\r\\n     */\\r\\n    function mint(address to, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        whenNotPaused\\r\\n        onlyRole(MINTER_ROLE)\\r\\n    {\\r\\n        _mint(to, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Burn token from holder\\r\\n     *\\r\\n     * @param from    The holder of the token\\r\\n     * @param amount  The amount of token to burn\\r\\n     */\\r\\n    function burn(address from, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        whenNotPaused\\r\\n        onlyRole(MINTER_ROLE)\\r\\n    {\\r\\n        _burn(from, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc ERC20\\r\\n     * @dev Note: minters can also move currency around to allow in-game actions.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override(ERC20, IERC20) returns (bool) {\\r\\n        // Minters can move currency around to enable gameplay\\r\\n        if (_hasAccessRole(MINTER_ROLE, _msgSender())) {\\r\\n            // Note this avoids events\\r\\n            _transfer(sender, recipient, amount);\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        // Normal ERC20 security flow (need approval, etc.)\\r\\n        return super.transferFrom(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Message sender override to get Context to work with meta transactions\\r\\n     *\\r\\n     */\\r\\n    function _msgSender()\\r\\n        internal\\r\\n        view\\r\\n        override(Context, GameRegistryConsumer)\\r\\n        returns (address)\\r\\n    {\\r\\n        return GameRegistryConsumer._msgSender();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Message data override to get Context to work with meta transactions\\r\\n     *\\r\\n     */\\r\\n    function _msgData()\\r\\n        internal\\r\\n        view\\r\\n        override(Context, GameRegistryConsumer)\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return GameRegistryConsumer._msgData();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/tokens/goldtoken/IGoldToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\n\\r\\nimport {IGameCurrency} from \\\"../IGameCurrency.sol\\\";\\r\\n\\r\\nuint256 constant ID = uint256(keccak256(\\\"game.piratenation.goldtoken\\\"));\\r\\n\\r\\ninterface IGoldToken is IGameCurrency {}\\r\\n\"\r\n    },\r\n    \"contracts/tokens/IGameCurrency.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Interface for a in-game currency, based off of ERC20\\r\\n */\\r\\ninterface IGameCurrency is IERC20 {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n\\r\\n    function burn(address from, uint256 amount) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameRegistryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidGameRegistry\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"expectedRole\",\"type\":\"bytes32\"}],\"name\":\"MissingRole\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"fulfillRandomWordsCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGameRegistry\",\"outputs\":[{\"internalType\":\"contract IGameRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameRegistryAddress\",\"type\":\"address\"}],\"name\":\"setGameRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"shouldPause\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GoldToken", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055a44e7ed23409241e1c4b9c5cbe80a066993bdd", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}