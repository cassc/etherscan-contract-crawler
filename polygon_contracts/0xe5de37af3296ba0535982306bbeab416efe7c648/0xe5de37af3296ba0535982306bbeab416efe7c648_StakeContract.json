{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.9;\r\n\r\nabstract contract ERC20 {\r\n    function name() external view virtual returns (string memory);\r\n    function symbol() external view virtual returns (string memory);\r\n    function decimals() external view virtual returns (uint8);\r\n    function totalSupply() external view virtual returns (uint256);\r\n    function balanceOf(address _owner) external view virtual returns (uint256);\r\n    function allowance(address _owner, address _spender) external view virtual returns (uint256);\r\n    function transfer(address _to, uint256 _value) external virtual returns (bool);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external virtual returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external virtual returns (bool);\r\n}\r\n\r\ncontract StakeContract\r\n{\r\n    uint256 ONE_HUNDRED     = 100000000000000000000;\r\n    uint256 ONE             = 1000000000000000000;\r\n    //uint    POWERUPDECIMALS = 18;\r\n    \r\n    address public networkcoinaddress;\r\n    ERC20 internal networkcointoken;\r\n    string public networkcoinsymbol;\r\n    bool public stakeRewardByAmount; //By amount or by share\r\n\r\n    struct Player{\r\n        address id;\r\n    }\r\n\r\n    struct ParticipantInfo {\r\n        uint deposits;\r\n        uint withdrawals;\r\n        uint stakes;\r\n        uint unstakes;\r\n        uint claims;\r\n    }\r\n\r\n    struct Balance {\r\n        uint256 total;\r\n        uint256 accumulatedEarning;\r\n        uint256 playerIndex;\r\n    }\r\n\r\n    struct StakedBalance {\r\n        uint256 total;\r\n        uint playerIndex;\r\n    }\r\n\r\n    struct StakeRecord {\r\n        uint256 total;\r\n        uint time;\r\n    }\r\n\r\n    struct StakeFee {\r\n        uint256 amount;\r\n        uint time;\r\n        address player;\r\n    }\r\n\r\n    struct PowerUpDepositRecord {\r\n        address powerToken;\r\n        uint time;\r\n    }\r\n\r\n    struct PowerUpRecord {\r\n        uint256 multiply;\r\n        uint durationInSeconds;\r\n    }\r\n\r\n    event OnDeposit(address from, address token, address tokenreceiving, uint256 total);\r\n    event OnWithdraw(address to, address token, address tokenreceiving, uint256 total);\r\n    event OnClaimEarnings(address to, address token, address tokenreceiving, uint256 total);\r\n    event OnStake(address from, address token, address tokenreceiving, uint256 total);\r\n    event OnUnstake(address from, address token, address tokenreceiving, uint256 total);\r\n    event OnPowerUp(address from, address token, address tokenreceiving, address powertoken);\r\n\r\n    address public owner;\r\n    address public feeTo;\r\n\r\n    //Participant list info by UserAddress\r\n    mapping(address => ParticipantInfo) public participants;\r\n\r\n    //Deposited Power-up by UserAddress/Token/TokenReceive\r\n    mapping(address => mapping(address => mapping(address => PowerUpDepositRecord[]))) depositedPowerup;\r\n\r\n    //Power-up token record by Token Address\r\n    mapping(address => PowerUpRecord) poweruptokenlist;\r\n\r\n    //Stake Players of Token/TokenReceive\r\n    mapping(address => mapping(address => Player[])) internal players;\r\n\r\n    //Deposit Players of Token/TokenReceive\r\n    mapping(address => mapping(address => Player[])) internal depositplayers;\r\n\r\n    //Earnings per Seconds per Share or Amount for each TokenStake/TokenReceive\r\n    mapping(address => mapping(address => uint256)) earningspersecondspershareoramount;\r\n\r\n    //Fee percent on stake action\r\n    mapping(address => mapping(address => uint256)) feepercentonstake;\r\n\r\n    //Stake Fee Records of Token/TokenReceive\r\n    mapping(address => mapping(address => StakeFee[])) feeonstakerecords;\r\n    \r\n    //Max and Min Deposit for each TokenStake/TokenReceive\r\n    mapping(address => mapping(address => uint256)) maxDeposit;\r\n    mapping(address => mapping(address => uint256)) minDeposit;\r\n\r\n    //Max and Min Withdrawal for each TokenStake/TokenReceive\r\n    mapping(address => mapping(address => uint256)) maxWithdraw;\r\n    mapping(address => mapping(address => uint256)) minWithdraw;\r\n\r\n    //Active Stake for each TokenStake/TokenReceive\r\n    mapping(address => mapping(address => bool)) activeStake;\r\n\r\n    //Total staked for all users\r\n    mapping(address => mapping(address => uint256)) totalStaked;\r\n\r\n    //Total deposited for all users\r\n    mapping(address => mapping(address => uint256)) totalDeposited;\r\n\r\n    //User lists (1st mapping user, 2nd mapping token, 3rd mapping receiving token)\r\n    mapping(address => mapping(address => mapping(address => Balance))) balances;\r\n    mapping(address => mapping(address => mapping(address => StakedBalance))) stakedbalances;\r\n    mapping(address => mapping(address => mapping(address => StakeRecord[]))) stakerecords;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        feeTo = owner;\r\n        networkcoinaddress = address(0x1110000000000000000100000000000000000111);\r\n        networkcointoken = ERC20(networkcoinaddress);\r\n        networkcoinsymbol = \"ETH\";\r\n        stakeRewardByAmount = true;\r\n    }\r\n\r\n    function setup(ERC20 token, ERC20 tokenReceiving, uint256 maxDepositAllowed, uint256 minDepositAllowed, uint256 maxWithdrawAllowed, uint256 minWithdrawAllowed, uint256 earningsPerSecondsPerShareOrAmount, uint256 feePercentOnStake, string memory networkCoinSymbol) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        require(feePercentOnStake <= ONE_HUNDRED, \"IP\"); //STAKE: Invalid percent fee value\r\n        \r\n        maxDeposit[address(token)][address(tokenReceiving)] = maxDepositAllowed;\r\n        minDeposit[address(token)][address(tokenReceiving)] = minDepositAllowed;\r\n\r\n        maxWithdraw[address(token)][address(tokenReceiving)] = maxWithdrawAllowed;\r\n        minWithdraw[address(token)][address(tokenReceiving)] = minWithdrawAllowed;\r\n\r\n        earningspersecondspershareoramount[address(token)][address(tokenReceiving)] = earningsPerSecondsPerShareOrAmount;\r\n        feepercentonstake[address(token)][address(tokenReceiving)] = feePercentOnStake;\r\n        networkcoinsymbol = networkCoinSymbol;\r\n        activeStake[address(token)][address(tokenReceiving)] = true;\r\n    }\r\n\r\n    function depositToken(ERC20 token, ERC20 tokenReceiving, uint256 amountInWei, bool enterStaked) external \r\n    {\r\n        require(activeStake[address(token)][address(tokenReceiving)] == true, \"IN\"); //STAKE: Inactive stake\r\n\r\n        address tokenAddress = address(token);\r\n        address tokenReceivingAddress = address(tokenReceiving);\r\n\r\n        //Approve (outside): allowed[msg.sender][spender] (sender = my account, spender = stake token address)\r\n        uint256 allowance = token.allowance(msg.sender, address(this));\r\n        require(allowance >= amountInWei, \"AL\"); //STAKE: Check the token allowance. Use approve function.\r\n\r\n        require(amountInWei <= maxDeposit[address(token)][address(tokenReceiving)], \"DH\"); //STAKE: Deposit value is too high.\r\n        require(amountInWei >= minDeposit[address(token)][address(tokenReceiving)], \"DL\"); //STAKE: Deposit value is too low.\r\n\r\n        token.transferFrom(msg.sender, address(this), amountInWei);\r\n\r\n        uint256 currentTotal = balances[msg.sender][tokenAddress][tokenReceivingAddress].total;\r\n\r\n        //Increase +1 participant deposit counter\r\n        participants[msg.sender].deposits = safeAdd(participants[msg.sender].deposits, 1);\r\n\r\n        //If is a new player for deposit, register\r\n        if(balances[msg.sender][tokenAddress][tokenReceivingAddress].total == 0)\r\n        {\r\n            depositplayers[tokenAddress][tokenReceivingAddress].push(Player({\r\n                id: msg.sender\r\n            }));\r\n\r\n            balances[msg.sender][tokenAddress][tokenReceivingAddress].playerIndex = depositplayers[tokenAddress][tokenReceivingAddress].length -1;\r\n        }\r\n\r\n        //Increase/register deposit balance\r\n        balances[msg.sender][tokenAddress][tokenReceivingAddress].total = safeAdd(currentTotal, amountInWei);\r\n\r\n        //Increase general deposit amount\r\n        totalDeposited[tokenAddress][tokenReceivingAddress] = safeAdd(totalDeposited[tokenAddress][tokenReceivingAddress], amountInWei);\r\n\r\n        emit OnDeposit(msg.sender, tokenAddress, tokenReceivingAddress, amountInWei);\r\n\r\n        if(enterStaked == true)\r\n        {\r\n            stakeToken(token, tokenReceiving, amountInWei);\r\n        }\r\n    }\r\n\r\n    function depositNetworkCoin(ERC20 tokenReceiving, bool enterStaked) external payable \r\n    {\r\n        require(msg.value > 0, \"DL\"); //STAKE: Deposit value is too low.\r\n\r\n        ERC20 token = networkcointoken;\r\n        require(activeStake[address(token)][address(tokenReceiving)] == true, \"IN\"); //STAKE: Inactive stake\r\n\r\n        require(msg.value <= maxDeposit[address(token)][address(tokenReceiving)], \"DH\"); //STAKE: Deposit value is too high.\r\n        require(msg.value >= minDeposit[address(token)][address(tokenReceiving)], \"DL\"); //STAKE: Deposit value is too low.\r\n\r\n        uint256 currentTotal = balances[msg.sender][address(token)][address(tokenReceiving)].total;\r\n\r\n        //Increase +1 participant deposit counter\r\n        participants[msg.sender].deposits = safeAdd(participants[msg.sender].deposits, 1);\r\n\r\n        //If is a new player for deposit, register\r\n        if(balances[msg.sender][address(token)][address(tokenReceiving)].total == 0)\r\n        {\r\n            depositplayers[address(token)][address(tokenReceiving)].push(Player({\r\n                id: msg.sender\r\n            }));\r\n\r\n            balances[msg.sender][address(token)][address(tokenReceiving)].playerIndex = depositplayers[address(token)][address(tokenReceiving)].length -1;\r\n        }\r\n\r\n        //Increase/register deposit balance\r\n        balances[msg.sender][address(token)][address(tokenReceiving)].total = safeAdd(currentTotal, msg.value);\r\n\r\n        //Increase general deposit amount\r\n        totalDeposited[address(token)][address(tokenReceiving)] = safeAdd(totalDeposited[address(token)][address(tokenReceiving)], msg.value);\r\n\r\n        emit OnDeposit(msg.sender, address(token), address(tokenReceiving), msg.value);\r\n\r\n        if(enterStaked == true)\r\n        {\r\n            stakeToken(token, tokenReceiving, msg.value);\r\n        }\r\n    }\r\n\r\n    function depositPowerUpOnPair(ERC20 token, ERC20 tokenReceiving, ERC20 powerToken) external \r\n    {\r\n        require(activeStake[address(token)][address(tokenReceiving)] == true, \"IN\"); //STAKE: Inactive stake\r\n\r\n        //address receiver = address(this);\r\n        //address powerTokenAddress = address(powerToken);\r\n\r\n        //Approve (outside): allowed[msg.sender][spender] (sender = my account, spender = stake token address)\r\n        //uint256 allowance = powerToken.allowance(msg.sender, address(this));\r\n\r\n        require(powerToken.allowance(msg.sender, address(this)) >= ONE, \"PA\"); //STAKE: Check the Powerup Token allowance. Use approve function.\r\n\r\n        require(totalStaked[address(token)][address(tokenReceiving)] > 0, \"ZS\"); //STAKE: You need to have some staked value to apply an improvement.\r\n\r\n        powerToken.transferFrom(msg.sender, address(this), ONE);\r\n\r\n        depositedPowerup[msg.sender][address(token)][address(tokenReceiving)].push(PowerUpDepositRecord({\r\n            powerToken: address(powerToken),\r\n            time: block.timestamp\r\n        }));\r\n\r\n        emit OnPowerUp(msg.sender, address(token), address(tokenReceiving), address(powerToken));\r\n    }\r\n\r\n    function getDepositBalance(ERC20 token, ERC20 tokenReceiving) public view returns(uint256 result) \r\n    {\r\n        return getDepositBalanceForPlayer(msg.sender, token, tokenReceiving);\r\n    }\r\n\r\n    function getDepositBalanceForPlayer(address playerAddress, ERC20 token, ERC20 tokenReceiving) public view returns(uint256 result) \r\n    {\r\n        return balances[playerAddress][address(token)][address(tokenReceiving)].total;\r\n    }\r\n\r\n    //Amount of deposit at all - for all users\r\n    function getDepositTotalAmount(ERC20 token, ERC20 tokenReceiving) public view returns(uint256 result) \r\n    {\r\n        return totalDeposited[address(token)][address(tokenReceiving)];\r\n    }\r\n\r\n    function getDepositAccumulatedEarnings(ERC20 token, ERC20 tokenReceiving) public view returns(uint256 result) \r\n    {\r\n        //Value when unstake earning token is different from stake token\r\n        return balances[msg.sender][address(token)][address(tokenReceiving)].accumulatedEarning;\r\n    }\r\n    \r\n    function withdrawToken(ERC20 token, ERC20 tokenReceiving, uint256 amountInWei, bool doClaimEarnings) external {\r\n        withdrawTokenForPlayer(msg.sender, token, tokenReceiving, amountInWei, doClaimEarnings);\r\n    }\r\n\r\n    function withdrawTokenForPlayer(address playerAddress, ERC20 token, ERC20 tokenReceiving, uint256 amountInWei, bool doClaimEarnings) internal {\r\n\r\n        require(amountInWei <= maxWithdraw[address(token)][address(tokenReceiving)], \"WH\"); //STAKE: Withdraw value is too high.\r\n        require(amountInWei >= minWithdraw[address(token)][address(tokenReceiving)], \"WL\"); //STAKE: Withdraw value is too low.\r\n        require(getDepositBalanceForPlayer(playerAddress, token, tokenReceiving) >= amountInWei, \"ZD\"); //STAKE: There is not enough deposit balance to withdraw the requested amount\r\n\r\n        uint sourceBalance;\r\n        if(address(token) != networkcoinaddress)\r\n        {\r\n            //Balance in Token\r\n            sourceBalance = token.balanceOf(address(this));\r\n        }\r\n        else\r\n        {\r\n            //Balance in Network Coin\r\n            sourceBalance = address(this).balance;\r\n        }\r\n\r\n        require(sourceBalance >= amountInWei, \"LW\"); //STAKE: Too low reserve to withdraw the requested amount\r\n\r\n        if(doClaimEarnings == true)\r\n        {\r\n            claimEarnings(token, tokenReceiving);\r\n        }\r\n\r\n        //Withdraw of deposit value\r\n        if(address(token) != networkcoinaddress)\r\n        {\r\n            //Withdraw token\r\n            token.transfer(playerAddress, amountInWei);\r\n        }\r\n        else\r\n        {\r\n            //Withdraw Network Coin\r\n            payable(playerAddress).transfer(amountInWei);\r\n        }\r\n\r\n        uint256 currentTotal = balances[playerAddress][address(token)][address(tokenReceiving)].total;\r\n        balances[playerAddress][address(token)][address(tokenReceiving)].total = safeSub(currentTotal, amountInWei);\r\n\r\n        //Increase +1 participant withdraw counter\r\n        participants[playerAddress].withdrawals = safeAdd(participants[playerAddress].withdrawals, 1);\r\n\r\n        //Reduce general deposit amount\r\n        totalDeposited[address(token)][address(tokenReceiving)] = safeSub(totalDeposited[address(token)][address(tokenReceiving)], amountInWei);\r\n\r\n        //If has no more deposit balances for this token, remove player\r\n        if(balances[playerAddress][address(token)][address(tokenReceiving)].total == 0)\r\n        {\r\n            uint playerIndex = balances[playerAddress][address(token)][address(tokenReceiving)].playerIndex;\r\n\r\n            //Swap index to last\r\n            uint playersCount = depositplayers[address(token)][address(tokenReceiving)].length;\r\n            if(playersCount > 1)\r\n            {\r\n                depositplayers[address(token)][address(tokenReceiving)][playerIndex] = depositplayers[address(token)][address(tokenReceiving)][playersCount - 1];\r\n            }\r\n\r\n            //Delete dirty last\r\n            if(playersCount > 0)\r\n            {\r\n                depositplayers[address(token)][address(tokenReceiving)].pop();\r\n            }\r\n\r\n            //Reindex players\r\n            if(depositplayers[address(token)][address(tokenReceiving)].length > 0)\r\n            {\r\n                for(uint ix = 0; ix < depositplayers[address(token)][address(tokenReceiving)].length; ix++)\r\n                {\r\n                    balances[  depositplayers[address(token)][address(tokenReceiving)][ix].id  ][address(token)][address(tokenReceiving)].playerIndex = ix;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit OnWithdraw(playerAddress, address(token), address(tokenReceiving), amountInWei);\r\n    }\r\n\r\n    function claimEarnings(ERC20 token, ERC20 tokenReceiving) public {\r\n        uint256 accumulatedEarning = balances[msg.sender][address(token)][address(tokenReceiving)].accumulatedEarning;\r\n\r\n        if(address(token) != address(tokenReceiving))\r\n        {\r\n            uint sourceReceivingBalance;\r\n\r\n            if(address(tokenReceiving) != networkcoinaddress)\r\n            {\r\n                //Balance in Token\r\n                sourceReceivingBalance = tokenReceiving.balanceOf(address(this));\r\n            }\r\n            else\r\n            {\r\n                //Balance in Network Coin\r\n                sourceReceivingBalance = address(this).balance;\r\n            }\r\n\r\n            require(sourceReceivingBalance >= accumulatedEarning, \"LE\"); //STAKE: Too low reserve to send earning\r\n        }\r\n\r\n        //Check accumulated earning when receiving token is different from stake token\r\n        if(address(token) != address(tokenReceiving))\r\n        {\r\n            if(accumulatedEarning > 0)\r\n            {\r\n                balances[msg.sender][address(token)][address(tokenReceiving)].accumulatedEarning = 0;\r\n\r\n                //Withdraw bonus\r\n                if(address(tokenReceiving) != networkcoinaddress)\r\n                {\r\n                    //Withdraw bonus token\r\n                    tokenReceiving.transfer(msg.sender, accumulatedEarning);\r\n                }\r\n                else\r\n                {\r\n                    //Withdraw bonus network coin\r\n                    payable(msg.sender).transfer(accumulatedEarning);\r\n                }\r\n\r\n                //Increase +1 participant claim counter\r\n                participants[msg.sender].claims = safeAdd(participants[msg.sender].claims, 1);\r\n\r\n                emit OnClaimEarnings(msg.sender, address(token), address(tokenReceiving), accumulatedEarning);\r\n            }\r\n        }\r\n    }\r\n\r\n    function stakeToken(ERC20 token, ERC20 tokenReceiving, uint256 amountInWei) public {\r\n        \r\n        require(activeStake[address(token)][address(tokenReceiving)] == true, \"IN\"); //STAKE: Inactive stake\r\n\r\n        require(balances[msg.sender][address(token)][address(tokenReceiving)].total >= amountInWei, 'ZD'); //STAKE: There is not enough deposit balance to stake the requested amount\r\n\r\n        uint256 currentTotalStaked = stakedbalances[msg.sender][address(token)][address(tokenReceiving)].total;\r\n        uint256 currentTotal = balances[msg.sender][address(token)][address(tokenReceiving)].total;\r\n\r\n        //If is a new player (no staked balance for this token), register him/her\r\n        if(stakedbalances[msg.sender][address(token)][address(tokenReceiving)].total == 0)\r\n        {\r\n            players[address(token)][address(tokenReceiving)].push(Player({\r\n                id: msg.sender\r\n            }));\r\n\r\n            stakedbalances[msg.sender][address(token)][address(tokenReceiving)].playerIndex = players[address(token)][address(tokenReceiving)].length -1;\r\n        }\r\n\r\n        //Pay admin fee on stake\r\n        uint256 feePercent = feepercentonstake[address(token)][address(tokenReceiving)]; //Eg 10 (10000000000000000000)\r\n\r\n        uint256 fee = 0;\r\n\r\n        if(feePercent > 0)\r\n        {\r\n            require(feePercent <= ONE_HUNDRED, \"IP\"); //STAKE: Invalid percent fee value\r\n\r\n            fee = safeDiv(safeMul(amountInWei, feePercent), ONE_HUNDRED);\r\n\r\n            amountInWei = safeSub(amountInWei, fee);\r\n\r\n            feeonstakerecords[address(token)][address(tokenReceiving)].push(StakeFee({\r\n                player: msg.sender,\r\n                time: block.timestamp,\r\n                amount: fee\r\n            }));\r\n\r\n            if(address(token) != networkcoinaddress)\r\n            {\r\n                //Withdraw token\r\n                token.transfer(feeTo, fee);\r\n            }\r\n            else\r\n            {\r\n                //Withdraw Network Coin\r\n                payable(feeTo).transfer(fee);\r\n            }\r\n        }\r\n\r\n        //Reduce from deposit balance amount and fee\r\n        balances[msg.sender][address(token)][address(tokenReceiving)].total = safeSub(currentTotal, safeAdd(amountInWei, fee));\r\n        \r\n        //Reduce from general deposit amount and fee\r\n        totalDeposited[address(token)][address(tokenReceiving)] = safeSub(totalDeposited[address(token)][address(tokenReceiving)], safeAdd(amountInWei, fee));\r\n        \r\n        //Increse staked balance with amount\r\n        stakedbalances[msg.sender][address(token)][address(tokenReceiving)].total = safeAdd(currentTotalStaked, amountInWei);\r\n        //stakedbalances[msg.sender][address(token)][address(tokenReceiving)].symbol = symbol;\r\n\r\n        //Increase total staked for token with amount\r\n        totalStaked[address(token)][address(tokenReceiving)] = safeAdd(totalStaked[address(token)][address(tokenReceiving)], amountInWei);\r\n\r\n        //Register stake\r\n        stakerecords[msg.sender][address(token)][address(tokenReceiving)].push(\r\n            StakeRecord({\r\n                total: amountInWei,\r\n                //symbol: symbol,\r\n                time: block.timestamp\r\n            })\r\n        );\r\n\r\n        //Increase +1 participant stake counter\r\n        participants[msg.sender].stakes = safeAdd(participants[msg.sender].stakes, 1);\r\n\r\n        emit OnStake(msg.sender, address(token), address(tokenReceiving), amountInWei);\r\n    }\r\n\r\n    function getStakeBalance(ERC20 token, ERC20 tokenReceiving) external view returns(uint256 result) \r\n    {\r\n        return stakedbalances[msg.sender][address(token)][address(tokenReceiving)].total;\r\n    }\r\n\r\n    function getStakeBonus(ERC20 token, ERC20 tokenReceiving) external view returns(uint256 result) \r\n    {\r\n        uint256 totalBonus = 0;\r\n\r\n        if(earningspersecondspershareoramount[address(token)][address(tokenReceiving)] > 0)\r\n        {\r\n            for (uint i = 0; i < getStakeCount(token, tokenReceiving); i++) \r\n            {\r\n                uint256 itemBonus = getStakeBonusByIndex(token, tokenReceiving, i);\r\n                totalBonus = safeAdd(totalBonus, itemBonus);\r\n            }\r\n        }\r\n\r\n        return totalBonus;\r\n    }\r\n\r\n    function getStakeBonusByIndex(ERC20 token, ERC20 tokenReceiving, uint i) public view returns(uint256 result) \r\n    {\r\n        uint256 itemBonus = 0;\r\n\r\n        if(i >= 0)\r\n        {\r\n            StakeRecord[] memory stakeList = stakerecords[msg.sender][address(token)][address(tokenReceiving)];\r\n\r\n            if(stakeList.length > i)\r\n            {\r\n                uint256 earningsPerSecond = earningspersecondspershareoramount[address(token)][address(tokenReceiving)];\r\n\r\n                if(earningsPerSecond > 0)\r\n                {\r\n                    uint256 stakeSeconds = safeSub(block.timestamp, stakeList[i].time);\r\n                    stakeSeconds = getPoweredUpSeconds(stakeSeconds, msg.sender, address(token), address(tokenReceiving));\r\n\r\n                    if(stakeRewardByAmount == false)\r\n                    {\r\n                        //Pay per share participation\r\n                        uint256 share = getStakeShareFromStakeRecord(stakeList[i], address(token), address(tokenReceiving));\r\n                        itemBonus = safeMul(earningsPerSecond, stakeSeconds);\r\n                        itemBonus = safeMul(itemBonus, share);\r\n                        itemBonus = safeDiv(itemBonus, ONE_HUNDRED); //getStakeShareFromStakeRecord function uses 100% scale, transform to 1 using div ONE_HUNDRED\r\n                    }\r\n                    else\r\n                    {\r\n                        //Pay per staked amount\r\n                        uint decimals = 18;\r\n                        if(address(token) != networkcoinaddress)\r\n                        {\r\n                            decimals = getTokenDecimals(token);\r\n                        }\r\n                        \r\n                        itemBonus = safeMul(earningsPerSecond, stakeSeconds);\r\n                        itemBonus = safeMulFloat(itemBonus, stakeList[i].total, decimals);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return itemBonus;\r\n    }\r\n\r\n    function getStakeBonusForecast(ERC20 token, ERC20 tokenReceiving, uint256 stakeAmount, uint256 stakeSecondsForecast) external view returns(uint256 result) \r\n    {\r\n        uint256 earningsPerSecond = earningspersecondspershareoramount[address(token)][address(tokenReceiving)];\r\n\r\n        uint256 itemBonus = 0;\r\n\r\n        if(earningsPerSecond > 0)\r\n        {\r\n            if(stakeRewardByAmount == false)\r\n            {\r\n                //Pay per share participation\r\n                uint256 share = getStakeShareForecast(stakeAmount, address(token), address(tokenReceiving));\r\n                itemBonus = safeMul(earningsPerSecond, stakeSecondsForecast);\r\n                itemBonus = safeMul(itemBonus, share);\r\n                itemBonus = safeDiv(itemBonus, ONE_HUNDRED); //getStakeShareForecast function uses 100% scale, transform to 1 using div ONE_HUNDRED\r\n            }\r\n            else\r\n            {\r\n                //Pay per staked amount\r\n                uint decimals = 18;\r\n                if(address(token) != networkcoinaddress)\r\n                {\r\n                    decimals = getTokenDecimals(token);\r\n                }\r\n\r\n                itemBonus = safeMul(earningsPerSecond, stakeSecondsForecast);\r\n                itemBonus = safeMulFloat(itemBonus, stakeAmount, decimals);\r\n            }\r\n        }\r\n\r\n        return itemBonus;\r\n    }\r\n\r\n    function getStakeCount(ERC20 token, ERC20 tokenReceiving) public view returns(uint256 result) \r\n    {\r\n        return getStakeCountForPlayer(msg.sender, token, tokenReceiving);\r\n    }\r\n\r\n    function getStakeCountForPlayer(address player, ERC20 token, ERC20 tokenReceiving) public view returns(uint256 result) \r\n    {\r\n        return stakerecords[player][address(token)][address(tokenReceiving)].length;\r\n    }\r\n\r\n    //Amount of stake at all - for all users\r\n    function getStakeTotalAmount(ERC20 token, ERC20 tokenReceiving) external view returns(uint256 result) \r\n    {\r\n        return totalStaked[address(token)][address(tokenReceiving)];\r\n    }\r\n\r\n    function getStakeRecord(ERC20 token, ERC20 tokenReceiving, uint stakeIndex) external view returns(StakeRecord memory result) \r\n    {\r\n        return getStakeRecordForPlayer(msg.sender, token, tokenReceiving, stakeIndex);\r\n    }\r\n\r\n    function getStakeRecordForPlayer(address player, ERC20 token, ERC20 tokenReceiving, uint stakeIndex) public view returns(StakeRecord memory result) \r\n    {\r\n        require(stakerecords[player][address(token)][address(tokenReceiving)].length > stakeIndex, 'IX'); //STAKE: Invalid stake index record\r\n        return stakerecords[player][address(token)][address(tokenReceiving)][stakeIndex];\r\n    }\r\n\r\n    /*\r\n    function getStakeShare(ERC20 token, ERC20 tokenReceiving, uint stakeIndex) public view returns(uint256 result) \r\n    {\r\n        require(stakerecords[msg.sender][address(token)][address(tokenReceiving)].length > stakeIndex, 'IX'); //STAKE: Invalid stake index record\r\n        uint share = getStakeShareFromStakeRecord(stakerecords[msg.sender][address(token)][address(tokenReceiving)][stakeIndex], address(token), address(tokenReceiving));\r\n        return share;\r\n    }\r\n    */\r\n\r\n    function getStakeShareFromStakeRecord(StakeRecord memory stakeItem, address tokenAddress, address tokenReceivingAddress) internal view returns(uint256 result)\r\n    {\r\n        uint256 share = 0;\r\n        if(totalStaked[tokenAddress][tokenReceivingAddress] > 0)\r\n        {\r\n            uint256 sharePercentPart = safeMul(stakeItem.total, ONE_HUNDRED);\r\n            share = safeDiv(sharePercentPart, totalStaked[tokenAddress][tokenReceivingAddress]);\r\n        }\r\n\r\n        return share;\r\n    }\r\n\r\n    function getStakeShareForecast(uint256 stakeAmount, address tokenAddress, address tokenReceivingAddress) public view returns(uint256 result)\r\n    {\r\n        uint256 totalStakedSimulationForToken = safeAdd(totalStaked[tokenAddress][tokenReceivingAddress], stakeAmount);\r\n\r\n        uint256 share = 0;\r\n        uint256 sharePercentPart = safeMul(stakeAmount, ONE_HUNDRED);\r\n        share = safeDiv(sharePercentPart, totalStakedSimulationForToken);\r\n\r\n        return share;\r\n    }\r\n\r\n    function unstakeToken(ERC20 token, ERC20 tokenReceiving, uint stakeIndex) external \r\n    {\r\n        unstakeTokenForPlayer(msg.sender, token, tokenReceiving, stakeIndex);\r\n    }\r\n\r\n    function unstakeTokenForPlayer(address playerAddress, ERC20 token, ERC20 tokenReceiving, uint stakeIndex) internal \r\n    {\r\n        require(stakerecords[playerAddress][address(token)][address(tokenReceiving)].length > stakeIndex, 'IX'); //STAKE: Invalid stake index record\r\n\r\n        uint256 stakeItemTotal = stakerecords[playerAddress][address(token)][address(tokenReceiving)][stakeIndex].total;\r\n\r\n        require(stakedbalances[playerAddress][address(token)][address(tokenReceiving)].total >= stakeItemTotal, 'IB'); //STAKE: Invalid stake balance\r\n\r\n        uint256 currentTotal = balances[playerAddress][address(token)][address(tokenReceiving)].total;\r\n        uint256 currentTotalStaked = stakedbalances[playerAddress][address(token)][address(tokenReceiving)].total;\r\n\r\n        uint256 stakeBonus = 0;\r\n\r\n        //if(getStakeCount(token, tokenReceiving) > stakeIndex)\r\n        if(getStakeCountForPlayer(playerAddress, token, tokenReceiving) > stakeIndex) //UPDATED: To test\r\n        {\r\n            //stakeBonus = getStakeBonusByIndex(token, tokenReceiving, stakeIndex);\r\n            stakeBonus = getStakeBonusByIndexForPlayer(playerAddress, token, tokenReceiving, stakeIndex); //UPDATED: To test\r\n        }\r\n\r\n        //Reduce stake balance\r\n        stakedbalances[playerAddress][address(token)][address(tokenReceiving)].total = safeSub(currentTotalStaked, stakeItemTotal);\r\n\r\n        //Increase deposit balance with STAKE + BONUS when stake and profit is the same, otherwise separate increase for STAKE and BONUS as accumulated Earning\r\n        if(address(token) == address(tokenReceiving))\r\n        {\r\n            balances[playerAddress][address(token)][address(tokenReceiving)].total = safeAdd(currentTotal, safeAdd(stakeItemTotal, stakeBonus) );\r\n\r\n            //Increase general deposit amount + BONUS\r\n            totalDeposited[address(token)][address(tokenReceiving)] = safeAdd(totalDeposited[address(token)][address(tokenReceiving)], safeAdd(stakeItemTotal, stakeBonus) );\r\n        }\r\n        else\r\n        {\r\n            balances[playerAddress][address(token)][address(tokenReceiving)].total = safeAdd(currentTotal, stakeItemTotal );\r\n\r\n            //Increase general deposit amount\r\n            totalDeposited[address(token)][address(tokenReceiving)] = safeAdd(totalDeposited[address(token)][address(tokenReceiving)], stakeItemTotal );\r\n\r\n            uint256 accumulatedEarning = balances[playerAddress][address(token)][address(tokenReceiving)].accumulatedEarning;\r\n            if(stakeBonus > 0)\r\n            {\r\n                accumulatedEarning = safeAdd(accumulatedEarning, stakeBonus);\r\n            }\r\n\r\n            balances[playerAddress][address(token)][address(tokenReceiving)].accumulatedEarning = accumulatedEarning;\r\n        }\r\n\r\n        //Reduce total staked for token\r\n        totalStaked[address(token)][address(tokenReceiving)] = safeSub(totalStaked[address(token)][address(tokenReceiving)], stakeItemTotal);\r\n\r\n        //Remove stake record\r\n        uint stakesCount = stakerecords[playerAddress][address(token)][address(tokenReceiving)].length;\r\n\r\n        //Swap last to index\r\n        if(stakesCount > 1)\r\n        {\r\n            stakerecords[playerAddress][address(token)][address(tokenReceiving)][stakeIndex] = stakerecords[playerAddress][address(token)][address(tokenReceiving)][stakesCount - 1];\r\n        }\r\n\r\n        //Delete dirty last\r\n        if(stakesCount > 0)\r\n        {\r\n            stakerecords[playerAddress][address(token)][address(tokenReceiving)].pop();\r\n        }\r\n\r\n        //If has no more staked balances for this token, remove player\r\n        if(stakedbalances[playerAddress][address(token)][address(tokenReceiving)].total == 0)\r\n        {\r\n            uint playerIndex = stakedbalances[playerAddress][address(token)][address(tokenReceiving)].playerIndex;\r\n\r\n            //Swap index to last\r\n            if(players[address(token)][address(tokenReceiving)].length > 1)\r\n            {\r\n                players[address(token)][address(tokenReceiving)][playerIndex] = players[address(token)][address(tokenReceiving)][   players[address(token)][address(tokenReceiving)].length - 1  ];\r\n            }\r\n\r\n            //Delete dirty last\r\n            if(players[address(token)][address(tokenReceiving)].length > 0)\r\n            {\r\n                players[address(token)][address(tokenReceiving)].pop();\r\n            }\r\n\r\n            //Reindex players\r\n            if(players[address(token)][address(tokenReceiving)].length > 0)\r\n            {\r\n                for(uint ix = 0; ix < players[address(token)][address(tokenReceiving)].length; ix++)\r\n                {\r\n                    stakedbalances[  players[address(token)][address(tokenReceiving)][ix].id  ][address(token)][address(tokenReceiving)].playerIndex = ix;\r\n                }\r\n            }\r\n        }\r\n        \r\n        //Increase +1 participant unstake counter\r\n        participants[playerAddress].unstakes = safeAdd(participants[playerAddress].unstakes, 1);\r\n\r\n        //Remove any applied powerup\r\n        clearDepositedPowerUpOfPair(msg.sender, address(token), address(tokenReceiving));\r\n\r\n        emit OnUnstake(playerAddress, address(token), address(tokenReceiving), stakeItemTotal);\r\n    }\r\n\r\n    function getEarningsPerSecondPerShareOrAmountInWei(ERC20 token, ERC20 tokenReceiving) external view returns (uint256 result)\r\n    {\r\n        return earningspersecondspershareoramount[address(token)][address(tokenReceiving)];\r\n    }\r\n\r\n    function setEarningsPerSecondPerShareOrAmountInWei(ERC20 token, ERC20 tokenReceiving, uint256 value) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        earningspersecondspershareoramount[address(token)][address(tokenReceiving)] = value;\r\n        return true;\r\n    }\r\n\r\n    function getFeePercentOnStake(ERC20 token, ERC20 tokenReceiving) external view returns (uint256 result)\r\n    {\r\n        return feepercentonstake[address(token)][address(tokenReceiving)];\r\n    }\r\n\r\n    function setFeePercentOnStake(ERC20 token, ERC20 tokenReceiving, uint256 value) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        require(value <= ONE_HUNDRED, \"IP\"); //STAKE: Invalid percent fee value\r\n        feepercentonstake[address(token)][address(tokenReceiving)] = value;\r\n        return true;\r\n    }\r\n\r\n    function getMaxDepositTokenInWei(ERC20 token, ERC20 tokenReceiving) external view returns (uint256 result)\r\n    {\r\n        return maxDeposit[address(token)][address(tokenReceiving)];\r\n    }\r\n\r\n    function setMaxDepositTokenInWei(ERC20 token, ERC20 tokenReceiving, uint256 value) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        maxDeposit[address(token)][address(tokenReceiving)] = value;\r\n        return true;\r\n    }\r\n\r\n    function getMinDepositTokenInWei(ERC20 token, ERC20 tokenReceiving) external view returns (uint256 result)\r\n    {\r\n        return minDeposit[address(token)][address(tokenReceiving)];\r\n    }\r\n\r\n    function setMinDepositTokenInWei(ERC20 token, ERC20 tokenReceiving, uint256 value) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        minDeposit[address(token)][address(tokenReceiving)] = value;\r\n        return true;\r\n    }\r\n\r\n    function getMaxWithdrawTokenInWei(ERC20 token, ERC20 tokenReceiving) external view returns (uint256 result)\r\n    {\r\n        return maxWithdraw[address(token)][address(tokenReceiving)];\r\n    }\r\n\r\n    function setMaxWithdrawTokenInWei(ERC20 token, ERC20 tokenReceiving, uint256 value) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        maxWithdraw[address(token)][address(tokenReceiving)] = value;\r\n        return true;\r\n    }\r\n\r\n    function getMinWithdrawTokenInWei(ERC20 token, ERC20 tokenReceiving) external view returns (uint256 result)\r\n    {\r\n        return minWithdraw[address(token)][address(tokenReceiving)];\r\n    }\r\n\r\n    function setMinWithdrawTokenInWei(ERC20 token, ERC20 tokenReceiving, uint256 value) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        minWithdraw[address(token)][address(tokenReceiving)] = value;\r\n        return true;\r\n    }\r\n\r\n    function getDepositAccumulatedEarningsForPlayer(address playerAddress, ERC20 token, ERC20 tokenReceiving) external view returns(uint256 result) \r\n    {\r\n        //Value when unstake earning token is different from stake token\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        return balances[playerAddress][address(token)][address(tokenReceiving)].accumulatedEarning;\r\n    }\r\n\r\n    function getStakeBalanceForPlayer(address playerAddress, ERC20 token, ERC20 tokenReceiving) external view returns(uint256 result) \r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        return stakedbalances[playerAddress][address(token)][address(tokenReceiving)].total;\r\n    }\r\n\r\n    function getStakeBonusByIndexForPlayer(address playerAddress, ERC20 token, ERC20 tokenReceiving, uint i) public view returns(uint256 result) \r\n    {\r\n        uint256 itemBonus = 0;\r\n\r\n        if(i >= 0)\r\n        {\r\n            if(stakerecords[playerAddress][address(token)][address(tokenReceiving)].length > i)\r\n            {\r\n                uint256 earningsPerSecond = earningspersecondspershareoramount[address(token)][address(tokenReceiving)];\r\n\r\n                if(earningsPerSecond > 0)\r\n                {\r\n                    uint256 stakeSeconds = safeSub(block.timestamp, stakerecords[playerAddress][address(token)][address(tokenReceiving)][i].time);\r\n                    stakeSeconds = getPoweredUpSeconds(stakeSeconds, playerAddress, address(token), address(tokenReceiving));\r\n\r\n                    if(stakeRewardByAmount == false)\r\n                    {\r\n                        //Pay per share participation\r\n                        uint256 share = getStakeShareFromStakeRecord(stakerecords[playerAddress][address(token)][address(tokenReceiving)][i], address(token), address(tokenReceiving));\r\n                        itemBonus = safeMul(earningsPerSecond, stakeSeconds);\r\n                        itemBonus = safeMul(itemBonus, share);\r\n                        itemBonus = safeDiv(itemBonus, ONE_HUNDRED); //getStakeShareFromStakeRecord function uses 100% scale, transform to 1 using div ONE_HUNDRED\r\n                    }\r\n                    else\r\n                    {\r\n                        //Pay per staked amount\r\n                        uint decimals = 18;\r\n                        if(address(token) != networkcoinaddress)\r\n                        {\r\n                            decimals = getTokenDecimals(token);\r\n                        }\r\n\r\n                        itemBonus = safeMul(earningsPerSecond, stakeSeconds);\r\n                        itemBonus = safeMulFloat(itemBonus, stakerecords[playerAddress][address(token)][address(tokenReceiving)][i].total, decimals);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return itemBonus;\r\n    }\r\n\r\n    function clearDepositBalanceForPlayer(address playerAddress, ERC20 token, ERC20 tokenReceiving) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        //Reduce general deposit amount\r\n        totalDeposited[address(token)][address(tokenReceiving)] = safeSub(totalDeposited[address(token)][address(tokenReceiving)], balances[playerAddress][address(token)][address(tokenReceiving)].total);\r\n\r\n        //Set user balance to Zero\r\n        balances[playerAddress][address(token)][address(tokenReceiving)].total = 0;\r\n\r\n        //Remove player\r\n        //Swap index to last\r\n        uint playersCount = depositplayers[address(token)][address(tokenReceiving)].length;\r\n        if(playersCount > 1)\r\n        {\r\n            depositplayers[address(token)][address(tokenReceiving)][  balances[playerAddress][address(token)][address(tokenReceiving)].playerIndex  ] = depositplayers[address(token)][address(tokenReceiving)][playersCount - 1];\r\n        }\r\n\r\n        //Delete dirty last\r\n        if(playersCount > 0)\r\n        {\r\n            depositplayers[address(token)][address(tokenReceiving)].pop();\r\n        }\r\n        \r\n        //Reindex players\r\n        if(depositplayers[address(token)][address(tokenReceiving)].length > 0)\r\n        {\r\n            for(uint ix = 0; ix < depositplayers[address(token)][address(tokenReceiving)].length; ix++)\r\n            {\r\n                balances[  depositplayers[address(token)][address(tokenReceiving)][ix].id  ][address(token)][address(tokenReceiving)].playerIndex = ix;\r\n            }\r\n        }\r\n    }\r\n\r\n    function clearStakeBalanceForPlayer(address playerAddress, ERC20 token, ERC20 tokenReceiving) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        //Set Stake Balance to Zero\r\n        stakedbalances[playerAddress][address(token)][address(tokenReceiving)].total = 0;\r\n\r\n        //Reduce total staked for token\r\n        totalStaked[address(token)][address(tokenReceiving)] = safeSub(totalStaked[address(token)][address(tokenReceiving)], stakedbalances[playerAddress][address(token)][address(tokenReceiving)].total);\r\n\r\n        //Clear stake records of user\r\n        if(stakerecords[playerAddress][address(token)][address(tokenReceiving)].length > 0)\r\n        {\r\n            delete stakerecords[playerAddress][address(token)][address(tokenReceiving)];\r\n        }\r\n\r\n        //Remove player\r\n        //Swap index to last\r\n        if(players[address(token)][address(tokenReceiving)].length > 1)\r\n        {\r\n            players[address(token)][address(tokenReceiving)][   stakedbalances[playerAddress][address(token)][address(tokenReceiving)].playerIndex   ] = players[address(token)][address(tokenReceiving)][   players[address(token)][address(tokenReceiving)].length  - 1];\r\n        }\r\n\r\n        //Delete dirty last\r\n        if(players[address(token)][address(tokenReceiving)].length > 0)\r\n        {\r\n            players[address(token)][address(tokenReceiving)].pop();\r\n        }\r\n\r\n        //Reindex players\r\n        if(players[address(token)][address(tokenReceiving)].length > 0)\r\n        {\r\n            for(uint ix = 0; ix < players[address(token)][address(tokenReceiving)].length; ix++)\r\n            {\r\n                stakedbalances[  players[address(token)][address(tokenReceiving)][ix].id  ][address(token)][address(tokenReceiving)].playerIndex = ix;\r\n            }\r\n        }\r\n    }\r\n\r\n    function forcePlayerToUnstake(address playerAddress, ERC20 token, ERC20 tokenReceiving, uint stakeIndex) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        unstakeTokenForPlayer(playerAddress, token, tokenReceiving, stakeIndex);\r\n    }\r\n\r\n    function forceAllToUnstake(ERC20 token, ERC20 tokenReceiving) public\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        for(uint ix = 0; ix < players[address(token)][address(tokenReceiving)].length; ix++)\r\n        {\r\n            address currentPlayerInStake = players[address(token)][address(tokenReceiving)][ix].id;\r\n\r\n            for(uint ixSt = 0; ixSt < stakerecords[currentPlayerInStake][address(token)][address(tokenReceiving)].length; ixSt++)\r\n            {\r\n                uint indexToUnstake = 0; //After unstake next item always remains at zero position\r\n                unstakeTokenForPlayer(currentPlayerInStake, token, tokenReceiving, indexToUnstake);\r\n            }\r\n        }\r\n    }\r\n\r\n    function forcePlayerToClaimAndWithdraw(address playerAddress, ERC20 token, ERC20 tokenReceiving) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        if(balances[playerAddress][address(token)][address(tokenReceiving)].total > 0)\r\n        {\r\n            withdrawTokenForPlayer(playerAddress, token, tokenReceiving, balances[playerAddress][address(token)][address(tokenReceiving)].total, true);                \r\n        }\r\n    }\r\n\r\n    function forceAllToClaimAndWithdraw(ERC20 token, ERC20 tokenReceiving) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        for(uint ix = 0; ix < depositplayers[address(token)][address(tokenReceiving)].length; ix++)\r\n        {\r\n            uint256 amountInDeposit = balances[   depositplayers[address(token)][address(tokenReceiving)][ix].id   ][address(token)][address(tokenReceiving)].total;\r\n                                                   \r\n            if(amountInDeposit > 0)\r\n            {\r\n                withdrawTokenForPlayer(depositplayers[address(token)][address(tokenReceiving)][ix].id, token, tokenReceiving, amountInDeposit, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    function transferFund(ERC20 token, address to, uint256 amountInWei) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        //Withdraw of deposit value\r\n        if(address(token) != networkcoinaddress)\r\n        {\r\n            //Withdraw token\r\n            token.transfer(to, amountInWei);\r\n        }\r\n        else\r\n        {\r\n            //Withdraw Network Coin\r\n            payable(to).transfer(amountInWei);\r\n        }\r\n    }\r\n\r\n    function supplyNetworkCoin() payable external {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        // nothing else to do!\r\n    }\r\n\r\n    function setActiveStake(ERC20 token, ERC20 tokenReceiving, bool value) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        activeStake[address(token)][address(tokenReceiving)] = value;\r\n        if(value == false)\r\n        {\r\n            forceAllToUnstake(token, tokenReceiving);\r\n        }\r\n    }\r\n\r\n    function getActiveStake(ERC20 token, ERC20 tokenReceiving) external view returns (bool result)\r\n    {\r\n        return activeStake[address(token)][address(tokenReceiving)];\r\n    }\r\n\r\n    function getStakeFeeCount(ERC20 token, ERC20 tokenReceiving) external view returns (uint256 result)\r\n    {\r\n        return feeonstakerecords[address(token)][address(tokenReceiving)].length;\r\n    }\r\n\r\n    function getStakePlayersCount(ERC20 token, ERC20 tokenReceiving) external view returns (uint256 result)\r\n    {\r\n        return players[address(token)][address(tokenReceiving)].length;\r\n    }\r\n\r\n    function getApprovedAllowance(ERC20 token) external view returns (uint256 result)\r\n    {\r\n        require(address(token) != networkcoinaddress, 'NA'); //STAKE: Network Coin could not be used with allowance.\r\n        return token.allowance(msg.sender, address(this));\r\n    }\r\n\r\n    function getTokenDecimals(ERC20 token) internal view returns(uint8 result)\r\n    {\r\n        uint8 defaultDecimals = 18;\r\n\r\n        try token.decimals() returns (uint8 v) \r\n        {\r\n            return (v);\r\n        } \r\n        catch (bytes memory /*lowLevelData*/) \r\n        {\r\n            return (defaultDecimals);\r\n        }\r\n    }\r\n\r\n    function setOwner(address newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        owner = newValue;\r\n        return true;\r\n    }\r\n\r\n    function setFeeTo(address newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        feeTo = newValue;\r\n        return true;\r\n    }\r\n\r\n    function setNetworkCoinAddress(address newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        networkcoinaddress = newValue;\r\n        return true;\r\n    }\r\n\r\n    function setNetworkCoinSymbol(string memory newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        networkcoinsymbol = newValue;\r\n        return true;\r\n    }\r\n\r\n    function setStakeRewardByAmount(bool newValue) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        stakeRewardByAmount = newValue;\r\n        return true;\r\n    }\r\n\r\n    function setPowerUpToken(address powerToken, uint256 multiply, uint durationInSeconds) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n\r\n        poweruptokenlist[powerToken].multiply = multiply;\r\n        poweruptokenlist[powerToken].durationInSeconds = durationInSeconds;\r\n\r\n        return true;\r\n    }\r\n\r\n    function getPowerUpTokenMultiply(address powerToken) external view returns (uint256 value)\r\n    {\r\n        return poweruptokenlist[powerToken].multiply;\r\n    }\r\n\r\n    function getPowerUpTokenDuration(address powerToken) external view returns (uint value)\r\n    {\r\n        return poweruptokenlist[powerToken].durationInSeconds;\r\n    }\r\n\r\n    function getDepositedPowerUpCountForPair(address playerAddress, address tokenAddress, address tokenReceivingAddress) external view returns (uint256 value)\r\n    {\r\n        return depositedPowerup[playerAddress][tokenAddress][tokenReceivingAddress].length;\r\n    }\r\n\r\n    function getDepositedPowerUpToken(address playerAddress, address tokenAddress, address tokenReceivingAddress, uint256 ix) external view returns (address value)\r\n    {\r\n        return depositedPowerup[playerAddress][tokenAddress][tokenReceivingAddress][ix].powerToken;\r\n    }\r\n\r\n    function getDepositedPowerUpTime(address playerAddress, address tokenAddress, address tokenReceivingAddress, uint256 ix) external view returns (uint value)\r\n    {\r\n        return depositedPowerup[playerAddress][tokenAddress][tokenReceivingAddress][ix].time;\r\n    }\r\n\r\n    function getDepositedPowerUpTimeLeftToFinish(address playerAddress, address tokenAddress, address tokenReceivingAddress, uint256 ix) external view returns (uint value)\r\n    {\r\n        uint duration = poweruptokenlist[ depositedPowerup[playerAddress][tokenAddress][tokenReceivingAddress][ix].powerToken ].durationInSeconds;\r\n        uint timeOut = safeAdd(depositedPowerup[playerAddress][tokenAddress][tokenReceivingAddress][ix].time, duration);\r\n        uint result = 0;\r\n        \r\n        if(timeOut >= block.timestamp)\r\n        {\r\n            result = safeSub(timeOut, block.timestamp);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function clearDepositedPowerUpOfPair(address playerAddress, address tokenAddress, address tokenReceivingAddress) internal returns(bool result)\r\n    {\r\n        delete depositedPowerup[playerAddress][tokenAddress][tokenReceivingAddress];\r\n        return true;\r\n    }\r\n\r\n    function getPoweredUpSeconds(uint stakeSeconds, address playerAddress, address tokenAddress, address tokenReceivingAddress) internal view returns (uint result)\r\n    {\r\n        uint newTime;\r\n        uint fullBonusTime = 0;\r\n        uint powerUpUsedTime = 0;\r\n        \r\n        for(uint ix = 0; ix < depositedPowerup[playerAddress][tokenAddress][tokenReceivingAddress].length; ix++)\r\n        {\r\n            address powerToken = depositedPowerup[playerAddress][tokenAddress][tokenReceivingAddress][ix].powerToken;\r\n            uint startedAt = depositedPowerup[playerAddress][tokenAddress][tokenReceivingAddress][ix].time;\r\n\r\n            uint usedTime;\r\n\r\n            if(block.timestamp > safeAdd(startedAt, poweruptokenlist[powerToken].durationInSeconds))\r\n            {\r\n                usedTime = poweruptokenlist[powerToken].durationInSeconds; //100% of power-up card was used\r\n            }\r\n            else\r\n            {\r\n                usedTime = safeSub(block.timestamp, startedAt); //Add partial used time of power-up card\r\n            }\r\n\r\n            //Regitering used time\r\n            powerUpUsedTime = safeAdd(powerUpUsedTime, usedTime); \r\n\r\n            //Empowering used time and add to bonus time\r\n            fullBonusTime = safeAdd(fullBonusTime, safeMul(usedTime, poweruptokenlist[powerToken].multiply));\r\n        }\r\n\r\n        if(fullBonusTime > 0)\r\n        {\r\n            if(stakeSeconds > powerUpUsedTime)\r\n            {\r\n                //Swap powerUp UsedTime with bonusTime\r\n                newTime = safeSub(stakeSeconds, powerUpUsedTime);\r\n                newTime = safeAdd(stakeSeconds, fullBonusTime);\r\n            }\r\n            else \r\n            {\r\n                //The sum of used time in powerup is greather than stake time, add everything to current stake time\r\n                newTime = safeAdd(stakeSeconds, fullBonusTime);\r\n                \r\n                //newTime = fullBonusTime;\r\n                \r\n            }\r\n        }\r\n        else\r\n        {\r\n            //No power-up bonus\r\n            newTime = stakeSeconds;\r\n        }\r\n\r\n        return newTime;\r\n    }\r\n\r\n    //Safe Math Functions\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"OADD\"); //STAKE: SafeMath: addition overflow\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return safeSub(a, b, \"OSUB\"); //STAKE: subtraction overflow\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \r\n    {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0) \r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"OMUL\"); //STAKE: multiplication overflow\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeMulFloat(uint256 a, uint256 b, uint decimals) internal pure returns(uint256)\r\n    {\r\n        if (a == 0 || decimals == 0)  \r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint result = safeDiv(safeMul(a, b), safePow(10, uint256(decimals)));\r\n\r\n        return result;\r\n    }\r\n\r\n    function safePow(uint256 n, uint256 e) internal pure returns(uint256)\r\n    {\r\n\r\n        if (e == 0) \r\n        {\r\n            return 1;\r\n        } \r\n        else if (e == 1) \r\n        {\r\n            return n;\r\n        } \r\n        else \r\n        {\r\n            uint256 p = safePow(n,  safeDiv(e, 2));\r\n            p = safeMul(p, p);\r\n\r\n            if (safeMod(e, 2) == 1) \r\n            {\r\n                p = safeMul(p, n);\r\n            }\r\n\r\n            return p;\r\n        }\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return safeDiv(a, b, \"ZDIV\"); //STAKE: division by zero\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \r\n    {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeMod(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return safeMod(a, b, \"ZMOD\"); //STAKE: modulo by zero\r\n    }\r\n\r\n    function safeMod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \r\n    {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenreceiving\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"OnClaimEarnings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenreceiving\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"OnDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenreceiving\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"powertoken\",\"type\":\"address\"}],\"name\":\"OnPowerUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenreceiving\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"OnStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenreceiving\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"OnUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenreceiving\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"OnWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"claimEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"clearDepositBalanceForPlayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"clearStakeBalanceForPlayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enterStaked\",\"type\":\"bool\"}],\"name\":\"depositNetworkCoin\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"powerToken\",\"type\":\"address\"}],\"name\":\"depositPowerUpOnPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enterStaked\",\"type\":\"bool\"}],\"name\":\"depositToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"forceAllToClaimAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"forceAllToUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"forcePlayerToClaimAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"forcePlayerToUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getActiveStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getApprovedAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getDepositAccumulatedEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getDepositAccumulatedEarningsForPlayer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getDepositBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getDepositBalanceForPlayer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getDepositTotalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenReceivingAddress\",\"type\":\"address\"}],\"name\":\"getDepositedPowerUpCountForPair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenReceivingAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ix\",\"type\":\"uint256\"}],\"name\":\"getDepositedPowerUpTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenReceivingAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ix\",\"type\":\"uint256\"}],\"name\":\"getDepositedPowerUpTimeLeftToFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenReceivingAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ix\",\"type\":\"uint256\"}],\"name\":\"getDepositedPowerUpToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getEarningsPerSecondPerShareOrAmountInWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getFeePercentOnStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getMaxDepositTokenInWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getMaxWithdrawTokenInWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getMinDepositTokenInWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getMinWithdrawTokenInWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"powerToken\",\"type\":\"address\"}],\"name\":\"getPowerUpTokenDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"powerToken\",\"type\":\"address\"}],\"name\":\"getPowerUpTokenMultiply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getStakeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getStakeBalanceForPlayer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getStakeBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getStakeBonusByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getStakeBonusByIndexForPlayer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeSecondsForecast\",\"type\":\"uint256\"}],\"name\":\"getStakeBonusForecast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getStakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getStakeCountForPlayer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getStakeFeeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getStakePlayersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"getStakeRecord\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeContract.StakeRecord\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"getStakeRecordForPlayer\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeContract.StakeRecord\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenReceivingAddress\",\"type\":\"address\"}],\"name\":\"getStakeShareForecast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"}],\"name\":\"getStakeTotalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkcoinaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkcoinsymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"participants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setActiveStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setEarningsPerSecondPerShareOrAmountInWei\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setFeePercentOnStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMaxDepositTokenInWei\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMaxWithdrawTokenInWei\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMinDepositTokenInWei\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMinWithdrawTokenInWei\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setNetworkCoinAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"setNetworkCoinSymbol\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"powerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"multiply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"durationInSeconds\",\"type\":\"uint256\"}],\"name\":\"setPowerUpToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newValue\",\"type\":\"bool\"}],\"name\":\"setStakeRewardByAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositAllowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDepositAllowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawAllowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minWithdrawAllowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earningsPerSecondsPerShareOrAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePercentOnStake\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"networkCoinSymbol\",\"type\":\"string\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeRewardByAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"stakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyNetworkCoin\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"transferFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"unstakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"tokenReceiving\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"doClaimEarnings\",\"type\":\"bool\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakeContract", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9642f69073abfb41df78b9f11d0158e11e791916402bb96c13f32549078f8a29"}