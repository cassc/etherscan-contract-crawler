{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/HiveTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IERC20 {\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\n\\tfunction transfer(address recipient, uint256 amount) external returns (bool);\\n\\n\\tfunction allowance(address owner, address spender) external view returns (uint256);\\n\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ncontract HiveTreasury {\\n\\n    event Deposit(address indexed sender, uint amount, uint balance);\\n    event SubmitTransaction(\\n        address indexed to,\\n        uint indexed txIndex,\\n        uint value\\n    );\\n    event ConfirmTransaction(address indexed owner, uint indexed txIndex);\\n    event RevokeConfirmation(address indexed owner, uint indexed txIndex);\\n    event ExecuteTransaction(address indexed owner, uint indexed txIndex);\\n    event TransactionDeclined(address indexed owner, uint indexed txIndex);\\n\\n    address[] public owners;\\n    address public admin;\\n    mapping(address => bool) public isOwner;\\n    uint public numConfirmationsRequired;\\n\\n    struct Transaction {\\n        address to;\\n        address tokenAddress;\\n        uint value;\\n        uint numConfirmations;\\n        uint numDeclined;\\n        bool executed;\\n        bool declined;\\n    }\\n\\n   // mapping from tx index => owner => bool, to check if the owner has accepted a proposed transaction\\n    mapping(uint => mapping(address => bool)) public isConfirmed;\\n\\n    // mapping from tx index => owner => bool, to check if the owner has declined a proposed transaction\\n    mapping(uint => mapping(address => bool)) public isDeclined;\\n\\n    Transaction[] public transactions;\\n\\n    modifier onlyOwner() {\\n        require(isOwner[msg.sender], \\\"not owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"not admin\\\");\\n        _;\\n    }\\n\\n    modifier txExists(uint _txIndex) {\\n        require(_txIndex < transactions.length, \\\"tx does not exist\\\");\\n        _;\\n    }\\n\\n    modifier notExecuted(uint _txIndex) {\\n        require(!transactions[_txIndex].executed, \\\"tx already executed\\\");\\n        _;\\n    }\\n\\n    modifier notConfirmed(uint _txIndex) {\\n        require(!isConfirmed[_txIndex][msg.sender], \\\"tx already confirmed\\\");\\n        _;\\n    }\\n\\n     modifier hasNotDeclined(uint _txIndex) {\\n        require(!isDeclined[_txIndex][msg.sender], \\\"tx already declined\\\");\\n        _;\\n    }\\n\\n    modifier notDeclined(uint _txIndex) {\\n        require(!transactions[_txIndex].declined, \\\"tx is declined\\\");\\n        _;\\n    }\\n\\n    constructor(address[] memory _owners, uint _numConfirmationsRequired) {\\n        require(_owners.length > 0, \\\"owners required\\\");\\n        require(\\n            _numConfirmationsRequired > 0 &&\\n                _numConfirmationsRequired <= _owners.length,\\n            \\\"invalid number of required confirmations\\\"\\n        );\\n\\n        for (uint i = 0; i < _owners.length; i++) {\\n            address owner = _owners[i];\\n\\n            require(owner != address(0), \\\"invalid owner\\\");\\n            require(!isOwner[owner], \\\"owner not unique\\\");\\n\\n            isOwner[owner] = true;\\n            owners.push(owner);\\n        }\\n\\n        admin = msg.sender;\\n        numConfirmationsRequired = _numConfirmationsRequired;\\n        \\n    }\\n\\n    receive() external payable {\\n        emit Deposit(msg.sender, msg.value, address(this).balance);\\n    }\\n\\n    modifier checkBalance(uint value, address _tokenAddress) {\\n        if(_tokenAddress == address(0)) {\\n            require(address(this).balance >= value, \\\"Insufficient matic balance\\\");\\n        } else {\\n            require(IERC20(_tokenAddress).balanceOf(address(this)) >= value, \\\"Insufficient token balance\\\");\\n        }\\n\\n        _;\\n    }\\n\\n\\n    /**\\n    * @dev propose a transaction, will only execute if the proposal recieves enough votes\\n    * Requires the caller to be a owner/team member\\n    * @notice _tokenAddress is the address of the erc 20 token to use in the transaction, if _tokenAddress is the zero address it will send matic\\n    */\\n    function submitTransaction(\\n        uint _value,\\n        address _tokenAddress\\n    ) external onlyOwner checkBalance(_value, _tokenAddress) {\\n\\n        uint txIndex = transactions.length;\\n\\n        transactions.push(\\n            Transaction({\\n                to: msg.sender,\\n                tokenAddress : _tokenAddress,\\n                value: _value,\\n                numConfirmations: 1,\\n                numDeclined: 0,\\n                executed: false,\\n                declined: false\\n            })\\n        );\\n\\n        isConfirmed[txIndex][msg.sender] = true;\\n        emit SubmitTransaction(msg.sender, txIndex, _value);\\n    }\\n\\n    /**\\n    * @dev Transfers ownership of the contract\\n    * @notice ownership will be transfered to the Owner Multisig, and will allow it to update the state of the contract\\n    */\\n    function TransferOwnership(address Admin) external onlyAdmin{\\n        admin=Admin; \\n    }\\n\\n    /**\\n    * @dev A team member votes that a proposed transaction should execute, if enough votes have been reached this call will execute the transaction\\n    */\\n    function confirmTransaction(uint _txIndex)\\n        external\\n        onlyOwner\\n        txExists(_txIndex)\\n        notExecuted(_txIndex)\\n        notConfirmed(_txIndex)\\n    {\\n        Transaction storage transaction = transactions[_txIndex];\\n        transaction.numConfirmations += 1;\\n        isConfirmed[_txIndex][msg.sender] = true;\\n\\n        emit ConfirmTransaction(msg.sender, _txIndex);\\n\\n        if(transaction.numConfirmations >= numConfirmationsRequired && !transaction.declined) {\\n            executeTransaction(_txIndex);\\n        }\\n    }\\n\\n    /**\\n    * @dev Executes a valid transaction\\n    */\\n    function executeTransaction(uint _txIndex)\\n        private\\n        onlyOwner\\n        txExists(_txIndex)\\n        notExecuted(_txIndex)\\n        notDeclined(_txIndex)\\n    {\\n        Transaction storage transaction = transactions[_txIndex];\\n\\n        require( isOwner[transaction.to], \\\"To address is not the owner!\\\");\\n\\n        require(\\n            transaction.numConfirmations >= numConfirmationsRequired,\\n            \\\"cannot execute tx\\\"\\n        );\\n\\n        transaction.executed = true;\\n\\n        if(transaction.tokenAddress == address(0)) {\\n            require(address(this).balance >= transaction.value, \\\"Insufficient matic balance to withdraw\\\");\\n            payable(transaction.to).transfer(transaction.value);\\n        } else {\\n            IERC20 token = IERC20(transaction.tokenAddress);\\n            require(token.balanceOf(address(this)) >= transaction.value, \\\"Insufficient token balance to withdraw\\\");\\n            token.transfer(transaction.to, transaction.value);\\n        }\\n\\n        emit ExecuteTransaction(msg.sender, _txIndex);\\n    }\\n\\n    /**\\n    * @dev Votes no on a transaction, if enough have voted no then it invalidates the transaction, preventing it from executing\\n    */\\n    function declineTransaction(uint _txIndex)\\n        public\\n        onlyOwner\\n        txExists(_txIndex)\\n        notExecuted(_txIndex)\\n        hasNotDeclined(_txIndex)\\n    {\\n        Transaction storage transaction = transactions[_txIndex];\\n\\n        transaction.numDeclined += 1;\\n        isDeclined[_txIndex][msg.sender] = true;\\n\\n        if(transaction.numDeclined >= owners.length - numConfirmationsRequired) {\\n\\n            ///@notice transaction can't execute with this number of declines, so it is invalidated and can no longer be executed\\n            transaction.declined = true;\\n\\n        }\\n\\n        emit TransactionDeclined(msg.sender, _txIndex);\\n    }\\n\\n    /**\\n    * @dev Adds a team member allowing them to vote on/propose transactions, this is called by the Owner multisig \\n    * @notice it will also increase the number of confirmations required by 1\\n    */\\n    function addTeamMember(address _addr) external onlyAdmin {\\n        owners.push(_addr);\\n        isOwner[_addr] = true;\\n        numConfirmationsRequired += 1;\\n    }\\n\\n    /**\\n    * @dev Removes a team member from being able to vote on/propose transactions, this is called by the Owner multisig\\n    * @notice it will also reduce the number of confirmations required by 1\\n    */\\n    function removeTeamMember(address _addr) public onlyAdmin {\\n        require(isOwner[_addr], \\\"The input address is not an owner\\\");\\n\\n        for(uint256 i = 0; i < owners.length; i++) {\\n            if(owners[i] == _addr) {\\n                owners[i] = owners[owners.length - 1];\\n                delete isOwner[_addr];\\n                owners.pop();\\n                numConfirmationsRequired -= 1;\\n                break;\\n            }\\n        }\\n    }\\n\\n\\n    function getOwners() public view returns (address[] memory) {\\n        return owners;\\n    }\\n\\n    function getTransactionCount() public view returns (uint) {\\n        return transactions.length;\\n    }\\n\\n    function getTransaction(uint _txIndex)\\n        public\\n        view\\n        returns (\\n            address to,\\n            address tokenAddress,\\n            uint value,\\n            uint numConfirmations,\\n            uint numDeclined,\\n            bool executed,\\n            bool declined\\n        )\\n    {\\n        Transaction memory transaction = transactions[_txIndex];\\n\\n        return (\\n            transaction.to,\\n            transaction.tokenAddress,\\n            transaction.numConfirmations,\\n            transaction.numDeclined,\\n            transaction.value,\\n            transaction.executed,\\n            transaction.declined\\n        );\\n    }\\n\\n    /**\\n    * @dev Changes the number of confirmations required to execute a proposed transaction, this is called by the Owner multisig\\n    */\\n    function changeNumberConfirmations(uint _numConfirmations) public onlyAdmin {\\n\\n        require(_numConfirmations <= owners.length, \\\"Can't have more confirmations required than number of owners\\\");\\n\\n        numConfirmationsRequired = _numConfirmations;\\n\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_numConfirmationsRequired\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"}],\"name\":\"ConfirmTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"}],\"name\":\"ExecuteTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"}],\"name\":\"RevokeConfirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SubmitTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"}],\"name\":\"TransactionDeclined\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Admin\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addTeamMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numConfirmations\",\"type\":\"uint256\"}],\"name\":\"changeNumberConfirmations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"}],\"name\":\"declineTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"}],\"name\":\"getTransaction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numConfirmations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numDeclined\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"declined\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDeclined\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numConfirmationsRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeTeamMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"submitTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numConfirmations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numDeclined\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"declined\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HiveTreasury", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000005000000000000000000000000390c2ffc22f09f09d9ee47539ecb699a8fcc953a0000000000000000000000000566313cc7cb734a5cc5473399a3ccc8c8478c7f0000000000000000000000009cf5b9afa41781bbe13891ed1d6a73d8750a47df00000000000000000000000034c8ac12dcf5b0e4ed2deea7ad9504b3bcdf5e8f0000000000000000000000003f3a7fda3c9b28c9cbbca06ba0b0ebb7005a4013", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}