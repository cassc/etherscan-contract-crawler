{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/CharityToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.12;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./contracts/Context.sol\\\";\\nimport \\\"./contracts/Ownable.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Router.sol\\\";\\n\\ncontract CharityToken is Context, IERC20, Ownable {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant MAX = ~uint256(0);\\n\\n    mapping(address => uint256) private _tOwned;\\n    mapping(address => uint256) private _rOwned;\\n    mapping(address => mapping(address => uint256)) private _allowance;\\n\\n    mapping(address => bool) private _isExcludedFromFee;\\n    mapping(address => bool) private _isExcludedFromReward;\\n    address[] private _excluded;\\n\\n    uint256 private constant _tTotal = 8100 * 10**6 * 10**18;\\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\\n    uint256 private _tFeeTotal;\\n\\n    string private constant _name = \\\"CharityToken\\\";\\n    string private constant _symbol = \\\"CHAT\\\";\\n    uint8 private constant _decimals = 18;\\n\\n    uint256 public _rewardsFee = 3; // REFLECTION RATE\\n    uint256 public _liquidityFee = 2; // BURN RATE\\n    uint256 public _charityFee = 1; // CHARITY RATE\\n    uint256 public _devFee = 1; // DEV RATE\\n\\n    IUniswapV2Router public constant uniswapV2Router = IUniswapV2Router(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);\\n    address public immutable uniswapV2Pair;\\n    address public charityFactory;\\n    address public devAddress;\\n\\n    bool inSwapAndLiquify;\\n    bool public swapAndLiquifyEnabled = true;\\n\\n    uint256 public maxTxAmount = 500 * 10**6 * 10**18;\\n    uint256 public numTokensSellToAddToLiquidity = 100000 * 10**18;\\n\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiquidity);\\n\\n    modifier lockTheSwap() {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n\\n    constructor() {\\n        _rOwned[_msgSender()] = _rTotal;\\n\\n        // Create a uniswap pair for this new token\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\\n\\n        //exclude owner and this contract from fee\\n        _isExcludedFromFee[owner()] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n\\n        emit Transfer(address(0), _msgSender(), _tTotal);\\n    }\\n\\n    function name() public pure returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public pure returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public pure returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public pure override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _isExcludedFromReward[account] ? _tOwned[account] : tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns (uint256) {\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\n        (uint256 reflectionAmount, uint256 reflectionTransferAmount, , , , , , ) = _getValues(tAmount);\\n        return deductTransferFee ? reflectionTransferAmount : reflectionAmount;\\n    }\\n\\n    function tokenFromReflection(uint256 rAmount) public view returns (uint256) {\\n        require(rAmount <= _rTotal, \\\"Amount must be less than total reflections\\\");\\n        return rAmount.div(_getRate());\\n    }\\n\\n    function excludeFromReward(address account) public onlyOwner {\\n        // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');\\n        require(!_isExcludedFromReward[account], \\\"Account is already excluded\\\");\\n\\n        if (_rOwned[account] > 0) {\\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\\n        }\\n\\n        _isExcludedFromReward[account] = true;\\n        _excluded.push(account);\\n    }\\n\\n    function includeInReward(address account) external onlyOwner {\\n        require(_isExcludedFromReward[account], \\\"Account is already excluded\\\");\\n\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_excluded[i] == account) {\\n                _excluded[i] = _excluded[_excluded.length - 1];\\n                _tOwned[account] = 0;\\n                _isExcludedFromReward[account] = false;\\n                _excluded.pop();\\n\\n                break;\\n            }\\n        }\\n    }\\n\\n    function excludeFromFee(address account) public onlyOwner {\\n        _isExcludedFromFee[account] = true;\\n    }\\n\\n    function includeInFee(address account) public onlyOwner {\\n        _isExcludedFromFee[account] = false;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowance[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowance[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\")\\n        );\\n        return true;\\n    }\\n\\n    function _approve(\\n        address _owner,\\n        address _spender,\\n        uint256 _amount\\n    ) internal {\\n        require(_owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(_spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowance[_owner][_spender] = _amount;\\n        emit Approval(_owner, _spender, _amount);\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address spender) public view override returns (uint256) {\\n        return _allowance[_owner][spender];\\n    }\\n\\n    function _getValues(uint256 tAmount)\\n        internal\\n        view\\n        returns (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rRewards,\\n            uint256 tTransferAmount,\\n            uint256 tRewards,\\n            uint256 tLiquidity,\\n            uint256 tCharity,\\n            uint256 tDev\\n        )\\n    {\\n        (tTransferAmount, tRewards, tLiquidity, tCharity, tDev) = _getTValues(tAmount);\\n\\n        uint256 tTransferFee = tLiquidity.add(tCharity).add(tDev);\\n        (rAmount, rTransferAmount, rRewards) = _getRValues(tAmount, tRewards, tTransferFee, _getRate());\\n\\n        return (rAmount, rTransferAmount, rRewards, tTransferAmount, tRewards, tLiquidity, tCharity, tDev);\\n    }\\n\\n    function _getTValues(uint256 amount)\\n        private\\n        view\\n        returns (\\n            uint256 transferAmount,\\n            uint256 rewards,\\n            uint256 liquidity,\\n            uint256 charity,\\n            uint256 dev\\n        )\\n    {\\n        rewards = amount.mul(_rewardsFee).div(10**2);\\n        liquidity = amount.mul(_liquidityFee).div(10**2);\\n        charity = amount.mul(_charityFee).div(10**2);\\n        dev = amount.mul(_devFee).div(10**2);\\n        transferAmount = amount.sub(rewards).sub(liquidity).sub(charity).sub(dev);\\n\\n        return (transferAmount, rewards, liquidity, charity, dev);\\n    }\\n\\n    function _getRValues(\\n        uint256 tAmount,\\n        uint256 tRewards,\\n        uint256 tTransferFee,\\n        uint256 currentRate\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 rAmount = tAmount.mul(currentRate);\\n        uint256 rRewards = tRewards.mul(currentRate);\\n        uint256 rTransferFee = tTransferFee.mul(currentRate);\\n        uint256 rTransferAmount = rAmount.sub(rRewards).sub(rTransferFee);\\n\\n        return (rAmount, rTransferAmount, rRewards);\\n    }\\n\\n    function _getCurrentSupply() internal view returns (uint256 rSupply, uint256 tSupply) {\\n        rSupply = _rTotal;\\n        tSupply = _tTotal;\\n\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\\n\\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\\n        }\\n\\n        return rSupply < _rTotal.div(tSupply) ? (_rTotal, _tTotal) : (rSupply, tSupply);\\n    }\\n\\n    function _getRate() internal view returns (uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n\\n        return rSupply.div(tSupply);\\n    }\\n\\n    function deliver(uint256 tAmount) public {\\n        address sender = _msgSender();\\n\\n        require(!_isExcludedFromReward[sender], \\\"Excluded addresses cannot call this function\\\");\\n\\n        (uint256 rAmount, , , , , , , ) = _getValues(tAmount);\\n\\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\\n        _rTotal = _rTotal.sub(rAmount);\\n        _tFeeTotal = _tFeeTotal.add(tAmount);\\n    }\\n\\n    function _swapTokensForEth(uint256 tAmount) internal {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(uniswapV2Router), tAmount);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tAmount,\\n            0, // accept any amount of MATIC\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) internal {\\n        // approve token transfer to cover all possible scenarios\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // add the liquidity\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            owner(),\\n            block.timestamp\\n        );\\n    }\\n\\n    function _swapAndLiquify(uint256 amount) internal lockTheSwap {\\n        // split the amount into halves\\n        uint256 half = amount.div(2);\\n        uint256 otherHalf = amount.sub(half);\\n\\n        // capture the contract's current MATIC balance.\\n        // this is so that we can capture exactly the amount of MATIC that the\\n        // swap creates, and not make the liquidity event include any MATIC that\\n        // has been manually sent to the contract\\n        uint256 initialBalance = address(this).balance;\\n\\n        // swap tokens for MATIC\\n        _swapTokensForEth(half); // <- this breaks the MATIC -> CHAT swap when swap+liquify is triggered\\n\\n        // how much MATIC did we just swap into?\\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\n\\n        // add liquidity to uniswap\\n        _addLiquidity(otherHalf, newBalance);\\n\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n\\n    function _transferStandard(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) internal returns (uint256) {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rRewards,\\n            uint256 tTransferAmount,\\n            uint256 tRewards,\\n            uint256 tLiquidity,\\n            uint256 tCharity,\\n            uint256 tDev\\n        ) = _getValues(tAmount);\\n\\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\\n\\n        // take liquidity\\n        uint256 rLiquidity = tLiquidity.mul(_getRate());\\n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\\n\\n        if (_isExcludedFromReward[address(this)]) {\\n            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\\n        }\\n\\n        // take charity\\n        uint256 rCharity = tCharity.mul(_getRate());\\n        _rOwned[charityFactory] = _rOwned[charityFactory].add(rCharity);\\n\\n        if (_isExcludedFromReward[charityFactory]) {\\n            _tOwned[charityFactory] = _tOwned[charityFactory].add(tCharity);\\n        }\\n\\n        // take dev\\n        uint256 rDev = tDev.mul(_getRate());\\n        _rOwned[devAddress] = _rOwned[devAddress].add(rDev);\\n\\n        if (_isExcludedFromReward[devAddress]) {\\n            _tOwned[devAddress] = _tOwned[devAddress].add(tDev);\\n        }\\n\\n        // reflect fee\\n        _rTotal = _rTotal.sub(rRewards);\\n        _tFeeTotal = _tFeeTotal.add(tRewards);\\n\\n        emit Transfer(sender, recipient, tTransferAmount);\\n\\n        return tTransferAmount;\\n    }\\n\\n    // This method is responsible for taking all fee, if possible\\n    function _tokenTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        // if any account belongs to isExcludedFromFee account then remove the fee from transfer\\n        bool takeFee = !_isExcludedFromFee[sender] && !_isExcludedFromFee[recipient];\\n        uint256 previousRewardsFee;\\n        uint256 previousLiquidityFee;\\n        uint256 previousCharityFee;\\n        uint256 previousDevFee;\\n\\n        if (!takeFee) {\\n            previousRewardsFee = _rewardsFee;\\n            previousLiquidityFee = _liquidityFee;\\n            previousCharityFee = _charityFee;\\n            previousDevFee = _devFee;\\n            _rewardsFee = 0;\\n            _liquidityFee = 0;\\n            _charityFee = 0;\\n            _devFee = 0;\\n        }\\n\\n        uint256 tTransferAmount;\\n\\n        if (_isExcludedFromReward[sender]) {\\n            if (_isExcludedFromReward[recipient]) {\\n                tTransferAmount = _transferStandard(sender, recipient, amount);\\n                _tOwned[sender] = _tOwned[sender].sub(amount);\\n                _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\\n            } else {\\n                _transferStandard(sender, recipient, amount);\\n                _tOwned[sender] = _tOwned[sender].sub(amount);\\n            }\\n        } else {\\n            if (_isExcludedFromReward[recipient]) {\\n                tTransferAmount = _transferStandard(sender, recipient, amount);\\n                _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\\n            } else {\\n                _transferStandard(sender, recipient, amount);\\n            }\\n        }\\n\\n        if (!takeFee) {\\n            _rewardsFee = previousRewardsFee;\\n            _liquidityFee = previousLiquidityFee;\\n            _charityFee = previousCharityFee;\\n            _devFee = previousDevFee;\\n        }\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n        require(from == owner() || to == owner() || amount <= maxTxAmount, \\\"Transfer amount exceeds the maxTxAmount.\\\");\\n\\n        // is the token balance of this contract address over the min number of\\n        // tokens that we need to initiate a swap + liquidity lock?\\n        // also, don't get caught in a circular liquidity event.\\n        // also, don't swap & liquify if sender is uniswap pair.\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        if (contractTokenBalance >= maxTxAmount) {\\n            contractTokenBalance = maxTxAmount;\\n        }\\n\\n        if (\\n            swapAndLiquifyEnabled &&\\n            !inSwapAndLiquify &&\\n            from != uniswapV2Pair &&\\n            contractTokenBalance >= numTokensSellToAddToLiquidity\\n        ) {\\n            // add liquidity\\n            _swapAndLiquify(numTokensSellToAddToLiquidity);\\n        }\\n\\n        // transfer amount, it will take tax, burn, liquidity fee\\n        _tokenTransfer(from, to, amount);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowance[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\")\\n        );\\n\\n        return true;\\n    }\\n\\n    // to receive MATIC from uniswapV2Router when swapping\\n    receive() external payable {}\\n\\n    function setRewardsFeePercent(uint256 rewardsFee) external onlyOwner {\\n        _rewardsFee = rewardsFee;\\n    }\\n\\n    function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner {\\n        _liquidityFee = liquidityFee;\\n    }\\n\\n    function setCharityFeePercent(uint256 charityFee) external onlyOwner {\\n        _charityFee = charityFee;\\n    }\\n\\n    function setDevFeePercent(uint256 devFee) external onlyOwner {\\n        _devFee = devFee;\\n    }\\n\\n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner {\\n        maxTxAmount = _tTotal.mul(maxTxPercent).div(10**2);\\n    }\\n\\n    function setNumTokensSellToAddToLiquidity(uint256 _numTokensSellToAddToLiquidity) external onlyOwner {\\n        numTokensSellToAddToLiquidity = _numTokensSellToAddToLiquidity.mul(10**18);\\n    }\\n\\n    function setSwapAndLiquifyEnabled(bool _enabled) external onlyOwner {\\n        swapAndLiquifyEnabled = _enabled;\\n        emit SwapAndLiquifyEnabledUpdated(_enabled);\\n    }\\n\\n    function setCharityFactory(address _charityFactory) external onlyOwner {\\n        charityFactory = _charityFactory;\\n        excludeFromReward(charityFactory);\\n    }\\n\\n    function setDevAddress(address _devAddress) external onlyOwner {\\n        devAddress = _devAddress;\\n        excludeFromReward(devAddress);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.12;\\n\\nlibrary SafeMath {\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\ninterface IUniswapV2Router {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"./Context.sol\\\";\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.12;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_charityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_devFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokensSellToAddToLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_charityFactory\",\"type\":\"address\"}],\"name\":\"setCharityFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"charityFee\",\"type\":\"uint256\"}],\"name\":\"setCharityFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devAddress\",\"type\":\"address\"}],\"name\":\"setDevAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"devFee\",\"type\":\"uint256\"}],\"name\":\"setDevFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxTxPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numTokensSellToAddToLiquidity\",\"type\":\"uint256\"}],\"name\":\"setNumTokensSellToAddToLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsFee\",\"type\":\"uint256\"}],\"name\":\"setRewardsFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CharityToken", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}