{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\n// \n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n\n// \n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n// \n/**\n * @title Interface for collectID events contract\n * @author collectID, AG\n * @custom:site https://collectid.io\n * @custom:email info@collectid.io\n */\ninterface ICollectIdEvents {\n  event EnableType(\n    uint256 indexed typeId\n  );\n\n  event CreateEvent(\n    uint256 indexed eventId,\n    uint256 indexed tokenId,\n    uint256 indexed typeId,\n    bytes data\n  );\n\n  event Endorse(\n    address indexed endorser,\n    uint256 indexed eventId\n  );\n\n  function eventIds(\n    uint256 _tokenId\n  ) external view returns (uint256[] memory);\n\n  function typeId(\n    uint256 _eventId\n  ) external view returns (uint256);\n\n  function eventData(\n    uint256 _eventId\n  ) external view returns (bytes memory);\n\n  function eventEndorsers(\n    uint256 _eventId\n  ) external view returns (address[] memory);\n\n  function enableType(\n    uint256 _typeId\n  ) external;\n\n  function createEvent(\n    uint256 _tokenId,\n    uint256 _typeId,\n    bytes calldata _data\n  ) external;\n\n  function endorse(\n    uint256 _eventId\n  ) external;\n\n  function safeEndorse(\n    uint256 _eventId,\n    uint256 _tokenId,\n    uint256 _typeId\n  ) external;\n\n  function createEventFor(\n    bytes calldata _delegationSig,\n    uint256 _tokenId,\n    uint256 _typeId,\n    bytes calldata _data,\n    address _endorser\n  ) external;\n\n  function mintAndCreateEventFor(\n    address _to,\n    string calldata _tokenURI,\n    bytes calldata _delegationSig,\n    uint256 _tokenId,\n    uint256 _typeId,\n    bytes calldata _data,\n    address _endorser\n  ) external;\n\n  function endorseFor(\n    bytes calldata _delegationSig,\n    uint256 _eventId,\n    address _endorser\n  ) external;\n\n  function safeEndorseFor(\n    bytes calldata _delegationSig,\n    uint256 _eventId,\n    uint256 _tokenId,\n    uint256 _typeId,\n    address _endorser\n  ) external;\n}\n\n// \n/**\n * @title Interface for collectID core contract\n * @author collectID, AG\n * @custom:site https://collectid.io\n * @custom:email info@collectid.io\n */\ninterface ICollectIdCore {\n  event DelegateTransfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n\n  function exists(uint256 _tokenId) external view returns (bool);\n  function tokenURI(uint256 _tokenId) external view returns (string memory);\n  function ownerOf(uint256 _tokenId) external view returns (address);\n  function supportsInterface(bytes4 _interfaceId) external returns (bool);\n\n  function burn(\n    uint256 _tokenId\n  ) external;\n\n  function mint(\n    address _to,\n    uint256 _tokenId\n  ) external;\n\n  function mint(\n    address _to,\n    uint256 _tokenId,\n    string calldata _tokenURI\n  ) external;\n\n  function mintMany(\n    address _to,\n    uint256[] calldata _tokenIds,\n    string[] calldata _tokenURIs\n  ) external;\n\n  function transferFor(\n    bytes calldata _delegationSig,\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) external;\n}\n\n// \n/**\n * @title Token contract for creating and managing collectID token events\n * @author collectID, AG\n * @custom:site https://collectid.io\n * @custom:email info@collectid.io\n */\ncontract CollectIdEvents is ICollectIdEvents {\n  using ECDSA for bytes32;\n\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n  bytes32 public constant ENDORSER_ROLE = keccak256(\"ENDORSER_ROLE\");\n\n  ICollectIdCore public core;\n  IAccessControl public accessControl;\n  uint256 public totalEvents;\n  mapping(uint256 => bool) public typeEnabled;\n\n  mapping(uint256 => uint256) private _eventTypeIds;\n  mapping(uint256 => bytes) private _eventData;\n  mapping(uint256 => address[]) private _eventEndorsers;\n  mapping(uint256 => uint256[]) private _tokenEventIds;\n\n  /**\n   * @dev Initialize with core contract address\n   * @param _core address of core contract\n   */\n  constructor(address _core) {\n    core = ICollectIdCore(_core);\n    accessControl = IAccessControl(_core);\n  }\n\n  /**\n   * @dev Modifier than reverts if referenced token does not exist\n   * @param _tokenId uint256 ID of the token\n   */\n  modifier tokenExists(uint256 _tokenId) {\n    core.ownerOf(_tokenId);\n    _;\n  }\n\n  /**\n   * @dev Modifier than reverts if caller does not have specific role\n   * @param _role bytes32 hash unique identifying the role\n   */\n  modifier onlyRole(bytes32 _role) {\n    require(accessControl.hasRole(_role, msg.sender), \"Insufficient permissions\");\n    _;\n  }\n\n  /**\n   * @dev Returns an array of event IDs associated with a specified collectID token\n   * @dev Returns an empty array if token ID does not exist in the collectID core contract\n   * @param _tokenId uint256 ID of the token\n   * @return uint256[] event IDs associated with a specified token\n   */\n  function eventIds(uint256 _tokenId) public view override returns (uint256[] memory) {\n    return _tokenEventIds[_tokenId];\n  }\n\n  /**\n   * @dev Returns the type ID of a specified event\n   * @dev Reverts if the specified event does not exist\n   * @param _eventId uint256 ID of the event\n   * @return uint256 type ID for a specified event\n   */\n  function typeId(uint256 _eventId) public view override returns (uint256) {\n    require(_eventId < totalEvents, \"Event ID is out of range\");\n\n    return _eventTypeIds[_eventId];\n  }\n\n  /**\n   * @dev Returns the byte data of a specified event\n   * @dev Reverts if the specified event does not exist\n   * @param _eventId uint256 ID of the event\n   * @return bytes encoded data for a specified event\n   */\n  function eventData(uint256 _eventId) public view override returns (bytes memory) {\n    require(_eventId < totalEvents, \"Event ID is out of range\");\n\n    return _eventData[_eventId];\n  }\n\n  /**\n   * @dev Returns the list of endorsers of a specified event\n   * @dev Reverts if the specified event does not exist\n   * @param _eventId uint256 ID of the event\n   * @return address[] list of addresses that have endorsed a specified event\n   */\n  function eventEndorsers(uint256 _eventId) public view override returns (address[] memory) {\n    require(_eventId < totalEvents, \"Event ID is out of range\");\n\n    return _eventEndorsers[_eventId];\n  }\n\n  /**\n   * @dev Only admin function for setting the core contract\n   * @param _contract address to be set as the core ERC721 contract\n   */\n  function setCore(address _contract) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    core = ICollectIdCore(_contract);\n  }\n\n  /**\n   * @dev Only admin function for setting the access control contract\n   * @param _contract address to be set as the access control contract\n   */\n  function setAccessControl(address _contract) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    accessControl = IAccessControl(_contract);\n  }\n\n  /**\n   * @dev Public function to create a new event type\n   * @dev Emits a EnableType event that includes the ID\n   * @param _typeId uint256 keccak256 hash of the type description\n   */\n  function enableType(uint256 _typeId)\n    public\n    override\n    onlyRole(DEFAULT_ADMIN_ROLE)\n  {\n    require(!typeEnabled[_typeId], \"Type already enabled\");\n\n    typeEnabled[_typeId] = true;\n\n    emit EnableType(_typeId);\n  }\n\n  /**\n   * @dev Private function to create a new event type\n   * @param _tokenId uint256 ID of the token associated with the event\n   * @param _typeId uint256 ID of the event type\n   * @param _data bytes data for additional event details\n   * @param _endorser address endorsing the event\n   */\n  function _createEvent(\n    uint256 _tokenId,\n    uint256 _typeId,\n    bytes memory _data,\n    address _endorser\n  ) private {\n    require(typeEnabled[_typeId], \"Type is not enabled\");\n\n    uint256 eventId = totalEvents;\n    _tokenEventIds[_tokenId].push(eventId);\n    _eventTypeIds[eventId] = _typeId;\n    _eventData[eventId] = _data;\n    totalEvents += 1;\n\n    emit CreateEvent(eventId, _tokenId, _typeId, _data);\n\n    _endorse(eventId, _endorser);\n  }\n\n  /**\n   * @dev Public function to create a new event; sender is the initial endorser\n   * @dev Emits a CreateEvent event that includes the ID, token ID, type ID, and data\n   * @dev Reverts if the specified event type ID does not exist\n   * @dev Reverts if the specified token ID does not exist in the collectID core contract\n   * @param _tokenId uint256 ID of the token associated with the event\n   * @param _typeId uint256 ID of the event type\n   * @param _data bytes data for additional event details\n   */\n  function createEvent(\n    uint256 _tokenId,\n    uint256 _typeId,\n    bytes memory _data\n  )\n    public\n    override\n    onlyRole(ENDORSER_ROLE)\n    tokenExists(_tokenId)\n  {\n    _createEvent(_tokenId, _typeId, _data, msg.sender);\n  }\n\n  /**\n   * @dev Public function to endorse a specified event\n   * @dev Emits an Endorse event that includes the endorser and event ID\n   * @dev Reverts if the specified event ID does not exist\n   * @param _eventId uint256 ID of the event to endorse\n   */\n  function endorse(uint256 _eventId)\n    public\n    override\n    onlyRole(ENDORSER_ROLE)\n  {\n    _endorse(_eventId, msg.sender);\n  }\n\n  /**\n   * @dev Private function to endorse a specified event\n   * @param _eventId uint256 ID of the event to endorse\n   * @param _endorser address endorsing the event\n   */\n  function _endorse(uint256 _eventId, address _endorser) private {\n    require(_eventId < totalEvents, \"Event ID is out of range\");\n\n    _eventEndorsers[_eventId].push(_endorser);\n\n    emit Endorse(_endorser, _eventId);\n  }\n\n  /**\n   * @dev Public function to safely endorse a specified event at a higher gas cost\n   * @dev Emits an Endorse event that includes the endorser and event ID\n   * @dev Reverts if the specified event ID does not exist\n   * @dev Reverts if the specified event type ID does not match that of the specified event\n   * @dev Reverts if the specified token ID is not associated with the specified event\n   * @dev Reverts if the sender address has already endorsed the specified event\n   * @param _eventId uint256 ID of the event to endorse\n   * @param _tokenId uint256 ID of the token associated with the event\n   * @param _typeId uint256 ID of the event type\n   */\n  function safeEndorse(\n    uint256 _eventId,\n    uint256 _tokenId,\n    uint256 _typeId\n  )\n    public\n    override\n    onlyRole(ENDORSER_ROLE)\n    tokenExists(_tokenId)\n  {\n    _safeEndorse(_eventId, _tokenId, _typeId, msg.sender);\n  }\n\n  /**\n   * @dev Private function to safely endorse a specified event at a higher gas cost\n   * @param _eventId uint256 ID of the event to endorse\n   * @param _tokenId uint256 ID of the token associated with the event\n   * @param _typeId uint256 ID of the event type\n   * @param _endorser address endorsing the event\n   */\n  function _safeEndorse(\n    uint256 _eventId,\n    uint256 _tokenId,\n    uint256 _typeId,\n    address _endorser\n  ) private {\n    require(_eventTypeIds[_eventId] == _typeId, \"Event is not the expected type\");\n    require(_eventExists(_eventId, _tokenId), \"Event is not associated with this token ID\");\n\n    _endorse(_eventId, _endorser);\n  }\n\n  /**\n   * @dev Private function that returns whether or not an event is associated with a specified token\n   * @dev Returns false if the specified token does not exist in the collectID core contract\n   * @param _eventId uint256 ID of the event\n   * @param _tokenId uint256 ID of the token associated with the event\n   * @return bool flag indicating if there exists an event associated with a specified token\n   */\n  function _eventExists(uint256 _eventId, uint256 _tokenId) private view returns (bool) {\n    for (uint8 i = 0; i < _tokenEventIds[_tokenId].length; i++) {\n      if (_tokenEventIds[_tokenId][i] == _eventId) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @dev Private function to verify that the address recovered from the delegation signature\n   * @dev matches the signer address claimed by the transaction sender\n   * @dev Reverts if the recovered signer does not match the claimed signer\n   * @param _delegationDigest bytes32 digest of the signed message\n   * @param _delegationSig bytes signed message\n   * @param _claimedSigner address of the claimed message signer\n   */\n  function _verifySigner(\n    bytes32 _delegationDigest,\n    bytes memory _delegationSig,\n    address _claimedSigner\n  ) private pure {\n    address _signer = ECDSA.recover(_delegationDigest, _delegationSig);\n    require(_claimedSigner == _signer, \"Signature does not match claimed signer address\");\n  }\n\n  /**\n   * @dev Public function to call \"createEvent\" on behalf of another address\n   * @dev The address that signed the delegation signature is the initial endorser\n   * @dev Reverts if the decoded delegation signature does not match the provided function argument\n   * @dev Emits a CreateEvent event that includes the ID, token ID, type ID, and data\n   * @param _delegationSig bytes transaction data encoded as ['CreateEvent', _tokenId, _typeId, _data]\n   * @param _tokenId uint256 ID of the token associated with the event\n   * @param _typeId uint256 ID of the event type\n   * @param _data bytes data for additional event details\n   * @param _creator address that signed the delegation signature\n   */\n  function createEventFor(\n    bytes memory _delegationSig,\n    uint256 _tokenId,\n    uint256 _typeId,\n    bytes memory _data,\n    address _creator\n  )\n    public\n    override\n    onlyRole(DEFAULT_ADMIN_ROLE)\n  {\n    bytes32 _delegationDigest = ECDSA.toEthSignedMessageHash(\n      keccak256(abi.encode(\"CreateEvent\", _tokenId, _typeId, _data))\n    );\n    _verifySigner(_delegationDigest, _delegationSig, _creator);\n    _createEvent(_tokenId, _typeId, _data, _creator);\n  }\n\n  /**\n   * @dev Public function to mint a token and create an event for it in a single transaction\n   * @param _to address owner of the newly minted token\n   * @param _tokenURI string describing the metadata of the token\n   * @param _delegationSig bytes signed message for creating a new event\n   * @param _tokenId uint256 hexadecimal tag ID represented as an integer\n   * @param _typeId uint256 ID of the event type\n   * @param _data bytes data for additional event details\n   * @param _creator address that signed the delegation signature\n   */\n  function mintAndCreateEventFor(\n    address _to,\n    string memory _tokenURI,\n    bytes memory _delegationSig,\n    uint256 _tokenId,\n    uint256 _typeId,\n    bytes memory _data,\n    address _creator\n  )\n    public\n    override\n    onlyRole(DEFAULT_ADMIN_ROLE)\n  {\n    core.mint(_to, _tokenId, _tokenURI);\n    createEventFor(_delegationSig, _tokenId, _typeId, _data, _creator);\n  }\n\n  /**\n   * @dev Public function to call \"endorse\" on behalf of another address\n   * @dev Reverts if the decoded delegation signature does not match the provided function arguments\n   * @dev Emits an Endorse event that includes the endorser and event ID\n   * @param _delegationSig bytes transaction data encoded as ['Endorse', _eventId]\n   * @param _eventId uint256 ID of the event to endorse\n   * @param _endorser address that signed the delegation signature\n   */\n  function endorseFor(\n    bytes memory _delegationSig,\n    uint256 _eventId,\n    address _endorser\n  )\n    public\n    override\n    onlyRole(DEFAULT_ADMIN_ROLE)\n  {\n    bytes32 _delegationDigest = ECDSA.toEthSignedMessageHash(\n      keccak256(abi.encode(\"Endorse\", _eventId))\n    );\n    _verifySigner(_delegationDigest, _delegationSig, _endorser);\n    _endorse(_eventId, _endorser);\n  }\n\n  /**\n   * @dev Public function to call \"safeEndorse\" on behalf of another address\n   * @dev Reverts if the decoded delegation signature does not match the provided function arguments\n   * @dev Emits an Endorse event that includes the endorser and event ID\n   * @param _delegationSig bytes transaction data encoded as ['SafeEndorse', _eventId, _tokenId, _typeId]\n   * @param _eventId uint256 ID of the event to endorse\n   * @param _tokenId uint256 ID of the token associated with the event\n   * @param _typeId uint256 ID of the event type\n   * @param _endorser address that signed the delegation signature\n   */\n  function safeEndorseFor(\n    bytes memory _delegationSig,\n    uint256 _eventId,\n    uint256 _tokenId,\n    uint256 _typeId,\n    address _endorser\n  )\n    public\n    override\n    onlyRole(DEFAULT_ADMIN_ROLE)\n  {\n    bytes32 _delegationDigest = ECDSA.toEthSignedMessageHash(\n      keccak256(abi.encode(\"SafeEndorse\", _eventId, _tokenId, _typeId))\n    );\n    _verifySigner(_delegationDigest, _delegationSig, _endorser);\n    _safeEndorse(_eventId, _tokenId, _typeId, _endorser);\n  }\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_core\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"typeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"CreateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"typeId\",\"type\":\"uint256\"}],\"name\":\"EnableType\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"endorser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"Endorse\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ENDORSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessControl\",\"outputs\":[{\"internalType\":\"contract IAccessControl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"internalType\":\"contract ICollectIdCore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_typeId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"createEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_delegationSig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_typeId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"createEventFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_typeId\",\"type\":\"uint256\"}],\"name\":\"enableType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eventId\",\"type\":\"uint256\"}],\"name\":\"endorse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_delegationSig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_eventId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_endorser\",\"type\":\"address\"}],\"name\":\"endorseFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eventId\",\"type\":\"uint256\"}],\"name\":\"eventData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eventId\",\"type\":\"uint256\"}],\"name\":\"eventEndorsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"eventIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_delegationSig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_typeId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"mintAndCreateEventFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_typeId\",\"type\":\"uint256\"}],\"name\":\"safeEndorse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_delegationSig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_typeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_endorser\",\"type\":\"address\"}],\"name\":\"safeEndorseFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setAccessControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setCore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEvents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"typeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eventId\",\"type\":\"uint256\"}],\"name\":\"typeId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CollectIdEvents", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e12e5b46be75efa04b5ebd3fa5935fb6ee6d32c7", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}