{"SourceCode": "{\"Escrow.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.18;\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\ninterface IFactory {\\n    function admin() external view returns(address);\\n    function token(address _token) external view returns(uint256 trx_fee, uint256 aff_fee, uint256 arb_fee, bool status);\\n}\\n\\ncontract Escrow is ReentrancyGuard {\\n    address public super_admin;\\n    address public affiliation_address;\\n    address public arbitrator_address;\\n    address public fee_collector;\\n    address public admin;\\n    address public factory_contract_address;\\n    uint64 public withdrawal_period;\\n    uint64 public delivery_period;\\n    uint64 public inspection_period;\\n    uint64 public extension_period;\\n    uint64 public request_reply_period;\\n    uint64 public super_admin_claim_period = 172800;\\n    uint64 public order_number = 1;\\n    uint64 public fees_paid_by;\\n    bool public pause = false;\\n\\n    struct Order {\\n        bytes32 order_desc;\\n        address buyer_address;\\n        bytes32 order_id;\\n        address token_address;\\n        uint256 amount;\\n        uint256 fee;\\n        uint64 feepaidby;\\n        uint256 time;\\n        Status status;\\n    }\\n    struct Token {\\n        uint256 trx_fee;\\n        uint256 aff_fee;\\n        uint256 arb_fee;\\n        bool status;\\n    }\\n    struct Settlement {\\n        uint256 percentage;\\n        bool by;\\n        uint256 requestTime;\\n        uint8 status;\\n    }\\n    struct Extension {\\n        bool by;\\n        bool accepted;\\n        uint256 time;\\n    }\\n    mapping(uint64 =\\u003e Order) public orders;\\n    mapping(uint64 =\\u003e uint64) public extension_time;\\n    mapping(bytes32 =\\u003e uint64) public order_ids;\\n    mapping(address =\\u003e Token) public tokens;\\n    mapping(uint64 =\\u003e Settlement) public settlements;\\n    mapping(uint64 =\\u003e Extension) public extensionRequests;\\n\\n    enum Status { \\n        IN, \\n        CA, \\n        CO, \\n        ER, \\n        SD, \\n        AR, \\n        FC\\n    }\\n    event NewOrder(bytes32 orderId, uint64 indexed orderNumber);\\n    event CancelOrder(uint64 indexed orderNumber, address by);\\n    event CompleteOrder(uint64 indexed orderNumber);\\n    event SettlementRequest(uint64 indexed orderNumber);\\n    event SettlementRequestAccepted(uint64 indexed orderNumber, address by);\\n    event SettlementRequestRejected(uint64 indexed orderNumber, address by);\\n    event InspectionExtended(uint64 indexed orderNumber, address by);\\n    event InspectionRequestRejected(uint64 indexed orderNumber, address by);\\n    event DisputeCreated(uint64 indexed orderNumber, address by);\\n    event Claim(uint64[] orderNumbers);\\n    event SuperClaim(uint64[] orderNumbers);\\n\\n    constructor(\\n        address _admin,\\n        address _fee_collector,\\n        address _arbitrator_address,\\n        address _affiliation_address,\\n        address[] memory _tokens,\\n        uint64 _fees_paid_by,\\n        uint64[5] memory options\\n    ) {\\n        admin = _admin;\\n        arbitrator_address = _arbitrator_address;\\n        fee_collector = _fee_collector;\\n        withdrawal_period = options[0];\\n        delivery_period = options[1];\\n        inspection_period = options[2];\\n        extension_period = options[3];\\n        request_reply_period = options[4];\\n        fees_paid_by = _fees_paid_by;\\n        affiliation_address = _affiliation_address;\\n        factory_contract_address = msg.sender;\\n        super_admin = IFactory(factory_contract_address).admin();\\n        addToken(_tokens);\\n    }\\n\\n\\n    modifier isPause() {\\n        require(pause==false, \\\"P\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"OA\\\");\\n        _;\\n    }\\n\\n    modifier onlySuperAdmin() {\\n        require(msg.sender == super_admin, \\\"OSA\\\");\\n        _;\\n    }\\n\\n    modifier validCaller(uint64 _order_num) {\\n        require(msg.sender == admin || orders[_order_num].buyer_address == msg.sender, \\\"U\\\");\\n        _;\\n    }\\n\\n    function validStatus(uint64 _order_num) private view {\\n        require(orders[_order_num].status == Status.ER || orders[_order_num].status == Status.IN , \\\"NVS\\\");\\n    }\\n\\n    function addToken(address[] memory _tokens) private {\\n        for(uint i; i \\u003c _tokens.length; i++){\\n            (uint256 trx_fee ,uint256 aff_fee, uint256 arb_fee, bool status)  = IFactory(factory_contract_address).token(_tokens[i]);\\n            tokens[_tokens[i]] = Token({\\n            trx_fee: trx_fee,\\n            aff_fee: aff_fee,\\n            arb_fee: arb_fee,\\n            status: status});\\n        }\\n    }\\n    \\n    function calculateFee(address _token, uint256 _amount) private view returns(uint256, uint256) {\\n        uint256 order_amount;\\n        uint256 order_fee;\\n        if(fees_paid_by == 0) {\\n            order_amount = (_amount*10000) / (tokens[_token].trx_fee+10000);\\n            order_fee = _amount - order_amount;\\n        } else {\\n            order_amount = _amount;\\n            order_fee = (_amount * tokens[_token].trx_fee) / 10000;\\n        }\\n        return (order_amount, order_fee);\\n    }\\n\\n    function changeSuperAdmin(address _address) external onlySuperAdmin {\\n        super_admin = _address;\\n    }\\n\\n    function changeArbitrator(address _address) external onlySuperAdmin {\\n        arbitrator_address = _address;\\n    }\\n\\n    function changeAffiliate(address _address) external onlySuperAdmin {\\n        affiliation_address = _address;\\n    }\\n\\n    function changeFeeCollector(address _address) external onlySuperAdmin {\\n        fee_collector = _address;\\n    }\\n\\n    function changeSuperAdminClaimPeriod(uint64 _time) external onlySuperAdmin {\\n        super_admin_claim_period = _time;\\n    }\\n\\n    function togglePause() external {\\n        require(msg.sender == admin || msg.sender == super_admin);\\n        pause = !pause;\\n    }\\n\\n    function recoverToken(address _token, uint256 _amount) external onlySuperAdmin {\\n        (bool success, ) = _token.call(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", super_admin, _amount));\\n        require(success, \\\"TF\\\");\\n    }\\n\\n    function changeConfig(address[] memory _tokens, bool[] memory _tokenStatus, uint64 _fee_paid_by) external onlyAdmin {\\n        require(_tokens.length == _tokenStatus.length, \\\"LM\\\");\\n        for(uint256 i; i\\u003c_tokens.length; i++) {\\n            if(tokens[_tokens[i]].trx_fee != 0){\\n                tokens[_tokens[i]].status = _tokenStatus[i];\\n            }else{\\n                (uint256 trx_fee ,uint256 aff_fee, uint256 arb_fee,bool status)  = IFactory(factory_contract_address).token(_tokens[i]);\\n                require(status, \\\"TNA\\\");\\n                tokens[_tokens[i]] = Token({\\n                trx_fee: trx_fee,\\n                aff_fee: aff_fee,\\n                arb_fee: arb_fee,\\n                status: true});\\n            }\\n    \\t}\\n        fees_paid_by = _fee_paid_by;\\n    }\\n    \\n    function addOrderByToken(address _token, bytes32 _orderId, uint256 _orderAmount, bytes32 _description) \\n    external isPause {\\n        require(orders[order_ids[_orderId]].buyer_address == address(0), \\\"ONE\\\");\\n        require (tokens[_token].status, \\\"IT\\\");\\n        (bool success,) = _token.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transferFrom(address,address,uint256)\\\")), msg.sender, address(this), _orderAmount));\\n\\t    require(success ,\\\"TFF\\\");\\n        order_ids[_orderId] = order_number;\\n        (uint256 odr_amt , uint256 odr_fee ) = calculateFee(_token, _orderAmount);\\n        orders[order_number] = Order({\\n            order_desc: _description,\\n            buyer_address: msg.sender,\\n            token_address: _token,\\n            order_id: _orderId,\\n            amount: odr_amt,\\n            fee: odr_fee,\\n            time: block.timestamp,\\n            feepaidby: fees_paid_by,\\n            status: Status.IN\\n        });\\n        emit NewOrder(_orderId, order_number);\\n        order_number++;\\n    }\\n\\n    function addOrder(bytes32 _orderId, bytes32 _description) external isPause payable {\\n        require(tokens[address(0)].status, \\\"IT\\\");\\n        require(orders[order_ids[_orderId]].buyer_address == address(0), \\\"ONE\\\");\\n        \\n        (uint256 odr_amt , uint256 odr_fee ) = calculateFee(address(0), msg.value);\\n\\n        order_ids[_orderId] = order_number;\\n        orders[order_number] = Order({\\n            order_desc: _description,\\n            buyer_address: msg.sender,\\n            token_address: address(0),\\n            order_id: _orderId,\\n            amount: odr_amt,\\n            fee: odr_fee,\\n            time: block.timestamp,\\n            feepaidby: fees_paid_by,\\n            status: Status.IN\\n        });\\n        emit NewOrder(_orderId, order_number);\\n        order_number++;\\n    }\\n\\n    function cancelOrder(uint64 _order_num) external isPause validCaller(_order_num) nonReentrant {\\n        validStatus(_order_num);\\n        if(orders[_order_num].buyer_address == msg.sender){\\n            require(orders[_order_num].time + withdrawal_period \\u003e block.timestamp ,\\\"CTP\\\");\\n        }else {\\n            require(orders[_order_num].time + withdrawal_period + delivery_period + inspection_period + extension_time[_order_num]\\n            \\u003e block.timestamp, \\\"CTP\\\");\\n        }\\n        uint256 amount = orders[_order_num].amount;\\n        if(orders[_order_num].feepaidby == 0){\\n            amount = orders[_order_num].amount + orders[_order_num].fee;\\n        }\\n        orders[_order_num].status = Status.CA;       \\n        if(orders[_order_num].token_address == address(0)) {\\n            payable(orders[_order_num].buyer_address).transfer(amount);\\n        } else {\\n            (bool success,) = orders[_order_num].token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),orders[_order_num].buyer_address, amount));\\n            require(success ,\\\"TF\\\");\\n        }\\n        emit CancelOrder(_order_num, msg.sender);\\n    }\\n\\n    function completeOrder(uint64 _order_num) external isPause nonReentrant {\\n        validStatus(_order_num);\\n        require(orders[_order_num].buyer_address == msg.sender, \\\"U\\\");\\n        require(block.timestamp \\u003c orders[_order_num].time + withdrawal_period + delivery_period + inspection_period + extension_time[_order_num], \\\"COTP\\\");\\n        orders[_order_num].status = Status.CO;\\n        uint256  amt = orders[_order_num].amount;\\n        uint256  fee = orders[_order_num].fee;\\n        if(orders[_order_num].feepaidby ==1){\\n            amt = amt - fee;\\n        }\\n        if (orders[_order_num].token_address == address(0)) {\\n            if(affiliation_address != address(0)){\\n                uint256 affiliation = (fee * (tokens[orders[_order_num].token_address].aff_fee/100)) / 100;\\n                fee = fee - affiliation;\\n                payable(affiliation_address).transfer(affiliation);\\n            }\\n            payable(admin).transfer(amt);\\n            payable(fee_collector).transfer(fee);\\n        }else{\\n            if(affiliation_address != address(0)) {\\n                uint256 affiliation = ((orders[_order_num].fee * (tokens[orders[_order_num].token_address].aff_fee/100)) / 100);\\n                fee = orders[_order_num].fee - affiliation;\\n                (bool success1,) = orders[_order_num].token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),affiliation_address, affiliation));\\n                require(success1 ,\\\"TF\\\");\\n            }\\n            (bool success2,) = orders[_order_num].token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),admin, amt));\\n            require(success2 ,\\\"TF\\\");\\n            \\n            (bool success3,) = orders[_order_num].token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),fee_collector, fee));\\n            require(success3 ,\\\"TF\\\");\\n        }\\n        emit CompleteOrder(_order_num);\\n    }\\n\\n    function settlementRequest(uint64 _order_num, uint256 _percentage) external validCaller(_order_num) isPause {\\n        validStatus(_order_num);\\n        require(_percentage \\u003c= 100 \\u0026\\u0026 _percentage \\u003e 0, \\\"IP\\\");\\n        require((block.timestamp \\u003e orders[_order_num].time + withdrawal_period)\\n            \\u0026\\u0026 (block.timestamp \\u003c orders[_order_num].time + withdrawal_period + delivery_period + inspection_period + extension_time[_order_num]), \\\"ST\\\");\\n        require(settlements[_order_num].percentage == 0 || settlements[_order_num].status == 2, \\\"SP\\\");\\n        bool by = false;\\n        if (msg.sender == admin) {\\n            by = true;\\n        }\\n        settlements[_order_num] = Settlement({\\n                percentage: _percentage,\\n                by: by,\\n                requestTime: block.timestamp,\\n                status: 0\\n            });\\n        emit SettlementRequest(_order_num);\\n    }\\n    function acceptSettlementRequest(uint64 _order_num) external isPause nonReentrant {\\n        validStatus(_order_num);\\n        require(block.timestamp \\u003c settlements[_order_num].requestTime + request_reply_period\\n            \\u0026\\u0026 settlements[_order_num].percentage != 0,\\\"RTRE\\\");\\n        require(msg.sender == orders[_order_num].buyer_address \\u0026\\u0026 settlements[_order_num].by == true\\n            || (msg.sender==admin \\u0026\\u0026 settlements[_order_num].by == false), \\\"U1\\\");\\n            \\n        uint256 amt = orders[_order_num].amount;\\n        uint256 fee = orders[_order_num].fee;\\n        if(orders[_order_num].feepaidby == 0){\\n            amt = amt+fee;\\n            fee = (fee * settlements[_order_num].percentage) / 100;\\n        }\\n        uint256 refund = (amt * settlements[_order_num].percentage) / 100;\\n        uint256 remain = amt - refund - fee;\\n        orders[_order_num].status = Status.SD;\\n        settlements[_order_num].status = 1;\\n        if(orders[_order_num].token_address == address(0)) {\\n            if(affiliation_address != address(0)){\\n                uint256 affiliation = (fee * (tokens[orders[_order_num].token_address].aff_fee/100)) / 100;\\n                fee = fee - affiliation;\\n                payable(affiliation_address).transfer(affiliation);\\n            }\\n            payable(orders[_order_num].buyer_address).transfer(refund);\\n            payable(admin).transfer(remain);\\n            payable(fee_collector).transfer(fee);\\n        } else {\\n            address token_address = orders[_order_num].token_address;\\n            if(affiliation_address != address(0)){\\n                uint256 affiliation = (fee * (tokens[token_address].aff_fee)) / 10000;\\n                fee = fee - affiliation;\\n                (bool success1,) = token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),affiliation_address, affiliation));\\n                require(success1 ,\\\"TF\\\");\\n            }\\n            (bool success2,) = token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),orders[_order_num].buyer_address, refund));\\n            require(success2 ,\\\"TF\\\");\\n            \\n            (bool success3,) = token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),admin, remain));\\n            require(success3 ,\\\"TF\\\");\\n\\n            (bool success4,) = token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),fee_collector, fee));\\n            require(success4 ,\\\"TF\\\");\\n        }\\n        emit SettlementRequestAccepted(_order_num, msg.sender);\\n    }\\n    function rejectSettlementRequest(uint64 _order_num) external validCaller(_order_num) isPause {\\n        validStatus(_order_num);\\n        require(block.timestamp \\u003c settlements[_order_num].requestTime + request_reply_period,\\\"RTRE\\\");\\n        require(settlements[_order_num].percentage != 0, \\\"ASR\\\");\\n        settlements[_order_num].status = 2;\\n        settlements[_order_num].percentage = 0;\\n        emit SettlementRequestRejected(_order_num, msg.sender);\\n    }\\n    \\n    function extendInspectionRequest(uint64 _order_num) external isPause validCaller(_order_num) {\\n        require(orders[_order_num].status == Status.IN, \\\"IN\\\");\\n        require((block.timestamp \\u003e orders[_order_num].time + withdrawal_period + delivery_period)\\n            \\u0026\\u0026 (block.timestamp \\u003c orders[_order_num].time + withdrawal_period + delivery_period + inspection_period), \\\"ITP\\\");\\n        bool by = false;\\n        if(msg.sender == admin) {\\n            by = true;   \\n        }\\n        extensionRequests[_order_num] = Extension({\\n            by:by,\\n            accepted: true,\\n            time: block.timestamp\\n        });\\n        extension_time[_order_num] = extension_period;\\n        orders[_order_num].status = Status.ER;\\n        emit InspectionExtended(_order_num, msg.sender);\\n    }\\n    \\n    function rejectInspectionRequest(uint64 _order_num) external isPause validCaller(_order_num) {\\n        require(orders[_order_num].status == Status.ER\\n        \\u0026\\u0026 block.timestamp \\u003c extensionRequests[_order_num].time + request_reply_period,\\\"ER\\\");\\n        extension_time[_order_num] = 0;\\n        extensionRequests[_order_num].accepted = false;\\n        orders[_order_num].status = Status.IN;\\n        emit InspectionRequestRejected(_order_num, msg.sender);\\n    }\\n\\n    function addDispute(uint64 _order_num) external payable isPause validCaller(_order_num)  nonReentrant {\\n        validStatus(_order_num);\\n        require(msg.value \\u003e= tokens[orders[_order_num].token_address].arb_fee, \\\"ARF\\\");\\n        require((block.timestamp \\u003e orders[_order_num].time + withdrawal_period + delivery_period)\\n            \\u0026\\u0026 (block.timestamp \\u003c orders[_order_num].time + withdrawal_period + delivery_period + inspection_period + extension_time[_order_num]), \\\"DTP\\\");\\n\\n        payable(arbitrator_address).transfer(orders[_order_num].amount + msg.value);\\n        orders[_order_num].status = Status.AR;\\n        emit DisputeCreated(_order_num, msg.sender);\\n    }\\n    function addDisputeByToken(uint64 _order_num) external isPause validCaller(_order_num) nonReentrant {\\n        validStatus(_order_num);\\n        require((block.timestamp \\u003e orders[_order_num].time + withdrawal_period + delivery_period)\\n            \\u0026\\u0026 (block.timestamp \\u003c orders[_order_num].time + withdrawal_period + delivery_period + inspection_period + extension_time[_order_num]), \\\"DTP\\\");\\n\\n        (bool success1,) = orders[_order_num].token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),arbitrator_address, orders[_order_num].amount));\\n        require(success1 ,\\\"TF\\\");\\n        (bool success2,) = orders[_order_num].token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transferFrom(address,address,uint256)\\\")), \\n            msg.sender, arbitrator_address, tokens[orders[_order_num].token_address].arb_fee));\\n\\t    require(success2 ,\\\"TFF\\\");\\n\\n        orders[_order_num].status = Status.AR;\\n        emit DisputeCreated(_order_num, msg.sender);\\n    }\\n\\n    function claim(uint64[] memory _order_nums) external isPause onlyAdmin nonReentrant{\\n        for(uint64 i; i\\u003c_order_nums.length; i++) {\\n            uint64  _order_num = _order_nums[i];\\n            validStatus(_order_num);\\n            \\n            if(settlements[_order_num].percentage != 0) {\\n            require(block.timestamp \\u003e settlements[_order_num].requestTime + request_reply_period, \\\"RTRE\\\");\\n            }\\n\\n            require(((block.timestamp \\u003e orders[_order_num].time\\n                        + withdrawal_period + delivery_period +inspection_period + extension_time[_order_num])\\n                        \\u0026\\u0026 (block.timestamp \\u003c orders[_order_num].time\\n                        + withdrawal_period + delivery_period +inspection_period + extension_time[_order_num]\\n                        +  super_admin_claim_period))\\n                    ,\\\"CTP\\\");\\n\\n            orders[_order_num].status = Status.CO;\\n            uint256  amt = orders[_order_num].amount;\\n            uint256  fee = orders[_order_num].fee;\\n            if(orders[_order_num].feepaidby==1){\\n                amt = orders[_order_num].amount - fee;\\n            }\\n            if (orders[_order_num].token_address == address(0)) {\\n                if(affiliation_address != address(0)){\\n                    uint256 affiliation = (fee * (tokens[orders[_order_num].token_address].aff_fee/100)) / 100;\\n                    fee = fee - affiliation;\\n                    payable(fee_collector).transfer(affiliation);\\n                }\\n                payable(admin).transfer(amt);\\n                payable(fee_collector).transfer(fee);\\n            }else{\\n                if(affiliation_address != address(0)){\\n                    uint256 affiliation = ((orders[_order_num].fee * (tokens[orders[_order_num].token_address].aff_fee/100)) / 100);\\n                    fee = orders[_order_num].fee - affiliation;\\n                    (bool success1,) = orders[_order_num].token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),affiliation_address, affiliation));\\n                    require(success1 ,\\\"TF\\\");\\n                }\\n                (bool success2,) = orders[_order_num].token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),admin, amt));\\n                require(success2 ,\\\"TF\\\");\\n                \\n                (bool success3,) = orders[_order_num].token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),fee_collector, fee));\\n                require(success3 ,\\\"TF\\\");\\n            }\\n        }\\n        emit Claim(_order_nums);\\n    }\\n\\n    function superClaim(uint64[] memory _order_nums) external onlySuperAdmin nonReentrant{\\n        for(uint64 i; i\\u003c_order_nums.length; i++) {\\n            uint64  _order_num = _order_nums[i];\\n            validStatus(_order_num);\\n            require(block.timestamp \\u003e= orders[_order_num].time\\n                        + withdrawal_period + delivery_period +inspection_period\\n                        + extension_time[_order_num]\\n                        +  super_admin_claim_period\\n                    ,\\\"SCT\\\");\\n            orders[_order_num].status = Status.FC;\\n            uint256 amt = orders[_order_num].amount;\\n            if(orders[_order_num].feepaidby == 0){\\n                amt = orders[_order_num].amount + orders[_order_num].fee;\\n            }\\n            if (orders[_order_num].token_address == address(0)) {\\n                payable(super_admin).transfer(amt);\\n            } else {\\n                (bool success1,) = orders[_order_num].token_address.call(abi.encodeWithSelector(bytes4(keccak256(\\\"transfer(address,uint256)\\\")),super_admin, amt));\\n                require(success1 ,\\\"TF\\\");\\n            }\\n        }\\n        emit SuperClaim(_order_nums);\\n    }\\n\\n    receive() external payable {\\n        payable(super_admin).transfer(msg.value);\\n    }\\n}\\n\"},\"Factory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.18;\\nimport \\\"./Escrow.sol\\\";\\n\\ncontract Factory {\\n    address public admin;\\n    address public arbitrator_address;\\n    address public fee_collector;\\n    bool public pause = false;\\n    \\n    struct Token {\\n        uint256 trx_fee;\\n        uint256 aff_fee;\\n        uint256 arb_fee;\\n        bool status;\\n    }\\n    mapping(address =\\u003e Token) public token;\\n    event newEscrow (address contract_address);\\n    \\n    constructor( address _arbitrator_address, address _fee_collector) {\\n        arbitrator_address = _arbitrator_address;\\n        fee_collector = _fee_collector;\\n        admin = msg.sender;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"OA\\\");\\n    _;}\\n    modifier ValidToken(address _token) {\\n        require (token[_token].status, \\\"IT\\\");\\n    _;}\\n    modifier isPause() {\\n        require(!pause, \\\"P\\\");\\n    _;}\\n    \\n    function togglePause() external onlyAdmin {\\n        pause = !pause;\\n    }\\n    function changeAdmin(address _address) external onlyAdmin {\\n        admin = _address;\\n    }\\n    function changeFeeCollector(address _address) external onlyAdmin {\\n        fee_collector = _address;\\n    }\\n    function changeArbitrator(address _address) external onlyAdmin {\\n        arbitrator_address = _address;\\n    }\\n    function addToken(address _token, uint256 _trx_fee, uint256 _aff_fee,uint256 _arb_fee) \\n    external isPause onlyAdmin {\\n        require(token[_token].trx_fee == 0, \\\"ATF\\\");\\n        token[_token].trx_fee = _trx_fee;\\n        token[_token].aff_fee = _aff_fee;\\n        token[_token].arb_fee = _arb_fee;\\n        token[_token].status = true;\\n    }   \\n    function changeToken(address _token, uint256 _trx_fee, uint256 _aff_fee, uint256 _arb_fee) \\n    external isPause onlyAdmin ValidToken(_token) { \\n        token[_token].trx_fee = _trx_fee;\\n        token[_token].aff_fee = _aff_fee;\\n        token[_token].arb_fee = _arb_fee;\\n    }\\n    function toggleToken(address _token) external onlyAdmin {\\n        token[_token].status = !token[_token].status;\\n    }\\n\\n    function recoverTokens(address _token, uint256 _amount) external onlyAdmin {\\n        (bool success, ) = _token.call(abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", admin, _amount));\\n        require(success, \\\"TF\\\");\\n    }\\n\\n    function deployEscrowContract(\\n        address  _affiliation_address,\\n        address[] calldata _tokens,\\n        uint64 _fees_paid_by,\\n        uint64[5] calldata options) external isPause {\\n        for(uint i; i \\u003c _tokens.length; i++) {\\n            require(token[_tokens[i]].status, \\\"IT\\\");\\n        }\\n        Escrow NewEscrow = new Escrow(\\n            msg.sender,\\n            fee_collector,\\n            arbitrator_address,\\n            _affiliation_address,\\n            _tokens,\\n            _fees_paid_by,\\n            options\\n        );\\n        emit newEscrow(address(NewEscrow));\\n    }\\n    \\n    receive() external payable {\\n        payable(admin).transfer(msg.value);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_arbitrator_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fee_collector\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contract_address\",\"type\":\"address\"}],\"name\":\"newEscrow\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_trx_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_aff_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_arb_fee\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arbitrator_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"changeArbitrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"changeFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_trx_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_aff_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_arb_fee\",\"type\":\"uint256\"}],\"name\":\"changeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_affiliation_address\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint64\",\"name\":\"_fees_paid_by\",\"type\":\"uint64\"},{\"internalType\":\"uint64[5]\",\"name\":\"options\",\"type\":\"uint64[5]\"}],\"name\":\"deployEscrowContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee_collector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"toggleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"token\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"trx_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aff_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arb_fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Factory", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b3551cf87995d533f03b4b7ec99f3ea80dc041fd000000000000000000000000b074723a1e1ac8147be936a4c1c99f01ac82d3af", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d812b79b9ea5d0498635ccc13c053dc8959e02b907fb3040d6b57db0b7766f12"}