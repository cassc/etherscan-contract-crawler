{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 15\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/interfaces/IERC20Fixed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n// we need some information from token contract\\n// we also need ability to transfer tokens from/to this contract\\ninterface IERC20Fixed {\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/OwnershipHolder/IOwnershipHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface IOwnershipHolder {\\n    // ----- PROXY METHODS ----- //\\n    function pEditClaimingAddress(\\n        address _contractAddress,\\n        address _newAddress\\n    ) external;\\n\\n    function pEditRoyaltyFee(\\n        address _contractAddress,\\n        uint256 _newFee\\n    ) external;\\n\\n    function pEditTokenUri(\\n        address _contractAddress,\\n        string memory _ttokenUri\\n    ) external;\\n\\n    function pRecoverERC20(address _contractAddress, address token) external;\\n\\n    function pOwner(address _contractAddress) external view returns (address);\\n\\n    function pTransferOwnership(\\n        address _contractAddress,\\n        address newOwner\\n    ) external;\\n\\n    function pBatchMintSelectedIds(\\n        uint256[] memory _ids,\\n        address[] memory _addresses,\\n        address _contractAddress\\n    ) external;\\n\\n    function pMintNFTTokens(\\n        address _contractAddress,\\n        address _requesterAddress,\\n        uint256 _bundleId,\\n        uint256[] memory _tokenIds,\\n        uint256 _chainId,\\n        bytes memory _transactionHash\\n    ) external;\\n\\n    function pMintNextToken(\\n        address _contractAddress,\\n        address _receiver\\n    ) external;\\n\\n    function pSetNewPaymentProxy(\\n        address _contractAddress,\\n        address _newPP\\n    ) external;\\n\\n    function pSetNewAdministrator(\\n        address _contractAddress,\\n        address _newAdmin\\n    ) external;\\n\\n    function pEditClaimingAdress(\\n        address _contractAddress,\\n        address _newAddress\\n    ) external;\\n\\n    function pBurn(address _contractAddress, uint256 _tokenId) external;\\n\\n    function pBatchMintAndBurn1155(\\n        address _contractAddress,\\n        uint256[] memory _ids,\\n        uint256[] memory _amounts,\\n        bool[] memory _burn,\\n        address _receiver\\n    ) external;\\n\\n    function pBatchBurnFrom1155(\\n        address _contractAddress,\\n        uint256[] memory _ids,\\n        uint256[] memory _amounts,\\n        address burner\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v1/UniqPaymentProxy/UniqPaymentProxyV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"../../utils/interfaces/IERC20Fixed.sol\\\";\\nimport \\\"../UniqRedeem/IUniqRedeemV3.sol\\\";\\nimport \\\"../OwnershipHolder/IOwnershipHolder.sol\\\";\\n\\ncontract UniqPaymentProxyV3 is Ownable, EIP712, ERC1155Holder, IERC721Receiver {\\n    // ----- EVENTS ----- //\\n    event Executed(address indexed executor, uint256 indexed nonce);\\n\\n    // ----- STRUCTURES ----- //\\n    struct ERC721TokenData {\\n        address tokenAddress;\\n        uint256 id;\\n        address receiver;\\n        uint256 network;\\n        RedeemTypes toBurn;\\n        uint256 purpose;\\n    }\\n\\n    struct ERC1155TokenData {\\n        address tokenAddress;\\n        uint256 id;\\n        uint256 amount;\\n        address receiver;\\n        uint256 network;\\n        RedeemTypes toBurn;\\n        uint256 purpose;\\n    }\\n\\n    enum RedeemTypes {\\n        MintOnly, //0\\n        MintAndRedeem, //1\\n        RedeemOnly //2\\n    }\\n\\n    // ----- VARIABLES ----- //\\n    uint256 internal _networkId;\\n    mapping(uint256 => bool) public _isNonceUsed;\\n    address public signer;\\n    IUniqRedeemV3 public redeem;\\n    IOwnershipHolder public ownershipHolder;\\n\\n    // ----- CONSTRUCTOR ----- //\\n    constructor(\\n        uint256 _pnetworkId,\\n        address _signer,\\n        address _redeem,\\n        address _ownershipHolder\\n    ) EIP712(\\\"Uniqly\\\", \\\"1\\\") {\\n        _networkId = _pnetworkId;\\n        signer = _signer;\\n        redeem = IUniqRedeemV3(_redeem);\\n        ownershipHolder = IOwnershipHolder(_ownershipHolder);\\n    }\\n\\n    function setRedeemAddress(IUniqRedeemV3 _redeemAddress) external onlyOwner {\\n        redeem = _redeemAddress;\\n    }\\n\\n    function setOwnershipHolderAddress(\\n        IOwnershipHolder _ownershipHolder\\n    ) external onlyOwner {\\n        ownershipHolder = _ownershipHolder;\\n    }\\n\\n    function _sendTokens(\\n        address _paymentToken,\\n        uint256[] memory _amount,\\n        address[] memory _paymentReceiver\\n    ) internal {\\n        uint256 len = _amount.length;\\n        require(len == _paymentReceiver.length, \\\"Length mimatch pt\\\");\\n        if (_paymentToken == address(0)) {\\n            uint256 sum;\\n            for (uint256 i = 0; i < len; i++) {\\n                sum += _amount[i];\\n            }\\n            require(msg.value >= sum, \\\"Not enough ether\\\");\\n            if (sum < msg.value) {\\n                payable(msg.sender).transfer(msg.value - sum);\\n            }\\n        }\\n        for (uint256 i = 0; i < len; i++) {\\n            if (_paymentToken == address(0)) {\\n                if (_amount[i] > 0) {\\n                    payable(_paymentReceiver[i]).transfer(_amount[i]);\\n                }\\n            } else {\\n                if (_amount[i] > 0) {\\n                    IERC20Fixed(_paymentToken).transferFrom(\\n                        msg.sender,\\n                        _paymentReceiver[i],\\n                        _amount[i]\\n                    );\\n                }\\n            }\\n        }\\n    }\\n\\n    function _redeemTokens(\\n        address _contractAddress,\\n        uint256[] memory _tokenIds,\\n        uint256[] memory _purposes,\\n        uint256[] memory _networks\\n    ) internal {\\n        address[] memory contractAddresses = new address[](_tokenIds.length);\\n        string[] memory names = new string[](_tokenIds.length);\\n        address[] memory owners = new address[](_tokenIds.length);\\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\\n            contractAddresses[i] = _contractAddress;\\n            names[i] = \\\"UniqlyPPV3\\\";\\n            owners[i] = address(this);\\n        }\\n        redeem.redeemTokensAsAdmin(\\n            contractAddresses,\\n            _tokenIds,\\n            _purposes,\\n            owners,\\n            names,\\n            _networks\\n        );\\n    }\\n\\n    function _processERC721(ERC721TokenData[] memory erc721Tokens) internal {\\n        uint256[] memory ids = new uint256[](erc721Tokens.length);\\n        address[] memory receivers = new address[](erc721Tokens.length);\\n        uint256[] memory purposes = new uint256[](erc721Tokens.length);\\n        uint256[] memory networks = new uint256[](erc721Tokens.length);\\n        //Redeem only scenario\\n        if (erc721Tokens[0].toBurn == RedeemTypes.RedeemOnly) {\\n            if (address(redeem) != address(0)) {\\n                for (uint256 i = 0; i < erc721Tokens.length; i++) {\\n                    require(erc721Tokens[i].purpose != 0, \\\"Purpose error\\\");\\n                    ids[i] = erc721Tokens[i].id;\\n                    purposes[i] = erc721Tokens[i].purpose;\\n                    networks[i] = erc721Tokens[i].network;\\n                }\\n                _redeemTokens(\\n                    erc721Tokens[0].tokenAddress,\\n                    ids,\\n                    purposes,\\n                    networks\\n                );\\n            }\\n        }\\n        //Mint and burn scenario\\n        else if (erc721Tokens[0].network == _networkId) {\\n            for (uint256 i = 0; i < erc721Tokens.length; i++) {\\n                if (erc721Tokens[0].toBurn == RedeemTypes.MintAndRedeem) {\\n                    require(erc721Tokens[i].purpose != 0, \\\"Purpose error\\\");\\n                }\\n                ids[i] = erc721Tokens[i].id;\\n                receivers[i] = erc721Tokens[i].receiver;\\n                purposes[i] = erc721Tokens[i].purpose;\\n                networks[i] = erc721Tokens[i].network;\\n            }\\n            try\\n                ownershipHolder.pBatchMintSelectedIds(\\n                    ids,\\n                    receivers,\\n                    erc721Tokens[0].tokenAddress\\n                )\\n            {} catch {\\n                bytes memory bt = abi.encodePacked(\\n                    erc721Tokens[0].tokenAddress,\\n                    networks,\\n                    ids,\\n                    receivers,\\n                    block.number\\n                );\\n                ownershipHolder.pMintNFTTokens(\\n                    erc721Tokens[0].tokenAddress,\\n                    receivers[0],\\n                    8888,\\n                    ids,\\n                    _networkId,\\n                    bt\\n                );\\n            }\\n            if (\\n                erc721Tokens[0].toBurn == RedeemTypes.MintAndRedeem &&\\n                address(redeem) != address(0)\\n            ) {\\n                _redeemTokens(\\n                    erc721Tokens[0].tokenAddress,\\n                    ids,\\n                    purposes,\\n                    networks\\n                );\\n            }\\n        }\\n    }\\n\\n    function _processERC1155(ERC1155TokenData[] memory erc1155Tokens) internal {\\n        uint256[] memory ids = new uint256[](erc1155Tokens.length);\\n        uint256[] memory amounts = new uint256[](erc1155Tokens.length);\\n        address[] memory receivers = new address[](erc1155Tokens.length);\\n        bool[] memory burn = new bool[](erc1155Tokens.length);\\n        for (uint256 i = 0; i < erc1155Tokens.length; i++) {\\n            ids[i] = erc1155Tokens[i].id;\\n            receivers[i] = erc1155Tokens[i].receiver;\\n            amounts[i] = erc1155Tokens[i].amount;\\n            burn[i] = erc1155Tokens[i].toBurn == RedeemTypes.MintAndRedeem\\n                ? true\\n                : false;\\n        }\\n        //Burn Scenario\\n        if (erc1155Tokens[0].toBurn == RedeemTypes.RedeemOnly) {\\n            //TODO: Redeem for erc1155?\\n            ///require(erc1155Tokens[0].purpose != 0, \\\"Purpose is zero\\\");\\n            ownershipHolder.pBatchBurnFrom1155(\\n                erc1155Tokens[0].tokenAddress,\\n                ids,\\n                amounts,\\n                erc1155Tokens[0].receiver\\n            );\\n            return;\\n        }\\n        //Mint or Mint-and-burn scenario\\n        if (erc1155Tokens[0].network == _networkId) {\\n            //TODO: Redeem for erc1155?\\n            ///require(erc1155Tokens[0].purpose != 0, \\\"Purpose is zero\\\");\\n            ownershipHolder.pBatchMintAndBurn1155(\\n                erc1155Tokens[0].tokenAddress,\\n                ids,\\n                amounts,\\n                burn,\\n                receivers[0]\\n            );\\n        }\\n    }\\n\\n    function _processBatch(\\n        uint256 network,\\n        address tokenContractAddress,\\n        uint256[] memory tokenIds,\\n        uint256[] memory erc1155tokenAmounts,\\n        RedeemTypes toBurn,\\n        address receiver,\\n        uint256 startBatchIndex,\\n        uint256 endBatchIndex,\\n        uint256 purpose\\n    ) internal {\\n        uint256 elSum = endBatchIndex - startBatchIndex;\\n        uint256 elInd;\\n        if (erc1155tokenAmounts[startBatchIndex] == 0) {\\n            ERC721TokenData[] memory erc721Tokens = new ERC721TokenData[](\\n                elSum\\n            );\\n            for (uint256 i = startBatchIndex; i < endBatchIndex; i++) {\\n                erc721Tokens[elInd] = ERC721TokenData({\\n                    tokenAddress: tokenContractAddress,\\n                    receiver: receiver,\\n                    id: tokenIds[i],\\n                    network: network,\\n                    toBurn: toBurn,\\n                    purpose: purpose\\n                });\\n                elInd++;\\n            }\\n            _processERC721(erc721Tokens);\\n        } else {\\n            ERC1155TokenData[] memory erc1155Tokens = new ERC1155TokenData[](\\n                elSum\\n            );\\n            for (uint256 i = startBatchIndex; i < endBatchIndex; i++) {\\n                erc1155Tokens[elInd] = ERC1155TokenData({\\n                    tokenAddress: tokenContractAddress,\\n                    receiver: receiver,\\n                    amount: erc1155tokenAmounts[i],\\n                    id: tokenIds[i],\\n                    network: network,\\n                    toBurn: toBurn,\\n                    purpose: purpose\\n                });\\n                elInd++;\\n            }\\n            _processERC1155(erc1155Tokens);\\n        }\\n    }\\n\\n    function _processTokens(\\n        uint256[] memory networks,\\n        address[] memory tokenContractAddreses,\\n        uint256[] memory tokenIds,\\n        uint256[] memory erc1155tokenAmounts,\\n        RedeemTypes[] memory toBurn,\\n        uint256[] memory purposes,\\n        address receiver\\n    ) internal {\\n        uint256 len = tokenContractAddreses.length;\\n        require(\\n            len == networks.length &&\\n                len == tokenIds.length &&\\n                len == erc1155tokenAmounts.length &&\\n                len == toBurn.length &&\\n                len == purposes.length,\\n            \\\"UPP: Check arrays lenghts\\\"\\n        );\\n        if (len == 0) return;\\n        uint256 elSum;\\n        for (uint256 i = 0; i < len; i++) {\\n            if (elSum > 0) {\\n                if (\\n                    tokenContractAddreses[i] != tokenContractAddreses[i - 1] ||\\n                    networks[i] != networks[i - 1] ||\\n                    toBurn[i] != toBurn[i - 1] ||\\n                    purposes[i] != purposes[i - 1]\\n                ) {\\n                    _processBatch(\\n                        networks[i - 1],\\n                        tokenContractAddreses[i - 1],\\n                        tokenIds,\\n                        erc1155tokenAmounts,\\n                        toBurn[i - 1],\\n                        receiver,\\n                        i - elSum,\\n                        i,\\n                        purposes[i - 1]\\n                    );\\n                    elSum = 0;\\n                    i--;\\n                    continue;\\n                }\\n            }\\n            elSum++;\\n        }\\n\\n        if (elSum > 0) {\\n            _processBatch(\\n                networks[len - 1],\\n                tokenContractAddreses[len - 1],\\n                tokenIds,\\n                erc1155tokenAmounts,\\n                toBurn[len - 1],\\n                receiver,\\n                len - elSum,\\n                len,\\n                purposes[len - 1]\\n            );\\n        }\\n    }\\n\\n    // ----- PUBLIC METHODS ----- //\\n    function execTransaction(\\n        uint256[] memory networks,\\n        address[] memory tokenContractAddresses,\\n        uint256[] memory tokenIds,\\n        uint256[] memory erc1155TokenAmounts,\\n        RedeemTypes[] memory toBurn,\\n        uint256[] memory purposes,\\n        uint256[] memory ptAmounts, //amount to send\\n        address[] memory ptReceivers, //tokens receivers\\n        address[] memory addresses, //0 - paymentToken address, 1- nft receiver address\\n        uint256 nonce,\\n        uint256 deadline,\\n        bytes memory signature\\n    ) external payable {\\n        require(deadline > block.timestamp, \\\"UPP: Transaction timed out\\\");\\n        require(!_isNonceUsed[nonce], \\\"UPP: Nonce already used\\\");\\n        bytes32 typedHash = _hashTypedDataV4(\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\n                        \\\"ExecData(uint256[] networks,address[] tokenContractAddresses,uint256[] tokenIds,uint256[] erc1155TokenAmounts,uint256[] toBurn,uint256[] purposes,uint256[] ptAmounts,address[] ptReceivers,address[] addresses,uint256 nonce,uint256 deadline)\\\"\\n                    ),\\n                    keccak256(abi.encodePacked(networks)),\\n                    keccak256(abi.encodePacked(tokenContractAddresses)),\\n                    keccak256(abi.encodePacked(tokenIds)),\\n                    keccak256(abi.encodePacked(erc1155TokenAmounts)),\\n                    keccak256(abi.encodePacked(toBurn)),\\n                    keccak256(abi.encodePacked(purposes)),\\n                    keccak256(abi.encodePacked(ptAmounts)),\\n                    keccak256(abi.encodePacked(ptReceivers)),\\n                    keccak256(abi.encodePacked(addresses)),\\n                    nonce,\\n                    deadline\\n                )\\n            )\\n        );\\n        require(\\n            ECDSA.recover(typedHash, signature) == signer,\\n            \\\"UPP: Signature Mismatch\\\"\\n        );\\n        _isNonceUsed[nonce] = true;\\n\\n        _sendTokens(addresses[0], ptAmounts, ptReceivers);\\n\\n        _processTokens(\\n            networks,\\n            tokenContractAddresses,\\n            tokenIds,\\n            erc1155TokenAmounts,\\n            toBurn,\\n            purposes,\\n            addresses[1]\\n        );\\n\\n        emit Executed(msg.sender, nonce);\\n    }\\n\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    // ----- PROXY METHODS ----- //\\n    function pEditClaimingAddress(\\n        address _contractAddress,\\n        address _newAddress\\n    ) external onlyOwner {\\n        ownershipHolder.pEditClaimingAdress(_contractAddress, _newAddress);\\n    }\\n\\n    function pEditRoyaltyFee(\\n        address _contractAddress,\\n        uint256 _newFee\\n    ) external onlyOwner {\\n        ownershipHolder.pEditRoyaltyFee(_contractAddress, _newFee);\\n    }\\n\\n    function pEditTokenUri(\\n        address _contractAddress,\\n        string memory _ttokenUri\\n    ) external onlyOwner {\\n        ownershipHolder.pEditTokenUri(_contractAddress, _ttokenUri);\\n    }\\n\\n    function pRecoverERC20(\\n        address _contractAddress,\\n        address token\\n    ) external onlyOwner {\\n        ownershipHolder.pRecoverERC20(_contractAddress, token);\\n    }\\n\\n    function pTransferOwnership(\\n        address _contractAddress,\\n        address newOwner\\n    ) external onlyOwner {\\n        ownershipHolder.pTransferOwnership(_contractAddress, newOwner);\\n    }\\n\\n    function pBatchMintSelectedIds(\\n        uint256[] memory _ids,\\n        address[] memory _addresses,\\n        address _contractAddress\\n    ) external onlyOwner {\\n        ownershipHolder.pBatchMintSelectedIds(\\n            _ids,\\n            _addresses,\\n            _contractAddress\\n        );\\n    }\\n\\n    function pMintNFTTokens(\\n        address _contractAddress,\\n        address _requesterAddress,\\n        uint256 _bundleId,\\n        uint256[] memory _tokenIds,\\n        uint256 _chainId,\\n        bytes memory _transactionHash\\n    ) external onlyOwner {\\n        ownershipHolder.pMintNFTTokens(\\n            _contractAddress,\\n            _requesterAddress,\\n            _bundleId,\\n            _tokenIds,\\n            _chainId,\\n            _transactionHash\\n        );\\n    }\\n\\n    function pMintNextToken(\\n        address _contractAddress,\\n        address _receiver\\n    ) external onlyOwner {\\n        ownershipHolder.pMintNextToken(_contractAddress, _receiver);\\n    }\\n\\n    function pSetNewPaymentProxy(\\n        address _contractAddress,\\n        address _newPP\\n    ) external onlyOwner {\\n        ownershipHolder.pSetNewPaymentProxy(_contractAddress, _newPP);\\n    }\\n\\n    function pSetNewAdministrator(\\n        address _contractAddress,\\n        address _newAdmin\\n    ) external onlyOwner {\\n        ownershipHolder.pSetNewAdministrator(_contractAddress, _newAdmin);\\n    }\\n\\n    // ----- OWNERS METHODS ----- //\\n\\n    function withdrawTokens(address token) external onlyOwner {\\n        uint256 val = IERC20(token).balanceOf(address(this));\\n        require(val != 0, \\\"Nothing to recover\\\");\\n        // use interface that not return value (USDT case)\\n        IERC20Fixed(token).transfer(msg.sender, val);\\n    }\\n\\n    receive() external payable {}\\n\\n    function wthdrawETH() external onlyOwner {\\n        require(payable(msg.sender).send(address(this).balance));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/UniqRedeem/IUniqRedeemV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.6;\\n\\ninterface IUniqRedeemV3 {\\n    event Redeemed(\\n        address indexed _contractAddress,\\n        uint256 indexed _tokenId,\\n        address indexed _redeemerAddress,\\n        string _redeemerName,\\n        uint256[] _purposes\\n    );\\n\\n    function isTokenRedeemedForPurpose(\\n        address _address,\\n        uint256 _tokenId,\\n        uint256 _purpose\\n    ) external view returns (bool);\\n\\n    function getMessageHash(\\n        address[] memory _tokenContracts,\\n        uint256[] memory _tokenIds,\\n        uint256[] memory _purposes,\\n        uint256 _price,\\n        address _paymentTokenAddress,\\n        uint256 _timestamp\\n    ) external pure returns (bytes32);\\n\\n    function redeemManyTokens(\\n        address[] memory _tokenContracts,\\n        uint256[] memory _tokenIds,\\n        uint256[] memory _purposes,\\n        string memory _redeemerName,\\n        uint256 _price,\\n        address _paymentTokenAddress,\\n        bytes memory _signature,\\n        uint256 _timestamp\\n    ) external payable;\\n\\n    function redeemTokenForPurposes(\\n        address _tokenContract,\\n        uint256 _tokenId,\\n        uint256[] memory _purposes,\\n        string memory _redeemerName,\\n        uint256 _price,\\n        address _paymentTokenAddress,\\n        bytes memory _signature,\\n        uint256 _timestamp\\n    ) external payable;\\n\\n    function setTransactionOffset(uint256 _newOffset) external;\\n\\n    function setStatusesForTokens(\\n        address[] memory _tokenAddresses,\\n        uint256[] memory _tokenIds,\\n        uint256[] memory _purposes,\\n        bool[] memory isRedeemed\\n    ) external;\\n\\n    function withdrawERC20(address _address) external;\\n\\n    function withdrawETH() external;\\n\\n    function redeemTokensAsAdmin(\\n        address[] memory _tokenContracts,\\n        uint256[] memory _tokenIds,\\n        uint256[] memory _purposes,\\n        string[] memory _redeemerName\\n    ) external;\\n\\n    function redeemTokenForPurposesAsAdmin(\\n        address _tokenContract,\\n        uint256 _tokenId,\\n        uint256[] memory _purposes,\\n        string memory _redeemerName\\n    ) external;\\n\\n\\n    function redeemTokensAsAdmin(\\n        address[] memory _tokenContracts,\\n        uint256[] memory _tokenIds,\\n        uint256[] memory _purposes,\\n        address[] memory _owners,\\n        string[] memory _redeemerName,\\n        uint256[] memory _networks\\n    ) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pnetworkId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_redeem\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ownershipHolder\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_isNonceUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"networks\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenContractAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"erc1155TokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"enum UniqPaymentProxyV3.RedeemTypes[]\",\"name\":\"toBurn\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"purposes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ptAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"ptReceivers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"execTransaction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownershipHolder\",\"outputs\":[{\"internalType\":\"contract IOwnershipHolder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"pBatchMintSelectedIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"pEditClaimingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"pEditRoyaltyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_ttokenUri\",\"type\":\"string\"}],\"name\":\"pEditTokenUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_requesterAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bundleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_transactionHash\",\"type\":\"bytes\"}],\"name\":\"pMintNFTTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"pMintNextToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"pRecoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"pSetNewAdministrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newPP\",\"type\":\"address\"}],\"name\":\"pSetNewPaymentProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"pTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"contract IUniqRedeemV3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOwnershipHolder\",\"name\":\"_ownershipHolder\",\"type\":\"address\"}],\"name\":\"setOwnershipHolderAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniqRedeemV3\",\"name\":\"_redeemAddress\",\"type\":\"address\"}],\"name\":\"setRedeemAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wthdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UniqPaymentProxyV3", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "15", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000089000000000000000000000000eb443863e3aaebafd470d40d3e088c573b0630ae000000000000000000000000c283229fb3f7e38e53ed53adcfcb0d3b811fa4f3000000000000000000000000d3bbdca6af805f54cda8547b54852392a4b31895", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}