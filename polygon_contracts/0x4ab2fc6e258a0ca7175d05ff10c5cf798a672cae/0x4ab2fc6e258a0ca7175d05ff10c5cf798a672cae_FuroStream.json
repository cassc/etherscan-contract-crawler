{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/FuroStream.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"../interfaces/IFuroStream.sol\\\";\\n\\n\\n// Use the FuroStreamRouter to create Streams and do not create streams directly.\\n\\ncontract FuroStream is\\n    IFuroStream,\\n    ERC721(\\\"Furo Stream\\\", \\\"FUROSTREAM\\\"),\\n    Multicall,\\n    BoringOwnable\\n{\\n    IBentoBoxMinimal public immutable bentoBox;\\n    address public immutable wETH;\\n\\n    uint256 public streamIds;\\n\\n    address public tokenURIFetcher;\\n\\n    mapping(uint256 => Stream) public streams;\\n\\n    // custom errors\\n    error NotSenderOrRecipient();\\n    error InvalidStartTime();\\n    error InvalidEndTime();\\n    error InvalidWithdrawTooMuch();\\n    error NotSender();\\n    error Overflow();\\n\\n    constructor(IBentoBoxMinimal _bentoBox, address _wETH) {\\n        bentoBox = _bentoBox;\\n        wETH = _wETH;\\n        streamIds = 1000;\\n        _bentoBox.registerProtocol();\\n    }\\n\\n    function setTokenURIFetcher(address _fetcher) external onlyOwner {\\n        tokenURIFetcher = _fetcher;\\n    }\\n\\n    function tokenURI(uint256 id) public view override returns (string memory) {\\n        return ITokenURIFetcher(tokenURIFetcher).fetchTokenURIData(id);\\n    }\\n\\n    function setBentoBoxApproval(\\n        address user,\\n        bool approved,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable override {\\n        bentoBox.setMasterContractApproval(\\n            user,\\n            address(this),\\n            approved,\\n            v,\\n            r,\\n            s\\n        );\\n    }\\n\\n    function createStream(\\n        address recipient,\\n        address token,\\n        uint64 startTime,\\n        uint64 endTime,\\n        uint256 amount, /// @dev in token amount and not in shares\\n        bool fromBentoBox\\n    )\\n        external\\n        payable\\n        override\\n        returns (uint256 streamId, uint256 depositedShares)\\n    {\\n        if (startTime < block.timestamp) revert InvalidStartTime();\\n        if (endTime <= startTime) revert InvalidEndTime();\\n\\n        depositedShares = _depositToken(\\n            token,\\n            msg.sender,\\n            address(this),\\n            amount,\\n            fromBentoBox\\n        );\\n\\n        streamId = streamIds++;\\n\\n        _mint(recipient, streamId);\\n\\n        streams[streamId] = Stream({\\n            sender: msg.sender,\\n            token: token == address(0) ? wETH : token,\\n            depositedShares: uint128(depositedShares), // @dev safe since we know bento returns u128\\n            withdrawnShares: 0,\\n            startTime: startTime,\\n            endTime: endTime\\n        });\\n\\n        emit CreateStream(\\n            streamId,\\n            msg.sender,\\n            recipient,\\n            token,\\n            depositedShares,\\n            startTime,\\n            endTime,\\n            fromBentoBox\\n        );\\n    }\\n\\n    function withdrawFromStream(\\n        uint256 streamId,\\n        uint256 sharesToWithdraw,\\n        address withdrawTo,\\n        bool toBentoBox,\\n        bytes calldata taskData\\n    ) external override returns (uint256 recipientBalance, address to) {\\n        address recipient = ownerOf[streamId];\\n        if (msg.sender != streams[streamId].sender && msg.sender != recipient) {\\n            revert NotSenderOrRecipient();\\n        }\\n        Stream storage stream = streams[streamId];\\n        (, recipientBalance) = _streamBalanceOf(stream);\\n        if (recipientBalance < sharesToWithdraw)\\n            revert InvalidWithdrawTooMuch();\\n        stream.withdrawnShares += uint128(sharesToWithdraw);\\n\\n        if (msg.sender == recipient && withdrawTo != address(0)) {\\n            to = withdrawTo;\\n        } else {\\n            to = recipient;\\n        }\\n\\n        _transferToken(\\n            stream.token,\\n            address(this),\\n            to,\\n            sharesToWithdraw,\\n            toBentoBox\\n        );\\n\\n        if (taskData.length != 0 && msg.sender == recipient)\\n            ITasker(to).onTaskReceived(taskData);\\n\\n        emit Withdraw(\\n            streamId,\\n            sharesToWithdraw,\\n            withdrawTo,\\n            stream.token,\\n            toBentoBox\\n        );\\n    }\\n\\n    function cancelStream(uint256 streamId, bool toBentoBox)\\n        external\\n        override\\n        returns (uint256 senderBalance, uint256 recipientBalance)\\n    {\\n        address recipient = ownerOf[streamId];\\n        if (msg.sender != streams[streamId].sender && msg.sender != recipient) {\\n            revert NotSenderOrRecipient();\\n        }\\n        Stream memory stream = streams[streamId];\\n        (senderBalance, recipientBalance) = _streamBalanceOf(stream);\\n\\n        delete streams[streamId];\\n\\n        _transferToken(\\n            stream.token,\\n            address(this),\\n            recipient,\\n            recipientBalance,\\n            toBentoBox\\n        );\\n        _transferToken(\\n            stream.token,\\n            address(this),\\n            stream.sender,\\n            senderBalance,\\n            toBentoBox\\n        );\\n\\n        emit CancelStream(\\n            streamId,\\n            senderBalance,\\n            recipientBalance,\\n            stream.token,\\n            toBentoBox\\n        );\\n    }\\n\\n    function getStream(uint256 streamId)\\n        external\\n        view\\n        override\\n        returns (Stream memory)\\n    {\\n        return streams[streamId];\\n    }\\n\\n    function streamBalanceOf(uint256 streamId)\\n        external\\n        view\\n        override\\n        returns (uint256 senderBalance, uint256 recipientBalance)\\n    {\\n        return _streamBalanceOf(streams[streamId]);\\n    }\\n\\n    function _streamBalanceOf(Stream memory stream)\\n        internal\\n        view\\n        returns (uint256 senderBalance, uint256 recipientBalance)\\n    {\\n        if (block.timestamp <= stream.startTime) {\\n            senderBalance = stream.depositedShares;\\n            recipientBalance = 0;\\n        } else if (stream.endTime <= block.timestamp) {\\n            recipientBalance = stream.depositedShares - stream.withdrawnShares;\\n            senderBalance = 0;\\n        } else {\\n            uint64 timeDelta = uint64(block.timestamp) - stream.startTime;\\n            uint128 streamed = ((stream.depositedShares * timeDelta) /\\n                (stream.endTime - stream.startTime));\\n            recipientBalance = streamed - stream.withdrawnShares;\\n            senderBalance = stream.depositedShares - streamed;\\n        }\\n    }\\n\\n    function updateSender(uint256 streamId, address sender) external override {\\n        Stream storage stream = streams[streamId];\\n        if (msg.sender != stream.sender) revert NotSender();\\n        stream.sender = sender;\\n    }\\n\\n    function updateStream(\\n        uint256 streamId,\\n        uint128 topUpAmount,\\n        uint64 extendTime,\\n        bool fromBentoBox\\n    ) external payable override returns (uint256 depositedShares) {\\n        Stream storage stream = streams[streamId];\\n        if (msg.sender != stream.sender) revert NotSender();\\n\\n        depositedShares = _depositToken(\\n            stream.token,\\n            stream.sender,\\n            address(this),\\n            topUpAmount,\\n            fromBentoBox\\n        );\\n\\n        address recipient = ownerOf[streamId];\\n\\n        (uint256 senderBalance, uint256 recipientBalance) = _streamBalanceOf(\\n            stream\\n        );\\n\\n        stream.startTime = uint64(block.timestamp);\\n        stream.withdrawnShares = 0;\\n        uint256 newDepositedShares = senderBalance + depositedShares;\\n        if (newDepositedShares > type(uint128).max) revert Overflow();\\n        stream.depositedShares = uint128(newDepositedShares);\\n        stream.endTime += extendTime;\\n\\n        _transferToken(\\n            stream.token,\\n            address(this),\\n            recipient,\\n            recipientBalance,\\n            true\\n        );\\n\\n        emit UpdateStream(streamId, topUpAmount, extendTime, fromBentoBox);\\n    }\\n\\n    function _depositToken(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bool fromBentoBox\\n    ) internal returns (uint256 depositedShares) {\\n        if (fromBentoBox) {\\n            depositedShares = bentoBox.toShare(token, amount, false);\\n            bentoBox.transfer(token, from, to, depositedShares);\\n        } else {\\n            (, depositedShares) = bentoBox.deposit{\\n                value: token == address(0) ? amount : 0\\n            }(token, from, to, amount, 0);\\n        }\\n    }\\n\\n    function _transferToken(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 share,\\n        bool toBentoBox\\n    ) internal {\\n        if (toBentoBox) {\\n            bentoBox.transfer(token, from, to, share);\\n        } else {\\n            bentoBox.withdraw(token, from, to, 0, share);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFuroStream.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./ITasker.sol\\\";\\nimport \\\"./ITokenURIFetcher.sol\\\";\\nimport \\\"./IBentoBoxMinimal.sol\\\";\\nimport \\\"../utils/Multicall.sol\\\";\\nimport \\\"../utils/BoringOwnable.sol\\\";\\nimport \\\"@rari-capital/solmate/src/tokens/ERC721.sol\\\";\\n\\ninterface IFuroStream {\\n    function setBentoBoxApproval(\\n        address user,\\n        bool approved,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable;\\n\\n    function createStream(\\n        address recipient,\\n        address token,\\n        uint64 startTime,\\n        uint64 endTime,\\n        uint256 amount, /// @dev in token amount and not in shares\\n        bool fromBento\\n    ) external payable returns (uint256 streamId, uint256 depositedShares);\\n\\n    function withdrawFromStream(\\n        uint256 streamId,\\n        uint256 sharesToWithdraw,\\n        address withdrawTo,\\n        bool toBentoBox,\\n        bytes memory taskData\\n    ) external returns (uint256 recipientBalance, address to);\\n\\n    function cancelStream(uint256 streamId, bool toBentoBox)\\n        external\\n        returns (uint256 senderBalance, uint256 recipientBalance);\\n\\n    function updateSender(uint256 streamId, address sender) external;\\n\\n    function updateStream(\\n        uint256 streamId,\\n        uint128 topUpAmount,\\n        uint64 extendTime,\\n        bool fromBentoBox\\n    ) external payable returns (uint256 depositedShares);\\n\\n    function streamBalanceOf(uint256 streamId)\\n        external\\n        view\\n        returns (uint256 senderBalance, uint256 recipientBalance);\\n\\n    function getStream(uint256 streamId) external view returns (Stream memory);\\n\\n    event CreateStream(\\n        uint256 indexed streamId,\\n        address indexed sender,\\n        address indexed recipient,\\n        address token,\\n        uint256 amount,\\n        uint256 startTime,\\n        uint256 endTime,\\n        bool fromBentoBox\\n    );\\n\\n    event UpdateStream(\\n        uint256 indexed streamId,\\n        uint128 indexed topUpAmount,\\n        uint64 indexed extendTime,\\n        bool fromBentoBox\\n    );\\n\\n    event Withdraw(\\n        uint256 indexed streamId,\\n        uint256 indexed sharesToWithdraw,\\n        address indexed withdrawTo,\\n        address token,\\n        bool toBentoBox\\n    );\\n\\n    event CancelStream(\\n        uint256 indexed streamId,\\n        uint256 indexed senderBalance,\\n        uint256 indexed recipientBalance,\\n        address token,\\n        bool toBentoBox\\n    );\\n\\n    struct Stream {\\n        address sender;\\n        address token;\\n        uint128 depositedShares;\\n        uint128 withdrawnShares;\\n        uint64 startTime;\\n        uint64 endTime;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITasker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.8.10;\\n\\ninterface ITasker {\\n    function onTaskReceived(\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenURIFetcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.8.10;\\n\\ninterface ITokenURIFetcher {\\n    function fetchTokenURIData(uint256 id)\\n        external\\n        view\\n        returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBentoBoxMinimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.8.10;\\n\\n/// @notice Minimal BentoBox vault interface.\\n/// @dev `token` is aliased as `address` from `IERC20` for simplicity.\\ninterface IBentoBoxMinimal {\\n    /// @notice Balance per ERC-20 token per account in shares.\\n    function balanceOf(address, address) external view returns (uint256);\\n\\n    /// @dev Helper function to represent an `amount` of `token` in shares.\\n    /// @param token The ERC-20 token.\\n    /// @param amount The `token` amount.\\n    /// @param roundUp If the result `share` should be rounded up.\\n    /// @return share The token amount represented in shares.\\n    function toShare(\\n        address token,\\n        uint256 amount,\\n        bool roundUp\\n    ) external view returns (uint256 share);\\n\\n    /// @dev Helper function to represent shares back into the `token` amount.\\n    /// @param token The ERC-20 token.\\n    /// @param share The amount of shares.\\n    /// @param roundUp If the result should be rounded up.\\n    /// @return amount The share amount back into native representation.\\n    function toAmount(\\n        address token,\\n        uint256 share,\\n        bool roundUp\\n    ) external view returns (uint256 amount);\\n\\n    /// @notice Registers this contract so that users can approve it for BentoBox.\\n    function registerProtocol() external;\\n\\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\\n    /// @param token_ The ERC-20 token to deposit.\\n    /// @param from which account to pull the tokens.\\n    /// @param to which account to push the tokens.\\n    /// @param amount Token amount in native representation to deposit.\\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\\n    /// @return amountOut The amount deposited.\\n    /// @return shareOut The deposited amount represented in shares.\\n    function deposit(\\n        address token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\\n\\n    /// @notice Withdraws an amount of `token` from a user account.\\n    /// @param token_ The ERC-20 token to withdraw.\\n    /// @param from which user to pull the tokens.\\n    /// @param to which user to push the tokens.\\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\\n    /// @param share Like above, but `share` takes precedence over `amount`.\\n    function withdraw(\\n        address token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external returns (uint256 amountOut, uint256 shareOut);\\n\\n    /// @notice Transfer shares from a user account to another one.\\n    /// @param token The ERC-20 token to transfer.\\n    /// @param from which user to pull the tokens.\\n    /// @param to which user to push the tokens.\\n    /// @param share The amount of `token` in shares.\\n    function transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 share\\n    ) external;\\n\\n    function setMasterContractApproval(\\n        address user,\\n        address masterContract,\\n        bool approved,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.10;\\n\\n/// @title Multicall\\n/// @notice Enables calling multiple methods in a single call to the contract\\nabstract contract Multicall {\\n    function multicall(bytes[] calldata data)\\n        public\\n        payable\\n        returns (bytes[] memory results)\\n    {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(\\n                data[i]\\n            );\\n\\n            if (!success) {\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n                if (result.length < 68) revert();\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n\\n            results[i] = result;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/BoringOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\\n// Edited by BoringCrypto\\n\\ncontract BoringOwnableData {\\n    address public owner;\\n    address public pendingOwner;\\n}\\n\\ncontract BoringOwnable is BoringOwnableData {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @notice `owner` defaults to msg.sender on construction.\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\\n    /// Can only be invoked by the current `owner`.\\n    /// @param newOwner Address of the new owner.\\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\\n    function transferOwnership(\\n        address newOwner,\\n        bool direct,\\n        bool renounce\\n    ) public onlyOwner {\\n        if (direct) {\\n            // Checks\\n            require(\\n                newOwner != address(0) || renounce,\\n                \\\"Ownable: zero address\\\"\\n            );\\n\\n            // Effects\\n            emit OwnershipTransferred(owner, newOwner);\\n            owner = newOwner;\\n            pendingOwner = address(0);\\n        } else {\\n            // Effects\\n            pendingOwner = newOwner;\\n        }\\n    }\\n\\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\\n    function claimOwnership() public {\\n        address _pendingOwner = pendingOwner;\\n\\n        // Checks\\n        require(\\n            msg.sender == _pendingOwner,\\n            \\\"Ownable: caller != pending owner\\\"\\n        );\\n\\n        // Effects\\n        emit OwnershipTransferred(owner, _pendingOwner);\\n        owner = _pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n\\n    /// @notice Only allows the `owner` to execute the function.\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(uint256 => address) public ownerOf;\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBentoBoxMinimal\",\"name\":\"_bentoBox\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidEndTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStartTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidWithdrawTooMuch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSenderOrRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Overflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"senderBalance\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"recipientBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"toBentoBox\",\"type\":\"bool\"}],\"name\":\"CancelStream\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"fromBentoBox\",\"type\":\"bool\"}],\"name\":\"CreateStream\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"topUpAmount\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"extendTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"fromBentoBox\",\"type\":\"bool\"}],\"name\":\"UpdateStream\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sharesToWithdraw\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"withdrawTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"toBentoBox\",\"type\":\"bool\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bentoBox\",\"outputs\":[{\"internalType\":\"contract IBentoBoxMinimal\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"toBentoBox\",\"type\":\"bool\"}],\"name\":\"cancelStream\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"senderBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recipientBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fromBentoBox\",\"type\":\"bool\"}],\"name\":\"createStream\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositedShares\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"getStream\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"depositedShares\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"withdrawnShares\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"}],\"internalType\":\"struct IFuroStream.Stream\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"setBentoBoxApproval\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fetcher\",\"type\":\"address\"}],\"name\":\"setTokenURIFetcher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"streamBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"senderBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recipientBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"streamIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"streams\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"depositedShares\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"withdrawnShares\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenURIFetcher\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"updateSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"topUpAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"extendTime\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"fromBentoBox\",\"type\":\"bool\"}],\"name\":\"updateStream\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"depositedShares\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesToWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"withdrawTo\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toBentoBox\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"taskData\",\"type\":\"bytes\"}],\"name\":\"withdrawFromStream\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"recipientBalance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FuroStream", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000000319000133d3ada02600f0875d2cf03d442c33670000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}