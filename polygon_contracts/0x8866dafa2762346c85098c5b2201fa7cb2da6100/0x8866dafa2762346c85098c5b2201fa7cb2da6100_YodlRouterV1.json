{"SourceCode": "//SPDX-License-Identifier: Unlicense\r\npragma solidity 0.8.13;\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with 'STF' if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with 'SA' if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\r\n    }\r\n\r\n    /// @notice Transfers ETH to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'STE');\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}\r\n\r\npragma abicoder v2;\r\n\r\n/// @title Callback for IUniswapV3PoolActions#swap\r\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\r\ninterface IUniswapV3SwapCallback {\r\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\r\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\r\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\r\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\r\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\r\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\r\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via Uniswap V3\r\ninterface ISwapRouter is IUniswapV3SwapCallback {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\r\n}\r\n\r\n// The Uniswap IWETH9 has an incompatible version. However, this is just an interface, so the version is irrelevant.\r\n/// @title Interface for WETH9\r\ninterface IWETH9 is IERC20 {\r\n    /// @notice Deposit ether to get wrapped ether\r\n    function deposit() external payable;\r\n\r\n    /// @notice Withdraw wrapped ether to get ether\r\n    function withdraw(uint256) external;\r\n}\r\n\r\ninterface ICurveRouter {\r\n    function exchange_multiple(\r\n        address[9] calldata _route,\r\n        uint256[3][4] calldata _swap_params,\r\n        uint256 _amount,\r\n        uint256 _expected,\r\n        address[4] calldata _pools,\r\n        address _receiver\r\n    ) external payable returns (uint256);\r\n}\r\n\r\n/// @title Yodl Router\r\n/// @author YodlPay\r\n/// @notice This contract facilitates payments for the yodl.me platform. It supports direct token payments\r\n/// as well as payments using swaps through Uniswap and Curve. There is support for cross-currency payments\r\n/// using Chainlink price feeds.\r\n/// @dev Keep in mind when deploying that a IWETH9 compatible wrapped native token needs to be available on chain.\r\n/// For Uniswap or Curve payments to work, there needs to be a valid router for each. The Curve router should support\r\n/// the `exchange_multiple` method.\r\ncontract YodlRouterV1 is Ownable {\r\n    enum SwapType {\r\n        SINGLE,\r\n        MULTI\r\n    }\r\n\r\n    /// @notice Parameters for a payment through Uniswap\r\n    /// @dev The `returnRemainder` boolean determines if the excess token in should be returned to the user.\r\n    struct YodlUniswapParams {\r\n        address sender;\r\n        address receiver;\r\n        uint256 amountIn; // amount of tokenIn needed to satisfy amountOut\r\n        uint256 amountOut; // The exact amount expected by merchant in tokenOut\r\n        bytes32 memo;\r\n        bytes path; // (address: tokenOut, uint24 poolfee, address: tokenIn) OR (address: tokenOut, uint24 poolfee2, address: tokenBase, uint24 poolfee1, tokenIn)\r\n        address[2] priceFeeds;\r\n        address extraFeeReceiver;\r\n        uint256 extraFeeBps;\r\n        bool returnRemainder;\r\n        SwapType swapType;\r\n    }\r\n\r\n    /// @notice Parameters for a payment through Curve\r\n    /// @dev The`route`, `swapParams` and `factoryAddresses` should be determined client-side by the CurveJS client.\r\n    /// The `returnRemainder` boolean determines if the excess token out should be returned to the user.\r\n    struct YodlCurveParams {\r\n        address sender;\r\n        address receiver;\r\n        uint256 amountIn; // amount of tokenIn needed to satisfy amountOut\r\n        // The exact amount expected by merchant in tokenOut\r\n        // If we are using price feeds, this is in terms of the invoice amount, but it must have the same decimals as tokenOut\r\n        uint256 amountOut;\r\n        bytes32 memo;\r\n        address[9] route;\r\n        uint256[3][4] swapParams; // [i, j, swap_type] where i and j are the coin index for the n'th pool in route\r\n        address[4] factoryAddresses;\r\n        address[2] priceFeeds;\r\n        address extraFeeReceiver;\r\n        uint256 extraFeeBps;\r\n        bool returnRemainder;\r\n    }\r\n\r\n    // This is not an actual token address, but we will use it to represent the native token in swaps\r\n    address public constant NATIVE_TOKEN =\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    uint256 public constant MAX_FEE_BPS = 5_000; // 50%\r\n\r\n    address public feeTreasury;\r\n    uint256 public baseFeeBps; // fee = calculateFee(amount, baseFeeDivisor)\r\n    ISwapRouter public uniswapRouter;\r\n    ICurveRouter public curveRouter;\r\n    // Before deploying to a L2 with its own native token,\r\n    // we should check that its wrapped native token works with IWETH9\r\n    IWETH9 public wrappedNativeToken;\r\n    string public version;\r\n\r\n    /// @notice Emitted when a payment goes through\r\n    /// @param sender The address who has made the payment\r\n    /// @param receiver The address who has received the payment\r\n    /// @param token The address of the token that was used for the payment. Either an ERC20 token or the native token\r\n    /// address.\r\n    /// @param amount The amount paid by the sender in terms of the token\r\n    /// @param fees The fees taken by the Yodl router from the amount paid\r\n    /// @param memo The message attached to the payment\r\n    event Payment(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address token /* the token that payee receives, use address(0) for AVAX*/,\r\n        uint256 amount,\r\n        uint256 fees,\r\n        bytes32 memo\r\n    );\r\n\r\n    /// @notice Emitted when a conversion has occured from one currency to another using a Chainlink price feed\r\n    /// @param priceFeed The address of the price feed used for conversion\r\n    /// @param exchangeRate The rate used from the price feed at the time of conversion\r\n    event Convert(address indexed priceFeed, int256 exchangeRate);\r\n\r\n    /// @notice Initializes the YodlRouter contract\r\n    /// @dev Using an incorrect _wrappedNativeToken address will result in native token payments reverting\r\n    /// @param _feeTreasury The address where we want the router to send fees. Can be a contract that supports receiving\r\n    /// the native token or a regular address.\r\n    /// @param _baseFeeBps The basis point amount as a whole number that we will take as a fee\r\n    /// @param _version Version number of the contract\r\n    /// @param _uniswapRouter The address of the Uniswap router, or address(0) if not supported\r\n    /// @param _curveRouter The address of the Curve router, or address(0) if not supported\r\n    /// @param _wrappedNativeToken The address of the IWETH9 compatible wrapped native token\r\n    constructor(\r\n        address _feeTreasury,\r\n        uint256 _baseFeeBps,\r\n        string memory _version,\r\n        address _uniswapRouter,\r\n        address _curveRouter,\r\n        address _wrappedNativeToken\r\n    ) {\r\n        baseFeeBps = _baseFeeBps;\r\n        feeTreasury = _feeTreasury;\r\n        version = _version;\r\n        uniswapRouter = ISwapRouter(_uniswapRouter);\r\n        curveRouter = ICurveRouter(_curveRouter);\r\n        wrappedNativeToken = IWETH9(_wrappedNativeToken);\r\n    }\r\n\r\n    /// @notice Enables the contract to receive Ether\r\n    /// @dev We need a receive method for when we withdraw WETH to the router. It does not need to do anything.\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @notice Handles payments when sending tokens directly without DEX.\r\n     * ## Example: Pay without pricefeeds, e.g. USDC transfer\r\n     *\r\n     * payWithToken(\r\n     *   \"tx-123\",         // memo\r\n     *   5*10**18,         // 5$\r\n     *   [0x0, 0x0],  // no pricefeeds\r\n     *   0xUSDC,           // usdc token address\r\n     *   0xAlice           // receiver token address\r\n     * )\r\n     *\r\n     * ## Example: Pay with pricefeeds (EUR / USD)\r\n     *\r\n     * The user entered the amount in EUR, which gets converted into\r\n     * USD by the on-chain pricefeed.\r\n     *\r\n     * payWithToken(\r\n     *     \"tx-123\",               // memo\r\n     *     4.5*10**18,             // 4.5 EUR (~5$).\r\n     *     [0xEURUSD, 0x0],   // EUR/USD price feed\r\n     *     0xUSDC,                 // usdc token address\r\n     *     0xAlice                 // receiver token address\r\n     * )\r\n     *\r\n     *\r\n     * ## Example: Pay with extra fee\r\n     *\r\n     * 3rd parties can receive an extra fee that is taken directly from\r\n     * the receivable amount.\r\n     *\r\n     * payWithToken(\r\n     *     \"tx-123\",               // memo\r\n     *     4.5*10**18,             // 4.5 EUR (~5$).\r\n     *     [0xEURUSD, 0x0],   //\r\n     *     0xUSDC,                 // usdc token address\r\n     *     0xAlice,                // receiver token address\r\n     *     0x3rdParty              // extra fee for 3rd party provider\r\n     *     50,                    // extra fee bps 0.5%\r\n     * )\r\n     * @dev This is the most gas efficient payment method. It supports currency conversion using price feeds. The\r\n     * native token (ETH, AVAX, MATIC) is represented by the NATIVE_TOKEN constant.\r\n     * @param memo The message attached to the payment. If present, the router will take a fee.\r\n     * @param amount The amount to pay before any price feeds are applied. This amount will be converted by the price\r\n     * feeds and then the sender will pay the converted amount in the given token.\r\n     * @param priceFeeds Array of Chainlink price feeds. See `exchangeRate` method for more details.\r\n     * @param token Token address to be used for the payment. Either an ERC20 token or the native token address.\r\n     * @param receiver Address to receive the payment\r\n     * @param extraFeeReceiver Address to receive an extra fee that is taken from the payment amount\r\n     * @param extraFeeBps Size of the extra fee in terms of basis points (or 0 for none)\r\n     * @return Boolean representing whether the payment was successful\r\n     */\r\n    function payWithToken(\r\n        bytes32 memo,\r\n        uint256 amount,\r\n        address[2] calldata priceFeeds,\r\n        address token,\r\n        address receiver,\r\n        address extraFeeReceiver,\r\n        uint256 extraFeeBps\r\n    ) external payable returns (bool) {\r\n        require(amount != 0, \"invalid amount\");\r\n\r\n        // transform amount with priceFeeds\r\n        if (priceFeeds[0] != address(0) || priceFeeds[1] != address(0)) {\r\n            {\r\n                int256[2] memory prices;\r\n                address[2] memory priceFeedsUsed;\r\n                (amount, priceFeedsUsed, prices) = exchangeRate(\r\n                    priceFeeds,\r\n                    amount\r\n                );\r\n                emit Convert(priceFeedsUsed[0], prices[0]);\r\n                if (priceFeedsUsed[1] != address(0)) {\r\n                    emit Convert(priceFeedsUsed[1], prices[1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (token != NATIVE_TOKEN) {\r\n            // ERC20 token\r\n            require(\r\n                IERC20(token).allowance(msg.sender, address(this)) >= amount,\r\n                \"insufficient allowance\"\r\n            );\r\n        } else {\r\n            // Native ether\r\n            require(msg.value >= amount, \"insufficient ether provided\");\r\n        }\r\n\r\n        uint256 totalFee = 0;\r\n\r\n        if (memo != \"\") {\r\n            totalFee += transferFee(\r\n                amount,\r\n                baseFeeBps,\r\n                token,\r\n                token == NATIVE_TOKEN ? address(this) : msg.sender,\r\n                feeTreasury\r\n            );\r\n        }\r\n\r\n        if (extraFeeReceiver != address(0)) {\r\n            // 50% maximum extra fee\r\n            require(extraFeeBps < MAX_FEE_BPS, \"extraFeeBps too high\");\r\n\r\n            totalFee += transferFee(\r\n                amount,\r\n                extraFeeBps,\r\n                token,\r\n                token == NATIVE_TOKEN ? address(this) : msg.sender,\r\n                extraFeeReceiver\r\n            );\r\n        }\r\n\r\n        // Transfer to receiver\r\n        if (token != NATIVE_TOKEN) {\r\n            // ERC20 token\r\n            TransferHelper.safeTransferFrom(\r\n                token,\r\n                msg.sender,\r\n                receiver,\r\n                amount - totalFee\r\n            );\r\n        } else {\r\n            // Native ether\r\n            (bool success, ) = receiver.call{value: amount - totalFee}(\"\");\r\n            require(success, \"transfer failed\");\r\n        }\r\n\r\n        emit Payment(msg.sender, receiver, token, amount, totalFee, memo);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Handles a payment with a swap through Uniswap\r\n    /// @dev This needs to have a valid Uniswap router or it will revert. Excess tokens from the swap as a result\r\n    /// of slippage are in terms of the token in.\r\n    /// @param params Struct that contains all the relevant parameters. See `YodlUniswapParams` for more details.\r\n    /// @return The amount spent in terms of token in by Uniswap to complete this payment\r\n    function payWithUniswap(\r\n        YodlUniswapParams calldata params\r\n    ) external payable returns (uint256) {\r\n        require(\r\n            address(uniswapRouter) != address(0),\r\n            \"uniswap router not present\"\r\n        );\r\n        (address tokenOut, address tokenIn) = decodeTokenInTokenOut(\r\n            params.path,\r\n            params.swapType\r\n        );\r\n        uint256 amountSpent;\r\n\r\n        // This is how much the recipient needs to receive\r\n        uint256 amountOutExpected;\r\n        if (\r\n            params.priceFeeds[0] != address(0) ||\r\n            params.priceFeeds[1] != address(0)\r\n        ) {\r\n            // Convert amountOut from invoice currency to swap currency using price feed\r\n            int256[2] memory prices;\r\n            address[2] memory priceFeeds;\r\n            (amountOutExpected, priceFeeds, prices) = exchangeRate(\r\n                params.priceFeeds,\r\n                params.amountOut\r\n            );\r\n            emit Convert(priceFeeds[0], prices[0]);\r\n            if (priceFeeds[1] != address(0)) {\r\n                emit Convert(priceFeeds[1], prices[1]);\r\n            }\r\n        } else {\r\n            amountOutExpected = params.amountOut;\r\n        }\r\n\r\n        // There should be no other situation in which we send a transaction with native token\r\n        if (msg.value != 0) {\r\n            // Wrap the native token\r\n            require(\r\n                msg.value >= params.amountIn,\r\n                \"insufficient ether provided\"\r\n            );\r\n            wrappedNativeToken.deposit{value: params.amountIn}();\r\n\r\n            // Update the tokenIn to wrapped native token\r\n            // wrapped native token has the same number of decimals as native token\r\n            tokenIn = address(wrappedNativeToken);\r\n        } else {\r\n            // Transfer the ERC20 token from the sender to the YodlRouter\r\n            TransferHelper.safeTransferFrom(\r\n                tokenIn,\r\n                msg.sender,\r\n                address(this),\r\n                params.amountIn\r\n            );\r\n        }\r\n        TransferHelper.safeApprove(\r\n            tokenIn,\r\n            address(uniswapRouter),\r\n            params.amountIn\r\n        );\r\n\r\n        // Special case for when we want native token out\r\n        bool useNativeToken = false;\r\n        if (tokenOut == NATIVE_TOKEN) {\r\n            useNativeToken = true;\r\n            tokenOut = address(wrappedNativeToken);\r\n        }\r\n\r\n        if (params.swapType == SwapType.SINGLE) {\r\n            uint24 poolFee = decodeSinglePoolFee(params.path);\r\n            ISwapRouter.ExactOutputSingleParams\r\n                memory routerParams = ISwapRouter.ExactOutputSingleParams({\r\n                    tokenIn: tokenIn,\r\n                    tokenOut: tokenOut,\r\n                    fee: poolFee,\r\n                    recipient: address(this),\r\n                    deadline: block.timestamp,\r\n                    amountOut: amountOutExpected,\r\n                    amountInMaximum: params.amountIn,\r\n                    sqrtPriceLimitX96: 0\r\n                });\r\n\r\n            amountSpent = uniswapRouter.exactOutputSingle(routerParams);\r\n        } else {\r\n            // We need to extract the path details so that we can use the tokenIn value from earlier which may have been replaced by WETH\r\n            (, uint24 poolFee2, address tokenBase, uint24 poolFee1, ) = abi\r\n                .decode(\r\n                    params.path,\r\n                    (address, uint24, address, uint24, address)\r\n                );\r\n            ISwapRouter.ExactOutputParams memory uniswapParams = ISwapRouter\r\n                .ExactOutputParams({\r\n                    path: abi.encodePacked(\r\n                        tokenOut,\r\n                        poolFee2,\r\n                        tokenBase,\r\n                        poolFee1,\r\n                        tokenIn\r\n                    ),\r\n                    recipient: address(this),\r\n                    deadline: block.timestamp,\r\n                    amountOut: amountOutExpected,\r\n                    amountInMaximum: params.amountIn\r\n                });\r\n\r\n            amountSpent = uniswapRouter.exactOutput(uniswapParams);\r\n        }\r\n\r\n        // Handle unwrapping wrapped native token\r\n        if (useNativeToken) {\r\n            // Unwrap and use NATIVE_TOKEN address as tokenOut\r\n            IWETH9(wrappedNativeToken).withdraw(amountOutExpected);\r\n            tokenOut = NATIVE_TOKEN;\r\n        }\r\n\r\n        // Calculate fee from amount out\r\n        uint256 totalFee = 0;\r\n        if (params.memo != \"\") {\r\n            totalFee += calculateFee(amountOutExpected, baseFeeBps);\r\n        }\r\n\r\n        // Handle extra fees\r\n        if (params.extraFeeReceiver != address(0)) {\r\n            // 50% maximum extra fee\r\n            require(params.extraFeeBps < MAX_FEE_BPS, \"extraFee too high\");\r\n\r\n            totalFee += transferFee(\r\n                amountOutExpected,\r\n                params.extraFeeBps,\r\n                tokenOut,\r\n                address(this),\r\n                params.extraFeeReceiver\r\n            );\r\n        }\r\n\r\n        if (tokenOut == NATIVE_TOKEN) {\r\n            (bool success, ) = params.receiver.call{\r\n                value: amountOutExpected - totalFee\r\n            }(\"\");\r\n            require(success, \"transfer failed\");\r\n        } else {\r\n            // transfer tokens to receiver\r\n            TransferHelper.safeTransfer(\r\n                tokenOut,\r\n                params.receiver,\r\n                amountOutExpected - totalFee\r\n            );\r\n        }\r\n\r\n        emit Payment(\r\n            params.sender,\r\n            params.receiver,\r\n            tokenOut,\r\n            amountOutExpected,\r\n            totalFee,\r\n            params.memo\r\n        );\r\n\r\n        TransferHelper.safeApprove(tokenIn, address(uniswapRouter), 0);\r\n\r\n        // For exact output swaps, the amountInMaximum may not have all been spent.\r\n        // If the actual amount spent (amountIn) is less than the specified maximum amount, we must refund the msg.sender and approve the _uniswapRouter to spend 0.\r\n        if (amountSpent < params.amountIn && params.returnRemainder == true) {\r\n            uint256 remainder = params.amountIn - amountSpent;\r\n            if (msg.value != 0) {\r\n                // Unwrap wrapped native token and send to sender\r\n                IWETH9(wrappedNativeToken).withdraw(remainder);\r\n                (bool success, ) = params.sender.call{value: remainder}(\"\");\r\n                require(success, \"transfer failed\");\r\n            } else {\r\n                TransferHelper.safeTransfer(tokenIn, params.sender, remainder);\r\n            }\r\n        }\r\n\r\n        return amountSpent;\r\n    }\r\n\r\n    /// @notice Handles a payment with a swap through Curve\r\n    /// @dev This needs to have a valid Curve router or it will revert. Excess tokens from the swap as a result\r\n    /// of slippage are in terms of the token out.\r\n    /// @param params Struct that contains all the relevant parameters. See `YodlCurveParams` for more details.\r\n    /// @return The amount received in terms of token out by the Curve swap\r\n    function payWithCurve(\r\n        YodlCurveParams calldata params\r\n    ) external payable returns (uint256) {\r\n        require(address(curveRouter) != address(0), \"curve router not present\");\r\n        (address tokenOut, address tokenIn) = decodeTokenInTokenOutCurve(\r\n            params.route\r\n        );\r\n\r\n        // This is how much the recipient needs to receive\r\n        uint256 amountOutExpected;\r\n        if (\r\n            params.priceFeeds[0] != address(0) ||\r\n            params.priceFeeds[1] != address(0)\r\n        ) {\r\n            // Convert amountOut from invoice currency to swap currency using price feed\r\n            int256[2] memory prices;\r\n            address[2] memory priceFeeds;\r\n            (amountOutExpected, priceFeeds, prices) = exchangeRate(\r\n                params.priceFeeds,\r\n                params.amountOut\r\n            );\r\n            emit Convert(priceFeeds[0], prices[0]);\r\n            if (priceFeeds[1] != address(0)) {\r\n                emit Convert(priceFeeds[1], prices[1]);\r\n            }\r\n        } else {\r\n            amountOutExpected = params.amountOut;\r\n        }\r\n\r\n        // There should be no other situation in which we send a transaction with native token\r\n        if (msg.value != 0) {\r\n            // Wrap the native token\r\n            require(\r\n                msg.value >= params.amountIn,\r\n                \"insufficient ether provided\"\r\n            );\r\n            wrappedNativeToken.deposit{value: params.amountIn}();\r\n\r\n            // Update the tokenIn to wrapped native token\r\n            // wrapped native token has the same number of decimals as native token\r\n            // wrapped native token is already the first token in the route parameter\r\n            tokenIn = address(wrappedNativeToken);\r\n        } else {\r\n            // Transfer the ERC20 token from the sender to the YodlRouter\r\n            TransferHelper.safeTransferFrom(\r\n                tokenIn,\r\n                msg.sender,\r\n                address(this),\r\n                params.amountIn\r\n            );\r\n        }\r\n        TransferHelper.safeApprove(\r\n            tokenIn,\r\n            address(curveRouter),\r\n            params.amountIn\r\n        );\r\n\r\n        // Make the swap - the YodlRouter will receive the tokens\r\n        uint256 amountOut = curveRouter.exchange_multiple(\r\n            params.route,\r\n            params.swapParams,\r\n            params.amountIn,\r\n            amountOutExpected, // this will revert if we do not get at least this amount\r\n            params.factoryAddresses, // this is for zap contracts\r\n            address(this) // the Yodl router will receive the tokens\r\n        );\r\n\r\n        // Handle fees for the transaction - in terms out the token out\r\n        uint256 totalFee = 0;\r\n        if (params.memo != \"\") {\r\n            totalFee += calculateFee(amountOutExpected, baseFeeBps);\r\n        }\r\n\r\n        // Handle extra fees\r\n        if (params.extraFeeReceiver != address(0)) {\r\n            // 50% maximum extra fee\r\n            require(params.extraFeeBps < MAX_FEE_BPS, \"extraFee too high\");\r\n\r\n            totalFee += transferFee(\r\n                amountOutExpected,\r\n                params.extraFeeBps,\r\n                tokenOut,\r\n                address(this),\r\n                params.extraFeeReceiver\r\n            );\r\n        }\r\n\r\n        if (tokenOut == NATIVE_TOKEN) {\r\n            // Need to transfer native token to receiver\r\n            (bool success, ) = params.receiver.call{\r\n                value: amountOutExpected - totalFee\r\n            }(\"\");\r\n            require(success, \"transfer failed\");\r\n        } else {\r\n            // Transfer tokens to receiver\r\n            TransferHelper.safeTransfer(\r\n                tokenOut,\r\n                params.receiver,\r\n                amountOutExpected - totalFee\r\n            );\r\n        }\r\n        emit Payment(\r\n            params.sender,\r\n            params.receiver,\r\n            tokenOut,\r\n            amountOutExpected,\r\n            totalFee,\r\n            params.memo\r\n        );\r\n\r\n        uint256 remainder = amountOut - amountOutExpected;\r\n        if (remainder > 0 && params.returnRemainder) {\r\n            if (tokenOut == NATIVE_TOKEN) {\r\n                // Transfer remainder native token to sender\r\n                (bool success, ) = params.sender.call{value: remainder}(\"\");\r\n                require(success, \"transfer failed\");\r\n            } else {\r\n                // Return the additional token out amount to the sender\r\n                TransferHelper.safeTransfer(tokenOut, params.sender, remainder);\r\n            }\r\n        }\r\n\r\n        return amountOut;\r\n    }\r\n\r\n    /// @notice Transfers all fees or slippage collected by the router to the treasury address\r\n    /// @param token The address of the token we want to transfer from the router\r\n    function sweep(address token) external onlyOwner {\r\n        if (token == NATIVE_TOKEN) {\r\n            // transfer native token out of contract\r\n            (bool success, ) = feeTreasury.call{value: address(this).balance}(\r\n                \"\"\r\n            );\r\n            require(success, \"transfer failed in sweep\");\r\n        } else {\r\n            // transfer ERC20 contract\r\n            TransferHelper.safeTransfer(\r\n                token,\r\n                feeTreasury,\r\n                IERC20(token).balanceOf(address(this))\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates exchange rates from a given price feed\r\n     * @dev At most we can have 2 price feeds.\r\n     *\r\n     * We will use a zero address to determine if we need to inverse a singular price feeds.\r\n     *\r\n     * For multiple price feeds, we will always pass them in such that we multiply by the first and divide by the second.\r\n     * This works because all of our price feeds have USD as the quote currency.\r\n     * @param priceFeeds Array of Chainlink price feeds\r\n     * @param amount Amount to be converted by the price feed exchange rates\r\n     * @return converted The amount after conversion\r\n     * @return priceFeedsUsed The price feeds in the order they were used\r\n     * @return prices The exchange rates from the price feeds\r\n     */\r\n    function exchangeRate(\r\n        address[2] calldata priceFeeds,\r\n        uint256 amount\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint256 converted,\r\n            address[2] memory priceFeedsUsed,\r\n            int256[2] memory prices\r\n        )\r\n    {\r\n        require(\r\n            priceFeeds[0] != address(0) || priceFeeds[1] != address(0),\r\n            \"invalid pricefeeds\"\r\n        );\r\n\r\n        bool shouldInverse;\r\n        AggregatorV3Interface priceFeedOne;\r\n        AggregatorV3Interface priceFeedTwo; // might not exist\r\n        if (priceFeeds[0] == address(0)) {\r\n            // Inverse the price feed\r\n            shouldInverse = true;\r\n            priceFeedOne = AggregatorV3Interface(priceFeeds[1]);\r\n        } else {\r\n            // No need to inverse\r\n            priceFeedOne = AggregatorV3Interface(priceFeeds[0]);\r\n            if (priceFeeds[1] != address(0)) {\r\n                // Multiply by the first, divide by the second\r\n                // Will always be A -> USD -> B\r\n                priceFeedTwo = AggregatorV3Interface(priceFeeds[1]);\r\n            }\r\n        }\r\n\r\n        // Calculate the converted value using price feeds\r\n        uint256 decimals = uint256(10 ** uint256(priceFeedOne.decimals()));\r\n        (, int256 price, , , ) = priceFeedOne.latestRoundData();\r\n        prices[0] = price;\r\n        if (shouldInverse) {\r\n            converted = (amount * decimals) / uint256(price);\r\n        } else {\r\n            converted = (amount * uint256(price)) / decimals;\r\n        }\r\n\r\n        // We will always divide by the second price feed\r\n        if (address(priceFeedTwo) != address(0)) {\r\n            decimals = uint256(10 ** uint256(priceFeedTwo.decimals()));\r\n            (, price, , , ) = priceFeedTwo.latestRoundData();\r\n            prices[1] = price;\r\n            converted = (converted * decimals) / uint256(price);\r\n        }\r\n\r\n        return (\r\n            converted,\r\n            [address(priceFeedOne), address(priceFeedTwo)],\r\n            prices\r\n        );\r\n    }\r\n\r\n    /// @notice Helper function to calculate fees\r\n    /// @dev A basis point is 0.01% -> 1/10000 is one basis point\r\n    /// So multiplying by the amount of basis points then dividing by 10000\r\n    /// will give us the fee as a portion of the original amount, expressed in terms of basis points.\r\n    ///\r\n    /// Overflows are allowed to occur at ridiculously large amounts.\r\n    /// @param amount The amount to calculate the fee for\r\n    /// @param feeBps The size of the fee in terms of basis points\r\n    /// @return The fee\r\n    function calculateFee(\r\n        uint256 amount,\r\n        uint256 feeBps\r\n    ) public pure returns (uint256) {\r\n        return (amount * feeBps) / 10_000;\r\n    }\r\n\r\n    /// @notice Helper method to determine the token in and out from a Uniswap path\r\n    /// @param path The path for a Uniswap swap\r\n    /// @param swapType Enum for whether the swap is a single hop or multiple hop\r\n    /// @return The tokenOut and tokenIn\r\n    function decodeTokenInTokenOut(\r\n        bytes memory path,\r\n        SwapType swapType\r\n    ) internal pure returns (address, address) {\r\n        address tokenOut;\r\n        address tokenIn;\r\n        if (swapType == SwapType.SINGLE) {\r\n            (tokenOut, , tokenIn) = abi.decode(\r\n                path,\r\n                (address, uint24, address)\r\n            );\r\n        } else {\r\n            (tokenOut, , , , tokenIn) = abi.decode(\r\n                path,\r\n                (address, uint24, address, uint24, address)\r\n            );\r\n        }\r\n        return (tokenOut, tokenIn);\r\n    }\r\n\r\n    /// @notice Helper method to get the fee for a single hop swap for Uniswap\r\n    /// @param path The path for a Uniswap swap\r\n    /// @return The pool fee for given swap path\r\n    function decodeSinglePoolFee(\r\n        bytes memory path\r\n    ) internal pure returns (uint24) {\r\n        (, uint24 poolFee, ) = abi.decode(path, (address, uint24, address));\r\n        return poolFee;\r\n    }\r\n\r\n    /// @notice Helper method to determine the token in and out from a Curve route\r\n    /// @param route Route for a Curve swap in the form of [token, pool address, token...] with zero addresses once the\r\n    /// swap has completed\r\n    /// @return The tokenOut and tokenIn\r\n    function decodeTokenInTokenOutCurve(\r\n        address[9] memory route\r\n    ) internal pure returns (address, address) {\r\n        address tokenIn = route[0];\r\n        address tokenOut = route[2];\r\n        // Output tokens can be located at indices 2, 4, 6 or 8, if the loop finds nothing, then it is index 2\r\n        for (uint i = 4; i >= 2; i--) {\r\n            if (route[i * 2] != address(0)) {\r\n                tokenOut = route[i * 2];\r\n                break;\r\n            }\r\n        }\r\n        require(tokenOut != address(0), \"Invalid route parameter\");\r\n        return (tokenOut, tokenIn);\r\n    }\r\n\r\n    /// @notice Calculates and transfers fee directly from an address to another\r\n    /// @dev This can be used for directly transferring the Yodl fee from the sender to the treasury, or transferring\r\n    /// the extra fee to the extra fee receiver.\r\n    /// @param amount Amount from which to calculate the fee\r\n    /// @param feeBps The size of the fee in basis points\r\n    /// @param token The token which is being used to pay the fee. Can be an ERC20 token or the native token\r\n    /// @param from The address from which we are transferring the fee\r\n    /// @param to The address to which the fee will be sent\r\n    /// @return The fee sent\r\n    function transferFee(\r\n        uint256 amount,\r\n        uint256 feeBps,\r\n        address token,\r\n        address from,\r\n        address to\r\n    ) private returns (uint256) {\r\n        uint256 fee = calculateFee(amount, feeBps);\r\n        if (fee > 0) {\r\n            if (token != NATIVE_TOKEN) {\r\n                // ERC20 token\r\n                if (from == address(this)) {\r\n                    TransferHelper.safeTransfer(token, to, fee);\r\n                } else {\r\n                    // safeTransferFrom requires approval\r\n                    TransferHelper.safeTransferFrom(token, from, to, fee);\r\n                }\r\n            } else {\r\n                require(\r\n                    from == address(this),\r\n                    \"can only transfer eth from the router address\"\r\n                );\r\n\r\n                // Native ether\r\n                (bool success, ) = to.call{value: fee}(\"\");\r\n                require(success, \"transfer failed in transferFee\");\r\n            }\r\n            return fee;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTreasury\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_baseFeeBps\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_version\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wrappedNativeToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"exchangeRate\",\"type\":\"int256\"}],\"name\":\"Convert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"memo\",\"type\":\"bytes32\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_FEE_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NATIVE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseFeeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBps\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveRouter\",\"outputs\":[{\"internalType\":\"contract ICurveRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"priceFeeds\",\"type\":\"address[2]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"converted\",\"type\":\"uint256\"},{\"internalType\":\"address[2]\",\"name\":\"priceFeedsUsed\",\"type\":\"address[2]\"},{\"internalType\":\"int256[2]\",\"name\":\"prices\",\"type\":\"int256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"memo\",\"type\":\"bytes32\"},{\"internalType\":\"address[9]\",\"name\":\"route\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"swapParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"address[4]\",\"name\":\"factoryAddresses\",\"type\":\"address[4]\"},{\"internalType\":\"address[2]\",\"name\":\"priceFeeds\",\"type\":\"address[2]\"},{\"internalType\":\"address\",\"name\":\"extraFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"extraFeeBps\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"returnRemainder\",\"type\":\"bool\"}],\"internalType\":\"struct YodlRouterV1.YodlCurveParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"payWithCurve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"memo\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[2]\",\"name\":\"priceFeeds\",\"type\":\"address[2]\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"extraFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"extraFeeBps\",\"type\":\"uint256\"}],\"name\":\"payWithToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"memo\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address[2]\",\"name\":\"priceFeeds\",\"type\":\"address[2]\"},{\"internalType\":\"address\",\"name\":\"extraFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"extraFeeBps\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"returnRemainder\",\"type\":\"bool\"},{\"internalType\":\"enum YodlRouterV1.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"}],\"internalType\":\"struct YodlRouterV1.YodlUniswapParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"payWithUniswap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedNativeToken\",\"outputs\":[{\"internalType\":\"contract IWETH9\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "YodlRouterV1", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005f0947253a8218894af13438ac2e2e0ced30d234000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000e592427a0aece92de3edee1f18e0157c058615640000000000000000000000002a426b3bb4fa87488387545f15d01d81352732f90000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000000000000000000000000000000000000000000003302e320000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2bb95277c262b39de57c6b2e6f0cc9f50d3b4f1871c5638d83914af299f5333d"}