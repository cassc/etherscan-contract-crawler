{"SourceCode": "# @version 0.3.1\r\n\"\"\"\r\n@title Child Liquidity Gauge\r\n@license MIT\r\n@author Curve Finance\r\n\"\"\"\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\n\r\ninterface ERC20Extended:\r\n    def symbol() -> String[26]: view\r\n\r\ninterface Factory:\r\n    def owner() -> address: view\r\n    def voting_escrow() -> address: view\r\n\r\ninterface Minter:\r\n    def minted(_user: address, _gauge: address) -> uint256: view\r\n\r\ninterface ERC1271:\r\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes32: view\r\n\r\n\r\nevent Approval:\r\n    _owner: indexed(address)\r\n    _spender: indexed(address)\r\n    _value: uint256\r\n\r\nevent Transfer:\r\n    _from: indexed(address)\r\n    _to: indexed(address)\r\n    _value: uint256\r\n\r\nevent Deposit:\r\n    _user: indexed(address)\r\n    _value: uint256\r\n\r\nevent Withdraw:\r\n    _user: indexed(address)\r\n    _value: uint256\r\n\r\nevent UpdateLiquidityLimit:\r\n    _user: indexed(address)\r\n    _original_balance: uint256\r\n    _original_supply: uint256\r\n    _working_balance: uint256\r\n    _working_supply: uint256\r\n\r\n\r\nstruct Reward:\r\n    distributor: address\r\n    period_finish: uint256\r\n    rate: uint256\r\n    last_update: uint256\r\n    integral: uint256\r\n\r\n\r\nDOMAIN_TYPE_HASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\r\nPERMIT_TYPE_HASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\r\nERC1271_MAGIC_VAL: constant(bytes32) = 0x1626ba7e00000000000000000000000000000000000000000000000000000000\r\n\r\nMAX_REWARDS: constant(uint256) = 8\r\nTOKENLESS_PRODUCTION: constant(uint256) = 40\r\nWEEK: constant(uint256) = 86400 * 7\r\nVERSION: constant(String[8]) = \"v0.1.0\"\r\n\r\n\r\nCRV: immutable(address)\r\nFACTORY: immutable(address)\r\n\r\n\r\nDOMAIN_SEPARATOR: public(bytes32)\r\nnonces: public(HashMap[address, uint256])\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\n\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\nbalanceOf: public(HashMap[address, uint256])\r\ntotalSupply: public(uint256)\r\n\r\nlp_token: public(address)\r\nmanager: public(address)\r\n\r\nvoting_escrow: public(address)\r\nworking_balances: public(HashMap[address, uint256])\r\nworking_supply: public(uint256)\r\n\r\nperiod: public(uint256)\r\nperiod_timestamp: public(HashMap[uint256, uint256])\r\n\r\nintegrate_checkpoint_of: public(HashMap[address, uint256])\r\nintegrate_fraction: public(HashMap[address, uint256])\r\nintegrate_inv_supply: public(HashMap[uint256, uint256])\r\nintegrate_inv_supply_of: public(HashMap[address, uint256])\r\n\r\n# For tracking external rewards\r\nreward_count: public(uint256)\r\nreward_tokens: public(address[MAX_REWARDS])\r\nreward_data: public(HashMap[address, Reward])\r\n# claimant -> default reward receiver\r\nrewards_receiver: public(HashMap[address, address])\r\n# reward token -> claiming address -> integral\r\nreward_integral_for: public(HashMap[address, HashMap[address, uint256]])\r\n# user -> token -> [uint128 claimable amount][uint128 claimed amount]\r\nclaim_data: HashMap[address, HashMap[address, uint256]]\r\n\r\nis_killed: public(bool)\r\ninflation_rate: public(HashMap[uint256, uint256])\r\n\r\n\r\n@external\r\ndef __init__(_crv_token: address, _factory: address):\r\n    self.lp_token = 0x000000000000000000000000000000000000dEaD\r\n\r\n    CRV = _crv_token\r\n    FACTORY = _factory\r\n\r\n\r\n@internal\r\ndef _checkpoint(_user: address):\r\n    \"\"\"\r\n    @notice Checkpoint a user calculating their CRV entitlement\r\n    @param _user User address\r\n    \"\"\"\r\n    period: uint256 = self.period\r\n    period_time: uint256 = self.period_timestamp[period]\r\n    integrate_inv_supply: uint256 = self.integrate_inv_supply[period]\r\n\r\n    if block.timestamp > period_time:\r\n\r\n        working_supply: uint256 = self.working_supply\r\n        prev_week_time: uint256 = period_time\r\n        week_time: uint256 = min((period_time + WEEK) / WEEK * WEEK, block.timestamp)\r\n\r\n        for i in range(256):\r\n            dt: uint256 = week_time - prev_week_time\r\n\r\n            if working_supply != 0:\r\n                # we don't have to worry about crossing inflation epochs\r\n                # and if we miss any weeks, those weeks inflation rates will be 0 for sure\r\n                # but that means no one interacted with the gauge for that long\r\n                integrate_inv_supply += self.inflation_rate[prev_week_time / WEEK] * 10 ** 18 * dt / working_supply\r\n\r\n            if week_time == block.timestamp:\r\n                break\r\n            prev_week_time = week_time\r\n            week_time = min(week_time + WEEK, block.timestamp)\r\n\r\n    # check CRV balance and increase weekly inflation rate by delta for the rest of the week\r\n    crv_balance: uint256 = ERC20(CRV).balanceOf(self)\r\n    if crv_balance != 0:\r\n        current_week: uint256 = block.timestamp / WEEK\r\n        self.inflation_rate[current_week] += crv_balance / ((current_week + 1) * WEEK - block.timestamp)\r\n        ERC20(CRV).transfer(FACTORY, crv_balance)\r\n\r\n    period += 1\r\n    self.period = period\r\n    self.period_timestamp[period] = block.timestamp\r\n    self.integrate_inv_supply[period] = integrate_inv_supply\r\n\r\n    working_balance: uint256 = self.working_balances[_user]\r\n    self.integrate_fraction[_user] += working_balance * (integrate_inv_supply - self.integrate_inv_supply_of[_user]) / 10 ** 18\r\n    self.integrate_inv_supply_of[_user] = integrate_inv_supply\r\n    self.integrate_checkpoint_of[_user] = block.timestamp\r\n\r\n\r\n@internal\r\ndef _update_liquidity_limit(_user: address, _user_balance: uint256, _total_supply: uint256):\r\n    \"\"\"\r\n    @notice Calculate working balances to apply amplification of CRV production.\r\n    @dev https://resources.curve.fi/guides/boosting-your-crv-rewards#formula\r\n    @param _user The user address\r\n    @param _user_balance User's amount of liquidity (LP tokens)\r\n    @param _total_supply Total amount of liquidity (LP tokens)\r\n    \"\"\"\r\n    working_balance: uint256 = _user_balance * TOKENLESS_PRODUCTION / 100\r\n\r\n    ve: address = self.voting_escrow\r\n    if ve != ZERO_ADDRESS:\r\n        ve_ts: uint256 = ERC20(ve).totalSupply()\r\n        if ve_ts != 0:\r\n            working_balance += _total_supply * ERC20(ve).balanceOf(_user) / ve_ts * (100 - TOKENLESS_PRODUCTION) / 100\r\n            working_balance = min(_user_balance, working_balance)\r\n\r\n    old_working_balance: uint256 = self.working_balances[_user]\r\n    self.working_balances[_user] = working_balance\r\n\r\n    working_supply: uint256 = self.working_supply + working_balance - old_working_balance\r\n    self.working_supply = working_supply\r\n\r\n    log UpdateLiquidityLimit(_user, _user_balance, _total_supply, working_balance, working_supply)\r\n\r\n\r\n@internal\r\ndef _checkpoint_rewards(_user: address, _total_supply: uint256, _claim: bool, _receiver: address):\r\n    \"\"\"\r\n    @notice Claim pending rewards and checkpoint rewards for a user\r\n    \"\"\"\r\n    user_balance: uint256 = 0\r\n    receiver: address = _receiver\r\n    if _user != ZERO_ADDRESS:\r\n        user_balance = self.balanceOf[_user]\r\n        if _claim and _receiver == ZERO_ADDRESS:\r\n            # if receiver is not explicitly declared, check if a default receiver is set\r\n            receiver = self.rewards_receiver[_user]\r\n            if receiver == ZERO_ADDRESS:\r\n                # if no default receiver is set, direct claims to the user\r\n                receiver = _user\r\n\r\n    reward_count: uint256 = self.reward_count\r\n    for i in range(MAX_REWARDS):\r\n        if i == reward_count:\r\n            break\r\n        token: address = self.reward_tokens[i]\r\n\r\n        integral: uint256 = self.reward_data[token].integral\r\n        last_update: uint256 = min(block.timestamp, self.reward_data[token].period_finish)\r\n        duration: uint256 = last_update - self.reward_data[token].last_update\r\n        if duration != 0:\r\n            self.reward_data[token].last_update = last_update\r\n            if _total_supply != 0:\r\n                integral += duration * self.reward_data[token].rate * 10**18 / _total_supply\r\n                self.reward_data[token].integral = integral\r\n\r\n        if _user != ZERO_ADDRESS:\r\n            integral_for: uint256 = self.reward_integral_for[token][_user]\r\n            new_claimable: uint256 = 0\r\n\r\n            if integral_for < integral:\r\n                self.reward_integral_for[token][_user] = integral\r\n                new_claimable = user_balance * (integral - integral_for) / 10**18\r\n\r\n            claim_data: uint256 = self.claim_data[_user][token]\r\n            total_claimable: uint256 = shift(claim_data, -128) + new_claimable\r\n            if total_claimable > 0:\r\n                total_claimed: uint256 = claim_data % 2**128\r\n                if _claim:\r\n                    response: Bytes[32] = raw_call(\r\n                        token,\r\n                        _abi_encode(\r\n                            receiver,\r\n                            total_claimable,\r\n                            method_id=method_id(\"transfer(address,uint256)\")\r\n                        ),\r\n                        max_outsize=32,\r\n                    )\r\n                    if len(response) != 0:\r\n                        assert convert(response, bool)\r\n                    self.claim_data[_user][token] = total_claimed + total_claimable\r\n                elif new_claimable > 0:\r\n                    self.claim_data[_user][token] = total_claimed + shift(total_claimable, 128)\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256):\r\n    if _value == 0:\r\n        return\r\n    total_supply: uint256 = self.totalSupply\r\n\r\n    has_rewards: bool = self.reward_count != 0\r\n    for addr in [_from, _to]:\r\n        self._checkpoint(addr)\r\n        self._checkpoint_rewards(addr, total_supply, False, ZERO_ADDRESS)\r\n\r\n    new_balance: uint256 = self.balanceOf[_from] - _value\r\n    self.balanceOf[_from] = new_balance\r\n    self._update_liquidity_limit(_from, new_balance, total_supply)\r\n\r\n    new_balance = self.balanceOf[_to] + _value\r\n    self.balanceOf[_to] = new_balance\r\n    self._update_liquidity_limit(_to, new_balance, total_supply)\r\n\r\n    log Transfer(_from, _to, _value)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef deposit(_value: uint256, _user: address = msg.sender, _claim_rewards: bool = False):\r\n    \"\"\"\r\n    @notice Deposit `_value` LP tokens\r\n    @param _value Number of tokens to deposit\r\n    @param _user The account to send gauge tokens to\r\n    \"\"\"\r\n    self._checkpoint(_user)\r\n    if _value == 0:\r\n        return\r\n\r\n    total_supply: uint256 = self.totalSupply\r\n    new_balance: uint256 = self.balanceOf[_user] + _value\r\n\r\n    if self.reward_count != 0:\r\n        self._checkpoint_rewards(_user, total_supply, _claim_rewards, ZERO_ADDRESS)\r\n\r\n    total_supply += _value\r\n\r\n    self.balanceOf[_user] = new_balance\r\n    self.totalSupply = total_supply\r\n\r\n    self._update_liquidity_limit(_user, new_balance, total_supply)\r\n\r\n    ERC20(self.lp_token).transferFrom(msg.sender, self, _value)\r\n\r\n    log Deposit(_user, _value)\r\n    log Transfer(ZERO_ADDRESS, _user, _value)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef withdraw(_value: uint256, _user: address = msg.sender, _claim_rewards: bool = False):\r\n    \"\"\"\r\n    @notice Withdraw `_value` LP tokens\r\n    @param _value Number of tokens to withdraw\r\n    @param _user The account to send LP tokens to\r\n    \"\"\"\r\n    self._checkpoint(_user)\r\n    if _value == 0:\r\n        return\r\n\r\n    total_supply: uint256 = self.totalSupply\r\n    new_balance: uint256 = self.balanceOf[msg.sender] - _value\r\n\r\n    if self.reward_count != 0:\r\n        self._checkpoint_rewards(_user, total_supply, _claim_rewards, ZERO_ADDRESS)\r\n\r\n    total_supply -= _value\r\n\r\n    self.balanceOf[msg.sender] = new_balance\r\n    self.totalSupply = total_supply\r\n\r\n    self._update_liquidity_limit(msg.sender, new_balance, total_supply)\r\n\r\n    ERC20(self.lp_token).transfer(_user, _value)\r\n\r\n    log Withdraw(_user, _value)\r\n    log Transfer(msg.sender, ZERO_ADDRESS, _value)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef transferFrom(_from: address, _to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer tokens from one address to another\r\n    @param _from The address which you want to send tokens from\r\n    @param _to The address which you want to transfer to\r\n    @param _value the amount of tokens to be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    allowance: uint256 = self.allowance[_from][msg.sender]\r\n    if allowance != MAX_UINT256:\r\n        self.allowance[_from][msg.sender] = allowance - _value\r\n\r\n    self._transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Approve the passed address to transfer the specified amount of\r\n            tokens on behalf of msg.sender\r\n    @dev Beware that changing an allowance via this method brings the risk\r\n         that someone may use both the old and new allowance by unfortunate\r\n         transaction ordering. This may be mitigated with the use of\r\n         {increaseAllowance} and {decreaseAllowance}.\r\n         https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will transfer the funds\r\n    @param _value The amount of tokens that may be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    self.allowance[msg.sender][_spender] = _value\r\n\r\n    log Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef permit(\r\n    _owner: address,\r\n    _spender: address,\r\n    _value: uint256,\r\n    _deadline: uint256,\r\n    _v: uint8,\r\n    _r: bytes32,\r\n    _s: bytes32\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Approves spender by owner's signature to expend owner's tokens.\r\n        See https://eips.ethereum.org/EIPS/eip-2612.\r\n    @dev Inspired by https://github.com/yearn/yearn-vaults/blob/main/contracts/Vault.vy#L753-L793\r\n    @dev Supports smart contract wallets which implement ERC1271\r\n        https://eips.ethereum.org/EIPS/eip-1271\r\n    @param _owner The address which is a source of funds and has signed the Permit.\r\n    @param _spender The address which is allowed to spend the funds.\r\n    @param _value The amount of tokens to be spent.\r\n    @param _deadline The timestamp after which the Permit is no longer valid.\r\n    @param _v The bytes[64] of the valid secp256k1 signature of permit by owner\r\n    @param _r The bytes[0:32] of the valid secp256k1 signature of permit by owner\r\n    @param _s The bytes[32:64] of the valid secp256k1 signature of permit by owner\r\n    @return True, if transaction completes successfully\r\n    \"\"\"\r\n    assert _owner != ZERO_ADDRESS\r\n    assert block.timestamp <= _deadline\r\n\r\n    nonce: uint256 = self.nonces[_owner]\r\n    digest: bytes32 = keccak256(\r\n        concat(\r\n            b\"\\x19\\x01\",\r\n            self.DOMAIN_SEPARATOR,\r\n            keccak256(_abi_encode(PERMIT_TYPE_HASH, _owner, _spender, _value, nonce, _deadline))\r\n        )\r\n    )\r\n\r\n    if _owner.is_contract:\r\n        sig: Bytes[65] = concat(_abi_encode(_r, _s), slice(convert(_v, bytes32), 31, 1))\r\n        assert ERC1271(_owner).isValidSignature(digest, sig) == ERC1271_MAGIC_VAL\r\n    else:\r\n        assert ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256)) == _owner\r\n\r\n    self.allowance[_owner][_spender] = _value\r\n    self.nonces[_owner] = nonce + 1\r\n\r\n    log Approval(_owner, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef transfer(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer token to a specified address\r\n    @param _to The address to transfer to\r\n    @param _value The amount to be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    self._transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef increaseAllowance(_spender: address, _added_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Increase the allowance granted to `_spender` by the caller\r\n    @dev This is alternative to {approve} that can be used as a mitigation for\r\n         the potential race condition\r\n    @param _spender The address which will transfer the funds\r\n    @param _added_value The amount of to increase the allowance\r\n    @return bool success\r\n    \"\"\"\r\n    allowance: uint256 = self.allowance[msg.sender][_spender] + _added_value\r\n    self.allowance[msg.sender][_spender] = allowance\r\n\r\n    log Approval(msg.sender, _spender, allowance)\r\n    return True\r\n\r\n\r\n@external\r\ndef decreaseAllowance(_spender: address, _subtracted_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Decrease the allowance granted to `_spender` by the caller\r\n    @dev This is alternative to {approve} that can be used as a mitigation for\r\n         the potential race condition\r\n    @param _spender The address which will transfer the funds\r\n    @param _subtracted_value The amount of to decrease the allowance\r\n    @return bool success\r\n    \"\"\"\r\n    allowance: uint256 = self.allowance[msg.sender][_spender] - _subtracted_value\r\n    self.allowance[msg.sender][_spender] = allowance\r\n\r\n    log Approval(msg.sender, _spender, allowance)\r\n    return True\r\n\r\n\r\n@external\r\ndef user_checkpoint(addr: address) -> bool:\r\n    \"\"\"\r\n    @notice Record a checkpoint for `addr`\r\n    @param addr User address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender in [addr, FACTORY]  # dev: unauthorized\r\n    self._checkpoint(addr)\r\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\r\n    return True\r\n\r\n\r\n@external\r\ndef claimable_tokens(addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of claimable tokens per user\r\n    @dev This function should be manually changed to \"view\" in the ABI\r\n    @return uint256 number of claimable tokens per user\r\n    \"\"\"\r\n    self._checkpoint(addr)\r\n    return self.integrate_fraction[addr] - Minter(FACTORY).minted(addr, self)\r\n\r\n\r\n@view\r\n@external\r\ndef claimed_reward(_addr: address, _token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of already-claimed reward tokens for a user\r\n    @param _addr Account to get reward amount for\r\n    @param _token Token to get reward amount for\r\n    @return uint256 Total amount of `_token` already claimed by `_addr`\r\n    \"\"\"\r\n    return self.claim_data[_addr][_token] % 2**128\r\n\r\n\r\n@view\r\n@external\r\ndef claimable_reward(_user: address, _reward_token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of claimable reward tokens for a user\r\n    @param _user Account to get reward amount for\r\n    @param _reward_token Token to get reward amount for\r\n    @return uint256 Claimable reward token amount\r\n    \"\"\"\r\n    integral: uint256 = self.reward_data[_reward_token].integral\r\n    total_supply: uint256 = self.totalSupply\r\n    if total_supply != 0:\r\n        last_update: uint256 = min(block.timestamp, self.reward_data[_reward_token].period_finish)\r\n        duration: uint256 = last_update - self.reward_data[_reward_token].last_update\r\n        integral += (duration * self.reward_data[_reward_token].rate * 10**18 / total_supply)\r\n\r\n    integral_for: uint256 = self.reward_integral_for[_reward_token][_user]\r\n    new_claimable: uint256 = self.balanceOf[_user] * (integral - integral_for) / 10**18\r\n\r\n    return shift(self.claim_data[_user][_reward_token], -128) + new_claimable\r\n\r\n\r\n@external\r\ndef set_rewards_receiver(_receiver: address):\r\n    \"\"\"\r\n    @notice Set the default reward receiver for the caller.\r\n    @dev When set to ZERO_ADDRESS, rewards are sent to the caller\r\n    @param _receiver Receiver address for any rewards claimed via `claim_rewards`\r\n    \"\"\"\r\n    self.rewards_receiver[msg.sender] = _receiver\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):\r\n    \"\"\"\r\n    @notice Claim available reward tokens for `_addr`\r\n    @param _addr Address to claim for\r\n    @param _receiver Address to transfer rewards to - if set to\r\n                     ZERO_ADDRESS, uses the default reward receiver\r\n                     for the caller\r\n    \"\"\"\r\n    if _receiver != ZERO_ADDRESS:\r\n        assert _addr == msg.sender  # dev: cannot redirect when claiming for another user\r\n    self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver)\r\n\r\n\r\n@external\r\ndef add_reward(_reward_token: address, _distributor: address):\r\n    \"\"\"\r\n    @notice Set the active reward contract\r\n    \"\"\"\r\n    assert msg.sender == self.manager or msg.sender == Factory(FACTORY).owner()\r\n\r\n    reward_count: uint256 = self.reward_count\r\n    assert reward_count < MAX_REWARDS\r\n    assert self.reward_data[_reward_token].distributor == ZERO_ADDRESS\r\n\r\n    self.reward_data[_reward_token].distributor = _distributor\r\n    self.reward_tokens[reward_count] = _reward_token\r\n    self.reward_count = reward_count + 1\r\n\r\n\r\n@external\r\ndef set_reward_distributor(_reward_token: address, _distributor: address):\r\n    current_distributor: address = self.reward_data[_reward_token].distributor\r\n\r\n    assert msg.sender == current_distributor or msg.sender == self.manager or msg.sender == Factory(FACTORY).owner()\r\n    assert current_distributor != ZERO_ADDRESS\r\n    assert _distributor != ZERO_ADDRESS\r\n\r\n    self.reward_data[_reward_token].distributor = _distributor\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef deposit_reward_token(_reward_token: address, _amount: uint256):\r\n    assert msg.sender == self.reward_data[_reward_token].distributor\r\n\r\n    self._checkpoint_rewards(ZERO_ADDRESS, self.totalSupply, False, ZERO_ADDRESS)\r\n\r\n    response: Bytes[32] = raw_call(\r\n        _reward_token,\r\n        _abi_encode(\r\n            msg.sender,\r\n            self,\r\n            _amount,\r\n            method_id=method_id(\"transferFrom(address,address,uint256)\")\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    period_finish: uint256 = self.reward_data[_reward_token].period_finish\r\n    if block.timestamp >= period_finish:\r\n        self.reward_data[_reward_token].rate = _amount / WEEK\r\n    else:\r\n        remaining: uint256 = period_finish - block.timestamp\r\n        leftover: uint256 = remaining * self.reward_data[_reward_token].rate\r\n        self.reward_data[_reward_token].rate = (_amount + leftover) / WEEK\r\n\r\n    self.reward_data[_reward_token].last_update = block.timestamp\r\n    self.reward_data[_reward_token].period_finish = block.timestamp + WEEK\r\n\r\n\r\n@external\r\ndef set_manager(_manager: address):\r\n    assert msg.sender == Factory(FACTORY).owner()\r\n\r\n    self.manager = _manager\r\n\r\n\r\n@external\r\ndef update_voting_escrow():\r\n    \"\"\"\r\n    @notice Update the voting escrow contract in storage\r\n    \"\"\"\r\n    self.voting_escrow = Factory(FACTORY).voting_escrow()\r\n\r\n\r\n@external\r\ndef set_killed(_is_killed: bool):\r\n    \"\"\"\r\n    @notice Set the kill status of the gauge\r\n    @param _is_killed Kill status to put the gauge into\r\n    \"\"\"\r\n    assert msg.sender == Factory(FACTORY).owner()\r\n\r\n    self.is_killed = _is_killed\r\n\r\n\r\n@view\r\n@external\r\ndef decimals() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the number of decimals the token uses\r\n    \"\"\"\r\n    return 18\r\n\r\n\r\n@view\r\n@external\r\ndef integrate_checkpoint() -> uint256:\r\n    return self.period_timestamp[self.period]\r\n\r\n\r\n@view\r\n@external\r\ndef version() -> String[8]:\r\n    return VERSION\r\n\r\n\r\n@view\r\n@external\r\ndef factory() -> address:\r\n    return FACTORY\r\n\r\n\r\n@external\r\ndef initialize(_lp_token: address, _manager: address):\r\n    assert self.lp_token == ZERO_ADDRESS  # dev: already initialzed\r\n\r\n    self.lp_token = _lp_token\r\n    self.manager = _manager\r\n\r\n    self.voting_escrow = Factory(msg.sender).voting_escrow()\r\n\r\n    symbol: String[26] = ERC20Extended(_lp_token).symbol()\r\n    name: String[64] = concat(\"Curve.fi \", symbol, \" Gauge Deposit\")\r\n\r\n    self.name = name\r\n    self.symbol = concat(symbol, \"-gauge\")\r\n\r\n    self.period_timestamp[0] = block.timestamp\r\n    self.DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(\r\n            DOMAIN_TYPE_HASH,\r\n            keccak256(name),\r\n            keccak256(VERSION),\r\n            chain.id,\r\n            self\r\n        )\r\n    )", "ABI": "[{\"name\":\"Approval\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateLiquidityLimit\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_original_balance\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_original_supply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_working_balance\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_working_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_crv_token\",\"type\":\"address\"},{\"name\":\"_factory\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_claim_rewards\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_claim_rewards\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_added_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtracted_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"user_checkpoint\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claimable_tokens\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claimed_reward\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claimable_reward\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_reward_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_rewards_receiver\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_rewards\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_rewards\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_rewards\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_reward\",\"inputs\":[{\"name\":\"_reward_token\",\"type\":\"address\"},{\"name\":\"_distributor\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_reward_distributor\",\"inputs\":[{\"name\":\"_reward_token\",\"type\":\"address\"},{\"name\":\"_distributor\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit_reward_token\",\"inputs\":[{\"name\":\"_reward_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_manager\",\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_voting_escrow\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_killed\",\"inputs\":[{\"name\":\"_is_killed\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_checkpoint\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_manager\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lp_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"manager\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"voting_escrow\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"working_balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"working_supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period_timestamp\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_checkpoint_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_fraction\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_inv_supply\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_inv_supply_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_tokens\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_data\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"distributor\",\"type\":\"address\"},{\"name\":\"period_finish\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"last_update\",\"type\":\"uint256\"},{\"name\":\"integral\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewards_receiver\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_integral_for\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"inflation_rate\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.1", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000172370d5cd63279efa6d502dab29171933a610af000000000000000000000000abc000d88f23bb45525e447528dbf656a9d55bf5", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}