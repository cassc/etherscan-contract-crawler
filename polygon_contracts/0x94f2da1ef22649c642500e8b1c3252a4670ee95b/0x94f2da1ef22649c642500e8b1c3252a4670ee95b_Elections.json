{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Elections.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./spec_interfaces/IElections.sol\\\";\\nimport \\\"./spec_interfaces/IDelegations.sol\\\";\\nimport \\\"./spec_interfaces/IGuardiansRegistration.sol\\\";\\nimport \\\"./spec_interfaces/ICommittee.sol\\\";\\nimport \\\"./spec_interfaces/ICertification.sol\\\";\\nimport \\\"./ManagedContract.sol\\\";\\n\\n/// @title Elections contract\\ncontract Elections is IElections, ManagedContract {\\n\\tusing SafeMath for uint256;\\n\\n\\tuint32 constant PERCENT_MILLIE_BASE = 100000;\\n\\n\\tmapping(address => mapping(address => uint256)) voteUnreadyVotes; // by => to => expiration\\n\\tmapping(address => uint256) public votersStake;\\n\\tmapping(address => address) voteOutVotes; // by => to\\n\\tmapping(address => uint256) accumulatedStakesForVoteOut; // addr => total stake\\n\\tmapping(address => bool) votedOutGuardians;\\n\\n\\tstruct Settings {\\n\\t\\tuint32 minSelfStakePercentMille;\\n\\t\\tuint32 voteUnreadyPercentMilleThreshold;\\n\\t\\tuint32 voteOutPercentMilleThreshold;\\n\\t}\\n\\tSettings settings;\\n\\n    /// Constructor\\n    /// @param _contractRegistry is the contract registry address\\n    /// @param _registryAdmin is the registry admin address\\n    /// @param minSelfStakePercentMille is the minimum self stake in percent-mille (0-100,000) \\n    /// @param voteUnreadyPercentMilleThreshold is the minimum vote-unready threshold in percent-mille (0-100,000)\\n    /// @param voteOutPercentMilleThreshold is the minimum vote-out threshold in percent-mille (0-100,000)\\n\\tconstructor(IContractRegistry _contractRegistry, address _registryAdmin, uint32 minSelfStakePercentMille, uint32 voteUnreadyPercentMilleThreshold, uint32 voteOutPercentMilleThreshold) ManagedContract(_contractRegistry, _registryAdmin) public {\\n\\t\\tsetMinSelfStakePercentMille(minSelfStakePercentMille);\\n\\t\\tsetVoteOutPercentMilleThreshold(voteOutPercentMilleThreshold);\\n\\t\\tsetVoteUnreadyPercentMilleThreshold(voteUnreadyPercentMilleThreshold);\\n\\t}\\n\\n\\tmodifier onlyDelegationsContract() {\\n\\t\\trequire(msg.sender == address(delegationsContract), \\\"caller is not the delegations contract\\\");\\n\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyGuardiansRegistrationContract() {\\n\\t\\trequire(msg.sender == address(guardianRegistrationContract), \\\"caller is not the guardian registrations contract\\\");\\n\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier onlyCertificationContract() {\\n\\t\\trequire(msg.sender == address(certificationContract), \\\"caller is not the certification contract\\\");\\n\\n\\t\\t_;\\n\\t}\\n\\n\\t/*\\n\\t * External functions\\n\\t */\\n\\n    /// Notifies that the guardian is ready to sync with other nodes\\n    /// @dev ready to sync state is not managed in the contract that only emits an event\\n    /// @dev readyToSync clears the readyForCommittee state\\n\\tfunction readyToSync() external override onlyWhenActive {\\n\\t\\taddress guardian = guardianRegistrationContract.resolveGuardianAddress(msg.sender); // this validates registration\\n\\t\\trequire(!isVotedOut(guardian), \\\"caller is voted-out\\\");\\n\\n\\t\\temit GuardianStatusUpdated(guardian, true, false);\\n\\n\\t\\tcommitteeContract.removeMember(guardian);\\n\\t}\\n\\n    /// Notifies that the guardian is ready to join the committee\\n    /// @dev a qualified guardian calling readyForCommittee is added to the committee\\n\\tfunction readyForCommittee() external override onlyWhenActive {\\n\\t\\t_readyForCommittee(msg.sender);\\n\\t}\\n\\n    /// Checks if a guardian is qualified to join the committee\\n    /// @dev when true, calling readyForCommittee() will result in adding the guardian to the committee\\n    /// @dev called periodically by guardians to check if they are qualified to join the committee\\n    /// @param guardian is the guardian to check\\n    /// @return canJoin indicating that the guardian can join the current committee\\n\\tfunction canJoinCommittee(address guardian) external view override returns (bool) {\\n\\t\\tguardian = guardianRegistrationContract.resolveGuardianAddress(guardian); // this validates registration\\n\\n\\t\\tif (isVotedOut(guardian)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tuint256 effectiveStake = getGuardianEffectiveStake(guardian, settings);\\n\\t\\treturn committeeContract.checkAddMember(guardian, effectiveStake);\\n\\t}\\n\\n    /// Returns an address effective stake\\n    /// The effective stake is derived from a guardian delegate stake and selfs stake  \\n    /// @return effectiveStake is the guardian's effective stake\\n\\tfunction getEffectiveStake(address guardian) external override view returns (uint effectiveStake) {\\n\\t\\treturn getGuardianEffectiveStake(guardian, settings);\\n\\t}\\n\\n    /// Returns the current committee along with the guardians' Orbs address and IP\\n    /// @return committee is a list of the committee members' guardian addresses\\n    /// @return weights is a list of the committee members' weight (effective stake)\\n    /// @return orbsAddrs is a list of the committee members' orbs address\\n    /// @return certification is a list of bool indicating the committee members certification\\n    /// @return ips is a list of the committee members' ip\\n\\tfunction getCommittee() external override view returns (address[] memory committee, uint256[] memory weights, address[] memory orbsAddrs, bool[] memory certification, bytes4[] memory ips) {\\n\\t\\tIGuardiansRegistration _guardianRegistrationContract = guardianRegistrationContract;\\n\\t\\t(committee, weights, certification) = committeeContract.getCommittee();\\n\\t\\torbsAddrs = _guardianRegistrationContract.getGuardiansOrbsAddress(committee);\\n\\t\\tips = _guardianRegistrationContract.getGuardianIps(committee);\\n\\t}\\n\\n\\t// Vote-unready\\n\\n    /// Casts an unready vote on a subject guardian\\n    /// @dev Called by a guardian as part of the automatic vote-unready flow\\n    /// @dev The transaction may be sent from the guardian or orbs address.\\n    /// @param subject is the subject guardian to vote out\\n    /// @param voteExpiration is the expiration time of the vote unready to prevent counting of a vote that is already irrelevant.\\n\\tfunction voteUnready(address subject, uint voteExpiration) external override onlyWhenActive {\\n\\t\\trequire(voteExpiration >= block.timestamp, \\\"vote expiration time must not be in the past\\\");\\n\\n\\t\\taddress voter = guardianRegistrationContract.resolveGuardianAddress(msg.sender);\\n\\t\\tvoteUnreadyVotes[voter][subject] = voteExpiration;\\n\\t\\temit VoteUnreadyCasted(voter, subject, voteExpiration);\\n\\n\\t\\t(address[] memory generalCommittee, uint256[] memory generalWeights, bool[] memory certification) = committeeContract.getCommittee();\\n\\n\\t\\tbool votedUnready = isCommitteeVoteUnreadyThresholdReached(generalCommittee, generalWeights, certification, subject);\\n\\t\\tif (votedUnready) {\\n\\t\\t\\tclearCommitteeUnreadyVotes(generalCommittee, subject);\\n\\t\\t\\temit GuardianVotedUnready(subject);\\n\\n\\t\\t\\temit GuardianStatusUpdated(subject, false, false);\\n\\t\\t\\tcommitteeContract.removeMember(subject);\\n\\t\\t}\\n\\t}\\n\\n    /// Returns the current vote unready vote for a voter and a subject pair\\n    /// @param voter is the voting guardian address\\n    /// @param subject is the subject guardian address\\n    /// @return valid indicates whether there is a valid vote\\n    /// @return expiration returns the votes expiration time\\n\\tfunction getVoteUnreadyVote(address voter, address subject) public override view returns (bool valid, uint256 expiration) {\\n\\t\\texpiration = voteUnreadyVotes[voter][subject];\\n\\t\\tvalid = expiration != 0 && block.timestamp < expiration;\\n\\t}\\n\\n    /// Returns the current vote-unready status of a subject guardian.\\n    /// @dev the committee and certification data is used to check the certified and committee threshold\\n    /// @param subject is the subject guardian address\\n    /// @return committee is a list of the current committee members\\n    /// @return weights is a list of the current committee members weight\\n    /// @return certification is a list of bool indicating the committee members certification\\n    /// @return votes is a list of bool indicating the members that votes the subject unready\\n    /// @return subjectInCommittee indicates that the subject is in the committee\\n    /// @return subjectInCertifiedCommittee indicates that the subject is in the certified committee\\n\\tfunction getVoteUnreadyStatus(address subject) external override view returns (address[] memory committee, uint256[] memory weights, bool[] memory certification, bool[] memory votes, bool subjectInCommittee, bool subjectInCertifiedCommittee) {\\n\\t\\t(committee, weights, certification) = committeeContract.getCommittee();\\n\\n\\t\\tvotes = new bool[](committee.length);\\n\\t\\tfor (uint i = 0; i < committee.length; i++) {\\n\\t\\t\\taddress memberAddr = committee[i];\\n\\t\\t\\tif (block.timestamp < voteUnreadyVotes[memberAddr][subject]) {\\n\\t\\t\\t\\tvotes[i] = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (memberAddr == subject) {\\n\\t\\t\\t\\tsubjectInCommittee = true;\\n\\t\\t\\t\\tsubjectInCertifiedCommittee = certification[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Vote-out\\n\\n    /// Casts a voteOut vote by the sender to the given address\\n    /// @dev the transaction is sent from the guardian address\\n    /// @param subject is the subject guardian address\\n\\tfunction voteOut(address subject) external override onlyWhenActive {\\n\\t\\tSettings memory _settings = settings;\\n\\n\\t\\taddress voter = msg.sender;\\n\\t\\taddress prevSubject = voteOutVotes[voter];\\n\\n\\t\\tvoteOutVotes[voter] = subject;\\n\\t\\temit VoteOutCasted(voter, subject);\\n\\n\\t\\tuint256 voterStake = delegationsContract.getDelegatedStake(voter);\\n\\n\\t\\tif (prevSubject == address(0)) {\\n\\t\\t\\tvotersStake[voter] = voterStake;\\n\\t\\t}\\n\\n\\t\\tif (subject == address(0)) {\\n\\t\\t\\tdelete votersStake[voter];\\n\\t\\t}\\n\\n\\t\\tuint totalStake = delegationsContract.getTotalDelegatedStake();\\n\\n\\t\\tif (prevSubject != address(0) && prevSubject != subject) {\\n\\t\\t\\tapplyVoteOutVotesFor(prevSubject, 0, voterStake, totalStake, _settings);\\n\\t\\t}\\n\\n\\t\\tif (subject != address(0)) {\\n\\t\\t\\tuint voteStakeAdded = prevSubject != subject ? voterStake : 0;\\n\\t\\t\\tapplyVoteOutVotesFor(subject, voteStakeAdded, 0, totalStake, _settings); // recheck also if not new\\n\\t\\t}\\n\\t}\\n\\n    /// Returns the subject address the addr has voted-out against\\n    /// @param voter is the voting guardian address\\n    /// @return subject is the subject the voter has voted out\\n\\tfunction getVoteOutVote(address voter) external override view returns (address) {\\n\\t\\treturn voteOutVotes[voter];\\n\\t}\\n\\n    /// Returns the governance voteOut status of a guardian.\\n    /// @dev A guardian is voted out if votedStake / totalDelegatedStake (in percent mille) > threshold\\n    /// @param subject is the subject guardian address\\n    /// @return votedOut indicates whether the subject was voted out\\n    /// @return votedStake is the total stake voting against the subject\\n    /// @return totalDelegatedStake is the total delegated stake\\n\\tfunction getVoteOutStatus(address subject) external override view returns (bool votedOut, uint votedStake, uint totalDelegatedStake) {\\n\\t\\tvotedOut = isVotedOut(subject);\\n\\t\\tvotedStake = accumulatedStakesForVoteOut[subject];\\n\\t\\ttotalDelegatedStake = delegationsContract.getTotalDelegatedStake();\\n\\t}\\n\\n\\t/*\\n\\t * Notification functions from other PoS contracts\\n\\t */\\n\\n    /// Notifies a delegated stake change event\\n    /// @dev Called by: delegation contract\\n    /// @param delegate is the delegate to update\\n    /// @param selfDelegatedStake is the delegate self stake (0 if not self-delegating)\\n    /// @param delegatedStake is the delegate delegated stake (0 if not self-delegating)\\n    /// @param totalDelegatedStake is the total delegated stake\\n\\tfunction delegatedStakeChange(address delegate, uint256 selfDelegatedStake, uint256 delegatedStake, uint256 totalDelegatedStake) external override onlyDelegationsContract onlyWhenActive {\\n\\t\\tSettings memory _settings = settings;\\n\\n\\t\\tuint effectiveStake = calcEffectiveStake(selfDelegatedStake, delegatedStake, _settings);\\n\\t\\temit StakeChanged(delegate, selfDelegatedStake, delegatedStake, effectiveStake);\\n\\n\\t\\tcommitteeContract.memberWeightChange(delegate, effectiveStake);\\n\\n\\t\\tapplyStakesToVoteOutBy(delegate, delegatedStake, totalDelegatedStake, _settings);\\n\\t}\\n\\n    /// Notifies a new guardian was unregistered\\n    /// @dev Called by: guardian registration contract\\n    /// @dev when a guardian unregisters its status is updated to not ready to sync and is removed from the committee\\n    /// @param guardian is the address of the guardian that unregistered\\n\\tfunction guardianUnregistered(address guardian) external override onlyGuardiansRegistrationContract onlyWhenActive {\\n\\t\\temit GuardianStatusUpdated(guardian, false, false);\\n\\t\\tcommitteeContract.removeMember(guardian);\\n\\t}\\n\\n    /// Notifies on a guardian certification change\\n    /// @dev Called by: guardian registration contract\\n    /// @param guardian is the address of the guardian to update\\n    /// @param isCertified indicates whether the guardian is certified\\n\\tfunction guardianCertificationChanged(address guardian, bool isCertified) external override onlyCertificationContract onlyWhenActive {\\n\\t\\tcommitteeContract.memberCertificationChange(guardian, isCertified);\\n\\t}\\n\\n\\t/*\\n     * Governance functions\\n\\t */\\n\\n    /// Sets the minimum self stake requirement for the effective stake\\n    /// @dev governance function called only by the functional manager\\n    /// @param minSelfStakePercentMille is the minimum self stake in percent-mille (0-100,000) \\n\\tfunction setMinSelfStakePercentMille(uint32 minSelfStakePercentMille) public override onlyFunctionalManager {\\n\\t\\trequire(minSelfStakePercentMille <= PERCENT_MILLIE_BASE, \\\"minSelfStakePercentMille must be 100000 at most\\\");\\n\\t\\temit MinSelfStakePercentMilleChanged(minSelfStakePercentMille, settings.minSelfStakePercentMille);\\n\\t\\tsettings.minSelfStakePercentMille = minSelfStakePercentMille;\\n\\t}\\n\\n    /// Returns the minimum self-stake required for the effective stake\\n    /// @return minSelfStakePercentMille is the minimum self stake in percent-mille \\n\\tfunction getMinSelfStakePercentMille() external override view returns (uint32) {\\n\\t\\treturn settings.minSelfStakePercentMille;\\n\\t}\\n\\n    /// Sets the vote-out threshold\\n    /// @dev governance function called only by the functional manager\\n    /// @param voteOutPercentMilleThreshold is the minimum threshold in percent-mille (0-100,000)\\n\\tfunction setVoteOutPercentMilleThreshold(uint32 voteOutPercentMilleThreshold) public override onlyFunctionalManager {\\n\\t\\trequire(voteOutPercentMilleThreshold <= PERCENT_MILLIE_BASE, \\\"voteOutPercentMilleThreshold must not be larger than 100000\\\");\\n\\t\\temit VoteOutPercentMilleThresholdChanged(voteOutPercentMilleThreshold, settings.voteOutPercentMilleThreshold);\\n\\t\\tsettings.voteOutPercentMilleThreshold = voteOutPercentMilleThreshold;\\n\\t}\\n\\n    /// Returns the vote-out threshold\\n    /// @return voteOutPercentMilleThreshold is the minimum threshold in percent-mille\\n\\tfunction getVoteOutPercentMilleThreshold() external override view returns (uint32) {\\n\\t\\treturn settings.voteOutPercentMilleThreshold;\\n\\t}\\n\\n    /// Sets the vote-unready threshold\\n    /// @dev governance function called only by the functional manager\\n    /// @param voteUnreadyPercentMilleThreshold is the minimum threshold in percent-mille (0-100,000)\\n\\tfunction setVoteUnreadyPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) public override onlyFunctionalManager {\\n\\t\\trequire(voteUnreadyPercentMilleThreshold <= PERCENT_MILLIE_BASE, \\\"voteUnreadyPercentMilleThreshold must not be larger than 100000\\\");\\n\\t\\temit VoteUnreadyPercentMilleThresholdChanged(voteUnreadyPercentMilleThreshold, settings.voteUnreadyPercentMilleThreshold);\\n\\t\\tsettings.voteUnreadyPercentMilleThreshold = voteUnreadyPercentMilleThreshold;\\n\\t}\\n\\n    /// Returns the vote-unready threshold\\n    /// @return voteUnreadyPercentMilleThreshold is the minimum threshold in percent-mille\\n\\tfunction getVoteUnreadyPercentMilleThreshold() external override view returns (uint32) {\\n\\t\\treturn settings.voteUnreadyPercentMilleThreshold;\\n\\t}\\n\\n    /// Returns the contract's settings \\n    /// @return minSelfStakePercentMille is the minimum self stake in percent-mille\\n    /// @return voteUnreadyPercentMilleThreshold is the minimum threshold in percent-mille\\n    /// @return voteOutPercentMilleThreshold is the minimum threshold in percent-mille\\n\\tfunction getSettings() external override view returns (\\n\\t\\tuint32 minSelfStakePercentMille,\\n\\t\\tuint32 voteUnreadyPercentMilleThreshold,\\n\\t\\tuint32 voteOutPercentMilleThreshold\\n\\t) {\\n\\t\\tSettings memory _settings = settings;\\n\\t\\tminSelfStakePercentMille = _settings.minSelfStakePercentMille;\\n\\t\\tvoteUnreadyPercentMilleThreshold = _settings.voteUnreadyPercentMilleThreshold;\\n\\t\\tvoteOutPercentMilleThreshold = _settings.voteOutPercentMilleThreshold;\\n\\t}\\n\\n    /// Initializes the ready for committee notification for the committee guardians\\n    /// @dev governance function called only by the initialization admin during migration \\n    /// @dev identical behaviour as if each guardian sent readyForCommittee() \\n    /// @param guardians a list of guardians addresses to update\\n\\tfunction initReadyForCommittee(address[] calldata guardians) external override onlyInitializationAdmin {\\n\\t\\tfor (uint i = 0; i < guardians.length; i++) {\\n\\t\\t\\t_readyForCommittee(guardians[i]);\\n\\t\\t}\\n\\t}\\n\\n\\t/*\\n     * Private functions\\n\\t */\\n\\n\\n    /// Handles a readyForCommittee notification\\n    /// @dev may be called with either the guardian address or the guardian's orbs address\\n    /// @dev notifies the committee contract that will add the guardian if qualified\\n    /// @param guardian is the guardian ready for committee\\n\\tfunction _readyForCommittee(address guardian) private {\\n\\t\\tguardian = guardianRegistrationContract.resolveGuardianAddress(guardian); // this validates registration\\n\\t\\trequire(!isVotedOut(guardian), \\\"caller is voted-out\\\");\\n\\n\\t\\temit GuardianStatusUpdated(guardian, true, true);\\n\\n\\t\\tuint256 effectiveStake = getGuardianEffectiveStake(guardian, settings);\\n\\t\\tcommitteeContract.addMember(guardian, effectiveStake, certificationContract.isGuardianCertified(guardian));\\n\\t}\\n\\n    /// Calculates a guardian effective stake based on its self-stake and delegated stake\\n\\tfunction calcEffectiveStake(uint256 selfStake, uint256 delegatedStake, Settings memory _settings) private pure returns (uint256) {\\n\\t\\tif (selfStake.mul(PERCENT_MILLIE_BASE) >= delegatedStake.mul(_settings.minSelfStakePercentMille)) {\\n\\t\\t\\treturn delegatedStake;\\n\\t\\t}\\n\\t\\treturn selfStake.mul(PERCENT_MILLIE_BASE).div(_settings.minSelfStakePercentMille); // never overflows or divides by zero\\n\\t}\\n\\n    /// Returns the effective state of a guardian \\n    /// @dev calls the delegation contract to retrieve the guardian current stake and delegated stake\\n    /// @param guardian is the guardian to query\\n    /// @param _settings is the contract settings struct\\n    /// @return effectiveStake is the guardian's effective stake\\n\\tfunction getGuardianEffectiveStake(address guardian, Settings memory _settings) private view returns (uint256 effectiveStake) {\\n\\t\\tIDelegations _delegationsContract = delegationsContract;\\n\\t\\t(,uint256 selfStake) = _delegationsContract.getDelegationInfo(guardian);\\n\\t\\tuint256 delegatedStake = _delegationsContract.getDelegatedStake(guardian);\\n\\t\\treturn calcEffectiveStake(selfStake, delegatedStake, _settings);\\n\\t}\\n\\n\\t// Vote-unready\\n\\n    /// Checks if the vote unready threshold was reached for a given subject\\n    /// @dev a subject is voted-unready if either it reaches the threshold in the general committee or a certified subject reaches the threshold in the certified committee\\n    /// @param committee is a list of the current committee members\\n    /// @param weights is a list of the current committee members weight\\n    /// @param certification is a list of bool indicating the committee members certification\\n    /// @param subject is the subject guardian address\\n    /// @return thresholdReached is a bool indicating that the threshold was reached\\n\\tfunction isCommitteeVoteUnreadyThresholdReached(address[] memory committee, uint256[] memory weights, bool[] memory certification, address subject) private returns (bool) {\\n\\t\\tSettings memory _settings = settings;\\n\\n\\t\\tuint256 totalCommitteeStake = 0;\\n\\t\\tuint256 totalVoteUnreadyStake = 0;\\n\\t\\tuint256 totalCertifiedStake = 0;\\n\\t\\tuint256 totalCertifiedVoteUnreadyStake = 0;\\n\\n\\t\\taddress member;\\n\\t\\tuint256 memberStake;\\n\\t\\tbool isSubjectCertified;\\n\\t\\tfor (uint i = 0; i < committee.length; i++) {\\n\\t\\t\\tmember = committee[i];\\n\\t\\t\\tmemberStake = weights[i];\\n\\n\\t\\t\\tif (member == subject && certification[i]) {\\n\\t\\t\\t\\tisSubjectCertified = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\ttotalCommitteeStake = totalCommitteeStake.add(memberStake);\\n\\t\\t\\tif (certification[i]) {\\n\\t\\t\\t\\ttotalCertifiedStake = totalCertifiedStake.add(memberStake);\\n\\t\\t\\t}\\n\\n\\t\\t\\t(bool valid, uint256 expiration) = getVoteUnreadyVote(member, subject);\\n\\t\\t\\tif (valid) {\\n\\t\\t\\t\\ttotalVoteUnreadyStake = totalVoteUnreadyStake.add(memberStake);\\n\\t\\t\\t\\tif (certification[i]) {\\n\\t\\t\\t\\t\\ttotalCertifiedVoteUnreadyStake = totalCertifiedVoteUnreadyStake.add(memberStake);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (expiration != 0) {\\n\\t\\t\\t\\t// Vote is stale, delete from state\\n\\t\\t\\t\\tdelete voteUnreadyVotes[member][subject];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (\\n\\t\\t\\ttotalCommitteeStake > 0 &&\\n\\t\\t\\ttotalVoteUnreadyStake.mul(PERCENT_MILLIE_BASE) >= uint256(_settings.voteUnreadyPercentMilleThreshold).mul(totalCommitteeStake)\\n\\t\\t) || (\\n\\t\\t\\tisSubjectCertified &&\\n\\t\\t\\ttotalCertifiedStake > 0 &&\\n\\t\\t\\ttotalCertifiedVoteUnreadyStake.mul(PERCENT_MILLIE_BASE) >= uint256(_settings.voteUnreadyPercentMilleThreshold).mul(totalCertifiedStake)\\n\\t\\t);\\n\\t}\\n\\n    /// Clears the committee members vote-unready state upon declaring a guardian unready\\n    /// @param committee is a list of the current committee members\\n    /// @param subject is the subject guardian address\\n\\tfunction clearCommitteeUnreadyVotes(address[] memory committee, address subject) private {\\n\\t\\tfor (uint i = 0; i < committee.length; i++) {\\n\\t\\t\\tvoteUnreadyVotes[committee[i]][subject] = 0; // clear vote-outs\\n\\t\\t}\\n\\t}\\n\\n\\t// Vote-out\\n\\n    /// Updates the vote-out state upon a stake change notification\\n    /// @param voter is the voter address\\n    /// @param currentVoterStake is the voter delegated stake\\n    /// @param totalDelegatedStake is the total delegated stake\\n    /// @param _settings is the contract settings struct\\n\\tfunction applyStakesToVoteOutBy(address voter, uint256 currentVoterStake, uint256 totalDelegatedStake, Settings memory _settings) private {\\n\\t\\taddress subject = voteOutVotes[voter];\\n\\t\\tif (subject == address(0)) return;\\n\\n\\t\\tuint256 prevVoterStake = votersStake[voter];\\n\\t\\tvotersStake[voter] = currentVoterStake;\\n\\n\\t\\tapplyVoteOutVotesFor(subject, currentVoterStake, prevVoterStake, totalDelegatedStake, _settings);\\n\\t}\\n\\n    /// Applies updates in a vote-out subject state and checks whether its threshold was reached\\n    /// @param subject is the vote-out subject\\n    /// @param voteOutStakeAdded is the added votes against the subject\\n    /// @param voteOutStakeRemoved is the removed votes against the subject\\n    /// @param totalDelegatedStake is the total delegated stake used to check the vote-out threshold\\n    /// @param _settings is the contract settings struct\\n    function applyVoteOutVotesFor(address subject, uint256 voteOutStakeAdded, uint256 voteOutStakeRemoved, uint256 totalDelegatedStake, Settings memory _settings) private {\\n\\t\\tif (isVotedOut(subject)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tuint256 accumulated = accumulatedStakesForVoteOut[subject].\\n\\t\\t\\tsub(voteOutStakeRemoved).\\n\\t\\t\\tadd(voteOutStakeAdded);\\n\\n\\t\\tbool shouldBeVotedOut = totalDelegatedStake > 0 && accumulated.mul(PERCENT_MILLIE_BASE) >= uint256(_settings.voteOutPercentMilleThreshold).mul(totalDelegatedStake);\\n\\t\\tif (shouldBeVotedOut) {\\n\\t\\t\\tvotedOutGuardians[subject] = true;\\n\\t\\t\\temit GuardianVotedOut(subject);\\n\\n\\t\\t\\temit GuardianStatusUpdated(subject, false, false);\\n\\t\\t\\tcommitteeContract.removeMember(subject);\\n\\t\\t}\\n\\n\\t\\taccumulatedStakesForVoteOut[subject] = accumulated;\\n\\t}\\n\\n    /// Checks whether a guardian was voted out\\n\\tfunction isVotedOut(address guardian) private view returns (bool) {\\n\\t\\treturn votedOutGuardians[guardian];\\n\\t}\\n\\n\\t/*\\n     * Contracts topology / registry interface\\n     */\\n\\n\\tICommittee committeeContract;\\n\\tIDelegations delegationsContract;\\n\\tIGuardiansRegistration guardianRegistrationContract;\\n\\tICertification certificationContract;\\n\\n    /// Refreshes the address of the other contracts the contract interacts with\\n    /// @dev called by the registry contract upon an update of a contract in the registry\\n\\tfunction refreshContracts() external override {\\n\\t\\tcommitteeContract = ICommittee(getCommitteeContract());\\n\\t\\tdelegationsContract = IDelegations(getDelegationsContract());\\n\\t\\tguardianRegistrationContract = IGuardiansRegistration(getGuardiansRegistrationContract());\\n\\t\\tcertificationContract = ICertification(getCertificationContract());\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"ContractRegistryAccessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./spec_interfaces/IContractRegistry.sol\\\";\\nimport \\\"./spec_interfaces/IContractRegistryAccessor.sol\\\";\\nimport \\\"./WithClaimableRegistryManagement.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\ncontract ContractRegistryAccessor is IContractRegistryAccessor, WithClaimableRegistryManagement, Initializable {\\n\\n    IContractRegistry private contractRegistry;\\n\\n    /// Constructor\\n    /// @param _contractRegistry is the contract registry address\\n    /// @param _registryAdmin is the registry admin address\\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\\n        require(address(_contractRegistry) != address(0), \\\"_contractRegistry cannot be 0\\\");\\n        setContractRegistry(_contractRegistry);\\n        _transferRegistryManagement(_registryAdmin);\\n    }\\n\\n    modifier onlyAdmin {\\n        require(isAdmin(), \\\"sender is not an admin (registryManger or initializationAdmin)\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyMigrationManager {\\n        require(isMigrationManager(), \\\"sender is not the migration manager\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyFunctionalManager {\\n        require(isFunctionalManager(), \\\"sender is not the functional manager\\\");\\n\\n        _;\\n    }\\n\\n    /// Checks whether the caller is Admin: either the contract registry, the registry admin, or the initialization admin\\n    function isAdmin() internal view returns (bool) {\\n        return msg.sender == address(contractRegistry) || msg.sender == registryAdmin() || msg.sender == initializationAdmin();\\n    }\\n\\n    /// Checks whether the caller is a specific manager role or and Admin\\n    /// @dev queries the registry contract for the up to date manager assignment\\n    function isManager(string memory role) internal view returns (bool) {\\n        IContractRegistry _contractRegistry = contractRegistry;\\n        return isAdmin() || _contractRegistry != IContractRegistry(0) && contractRegistry.getManager(role) == msg.sender;\\n    }\\n\\n    /// Checks whether the caller is the migration manager\\n    function isMigrationManager() internal view returns (bool) {\\n        return isManager('migrationManager');\\n    }\\n\\n    /// Checks whether the caller is the functional manager\\n    function isFunctionalManager() internal view returns (bool) {\\n        return isManager('functionalManager');\\n    }\\n\\n    /* \\n     * Contract getters, return the address of a contract by calling the contract registry \\n     */ \\n\\n    function getProtocolContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"protocol\\\");\\n    }\\n\\n    function getStakingRewardsContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"stakingRewards\\\");\\n    }\\n\\n    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"feesAndBootstrapRewards\\\");\\n    }\\n\\n    function getCommitteeContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"committee\\\");\\n    }\\n\\n    function getElectionsContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"elections\\\");\\n    }\\n\\n    function getDelegationsContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"delegations\\\");\\n    }\\n\\n    function getGuardiansRegistrationContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"guardiansRegistration\\\");\\n    }\\n\\n    function getCertificationContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"certification\\\");\\n    }\\n\\n    function getStakingContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"staking\\\");\\n    }\\n\\n    function getSubscriptionsContract() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"subscriptions\\\");\\n    }\\n\\n    function getStakingRewardsWallet() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"stakingRewardsWallet\\\");\\n    }\\n\\n    function getBootstrapRewardsWallet() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"bootstrapRewardsWallet\\\");\\n    }\\n\\n    function getGeneralFeesWallet() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"generalFeesWallet\\\");\\n    }\\n\\n    function getCertifiedFeesWallet() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"certifiedFeesWallet\\\");\\n    }\\n\\n    function getStakingContractHandler() internal view returns (address) {\\n        return contractRegistry.getContract(\\\"stakingContractHandler\\\");\\n    }\\n\\n    /*\\n    * Governance functions\\n    */\\n\\n    event ContractRegistryAddressUpdated(address addr);\\n\\n    /// Sets the contract registry address\\n    /// @dev governance function called only by an admin\\n    /// @param newContractRegistry is the new registry contract \\n    function setContractRegistry(IContractRegistry newContractRegistry) public override onlyAdmin {\\n        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), \\\"new contract registry must provide the previous contract registry\\\");\\n        contractRegistry = newContractRegistry;\\n        emit ContractRegistryAddressUpdated(address(newContractRegistry));\\n    }\\n\\n    /// Returns the contract registry that the contract is set to use\\n    /// @return contractRegistry is the registry contract address\\n    function getContractRegistry() public override view returns (IContractRegistry) {\\n        return contractRegistry;\\n    }\\n\\n    function setRegistryAdmin(address _registryAdmin) external override onlyInitializationAdmin {\\n        _transferRegistryManagement(_registryAdmin);\\n    }\\n\\n}\\n\\n\"\r\n    },\r\n    \"Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ncontract Initializable {\\n\\n    address private _initializationAdmin;\\n\\n    event InitializationComplete();\\n\\n    /// Constructor\\n    /// Sets the initializationAdmin to the contract deployer\\n    /// The initialization admin may call any manager only function until initializationComplete\\n    constructor() public{\\n        _initializationAdmin = msg.sender;\\n    }\\n\\n    modifier onlyInitializationAdmin() {\\n        require(msg.sender == initializationAdmin(), \\\"sender is not the initialization admin\\\");\\n\\n        _;\\n    }\\n\\n    /*\\n    * External functions\\n    */\\n\\n    /// Returns the initializationAdmin address\\n    function initializationAdmin() public view returns (address) {\\n        return _initializationAdmin;\\n    }\\n\\n    /// Finalizes the initialization and revokes the initializationAdmin role \\n    function initializationComplete() external onlyInitializationAdmin {\\n        _initializationAdmin = address(0);\\n        emit InitializationComplete();\\n    }\\n\\n    /// Checks if the initialization was completed\\n    function isInitializationComplete() public view returns (bool) {\\n        return _initializationAdmin == address(0);\\n    }\\n\\n}\"\r\n    },\r\n    \"Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./ContractRegistryAccessor.sol\\\";\\nimport \\\"./spec_interfaces/ILockable.sol\\\";\\n\\n/// @title lockable contract\\ncontract Lockable is ILockable, ContractRegistryAccessor {\\n\\n    bool public locked;\\n\\n    /// Constructor\\n    /// @param _contractRegistry is the contract registry address\\n    /// @param _registryAdmin is the registry admin address\\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\\n\\n    /// Locks the contract to external non-governance function calls\\n    /// @dev governance function called only by the migration manager or an admin\\n    /// @dev typically called by the registry contract upon locking all managed contracts\\n    /// @dev getters and migration functions remain active also for locked contracts\\n    /// @dev checked by the onlyWhenActive modifier\\n    function lock() external override onlyMigrationManager {\\n        locked = true;\\n        emit Locked();\\n    }\\n\\n    /// Unlocks the contract \\n    /// @dev governance function called only by the migration manager or an admin\\n    /// @dev typically called by the registry contract upon unlocking all managed contracts\\n    function unlock() external override onlyMigrationManager {\\n        locked = false;\\n        emit Unlocked();\\n    }\\n\\n    /// Returns the contract locking status\\n    /// @return isLocked is a bool indicating the contract is locked \\n    function isLocked() external override view returns (bool) {\\n        return locked;\\n    }\\n\\n    modifier onlyWhenActive() {\\n        require(!locked, \\\"contract is locked for this operation\\\");\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"ManagedContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./spec_interfaces/IManagedContract.sol\\\";\\nimport \\\"./Lockable.sol\\\";\\n\\n/// @title managed contract\\ncontract ManagedContract is IManagedContract, Lockable {\\n\\n    /// @param _contractRegistry is the contract registry address\\n    /// @param _registryAdmin is the registry admin address\\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\\n\\n    /// Refreshes the address of the other contracts the contract interacts with\\n    /// @dev called by the registry contract upon an update of a contract in the registry\\n    function refreshContracts() virtual override external {}\\n\\n}\"\r\n    },\r\n    \"WithClaimableRegistryManagement.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\n\\n/**\\n * @title Claimable\\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\\n * This allows the new owner to accept the transfer.\\n */\\ncontract WithClaimableRegistryManagement is Context {\\n    address private _registryAdmin;\\n    address private _pendingRegistryAdmin;\\n\\n    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _registryAdmin = msgSender;\\n        emit RegistryManagementTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current registryAdmin.\\n     */\\n    function registryAdmin() public view returns (address) {\\n        return _registryAdmin;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the registryAdmin.\\n     */\\n    modifier onlyRegistryAdmin() {\\n        require(isRegistryAdmin(), \\\"WithClaimableRegistryManagement: caller is not the registryAdmin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current registryAdmin.\\n     */\\n    function isRegistryAdmin() public view returns (bool) {\\n        return _msgSender() == _registryAdmin;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without registryAdmin. It will not be possible to call\\n     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\\n     *\\n     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\\n     * thereby removing any functionality that is only available to the registryAdmin.\\n     */\\n    function renounceRegistryManagement() public onlyRegistryAdmin {\\n        emit RegistryManagementTransferred(_registryAdmin, address(0));\\n        _registryAdmin = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\\n     */\\n    function _transferRegistryManagement(address newRegistryAdmin) internal {\\n        require(newRegistryAdmin != address(0), \\\"RegistryAdmin: new registryAdmin is the zero address\\\");\\n        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\\n        _registryAdmin = newRegistryAdmin;\\n    }\\n\\n    /**\\n     * @dev Modifier throws if called by any account other than the pendingManager.\\n     */\\n    modifier onlyPendingRegistryAdmin() {\\n        require(msg.sender == _pendingRegistryAdmin, \\\"Caller is not the pending registryAdmin\\\");\\n        _;\\n    }\\n    /**\\n     * @dev Allows the current registryAdmin to set the pendingManager address.\\n     * @param newRegistryAdmin The address to transfer registryManagement to.\\n     */\\n    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\\n        _pendingRegistryAdmin = newRegistryAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\\n     */\\n    function claimRegistryManagement() external onlyPendingRegistryAdmin {\\n        _transferRegistryManagement(_pendingRegistryAdmin);\\n        _pendingRegistryAdmin = address(0);\\n    }\\n\\n    /**\\n     * @dev Returns the current pendingRegistryAdmin\\n    */\\n    function pendingRegistryAdmin() public view returns (address) {\\n       return _pendingRegistryAdmin;  \\n    }\\n}\\n\"\r\n    },\r\n    \"spec_interfaces/ICertification.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/// @title Certification contract interface\\ninterface ICertification /* is Ownable */ {\\n\\tevent GuardianCertificationUpdate(address indexed guardian, bool isCertified);\\n\\n\\t/*\\n     * External methods\\n     */\\n\\n    /// Returns the certification status of a guardian\\n    /// @param guardian is the guardian to query\\n\\tfunction isGuardianCertified(address guardian) external view returns (bool isCertified);\\n\\n    /// Sets the guardian certification status\\n    /// @dev governance function called only by the certification manager\\n    /// @param guardian is the guardian to update\\n    /// @param isCertified bool indication whether the guardian is certified\\n\\tfunction setGuardianCertification(address guardian, bool isCertified) external /* onlyCertificationManager */ ;\\n}\\n\"\r\n    },\r\n    \"spec_interfaces/ICommittee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/// @title Committee contract interface\\ninterface ICommittee {\\n\\tevent CommitteeChange(address indexed addr, uint256 weight, bool certification, bool inCommittee);\\n\\tevent CommitteeSnapshot(address[] addrs, uint256[] weights, bool[] certification);\\n\\n\\t// No external functions\\n\\n\\t/*\\n     * External functions\\n     */\\n\\n    /// Notifies a weight change of a member\\n    /// @dev Called only by: Elections contract\\n    /// @param addr is the committee member address\\n    /// @param weight is the updated weight of the committee member\\n\\tfunction memberWeightChange(address addr, uint256 weight) external /* onlyElectionsContract onlyWhenActive */;\\n\\n    /// Notifies a change in the certification of a member\\n    /// @dev Called only by: Elections contract\\n    /// @param addr is the committee member address\\n    /// @param isCertified is the updated certification state of the member\\n\\tfunction memberCertificationChange(address addr, bool isCertified) external /* onlyElectionsContract onlyWhenActive */;\\n\\n    /// Notifies a member removal for example due to voteOut or voteUnready\\n    /// @dev Called only by: Elections contract\\n    /// @param memberRemoved is the removed committee member address\\n    /// @return memberRemoved indicates whether the member was removed from the committee\\n    /// @return removedMemberWeight indicates the removed member weight\\n    /// @return removedMemberCertified indicates whether the member was in the certified committee\\n\\tfunction removeMember(address addr) external returns (bool memberRemoved, uint removedMemberWeight, bool removedMemberCertified)/* onlyElectionContract */;\\n\\n    /// Notifies a new member applicable for committee (due to registration, unbanning, certification change)\\n    /// The new member will be added only if it is qualified to join the committee \\n    /// @dev Called only by: Elections contract\\n    /// @param addr is the added committee member address\\n    /// @param weight is the added member weight\\n    /// @param isCertified is the added member certification state\\n    /// @return memberAdded bool indicates whether the member was added\\n\\tfunction addMember(address addr, uint256 weight, bool isCertified) external returns (bool memberAdded)  /* onlyElectionsContract */;\\n\\n    /// Checks if addMember() would add a the member to the committee (qualified to join)\\n    /// @param addr is the candidate committee member address\\n    /// @param weight is the candidate committee member weight\\n    /// @return wouldAddMember bool indicates whether the member will be added\\n\\tfunction checkAddMember(address addr, uint256 weight) external view returns (bool wouldAddMember);\\n\\n    /// Returns the committee members and their weights\\n    /// @return addrs is the committee members list\\n    /// @return weights is an array of uint, indicating committee members list weight\\n    /// @return certification is an array of bool, indicating the committee members certification status\\n\\tfunction getCommittee() external view returns (address[] memory addrs, uint256[] memory weights, bool[] memory certification);\\n\\n    /// Returns the currently appointed committee data\\n    /// @return generalCommitteeSize is the number of members in the committee\\n    /// @return certifiedCommitteeSize is the number of certified members in the committee\\n    /// @return totalWeight is the total effective stake (weight) of the committee\\n\\tfunction getCommitteeStats() external view returns (uint generalCommitteeSize, uint certifiedCommitteeSize, uint totalWeight);\\n\\n    /// Returns a committee member data\\n    /// @param addr is the committee member address\\n    /// @return inCommittee indicates whether the queried address is a member in the committee\\n    /// @return weight is the committee member weight\\n    /// @return isCertified indicates whether the committee member is certified\\n    /// @return totalCommitteeWeight is the total weight of the committee.\\n\\tfunction getMemberInfo(address addr) external view returns (bool inCommittee, uint weight, bool isCertified, uint totalCommitteeWeight);\\n\\n    /// Emits a CommitteeSnapshot events with current committee info\\n    /// @dev a CommitteeSnapshot is useful on contract migration or to remove the need to track past events.\\n\\tfunction emitCommitteeSnapshot() external;\\n\\n\\t/*\\n\\t * Governance functions\\n\\t */\\n\\n\\tevent MaxCommitteeSizeChanged(uint8 newValue, uint8 oldValue);\\n\\n    /// Sets the maximum number of committee members\\n    /// @dev governance function called only by the functional manager\\n    /// @dev when reducing the number of members, the bottom ones are removed from the committee\\n    /// @param _maxCommitteeSize is the maximum number of committee members \\n\\tfunction setMaxCommitteeSize(uint8 _maxCommitteeSize) external /* onlyFunctionalManager */;\\n\\n    /// Returns the maximum number of committee members\\n    /// @return maxCommitteeSize is the maximum number of committee members \\n\\tfunction getMaxCommitteeSize() external view returns (uint8);\\n\\t\\n    /// Imports the committee members from a previous committee contract during migration\\n    /// @dev initialization function called only by the initializationManager\\n    /// @dev does not update the reward contract to avoid incorrect notifications \\n    /// @param previousCommitteeContract is the address of the previous committee contract\\n\\tfunction importMembers(ICommittee previousCommitteeContract) external /* onlyInitializationAdmin */;\\n}\\n\"\r\n    },\r\n    \"spec_interfaces/IContractRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/// @title Contract registry contract interface\\n/// @dev The contract registry holds Orbs PoS contracts and managers lists\\n/// @dev The contract registry updates the managed contracts on changes in the contract list\\n/// @dev Governance functions restricted to managers access the registry to retrieve the manager address \\n/// @dev The contract registry represents the source of truth for Orbs Ethereum contracts \\n/// @dev By tracking the registry events or query before interaction, one can access the up to date contracts \\ninterface IContractRegistry {\\n\\n\\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\\n\\tevent ManagerChanged(string role, address newManager);\\n\\tevent ContractRegistryUpdated(address newContractRegistry);\\n\\n\\t/*\\n\\t* External functions\\n\\t*/\\n\\n    /// Updates the contracts address and emits a corresponding event\\n    /// @dev governance function called only by the migrationManager or registryAdmin\\n    /// @param contractName is the contract name, used to identify it\\n    /// @param addr is the contract updated address\\n    /// @param managedContract indicates whether the contract is managed by the registry and notified on changes\\n\\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdminOrMigrationManager */;\\n\\n    /// Returns the current address of the given contracts\\n    /// @param contractName is the contract name, used to identify it\\n    /// @return addr is the contract updated address\\n\\tfunction getContract(string calldata contractName) external view returns (address);\\n\\n    /// Returns the list of contract addresses managed by the registry\\n    /// @dev Managed contracts are updated on changes in the registry contracts addresses \\n    /// @return addrs is the list of managed contracts\\n\\tfunction getManagedContracts() external view returns (address[] memory);\\n\\n    /// Locks all the managed contracts \\n    /// @dev governance function called only by the migrationManager or registryAdmin\\n    /// @dev When set all onlyWhenActive functions will revert\\n\\tfunction lockContracts() external /* onlyAdminOrMigrationManager */;\\n\\n    /// Unlocks all the managed contracts \\n    /// @dev governance function called only by the migrationManager or registryAdmin\\n\\tfunction unlockContracts() external /* onlyAdminOrMigrationManager */;\\n\\t\\n    /// Updates a manager address and emits a corresponding event\\n    /// @dev governance function called only by the registryAdmin\\n    /// @dev the managers list is a flexible list of role to the manager's address\\n    /// @param role is the managers' role name, for example \\\"functionalManager\\\"\\n    /// @param manager is the manager updated address\\n\\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\\n\\n    /// Returns the current address of the given manager\\n    /// @param role is the manager name, used to identify it\\n    /// @return addr is the manager updated address\\n\\tfunction getManager(string calldata role) external view returns (address);\\n\\n    /// Sets a new contract registry to migrate to\\n    /// @dev governance function called only by the registryAdmin\\n    /// @dev updates the registry address record in all the managed contracts\\n    /// @dev by tracking the emitted ContractRegistryUpdated, tools can track the up to date contracts\\n    /// @param newRegistry is the new registry contract \\n\\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\\n\\n    /// Returns the previous contract registry address \\n    /// @dev used when the setting the contract as a new registry to assure a valid registry\\n    /// @return previousContractRegistry is the previous contract registry\\n\\tfunction getPreviousContractRegistry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"spec_interfaces/IContractRegistryAccessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IContractRegistry.sol\\\";\\n\\ninterface IContractRegistryAccessor {\\n\\n    /// Sets the contract registry address\\n    /// @dev governance function called only by an admin\\n    /// @param newRegistry is the new registry contract \\n    function setContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\\n\\n    /// Returns the contract registry address\\n    /// @return contractRegistry is the contract registry address\\n    function getContractRegistry() external view returns (IContractRegistry contractRegistry);\\n\\n    function setRegistryAdmin(address _registryAdmin) external /* onlyInitializationAdmin */;\\n\\n}\\n\"\r\n    },\r\n    \"spec_interfaces/IDelegations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/// @title Delegations contract interface\\ninterface IDelegations /* is IStakeChangeNotifier */ {\\n\\n    // Delegation state change events\\n\\tevent DelegatedStakeChanged(address indexed addr, uint256 selfDelegatedStake, uint256 delegatedStake, address indexed delegator, uint256 delegatorContributedStake);\\n\\n    // Function calls\\n\\tevent Delegated(address indexed from, address indexed to);\\n\\n\\t/*\\n     * External functions\\n     */\\n\\n    /// Delegate your stake\\n    /// @dev updates the election contract on the changes in the delegated stake\\n    /// @dev updates the rewards contract on the upcoming change in the delegator's delegation state\\n    /// @param to is the address to delegate to\\n\\tfunction delegate(address to) external /* onlyWhenActive */;\\n\\n    /// Refresh the address stake for delegation power based on the staking contract\\n    /// @dev Disabled stake change update notifications from the staking contract may create mismatches\\n    /// @dev refreshStake re-syncs the stake data with the staking contract\\n    /// @param addr is the address to refresh its stake\\n\\tfunction refreshStake(address addr) external /* onlyWhenActive */;\\n\\n    /// Refresh the addresses stake for delegation power based on the staking contract\\n    /// @dev Batched version of refreshStake\\n    /// @dev Disabled stake change update notifications from the staking contract may create mismatches\\n    /// @dev refreshStakeBatch re-syncs the stake data with the staking contract\\n    /// @param addrs is the list of addresses to refresh their stake\\n\\tfunction refreshStakeBatch(address[] calldata addrs) external /* onlyWhenActive */;\\n\\n    /// Returns the delegate address of the given address\\n    /// @param addr is the address to query\\n    /// @return delegation is the address the addr delegated to\\n\\tfunction getDelegation(address addr) external view returns (address);\\n\\n    /// Returns a delegator info\\n    /// @param addr is the address to query\\n    /// @return delegation is the address the addr delegated to\\n    /// @return delegatorStake is the stake of the delegator as reflected in the delegation contract\\n\\tfunction getDelegationInfo(address addr) external view returns (address delegation, uint256 delegatorStake);\\n\\t\\n    /// Returns the delegated stake of an addr \\n    /// @dev an address that is not self delegating has a 0 delegated stake\\n    /// @param addr is the address to query\\n    /// @return delegatedStake is the address delegated stake\\n\\tfunction getDelegatedStake(address addr) external view returns (uint256);\\n\\n    /// Returns the total delegated stake\\n    /// @dev delegatedStake - the total stake delegated to an address that is self delegating\\n    /// @dev the delegated stake of a non self-delegated address is 0\\n    /// @return totalDelegatedStake is the total delegatedStake of all the addresses\\n\\tfunction getTotalDelegatedStake() external view returns (uint256) ;\\n\\n\\t/*\\n\\t * Governance functions\\n\\t */\\n\\n\\tevent DelegationsImported(address[] from, address indexed to);\\n\\n\\tevent DelegationInitialized(address indexed from, address indexed to);\\n\\n    /// Imports delegations during initial migration\\n    /// @dev initialization function called only by the initializationManager\\n    /// @dev Does not update the Rewards or Election contracts\\n    /// @dev assumes deactivated Rewards\\n    /// @param from is a list of delegator addresses\\n    /// @param to is the address the delegators delegate to\\n\\tfunction importDelegations(address[] calldata from, address to) external /* onlyMigrationManager onlyDuringDelegationImport */;\\n\\n    /// Initializes the delegation of an address during initial migration \\n    /// @dev initialization function called only by the initializationManager\\n    /// @dev behaves identically to a delegate transaction sent by the delegator\\n    /// @param from is the delegator addresses\\n    /// @param to is the delegator delegates to\\n\\tfunction initDelegation(address from, address to) external /* onlyInitializationAdmin */;\\n}\\n\"\r\n    },\r\n    \"spec_interfaces/IElections.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/// @title Elections contract interface\\ninterface IElections {\\n\\t\\n\\t// Election state change events\\n\\tevent StakeChanged(address indexed addr, uint256 selfDelegatedStake, uint256 delegatedStake, uint256 effectiveStake);\\n\\tevent GuardianStatusUpdated(address indexed guardian, bool readyToSync, bool readyForCommittee);\\n\\n\\t// Vote out / Vote unready\\n\\tevent GuardianVotedUnready(address indexed guardian);\\n\\tevent VoteUnreadyCasted(address indexed voter, address indexed subject, uint256 expiration);\\n\\tevent GuardianVotedOut(address indexed guardian);\\n\\tevent VoteOutCasted(address indexed voter, address indexed subject);\\n\\n\\t/*\\n\\t * External functions\\n\\t */\\n\\n    /// Notifies that the guardian is ready to sync with other nodes\\n    /// @dev may be called with either the guardian address or the guardian's orbs address\\n    /// @dev ready to sync state is not managed in the contract that only emits an event\\n    /// @dev readyToSync clears the readyForCommittee state\\n\\tfunction readyToSync() external;\\n\\n    /// Notifies that the guardian is ready to join the committee\\n    /// @dev may be called with either the guardian address or the guardian's orbs address\\n    /// @dev a qualified guardian calling readyForCommittee is added to the committee\\n\\tfunction readyForCommittee() external;\\n\\n    /// Checks if a guardian is qualified to join the committee\\n    /// @dev when true, calling readyForCommittee() will result in adding the guardian to the committee\\n    /// @dev called periodically by guardians to check if they are qualified to join the committee\\n    /// @param guardian is the guardian to check\\n    /// @return canJoin indicating that the guardian can join the current committee\\n\\tfunction canJoinCommittee(address guardian) external view returns (bool);\\n\\n    /// Returns an address effective stake\\n    /// The effective stake is derived from a guardian delegate stake and selfs stake  \\n    /// @return effectiveStake is the guardian's effective stake\\n\\tfunction getEffectiveStake(address guardian) external view returns (uint effectiveStake);\\n\\n    /// Returns the current committee along with the guardians' Orbs address and IP\\n    /// @return committee is a list of the committee members' guardian addresses\\n    /// @return weights is a list of the committee members' weight (effective stake)\\n    /// @return orbsAddrs is a list of the committee members' orbs address\\n    /// @return certification is a list of bool indicating the committee members certification\\n    /// @return ips is a list of the committee members' ip\\n\\tfunction getCommittee() external view returns (address[] memory committee, uint256[] memory weights, address[] memory orbsAddrs, bool[] memory certification, bytes4[] memory ips);\\n\\n\\t// Vote-unready\\n\\n    /// Casts an unready vote on a subject guardian\\n    /// @dev Called by a guardian as part of the automatic vote-unready flow\\n    /// @dev The transaction may be sent from the guardian or orbs address.\\n    /// @param subject is the subject guardian to vote out\\n    /// @param voteExpiration is the expiration time of the vote unready to prevent counting of a vote that is already irrelevant.\\n\\tfunction voteUnready(address subject, uint voteExpiration) external;\\n\\n    /// Returns the current vote unready vote for a voter and a subject pair\\n    /// @param voter is the voting guardian address\\n    /// @param subject is the subject guardian address\\n    /// @return valid indicates whether there is a valid vote\\n    /// @return expiration returns the votes expiration time\\n\\tfunction getVoteUnreadyVote(address voter, address subject) external view returns (bool valid, uint256 expiration);\\n\\n    /// Returns the current vote-unready status of a subject guardian.\\n    /// @dev the committee and certification data is used to check the certified and committee threshold\\n    /// @param subject is the subject guardian address\\n    /// @return committee is a list of the current committee members\\n    /// @return weights is a list of the current committee members weight\\n    /// @return certification is a list of bool indicating the committee members certification\\n    /// @return votes is a list of bool indicating the members that votes the subject unready\\n    /// @return subjectInCommittee indicates that the subject is in the committee\\n    /// @return subjectInCertifiedCommittee indicates that the subject is in the certified committee\\n\\tfunction getVoteUnreadyStatus(address subject) external view returns (\\n\\t\\taddress[] memory committee,\\n\\t\\tuint256[] memory weights,\\n\\t\\tbool[] memory certification,\\n\\t\\tbool[] memory votes,\\n\\t\\tbool subjectInCommittee,\\n\\t\\tbool subjectInCertifiedCommittee\\n\\t);\\n\\n\\t// Vote-out\\n\\n    /// Casts a voteOut vote by the sender to the given address\\n    /// @dev the transaction is sent from the guardian address\\n    /// @param subject is the subject guardian address\\n\\tfunction voteOut(address subject) external;\\n\\n    /// Returns the subject address the addr has voted-out against\\n    /// @param voter is the voting guardian address\\n    /// @return subject is the subject the voter has voted out\\n\\tfunction getVoteOutVote(address voter) external view returns (address);\\n\\n    /// Returns the governance voteOut status of a guardian.\\n    /// @dev A guardian is voted out if votedStake / totalDelegatedStake (in percent mille) > threshold\\n    /// @param subject is the subject guardian address\\n    /// @return votedOut indicates whether the subject was voted out\\n    /// @return votedStake is the total stake voting against the subject\\n    /// @return totalDelegatedStake is the total delegated stake\\n\\tfunction getVoteOutStatus(address subject) external view returns (bool votedOut, uint votedStake, uint totalDelegatedStake);\\n\\n\\t/*\\n\\t * Notification functions from other PoS contracts\\n\\t */\\n\\n    /// Notifies a delegated stake change event\\n    /// @dev Called by: delegation contract\\n    /// @param delegate is the delegate to update\\n    /// @param selfDelegatedStake is the delegate self stake (0 if not self-delegating)\\n    /// @param delegatedStake is the delegate delegated stake (0 if not self-delegating)\\n    /// @param totalDelegatedStake is the total delegated stake\\n\\tfunction delegatedStakeChange(address delegate, uint256 selfDelegatedStake, uint256 delegatedStake, uint256 totalDelegatedStake) external /* onlyDelegationsContract onlyWhenActive */;\\n\\n    /// Notifies a new guardian was unregistered\\n    /// @dev Called by: guardian registration contract\\n    /// @dev when a guardian unregisters its status is updated to not ready to sync and is removed from the committee\\n    /// @param guardian is the address of the guardian that unregistered\\n\\tfunction guardianUnregistered(address guardian) external /* onlyGuardiansRegistrationContract */;\\n\\n    /// Notifies on a guardian certification change\\n    /// @dev Called by: guardian registration contract\\n    /// @param guardian is the address of the guardian to update\\n    /// @param isCertified indicates whether the guardian is certified\\n\\tfunction guardianCertificationChanged(address guardian, bool isCertified) external /* onlyCertificationContract */;\\n\\n\\n\\t/*\\n     * Governance functions\\n\\t */\\n\\n\\tevent VoteUnreadyTimeoutSecondsChanged(uint32 newValue, uint32 oldValue);\\n\\tevent VoteOutPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);\\n\\tevent VoteUnreadyPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);\\n\\tevent MinSelfStakePercentMilleChanged(uint32 newValue, uint32 oldValue);\\n\\n    /// Sets the minimum self stake requirement for the effective stake\\n    /// @dev governance function called only by the functional manager\\n    /// @param minSelfStakePercentMille is the minimum self stake in percent-mille (0-100,000) \\n\\tfunction setMinSelfStakePercentMille(uint32 minSelfStakePercentMille) external /* onlyFunctionalManager */;\\n\\n    /// Returns the minimum self-stake required for the effective stake\\n    /// @return minSelfStakePercentMille is the minimum self stake in percent-mille \\n\\tfunction getMinSelfStakePercentMille() external view returns (uint32);\\n\\n    /// Sets the vote-out threshold\\n    /// @dev governance function called only by the functional manager\\n    /// @param voteOutPercentMilleThreshold is the minimum threshold in percent-mille (0-100,000)\\n\\tfunction setVoteOutPercentMilleThreshold(uint32 voteOutPercentMilleThreshold) external /* onlyFunctionalManager */;\\n\\n    /// Returns the vote-out threshold\\n    /// @return voteOutPercentMilleThreshold is the minimum threshold in percent-mille\\n\\tfunction getVoteOutPercentMilleThreshold() external view returns (uint32);\\n\\n    /// Sets the vote-unready threshold\\n    /// @dev governance function called only by the functional manager\\n    /// @param voteUnreadyPercentMilleThreshold is the minimum threshold in percent-mille (0-100,000)\\n\\tfunction setVoteUnreadyPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) external /* onlyFunctionalManager */;\\n\\n    /// Returns the vote-unready threshold\\n    /// @return voteUnreadyPercentMilleThreshold is the minimum threshold in percent-mille\\n\\tfunction getVoteUnreadyPercentMilleThreshold() external view returns (uint32);\\n\\n    /// Returns the contract's settings \\n    /// @return minSelfStakePercentMille is the minimum self stake in percent-mille\\n    /// @return voteUnreadyPercentMilleThreshold is the minimum threshold in percent-mille\\n    /// @return voteOutPercentMilleThreshold is the minimum threshold in percent-mille\\n\\tfunction getSettings() external view returns (\\n\\t\\tuint32 minSelfStakePercentMille,\\n\\t\\tuint32 voteUnreadyPercentMilleThreshold,\\n\\t\\tuint32 voteOutPercentMilleThreshold\\n\\t);\\n\\n    /// Initializes the ready for committee notification for the committee guardians\\n    /// @dev governance function called only by the initialization admin during migration \\n    /// @dev identical behaviour as if each guardian sent readyForCommittee() \\n    /// @param guardians a list of guardians addresses to update\\n\\tfunction initReadyForCommittee(address[] calldata guardians) external /* onlyInitializationAdmin */;\\n\\n}\\n\"\r\n    },\r\n    \"spec_interfaces/IGuardiansRegistration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/// @title Guardian registration contract interface\\ninterface IGuardiansRegistration {\\n\\tevent GuardianRegistered(address indexed guardian);\\n\\tevent GuardianUnregistered(address indexed guardian);\\n\\tevent GuardianDataUpdated(address indexed guardian, bool isRegistered, bytes4 ip, address orbsAddr, string name, string website, uint256 registrationTime);\\n\\tevent GuardianMetadataChanged(address indexed guardian, string key, string newValue, string oldValue);\\n\\n\\t/*\\n     * External methods\\n     */\\n\\n    /// Registers a new guardian\\n    /// @dev called using the guardian's address that holds the guardian self-stake and used for delegation\\n    /// @param ip is the guardian's node ipv4 address as a 32b number \\n    /// @param orbsAddr is the guardian's Orbs node address \\n    /// @param name is the guardian's name as a string\\n    /// @param website is the guardian's website as a string, publishing a name and website provide information for delegators\\n\\tfunction registerGuardian(bytes4 ip, address orbsAddr, string calldata name, string calldata website) external;\\n\\n    /// Updates a registered guardian data\\n    /// @dev may be called only by a registered guardian\\n    /// @param ip is the guardian's node ipv4 address as a 32b number \\n    /// @param orbsAddr is the guardian's Orbs node address \\n    /// @param name is the guardian's name as a string\\n    /// @param website is the guardian's website as a string, publishing a name and website provide information for delegators\\n\\tfunction updateGuardian(bytes4 ip, address orbsAddr, string calldata name, string calldata website) external;\\n\\n    /// Updates a registered guardian ip address\\n    /// @dev may be called only by a registered guardian\\n    /// @dev may be called with either the guardian address or the guardian's orbs address\\n    /// @param ip is the guardian's node ipv4 address as a 32b number \\n\\tfunction updateGuardianIp(bytes4 ip) external /* onlyWhenActive */;\\n\\n    /// Updates a guardian's metadata property\\n    /// @dev called using the guardian's address\\n    /// @dev any key may be updated to be used by Orbs platform and tools\\n    /// @param key is the name of the property to update\\n    /// @param value is the value of the property to update in a string format\\n    function setMetadata(string calldata key, string calldata value) external;\\n\\n    /// Returns a guardian's metadata property\\n    /// @dev a property that wasn't set returns an empty string\\n    /// @param guardian is the guardian to query\\n    /// @param key is the name of the metadata property to query\\n    /// @return value is the value of the queried property in a string format\\n    function getMetadata(address guardian, string calldata key) external view returns (string memory);\\n\\n    /// Unregisters a guardian\\n    /// @dev may be called only by a registered guardian\\n    /// @dev unregistering does not clear the guardian's metadata properties\\n\\tfunction unregisterGuardian() external;\\n\\n    /// Returns a guardian's data\\n    /// @param guardian is the guardian to query\\n    /// @param ip is the guardian's node ipv4 address as a 32b number \\n    /// @param orbsAddr is the guardian's Orbs node address \\n    /// @param name is the guardian's name as a string\\n    /// @param website is the guardian's website as a string\\n    /// @param registrationTime is the timestamp of the guardian's registration\\n    /// @param lastUpdateTime is the timestamp of the guardian's last update\\n\\tfunction getGuardianData(address guardian) external view returns (bytes4 ip, address orbsAddr, string memory name, string memory website, uint registrationTime, uint lastUpdateTime);\\n\\n    /// Returns the Orbs addresses of a list of guardians\\n    /// @dev an unregistered guardian returns address(0) Orbs address\\n    /// @param guardianAddrs is a list of guardians' addresses to query\\n    /// @return orbsAddrs is a list of the guardians' Orbs addresses \\n\\tfunction getGuardiansOrbsAddress(address[] calldata guardianAddrs) external view returns (address[] memory orbsAddrs);\\n\\n    /// Returns a guardian's ip\\n    /// @dev an unregistered guardian returns 0 ip address\\n    /// @param guardian is the guardian to query\\n    /// @return ip is the guardian's node ipv4 address as a 32b number \\n\\tfunction getGuardianIp(address guardian) external view returns (bytes4 ip);\\n\\n    /// Returns the ip of a list of guardians\\n    /// @dev an unregistered guardian returns 0 ip address\\n    /// @param guardianAddrs is a list of guardians' addresses to query\\n    /// @param ips is a list of the guardians' node ipv4 addresses as a 32b numbers\\n\\tfunction getGuardianIps(address[] calldata guardianAddrs) external view returns (bytes4[] memory ips);\\n\\n    /// Checks if a guardian is registered\\n    /// @param guardian is the guardian to query\\n    /// @return registered is a bool indicating a guardian address is registered\\n\\tfunction isRegistered(address guardian) external view returns (bool);\\n\\n    /// Translates a list guardians Orbs addresses to guardian addresses\\n    /// @dev an Orbs address that does not correspond to any registered guardian returns address(0)\\n    /// @param orbsAddrs is a list of the guardians' Orbs addresses to query\\n    /// @return guardianAddrs is a list of guardians' addresses that matches the Orbs addresses\\n\\tfunction getGuardianAddresses(address[] calldata orbsAddrs) external view returns (address[] memory guardianAddrs);\\n\\n    /// Resolves the guardian address for a guardian, given a Guardian/Orbs address\\n    /// @dev revert if the address does not correspond to a registered guardian address or Orbs address\\n    /// @dev designed to be used for contracts calls, validating a registered guardian\\n    /// @dev should be used with caution when called by tools as the call may revert\\n    /// @dev in case of a conflict matching both guardian and Orbs address, the Guardian address takes precedence\\n    /// @param guardianOrOrbsAddress is the address to query representing a guardian address or Orbs address\\n    /// @return guardianAddress is the guardian address that matches the queried address\\n\\tfunction resolveGuardianAddress(address guardianOrOrbsAddress) external view returns (address guardianAddress);\\n\\n\\t/*\\n\\t * Governance functions\\n\\t */\\n\\n    /// Migrates a list of guardians from a previous guardians registration contract\\n    /// @dev governance function called only by the initialization admin\\n    /// @dev reads the migrated guardians data by calling getGuardianData in the previous contract\\n    /// @dev imports also the guardians' registration time and last update\\n    /// @dev emits a GuardianDataUpdated for each guardian to allow tracking by tools\\n    /// @param guardiansToMigrate is a list of guardians' addresses to migrate\\n    /// @param previousContract is the previous registration contract address\\n\\tfunction migrateGuardians(address[] calldata guardiansToMigrate, IGuardiansRegistration previousContract) external /* onlyInitializationAdmin */;\\n\\n}\\n\"\r\n    },\r\n    \"spec_interfaces/ILockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/// @title lockable contract interface, allows to lock a contract\\ninterface ILockable {\\n\\n    event Locked();\\n    event Unlocked();\\n\\n    /// Locks the contract to external non-governance function calls\\n    /// @dev governance function called only by the migration manager or an admin\\n    /// @dev typically called by the registry contract upon locking all managed contracts\\n    /// @dev getters and migration functions remain active also for locked contracts\\n    /// @dev checked by the onlyWhenActive modifier\\n    function lock() external /* onlyMigrationManager */;\\n\\n    /// Unlocks the contract \\n    /// @dev governance function called only by the migration manager or an admin\\n    /// @dev typically called by the registry contract upon unlocking all managed contracts\\n    function unlock() external /* onlyMigrationManager */;\\n\\n    /// Returns the contract locking status\\n    /// @return isLocked is a bool indicating the contract is locked \\n    function isLocked() view external returns (bool);\\n\\n}\\n\"\r\n    },\r\n    \"spec_interfaces/IManagedContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/// @title managed contract interface, used by the contracts registry to notify the contract on updates\\ninterface IManagedContract /* is ILockable, IContractRegistryAccessor, Initializable */ {\\n\\n    /// Refreshes the address of the other contracts the contract interacts with\\n    /// @dev called by the registry contract upon an update of a contract in the registry\\n    function refreshContracts() external;\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"_contractRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registryAdmin\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"minSelfStakePercentMille\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"voteUnreadyPercentMilleThreshold\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"voteOutPercentMilleThreshold\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ContractRegistryAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"readyToSync\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"readyForCommittee\",\"type\":\"bool\"}],\"name\":\"GuardianStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"GuardianVotedOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"GuardianVotedUnready\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InitializationComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newValue\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"oldValue\",\"type\":\"uint32\"}],\"name\":\"MinSelfStakePercentMilleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousRegistryAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRegistryAdmin\",\"type\":\"address\"}],\"name\":\"RegistryManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"selfDelegatedStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"effectiveStake\",\"type\":\"uint256\"}],\"name\":\"StakeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"}],\"name\":\"VoteOutCasted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newValue\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"oldValue\",\"type\":\"uint32\"}],\"name\":\"VoteOutPercentMilleThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"VoteUnreadyCasted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newValue\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"oldValue\",\"type\":\"uint32\"}],\"name\":\"VoteUnreadyPercentMilleThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newValue\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"oldValue\",\"type\":\"uint32\"}],\"name\":\"VoteUnreadyTimeoutSecondsChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"canJoinCommittee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"selfDelegatedStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegatedStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDelegatedStake\",\"type\":\"uint256\"}],\"name\":\"delegatedStakeChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCommittee\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"committee\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"orbsAddrs\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"certification\",\"type\":\"bool[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"ips\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractRegistry\",\"outputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"getEffectiveStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"effectiveStake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinSelfStakePercentMille\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSettings\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"minSelfStakePercentMille\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"voteUnreadyPercentMilleThreshold\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"voteOutPercentMilleThreshold\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVoteOutPercentMilleThreshold\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"}],\"name\":\"getVoteOutStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"votedOut\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"votedStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDelegatedStake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getVoteOutVote\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVoteUnreadyPercentMilleThreshold\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"}],\"name\":\"getVoteUnreadyStatus\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"committee\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"weights\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"certification\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"votes\",\"type\":\"bool[]\"},{\"internalType\":\"bool\",\"name\":\"subjectInCommittee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"subjectInCertifiedCommittee\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"}],\"name\":\"getVoteUnreadyVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCertified\",\"type\":\"bool\"}],\"name\":\"guardianCertificationChanged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"guardianUnregistered\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"}],\"name\":\"initReadyForCommittee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializationAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializationComplete\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitializationComplete\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRegistryAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRegistryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"readyForCommittee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"readyToSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"newContractRegistry\",\"type\":\"address\"}],\"name\":\"setContractRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"minSelfStakePercentMille\",\"type\":\"uint32\"}],\"name\":\"setMinSelfStakePercentMille\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registryAdmin\",\"type\":\"address\"}],\"name\":\"setRegistryAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"voteOutPercentMilleThreshold\",\"type\":\"uint32\"}],\"name\":\"setVoteOutPercentMilleThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"voteUnreadyPercentMilleThreshold\",\"type\":\"uint32\"}],\"name\":\"setVoteUnreadyPercentMilleThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRegistryAdmin\",\"type\":\"address\"}],\"name\":\"transferRegistryManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"}],\"name\":\"voteOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"voteExpiration\",\"type\":\"uint256\"}],\"name\":\"voteUnready\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votersStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Elections", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000035ea0d75b2a3ab06393749b4651dfad1ffd49a77000000000000000000000000f1fd5233e60e7ef797025fe9dd066d60d59bcb92000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111700000000000000000000000000000000000000000000000000000000000011170", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e2643d8debe01ae4182e08ac333b74b50c649fb45d8fb6b9be0f1cfff5d8d5ce"}