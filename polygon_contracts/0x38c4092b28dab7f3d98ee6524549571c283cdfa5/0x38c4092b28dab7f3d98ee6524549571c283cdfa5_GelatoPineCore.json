{"SourceCode": "{\"GelatoPineCore.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n//\\n// Original work by Pine.Finance\\n//  - https://github.com/pine-finance\\n//\\n// Authors:\\n//  - Ignacio Mazzara \\u003c@nachomazzara\\u003e\\n//  - Agustin Aguilar \\u003c@agusx1211\\u003e\\n\\n// solhint-disable-next-line\\npragma solidity 0.6.12;\\n\\nimport {PineCore, IModule, IERC20} from \\\"./PineCore.sol\\\";\\n\\ncontract GelatoPineCore is PineCore {\\n    // solhint-disable-next-line var-name-mixedcase\\n    address public immutable GELATO;\\n\\n    constructor(address _gelato) public {\\n        GELATO = _gelato;\\n    }\\n\\n    modifier onlyGelato {\\n        require(GELATO == msg.sender, \\\"GelatoPineCore: onlyGelato\\\");\\n        _;\\n    }\\n\\n    function executeOrder(\\n        IModule _module,\\n        IERC20 _inputToken,\\n        address payable _owner,\\n        bytes calldata _data,\\n        bytes calldata _signature,\\n        bytes calldata _auxData\\n    ) public override onlyGelato {\\n        super.executeOrder(\\n            _module,\\n            _inputToken,\\n            _owner,\\n            _data,\\n            _signature,\\n            _auxData\\n        );\\n    }\\n}\\n\"},\"PineCore.sol\":{\"content\":\"/**\\n *Submitted for verification at Etherscan.io on 2020-08-30\\n */\\n\\n/**\\n *Submitted for verification at Etherscan.io on 2020-08-30\\n */\\n\\n// SPDX-License-Identifier: GPL-3.0\\n//\\n// Original work by Pine.Finance\\n//  - https://github.com/pine-finance\\n//\\n// Authors:\\n//  - Ignacio Mazzara \\u003c@nachomazzara\\u003e\\n//  - Agustin Aguilar \\u003c@agusx1211\\u003e\\n\\n//\\n//\\n//                                                /\\n//                                                @,\\n//                                               /\\u0026\\u0026\\n//                                              \\u0026\\u0026%%\\u0026/\\n//                                            \\u0026%%%%\\u0026%%,..\\n//                                         */%\\u0026,*\\u0026\\u0026\\u0026\\u0026\\u0026\\u0026%%\\u0026*\\n//                                           /\\u0026%%%%%%%#.\\n//                                    ./%\\u0026%%%\\u0026#/%%%%\\u0026#\\u0026%%%\\u0026#(*.\\n//                                         .%%%%%%%\\u0026\\u0026%\\u0026/ ..,...\\n//                                       .*,%%%%%%%%%\\u0026\\u0026%%%%(\\n//                                     ,\\u0026\\u0026%%%\\u0026\\u0026*%%%%%%%%.*(#%\\u0026/\\n//                                  ./,(*,*,#%%%%%%%%%%%%%%%(,\\n//                                 ,(%%%%%%%%%%%%\\u0026%%%%%%%%%#\\u0026\\u0026%%%#/(*\\n//                                     *#%%%%%%%\\u0026%%%\\u0026%%#%%%%%%(\\n//                              .(####%%\\u0026%\\u0026#*\\u0026%%##%%%%%%%%%%%#.,,\\n//                                      ,\\u0026%%%%%###%%%%%%%%%%%%#\\u0026\\u0026.\\n//                             ..,(\\u0026%%%%%%%%%%%%%%%%%%\\u0026\\u0026%%%%#%\\u0026\\u0026%\\u0026%%%%\\u0026\\u0026#,\\n//                           ,##//%((#*/#%%%%%%%%%%%%%%%%%%%%%\\u0026(.\\n//                                  (%%%%%%%%%%%%%%%%%%%#%%%%%%%%%\\u0026\\u0026\\u0026\\u0026#(*,\\n//                                   ./%%%%\\u0026%%%%#%\\u0026%%%%%%##%%\\u0026\\u0026\\u0026\\u0026%%(*,\\n//                                #%%%%%%\\u0026\\u0026%%%#%%%%%%%%%%%%%%%\\u0026#,*\\u0026\\u0026#.\\n//                            /%##%(%\\u0026/ #%%%%%%%%%%%%%%%%%%%%%%%%%\\u0026%%%.\\n//                                 *\\u0026%%%%\\u0026%%%%%%%%#%%%%%%%%%%%%%%%%%\\u0026%%%#%#%%,\\n//                        .*(#\\u0026%%%%%%%%\\u0026\\u0026%%%%%%%%%%#%%%%%%%%%%%%%%%(,\\n//                    ./#%%%%%%%%%%%%%%%%%%%%%%%#%\\u0026%#%%%%%%%%%%%%%%%%%%%%\\u0026%%%#####(.\\n//                          .,,*#%%%%%%%%%%%%%##%%\\u0026\\u0026%#%%%%%%%%\\u0026\\u0026%%%%%%(\\u0026*#\\u0026**/(*\\n//                        .,(\\u0026%%%%%#((%%%%%%#%%%%%%%%%#%%%%%%%\\u0026\\u0026\\u0026\\u0026\\u0026%%%%\\u0026%*\\n//                         ,,,,,..*\\u0026%%%%%%%%%%%%%%%%%%%%%%%\\u0026%%%%%%%%%#/*.\\n//                           ,#\\u0026%%%%%%%%%%%%%%%%%%%%%%%%\\u0026%%%%%%%%%%%%%%%%%%/,\\n//           .     .,*(#%%%%%%%%%\\u0026\\u0026\\u0026\\u0026%%%%%%\\u0026\\u0026\\u0026%%%%%%%%%\\u0026\\u0026%##%%%%%#,(%%%%%%%%%%%(((*\\n//             ,/((%%%%%#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#%%%%%%%\\u0026#  . . ...\\n//                      .,.,,**(%%%%%%%%\\u0026%##%%%%%%%%%%%%%%%%%%###%%%%%%%%%\\u0026*\\n//                       ,%\\u0026%%%%%\\u0026\\u0026%%%%%%%#%%%%%%%%%%%%%%%%%%\\u0026%%%%##%%%%%%%%%%%%%%%%\\u0026\\u0026#.\\n//              .(\\u0026\\u0026\\u0026%%%%%%\\u0026#\\u0026\\u0026%\\u0026%%%%%%%##%%%%\\u0026\\u0026%%%#%%%%%%\\u0026%%%%%%\\u0026\\u0026%%%%\\u0026\\u0026\\u0026/*(,(#(,,.\\n//                         ..\\u0026%%%%%%#%#%%%%%%%%%%%##%%%%%%%\\u0026%%%%%%%%%%%%%%%%\\u0026\\u0026(.\\n//                      ,%%%%%%%%%##%%%\\u0026%%%%%%%%\\u0026%%#%%\\u0026\\u0026%%%%\\u0026%%%%%%\\u0026%%%%%\\u0026(#%%%#,\\n//              ./%\\u0026%%%%%%%%%%%%%%%%%%%%%%%%%\\u0026\\u0026\\u0026%%%##%%%%%%%%%%%%%\\u0026\\u0026\\u0026%%%%%%%%\\u0026#.//*/,..\\n//      ,#%%%%%%%%%%%%%%%%%%\\u0026\\u0026%%%%%\\u0026\\u0026\\u0026\\u0026%%%%%\\u0026\\u0026\\u0026%%%%%#%%%%#%%%%%%%%%%%%%%%%%%%%%%%%%%\\u0026\\u0026(,..\\n//            ,#* ,\\u0026\\u0026\\u0026%,.,*(%%%%%%%%%\\u0026%%%%\\u0026\\u0026\\u0026%%%%%\\u0026%%%%#%%%%##%%%%%%%\\u0026\\u0026%%%%%%%%%%%#%%%%%%%%\\u0026%(*.\\n//          .,,/((#%\\u0026%#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\u0026\\u0026\\u0026\\u0026\\u0026%#%%%%%%%%%%%%%%%%%#%%%%%%%((*\\n// *,//**,...,/#%%%%%%%%%%%\\u0026\\u0026\\u0026\\u0026%%%%%%%%%%%%%#%%%%%%\\u0026\\u0026\\u0026%%%%\\u0026\\u0026\\u0026\\u0026%%%#%%#%%%%%%%%%%%%%%%#*.       .,(#%\\u0026@*\\n//  .*%%(*(%%%%%%%%%%\\u0026\\u0026\\u0026\\u0026\\u0026\\u0026\\u0026\\u0026%%%%%%%\\u0026\\u0026%%%%%%%%%%%%%\\u0026\\u0026\\u0026%%%%%%%%%##%%%%%%%%%%%%%%%%%%%%%%%%%%%\\u0026%%%/..\\n//      .,/%\\u0026%%%%%%@#(\\u0026%\\u0026%%%%%%%%%#\\u0026\\u0026%%##%#%%%#%%%%\\u0026\\u0026\\u0026%%%%%%%%###%%%%%\\u0026\\u0026\\u0026%%%%%%%%%%%%%%%%\\u0026(//%%/\\n//          ,..     .(%%%%##%%%#%%%%%%#%%%%%##%%%%%\\u0026\\u0026\\u0026\\u0026%%%%%%%#\\u0026%#%%%%%%\\u0026\\u0026\\u0026%%%%%##//  ,,.\\n//            .,(%#%%##%%%#%%%#%%%#%%*,.*%%%%%%%%%\\u0026.,/\\u0026%%%%%%% #\\u0026%%#%%%%%\\u0026%(\\u0026%((%\\u0026\\u0026\\u0026(*\\n//                        ,/#/(%%,    ,\\u0026%%#%/.//         %*\\u0026(%#    .(,(%%%.\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n// File: contracts/libs/ECDSA.sol\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 \\u003c s \\u003c secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (\\n            uint256(s) \\u003e\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) {\\n            revert(\\\"ECDSA: invalid signature \\u0027s\\u0027 value\\\");\\n        }\\n\\n        if (v != 27 \\u0026\\u0026 v != 28) {\\n            revert(\\\"ECDSA: invalid signature \\u0027v\\u0027 value\\\");\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n            );\\n    }\\n}\\n\\n// File: contracts/interfaces/IERC20.sol\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n// File: contracts/libs/Fabric.sol\\n\\n/**\\n * @title Fabric\\n * @dev Create deterministics vaults.\\n *\\n * Original work by Pine.Finance\\n * - https://github.com/pine-finance\\n *\\n * Authors:\\n * - Agustin Aguilar \\u003cagusx1211\\u003e\\n * - Ignacio Mazzara \\u003cnachomazzara\\u003e\\n */\\nlibrary Fabric {\\n    /*Vault bytecode\\n\\n        def _fallback() payable:\\n            call cd[56] with:\\n                funct call.data[0 len 4]\\n                gas cd[56] wei\\n                args call.data[4 len 64]\\n            selfdestruct(tx.origin)\\n\\n        // Constructor bytecode\\n        0x6012600081600A8239f3\\n\\n        0x60 12 - PUSH1 12           // Size of the contract to return\\n        0x60 00 - PUSH1 00           // Memory offset to return stored code\\n        0x81    - DUP2  12           // Size of code to copy\\n        0x60 0a - PUSH1 0A           // Start of the code to copy\\n        0x82    - DUP3  00           // Dest memory for code copy\\n        0x39    - CODECOPY 00 0A 12  // Code copy to memory\\n        0xf3    - RETURN 00 12       // Return code to store\\n\\n        // Deployed contract bytecode\\n        0x60008060448082803781806038355AF132FF\\n\\n        0x60 00 - PUSH1 00                    // Size for the call output\\n        0x80    - DUP1  00                    // Offset for the call output\\n        0x60 44 - PUSH1 44                    // Size for the call input\\n        0x80    - DUP1  44                    // Size for copying calldata to memory\\n        0x82    - DUP3  00                    // Offset for calldata copy\\n        0x80    - DUP1  00                    // Offset for destination of calldata copy\\n        0x37    - CALLDATACOPY 00 00 44       // Execute calldata copy, is going to be used for next call\\n        0x81    - DUP2  00                    // Offset for call input\\n        0x80    - DUP1  00                    // Amount of ETH to send during call\\n        0x60 38 - PUSH1 38                    // calldata pointer to load value into stack\\n        0x35    - CALLDATALOAD 38 (A)         // Load value (A), address to call\\n        0x5a    - GAS                         // Remaining gas\\n        0xf1    - CALL (A) (A) 00 00 44 00 00 // Execute call to address (A) with calldata mem[0:64]\\n        0x32    - ORIGIN (B)                  // Dest funds for selfdestruct\\n        0xff    - SELFDESTRUCT (B)            // selfdestruct contract, end of execution\\n    */\\n    bytes public constant code =\\n        hex\\\"6012600081600A8239F360008060448082803781806038355AF132FF\\\";\\n    bytes32 public constant vaultCodeHash =\\n        bytes32(\\n            0xfa3da1081bc86587310fce8f3a5309785fc567b9b20875900cb289302d6bfa97\\n        );\\n\\n    /**\\n     * @dev Get a deterministics vault.\\n     */\\n    function getVault(bytes32 _key) internal view returns (address) {\\n        return\\n            address(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(this),\\n                            _key,\\n                            vaultCodeHash\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Create deterministic vault.\\n     */\\n    function executeVault(\\n        bytes32 _key,\\n        IERC20 _token,\\n        address _to\\n    ) internal returns (uint256 value) {\\n        address addr;\\n        bytes memory slotcode = code;\\n\\n        /* solium-disable-next-line */\\n        assembly {\\n            // Create the contract arguments for the constructor\\n            addr := create2(0, add(slotcode, 0x20), mload(slotcode), _key)\\n        }\\n\\n        value = _token.balanceOf(addr);\\n        /* solium-disable-next-line */\\n        (bool success, ) =\\n            addr.call(\\n                abi.encodePacked(\\n                    abi.encodeWithSelector(\\n                        _token.transfer.selector,\\n                        _to,\\n                        value\\n                    ),\\n                    address(_token)\\n                )\\n            );\\n\\n        require(success, \\\"Error pulling tokens\\\");\\n    }\\n}\\n\\n// File: contracts/interfaces/IModule.sol\\n\\n/**\\n * Original work by Pine.Finance\\n * - https://github.com/pine-finance\\n *\\n * Authors:\\n * - Ignacio Mazzara \\u003cnachomazzara\\u003e\\n * - Agustin Aguilar \\u003cagusx1211\\u003e\\n */\\ninterface IModule {\\n    /// @notice receive ETH\\n    receive() external payable;\\n\\n    /**\\n     * @notice Executes an order\\n     * @param _inputToken - Address of the input token\\n     * @param _inputAmount - uint256 of the input token amount (order amount)\\n     * @param _owner - Address of the order\\u0027s owner\\n     * @param _data - Bytes of the order\\u0027s data\\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\\n     * @return bought - amount of output token bought\\n     */\\n    function execute(\\n        IERC20 _inputToken,\\n        uint256 _inputAmount,\\n        address payable _owner,\\n        bytes calldata _data,\\n        bytes calldata _auxData\\n    ) external returns (uint256 bought);\\n\\n    /**\\n     * @notice Check whether an order can be executed or not\\n     * @param _inputToken - Address of the input token\\n     * @param _inputAmount - uint256 of the input token amount (order amount)\\n     * @param _data - Bytes of the order\\u0027s data\\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\\n     * @return bool - whether the order can be executed or not\\n     */\\n    function canExecute(\\n        IERC20 _inputToken,\\n        uint256 _inputAmount,\\n        bytes calldata _data,\\n        bytes calldata _auxData\\n    ) external view returns (bool);\\n}\\n\\n// File: contracts/commons/Order.sol\\n\\ncontract Order {\\n    address public constant ETH_ADDRESS =\\n        address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\\n}\\n\\n// File: contracts/PineCore.sol\\n\\n/**\\n * Original work by Pine.Finance\\n * - https://github.com/pine-finance\\n *\\n * Authors:\\n * - Ignacio Mazzara \\u003cnachomazzara\\u003e\\n * - Agustin Aguilar \\u003cagusx1211\\u003e\\n */\\nabstract contract PineCore is Order {\\n    using SafeMath for uint256;\\n    using Fabric for bytes32;\\n\\n    // ETH orders\\n    mapping(bytes32 =\\u003e uint256) public ethDeposits;\\n\\n    // Events\\n    event DepositETH(\\n        bytes32 indexed _key,\\n        address indexed _caller,\\n        uint256 _amount,\\n        bytes _data\\n    );\\n\\n    event OrderExecuted(\\n        bytes32 indexed _key,\\n        address _inputToken,\\n        address _owner,\\n        address _witness,\\n        bytes _data,\\n        bytes _auxData,\\n        uint256 _amount,\\n        uint256 _bought\\n    );\\n\\n    event OrderCancelled(\\n        bytes32 indexed _key,\\n        address _inputToken,\\n        address _owner,\\n        address _witness,\\n        bytes _data,\\n        uint256 _amount\\n    );\\n\\n    /**\\n     * @dev Prevent users to send Ether directly to this contract\\n     */\\n    receive() external payable {\\n        require(\\n            msg.sender != tx.origin,\\n            \\\"PineCore#receive: NO_SEND_ETH_PLEASE\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Create an ETH to token order\\n     * @param _data - Bytes of an ETH to token order. See `encodeEthOrder` for more info\\n     */\\n    function depositEth(bytes calldata _data) external payable {\\n        require(msg.value \\u003e 0, \\\"PineCore#depositEth: VALUE_IS_0\\\");\\n\\n        (\\n            address module,\\n            address inputToken,\\n            address payable owner,\\n            address witness,\\n            bytes memory data,\\n\\n        ) = decodeOrder(_data);\\n\\n        require(\\n            inputToken == ETH_ADDRESS,\\n            \\\"PineCore#depositEth: WRONG_INPUT_TOKEN\\\"\\n        );\\n\\n        bytes32 key =\\n            keyOf(\\n                IModule(uint160(module)),\\n                IERC20(inputToken),\\n                owner,\\n                witness,\\n                data\\n            );\\n\\n        ethDeposits[key] = ethDeposits[key].add(msg.value);\\n        emit DepositETH(key, msg.sender, msg.value, _data);\\n    }\\n\\n    /**\\n     * @notice Cancel order\\n     * @dev The params should be the same used for the order creation\\n     * @param _module - Address of the module to use for the order execution\\n     * @param _inputToken - Address of the input token\\n     * @param _owner - Address of the order\\u0027s owner\\n     * @param _witness - Address of the witness\\n     * @param _data - Bytes of the order\\u0027s data\\n     */\\n    function cancelOrder(\\n        IModule _module,\\n        IERC20 _inputToken,\\n        address payable _owner,\\n        address _witness,\\n        bytes calldata _data\\n    ) external {\\n        require(msg.sender == _owner, \\\"PineCore#cancelOrder: INVALID_OWNER\\\");\\n        bytes32 key = keyOf(_module, _inputToken, _owner, _witness, _data);\\n\\n        uint256 amount = _pullOrder(_inputToken, key, msg.sender);\\n\\n        emit OrderCancelled(\\n            key,\\n            address(_inputToken),\\n            _owner,\\n            _witness,\\n            _data,\\n            amount\\n        );\\n    }\\n\\n    /**\\n     * @notice Get the calldata needed to create a token to token/ETH order\\n     * @dev Returns the input data that the user needs to use to create the order\\n     * The _secret is used to prevent a front-running at the order execution\\n     * The _amount is used as the param `_value` for the ERC20 `transfer` function\\n     * @param _module - Address of the module to use for the order execution\\n     * @param _inputToken - Address of the input token\\n     * @param _owner - Address of the order\\u0027s owner\\n     * @param _witness - Address of the witness\\n     * @param _data - Bytes of the order\\u0027s data\\n     * @param _secret - Private key of the _witness\\n     * @param _amount - uint256 of the order amount\\n     * @return bytes - input data to send the transaction\\n     */\\n    function encodeTokenOrder(\\n        IModule _module,\\n        IERC20 _inputToken,\\n        address payable _owner,\\n        address _witness,\\n        bytes calldata _data,\\n        bytes32 _secret,\\n        uint256 _amount\\n    ) external view returns (bytes memory) {\\n        return\\n            abi.encodeWithSelector(\\n                _inputToken.transfer.selector,\\n                vaultOfOrder(_module, _inputToken, _owner, _witness, _data),\\n                _amount,\\n                abi.encode(\\n                    _module,\\n                    _inputToken,\\n                    _owner,\\n                    _witness,\\n                    _data,\\n                    _secret\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Get the calldata needed to create a ETH to token order\\n     * @dev Returns the input data that the user needs to use to create the order\\n     * The _secret is used to prevent a front-running at the order execution\\n     * @param _module - Address of the module to use for the order execution\\n     * @param _inputToken - Address of the input token\\n     * @param _owner - Address of the order\\u0027s owner\\n     * @param _witness - Address of the witness\\n     * @param _data - Bytes of the order\\u0027s data\\n     * @param _secret -  Private key of the _witness\\n     * @return bytes - input data to send the transaction\\n     */\\n    function encodeEthOrder(\\n        address _module,\\n        address _inputToken,\\n        address payable _owner,\\n        address _witness,\\n        bytes calldata _data,\\n        bytes32 _secret\\n    ) external pure returns (bytes memory) {\\n        return\\n            abi.encode(_module, _inputToken, _owner, _witness, _data, _secret);\\n    }\\n\\n    /**\\n     * @notice Get order\\u0027s properties\\n     * @param _data - Bytes of the order\\n     * @return module - Address of the module to use for the order execution\\n     * @return inputToken - Address of the input token\\n     * @return owner - Address of the order\\u0027s owner\\n     * @return witness - Address of the witness\\n     * @return data - Bytes of the order\\u0027s data\\n     * @return secret -  Private key of the _witness\\n     */\\n    function decodeOrder(bytes memory _data)\\n        public\\n        pure\\n        returns (\\n            address module,\\n            address inputToken,\\n            address payable owner,\\n            address witness,\\n            bytes memory data,\\n            bytes32 secret\\n        )\\n    {\\n        (module, inputToken, owner, witness, data, secret) = abi.decode(\\n            _data,\\n            (address, address, address, address, bytes, bytes32)\\n        );\\n    }\\n\\n    /**\\n     * @notice Get the vault\\u0027s address of a token to token/ETH order\\n     * @param _module - Address of the module to use for the order execution\\n     * @param _inputToken - Address of the input token\\n     * @param _owner - Address of the order\\u0027s owner\\n     * @param _witness - Address of the witness\\n     * @param _data - Bytes of the order\\u0027s data\\n     * @return address - The address of the vault\\n     */\\n    function vaultOfOrder(\\n        IModule _module,\\n        IERC20 _inputToken,\\n        address payable _owner,\\n        address _witness,\\n        bytes memory _data\\n    ) public view returns (address) {\\n        return keyOf(_module, _inputToken, _owner, _witness, _data).getVault();\\n    }\\n\\n    /**\\n     * @notice Executes an order\\n     * @dev The sender should use the _secret to sign its own address\\n     * to prevent front-runnings\\n     * @param _module - Address of the module to use for the order execution\\n     * @param _inputToken - Address of the input token\\n     * @param _owner - Address of the order\\u0027s owner\\n     * @param _data - Bytes of the order\\u0027s data\\n     * @param _signature - Signature to calculate the witness\\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\\n     */\\n    function executeOrder(\\n        IModule _module,\\n        IERC20 _inputToken,\\n        address payable _owner,\\n        bytes calldata _data,\\n        bytes calldata _signature,\\n        bytes calldata _auxData\\n    ) public virtual {\\n        // Calculate witness using signature\\n        address witness =\\n            ECDSA.recover(keccak256(abi.encodePacked(msg.sender)), _signature);\\n\\n        bytes32 key = keyOf(_module, _inputToken, _owner, witness, _data);\\n\\n        // Pull amount\\n        uint256 amount = _pullOrder(_inputToken, key, address(_module));\\n        require(amount \\u003e 0, \\\"PineCore#executeOrder: INVALID_ORDER\\\");\\n\\n        uint256 bought =\\n            _module.execute(_inputToken, amount, _owner, _data, _auxData);\\n\\n        emit OrderExecuted(\\n            key,\\n            address(_inputToken),\\n            _owner,\\n            witness,\\n            _data,\\n            _auxData,\\n            amount,\\n            bought\\n        );\\n    }\\n\\n    /**\\n     * @notice Check whether an order exists or not\\n     * @dev Check the balance of the order\\n     * @param _module - Address of the module to use for the order execution\\n     * @param _inputToken - Address of the input token\\n     * @param _owner - Address of the order\\u0027s owner\\n     * @param _witness - Address of the witness\\n     * @param _data - Bytes of the order\\u0027s data\\n     * @return bool - whether the order exists or not\\n     */\\n    function existOrder(\\n        IModule _module,\\n        IERC20 _inputToken,\\n        address payable _owner,\\n        address _witness,\\n        bytes calldata _data\\n    ) external view returns (bool) {\\n        bytes32 key = keyOf(_module, _inputToken, _owner, _witness, _data);\\n\\n        if (address(_inputToken) == ETH_ADDRESS) {\\n            return ethDeposits[key] != 0;\\n        } else {\\n            return _inputToken.balanceOf(key.getVault()) != 0;\\n        }\\n    }\\n\\n    /**\\n     * @notice Check whether an order can be executed or not\\n     * @param _module - Address of the module to use for the order execution\\n     * @param _inputToken - Address of the input token\\n     * @param _owner - Address of the order\\u0027s owner\\n     * @param _witness - Address of the witness\\n     * @param _data - Bytes of the order\\u0027s data\\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\\n     * @return bool - whether the order can be executed or not\\n     */\\n    function canExecuteOrder(\\n        IModule _module,\\n        IERC20 _inputToken,\\n        address payable _owner,\\n        address _witness,\\n        bytes calldata _data,\\n        bytes calldata _auxData\\n    ) external view returns (bool) {\\n        bytes32 key = keyOf(_module, _inputToken, _owner, _witness, _data);\\n\\n        // Pull amount\\n        uint256 amount;\\n        if (address(_inputToken) == ETH_ADDRESS) {\\n            amount = ethDeposits[key];\\n        } else {\\n            amount = _inputToken.balanceOf(key.getVault());\\n        }\\n\\n        return _module.canExecute(_inputToken, amount, _data, _auxData);\\n    }\\n\\n    /**\\n     * @notice Transfer the order amount to a recipient.\\n     * @dev For an ETH order, the ETH will be transferred from this contract\\n     * For a token order, its vault will be executed transferring the amount of tokens to\\n     * the recipient\\n     * @param _inputToken - Address of the input token\\n     * @param _key - Order\\u0027s key\\n     * @param _to - Address of the recipient\\n     * @return amount - amount transferred\\n     */\\n    function _pullOrder(\\n        IERC20 _inputToken,\\n        bytes32 _key,\\n        address payable _to\\n    ) private returns (uint256 amount) {\\n        if (address(_inputToken) == ETH_ADDRESS) {\\n            amount = ethDeposits[_key];\\n            ethDeposits[_key] = 0;\\n            (bool success, ) = _to.call{value: amount}(\\\"\\\");\\n            require(success, \\\"PineCore#_pullOrder: PULL_ETHER_FAILED\\\");\\n        } else {\\n            amount = _key.executeVault(_inputToken, _to);\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the order\\u0027s key\\n     * @param _module - Address of the module to use for the order execution\\n     * @param _inputToken - Address of the input token\\n     * @param _owner - Address of the order\\u0027s owner\\n     * @param _witness - Address of the witness\\n     * @param _data - Bytes of the order\\u0027s data\\n     * @return bytes32 - order\\u0027s key\\n     */\\n    function keyOf(\\n        IModule _module,\\n        IERC20 _inputToken,\\n        address payable _owner,\\n        address _witness,\\n        bytes memory _data\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(_module, _inputToken, _owner, _witness, _data)\\n            );\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gelato\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"DepositETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_auxData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_bought\",\"type\":\"uint256\"}],\"name\":\"OrderExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GELATO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_auxData\",\"type\":\"bytes\"}],\"name\":\"canExecuteOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"decodeOrder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"depositEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"encodeEthOrder\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"encodeTokenOrder\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ethDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_auxData\",\"type\":\"bytes\"}],\"name\":\"executeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"existOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"keyOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IModule\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_witness\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"vaultOfOrder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GelatoPineCore", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007598e84b2e114ab62cab288ce5f7d5f6bad35bba", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://39c94aae189c78d2bbe1139a3c9dcaf0c37268b05ac68626127e715bf1466ab5"}