{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BLK.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"solady/src/tokens/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ncontract BLK is ERC20, Ownable, Pausable {\\n    enum Roles {\\n        None,\\n        Whitelisted,\\n        Shop // A shop account counts also as whitelisted\\n    }\\n\\n    struct Account {\\n        uint256 lockedBalance;\\n        Roles role;\\n        uint256 conversionRate;\\n    }\\n\\n    mapping(address => Account) public accounts;\\n\\n    event AddedToWhitelist(address indexed account);\\n    event RemovedFromWhitelist(address indexed account);\\n    event AddedToShops(address indexed account);\\n    event RemovedFromShops(address indexed account);\\n    error NotWhitelisted(address account);\\n    //error AlreadyWhitelisted(address account);\\n    //error NotShop(address account);\\n    //error AlreadyShop(address account);\\n    error NotEnoughLockedBalance(address account);\\n    error NotEnoughUnlockedBalance(address account);\\n    error SelfTransfer(address from, address to);\\n    error ZeroAddress();\\n    error ZeroAmount();\\n\\n    constructor() ERC20() {\\n        addWhitelisted(0x0000000000000000000000000000000000000000);\\n        addWhitelisted(msg.sender);\\n    }\\n\\n    function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n) internal override whenNotPaused {\\n    if (to == from) revert SelfTransfer(from, to);\\n    \\n    Roles fromRole = accounts[from].role;\\n    Roles toRole = accounts[to].role;\\n    \\n    if (fromRole == Roles.None) revert NotWhitelisted(from);\\n    if (toRole == Roles.None) revert NotWhitelisted(to);\\n\\n    if (from != address(0) && toRole == Roles.Shop) {\\n        Account storage toAccount = accounts[to];\\n        if (toAccount.lockedBalance < amount)\\n            revert NotEnoughLockedBalance(to);\\n    }\\n\\n    super._beforeTokenTransfer(from, to, amount);\\n}\\n\\nfunction _afterTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n) internal override whenNotPaused {\\n    if (from != address(0) && isShop(to)) {\\n        Account storage toAccount = accounts[to];\\n        uint256 unlockedBalance = amount * toAccount.conversionRate;\\n        uint256 lockedBalance = toAccount.lockedBalance;\\n        \\n        if (lockedBalance < unlockedBalance)\\n            revert NotEnoughLockedBalance(to);\\n        \\n        unchecked {\\n            lockedBalance -= unlockedBalance;\\n        }\\n        \\n        toAccount.lockedBalance = lockedBalance;\\n        _mint(to, unlockedBalance);\\n    }\\n\\n    super._afterTokenTransfer(from, to, amount);\\n}\\n\\n\\n    function addWhitelisted(address _addr) public onlyOwner {\\n        // if(isWhitelisted(_addr)) revert AlreadyWhitelisted(_addr);\\n        accounts[_addr].role = Roles.Whitelisted;\\n        emit AddedToWhitelist(_addr);\\n    }\\n\\n    function removeWhitelisted(address _addr) public onlyOwner {\\n        // if(!isWhitelisted(_addr)) revert NotWhitelisted(_addr);\\n        accounts[_addr].role = Roles.None;\\n        emit RemovedFromWhitelist(_addr);\\n    }\\n\\n    function isWhitelisted(address _addr) public view returns (bool) {\\n        // An account is whitelisted if it is a shop or a whitelisted account\\n        return accounts[_addr].role != Roles.None;\\n    }\\n\\n    function addShop(address _addr) external onlyOwner {\\n        // if(!isShop(_addr)) revert alreadyShop(_addr);\\n        Account storage account = accounts[_addr];\\n        account.role = Roles.Shop;\\n        account.conversionRate = 2;\\n        emit AddedToShops(_addr);\\n    }\\n\\n    function removeShop(address _addr) external onlyOwner {\\n        // if(isShop(_addr)) revert NotShop(_addr);\\n        accounts[_addr].role = Roles.None;\\n        accounts[_addr].conversionRate = 1;\\n        emit RemovedFromShops(_addr);\\n    }\\n\\n    function isShop(address _addr) public view returns (bool) {\\n        return accounts[_addr].role == Roles.Shop;\\n    }\\n\\n    function getConversionRate(address _addr) external view returns (uint256) {\\n        return accounts[_addr].conversionRate;\\n    }\\n\\n    function setConversionRate(address _addr, uint256 _rate)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        accounts[_addr].conversionRate = _rate;\\n        return true;\\n    }\\n\\n    function balanceLockedOf(address _addr) external view returns (uint256) {\\n        return accounts[_addr].lockedBalance;\\n    }\\n\\n    function mintLocked(address _addr, uint256 amount)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        accounts[_addr].lockedBalance += amount;\\n        return true;\\n    }\\n\\n    function mint(address to, uint256 amount) external onlyOwner {\\n        _mint(to, amount);\\n    }\\n\\n    /* openzeppelin ERC20Burnable */\\n    function burn(uint256 amount) external virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    function burnFrom(address account, uint256 amount) external virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n\\n    /* admin functions */\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    \\n\\n    /* pure functions */\\n    function decimals() public pure override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function name() public pure override returns (string memory) {\\n        return \\\"Blockeras\\\";\\n    }\\n\\n    function symbol() public pure override returns (string memory) {\\n        return \\\"BLK\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC20 + EIP-2612 implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\\nabstract contract ERC20 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The total supply has overflowed.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev The allowance has overflowed.\\n    error AllowanceOverflow();\\n\\n    /// @dev The allowance has underflowed.\\n    error AllowanceUnderflow();\\n\\n    /// @dev Insufficient balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev The permit is invalid.\\n    error InvalidPermit();\\n\\n    /// @dev The permit has expired.\\n    error PermitExpired();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The storage slot for the total supply.\\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\\n\\n    /// @dev The balance slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\\n\\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\\n    /// ```\\n    ///     mstore(0x20, spender)\\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\\n    /// ```\\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\\n\\n    /// @dev The nonce slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ERC20 METADATA                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the decimals places of the token.\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           ERC20                            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_TOTAL_SUPPLY_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Atomically increases the allowance granted to `spender` by the caller.\\n    ///\\n    /// Emits a {Approval} event.\\n    function increaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowanceBefore := sload(allowanceSlot)\\n            // Add to the allowance.\\n            let allowanceAfter := add(allowanceBefore, difference)\\n            // Revert upon overflow.\\n            if lt(allowanceAfter, allowanceBefore) {\\n                mstore(0x00, 0xf9067066) // `AllowanceOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated allowance.\\n            sstore(allowanceSlot, allowanceAfter)\\n            // Emit the {Approval} event.\\n            mstore(0x00, allowanceAfter)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Atomically decreases the allowance granted to `spender` by the caller.\\n    ///\\n    /// Emits a {Approval} event.\\n    function decreaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowanceBefore := sload(allowanceSlot)\\n            // Revert if will underflow.\\n            if lt(allowanceBefore, difference) {\\n                mstore(0x00, 0x8301ab38) // `AllowanceUnderflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated allowance.\\n            let allowanceAfter := sub(allowanceBefore, difference)\\n            sstore(allowanceSlot, allowanceAfter)\\n            // Emit the {Approval} event.\\n            mstore(0x00, allowanceAfter)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(msg.sender, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, caller())\\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if iszero(eq(allowance_, not(0))) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          EIP-2612                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the current nonce for `owner`.\\n    /// This value is used to compute the signature for EIP-2612 permit.\\n    function nonces(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\\n    /// authorized by a signed approval by `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        bytes32 domainSeparator = DOMAIN_SEPARATOR();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            let m := mload(0x40)\\n            // Revert if the block timestamp greater than `deadline`.\\n            if gt(timestamp(), deadline) {\\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Clean the upper 96 bits.\\n            owner := shr(96, shl(96, owner))\\n            spender := shr(96, shl(96, spender))\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            let nonceValue := sload(nonceSlot)\\n            // Increment and store the updated nonce.\\n            sstore(nonceSlot, add(nonceValue, 1))\\n            // Prepare the inner hash.\\n            // `keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")`.\\n            // forgefmt: disable-next-item\\n            mstore(m, 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9)\\n            mstore(add(m, 0x20), owner)\\n            mstore(add(m, 0x40), spender)\\n            mstore(add(m, 0x60), value)\\n            mstore(add(m, 0x80), nonceValue)\\n            mstore(add(m, 0xa0), deadline)\\n            // Prepare the outer hash.\\n            mstore(0, 0x1901)\\n            mstore(0x20, domainSeparator)\\n            mstore(0x40, keccak256(m, 0xc0))\\n            // Prepare the ecrecover calldata.\\n            mstore(0, keccak256(0x1e, 0x42))\\n            mstore(0x20, and(0xff, v))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            pop(staticcall(gas(), 1, 0, 0x80, 0x20, 0x20))\\n            // If the ecrecover fails, the returndatasize will be 0x00,\\n            // `owner` will be be checked if it equals the hash at 0x00,\\n            // which evaluates to false (i.e. 0), and we will revert.\\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\\n            // `owner` will be compared against the returned address at 0x20.\\n            if iszero(eq(mload(returndatasize()), owner)) {\\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Compute the allowance slot and store the value.\\n            // The `owner` is already at slot 0x20.\\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\\n            sstore(keccak256(0x2c, 0x34), value)\\n            // Emit the {Approval} event.\\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the EIP-2612 domains separator.\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40) // Grab the free memory pointer.\\n        }\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        bytes32 nameHash = keccak256(bytes(name()));\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := result\\n            // `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n            // forgefmt: disable-next-item\\n            mstore(m, 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f)\\n            mstore(add(m, 0x20), nameHash)\\n            // `keccak256(\\\"1\\\")`.\\n            // forgefmt: disable-next-item\\n            mstore(add(m, 0x40), 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            result := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\\n            // Revert if the total supply overflows.\\n            if lt(totalSupplyAfter, totalSupplyBefore) {\\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(address(0), to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, address(0), amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, from)\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Subtract and store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\\n        }\\n        _afterTokenTransfer(from, address(0), amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if iszero(eq(allowance_, not(0))) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let owner_ := shl(96, owner)\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HOOKS TO OVERRIDE                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Hook that is called before any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /// @dev Hook that is called after any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": false,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AllowanceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AllowanceUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPermit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NotEnoughLockedBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NotEnoughUnlockedBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NotWhitelisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermitExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SelfTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddedToShops\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemovedFromShops\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedBalance\",\"type\":\"uint256\"},{\"internalType\":\"enum BLK.Roles\",\"name\":\"role\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"conversionRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addShop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceLockedOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"difference\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getConversionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"difference\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isShop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeShop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setConversionRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BLK", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}