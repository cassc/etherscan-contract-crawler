{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PaymentProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./IOwnable.sol\\\";\\nimport \\\"./IPaymentProcessor.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC1271.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n/**\\n * @title  PaymentProcessor\\n * @author Limit Break, Inc.\\n * @notice The world's first ERC721-C compatible marketplace contract!  \\n * @notice Use ERC721-C to whitelist this contract or other marketplace contracts that process royalties entirely \\n *         on-chain manner to make them 100% enforceable and fully programmable! \\n *\\n * @notice <h4>Features</h4>\\n *\\n * @notice <ul>\\n *            <li>Creator Defined Security Profiles</li>\\n *            <ul>\\n *             <li>Exchange Whitelist On/Off</li>\\n *             <li>Payment Method Whitelist On/Off</li>\\n *             <li>Pricing Constraints On/Off</li>\\n *             <li>Private Sales On/Off</li>\\n *             <li>Delegate Purchase Wallets On/Off</li>\\n *             <li>Smart Contract Buyers/Sellers On/Off</li>\\n *             <li>Exchange Whitelist Bypass for EOAs On/Off</li>\\n *            </ul>\\n *           <li>Enforceable/Programmable Fees</li>\\n *           <ul>\\n *             <li>Built-in EIP-2981 Royalty Enforcement</li>\\n *             <li>Built-in Marketplace Fee Enforcement</li>\\n *           </ul>\\n *           <li>Multi-Standard Support</li>\\n *           <ul>\\n *             <li>ERC721-C</li>\\n *             <li>ERC1155-C</li>\\n *             <li>ERC721 + EIP-2981</li>\\n *             <li>ERC1155 + EIP-2981</li>\\n *           </ul>\\n *           <li>Payments</li>\\n *           <ul>\\n *             <li>Native Currency (ETH or Equivalent)</li>\\n *             <li>ERC-20 Coin Payments</li>\\n *           </ul>\\n *           <li>A Multitude of Supported Sale Types</li>\\n *           <ul>\\n *             <li>Buy Single Listing</li>\\n *             <ul>\\n *               <li>Collection-Level Offers</li>\\n *               <li>Item-Specific Offers</li>\\n *             </ul>\\n *             <li>Buy Batch of Listings (Shopping Cart)</li>\\n *             <li>Buy Bundled Listing (From One Collection)</li>\\n *             <li>Sweep Listings (From One Collection)</li>\\n *             <li>Partial Order Fills (When ERC-20 Payment Method Is Used)</li>\\n *           </ul>\\n *         </ul>\\n *\\n * @notice <h4>Security Considerations for Users</h4>\\n *\\n * @notice Virtually all on-chain marketplace contracts have the potential to be front-run.\\n *         When purchasing high-value items, whether individually or in a batch/bundle it is highly\\n *         recommended to execute transactions using Flashbots RPC Relay/private mempool to avoid\\n *         sniper bots.  Partial fills are available for batched purchases, bundled listing purchases,\\n *         and collection sweeps when the method of payment is an ERC-20 token, but not for purchases\\n *         using native currency.  It is preferable to use wrapped ETH (or equivalent) when buying\\n *         multiple tokens and it is highly advisable to use Flashbots whenever possible.  [Read the\\n *         quickstart guide for more information](https://docs.flashbots.net/flashbots-protect/rpc/quick-start).\\n */\\ncontract PaymentProcessor is ERC165, EIP712, Ownable, Pausable, IPaymentProcessor {\\n\\n    error PaymentProcessor__AddressCannotBeZero();\\n    error PaymentProcessor__AmountForERC721SalesMustEqualOne();\\n    error PaymentProcessor__AmountForERC1155SalesGreaterThanZero();\\n    error PaymentProcessor__BundledOfferPriceMustEqualSumOfAllListingPrices();\\n    error PaymentProcessor__BuyerDidNotAuthorizePurchase();\\n    error PaymentProcessor__BuyerMustBeDesignatedPrivateBuyer();\\n    error PaymentProcessor__CallerDoesNotOwnSecurityPolicy();\\n    error PaymentProcessor__CallerIsNotTheDelegatedPurchaser();\\n    error PaymentProcessor__CallerIsNotWhitelistedMarketplace();\\n    error PaymentProcessor__CallerMustHaveElevatedPermissionsForSpecifiedNFT();\\n    error PaymentProcessor__CannotIncludeNativeFundsWhenPaymentMethodIsAnERC20Coin();\\n    error PaymentProcessor__CeilingPriceMustBeGreaterThanFloorPrice();\\n    error PaymentProcessor__CoinDoesNotImplementDecimalsAndLikelyIsNotAnERC20Token();\\n    error PaymentProcessor__CoinIsApproved();\\n    error PaymentProcessor__CoinIsNotApproved();\\n    error PaymentProcessor__CollectionLevelOrItemLevelOffersCanOnlyBeMadeUsingERC20PaymentMethods();\\n    error PaymentProcessor__DispensingTokenWasUnsuccessful();\\n    error PaymentProcessor__EIP1271SignaturesAreDisabled();\\n    error PaymentProcessor__EIP1271SignatureInvalid();\\n    error PaymentProcessor__ExchangeIsWhitelisted();\\n    error PaymentProcessor__ExchangeIsNotWhitelisted();\\n    error PaymentProcessor__FailedToTransferProceeds();\\n    error PaymentProcessor__InputArrayLengthCannotBeZero();\\n    error PaymentProcessor__InputArrayLengthMismatch();\\n    error PaymentProcessor__MarketplaceAndRoyaltyFeesWillExceedSalePrice();\\n    error PaymentProcessor__NativeCurrencyIsNotAnApprovedPaymentMethod();\\n    error PaymentProcessor__OfferHasExpired();\\n    error PaymentProcessor__OfferPriceMustEqualSalePrice();\\n    error PaymentProcessor__OnchainRoyaltiesExceedMaximumApprovedRoyaltyFee();\\n    error PaymentProcessor__OverpaidNativeFunds();\\n    error PaymentProcessor__PaymentCoinIsNotAnApprovedPaymentMethod();\\n    error PaymentProcessor__PricingBoundsAreImmutable();\\n    error PaymentProcessor__RanOutOfNativeFunds();\\n    error PaymentProcessor__SaleHasExpired();\\n    error PaymentProcessor__SalePriceAboveMaximumCeiling();\\n    error PaymentProcessor__SalePriceBelowMinimumFloor();\\n    error PaymentProcessor__SalePriceBelowSellerApprovedMinimum();\\n    error PaymentProcessor__SecurityPolicyDoesNotExist();\\n    error PaymentProcessor__SecurityPolicyOwnershipCannotBeTransferredToZeroAddress();\\n    error PaymentProcessor__SellerDidNotAuthorizeSale();\\n    error PaymentProcessor__SignatureAlreadyUsedOrRevoked();\\n    error PaymentProcessor__TokenSecurityPolicyDoesNotAllowDelegatedPurchases();\\n    error PaymentProcessor__TokenSecurityPolicyDoesNotAllowEOACallers();\\n    error PaymentProcessor__TokenSecurityPolicyDoesNotAllowPrivateListings();\\n\\n    /// @dev Convenience to avoid magic number in bitmask get/set logic.\\n    uint256 private constant ONE = uint256(1);\\n\\n    /// @notice The default admin role for NFT collections using Access Control.\\n    bytes32 private constant DEFAULT_ACCESS_CONTROL_ADMIN_ROLE = 0x00;\\n\\n    /// @notice The default security policy id.\\n    uint256 public constant DEFAULT_SECURITY_POLICY_ID = 0;\\n\\n    /// @notice The denominator used when calculating the marketplace fee.\\n    /// @dev    0.5% fee numerator is 50, 1% fee numerator is 100, 10% fee numerator is 1,000 and so on.\\n    uint256 public constant FEE_DENOMINATOR = 10_000;\\n\\n    /// @notice keccack256(\\\"OfferApproval(uint8 protocol,address marketplace,uint256 marketplaceFeeNumerator,address delegatedPurchaser,address buyer,address tokenAddress,uint256 tokenId,uint256 amount,uint256 price,uint256 expiration,uint256 nonce,uint256 masterNonce,address coin)\\\")\\n    bytes32 public constant OFFER_APPROVAL_HASH = 0x2008a1ab898fdaa2d8f178bc39e807035d2d6e330dac5e42e913ca727ab56038;\\n\\n    /// @notice keccack256(\\\"CollectionOfferApproval(uint8 protocol,bool collectionLevelOffer,address marketplace,uint256 marketplaceFeeNumerator,address delegatedPurchaser,address buyer,address tokenAddress,uint256 amount,uint256 price,uint256 expiration,uint256 nonce,uint256 masterNonce,address coin)\\\")\\n    bytes32 public constant COLLECTION_OFFER_APPROVAL_HASH = 0x0bc3075778b80a2341ce445063e81924b88d61eb5f21c815e8f9cc824af096d0;\\n\\n    /// @notice keccack256(\\\"BundledOfferApproval(uint8 protocol,address marketplace,uint256 marketplaceFeeNumerator,address delegatedPurchaser,address buyer,address tokenAddress,uint256 price,uint256 expiration,uint256 nonce,uint256 masterNonce,address coin,uint256[] tokenIds,uint256[] amounts,uint256[] itemSalePrices)\\\")\\n    bytes32 public constant BUNDLED_OFFER_APPROVAL_HASH = 0x126520d0bca0cfa7e5852d004cc4335723ce67c638cbd55cd530fe992a089e7b;\\n\\n    /// @notice keccack256(\\\"SaleApproval(uint8 protocol,bool sellerAcceptedOffer,address marketplace,uint256 marketplaceFeeNumerator,uint256 maxRoyaltyFeeNumerator,address privateBuyer,address seller,address tokenAddress,uint256 tokenId,uint256 amount,uint256 minPrice,uint256 expiration,uint256 nonce,uint256 masterNonce,address coin)\\\")\\n    bytes32 public constant SALE_APPROVAL_HASH = 0xd3f4273db8ff5262b6bc5f6ee07d139463b4f826cce90c05165f63062f3686dc;\\n\\n    /// @notice keccack256(\\\"BundledSaleApproval(uint8 protocol,address marketplace,uint256 marketplaceFeeNumerator,address privateBuyer,address seller,address tokenAddress,uint256 expiration,uint256 nonce,uint256 masterNonce,address coin,uint256[] tokenIds,uint256[] amounts,uint256[] maxRoyaltyFeeNumerators,uint256[] itemPrices)\\\")\\n    bytes32 public constant BUNDLED_SALE_APPROVAL_HASH = 0x80244acca7a02d7199149a3038653fc8cb10ca984341ec429a626fab631e1662;\\n\\n    /// @dev Tracks the most recently created security profile id\\n    uint256 private lastSecurityPolicyId;\\n\\n    /// @dev Mapping of token address (NFT collection) to a security policy id.\\n    mapping(address => uint256) private tokenSecurityPolicies;\\n\\n    /// @dev Mapping of whitelisted exchange addresses, organized by security policy id.\\n    mapping(uint256 => mapping(address => bool)) private exchangeWhitelist;\\n\\n    /// @dev Mapping of coin addresses that are approved for payments, organized by security policy id.\\n    mapping(uint256 => mapping(address => bool)) private paymentMethodWhitelist;\\n\\n    /// @dev Mapping of security policy id to security policy settings.\\n    mapping(uint256 => SecurityPolicy) private securityPolicies;\\n\\n    /**\\n     * @notice User-specific master nonce that allows buyers and sellers to efficiently cancel all listings or offers\\n     *         they made previously. The master nonce for a user only changes when they explicitly request to revoke all\\n     *         existing listings and offers.\\n     *\\n     * @dev    When prompting sellers to sign a listing or offer, marketplaces must query the current master nonce of\\n     *         the user and include it in the listing/offer signature data.\\n     */\\n    mapping(address => uint256) public masterNonces;\\n\\n    /**\\n     * @dev The mapping key is the keccak256 hash of marketplace address and user address.\\n     *\\n     * @dev ```keccak256(abi.encodePacked(marketplace, user))```\\n     *\\n     * @dev The mapping value is another nested mapping of \\\"slot\\\" (key) to a bitmap (value) containing boolean flags\\n     *      indicating whether or not a nonce has been used or invalidated.\\n     *\\n     * @dev Marketplaces MUST track their own nonce by user, incrementing it for every signed listing or offer the user\\n     *      creates.  Listings and purchases may be executed out of order, and they may never be executed if orders\\n     *      are not matched prior to expriation.\\n     *\\n     * @dev The slot and the bit offset within the mapped value are computed as:\\n     *\\n     * @dev ```slot = nonce / 256;```\\n     * @dev ```offset = nonce % 256;```\\n     */\\n    mapping(bytes32 => mapping(uint256 => uint256)) private invalidatedSignatures;\\n\\n    /**\\n     * @dev Mapping of token contract addresses to the address of the ERC-20 payment coin tokens are priced in.\\n     *      When unspecified, the default currency for collections is the native currency.\\n     *\\n     * @dev If the designated ERC-20 payment coin is not in the list of approved coins, sales cannot be executed\\n     *      until the designated coin is set to an approved payment coin.\\n     */\\n    mapping (address => address) public collectionPaymentCoins;\\n\\n    /**\\n     * @dev Mapping of token contract addresses to the collection-level pricing boundaries (floor and ceiling price).\\n     */\\n    mapping (address => PricingBounds) private collectionPricingBounds;\\n\\n    /**\\n     * @dev Mapping of token contract addresses to the token-level pricing boundaries (floor and ceiling price).\\n     */\\n    mapping (address => mapping (uint256 => PricingBounds)) private tokenPricingBounds;\\n\\n    constructor(\\n        address defaultContractOwner_,\\n        uint32 defaultPushPaymentGasLimit_, \\n        address[] memory defaultPaymentMethods) EIP712(\\\"PaymentProcessor\\\", \\\"1\\\") {\\n\\n        securityPolicies[DEFAULT_SECURITY_POLICY_ID] = SecurityPolicy({\\n            enforceExchangeWhitelist: false,\\n            enforcePaymentMethodWhitelist: true,\\n            enforcePricingConstraints: false,\\n            disablePrivateListings: false,\\n            disableDelegatedPurchases: false,\\n            disableEIP1271Signatures: false,\\n            disableExchangeWhitelistEOABypass: false,\\n            pushPaymentGasLimit: defaultPushPaymentGasLimit_,\\n            policyOwner: address(0)\\n        });\\n\\n        emit CreatedOrUpdatedSecurityPolicy(\\n            DEFAULT_SECURITY_POLICY_ID, \\n            false,\\n            true,\\n            false,\\n            false,\\n            false,\\n            false,\\n            false,\\n            defaultPushPaymentGasLimit_,\\n            \\\"DEFAULT SECURITY POLICY\\\");\\n\\n        for (uint256 i = 0; i < defaultPaymentMethods.length;) {\\n            address coin = defaultPaymentMethods[i];\\n\\n            paymentMethodWhitelist[DEFAULT_SECURITY_POLICY_ID][coin] = true;\\n            emit PaymentMethodAddedToWhitelist(DEFAULT_SECURITY_POLICY_ID, coin);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        _transferOwnership(defaultContractOwner_);\\n    }\\n\\n    /**\\n     * @notice Allows Payment Processor contract owner to pause trading on this contract.  This is only to be used\\n     *         in case a future vulnerability emerges to allow a migration to an updated contract.\\n     *\\n     * @dev    Throws when caller is not the contract owner.\\n     * @dev    Throws when contract is already paused.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The contract has been placed in the `paused` state.\\n     * @dev    2. Trading is frozen.\\n     */\\n    function pause() external {\\n        _checkOwner();\\n        _pause();\\n    }\\n\\n    /**\\n     * @notice Allows Payment Processor contract owner to resume trading on this contract.  This is only to be used\\n     *         in case a pause was not necessary and trading can safely resume.\\n     *\\n     * @dev    Throws when caller is not the contract owner.\\n     * @dev    Throws when contract is not currently paused.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The contract has been placed in the `unpaused` state.\\n     * @dev    2. Trading is resumed.\\n     */\\n    function unpause() external {\\n        _checkOwner();\\n        _unpause();\\n    }\\n\\n    /**\\n     * @notice Allows any user to create a new security policy for the payment processor.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The security policy id tracker has been incremented by `1`.\\n     * @dev    2. The security policy has been added to the security policies mapping.\\n     * @dev    3. The caller has been assigned as the owner of the security policy.\\n     * @dev    4. A `CreatedOrUpdatedSecurityPolicy` event has been emitted.\\n     *\\n     * @param  enforceExchangeWhitelist          Requires external exchange contracts be whitelisted to make buy calls.\\n     * @param  enforcePaymentMethodWhitelist     Requires that ERC-20 payment methods be pre-approved.\\n     * @param  enforcePricingConstraints         Allows the creator to specify exactly one approved payment method, \\n     *                                           a minimum floor price and a maximum ceiling price.  \\n     *                                           When true, this value supercedes `enforcePaymentMethodWhitelist`.\\n     * @param  disablePrivateListings            Prevents private sales.\\n     * @param  disableDelegatedPurchases         Prevents delegated purchases.\\n     * @param  disableEIP1271Signatures          Prevents EIP-1271 compliant smart contracts such as multi-sig wallets\\n     *                                           from buying or selling.  Forces buyers and sellers to be EOAs.\\n     * @param  disableExchangeWhitelistEOABypass When exchange whitelists are enforced, prevents EOAs from executing\\n     *                                           purchases directly and bypassing whitelisted exchange contracts.\\n     * @param  pushPaymentGasLimit               The amount of gas to forward when pushing native proceeds.\\n     * @param  registryName                      A human readable name that describes the security policy.\\n     */\\n    function createSecurityPolicy(\\n        bool enforceExchangeWhitelist,\\n        bool enforcePaymentMethodWhitelist,\\n        bool enforcePricingConstraints,\\n        bool disablePrivateListings,\\n        bool disableDelegatedPurchases,\\n        bool disableEIP1271Signatures,\\n        bool disableExchangeWhitelistEOABypass,\\n        uint32 pushPaymentGasLimit,\\n        string calldata registryName) external override returns (uint256) {\\n        uint256 securityPolicyId;\\n        \\n        unchecked {\\n            securityPolicyId = ++lastSecurityPolicyId;\\n        }\\n        \\n        _createOrUpdateSecurityPolicy(\\n            securityPolicyId,\\n            enforceExchangeWhitelist,\\n            enforcePaymentMethodWhitelist,\\n            enforcePricingConstraints,\\n            disablePrivateListings,\\n            disableDelegatedPurchases,\\n            disableEIP1271Signatures,\\n            disableExchangeWhitelistEOABypass,\\n            pushPaymentGasLimit,\\n            registryName\\n        );\\n\\n        return securityPolicyId;\\n    }\\n\\n    /**\\n     * @notice Allows security policy owners to update existing security policies.\\n     * \\n     * @dev    Throws when caller is not the owner of the specified security policy.\\n     * @dev    Throws when the specified security policy id does not exist.\\n     * \\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The security policy details have been updated in the security policies mapping.\\n     * @dev    2. A `CreatedOrUpdatedSecurityPolicy` event has been emitted.\\n     *\\n     * @param  enforceExchangeWhitelist          Requires external exchange contracts be whitelisted to make buy calls.\\n     * @param  enforcePaymentMethodWhitelist     Requires that ERC-20 payment methods be pre-approved.\\n     * @param  enforcePricingConstraints         Allows the creator to specify exactly one approved payment method, \\n     *                                           a minimum floor price and a maximum ceiling price.  \\n     *                                           When true, this value supercedes `enforcePaymentMethodWhitelist`.\\n     * @param  disablePrivateListings            Prevents private sales.\\n     * @param  disableDelegatedPurchases         Prevents delegated purchases.\\n     * @param  disableEIP1271Signatures          Prevents EIP-1271 compliant smart contracts such as multi-sig wallets\\n     *                                           from buying or selling.  Forces buyers and sellers to be EOAs.\\n     * @param  disableExchangeWhitelistEOABypass When exchange whitelists are enforced, prevents EOAs from executing\\n     *                                           purchases directly and bypassing whitelisted exchange contracts.\\n     * @param  pushPaymentGasLimit               The amount of gas to forward when pushing native proceeds.\\n     * @param  registryName                      A human readable name that describes the security policy.\\n     */\\n    function updateSecurityPolicy(\\n        uint256 securityPolicyId,\\n        bool enforceExchangeWhitelist,\\n        bool enforcePaymentMethodWhitelist,\\n        bool enforcePricingConstraints,\\n        bool disablePrivateListings,\\n        bool disableDelegatedPurchases,\\n        bool disableEIP1271Signatures,\\n        bool disableExchangeWhitelistEOABypass,\\n        uint32 pushPaymentGasLimit,\\n        string calldata registryName) external override {\\n        _requireCallerOwnsSecurityPolicy(securityPolicyId);\\n\\n        _createOrUpdateSecurityPolicy(\\n            securityPolicyId,\\n            enforceExchangeWhitelist,\\n            enforcePaymentMethodWhitelist,\\n            enforcePricingConstraints,\\n            disablePrivateListings,\\n            disableDelegatedPurchases,\\n            disableEIP1271Signatures,\\n            disableExchangeWhitelistEOABypass,\\n            pushPaymentGasLimit,\\n            registryName\\n        );\\n    }\\n\\n    /**\\n     * @notice Allow security policy owners to transfer ownership of their security policy to a new account.\\n     *\\n     * @dev    Throws when `newOwner` is the zero address.\\n     * @dev    Throws when caller is not the owner of the specified security policy.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The security policy owner has been updated in the security policies mapping.\\n     * @dev    2. A `SecurityPolicyOwnershipTransferred` event has been emitted.\\n     *\\n     * @param  securityPolicyId The id of the security policy to update.\\n     * @param  newOwner         The new policy owner address.\\n     */\\n    function transferSecurityPolicyOwnership(uint256 securityPolicyId, address newOwner) external override {\\n        if(newOwner == address(0)) {\\n            revert PaymentProcessor__SecurityPolicyOwnershipCannotBeTransferredToZeroAddress();\\n        }\\n\\n        _transferSecurityPolicyOwnership(securityPolicyId, newOwner);\\n    }\\n\\n    /**\\n     * @notice Allow security policy owners to transfer ownership of their security policy to the zero address.\\n     *         This can be done to make a security policy permanently immutable.\\n     *\\n     * @dev    Throws when caller is not the owner of the specified security policy.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The security policy owner has been set to the zero address in the security policies mapping.\\n     * @dev    2. A `SecurityPolicyOwnershipTransferred` event has been emitted.\\n     *\\n     * @param  securityPolicyId The id of the security policy to update.\\n     */\\n    function renounceSecurityPolicyOwnership(uint256 securityPolicyId) external override {\\n        _transferSecurityPolicyOwnership(securityPolicyId, address(0));\\n    }\\n\\n    /**\\n     * @notice Allows the smart contract, the contract owner, or the contract admin of any NFT collection to \\n     *         set the security policy for their collection..\\n     *\\n     * @dev    Throws when the specified tokenAddress is address(0).\\n     * @dev    Throws when the caller is not the contract, the owner or the administrator of the specified collection.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The `tokenSecurityPolicies` mapping has be updated to reflect the designated security policy id.\\n     * @dev    2. An `UpdatedCollectionSecurityPolicy` event has been emitted.\\n     *\\n     * @param  tokenAddress     The smart contract address of the NFT collection.\\n     * @param  securityPolicyId The security policy id to use for the collection.\\n     */\\n    function setCollectionSecurityPolicy(address tokenAddress, uint256 securityPolicyId) external override {\\n        _requireCallerIsNFTOrContractOwnerOrAdmin(tokenAddress);\\n\\n        if (securityPolicyId > lastSecurityPolicyId) {\\n            revert PaymentProcessor__SecurityPolicyDoesNotExist();\\n        }\\n\\n        tokenSecurityPolicies[tokenAddress] = securityPolicyId;\\n        emit UpdatedCollectionSecurityPolicy(tokenAddress, securityPolicyId);\\n    }\\n\\n    /**\\n     * @notice Allows the smart contract, the contract owner, or the contract admin of any NFT collection to \\n     *         specify the currency their collection is priced in.  Only applicable when `enforcePricingConstraints` \\n     *         security setting is in effect for a collection.\\n     *\\n     * @dev    Throws when the specified tokenAddress is address(0).\\n     * @dev    Throws when the caller is not the contract, the owner or the administrator of the specified tokenAddress.\\n     * @dev    Throws when the specified coin address non-zero and does not implement decimals() > 0.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The `collectionPaymentCoins` mapping has be updated to reflect the designated payment coin.\\n     * @dev    2. An `UpdatedCollectionPaymentCoin` event has been emitted.\\n     *\\n     * @param  tokenAddress The smart contract address of the NFT collection.\\n     * @param  coin         The address of the designated ERC-20 payment coin smart contract.\\n     *                      Specify address(0) to designate native currency as the payment currency.\\n     */\\n    function setCollectionPaymentCoin(address tokenAddress, address coin) external override {\\n        _requireCallerIsNFTOrContractOwnerOrAdmin(tokenAddress);\\n        collectionPaymentCoins[tokenAddress] = coin;\\n        emit UpdatedCollectionPaymentCoin(tokenAddress, coin);\\n    }\\n\\n    /**\\n     * @notice Allows the smart contract, the contract owner, or the contract admin of any NFT collection to \\n     *         specify their own bounded price at the collection level.\\n     *\\n     * @dev    Throws when the specified tokenAddress is address(0).\\n     * @dev    Throws when the caller is not the contract, the owner or the administrator of the specified tokenAddress.\\n     * @dev    Throws when the previously set pricing bounds were set to be immutable.\\n     * @dev    Throws when the specified floor price is greater than the ceiling price.\\n     * \\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The collection-level pricing bounds for the specified tokenAddress has been set.\\n     * @dev    2. An `UpdatedCollectionLevelPricingBoundaries` event has been emitted.\\n     *\\n     * @param  tokenAddress The smart contract address of the NFT collection.\\n     * @param  pricingBounds Including the floor price, ceiling price, and an immutability flag.\\n     */\\n    function setCollectionPricingBounds(address tokenAddress, PricingBounds calldata pricingBounds) external override {\\n        _requireCallerIsNFTOrContractOwnerOrAdmin(tokenAddress);\\n\\n        if(collectionPricingBounds[tokenAddress].isImmutable) {\\n            revert PaymentProcessor__PricingBoundsAreImmutable();\\n        }\\n\\n        if(pricingBounds.floorPrice > pricingBounds.ceilingPrice) {\\n            revert PaymentProcessor__CeilingPriceMustBeGreaterThanFloorPrice();\\n        }\\n        \\n        collectionPricingBounds[tokenAddress] = pricingBounds;\\n        \\n        emit UpdatedCollectionLevelPricingBoundaries(\\n            tokenAddress, \\n            pricingBounds.floorPrice, \\n            pricingBounds.ceilingPrice);\\n    }\\n\\n    /**\\n     * @notice Allows the smart contract, the contract owner, or the contract admin of any NFT collection to \\n     *         specify their own bounded price at the individual token level.\\n     *\\n     * @dev    Throws when the specified tokenAddress is address(0).\\n     * @dev    Throws when the caller is not the contract, the owner or the administrator of the specified tokenAddress.\\n     * @dev    Throws when the lengths of the tokenIds and pricingBounds array don't match.\\n     * @dev    Throws when the tokenIds or pricingBounds array length is zero.     \\n     * @dev    Throws when the previously set pricing bounds of a token were set to be immutable.\\n     * @dev    Throws when the any of the specified floor prices is greater than the ceiling price for that token id.\\n     * \\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The token-level pricing bounds for the specified tokenAddress and token ids has been set.\\n     * @dev    2. An `UpdatedTokenLevelPricingBoundaries` event has been emitted.\\n     *\\n     * @param  tokenAddress  The smart contract address of the NFT collection.\\n     * @param  tokenIds      An array of token ids for which pricing bounds are being set.\\n     * @param  pricingBounds An array of pricing bounds used to set the floor, ceiling and immutability flag on the \\n     *                       individual token level.\\n     */\\n    function setTokenPricingBounds(\\n        address tokenAddress, \\n        uint256[] calldata tokenIds, \\n        PricingBounds[] calldata pricingBounds) external override {\\n        _requireCallerIsNFTOrContractOwnerOrAdmin(tokenAddress);\\n\\n        if(tokenIds.length != pricingBounds.length) {\\n            revert PaymentProcessor__InputArrayLengthMismatch();\\n        }\\n\\n        if(tokenIds.length == 0) {\\n            revert PaymentProcessor__InputArrayLengthCannotBeZero();\\n        }\\n\\n        mapping (uint256 => PricingBounds) storage ptrTokenPricingBounds = tokenPricingBounds[tokenAddress];\\n\\n        uint256 tokenId;\\n        for(uint256 i = 0; i < tokenIds.length;) {\\n            tokenId = tokenIds[i];\\n            PricingBounds memory pricingBounds_ = pricingBounds[i];\\n\\n            if(ptrTokenPricingBounds[tokenId].isImmutable) {\\n                revert PaymentProcessor__PricingBoundsAreImmutable();\\n            }\\n\\n            if(pricingBounds_.floorPrice > pricingBounds_.ceilingPrice) {\\n                revert PaymentProcessor__CeilingPriceMustBeGreaterThanFloorPrice();\\n            }\\n\\n            ptrTokenPricingBounds[tokenId] = pricingBounds_;\\n\\n            emit UpdatedTokenLevelPricingBoundaries(\\n                tokenAddress, \\n                tokenId, \\n                pricingBounds_.floorPrice, \\n                pricingBounds_.ceilingPrice);\\n            \\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Allows security policy owners to whitelist an exchange.\\n     *\\n     * @dev    Throws when caller is not the owner of the specified security policy.\\n     * @dev    Throws when the specified address is address(0).\\n     * @dev    Throws when the specified address is already whitelisted under the specified security policy.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. `account` has been whitelisted in `exchangeWhitelist` mapping.\\n     * @dev    2. An `ExchangeAddedToWhitelist` event has been emitted.\\n     *\\n     * @param  securityPolicyId The id of the security policy to update.\\n     * @param  account          The address of the exchange to whitelist.\\n     */\\n    function whitelistExchange(uint256 securityPolicyId, address account) external override {\\n        _requireCallerOwnsSecurityPolicy(securityPolicyId);\\n\\n        if (account == address(0)) {\\n            revert PaymentProcessor__AddressCannotBeZero();\\n        }\\n\\n        mapping (address => bool) storage ptrExchangeWhitelist = exchangeWhitelist[securityPolicyId];\\n\\n        if (ptrExchangeWhitelist[account]) {\\n            revert PaymentProcessor__ExchangeIsWhitelisted();\\n        }\\n\\n        ptrExchangeWhitelist[account] = true;\\n        emit ExchangeAddedToWhitelist(securityPolicyId, account);\\n    }\\n\\n    /**\\n     * @notice Allows security policy owners to remove an exchange from the whitelist.\\n     *\\n     * @dev    Throws when caller is not the owner of the specified security policy.\\n     * @dev    Throws when the specified address is not whitelisted under the specified security policy.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. `account` has been unwhitelisted and removed from the `exchangeWhitelist` mapping.\\n     * @dev    2. An `ExchangeRemovedFromWhitelist` event has been emitted.\\n     *\\n     * @param  securityPolicyId The id of the security policy to update.\\n     * @param  account          The address of the exchange to unwhitelist.\\n     */\\n    function unwhitelistExchange(uint256 securityPolicyId, address account) external override {\\n        _requireCallerOwnsSecurityPolicy(securityPolicyId);\\n\\n        mapping (address => bool) storage ptrExchangeWhitelist = exchangeWhitelist[securityPolicyId];\\n\\n        if (!ptrExchangeWhitelist[account]) {\\n            revert PaymentProcessor__ExchangeIsNotWhitelisted();\\n        }\\n\\n        delete ptrExchangeWhitelist[account];\\n        emit ExchangeRemovedFromWhitelist(securityPolicyId, account);\\n    }\\n\\n    /**\\n     * @notice Allows security policy owners to approve a new coin for use as a payment currency.\\n     *\\n     * @dev    Throws when caller is not the owner of the specified security policy.\\n     * @dev    Throws when the specified coin address is address(0).\\n     * @dev    Throws when the specified coin does not implement the decimals() that returns a non-zero value. \\n     * @dev    Throws when the specified coin is already approved under the specified security policy.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. `coin` has been approved in `paymentMethodWhitelist` mapping.\\n     * @dev    2. A `PaymentMethodAddedToWhitelist` event has been emitted.\\n     *\\n     * @param  securityPolicyId The id of the security policy to update.\\n     * @param  coin             The address of the coin to approve.\\n     */\\n    function whitelistPaymentMethod(uint256 securityPolicyId, address coin) external override {\\n        _requireCallerOwnsSecurityPolicy(securityPolicyId);\\n\\n        mapping (address => bool) storage ptrPaymentMethodWhitelist = paymentMethodWhitelist[securityPolicyId];\\n\\n        if (ptrPaymentMethodWhitelist[coin]) {\\n            revert PaymentProcessor__CoinIsApproved();\\n        }\\n\\n        ptrPaymentMethodWhitelist[coin] = true;\\n        emit PaymentMethodAddedToWhitelist(securityPolicyId, coin);\\n    }\\n\\n    /**\\n     * @notice Allows security policy owners to remove a coin from the list of approved payment currencies.\\n     *\\n     * @dev    Throws when caller is not the owner of the specified security policy.\\n     * @dev    Throws when the specified coin is not currently approved under the specified security policy.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. `coin` has been removed from the `paymentMethodWhitelist` mapping.\\n     * @dev    2. A `PaymentMethodRemovedFromWhitelist` event has been emitted.\\n     *\\n     * @param  securityPolicyId The id of the security policy to update.\\n     * @param  coin             The address of the coin to disapprove.\\n     */\\n    function unwhitelistPaymentMethod(uint256 securityPolicyId, address coin) external override {\\n        _requireCallerOwnsSecurityPolicy(securityPolicyId);\\n\\n        mapping (address => bool) storage ptrPaymentMethodWhitelist = paymentMethodWhitelist[securityPolicyId];\\n\\n        if (!ptrPaymentMethodWhitelist[coin]) {\\n            revert PaymentProcessor__CoinIsNotApproved();\\n        }\\n\\n        delete ptrPaymentMethodWhitelist[coin];\\n        emit PaymentMethodRemovedFromWhitelist(securityPolicyId, coin);\\n    }\\n\\n    /**\\n     * @notice Allows a user to revoke/cancel all prior signatures of listings and offers.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The user's master nonce has been incremented by `1` in contract storage, rendering all signed\\n     *            approvals using the prior nonce unusable.\\n     * @dev    2. A `MasterNonceInvalidated` event has been emitted.\\n     */\\n    function revokeMasterNonce() external override {\\n        emit MasterNonceInvalidated(masterNonces[_msgSender()], _msgSender());\\n\\n        unchecked {\\n            ++masterNonces[_msgSender()];\\n        }\\n    }\\n\\n    /**\\n     * @notice Allows a user to revoke/cancel a single, previously signed listing or offer by specifying the marketplace\\n     *         and nonce of the listing or offer.\\n     *\\n     * @dev    Throws when the user has already revoked the nonce.\\n     * @dev    Throws when the nonce was already used to successfully buy or sell an NFT.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The specified `nonce` for the specified `marketplace` and `msg.sender` pair has been revoked and can\\n     *            no longer be used to execute a sale or purchase.\\n     * @dev    2. A `RevokedListingOrOffer` event has been emitted.\\n     *\\n     * @param  marketplace The marketplace where the `msg.sender` signed the listing or offer.\\n     * @param  nonce       The nonce that was signed in the revoked listing or offer.\\n     */\\n    function revokeSingleNonce(address marketplace, uint256 nonce) external override {\\n        _checkAndInvalidateNonce(marketplace, _msgSender(), nonce, true);\\n    }\\n\\n    /**\\n     * @notice Executes the sale of one ERC-721 or ERC-1155 token.\\n     *\\n     * @notice The seller's signature must be provided that proves that they approved the sale.\\n     * @notice This an an EIP-712 signature with the following data format.\\n     * @notice ```EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)```\\n     * @notice ```\\n     *         SaleApproval(\\n     *           uint8 protocol,\\n     *           bool sellerAcceptedOffer,\\n     *           address marketplace,\\n     *           uint256 marketplaceFeeNumerator,\\n     *           uint256 maxRoyaltyFeeNumerator,\\n     *           address privateBuyer,\\n     *           address seller,\\n     *           address tokenAddress,\\n     *           uint256 tokenId,\\n     *           uint256 amount,\\n     *           uint256 minPrice,\\n     *           uint256 expiration,\\n     *           uint256 nonce,\\n     *           uint256 masterNonce,\\n     *           address coin)\\n     *         ```\\n     *\\n     * @notice The buyer's signature must be provided that proves that they approved the purchase.  There are two\\n     *         formats for this approval, one format to be used for collection-level offers when a specific token id is \\n     *         not specified and one format to be used for item-level offers when a specific token id is specified.\\n     *\\n     * @notice This an an EIP-712 signature with the following data format.\\n     * @notice ```EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)```\\n     * @notice ```\\n     *         OfferApproval(\\n     *           uint8 protocol,\\n     *           address marketplace,\\n     *           uint256 marketplaceFeeNumerator,\\n     *           address delegatedPurchaser,\\n     *           address buyer,\\n     *           address tokenAddress,\\n     *           uint256 tokenId,\\n     *           uint256 amount,\\n     *           uint256 price,\\n     *           uint256 expiration,\\n     *           uint256 nonce,\\n     *           uint256 masterNonce,\\n     *           address coin)\\n     *         ```\\n     *\\n     * @notice OR\\n     *\\n     * @notice ```\\n     *         CollectionOfferApproval(\\n     *           uint8 protocol,\\n     *           bool collectionLevelOffer,\\n     *           address marketplace,\\n     *           uint256 marketplaceFeeNumerator,\\n     *           address delegatedPurchaser,\\n     *           address buyer,\\n     *           address tokenAddress,\\n     *           uint256 amount,\\n     *           uint256 price,\\n     *           uint256 expiration,\\n     *           uint256 nonce,\\n     *           uint256 masterNonce,\\n     *           address coin)\\n     *         ```\\n     *\\n     * @dev    WARNING: Calling marketplaces MUST be aware that for ERC-1155 sales, a `safeTransferFrom` function is\\n     *         called which provides surface area for cross-contract re-entrancy.  Marketplace contracts are responsible\\n     *         for ensuring this is safely handled.\\n     *\\n     * @dev    Throws when payment processor has been `paused`.\\n     * @dev    Throws when payment method is ETH/native currency and offer price does not equal `msg.value`.\\n     * @dev    Throws when payment method is ETH/native currency and the order was a collection or item offer.\\n     * @dev    Throws when payment method is an ERC-20 coin and `msg.value` is not equal to zero.\\n     * @dev    Throws when the protocol is ERC-721 and amount is not equal to `1`.\\n     * @dev    Throws when the protocol is ERC-1155 and amount is equal to `0`.\\n     * @dev    Throws when the expiration timestamp of the listing or offer is in the past/expired.\\n     * @dev    Throws when the offer price is less than the seller-approved minimum price.\\n     * @dev    Throws when the marketplace fee + royalty fee numerators exceeds 10,000 (100%).\\n     * @dev    Throws when the collection security policy enforces pricing constraints and the payment/sale price\\n     *         violates the constraints.\\n     * @dev    Throws when a private buyer is specified and the buyer does not match the private buyer.\\n     * @dev    Throws when a private buyer is specified and private listings are disabled by collection security policy.\\n     * @dev    Throws when a delegated purchaser is specified and the `msg.sender` is not the delegated purchaser.\\n     * @dev    Throws when a delegated purchaser is specified and delegated purchases are disabled by collection \\n     *         security policy.\\n     * @dev    Throws when the seller or buyer is a smart contract and EIP-1271 signatures are disabled by collection\\n     *         security policy.\\n     * @dev    Throws when the exchange whitelist is enforced by collection security policy and `msg.sender` is a \\n     *         smart contract that is not on the whitelist.\\n     * @dev    Throws when the exchange whitelist is enforced AND exchange whitelist EOA bypass is disabled by \\n     *         collection security policy and `msg.sender` is an EOA that is not whitelisted. \\n     * @dev    Throws when the seller's nonce on the specified marketplace has already been used to execute a sale.\\n     * @dev    Throws when the seller's nonce on the specified marketplace has already been revoked/canceled.\\n     * @dev    Throws when the buyer's nonce on the specified marketplace has already been used to execute a sale.\\n     * @dev    Throws when the buyer's nonce on the specified marketplace has already been revoked/canceled.\\n     * @dev    Throws when the `masterNonce` in the signed listing is not equal to the seller's current `masterNonce.\\n     * @dev    Throws when the `masterNonce` in the signed offer is not equal to the buyer's current `masterNonce.\\n     * @dev    Throws when the seller is an EOA and ECDSA recover operation on the SaleApproval EIP-712 signature \\n     *         does not return the seller's address, meaning the seller did not approve the sale with the provided \\n     *         sale details.\\n     * @dev    Throws when the seller is a smart contract and EIP-1271 signature validation returns false for the\\n     *         supplied listing signature.\\n     * @dev    Throws when the buyer is an EOA and ECDSA recover operation on the OfferApproval EIP-712 signature \\n     *         does not return the buyer's address, meaning the buyer did not approve the purchase with the provided \\n     *         purchase details.\\n     * @dev    Throws when the buyer is a smart contract and EIP-1271 signature validation returns false for the\\n     *         supplied offer signature.\\n     * @dev    Throws when the onchain royalty amount exceeds the seller-approved maximum royalty fee.\\n     * @dev    Throws when the seller has not approved the Payment Processor contract for transfers of the specified\\n     *         token or collection.\\n     * @dev    Throws when transferFrom (ERC-721) or safeTransferFrom (ERC-1155) fails to transfer the token from the\\n     *         seller to the buyer.\\n     * @dev    Throws when the transfer of ERC-20 coin payment tokens from the purchaser fails.\\n     * @dev    Throws when the distribution of native proceeds cannot be accepted or fails for any reason.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The listing nonce for the specified marketplace and seller has been marked as invalidated so that it \\n     *            cannot be replayed/used again.\\n     * @dev    2. The offer nonce for the specified marketplace and buyer has been marked as invalidated so that it \\n     *            cannot be replayed/used again.\\n     * @dev    3. Applicable royalties have been paid to the address designated with EIP-2981 (when implemented on the\\n     *            NFT contract).\\n     * @dev    4. Applicable marketplace fees have been paid to the designated marketplace.\\n     * @dev    5. All remaining funds have been paid to the seller of the token.\\n     * @dev    6. The `BuySingleListing` event has been emitted.\\n     * @dev    7. The token has been transferred from the seller to the buyer.\\n     *\\n     * @param saleDetails   See `MatchedOrder` struct.\\n     * @param signedListing See `SignatureECSA` struct.\\n     * @param signedOffer   See `SignatureECSA` struct.\\n     */\\n    function buySingleListing(\\n        MatchedOrder memory saleDetails,\\n        SignatureECDSA memory signedListing,\\n        SignatureECDSA memory signedOffer\\n    ) external payable override {\\n        _requireNotPaused();\\n        if (!_executeMatchedOrderSale(msg.value, saleDetails, signedListing, signedOffer)) {\\n            revert PaymentProcessor__DispensingTokenWasUnsuccessful();\\n        }\\n    }\\n\\n    /**\\n     * @notice Executes the sale of multiple ERC-721 or ERC-1155 tokens.\\n     *\\n     * @notice Sales may be a combination of native currency and ERC-20 payments.  Matched orders may be any combination\\n     *         of ERC-721 or ERC-1155 sales, as each matched order signature is validated independently against\\n     *         individual listings/orders associated with the matched orders.\\n     *\\n     * @notice A batch of orders will be partially filled in the case where an NFT is not available at the time of sale,\\n     *         but only if the method of payment is an ERC-20 token.  Partial fills are not supported for native\\n     *         payments to limit re-entrancy risks associated with issuing refunds.\\n     *\\n     * @notice The seller's signatures must be provided that proves that they approved the sales of each item.\\n     * @notice This an an EIP-712 signature with the following data format.\\n     * @notice ```EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)```\\n     * @notice ```\\n     *         SaleApproval(\\n     *           uint8 protocol,\\n     *           bool sellerAcceptedOffer,\\n     *           address marketplace,\\n     *           uint256 marketplaceFeeNumerator,\\n     *           uint256 maxRoyaltyFeeNumerator,\\n     *           address privateBuyer,\\n     *           address seller,\\n     *           address tokenAddress,\\n     *           uint256 tokenId,\\n     *           uint256 amount,\\n     *           uint256 minPrice,\\n     *           uint256 expiration,\\n     *           uint256 nonce,\\n     *           uint256 masterNonce,\\n     *           address coin)\\n     *         ```\\n     *\\n     * @notice The buyer's signature must be provided that proves that they approved the purchase of each item.\\n     *         There are two formats for this approval, one format to be used for collection-level offers when a \\n     *         specific token id is not specified and one format to be used for item-level offers when a specific token \\n     *         id is specified.\\n     *\\n     * @notice This an an EIP-712 signature with the following data format.\\n     * @notice ```EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)```\\n     * @notice ```\\n     *         OfferApproval(\\n     *           uint8 protocol,\\n     *           address marketplace,\\n     *           uint256 marketplaceFeeNumerator,\\n     *           address delegatedPurchaser,\\n     *           address buyer,\\n     *           address tokenAddress,\\n     *           uint256 tokenId,\\n     *           uint256 amount,\\n     *           uint256 price,\\n     *           uint256 expiration,\\n     *           uint256 nonce,\\n     *           uint256 masterNonce,\\n     *           address coin)\\n     *         ```\\n     *\\n     * @notice OR\\n     *\\n     * @notice ```\\n     *         CollectionOfferApproval(\\n     *           uint8 protocol,\\n     *           bool collectionLevelOffer,\\n     *           address marketplace,\\n     *           uint256 marketplaceFeeNumerator,\\n     *           address delegatedPurchaser,\\n     *           address buyer,\\n     *           address tokenAddress,\\n     *           uint256 amount,\\n     *           uint256 price,\\n     *           uint256 expiration,\\n     *           uint256 nonce,\\n     *           uint256 masterNonce,\\n     *           address coin)\\n     *         ```\\n     *\\n     * @dev    Throws when payment processor has been `paused`.\\n     * @dev    Throws when any of the input arrays have mismatched lengths.\\n     * @dev    Throws when any of the input arrays are empty.\\n     * @dev    Throws when the the amount of native funds included isn't exactly equal to the sum of the native sale\\n     *         prices of individual items.\\n     * @dev    Throws when the the amount of ERC-20 funds approved is less than the sum of the ERC-20\\n     *         prices of individual items.\\n     *\\n     * @dev    WARNING: Calling marketplaces MUST be aware that for ERC-1155 sales, a `safeTransferFrom` function is\\n     *         called which provides surface area for cross-contract re-entrancy.  Marketplace contracts are responsible\\n     *         for ensuring this is safely handled.\\n     *\\n     * @dev    For each individual matched order to process:\\n     *\\n     * @dev    Throws when payment method is ETH/native currency and the order was a collection or item offer.\\n     * @dev    Throws when payment method is an ERC-20 coin and supplied ETH/native funds for item is not equal to zero.\\n     * @dev    Throws when the protocol is ERC-721 and amount is not equal to `1`.\\n     * @dev    Throws when the protocol is ERC-1155 and amount is equal to `0`.\\n     * @dev    Throws when the expiration timestamp of the listing or offer is in the past/expired.\\n     * @dev    Throws when the offer price is less than the seller-approved minimum price.\\n     * @dev    Throws when the marketplace fee + royalty fee numerators exceeds 10,000 (100%).\\n     * @dev    Throws when the collection security policy enforces pricing constraints and the payment/sale price\\n     *         violates the constraints.\\n     * @dev    Throws when a private buyer is specified and the buyer does not match the private buyer.\\n     * @dev    Throws when a private buyer is specified and private listings are disabled by collection security policy.\\n     * @dev    Throws when a delegated purchaser is specified and the `msg.sender` is not the delegated purchaser.\\n     * @dev    Throws when a delegated purchaser is specified and delegated purchases are disabled by collection \\n     *         security policy.\\n     * @dev    Throws when the seller or buyer is a smart contract and EIP-1271 signatures are disabled by collection\\n     *         security policy.\\n     * @dev    Throws when the exchange whitelist is enforced by collection security policy and `msg.sender` is a \\n     *         smart contract that is not on the whitelist.\\n     * @dev    Throws when the exchange whitelist is enforced AND exchange whitelist EOA bypass is disabled by \\n     *         collection security policy and `msg.sender` is an EOA that is not whitelisted. \\n     * @dev    Throws when the seller's nonce on the specified marketplace has already been used to execute a sale.\\n     * @dev    Throws when the seller's nonce on the specified marketplace has already been revoked/canceled.\\n     * @dev    Throws when the buyer's nonce on the specified marketplace has already been used to execute a sale.\\n     * @dev    Throws when the buyer's nonce on the specified marketplace has already been revoked/canceled.\\n     * @dev    Throws when the `masterNonce` in the signed listing is not equal to the seller's current `masterNonce.\\n     * @dev    Throws when the `masterNonce` in the signed offer is not equal to the buyer's current `masterNonce.\\n     * @dev    Throws when the seller is an EOA and ECDSA recover operation on the SaleApproval EIP-712 signature \\n     *         does not return the seller's address, meaning the seller did not approve the sale with the provided \\n     *         sale details.\\n     * @dev    Throws when the seller is a smart contract and EIP-1271 signature validation returns false for the\\n     *         supplied listing signature.\\n     * @dev    Throws when the buyer is an EOA and ECDSA recover operation on the OfferApproval EIP-712 signature \\n     *         does not return the buyer's address, meaning the buyer did not approve the purchase with the provided \\n     *         purchase details.\\n     * @dev    Throws when the buyer is a smart contract and EIP-1271 signature validation returns false for the\\n     *         supplied offer signature.\\n     * @dev    Throws when the onchain royalty amount exceeds the seller-approved maximum royalty fee.\\n     * @dev    Throws when the seller has not approved the Payment Processor contract for transfers of the specified\\n     *         token or collection.\\n     * @dev    Throws when transferFrom (ERC-721) or safeTransferFrom (ERC-1155) fails to transfer the token from the\\n     *         seller to the buyer and method of payment is native currency. (Partial fills allowed for ERC-20 payments).\\n     * @dev    Throws when the transfer of ERC-20 coin payment tokens from the purchaser fails.\\n     * @dev    Throws when the distribution of native proceeds cannot be accepted or fails for any reason.\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    For each item:\\n     *\\n     * @dev    1. The listing nonce for the specified marketplace and seller has been marked as invalidated so that it \\n     *            cannot be replayed/used again.\\n     * @dev    2. The offer nonce for the specified marketplace and buyer has been marked as invalidated so that it \\n     *            cannot be replayed/used again.\\n     * @dev    3. Applicable royalties have been paid to the address designated with EIP-2981 (when implemented on the\\n     *            NFT contract).\\n     * @dev    4. Applicable marketplace fees have been paid to the designated marketplace.\\n     * @dev    5. All remaining funds have been paid to the seller of the token.\\n     * @dev    6. The `BuySingleListing` event has been emitted.\\n     * @dev    7. The token has been transferred from the seller to the buyer.\\n     *\\n     * @param saleDetailsArray An array of `MatchedOrder` structs.\\n     * @param signedListings   An array of `SignatureECDSA` structs.\\n     * @param signedOffers     An array of `SignatureECDSA` structs.\\n     */\\n    function buyBatchOfListings(\\n        MatchedOrder[] calldata saleDetailsArray,\\n        SignatureECDSA[] calldata signedListings,\\n        SignatureECDSA[] calldata signedOffers\\n    ) external payable override {\\n        _requireNotPaused();\\n\\n        if (saleDetailsArray.length != signedListings.length || \\n            saleDetailsArray.length != signedOffers.length) {\\n            revert PaymentProcessor__InputArrayLengthMismatch();\\n        }\\n\\n        if (saleDetailsArray.length == 0) {\\n            revert PaymentProcessor__InputArrayLengthCannotBeZero();\\n        }\\n\\n        uint256 runningBalanceNativeProceeds = msg.value;\\n\\n        MatchedOrder memory saleDetails;\\n        SignatureECDSA memory signedListing;\\n        SignatureECDSA memory signedOffer;\\n        uint256 msgValue;\\n\\n        for (uint256 i = 0; i < saleDetailsArray.length;) {\\n            saleDetails = saleDetailsArray[i];\\n            signedListing = signedListings[i];\\n            signedOffer = signedOffers[i];\\n            msgValue = 0;\\n\\n            if(saleDetails.paymentCoin == address(0)) {\\n                msgValue = saleDetails.offerPrice;\\n\\n                if (runningBalanceNativeProceeds < msgValue) {\\n                    revert PaymentProcessor__RanOutOfNativeFunds();\\n                }\\n\\n                unchecked {\\n                    runningBalanceNativeProceeds -= msgValue;\\n                }\\n\\n                if (!_executeMatchedOrderSale(msgValue, saleDetails, signedListing, signedOffer)) {\\n                    revert PaymentProcessor__DispensingTokenWasUnsuccessful();\\n                }\\n            } else {\\n                _executeMatchedOrderSale(msgValue, saleDetails, signedListing, signedOffer);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (runningBalanceNativeProceeds > 0) {\\n            revert PaymentProcessor__OverpaidNativeFunds();\\n        }\\n    }\\n\\n    /**\\n     * @notice Executes the bundled sale of ERC-721 or ERC-1155 token listed by a single seller for a single collection.\\n     *\\n     * @notice Orders will be partially filled in the case where an NFT is not available at the time of sale,\\n     *         but only if the method of payment is an ERC-20 token.  Partial fills are not supported for native\\n     *         payments to limit re-entrancy risks associated with issuing refunds.\\n     *\\n     * @notice The seller's signature must be provided that proves that they approved the sale of each token.\\n     * @notice This an an EIP-712 signature with the following data format.\\n     * @notice ```EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)```\\n     * @notice ```\\n     *         BundledSaleApproval(\\n     *           uint8 protocol,\\n     *           address marketplace,\\n     *           uint256 marketplaceFeeNumerator,\\n     *           address privateBuyer,\\n     *           address seller,\\n     *           address tokenAddress,\\n     *           uint256 expiration,\\n     *           uint256 nonce,\\n     *           uint256 masterNonce,\\n     *           address coin,\\n     *           uint256[] tokenIds,\\n     *           uint256[] amounts,\\n     *           uint256[] maxRoyaltyFeeNumerators,\\n     *           uint256[] itemPrices)\\n     *         ```\\n     *\\n     * @notice The buyer's signature must be provided that proves that they approved the purchase of each token.\\n     * @notice This an an EIP-712 signature with the following data format.\\n     * @notice ```EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)```\\n     * @notice ```\\n     *         BundledOfferApproval(\\n     *           uint8 protocol,\\n     *           address marketplace,\\n     *           uint256 marketplaceFeeNumerator,\\n     *           address delegatedPurchaser,\\n     *           address buyer,\\n     *           address tokenAddress,\\n     *           uint256 price,\\n     *           uint256 expiration,\\n     *           uint256 nonce,\\n     *           uint256 masterNonce,\\n     *           address coin,\\n     *           uint256[] tokenIds,\\n     *           uint256[] amounts,\\n     *           uint256[] itemSalePrices)\\n     *         ```\\n     *\\n     * @dev    WARNING: Calling marketplaces MUST be aware that for ERC-1155 sales, a `safeTransferFrom` function is\\n     *         called which provides surface area for cross-contract re-entrancy.  Marketplace contracts are responsible\\n     *         for ensuring this is safely handled.\\n     *\\n     * @dev    Throws when payment processor has been `paused`.\\n     * @dev    Throws when the bundled items array has a length of zero.\\n     * @dev    Throws when payment method is ETH/native currency and offer price does not equal `msg.value`.\\n     * @dev    Throws when payment method is an ERC-20 coin and `msg.value` is not equal to zero.\\n     * @dev    Throws when the offer price does not equal the sum of the individual item prices in the listing.\\n     * @dev    Throws when the expiration timestamp of the offer is in the past/expired.\\n     * @dev    Throws when a private buyer is specified and the buyer does not match the private buyer.\\n     * @dev    Throws when a private buyer is specified and private listings are disabled by collection security policy.\\n     * @dev    Throws when a delegated purchaser is specified and the `msg.sender` is not the delegated purchaser.\\n     * @dev    Throws when a delegated purchaser is specified and delegated purchases are disabled by collection \\n     *         security policy.\\n     * @dev    Throws when the exchange whitelist is enforced by collection security policy and `msg.sender` is a \\n     *         smart contract that is not on the whitelist.\\n     * @dev    Throws when the exchange whitelist is enforced AND exchange whitelist EOA bypass is disabled by \\n     *         collection security policy and `msg.sender` is an EOA that is not whitelisted. \\n     * @dev    Throws when the seller's nonce on the specified marketplace has already been used to execute a sale.\\n     * @dev    Throws when the seller's nonce on the specified marketplace has already been revoked/canceled.\\n     * @dev    Throws when the buyer's nonce on the specified marketplace has already been used to execute a sale.\\n     * @dev    Throws when the buyer's nonce on the specified marketplace has already been revoked/canceled.\\n     * @dev    Throws when the `masterNonce` in the signed listing is not equal to the seller's current `masterNonce.\\n     * @dev    Throws when the `masterNonce` in the signed offer is not equal to the buyer's current `masterNonce.\\n     * @dev    Throws when the seller is an EOA and ECDSA recover operation on the SaleApproval EIP-712 signature \\n     *         does not return the seller's address, meaning the seller did not approve the sale with the provided \\n     *         sale details.\\n     * @dev    Throws when the seller is a smart contract and EIP-1271 signature validation returns false for the\\n     *         supplied listing signature.\\n     * @dev    Throws when the buyer is an EOA and ECDSA recover operation on the OfferApproval EIP-712 signature \\n     *         does not return the buyer's address, meaning the buyer did not approve the purchase with the provided \\n     *         purchase details.\\n     * @dev    Throws when the buyer is a smart contract and EIP-1271 signature validation returns false for the\\n     *         supplied offer signature.\\n     * @dev    Throws when the transfer of ERC-20 coin payment tokens from the purchaser fails.\\n     * @dev    Throws when the distribution of native proceeds cannot be accepted or fails for any reason.\\n     *\\n     * @dev    For each item in the bundled listing:\\n     *\\n     * @dev    Throws when the protocol is ERC-721 and amount is not equal to `1`.\\n     * @dev    Throws when the protocol is ERC-1155 and amount is equal to `0`.\\n     * @dev    Throws when the marketplace fee + royalty fee numerators exceeds 10,000 (100%).\\n     * @dev    Throws when the collection security policy enforces pricing constraints and the payment/sale price\\n     *         violates the constraints.\\n     * @dev    Throws when the expiration timestamp of the listing is in the past/expired.\\n     * @dev    Throws when the seller is a smart contract and EIP-1271 signatures are disabled by collection\\n     *         security policy.\\n     * @dev    Throws when the onchain royalty amount exceeds the seller-approved maximum royalty fee.\\n     * @dev    Throws when the seller has not approved the Payment Processor contract for transfers of the specified\\n     *         tokens in the collection.\\n     * @dev    Throws when transferFrom (ERC-721) or safeTransferFrom (ERC-1155) fails to transfer the tokens from the\\n     *         seller to the buyer and method of payment is native currency. (Partial fills allowed for ERC-20 payments).\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The listing nonce for the specified marketplace and seller has been marked as invalidated so that it \\n     *            cannot be replayed/used again.\\n     * @dev    2. The offer nonce for the specified marketplace and buyer has been marked as invalidated so that it \\n     *            cannot be replayed/used again.\\n     * @dev    3. Applicable royalties have been paid to the address designated with EIP-2981 (when implemented on the\\n     *            NFT contract).\\n     * @dev    4. Applicable marketplace fees have been paid to the designated marketplace.\\n     * @dev    5. All remaining funds have been paid to the seller of the token.\\n     * @dev    6. The `BuyBundledListingERC721` or `BuyBundledListingERC1155`  event has been emitted.\\n     * @dev    7. The tokens in the bundle has been transferred from the seller to the buyer.\\n     *\\n     * @param signedListing See `SignatureECSA` struct.\\n     * @param signedOffer   See `SignatureECSA` struct.\\n     * @param bundleDetails See `MatchedOrderBundleExtended` struct.\\n     * @param bundleItems   See `BundledItem` struct. \\n     */\\n    function buyBundledListing(\\n        SignatureECDSA memory signedListing,\\n        SignatureECDSA memory signedOffer,\\n        MatchedOrderBundleExtended memory bundleDetails,\\n        BundledItem[] calldata bundleItems) external payable override {\\n        _requireNotPaused();\\n\\n        if (bundleItems.length == 0) {\\n            revert PaymentProcessor__InputArrayLengthCannotBeZero();\\n        }\\n\\n        (uint256 securityPolicyId, SecurityPolicy storage securityPolicy) = \\n            _getTokenSecurityPolicy(bundleDetails.bundleBase.tokenAddress);\\n\\n        SignatureECDSA[] memory signedListingAsSingletonArray = new SignatureECDSA[](1);\\n        signedListingAsSingletonArray[0] = signedListing;\\n\\n        (Accumulator memory accumulator, MatchedOrder[] memory saleDetailsBatch) = \\n        _validateBundledItems(\\n            false,\\n            securityPolicy,\\n            bundleDetails,\\n            bundleItems,\\n            signedListingAsSingletonArray\\n        );\\n\\n        _validateBundledOffer(\\n            securityPolicyId,\\n            securityPolicy,\\n            bundleDetails.bundleBase,\\n            accumulator,\\n            signedOffer\\n        );\\n\\n        bool[] memory unsuccessfulFills = _computeAndDistributeProceeds(\\n            ComputeAndDistributeProceedsArgs({\\n                pushPaymentGasLimit: securityPolicy.pushPaymentGasLimit,\\n                purchaser: bundleDetails.bundleBase.delegatedPurchaser == address(0) ? bundleDetails.bundleBase.buyer : bundleDetails.bundleBase.delegatedPurchaser,\\n                paymentCoin: IERC20(bundleDetails.bundleBase.paymentCoin),\\n                funcPayout: bundleDetails.bundleBase.paymentCoin == address(0) ? _payoutNativeCurrency : _payoutCoinCurrency,\\n                funcDispenseToken: bundleDetails.bundleBase.protocol == TokenProtocols.ERC1155 ? _dispenseERC1155Token : _dispenseERC721Token\\n            }),\\n            saleDetailsBatch\\n        );\\n\\n        if (bundleDetails.bundleBase.protocol == TokenProtocols.ERC1155) {\\n            emit BuyBundledListingERC1155(\\n                    bundleDetails.bundleBase.marketplace,\\n                    bundleDetails.bundleBase.tokenAddress,\\n                    bundleDetails.bundleBase.paymentCoin,\\n                    bundleDetails.bundleBase.buyer,\\n                    bundleDetails.seller,\\n                    unsuccessfulFills,\\n                    accumulator.tokenIds,\\n                    accumulator.amounts,\\n                    accumulator.salePrices);\\n        } else {\\n            emit BuyBundledListingERC721(\\n                    bundleDetails.bundleBase.marketplace,\\n                    bundleDetails.bundleBase.tokenAddress,\\n                    bundleDetails.bundleBase.paymentCoin,\\n                    bundleDetails.bundleBase.buyer,\\n                    bundleDetails.seller,\\n                    unsuccessfulFills,\\n                    accumulator.tokenIds,\\n                    accumulator.salePrices);\\n        }\\n    }\\n\\n    /**\\n     * @notice Executes the bundled purchase of ERC-721 or ERC-1155 tokens individually listed for a single collection.\\n     *\\n     * @notice The seller's signatures must be provided that proves that they approved the sales of each item.\\n     * @notice This an an EIP-712 signature with the following data format.\\n     * @notice ```EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)```\\n     * @notice ```\\n     *         SaleApproval(\\n     *           uint8 protocol,\\n     *           bool sellerAcceptedOffer,\\n     *           address marketplace,\\n     *           uint256 marketplaceFeeNumerator,\\n     *           uint256 maxRoyaltyFeeNumerator,\\n     *           address privateBuyer,\\n     *           address seller,\\n     *           address tokenAddress,\\n     *           uint256 tokenId,\\n     *           uint256 amount,\\n     *           uint256 minPrice,\\n     *           uint256 expiration,\\n     *           uint256 nonce,\\n     *           uint256 masterNonce,\\n     *           address coin)\\n     *         ```\\n     *\\n     * @notice The buyer's signature must be provided that proves that they approved the purchase of each token.\\n     * @notice This an an EIP-712 signature with the following data format.\\n     * @notice ```EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)```\\n     * @notice ```\\n     *         BundledOfferApproval(\\n     *           uint8 protocol,\\n     *           address marketplace,\\n     *           uint256 marketplaceFeeNumerator,\\n     *           address delegatedPurchaser,\\n     *           address buyer,\\n     *           address tokenAddress,\\n     *           uint256 price,\\n     *           uint256 expiration,\\n     *           uint256 nonce,\\n     *           uint256 masterNonce,\\n     *           address coin,\\n     *           uint256[] tokenIds,\\n     *           uint256[] amounts,\\n     *           uint256[] itemSalePrices)\\n     *         ```\\n     *\\n     * @dev    WARNING: Calling marketplaces MUST be aware that for ERC-1155 sales, a `safeTransferFrom` function is\\n     *         called which provides surface area for cross-contract re-entrancy.  Marketplace contracts are responsible\\n     *         for ensuring this is safely handled.\\n     *\\n     * @dev    Throws when payment processor has been `paused`.\\n     * @dev    Throws when any of the input arrays have mismatched lengths.\\n     * @dev    Throws when any of the input array have a length of zero.\\n     * @dev    Throws when payment method is ETH/native currency and offer price does not equal `msg.value`.\\n     * @dev    Throws when payment method is an ERC-20 coin and `msg.value` is not equal to zero.\\n     * @dev    Throws when the offer price does not equal the sum of the individual item prices in the listing.\\n     * @dev    Throws when the expiration timestamp of the offer is in the past/expired.\\n     * @dev    Throws when a private buyer is specified and the buyer does not match the private buyer.\\n     * @dev    Throws when a private buyer is specified and private listings are disabled by collection security policy.\\n     * @dev    Throws when a delegated purchaser is specified and the `msg.sender` is not the delegated purchaser.\\n     * @dev    Throws when a delegated purchaser is specified and delegated purchases are disabled by collection \\n     *         security policy.\\n     * @dev    Throws when the exchange whitelist is enforced by collection security policy and `msg.sender` is a \\n     *         smart contract that is not on the whitelist.\\n     * @dev    Throws when the exchange whitelist is enforced AND exchange whitelist EOA bypass is disabled by \\n     *         collection security policy and `msg.sender` is an EOA that is not whitelisted. \\n     * @dev    Throws when the buyer's nonce on the specified marketplace has already been used to execute a sale.\\n     * @dev    Throws when the buyer's nonce on the specified marketplace has already been revoked/canceled.\\n     * @dev    Throws when the `masterNonce` in the signed offer is not equal to the buyer's current `masterNonce.\\n     * @dev    Throws when the buyer is an EOA and ECDSA recover operation on the OfferApproval EIP-712 signature \\n     *         does not return the buyer's address, meaning the buyer did not approve the purchase with the provided \\n     *         purchase details.\\n     * @dev    Throws when the buyer is a smart contract and EIP-1271 signature validation returns false for the\\n     *         supplied offer signature.\\n     * @dev    Throws when the transfer of ERC-20 coin payment tokens from the purchaser fails.\\n     * @dev    Throws when the distribution of native proceeds cannot be accepted or fails for any reason.\\n     *\\n     * @dev    For each item in the bundled listing:\\n     *\\n     * @dev    Throws when the protocol is ERC-721 and amount is not equal to `1`.\\n     * @dev    Throws when the protocol is ERC-1155 and amount is equal to `0`.\\n     * @dev    Throws when the marketplace fee + royalty fee numerators exceeds 10,000 (100%).\\n     * @dev    Throws when the collection security policy enforces pricing constraints and the payment/sale price\\n     *         violates the constraints.\\n     * @dev    Throws when the expiration timestamp of the listing is in the past/expired.\\n     * @dev    Throws when the seller's nonce on the specified marketplace has already been used to execute a sale.\\n     * @dev    Throws when the seller's nonce on the specified marketplace has already been revoked/canceled.\\n     * @dev    Throws when the `masterNonce` in the signed listing is not equal to the seller's current `masterNonce.\\n     * @dev    Throws when the seller is a smart contract and EIP-1271 signatures are disabled by collection\\n     *         security policy.\\n     * @dev    Throws when the seller is an EOA and ECDSA recover operation on the SaleApproval EIP-712 signature \\n     *         does not return the seller's address, meaning the seller did not approve the sale with the provided \\n     *         sale details.\\n     * @dev    Throws when the seller is a smart contract and EIP-1271 signature validation returns false for the\\n     *         supplied listing signature.\\n     * @dev    Throws when the onchain royalty amount exceeds the seller-approved maximum royalty fee.\\n     * @dev    Throws when the seller has not approved the Payment Processor contract for transfers of the specified\\n     *         tokens in the collection.\\n     * @dev    Throws when transferFrom (ERC-721) or safeTransferFrom (ERC-1155) fails to transfer the tokens from the\\n     *         seller to the buyer and method of payment is native currency. (Partial fills allowed for ERC-20 payments).\\n     *\\n     * @dev    <h4>Postconditions:</h4>\\n     * @dev    1. The listing nonce for the specified marketplace and seller has been marked as invalidated so that it \\n     *            cannot be replayed/used again.\\n     * @dev    2. The offer nonce for the specified marketplace and buyer has been marked as invalidated so that it \\n     *            cannot be replayed/used again.\\n     * @dev    3. Applicable royalties have been paid to the address designated with EIP-2981 (when implemented on the\\n     *            NFT contract).\\n     * @dev    4. Applicable marketplace fees have been paid to the designated marketplace.\\n     * @dev    5. All remaining funds have been paid to the seller of the token.\\n     * @dev    6. The `SweepCollectionERC721` or `SweepCollectionERC1155`  event has been emitted.\\n     * @dev    7. The tokens in the bundle has been transferred from the seller to the buyer.\\n     *\\n     * @param signedOffer    See `SignatureECSA` struct.\\n     * @param bundleDetails  See `MatchedOrderBundleBase` struct.\\n     * @param bundleItems    See `BundledItem` struct. \\n     * @param signedListings See `SignatureECSA` struct.\\n     */\\n    function sweepCollection(\\n        SignatureECDSA memory signedOffer,\\n        MatchedOrderBundleBase memory bundleDetails,\\n        BundledItem[] calldata bundleItems,\\n        SignatureECDSA[] calldata signedListings) external payable override {\\n        _requireNotPaused();\\n\\n        if (bundleItems.length != signedListings.length) {\\n            revert PaymentProcessor__InputArrayLengthMismatch();\\n        }\\n\\n        if (bundleItems.length == 0) {\\n            revert PaymentProcessor__InputArrayLengthCannotBeZero();\\n        }\\n\\n        (uint256 securityPolicyId, SecurityPolicy storage securityPolicy) = \\n            _getTokenSecurityPolicy(bundleDetails.tokenAddress);\\n\\n        (Accumulator memory accumulator, MatchedOrder[] memory saleDetailsBatch) = \\n        _validateBundledItems(\\n            true,\\n            securityPolicy,\\n            MatchedOrderBundleExtended({\\n                bundleBase: bundleDetails,\\n                seller: address(0),\\n                listingNonce: 0,\\n                listingExpiration: 0\\n            }),\\n            bundleItems,\\n            signedListings\\n        );\\n\\n        _validateBundledOffer(\\n            securityPolicyId,\\n            securityPolicy,\\n            bundleDetails,\\n            accumulator,\\n            signedOffer\\n        );\\n\\n        bool[] memory unsuccessfulFills = _computeAndDistributeProceeds(\\n            ComputeAndDistributeProceedsArgs({\\n                pushPaymentGasLimit: securityPolicy.pushPaymentGasLimit,\\n                purchaser: bundleDetails.delegatedPurchaser == address(0) ? bundleDetails.buyer : bundleDetails.delegatedPurchaser,\\n                paymentCoin: IERC20(bundleDetails.paymentCoin),\\n                funcPayout: bundleDetails.paymentCoin == address(0) ? _payoutNativeCurrency : _payoutCoinCurrency,\\n                funcDispenseToken: bundleDetails.protocol == TokenProtocols.ERC1155 ? _dispenseERC1155Token : _dispenseERC721Token\\n            }),\\n            saleDetailsBatch\\n        );\\n\\n        if (bundleDetails.protocol == TokenProtocols.ERC1155) {\\n            emit SweepCollectionERC1155(\\n                    bundleDetails.marketplace,\\n                    bundleDetails.tokenAddress,\\n                    bundleDetails.paymentCoin,\\n                    bundleDetails.buyer,\\n                    unsuccessfulFills,\\n                    accumulator.sellers,\\n                    accumulator.tokenIds,\\n                    accumulator.amounts,\\n                    accumulator.salePrices);\\n        } else {\\n            emit SweepCollectionERC721(\\n                    bundleDetails.marketplace,\\n                    bundleDetails.tokenAddress,\\n                    bundleDetails.paymentCoin,\\n                    bundleDetails.buyer,\\n                    unsuccessfulFills,\\n                    accumulator.sellers,\\n                    accumulator.tokenIds,\\n                    accumulator.salePrices);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the EIP-712 domain separator for this contract.\\n     */\\n    function getDomainSeparator() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    /**\\n     * @notice Returns the security policy details for the specified security policy id.\\n     * \\n     * @param  securityPolicyId The security policy id to lookup.\\n     * @return securityPolicy   The security policy details.\\n     */\\n    function getSecurityPolicy(uint256 securityPolicyId) external view override returns (SecurityPolicy memory) {\\n        return securityPolicies[securityPolicyId];\\n    }\\n\\n    /**\\n     * @notice Returns whitelist status of the exchange address for the specified security policy id.\\n     *\\n     * @param  securityPolicyId The security policy id to lookup.\\n     * @param  account          The address to check.\\n     * @return isWhitelisted    True if the address is whitelisted, false otherwise.\\n     */\\n    function isWhitelisted(uint256 securityPolicyId, address account) external view override returns (bool) {\\n        return exchangeWhitelist[securityPolicyId][account];\\n    }\\n\\n    /**\\n     * @notice Returns approval status of the payment coin address for the specified security policy id.\\n     *\\n     * @param  securityPolicyId        The security policy id to lookup.\\n     * @param  coin                    The coin address to check.\\n     * @return isPaymentMethodApproved True if the coin address is approved, false otherwise.\\n     */\\n    function isPaymentMethodApproved(uint256 securityPolicyId, address coin) external view override returns (bool) {\\n        return paymentMethodWhitelist[securityPolicyId][coin];\\n    }\\n\\n    /**\\n     * @notice Returns the current security policy id for the specified collection address.\\n     * \\n     * @param  collectionAddress The address of the collection to lookup.\\n     * @return securityPolicyId  The current security policy id for the specifed collection.\\n     */\\n    function getTokenSecurityPolicyId(address collectionAddress) external view override returns (uint256) {\\n        return tokenSecurityPolicies[collectionAddress];\\n    }\\n\\n    /**\\n     * @notice Returns whether or not the price of a collection is immutable.\\n     * @param  tokenAddress The smart contract address of the NFT collection.\\n     * @return True if the floor and ceiling price for the specified token contract has been set immutably, false otherwise.\\n     */\\n    function isCollectionPricingImmutable(address tokenAddress) external view override returns (bool) {\\n        return collectionPricingBounds[tokenAddress].isImmutable;\\n    }\\n\\n    /**\\n     * @notice Returns whether or not the price of a specific token is immutable.\\n     * @param  tokenAddress The smart contract address of the NFT collection.\\n     * @param  tokenId      The token id.\\n     * @return True if the floor and ceiling price for the specified token contract and tokenId has been set immutably, false otherwise.\\n     */\\n    function isTokenPricingImmutable(address tokenAddress, uint256 tokenId) external view override returns (bool) {\\n        return tokenPricingBounds[tokenAddress][tokenId].isImmutable;\\n    }\\n\\n    /**\\n     * @notice Gets the floor price for the specified nft contract address and token id.\\n     *\\n     * @param  tokenAddress The smart contract address of the NFT collection.\\n     * @param  tokenId      The token id.\\n     * @return The floor price.\\n     */\\n    function getFloorPrice(address tokenAddress, uint256 tokenId) external view override returns (uint256) {\\n        (uint256 floorPrice,) = _getFloorAndCeilingPrices(tokenAddress, tokenId);\\n        return floorPrice;\\n    }\\n\\n    /**\\n     * @notice Gets the ceiling price for the specified nft contract address and token id.\\n     *\\n     * @param  tokenAddress The smart contract address of the NFT collection.\\n     * @param  tokenId      The token id.\\n     * @return The ceiling price.\\n     */\\n    function getCeilingPrice(address tokenAddress, uint256 tokenId) external view override returns (uint256) {\\n        (, uint256 ceilingPrice) = _getFloorAndCeilingPrices(tokenAddress, tokenId);\\n        return ceilingPrice;\\n    }\\n\\n    /**\\n     * @notice ERC-165 Interface Introspection Support.\\n     * @dev    Supports `IPaymentProcessor` interface as well as parent contract interfaces.\\n     * @param  interfaceId The interface to query.\\n     * @return True if the interface is supported, false otherwise.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IPaymentProcessor).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    function _payoutNativeCurrency(\\n        address payee, \\n        address /*payer*/, \\n        IERC20 /*paymentCoin*/, \\n        uint256 proceeds, \\n        uint256 gasLimit_) internal {\\n        _pushProceeds(payee, proceeds, gasLimit_);\\n    }\\n\\n    function _payoutCoinCurrency(\\n        address payee, \\n        address payer, \\n        IERC20 paymentCoin, \\n        uint256 proceeds, \\n        uint256 /*gasLimit_*/) internal {\\n        SafeERC20.safeTransferFrom(paymentCoin, payer, payee, proceeds);\\n    }\\n\\n    function _dispenseERC721Token(\\n        address from, \\n        address to, \\n        address tokenAddress, \\n        uint256 tokenId, \\n        uint256 /*amount*/) internal returns (bool) {\\n        try IERC721(tokenAddress).transferFrom(from, to, tokenId) {\\n            return true;\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    function _dispenseERC1155Token(\\n        address from, \\n        address to, \\n        address tokenAddress, \\n        uint256 tokenId, \\n        uint256 amount) internal returns (bool) {\\n        try IERC1155(tokenAddress).safeTransferFrom(from, to, tokenId, amount, \\\"\\\") {\\n            return true;\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    function _requireCallerIsNFTOrContractOwnerOrAdmin(address tokenAddress) internal view {\\n        bool callerHasPermissions = false;\\n        \\n        callerHasPermissions = _msgSender() == tokenAddress;\\n        if(!callerHasPermissions) {\\n            try IOwnable(tokenAddress).owner() returns (address contractOwner) {\\n                callerHasPermissions = _msgSender() == contractOwner;\\n            } catch {}\\n\\n            if(!callerHasPermissions) {\\n                try IAccessControl(tokenAddress).hasRole(DEFAULT_ACCESS_CONTROL_ADMIN_ROLE, _msgSender()) \\n                    returns (bool callerIsContractAdmin) {\\n                    callerHasPermissions = callerIsContractAdmin;\\n                } catch {}\\n            }\\n        }\\n\\n        if(!callerHasPermissions) {\\n            revert PaymentProcessor__CallerMustHaveElevatedPermissionsForSpecifiedNFT();\\n        }\\n    }\\n\\n    function _verifyPaymentCoinIsApproved(\\n        uint256 securityPolicyId, \\n        bool enforcePaymentMethodWhitelist,\\n        bool enforcePricingConstraints,\\n        address tokenAddress, \\n        address coin) internal view virtual {\\n        if (enforcePricingConstraints) {\\n            if(collectionPaymentCoins[tokenAddress] != coin) {\\n                revert PaymentProcessor__PaymentCoinIsNotAnApprovedPaymentMethod();\\n            }\\n        } else if (enforcePaymentMethodWhitelist) {\\n            if (!paymentMethodWhitelist[securityPolicyId][coin]) {\\n                revert PaymentProcessor__PaymentCoinIsNotAnApprovedPaymentMethod();\\n            }\\n        }\\n    }\\n\\n    function _createOrUpdateSecurityPolicy(\\n        uint256 securityPolicyId,\\n        bool enforceExchangeWhitelist,\\n        bool enforcePaymentMethodWhitelist,\\n        bool enforcePricingConstraints,\\n        bool disablePrivateListings,\\n        bool disableDelegatedPurchases,\\n        bool disableEIP1271Signatures,\\n        bool disableExchangeWhitelistEOABypass,\\n        uint32 pushPaymentGasLimit,\\n        string calldata registryName) private {\\n\\n        securityPolicies[securityPolicyId] = SecurityPolicy({\\n            enforceExchangeWhitelist: enforceExchangeWhitelist,\\n            enforcePaymentMethodWhitelist: enforcePaymentMethodWhitelist,\\n            enforcePricingConstraints: enforcePricingConstraints,\\n            disablePrivateListings: disablePrivateListings,\\n            disableDelegatedPurchases: disableDelegatedPurchases,\\n            disableEIP1271Signatures: disableEIP1271Signatures,\\n            disableExchangeWhitelistEOABypass: disableExchangeWhitelistEOABypass,\\n            pushPaymentGasLimit: pushPaymentGasLimit,\\n            policyOwner: _msgSender()\\n        });\\n\\n        emit CreatedOrUpdatedSecurityPolicy(\\n            securityPolicyId, \\n            enforceExchangeWhitelist,\\n            enforcePaymentMethodWhitelist,\\n            enforcePricingConstraints,\\n            disablePrivateListings,\\n            disableDelegatedPurchases,\\n            disableEIP1271Signatures,\\n            disableExchangeWhitelistEOABypass,\\n            pushPaymentGasLimit,\\n            registryName);\\n    }\\n\\n    function _transferSecurityPolicyOwnership(uint256 securityPolicyId, address newOwner) private {\\n        _requireCallerOwnsSecurityPolicy(securityPolicyId);\\n\\n        SecurityPolicy storage securityPolicy = securityPolicies[securityPolicyId];\\n\\n        address oldOwner = securityPolicy.policyOwner;\\n        securityPolicy.policyOwner = newOwner;\\n        emit SecurityPolicyOwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    function _executeMatchedOrderSale(\\n        uint256 msgValue,\\n        MatchedOrder memory saleDetails,\\n        SignatureECDSA memory signedListing,\\n        SignatureECDSA memory signedOffer\\n    ) private returns (bool tokenDispensedSuccessfully) {\\n        uint256 securityPolicyId = tokenSecurityPolicies[saleDetails.tokenAddress];\\n        SecurityPolicy memory securityPolicy = securityPolicies[securityPolicyId];\\n\\n        if (saleDetails.paymentCoin == address(0)) {\\n            if (saleDetails.offerPrice != msgValue) {\\n                revert PaymentProcessor__OfferPriceMustEqualSalePrice();\\n            }\\n\\n            if (saleDetails.sellerAcceptedOffer || saleDetails.seller == tx.origin) {\\n                revert PaymentProcessor__CollectionLevelOrItemLevelOffersCanOnlyBeMadeUsingERC20PaymentMethods();\\n            }\\n        } else {\\n            if (msgValue > 0) {\\n                revert PaymentProcessor__CannotIncludeNativeFundsWhenPaymentMethodIsAnERC20Coin();\\n            }\\n\\n            _verifyPaymentCoinIsApproved(\\n                securityPolicyId, \\n                securityPolicy.enforcePaymentMethodWhitelist, \\n                securityPolicy.enforcePricingConstraints,\\n                saleDetails.tokenAddress, \\n                saleDetails.paymentCoin);\\n        }\\n        \\n        if (saleDetails.protocol == TokenProtocols.ERC1155) {\\n            if (saleDetails.amount == 0) {\\n                revert PaymentProcessor__AmountForERC1155SalesGreaterThanZero();\\n            }\\n        } else {\\n            if (saleDetails.amount != ONE) {\\n                revert PaymentProcessor__AmountForERC721SalesMustEqualOne();\\n            }\\n        }\\n\\n        if (block.timestamp > saleDetails.listingExpiration) {\\n            revert PaymentProcessor__SaleHasExpired();\\n        }\\n\\n        if (block.timestamp > saleDetails.offerExpiration) {\\n            revert PaymentProcessor__OfferHasExpired();\\n        }\\n\\n        if (saleDetails.offerPrice < saleDetails.listingMinPrice) {\\n            revert PaymentProcessor__SalePriceBelowSellerApprovedMinimum();\\n        }\\n\\n        if (saleDetails.marketplaceFeeNumerator + saleDetails.maxRoyaltyFeeNumerator > FEE_DENOMINATOR) {\\n            revert PaymentProcessor__MarketplaceAndRoyaltyFeesWillExceedSalePrice();\\n        }\\n\\n        if (saleDetails.privateBuyer != address(0)) {\\n            if (saleDetails.buyer != saleDetails.privateBuyer) {\\n                revert PaymentProcessor__BuyerMustBeDesignatedPrivateBuyer();\\n            }\\n    \\n            if (securityPolicy.disablePrivateListings) {\\n                revert PaymentProcessor__TokenSecurityPolicyDoesNotAllowPrivateListings();\\n            }\\n        }\\n\\n        if (saleDetails.delegatedPurchaser != address(0)) {\\n            if (_msgSender() != saleDetails.delegatedPurchaser) {\\n                revert PaymentProcessor__CallerIsNotTheDelegatedPurchaser();\\n            }\\n\\n            if(securityPolicy.disableDelegatedPurchases) {\\n                revert PaymentProcessor__TokenSecurityPolicyDoesNotAllowDelegatedPurchases();\\n            }\\n        }\\n\\n        if(securityPolicy.disableEIP1271Signatures) {\\n            if (saleDetails.seller.code.length > 0) {\\n                revert PaymentProcessor__EIP1271SignaturesAreDisabled();\\n            }\\n\\n            if (saleDetails.buyer.code.length > 0) {\\n                revert PaymentProcessor__EIP1271SignaturesAreDisabled();\\n            }\\n        }\\n\\n        if (securityPolicy.enforceExchangeWhitelist) {\\n            if (_msgSender() != tx.origin) {\\n                if (!exchangeWhitelist[securityPolicyId][_msgSender()]) {\\n                    revert PaymentProcessor__CallerIsNotWhitelistedMarketplace();\\n                }\\n            } else if (securityPolicy.disableExchangeWhitelistEOABypass) {\\n                if (!exchangeWhitelist[securityPolicyId][_msgSender()]) {\\n                    revert PaymentProcessor__TokenSecurityPolicyDoesNotAllowEOACallers();\\n                }\\n            }\\n        }\\n\\n        if (securityPolicy.enforcePricingConstraints) {\\n            if (saleDetails.paymentCoin == address(0)) {\\n                if(collectionPaymentCoins[saleDetails.tokenAddress] != address(0)) {\\n                    revert PaymentProcessor__NativeCurrencyIsNotAnApprovedPaymentMethod();\\n                }\\n            }\\n\\n            _verifySalePriceInRange(\\n                saleDetails.tokenAddress, \\n                saleDetails.tokenId, \\n                saleDetails.amount, \\n                saleDetails.offerPrice);\\n        }\\n\\n        _verifySignedItemListing(saleDetails, signedListing);\\n\\n        if (saleDetails.collectionLevelOffer) {\\n            _verifySignedCollectionOffer(saleDetails, signedOffer);\\n        } else {\\n            _verifySignedItemOffer(saleDetails, signedOffer);\\n        }\\n\\n        MatchedOrder[] memory saleDetailsSingletonBatch = new MatchedOrder[](1);\\n        saleDetailsSingletonBatch[0] = saleDetails;\\n\\n        bool[] memory unsuccessfulFills = _computeAndDistributeProceeds(\\n            ComputeAndDistributeProceedsArgs({\\n                pushPaymentGasLimit: securityPolicy.pushPaymentGasLimit,\\n                purchaser: saleDetails.delegatedPurchaser == address(0) ? saleDetails.buyer : saleDetails.delegatedPurchaser,\\n                paymentCoin: IERC20(saleDetails.paymentCoin),\\n                funcPayout: saleDetails.paymentCoin == address(0) ? _payoutNativeCurrency : _payoutCoinCurrency,\\n                funcDispenseToken: saleDetails.protocol == TokenProtocols.ERC1155 ? _dispenseERC1155Token : _dispenseERC721Token\\n            }),\\n            saleDetailsSingletonBatch\\n        );\\n\\n        tokenDispensedSuccessfully = !unsuccessfulFills[0];\\n\\n        if (tokenDispensedSuccessfully) {\\n            emit BuySingleListing(\\n                saleDetails.marketplace,\\n                saleDetails.tokenAddress,\\n                saleDetails.paymentCoin,\\n                saleDetails.buyer,\\n                saleDetails.seller,\\n                saleDetails.tokenId,\\n                saleDetails.amount,\\n                saleDetails.offerPrice);\\n        }\\n    }\\n\\n    function _validateBundledOffer(\\n        uint256 securityPolicyId,\\n        SecurityPolicy storage securityPolicy,\\n        MatchedOrderBundleBase memory bundleDetails,\\n        Accumulator memory accumulator,\\n        SignatureECDSA memory signedOffer) private {\\n        if (bundleDetails.paymentCoin != address(0)) {\\n            if (msg.value > 0) {\\n                revert PaymentProcessor__CannotIncludeNativeFundsWhenPaymentMethodIsAnERC20Coin();\\n            }\\n    \\n            _verifyPaymentCoinIsApproved(\\n                securityPolicyId, \\n                securityPolicy.enforcePaymentMethodWhitelist, \\n                securityPolicy.enforcePricingConstraints,\\n                bundleDetails.tokenAddress, \\n                bundleDetails.paymentCoin);\\n        } else {\\n            if (msg.value != bundleDetails.offerPrice) {\\n                revert PaymentProcessor__OfferPriceMustEqualSalePrice();\\n            }\\n\\n            if (securityPolicy.enforcePricingConstraints) {\\n                if(collectionPaymentCoins[bundleDetails.tokenAddress] != address(0)) {\\n                    revert PaymentProcessor__NativeCurrencyIsNotAnApprovedPaymentMethod();\\n                }\\n            }\\n        }\\n\\n        if (block.timestamp > bundleDetails.offerExpiration) {\\n            revert PaymentProcessor__OfferHasExpired();\\n        }\\n\\n        if (bundleDetails.delegatedPurchaser != address(0)) {\\n            if (_msgSender() != bundleDetails.delegatedPurchaser) {\\n                revert PaymentProcessor__CallerIsNotTheDelegatedPurchaser();\\n            }\\n\\n            if(securityPolicy.disableDelegatedPurchases) {\\n                revert PaymentProcessor__TokenSecurityPolicyDoesNotAllowDelegatedPurchases();\\n            }\\n        }\\n\\n        if(securityPolicy.disableEIP1271Signatures) {\\n            if (bundleDetails.buyer.code.length > 0) {\\n                revert PaymentProcessor__EIP1271SignaturesAreDisabled();\\n            }\\n        }\\n\\n        if (securityPolicy.enforceExchangeWhitelist) {\\n            if (_msgSender() != tx.origin) {\\n                if (!exchangeWhitelist[securityPolicyId][_msgSender()]) {\\n                    revert PaymentProcessor__CallerIsNotWhitelistedMarketplace();\\n                }\\n            } else if (securityPolicy.disableExchangeWhitelistEOABypass) {\\n                if (!exchangeWhitelist[securityPolicyId][_msgSender()]) {\\n                    revert PaymentProcessor__TokenSecurityPolicyDoesNotAllowEOACallers();\\n                }\\n            }\\n        }\\n\\n        if (accumulator.sumListingPrices != bundleDetails.offerPrice) {\\n            revert PaymentProcessor__BundledOfferPriceMustEqualSumOfAllListingPrices();\\n        }\\n\\n        _verifySignedOfferForBundledItems(\\n            keccak256(abi.encodePacked(accumulator.tokenIds)),\\n            keccak256(abi.encodePacked(accumulator.amounts)),\\n            keccak256(abi.encodePacked(accumulator.salePrices)),\\n            bundleDetails,\\n            signedOffer\\n        );\\n    }\\n\\n    function _validateBundledItems(\\n        bool individualListings,\\n        SecurityPolicy storage securityPolicy,\\n        MatchedOrderBundleExtended memory bundleDetails,\\n        BundledItem[] memory bundledOfferItems,\\n        SignatureECDSA[] memory signedListings) \\n        private returns (Accumulator memory accumulator, MatchedOrder[] memory saleDetailsBatch) {\\n\\n        saleDetailsBatch = new MatchedOrder[](bundledOfferItems.length);\\n        accumulator = Accumulator({\\n            tokenIds: new uint256[](bundledOfferItems.length),\\n            amounts: new uint256[](bundledOfferItems.length),\\n            salePrices: new uint256[](bundledOfferItems.length),\\n            maxRoyaltyFeeNumerators: new uint256[](bundledOfferItems.length),\\n            sellers: new address[](bundledOfferItems.length),\\n            sumListingPrices: 0\\n        });\\n\\n        for (uint256 i = 0; i < bundledOfferItems.length;) {\\n\\n            address seller = bundleDetails.seller;\\n            uint256 listingNonce = bundleDetails.listingNonce;\\n            uint256 listingExpiration = bundleDetails.listingExpiration;\\n\\n            if (individualListings) {\\n                seller = bundledOfferItems[i].seller;\\n                listingNonce = bundledOfferItems[i].listingNonce;\\n                listingExpiration = bundledOfferItems[i].listingExpiration;\\n            }\\n            \\n            MatchedOrder memory saleDetails = \\n                MatchedOrder({\\n                    sellerAcceptedOffer: false,\\n                    collectionLevelOffer: false,\\n                    protocol: bundleDetails.bundleBase.protocol,\\n                    paymentCoin: bundleDetails.bundleBase.paymentCoin,\\n                    tokenAddress: bundleDetails.bundleBase.tokenAddress,\\n                    seller: seller,\\n                    privateBuyer: bundleDetails.bundleBase.privateBuyer,\\n                    buyer: bundleDetails.bundleBase.buyer,\\n                    delegatedPurchaser: bundleDetails.bundleBase.delegatedPurchaser,\\n                    marketplace: bundleDetails.bundleBase.marketplace,\\n                    marketplaceFeeNumerator: bundleDetails.bundleBase.marketplaceFeeNumerator,\\n                    maxRoyaltyFeeNumerator: bundledOfferItems[i].maxRoyaltyFeeNumerator,\\n                    listingNonce: listingNonce,\\n                    offerNonce: bundleDetails.bundleBase.offerNonce,\\n                    listingMinPrice: bundledOfferItems[i].itemPrice,\\n                    offerPrice: bundledOfferItems[i].itemPrice,\\n                    listingExpiration: listingExpiration,\\n                    offerExpiration: bundleDetails.bundleBase.offerExpiration,\\n                    tokenId: bundledOfferItems[i].tokenId,\\n                    amount: bundledOfferItems[i].amount\\n                });\\n\\n            saleDetailsBatch[i] = saleDetails;\\n\\n            accumulator.tokenIds[i] = saleDetails.tokenId;\\n            accumulator.amounts[i] = saleDetails.amount;\\n            accumulator.salePrices[i] = saleDetails.listingMinPrice;\\n            accumulator.maxRoyaltyFeeNumerators[i] = saleDetails.maxRoyaltyFeeNumerator;\\n            accumulator.sellers[i] = saleDetails.seller;\\n            accumulator.sumListingPrices += saleDetails.listingMinPrice;\\n\\n            if (saleDetails.protocol == TokenProtocols.ERC1155) {\\n                if (saleDetails.amount == 0) {\\n                    revert PaymentProcessor__AmountForERC1155SalesGreaterThanZero();\\n                }\\n            } else {\\n                if (saleDetails.amount != ONE) {\\n                    revert PaymentProcessor__AmountForERC721SalesMustEqualOne();\\n                }\\n            }\\n\\n            if (saleDetails.marketplaceFeeNumerator + saleDetails.maxRoyaltyFeeNumerator > FEE_DENOMINATOR) {\\n                revert PaymentProcessor__MarketplaceAndRoyaltyFeesWillExceedSalePrice();\\n            }\\n\\n            if (securityPolicy.enforcePricingConstraints) {\\n                _verifySalePriceInRange(\\n                    saleDetails.tokenAddress, \\n                    saleDetails.tokenId, \\n                    saleDetails.amount, \\n                    saleDetails.offerPrice);\\n            }\\n   \\n            if (individualListings) {\\n                if (block.timestamp > saleDetails.listingExpiration) {\\n                    revert PaymentProcessor__SaleHasExpired();\\n                }\\n\\n                if (saleDetails.privateBuyer != address(0)) {\\n                    if (saleDetails.buyer != saleDetails.privateBuyer) {\\n                        revert PaymentProcessor__BuyerMustBeDesignatedPrivateBuyer();\\n                    }\\n    \\n                    if (securityPolicy.disablePrivateListings) {\\n                        revert PaymentProcessor__TokenSecurityPolicyDoesNotAllowPrivateListings();\\n                    }\\n                }\\n        \\n                if(securityPolicy.disableEIP1271Signatures) {\\n                    if (saleDetails.seller.code.length > 0) {\\n                        revert PaymentProcessor__EIP1271SignaturesAreDisabled();\\n                    }\\n                }\\n    \\n                _verifySignedItemListing(saleDetails, signedListings[i]);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if(!individualListings) {\\n            if (block.timestamp > bundleDetails.listingExpiration) {\\n                revert PaymentProcessor__SaleHasExpired();\\n            }\\n\\n            if (bundleDetails.bundleBase.privateBuyer != address(0)) {\\n                if (bundleDetails.bundleBase.buyer != bundleDetails.bundleBase.privateBuyer) {\\n                    revert PaymentProcessor__BuyerMustBeDesignatedPrivateBuyer();\\n                }\\n    \\n                if (securityPolicy.disablePrivateListings) {\\n                    revert PaymentProcessor__TokenSecurityPolicyDoesNotAllowPrivateListings();\\n                }\\n            }\\n\\n            if(securityPolicy.disableEIP1271Signatures) {\\n                if (bundleDetails.seller.code.length > 0) {\\n                    revert PaymentProcessor__EIP1271SignaturesAreDisabled();\\n                }\\n            }\\n\\n            _verifySignedBundleListing(\\n                AccumulatorHashes({\\n                    tokenIdsKeccakHash: keccak256(abi.encodePacked(accumulator.tokenIds)),\\n                    amountsKeccakHash: keccak256(abi.encodePacked(accumulator.amounts)),\\n                    maxRoyaltyFeeNumeratorsKeccakHash: keccak256(abi.encodePacked(accumulator.maxRoyaltyFeeNumerators)),\\n                    itemPricesKeccakHash: keccak256(abi.encodePacked(accumulator.salePrices))\\n                }),\\n                bundleDetails, \\n                signedListings[0]);\\n        }\\n    }\\n\\n    function _verifySignedItemOffer(\\n        MatchedOrder memory saleDetails,\\n        SignatureECDSA memory signedOffer) private {\\n        bytes32 digest = \\n            _hashTypedDataV4(keccak256(\\n                bytes.concat(\\n                    abi.encode(\\n                        OFFER_APPROVAL_HASH,\\n                        uint8(saleDetails.protocol),\\n                        saleDetails.marketplace,\\n                        saleDetails.marketplaceFeeNumerator,\\n                        saleDetails.delegatedPurchaser,\\n                        saleDetails.buyer,\\n                        saleDetails.tokenAddress,\\n                        saleDetails.tokenId,\\n                        saleDetails.amount,\\n                        saleDetails.offerPrice\\n                    ),\\n                    abi.encode(\\n                        saleDetails.offerExpiration,\\n                        saleDetails.offerNonce,\\n                        _checkAndInvalidateNonce(\\n                            saleDetails.marketplace, \\n                            saleDetails.buyer, \\n                            saleDetails.offerNonce,\\n                            false\\n                        ),\\n                        saleDetails.paymentCoin\\n                    )\\n                )\\n            )\\n        );\\n\\n        if(saleDetails.buyer.code.length > 0) {\\n            _verifyEIP1271Signature(saleDetails.buyer, digest, signedOffer);\\n        } else if (saleDetails.buyer != ECDSA.recover(digest, signedOffer.v, signedOffer.r, signedOffer.s)) {\\n            revert PaymentProcessor__BuyerDidNotAuthorizePurchase();\\n        }\\n    }\\n\\n    function _verifySignedCollectionOffer(\\n        MatchedOrder memory saleDetails,\\n        SignatureECDSA memory signedOffer) private {\\n        bytes32 digest = \\n            _hashTypedDataV4(keccak256(\\n                bytes.concat(\\n                    abi.encode(\\n                        COLLECTION_OFFER_APPROVAL_HASH,\\n                        uint8(saleDetails.protocol),\\n                        saleDetails.collectionLevelOffer,\\n                        saleDetails.marketplace,\\n                        saleDetails.marketplaceFeeNumerator,\\n                        saleDetails.delegatedPurchaser,\\n                        saleDetails.buyer,\\n                        saleDetails.tokenAddress,\\n                        saleDetails.amount,\\n                        saleDetails.offerPrice\\n                    ),\\n                    abi.encode(\\n                        saleDetails.offerExpiration,\\n                        saleDetails.offerNonce,\\n                        _checkAndInvalidateNonce(\\n                            saleDetails.marketplace, \\n                            saleDetails.buyer, \\n                            saleDetails.offerNonce,\\n                            false\\n                        ),\\n                        saleDetails.paymentCoin\\n                    )\\n                )\\n            )\\n        );\\n\\n        if(saleDetails.buyer.code.length > 0) {\\n            _verifyEIP1271Signature(saleDetails.buyer, digest, signedOffer);\\n        } else if (saleDetails.buyer != ECDSA.recover(digest, signedOffer.v, signedOffer.r, signedOffer.s)) {\\n            revert PaymentProcessor__BuyerDidNotAuthorizePurchase();\\n        }\\n    }\\n\\n    function _verifySignedOfferForBundledItems(\\n        bytes32 tokenIdsKeccakHash,\\n        bytes32 amountsKeccakHash,\\n        bytes32 salePricesKeccakHash,\\n        MatchedOrderBundleBase memory bundledOfferDetails,\\n        SignatureECDSA memory signedOffer) private {\\n\\n        bytes32 digest = \\n            _hashTypedDataV4(keccak256(\\n                bytes.concat(\\n                    abi.encode(\\n                        BUNDLED_OFFER_APPROVAL_HASH,\\n                        uint8(bundledOfferDetails.protocol),\\n                        bundledOfferDetails.marketplace,\\n                        bundledOfferDetails.marketplaceFeeNumerator,\\n                        bundledOfferDetails.delegatedPurchaser,\\n                        bundledOfferDetails.buyer,\\n                        bundledOfferDetails.tokenAddress,\\n                        bundledOfferDetails.offerPrice\\n                    ),\\n                    abi.encode(\\n                        bundledOfferDetails.offerExpiration,\\n                        bundledOfferDetails.offerNonce,\\n                        _checkAndInvalidateNonce(\\n                            bundledOfferDetails.marketplace, \\n                            bundledOfferDetails.buyer, \\n                            bundledOfferDetails.offerNonce,\\n                            false\\n                        ),\\n                        bundledOfferDetails.paymentCoin,\\n                        tokenIdsKeccakHash,\\n                        amountsKeccakHash,\\n                        salePricesKeccakHash\\n                    )\\n                )\\n            )\\n        );\\n\\n        if(bundledOfferDetails.buyer.code.length > 0) {\\n            _verifyEIP1271Signature(bundledOfferDetails.buyer, digest, signedOffer);\\n        } else if (bundledOfferDetails.buyer != ECDSA.recover(digest, signedOffer.v, signedOffer.r, signedOffer.s)) {\\n            revert PaymentProcessor__BuyerDidNotAuthorizePurchase();\\n        }\\n    }\\n\\n    function _verifySignedBundleListing(\\n        AccumulatorHashes memory accumulatorHashes,\\n        MatchedOrderBundleExtended memory bundleDetails,\\n        SignatureECDSA memory signedListing) private {\\n\\n        bytes32 digest = \\n            _hashTypedDataV4(keccak256(\\n                bytes.concat(\\n                    abi.encode(\\n                        BUNDLED_SALE_APPROVAL_HASH,\\n                        uint8(bundleDetails.bundleBase.protocol),\\n                        bundleDetails.bundleBase.marketplace,\\n                        bundleDetails.bundleBase.marketplaceFeeNumerator,\\n                        bundleDetails.bundleBase.privateBuyer,\\n                        bundleDetails.seller,\\n                        bundleDetails.bundleBase.tokenAddress\\n                    ),\\n                    abi.encode(\\n                        bundleDetails.listingExpiration,\\n                        bundleDetails.listingNonce,\\n                        _checkAndInvalidateNonce(\\n                            bundleDetails.bundleBase.marketplace, \\n                            bundleDetails.seller, \\n                            bundleDetails.listingNonce,\\n                            false\\n                        ),\\n                        bundleDetails.bundleBase.paymentCoin,\\n                        accumulatorHashes.tokenIdsKeccakHash,\\n                        accumulatorHashes.amountsKeccakHash,\\n                        accumulatorHashes.maxRoyaltyFeeNumeratorsKeccakHash,\\n                        accumulatorHashes.itemPricesKeccakHash\\n                    )\\n                )\\n            )\\n        );\\n\\n        if(bundleDetails.seller.code.length > 0) {\\n            _verifyEIP1271Signature(bundleDetails.seller, digest, signedListing);\\n        } else if (bundleDetails.seller != ECDSA.recover(digest, signedListing.v, signedListing.r, signedListing.s)) {\\n            revert PaymentProcessor__SellerDidNotAuthorizeSale();\\n        }\\n    }\\n\\n    function _verifySignedItemListing(\\n        MatchedOrder memory saleDetails,\\n        SignatureECDSA memory signedListing) private {\\n        bytes32 digest = \\n            _hashTypedDataV4(keccak256(\\n                bytes.concat(\\n                    abi.encode(\\n                        SALE_APPROVAL_HASH,\\n                        uint8(saleDetails.protocol),\\n                        saleDetails.sellerAcceptedOffer,\\n                        saleDetails.marketplace,\\n                        saleDetails.marketplaceFeeNumerator,\\n                        saleDetails.maxRoyaltyFeeNumerator,\\n                        saleDetails.privateBuyer\\n                    ),\\n                    abi.encode(\\n                        saleDetails.seller,\\n                        saleDetails.tokenAddress,\\n                        saleDetails.tokenId,\\n                        saleDetails.amount,\\n                        saleDetails.listingMinPrice,\\n                        saleDetails.listingExpiration,\\n                        saleDetails.listingNonce,\\n                        _checkAndInvalidateNonce(\\n                            saleDetails.marketplace, \\n                            saleDetails.seller, \\n                            saleDetails.listingNonce,\\n                            false\\n                        ),\\n                        saleDetails.paymentCoin\\n                    )\\n                )\\n            )\\n        );\\n\\n        if(saleDetails.seller.code.length > 0) {\\n            _verifyEIP1271Signature(saleDetails.seller, digest, signedListing);\\n        } else if (saleDetails.seller != ECDSA.recover(digest, signedListing.v, signedListing.r, signedListing.s)) {\\n            revert PaymentProcessor__SellerDidNotAuthorizeSale();\\n        }\\n    }\\n\\n    function _checkAndInvalidateNonce(\\n        address marketplace, \\n        address account, \\n        uint256 nonce, \\n        bool wasCancellation) private returns (uint256) {\\n\\n        mapping(uint256 => uint256) storage ptrInvalidatedSignatureBitmap =\\n            invalidatedSignatures[keccak256(abi.encodePacked(marketplace, account))];\\n\\n        unchecked {\\n            uint256 slot = nonce / 256;\\n            uint256 offset = nonce % 256;\\n            uint256 slotValue = ptrInvalidatedSignatureBitmap[slot];\\n\\n            if (((slotValue >> offset) & ONE) == ONE) {\\n                revert PaymentProcessor__SignatureAlreadyUsedOrRevoked();\\n            }\\n\\n            ptrInvalidatedSignatureBitmap[slot] = (slotValue | ONE << offset);\\n        }\\n\\n        emit NonceInvalidated(nonce, account, marketplace, wasCancellation);\\n\\n        return masterNonces[account];\\n    }\\n\\n    function _computeAndDistributeProceeds(\\n        ComputeAndDistributeProceedsArgs memory args,\\n        MatchedOrder[] memory saleDetailsBatch) private returns (bool[] memory unsuccessfulFills) {\\n\\n        unsuccessfulFills = new bool[](saleDetailsBatch.length);\\n\\n        PayoutsAccumulator memory accumulator = PayoutsAccumulator({\\n            lastSeller: address(0),\\n            lastMarketplace: address(0),\\n            lastRoyaltyRecipient: address(0),\\n            accumulatedSellerProceeds: 0,\\n            accumulatedMarketplaceProceeds: 0,\\n            accumulatedRoyaltyProceeds: 0\\n        });\\n\\n        for (uint256 i = 0; i < saleDetailsBatch.length;) {\\n            MatchedOrder memory saleDetails = saleDetailsBatch[i];\\n\\n            bool successfullyDispensedToken = \\n                args.funcDispenseToken(\\n                    saleDetails.seller, \\n                    saleDetails.buyer, \\n                    saleDetails.tokenAddress, \\n                    saleDetails.tokenId, \\n                    saleDetails.amount);\\n\\n            if (!successfullyDispensedToken) {\\n                if (address(args.paymentCoin) == address(0)) {\\n                    revert PaymentProcessor__DispensingTokenWasUnsuccessful();\\n                }\\n\\n                unsuccessfulFills[i] = true;\\n            } else {\\n                SplitProceeds memory proceeds =\\n                    _computePaymentSplits(\\n                        saleDetails.offerPrice,\\n                        saleDetails.tokenAddress,\\n                        saleDetails.tokenId,\\n                        saleDetails.marketplace,\\n                        saleDetails.marketplaceFeeNumerator,\\n                        saleDetails.maxRoyaltyFeeNumerator\\n                    );\\n    \\n                if (proceeds.royaltyRecipient != accumulator.lastRoyaltyRecipient) {\\n                    if(accumulator.accumulatedRoyaltyProceeds > 0) {\\n                        args.funcPayout(accumulator.lastRoyaltyRecipient, args.purchaser, args.paymentCoin, accumulator.accumulatedRoyaltyProceeds, args.pushPaymentGasLimit);\\n                    }\\n    \\n                    accumulator.lastRoyaltyRecipient = proceeds.royaltyRecipient;\\n                    accumulator.accumulatedRoyaltyProceeds = 0;\\n                }\\n    \\n                if (saleDetails.marketplace != accumulator.lastMarketplace) {\\n                    if(accumulator.accumulatedMarketplaceProceeds > 0) {\\n                        args.funcPayout(accumulator.lastMarketplace, args.purchaser, args.paymentCoin, accumulator.accumulatedMarketplaceProceeds, args.pushPaymentGasLimit);\\n                    }\\n    \\n                    accumulator.lastMarketplace = saleDetails.marketplace;\\n                    accumulator.accumulatedMarketplaceProceeds = 0;\\n                }\\n    \\n                if (saleDetails.seller != accumulator.lastSeller) {\\n                    if(accumulator.accumulatedSellerProceeds > 0) {\\n                        args.funcPayout(accumulator.lastSeller, args.purchaser, args.paymentCoin, accumulator.accumulatedSellerProceeds, args.pushPaymentGasLimit);\\n                    }\\n    \\n                    accumulator.lastSeller = saleDetails.seller;\\n                    accumulator.accumulatedSellerProceeds = 0;\\n                }\\n\\n                unchecked {\\n                    accumulator.accumulatedRoyaltyProceeds += proceeds.royaltyProceeds;\\n                    accumulator.accumulatedMarketplaceProceeds += proceeds.marketplaceProceeds;\\n                    accumulator.accumulatedSellerProceeds += proceeds.sellerProceeds;\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if(accumulator.accumulatedRoyaltyProceeds > 0) {\\n            args.funcPayout(accumulator.lastRoyaltyRecipient, args.purchaser, args.paymentCoin, accumulator.accumulatedRoyaltyProceeds, args.pushPaymentGasLimit);\\n        }\\n\\n        if(accumulator.accumulatedMarketplaceProceeds > 0) {\\n            args.funcPayout(accumulator.lastMarketplace, args.purchaser, args.paymentCoin, accumulator.accumulatedMarketplaceProceeds, args.pushPaymentGasLimit);\\n        }\\n\\n        if(accumulator.accumulatedSellerProceeds > 0) {\\n            args.funcPayout(accumulator.lastSeller, args.purchaser, args.paymentCoin, accumulator.accumulatedSellerProceeds, args.pushPaymentGasLimit);\\n        }\\n\\n        return unsuccessfulFills;\\n    }\\n\\n    function _pushProceeds(address to, uint256 proceeds, uint256 pushPaymentGasLimit_) private {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(pushPaymentGasLimit_, to, proceeds, 0, 0, 0, 0)\\n        }\\n\\n        if (!success) {\\n            revert PaymentProcessor__FailedToTransferProceeds();\\n        }\\n    }\\n\\n    function _computePaymentSplits(\\n        uint256 salePrice,\\n        address tokenAddress,\\n        uint256 tokenId,\\n        address marketplaceFeeRecipient,\\n        uint256 marketplaceFeeNumerator,\\n        uint256 maxRoyaltyFeeNumerator) private view returns (SplitProceeds memory proceeds) {\\n\\n        proceeds.sellerProceeds = salePrice;\\n\\n        try IERC2981(tokenAddress).royaltyInfo(\\n            tokenId, \\n            salePrice) \\n            returns (address royaltyReceiver, uint256 royaltyAmount) {\\n            if (royaltyReceiver == address(0)) {\\n                royaltyAmount = 0;\\n            }\\n\\n            if (royaltyAmount > 0) {\\n                if (royaltyAmount > (salePrice * maxRoyaltyFeeNumerator) / FEE_DENOMINATOR) {\\n                    revert PaymentProcessor__OnchainRoyaltiesExceedMaximumApprovedRoyaltyFee();\\n                }\\n\\n                proceeds.royaltyRecipient = royaltyReceiver;\\n                proceeds.royaltyProceeds = royaltyAmount;\\n\\n                unchecked {\\n                    proceeds.sellerProceeds -= royaltyAmount;\\n                }\\n            }\\n        } catch (bytes memory) {}\\n\\n        proceeds.marketplaceProceeds =\\n            marketplaceFeeRecipient != address(0) ? (salePrice * marketplaceFeeNumerator) / FEE_DENOMINATOR : 0;\\n        if (proceeds.marketplaceProceeds > 0) {\\n            unchecked {\\n                proceeds.sellerProceeds -= proceeds.marketplaceProceeds;\\n            }\\n        }\\n    }\\n\\n    function _getTokenSecurityPolicy(address tokenAddress) private view returns (uint256, SecurityPolicy storage) {\\n        uint256 securityPolicyId = tokenSecurityPolicies[tokenAddress];\\n        SecurityPolicy storage securityPolicy = securityPolicies[securityPolicyId];\\n        return (securityPolicyId, securityPolicy);\\n    }\\n\\n    function _requireCallerOwnsSecurityPolicy(uint256 securityPolicyId) private view {\\n        if(_msgSender() != securityPolicies[securityPolicyId].policyOwner) {\\n            revert PaymentProcessor__CallerDoesNotOwnSecurityPolicy();\\n        }\\n    }\\n\\n    function _getFloorAndCeilingPrices(\\n        address tokenAddress, \\n        uint256 tokenId) private view returns (uint256, uint256) {\\n\\n        PricingBounds memory tokenLevelPricingBounds = tokenPricingBounds[tokenAddress][tokenId];\\n        if (tokenLevelPricingBounds.isEnabled) {\\n            return (tokenLevelPricingBounds.floorPrice, tokenLevelPricingBounds.ceilingPrice);\\n        } else {\\n            PricingBounds memory collectionLevelPricingBounds = collectionPricingBounds[tokenAddress];\\n            if (collectionLevelPricingBounds.isEnabled) {\\n                return (collectionLevelPricingBounds.floorPrice, collectionLevelPricingBounds.ceilingPrice);\\n            }\\n        }\\n\\n        return (0, type(uint256).max);\\n    }\\n\\n    function _verifySalePriceInRange(\\n        address tokenAddress, \\n        uint256 tokenId, \\n        uint256 amount, \\n        uint256 salePrice) private view {\\n\\n        uint256 salePricePerUnit = salePrice / amount;\\n\\n        (uint256 floorPrice, uint256 ceilingPrice) = _getFloorAndCeilingPrices(tokenAddress, tokenId);\\n\\n        if(salePricePerUnit < floorPrice) {\\n            revert PaymentProcessor__SalePriceBelowMinimumFloor();\\n        }\\n\\n        if(salePricePerUnit > ceilingPrice) {\\n            revert PaymentProcessor__SalePriceAboveMaximumCeiling();\\n        }\\n    }\\n\\n    function _verifyEIP1271Signature(\\n        address signer, \\n        bytes32 hash, \\n        SignatureECDSA memory signatureComponents) private view {\\n        bool isValidSignatureNow;\\n        \\n        try IERC1271(signer).isValidSignature(\\n            hash, \\n            abi.encodePacked(signatureComponents.r, signatureComponents.s, signatureComponents.v)) \\n            returns (bytes4 magicValue) {\\n            isValidSignatureNow = magicValue == IERC1271.isValidSignature.selector;\\n        } catch {}\\n\\n        if (!isValidSignatureNow) {\\n            revert PaymentProcessor__EIP1271SignatureInvalid();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\"\r\n    },\r\n    \"contracts/IPaymentProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./PaymentProcessorDataTypes.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title IPaymentProcessor\\n * @author Limit Break, Inc.\\n * @notice Interface definition for payment processor contracts.\\n */\\ninterface IPaymentProcessor is IERC165 {\\n\\n    /// @notice Emitted when a bundle of ERC-721 tokens is successfully purchased using `buyBundledListing`\\n    event BuyBundledListingERC721(\\n        address indexed marketplace,\\n        address indexed tokenAddress,\\n        address indexed paymentCoin,\\n        address buyer,\\n        address seller,\\n        bool[] unsuccessfulFills,\\n        uint256[] tokenIds,\\n        uint256[] salePrices);\\n\\n    /// @notice Emitted when a bundle of ERC-1155 tokens is successfully purchased using `buyBundledListing`\\n    event BuyBundledListingERC1155(\\n        address indexed marketplace,\\n        address indexed tokenAddress,\\n        address indexed paymentCoin,\\n        address buyer,\\n        address seller,\\n        bool[] unsuccessfulFills,\\n        uint256[] tokenIds,\\n        uint256[] amounts,\\n        uint256[] salePrices);\\n\\n    /// @notice Emitted for each token successfully purchased using either `buySingleLising` or `buyBatchOfListings`\\n    event BuySingleListing(\\n        address indexed marketplace,\\n        address indexed tokenAddress,\\n        address indexed paymentCoin,\\n        address buyer,\\n        address seller,\\n        uint256 tokenId,\\n        uint256 amount,\\n        uint256 salePrice);\\n\\n    /// @notice Emitted when a security policy is either created or modified\\n    event CreatedOrUpdatedSecurityPolicy(\\n        uint256 indexed securityPolicyId, \\n        bool enforceExchangeWhitelist,\\n        bool enforcePaymentMethodWhitelist,\\n        bool enforcePricingConstraints,\\n        bool disablePrivateListings,\\n        bool disableDelegatedPurchases,\\n        bool disableEIP1271Signatures,\\n        bool disableExchangeWhitelistEOABypass,\\n        uint32 pushPaymentGasLimit,\\n        string policyName);\\n\\n    /// @notice Emitted when an address is added to the exchange whitelist for a security policy\\n    event ExchangeAddedToWhitelist(uint256 indexed securityPolicyId, address indexed exchange);\\n\\n    /// @notice Emitted when an address is removed from the exchange whitelist for a security policy\\n    event ExchangeRemovedFromWhitelist(uint256 indexed securityPolicyId, address indexed exchange);\\n\\n    /// @notice Emitted when a user revokes all of their existing listings or offers that share the master nonce.\\n    event MasterNonceInvalidated(uint256 indexed nonce, address indexed account);\\n\\n    /// @notice Emitted when a user revokes a single listing or offer nonce for a specific marketplace.\\n    event NonceInvalidated(\\n        uint256 indexed nonce, \\n        address indexed account, \\n        address indexed marketplace, \\n        bool wasCancellation);\\n\\n    /// @notice Emitted when a coin is added to the approved coins mapping for a security policy\\n    event PaymentMethodAddedToWhitelist(uint256 indexed securityPolicyId, address indexed coin);\\n\\n    /// @notice Emitted when a coin is removed from the approved coins mapping for a security policy\\n    event PaymentMethodRemovedFromWhitelist(uint256 indexed securityPolicyId, address indexed coin);\\n\\n    /// @notice Emitted when the ownership of a security policy is transferred to a new account\\n    event SecurityPolicyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a collection of ERC-721 tokens is successfully swept using `sweepCollection`\\n    event SweepCollectionERC721(\\n        address indexed marketplace,\\n        address indexed tokenAddress,\\n        address indexed paymentCoin,\\n        address buyer,\\n        bool[] unsuccessfulFills,\\n        address[] sellers,\\n        uint256[] tokenIds,\\n        uint256[] salePrices);\\n\\n    /// @notice Emitted when a collection of ERC-1155 tokens is successfully swept using `sweepCollection`\\n    event SweepCollectionERC1155(\\n        address indexed marketplace,\\n        address indexed tokenAddress,\\n        address indexed paymentCoin,\\n        address buyer,\\n        bool[] unsuccessfulFills,\\n        address[] sellers,\\n        uint256[] tokenIds,\\n        uint256[] amounts,\\n        uint256[] salePrices);\\n\\n    /// @notice Emitted whenever the designated security policy id changes for a collection.\\n    event UpdatedCollectionSecurityPolicy(address indexed tokenAddress, uint256 indexed securityPolicyId);\\n\\n    /// @notice Emitted whenever the supported ERC-20 payment is set for price-constrained collections.\\n    event UpdatedCollectionPaymentCoin(address indexed tokenAddress, address indexed paymentCoin);\\n\\n    /// @notice Emitted whenever pricing bounds change at a collection level for price-constrained collections.\\n    event UpdatedCollectionLevelPricingBoundaries(\\n        address indexed tokenAddress, \\n        uint256 floorPrice, \\n        uint256 ceilingPrice);\\n\\n    /// @notice Emitted whenever pricing bounds change at a token level for price-constrained collections.\\n    event UpdatedTokenLevelPricingBoundaries(\\n        address indexed tokenAddress, \\n        uint256 indexed tokenId, \\n        uint256 floorPrice, \\n        uint256 ceilingPrice);\\n    \\n    function createSecurityPolicy(\\n        bool enforceExchangeWhitelist,\\n        bool enforcePaymentMethodWhitelist,\\n        bool enforcePricingConstraints,\\n        bool disablePrivateListings,\\n        bool disableDelegatedPurchases,\\n        bool disableEIP1271Signatures,\\n        bool disableExchangeWhitelistEOABypass,\\n        uint32 pushPaymentGasLimit,\\n        string calldata registryName) external returns (uint256);\\n\\n    function updateSecurityPolicy(\\n        uint256 securityPolicyId,\\n        bool enforceExchangeWhitelist,\\n        bool enforcePaymentMethodWhitelist,\\n        bool enforcePricingConstraints,\\n        bool disablePrivateListings,\\n        bool disableDelegatedPurchases,\\n        bool disableEIP1271Signatures,\\n        bool disableExchangeWhitelistEOABypass,\\n        uint32 pushPaymentGasLimit,\\n        string calldata registryName) external;\\n\\n    function transferSecurityPolicyOwnership(uint256 securityPolicyId, address newOwner) external;\\n    function renounceSecurityPolicyOwnership(uint256 securityPolicyId) external;\\n    function setCollectionSecurityPolicy(address tokenAddress, uint256 securityPolicyId) external;\\n    function setCollectionPaymentCoin(address tokenAddress, address coin) external;\\n    function setCollectionPricingBounds(address tokenAddress, PricingBounds calldata pricingBounds) external;\\n\\n    function setTokenPricingBounds(\\n        address tokenAddress, \\n        uint256[] calldata tokenIds, \\n        PricingBounds[] calldata pricingBounds) external;\\n\\n    function whitelistExchange(uint256 securityPolicyId, address account) external;\\n    function unwhitelistExchange(uint256 securityPolicyId, address account) external;\\n    function whitelistPaymentMethod(uint256 securityPolicyId, address coin) external;\\n    function unwhitelistPaymentMethod(uint256 securityPolicyId, address coin) external;\\n    function revokeMasterNonce() external;\\n    function revokeSingleNonce(address marketplace, uint256 nonce) external;\\n\\n    function buySingleListing(\\n        MatchedOrder memory saleDetails, \\n        SignatureECDSA memory signedListing, \\n        SignatureECDSA memory signedOffer\\n    ) external payable;\\n\\n    function buyBatchOfListings(\\n        MatchedOrder[] calldata saleDetailsArray,\\n        SignatureECDSA[] calldata signedListings,\\n        SignatureECDSA[] calldata signedOffers\\n    ) external payable;\\n\\n    function buyBundledListing(\\n        SignatureECDSA memory signedListing,\\n        SignatureECDSA memory signedOffer,\\n        MatchedOrderBundleExtended memory bundleDetails,\\n        BundledItem[] calldata bundleItems) external payable;\\n\\n    function sweepCollection(\\n        SignatureECDSA memory signedOffer,\\n        MatchedOrderBundleBase memory bundleDetails,\\n        BundledItem[] calldata bundleItems,\\n        SignatureECDSA[] calldata signedListings) external payable;\\n\\n    function getDomainSeparator() external view returns (bytes32);\\n    function getSecurityPolicy(uint256 securityPolicyId) external view returns (SecurityPolicy memory);\\n    function isWhitelisted(uint256 securityPolicyId, address account) external view returns (bool);\\n    function isPaymentMethodApproved(uint256 securityPolicyId, address coin) external view returns (bool);\\n    function getTokenSecurityPolicyId(address collectionAddress) external view returns (uint256);\\n    function isCollectionPricingImmutable(address tokenAddress) external view returns (bool);\\n    function isTokenPricingImmutable(address tokenAddress, uint256 tokenId) external view returns (bool);\\n    function getFloorPrice(address tokenAddress, uint256 tokenId) external view returns (uint256);\\n    function getCeilingPrice(address tokenAddress, uint256 tokenId) external view returns (uint256);\\n}\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PaymentProcessorDataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nenum TokenProtocols { ERC721, ERC1155 }\\n\\n/**\\n * @dev The `v`, `r`, and `s` components of an ECDSA signature.  For more information\\n *      [refer to this article](https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7).\\n */\\nstruct SignatureECDSA {\\n    uint8 v;\\n    bytes32 r;\\n    bytes32 s;\\n}\\n\\n/**\\n * @dev This struct is used as input to `buySingleListing` and `buyBatchOfListings` calls after an exchange matches\\n * @dev a buyer and seller.\\n *\\n * @dev **sellerAcceptedOffer**: Denotes that the transaction was initiated by the seller account by accepting an offer.\\n * @dev When true, ETH/native payments are not accepted, and only ERC-20 payment methods can be used.\\n * @dev **collectionLevelOffer**: Denotes that the offer that was accepted was at the collection level.  When `true`,\\n * @dev the Buyer should be prompted to sign the the collection offer approval stucture.  When false, the Buyer should\\n * @dev prompted to sign the offer approval structure.\\n * @dev **protocol**: 0 for ERC-721 or 1 for ERC-1155.  See `TokenProtocols`.\\n * @dev **paymentCoin**: `address(0)` denotes native currency sale.  Otherwise ERC-20 payment coin address.\\n * @dev **tokenAddress**: The smart contract address of the ERC-721 or ERC-1155 token being sold.\\n * @dev **seller**: The seller/current owner of the token.\\n * @dev **privateBuyer**: `address(0)` denotes a listing available to any buyer.  Otherwise, this denotes the privately\\n * @dev designated buyer.\\n * @dev **buyer**: The buyer/new owner of the token.\\n * @dev **delegatedPurchaser**: Allows a buyer to delegate an address to buy a token on their behalf.  This would allow\\n * @dev a warm burner wallet to purchase tokens and allow them to be received in a cold wallet, for example.\\n * @dev **marketplace**: The address designated to receive marketplace fees, if applicable.\\n * @dev **marketplaceFeeNumerator**: Marketplace fee percentage.  Denominator is 10,000.\\n * @dev 0.5% fee numerator is 50, 1% fee numerator is 100, 10% fee numerator is 1,000 and so on.\\n * @dev **maxRoyaltyFeeNumerator**: Maximum approved royalty fee percentage.  Denominator is 10,000.\\n * @dev 0.5% fee numerator is 50, 1% fee numerator is 100, 10% fee numerator is 1,000 and so on.\\n * @dev Marketplaces are responsible to query EIP-2981 royalty info from the NFT contract when presenting this\\n * @dev for signature.\\n * @dev **listingNonce**: The nonce the seller signed in the listing.\\n * @dev **offerNonce**: The nonce the buyer signed in the offer.\\n * @dev **listingMinPrice**: The minimum price the seller signed off on, in wei.  Buyer can buy above, \\n * @dev but not below the seller-approved minimum price.\\n * @dev **offerPrice**: The sale price of the matched order, in wei.  Buyer signs off on the final offer price.\\n * @dev **listingExpiration**: The timestamp at which the listing expires.\\n * @dev **offerExpiration**: The timestamp at which the offer expires.\\n * @dev **tokenId**: The id of the token being sold.  For ERC-721 tokens, this is the specific NFT token id.  \\n * @dev For ERC-1155 tokens, this denotes the token type id.\\n * @dev **amount**: The number of tokens being sold.  For ERC-721 tokens, this must always be `1`.\\n * @dev For ERC-1155 tokens where balances are transferred, this must be greater than or equal to `1`.\\n */\\nstruct MatchedOrder {\\n    bool sellerAcceptedOffer;\\n    bool collectionLevelOffer;\\n    TokenProtocols protocol;\\n    address paymentCoin;\\n    address tokenAddress;\\n    address seller;\\n    address privateBuyer;\\n    address buyer;\\n    address delegatedPurchaser;\\n    address marketplace;\\n    uint256 marketplaceFeeNumerator;\\n    uint256 maxRoyaltyFeeNumerator;\\n    uint256 listingNonce;\\n    uint256 offerNonce;\\n    uint256 listingMinPrice;\\n    uint256 offerPrice;\\n    uint256 listingExpiration;\\n    uint256 offerExpiration;\\n    uint256 tokenId;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev This struct is used as input to `buyBundledListing` calls after an exchange matches a buyer and seller.\\n * @dev Wraps `MatchedOrderBundleBase` and adds seller, listing nonce and listing expiration.\\n *\\n * @dev **bundleBase**: Includes all fields from `MatchedOrderBundleBase`.\\n * @dev **seller**: The seller/current owner of all the tokens in a bundled listing.\\n * @dev **listingNonce**: The nonce the seller signed in the listing. Only one nonce is required approving the sale\\n * @dev of multiple tokens from one collection.\\n * @dev **listingExpiration**: The timestamp at which the listing expires.\\n */\\nstruct MatchedOrderBundleExtended {\\n    MatchedOrderBundleBase bundleBase; \\n    address seller;\\n    uint256 listingNonce;\\n    uint256 listingExpiration;\\n}\\n\\n/**\\n * @dev This struct is used as input to `sweepCollection` calls after an exchange matches multiple individual listings\\n * @dev with a single buyer.\\n *\\n * @dev **protocol**: 0 for ERC-721 or 1 for ERC-1155.  See `TokenProtocols`.\\n * @dev **paymentCoin**: `address(0)` denotes native currency sale.  Otherwise ERC-20 payment coin address.\\n * @dev **tokenAddress**: The smart contract address of the ERC-721 or ERC-1155 token being sold.\\n * @dev **privateBuyer**: `address(0)` denotes a listing available to any buyer.  Otherwise, this denotes the privately\\n * @dev designated buyer.\\n * @dev **buyer**: The buyer/new owner of the token.\\n * @dev **delegatedPurchaser**: Allows a buyer to delegate an address to buy a token on their behalf.  This would allow\\n * @dev a warm burner wallet to purchase tokens and allow them to be received in a cold wallet, for example.\\n * @dev **marketplace**: The address designated to receive marketplace fees, if applicable.\\n * @dev **marketplaceFeeNumerator**: Marketplace fee percentage.  Denominator is 10,000.\\n * @dev 0.5% fee numerator is 50, 1% fee numerator is 100, 10% fee numerator is 1,000 and so on.\\n * @dev **offerNonce**: The nonce the buyer signed in the offer.  Only one nonce is required approving the purchase\\n * @dev of multiple tokens from one collection.\\n * @dev **offerPrice**: The sale price of the entire order, in wei.  Buyer signs off on the final offer price.\\n * @dev **offerExpiration**: The timestamp at which the offer expires.\\n */\\nstruct MatchedOrderBundleBase {\\n    TokenProtocols protocol;\\n    address paymentCoin;\\n    address tokenAddress;\\n    address privateBuyer;\\n    address buyer;\\n    address delegatedPurchaser;\\n    address marketplace;\\n    uint256 marketplaceFeeNumerator;\\n    uint256 offerNonce;\\n    uint256 offerPrice;\\n    uint256 offerExpiration;\\n}\\n\\n/**\\n * @dev This struct is used as input to `sweepCollection` and `buyBundledListing` calls.\\n * @dev These fields are required per individual item listed.\\n *\\n * @dev **tokenId**: The id of the token being sold.  For ERC-721 tokens, this is the specific NFT token id.  \\n * @dev For ERC-1155 tokens, this denotes the token type id.\\n * @dev **amount**: The number of tokens being sold.  For ERC-721 tokens, this must always be `1`.\\n * @dev For ERC-1155 tokens where balances are transferred, this must be greater than or equal to `1`.\\n * @dev **maxRoyaltyFeeNumerator**: Maximum approved royalty fee percentage.  Denominator is 10,000.\\n * @dev 0.5% fee numerator is 50, 1% fee numerator is 100, 10% fee numerator is 1,000 and so on.\\n * @dev Marketplaces are responsible to query EIP-2981 royalty info from the NFT contract when presenting this\\n * @dev for signature.\\n * @dev **itemPrice**: The exact price the seller signed off on for an individual item, in wei. \\n * @dev Purchase price for the item must be exactly the listing item price.\\n * @dev **listingNonce**: The nonce the seller signed in the listing for an individual item.  This should be set\\n * @dev for collection sweep transactions, but it should be zero for bundled listings, as the listing nonce is global\\n * @dev in that case.\\n * @dev **listingExpiration**: The timestamp at which an individual listing expires. This should be set\\n * @dev for collection sweep transactions, but it should be zero for bundled listings, as the listing nonce is global\\n * @dev in that case.\\n * @dev **seller**: The seller/current owner of the token. This should be set\\n * @dev for collection sweep transactions, but it should be zero for bundled listings, as the listing nonce is global\\n * @dev in that case.\\n */\\nstruct BundledItem {\\n    uint256 tokenId;\\n    uint256 amount;\\n    uint256 maxRoyaltyFeeNumerator;\\n    uint256 itemPrice;\\n    uint256 listingNonce;\\n    uint256 listingExpiration;\\n    address seller;\\n}\\n\\n/**\\n * @dev This struct is used to define the marketplace behavior and constraints, giving creators flexibility to define\\n *      marketplace behavior(s).\\n *\\n * @dev **enforceExchangeWhitelist**: Requires `buy` calls from smart contracts to be whitelisted.\\n * @dev **enforcePaymentMethodWhitelist**: Requires ERC-20 payment coins for `buy` calls to be whitelisted as an \\n * @dev approved payment method.\\n * @dev **enforcePricingConstraints**: Allows the creator to specify exactly one approved payment method, a minimum\\n * @dev floor price and a maximum ceiling price.  When true, this value supercedes `enforcePaymentMethodWhitelist`.\\n * @dev **disablePrivateListings**: Disables private sales.\\n * @dev **disableDelegatedPurchases**: Disables purchases by delegated accounts on behalf of buyers.\\n * @dev **disableEIP1271Signatures**: Disables sales and purchases using multi-sig wallets that implement EIP-1271.\\n * @dev Enforces that buyers and sellers are EOAs.\\n * @dev **disableExchangeWhitelistEOABypass**: Has no effect when `enforceExchangeWhitelist` is false.\\n * @dev When exchange whitelist is enforced, this disables calls from EOAs, effectively requiring purchases to be\\n * @dev composed by whitelisted 3rd party exchange contracts.\\n * @dev **pushPaymentGasLimit**: This is the amount of gas to forward when pushing native payments.\\n * @dev At the time this contract was written, 2300 gas is the recommended amount, but should costs of EVM opcodes\\n * @dev change in the future, this field can be used to increase or decrease the amount of forwarded gas.  Care should\\n * @dev be taken to ensure not enough gas is forwarded to result in possible re-entrancy.\\n * @dev **policyOwner**: The account that has access to modify a security policy or update the exchange whitelist\\n * @dev or approved payment list for the security policy.\\n */\\nstruct SecurityPolicy {\\n    bool enforceExchangeWhitelist;\\n    bool enforcePaymentMethodWhitelist;\\n    bool enforcePricingConstraints;\\n    bool disablePrivateListings;\\n    bool disableDelegatedPurchases;\\n    bool disableEIP1271Signatures;\\n    bool disableExchangeWhitelistEOABypass;\\n    uint32 pushPaymentGasLimit;\\n    address policyOwner;\\n}\\n\\n/**\\n * @dev This struct is used to define pricing constraints for a collection or individual token.\\n *\\n * @dev **isEnabled**: When true, this indicates that pricing constraints are set for the collection or token.\\n * @dev **isImmutable**: When true, this indicates that pricing constraints are immutable and cannot be changed.\\n * @dev **floorPrice**: The minimum price for a token or collection.  This is only enforced when \\n * @dev `enforcePricingConstraints` is `true`.\\n * @dev **ceilingPrice**: The maximum price for a token or collection.  This is only enforced when\\n * @dev `enforcePricingConstraints` is `true`.\\n */\\nstruct PricingBounds {\\n    bool isEnabled;\\n    bool isImmutable;\\n    uint256 floorPrice;\\n    uint256 ceilingPrice;\\n}\\n\\n/** \\n * @dev Internal contract use only - this is not a public-facing struct\\n */\\nstruct SplitProceeds {\\n    address royaltyRecipient;\\n    uint256 royaltyProceeds;\\n    uint256 marketplaceProceeds;\\n    uint256 sellerProceeds;\\n}\\n\\n/** \\n * @dev Internal contract use only - this is not a public-facing struct\\n */\\nstruct Accumulator {\\n    uint256[] tokenIds;\\n    uint256[] amounts;\\n    uint256[] salePrices;\\n    uint256[] maxRoyaltyFeeNumerators;\\n    address[] sellers;\\n    uint256 sumListingPrices;\\n}\\n\\n/** \\n * @dev Internal contract use only - this is not a public-facing struct\\n */\\nstruct AccumulatorHashes {\\n    bytes32 tokenIdsKeccakHash;\\n    bytes32 amountsKeccakHash;\\n    bytes32 maxRoyaltyFeeNumeratorsKeccakHash;\\n    bytes32 itemPricesKeccakHash;\\n}\\n\\n/** \\n * @dev Internal contract use only - this is not a public-facing struct\\n */\\nstruct PayoutsAccumulator {\\n    address lastSeller;\\n    address lastMarketplace;\\n    address lastRoyaltyRecipient;\\n    uint256 accumulatedSellerProceeds;\\n    uint256 accumulatedMarketplaceProceeds;\\n    uint256 accumulatedRoyaltyProceeds;\\n}\\n\\n/**\\n * @dev Internal contract use only - this is not a public-facing struct\\n */\\nstruct ComputeAndDistributeProceedsArgs {\\n    uint256 pushPaymentGasLimit;\\n    address purchaser;\\n    IERC20 paymentCoin;\\n    function(address,address,IERC20,uint256,uint256) funcPayout;\\n    function(address,address,address,uint256,uint256) returns (bool) funcDispenseToken;\\n}\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@limitbreak/=node_modules/@limitbreak/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"@rari-capital/solmate/=node_modules/@rari-capital/solmate/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 600\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"defaultContractOwner_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"defaultPushPaymentGasLimit_\",\"type\":\"uint32\"},{\"internalType\":\"address[]\",\"name\":\"defaultPaymentMethods\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"PaymentProcessor__AddressCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__AmountForERC1155SalesGreaterThanZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__AmountForERC721SalesMustEqualOne\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__BundledOfferPriceMustEqualSumOfAllListingPrices\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__BuyerDidNotAuthorizePurchase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__BuyerMustBeDesignatedPrivateBuyer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__CallerDoesNotOwnSecurityPolicy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__CallerIsNotTheDelegatedPurchaser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__CallerIsNotWhitelistedMarketplace\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__CallerMustHaveElevatedPermissionsForSpecifiedNFT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__CannotIncludeNativeFundsWhenPaymentMethodIsAnERC20Coin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__CeilingPriceMustBeGreaterThanFloorPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__CoinDoesNotImplementDecimalsAndLikelyIsNotAnERC20Token\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__CoinIsApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__CoinIsNotApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__CollectionLevelOrItemLevelOffersCanOnlyBeMadeUsingERC20PaymentMethods\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__DispensingTokenWasUnsuccessful\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__EIP1271SignatureInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__EIP1271SignaturesAreDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__ExchangeIsNotWhitelisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__ExchangeIsWhitelisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__FailedToTransferProceeds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__InputArrayLengthCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__InputArrayLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__MarketplaceAndRoyaltyFeesWillExceedSalePrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__NativeCurrencyIsNotAnApprovedPaymentMethod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__OfferHasExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__OfferPriceMustEqualSalePrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__OnchainRoyaltiesExceedMaximumApprovedRoyaltyFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__OverpaidNativeFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__PaymentCoinIsNotAnApprovedPaymentMethod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__PricingBoundsAreImmutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__RanOutOfNativeFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__SaleHasExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__SalePriceAboveMaximumCeiling\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__SalePriceBelowMinimumFloor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__SalePriceBelowSellerApprovedMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__SecurityPolicyDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__SecurityPolicyOwnershipCannotBeTransferredToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__SellerDidNotAuthorizeSale\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__SignatureAlreadyUsedOrRevoked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__TokenSecurityPolicyDoesNotAllowDelegatedPurchases\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__TokenSecurityPolicyDoesNotAllowEOACallers\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaymentProcessor__TokenSecurityPolicyDoesNotAllowPrivateListings\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"unsuccessfulFills\",\"type\":\"bool[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"salePrices\",\"type\":\"uint256[]\"}],\"name\":\"BuyBundledListingERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"unsuccessfulFills\",\"type\":\"bool[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"salePrices\",\"type\":\"uint256[]\"}],\"name\":\"BuyBundledListingERC721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"BuySingleListing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enforceExchangeWhitelist\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enforcePaymentMethodWhitelist\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enforcePricingConstraints\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disablePrivateListings\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disableDelegatedPurchases\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disableEIP1271Signatures\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disableExchangeWhitelistEOABypass\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"pushPaymentGasLimit\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"policyName\",\"type\":\"string\"}],\"name\":\"CreatedOrUpdatedSecurityPolicy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"name\":\"ExchangeAddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"name\":\"ExchangeRemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MasterNonceInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"wasCancellation\",\"type\":\"bool\"}],\"name\":\"NonceInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"}],\"name\":\"PaymentMethodAddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"}],\"name\":\"PaymentMethodRemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SecurityPolicyOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"unsuccessfulFills\",\"type\":\"bool[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"sellers\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"salePrices\",\"type\":\"uint256[]\"}],\"name\":\"SweepCollectionERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"unsuccessfulFills\",\"type\":\"bool[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"sellers\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"salePrices\",\"type\":\"uint256[]\"}],\"name\":\"SweepCollectionERC721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"floorPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ceilingPrice\",\"type\":\"uint256\"}],\"name\":\"UpdatedCollectionLevelPricingBoundaries\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"}],\"name\":\"UpdatedCollectionPaymentCoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"}],\"name\":\"UpdatedCollectionSecurityPolicy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"floorPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ceilingPrice\",\"type\":\"uint256\"}],\"name\":\"UpdatedTokenLevelPricingBoundaries\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUNDLED_OFFER_APPROVAL_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUNDLED_SALE_APPROVAL_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COLLECTION_OFFER_APPROVAL_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_SECURITY_POLICY_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OFFER_APPROVAL_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SALE_APPROVAL_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"sellerAcceptedOffer\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"collectionLevelOffer\",\"type\":\"bool\"},{\"internalType\":\"enum TokenProtocols\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"privateBuyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegatedPurchaser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"marketplaceFeeNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRoyaltyFeeNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingMinPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct MatchedOrder[]\",\"name\":\"saleDetailsArray\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct SignatureECDSA[]\",\"name\":\"signedListings\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct SignatureECDSA[]\",\"name\":\"signedOffers\",\"type\":\"tuple[]\"}],\"name\":\"buyBatchOfListings\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct SignatureECDSA\",\"name\":\"signedListing\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct SignatureECDSA\",\"name\":\"signedOffer\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"enum TokenProtocols\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"privateBuyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegatedPurchaser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"marketplaceFeeNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerExpiration\",\"type\":\"uint256\"}],\"internalType\":\"struct MatchedOrderBundleBase\",\"name\":\"bundleBase\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"listingNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingExpiration\",\"type\":\"uint256\"}],\"internalType\":\"struct MatchedOrderBundleExtended\",\"name\":\"bundleDetails\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRoyaltyFeeNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingExpiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"internalType\":\"struct BundledItem[]\",\"name\":\"bundleItems\",\"type\":\"tuple[]\"}],\"name\":\"buyBundledListing\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"sellerAcceptedOffer\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"collectionLevelOffer\",\"type\":\"bool\"},{\"internalType\":\"enum TokenProtocols\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"privateBuyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegatedPurchaser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"marketplaceFeeNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRoyaltyFeeNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingMinPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct MatchedOrder\",\"name\":\"saleDetails\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct SignatureECDSA\",\"name\":\"signedListing\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct SignatureECDSA\",\"name\":\"signedOffer\",\"type\":\"tuple\"}],\"name\":\"buySingleListing\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collectionPaymentCoins\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enforceExchangeWhitelist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enforcePaymentMethodWhitelist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enforcePricingConstraints\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disablePrivateListings\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disableDelegatedPurchases\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disableEIP1271Signatures\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disableExchangeWhitelistEOABypass\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"pushPaymentGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"registryName\",\"type\":\"string\"}],\"name\":\"createSecurityPolicy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCeilingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getFloorPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"}],\"name\":\"getSecurityPolicy\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"enforceExchangeWhitelist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enforcePaymentMethodWhitelist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enforcePricingConstraints\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disablePrivateListings\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disableDelegatedPurchases\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disableEIP1271Signatures\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disableExchangeWhitelistEOABypass\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"pushPaymentGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"policyOwner\",\"type\":\"address\"}],\"internalType\":\"struct SecurityPolicy\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"}],\"name\":\"getTokenSecurityPolicyId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"isCollectionPricingImmutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"}],\"name\":\"isPaymentMethodApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isTokenPricingImmutable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"masterNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"}],\"name\":\"renounceSecurityPolicyOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeMasterNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"revokeSingleNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"}],\"name\":\"setCollectionPaymentCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isImmutable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"floorPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceilingPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct PricingBounds\",\"name\":\"pricingBounds\",\"type\":\"tuple\"}],\"name\":\"setCollectionPricingBounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"}],\"name\":\"setCollectionSecurityPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isImmutable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"floorPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceilingPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct PricingBounds[]\",\"name\":\"pricingBounds\",\"type\":\"tuple[]\"}],\"name\":\"setTokenPricingBounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct SignatureECDSA\",\"name\":\"signedOffer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum TokenProtocols\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentCoin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"privateBuyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegatedPurchaser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"marketplace\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"marketplaceFeeNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerExpiration\",\"type\":\"uint256\"}],\"internalType\":\"struct MatchedOrderBundleBase\",\"name\":\"bundleDetails\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRoyaltyFeeNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingExpiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"internalType\":\"struct BundledItem[]\",\"name\":\"bundleItems\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct SignatureECDSA[]\",\"name\":\"signedListings\",\"type\":\"tuple[]\"}],\"name\":\"sweepCollection\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferSecurityPolicyOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unwhitelistExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"}],\"name\":\"unwhitelistPaymentMethod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enforceExchangeWhitelist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enforcePaymentMethodWhitelist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enforcePricingConstraints\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disablePrivateListings\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disableDelegatedPurchases\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disableEIP1271Signatures\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disableExchangeWhitelistEOABypass\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"pushPaymentGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"registryName\",\"type\":\"string\"}],\"name\":\"updateSecurityPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"whitelistExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"securityPolicyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coin\",\"type\":\"address\"}],\"name\":\"whitelistPaymentMethod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PaymentProcessor", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "600", "ConstructorArguments": "000000000000000000000000f0e41a1f6e417c0666e3577422297b71ce5455770000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f0000000000000000000000008f3cf7ad23cd3cadbd9735aff958023239c6a063", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}