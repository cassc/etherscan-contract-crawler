{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/relayer/wormholeRelayer/WormholeRelayer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.19;\\n\\nimport {IWormholeRelayer} from \\\"../../interfaces/relayer/IWormholeRelayerTyped.sol\\\";\\n\\nimport {getDefaultDeliveryProviderState} from \\\"./WormholeRelayerStorage.sol\\\";\\nimport {WormholeRelayerGovernance} from \\\"./WormholeRelayerGovernance.sol\\\";\\nimport {WormholeRelayerSend} from \\\"./WormholeRelayerSend.sol\\\";\\nimport {WormholeRelayerDelivery} from \\\"./WormholeRelayerDelivery.sol\\\";\\nimport {WormholeRelayerBase} from \\\"./WormholeRelayerBase.sol\\\";\\n\\n//WormholeRelayerGovernance inherits from ERC1967Upgrade, i.e. this is a proxy contract!\\ncontract WormholeRelayer is\\n    WormholeRelayerGovernance,\\n    WormholeRelayerSend,\\n    WormholeRelayerDelivery,\\n    IWormholeRelayer\\n{\\n    //the only normal storage variable - everything else uses slot pattern\\n    //no point doing it for this one since it is entirely one-off and of no interest to the rest\\n    //  of the contract and it also can't accidentally be moved because we are at the bottom of\\n    //  the inheritance hierarchy here\\n    bool private initialized;\\n\\n    constructor(address wormhole) WormholeRelayerBase(wormhole) {}\\n\\n    //needs to be called upon construction of the EC1967 proxy\\n    function initialize(address defaultDeliveryProvider) public {\\n        assert(!initialized);\\n        initialized = true;\\n        getDefaultDeliveryProviderState().defaultDeliveryProvider = defaultDeliveryProvider;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/relayer/IWormholeRelayerTyped.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./TypedUnits.sol\\\";\\n\\n/**\\n * @title WormholeRelayer\\n * @author \\n * @notice This project allows developers to build cross-chain applications powered by Wormhole without needing to \\n * write and run their own relaying infrastructure\\n * \\n * We implement the IWormholeRelayer interface that allows users to request a delivery provider to relay a payload (and/or additional messages) \\n * to a chain and address of their choice.\\n */\\n\\n/**\\n * @notice VaaKey identifies a wormhole message\\n *\\n * @custom:member chainId Wormhole chain ID of the chain where this VAA was emitted from\\n * @custom:member emitterAddress Address of the emitter of the VAA, in Wormhole bytes32 format\\n * @custom:member sequence Sequence number of the VAA\\n */\\nstruct VaaKey {\\n    uint16 chainId;\\n    bytes32 emitterAddress;\\n    uint64 sequence;\\n}\\n\\n// 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\\nuint8 constant VAA_KEY_TYPE = 1;\\n\\nstruct MessageKey {\\n    uint8 keyType; // 0-127 are reserved for standardized KeyTypes, 128-255 are for custom use\\n    bytes encodedKey;\\n}\\n\\n\\ninterface IWormholeRelayerBase {\\n    event SendEvent(\\n        uint64 indexed sequence, LocalNative deliveryQuote, LocalNative paymentForExtraReceiverValue\\n    );\\n\\n    function getRegisteredWormholeRelayerContract(uint16 chainId) external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns true if a delivery has been attempted for the given deliveryHash\\n     * Note: invalid deliveries where the tx reverts are not considered attempted\\n     */\\n    function deliveryAttempted(bytes32 deliveryHash) external view returns (bool attempted);\\n\\n    /**\\n     * @notice block number at which a delivery was successfully executed\\n     */\\n    function deliverySuccessBlock(bytes32 deliveryHash) external view returns (uint256 blockNumber);\\n\\n    /**\\n     * @notice block number of the latest attempt to execute a delivery that failed\\n     */\\n    function deliveryFailureBlock(bytes32 deliveryHash) external view returns (uint256 blockNumber);\\n}\\n\\n/**\\n * @title IWormholeRelayerSend\\n * @notice The interface to request deliveries\\n */\\ninterface IWormholeRelayerSend is IWormholeRelayerBase {\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     * \\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     * \\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendPayloadToEvm` function \\n     * with `refundChain` and `refundAddress` as parameters\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver) \\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        Gas gasLimit\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver) \\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        Gas gasLimit,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     * \\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     * \\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendVaasToEvm` function \\n     * with `refundChain` and `refundAddress` as parameters\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver) \\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. \\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        Gas gasLimit,\\n        VaaKey[] memory vaaKeys\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver) \\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the \\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        Gas gasLimit,\\n        VaaKey[] memory vaaKeys,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress` \\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and `msg.value` equal to \\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to \\n     * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver) \\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue \\n     *        (in addition to the `receiverValue` specified)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the  \\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see \\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        LocalNative paymentForExtraReceiverValue,\\n        Gas gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress` \\n     * to relay a payload and external messages specified by `messageKeys` to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and `msg.value` equal to \\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to \\n     * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     *\\n     * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected \\n     * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver) \\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue \\n     *        (in addition to the `receiverValue` specified)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the  \\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see \\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        LocalNative paymentForExtraReceiverValue,\\n        Gas gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        MessageKey[] memory messageKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n    \\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress` \\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with `msg.value` equal to \\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to \\n     * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue  \\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue \\n     *        (in addition to the `receiverValue` specified)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see \\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function send(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        LocalNative paymentForExtraReceiverValue,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress` \\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with `msg.value` equal to \\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to \\n     * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue  \\n     *\\n     * Note: MessageKeys can specify wormhole messages (VaaKeys) or other types of messages (ex. USDC CCTP attestations). Ensure the selected \\n     * DeliveryProvider supports all the MessageKey.keyType values specified or it will not be delivered!\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue \\n     *        (in addition to the `receiverValue` specified)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param messageKeys Additional messagess to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see \\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function send(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        LocalNative paymentForExtraReceiverValue,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        MessageKey[] memory messageKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Requests a previously published delivery instruction to be redelivered \\n     * (e.g. with a different delivery provider)\\n     *\\n     * This function must be called with `msg.value` equal to \\n     * quoteEVMDeliveryPrice(targetChain, newReceiverValue, newGasLimit, newDeliveryProviderAddress)\\n     * \\n     *  @notice *** This will only be able to succeed if the following is true **\\n     *         - newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     * \\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the \\n     *        previously published delivery instructions\\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param newGasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the  \\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider, to the refund chain and address specified in the original request\\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return sequence sequence number of published VAA containing redelivery instructions\\n     *\\n     * @notice *** This will only be able to succeed if the following is true **\\n     *         - newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     */\\n    function resendToEvm(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        TargetNative newReceiverValue,\\n        Gas newGasLimit,\\n        address newDeliveryProviderAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Requests a previously published delivery instruction to be redelivered \\n     * \\n     *\\n     * This function must be called with `msg.value` equal to \\n     * quoteDeliveryPrice(targetChain, newReceiverValue, newEncodedExecutionParameters, newDeliveryProviderAddress)\\n     * \\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the \\n     *        previously published delivery instructions\\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param newEncodedExecutionParameters new encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return sequence sequence number of published VAA containing redelivery instructions\\n     * \\n     *  @notice *** This will only be able to succeed if the following is true **\\n     *         - (For EVM_V1) newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - (For EVM_V1) newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     */\\n    function resend(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        TargetNative newReceiverValue,\\n        bytes memory newEncodedExecutionParameters,\\n        address newDeliveryProviderAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using the default delivery provider\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. \\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused, \\n     *         if a refundAddress is specified. \\n     *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a \\n     *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain. \\n     *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain. \\n     */\\n    function quoteEVMDeliveryPrice(\\n        uint16 targetChain,\\n        TargetNative receiverValue,\\n        Gas gasLimit\\n    ) external view returns (LocalNative nativePriceQuote, GasPrice targetChainRefundPerGasUnused);\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. \\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused, \\n     *         if a refundAddress is specified\\n     *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here should be considered to be a \\n     *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the refundAddress at the target chain. \\n     *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on the target chain.\\n     */\\n    function quoteEVMDeliveryPrice(\\n        uint16 targetChain,\\n        TargetNative receiverValue,\\n        Gas gasLimit,\\n        address deliveryProviderAddress\\n    ) external view returns (LocalNative nativePriceQuote, GasPrice targetChainRefundPerGasUnused);\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return encodedExecutionInfo encoded information on how the delivery will be executed\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` and `targetChainRefundPerGasUnused`\\n     *             (which is the amount of target chain currency that will be refunded per unit of gas unused, \\n     *              if a refundAddress is specified)\\n     */\\n    function quoteDeliveryPrice(\\n        uint16 targetChain,\\n        TargetNative receiverValue,\\n        bytes memory encodedExecutionParameters,\\n        address deliveryProviderAddress\\n    ) external view returns (LocalNative nativePriceQuote, bytes memory encodedExecutionInfo);\\n\\n    /**\\n     * @notice Returns the (extra) amount of target chain currency that `targetAddress`\\n     * will be called with, if the `paymentForExtraReceiverValue` field is set to `currentChainAmount`\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param currentChainAmount The value that `paymentForExtraReceiverValue` will be set to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return targetChainAmount The amount such that if `targetAddress` will be called with `msg.value` equal to\\n     *         receiverValue + targetChainAmount\\n     */\\n    function quoteNativeForChain(\\n        uint16 targetChain,\\n        LocalNative currentChainAmount,\\n        address deliveryProviderAddress\\n    ) external view returns (TargetNative targetChainAmount);\\n\\n    /**\\n     * @notice Returns the address of the current default delivery provider\\n     * @return deliveryProvider The address of (the default delivery provider)'s contract on this source\\n     *   chain. This must be a contract that implements IDeliveryProvider.\\n     */\\n    function getDefaultDeliveryProvider() external view returns (address deliveryProvider);\\n}\\n\\n/**\\n * @title IWormholeRelayerDelivery\\n * @notice The interface to execute deliveries. Only relevant for Delivery Providers \\n */\\ninterface IWormholeRelayerDelivery is IWormholeRelayerBase {\\n    enum DeliveryStatus {\\n        SUCCESS,\\n        RECEIVER_FAILURE\\n    }\\n\\n    enum RefundStatus {\\n        REFUND_SENT,\\n        REFUND_FAIL,\\n        CROSS_CHAIN_REFUND_SENT,\\n        CROSS_CHAIN_REFUND_FAIL_PROVIDER_NOT_SUPPORTED,\\n        CROSS_CHAIN_REFUND_FAIL_NOT_ENOUGH,\\n        NO_REFUND_REQUESTED\\n    }\\n\\n    /**\\n     * @custom:member recipientContract - The target contract address\\n     * @custom:member sourceChain - The chain which this delivery was requested from (in wormhole\\n     *     ChainID format)\\n     * @custom:member sequence - The wormhole sequence number of the delivery VAA on the source chain\\n     *     corresponding to this delivery request\\n     * @custom:member deliveryVaaHash - The hash of the delivery VAA corresponding to this delivery\\n     *     request\\n     * @custom:member gasUsed - The amount of gas that was used to call your target contract \\n     * @custom:member status:\\n     *   - RECEIVER_FAILURE, if the target contract reverts\\n     *   - SUCCESS, if the target contract doesn't revert\\n     * @custom:member additionalStatusInfo:\\n     *   - If status is SUCCESS, then this is empty.\\n     *   - If status is RECEIVER_FAILURE, this is `RETURNDATA_TRUNCATION_THRESHOLD` bytes of the\\n     *       return data (i.e. potentially truncated revert reason information).\\n     * @custom:member refundStatus - Result of the refund. REFUND_SUCCESS or REFUND_FAIL are for\\n     *     refunds where targetChain=refundChain; the others are for targetChain!=refundChain,\\n     *     where a cross chain refund is necessary, or if the default code path is used where no refund is requested (NO_REFUND_REQUESTED)\\n     * @custom:member overridesInfo:\\n     *   - If not an override: empty bytes array\\n     *   - Otherwise: An encoded `DeliveryOverride`\\n     */\\n    event Delivery(\\n        address indexed recipientContract,\\n        uint16 indexed sourceChain,\\n        uint64 indexed sequence,\\n        bytes32 deliveryVaaHash,\\n        DeliveryStatus status,\\n        Gas gasUsed,\\n        RefundStatus refundStatus,\\n        bytes additionalStatusInfo,\\n        bytes overridesInfo\\n    );\\n\\n    /**\\n     * @notice The delivery provider calls `deliver` to relay messages as described by one delivery instruction\\n     * \\n     * The delivery provider must pass in the specified (by VaaKeys[]) signed wormhole messages (VAAs) from the source chain\\n     * as well as the signed wormhole message with the delivery instructions (the delivery VAA)\\n     *\\n     * The messages will be relayed to the target address (with the specified gas limit and receiver value) iff the following checks are met:\\n     * - the delivery VAA has a valid signature\\n     * - the delivery VAA's emitter is one of these WormholeRelayer contracts\\n     * - the delivery provider passed in at least enough of this chain's currency as msg.value (enough meaning the maximum possible refund)     \\n     * - the instruction's target chain is this chain\\n     * - the relayed signed VAAs match the descriptions in container.messages (the VAA hashes match, or the emitter address, sequence number pair matches, depending on the description given)\\n     *\\n     * @param encodedVMs - An array of signed wormhole messages (all from the same source chain\\n     *     transaction)\\n     * @param encodedDeliveryVAA - Signed wormhole message from the source chain's WormholeRelayer\\n     *     contract with payload being the encoded delivery instruction container\\n     * @param relayerRefundAddress - The address to which any refunds to the delivery provider\\n     *     should be sent\\n     * @param deliveryOverrides - Optional overrides field which must be either an empty bytes array or\\n     *     an encoded DeliveryOverride struct\\n     */\\n    function deliver(\\n        bytes[] memory encodedVMs,\\n        bytes memory encodedDeliveryVAA,\\n        address payable relayerRefundAddress,\\n        bytes memory deliveryOverrides\\n    ) external payable;\\n}\\n\\ninterface IWormholeRelayer is IWormholeRelayerDelivery, IWormholeRelayerSend {}\\n\\n/*\\n *  Errors thrown by IWormholeRelayer contract\\n */\\n\\n// Bound chosen by the following formula: `memoryWord * 4 + selectorSize`.\\n// This means that an error identifier plus four fixed size arguments should be available to developers.\\n// In the case of a `require` revert with error message, this should provide 2 memory word's worth of data.\\nuint256 constant RETURNDATA_TRUNCATION_THRESHOLD = 132;\\n\\n//When msg.value was not equal to `delivery provider's quoted delivery price` + `paymentForExtraReceiverValue`\\nerror InvalidMsgValue(LocalNative msgValue, LocalNative totalFee);\\n\\nerror RequestedGasLimitTooLow();\\n\\nerror DeliveryProviderDoesNotSupportTargetChain(address relayer, uint16 chainId);\\nerror DeliveryProviderCannotReceivePayment();\\nerror DeliveryProviderDoesNotSupportMessageKeyType(uint8 keyType);\\n\\n//When calling `delivery()` a second time even though a delivery is already in progress\\nerror ReentrantDelivery(address msgSender, address lockedBy);\\n\\nerror InvalidPayloadId(uint8 parsed, uint8 expected);\\nerror InvalidPayloadLength(uint256 received, uint256 expected);\\nerror InvalidVaaKeyType(uint8 parsed);\\nerror TooManyMessageKeys(uint256 numMessageKeys);\\n\\nerror InvalidDeliveryVaa(string reason);\\n//When the delivery VAA (signed wormhole message with delivery instructions) was not emitted by the\\n//  registered WormholeRelayer contract\\nerror InvalidEmitter(bytes32 emitter, bytes32 registered, uint16 chainId);\\nerror MessageKeysLengthDoesNotMatchMessagesLength(uint256 keys, uint256 vaas);\\nerror VaaKeysDoNotMatchVaas(uint8 index);\\n//When someone tries to call an external function of the WormholeRelayer that is only intended to be\\n//  called by the WormholeRelayer itself (to allow retroactive reverts for atomicity)\\nerror RequesterNotWormholeRelayer();\\n\\n//When trying to relay a `DeliveryInstruction` to any other chain but the one it was specified for\\nerror TargetChainIsNotThisChain(uint16 targetChain);\\n//When a `DeliveryOverride` contains a gas limit that's less than the original\\nerror InvalidOverrideGasLimit();\\n//When a `DeliveryOverride` contains a receiver value that's less than the original\\nerror InvalidOverrideReceiverValue();\\n//When a `DeliveryOverride` contains a 'refund per unit of gas unused' that's less than the original\\nerror InvalidOverrideRefundPerGasUnused();\\n\\n//When the delivery provider doesn't pass in sufficient funds (i.e. msg.value does not cover the\\n// maximum possible refund to the user)\\nerror InsufficientRelayerFunds(LocalNative msgValue, LocalNative minimum);\\n\\n//When a bytes32 field can't be converted into a 20 byte EVM address, because the 12 padding bytes\\n//  are non-zero (duplicated from Utils.sol)\\nerror NotAnEvmAddress(bytes32);\\n\"\r\n    },\r\n    \"contracts/relayer/wormholeRelayer/WormholeRelayerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../../interfaces/relayer/TypedUnits.sol\\\";\\n\\n// -------------------------------------- Persistent Storage ---------------------------------------\\n\\n//We have to hardcode the keccak256 values by hand rather than having them calculated because:\\n//  solc: TypeError: Only direct number constants and references to such constants are supported by\\n//          inline assembly.\\n//And presumably what they mean by \\\"direct number constants\\\" is number literals...\\n\\nstruct GovernanceState {\\n    // mapping of IWormhole.VM.hash of previously executed governance VMs\\n    mapping(bytes32 => bool) consumedGovernanceActions;\\n}\\n\\n//keccak256(\\\"GovernanceState\\\") - 1\\nbytes32 constant GOVERNANCE_STORAGE_SLOT =\\n    0x970ad24d4754c92e299cabb86552091f5df0a15abc0f1b71f37d3e30031585dc;\\n\\nfunction getGovernanceState() pure returns (GovernanceState storage state) {\\n    assembly (\\\"memory-safe\\\") {\\n        state.slot := GOVERNANCE_STORAGE_SLOT\\n    }\\n}\\n\\nstruct DefaultDeliveryProviderState {\\n    // address of the default relay provider on this chain\\n    address defaultDeliveryProvider;\\n}\\n\\n//keccak256(\\\"DefaultRelayProviderState\\\") - 1\\nbytes32 constant DEFAULT_RELAY_PROVIDER_STORAGE_SLOT =\\n    0xebc28a1927f62765bfb7ada566eeab2d31a98c65dbd1e8cad64acae2a3ae45d4;\\n\\nfunction getDefaultDeliveryProviderState()\\n    pure\\n    returns (DefaultDeliveryProviderState storage state)\\n{\\n    assembly (\\\"memory-safe\\\") {\\n        state.slot := DEFAULT_RELAY_PROVIDER_STORAGE_SLOT\\n    }\\n}\\n\\nstruct RegisteredWormholeRelayersState {\\n    // chainId => wormhole address mapping of relayer contracts on other chains\\n    mapping(uint16 => bytes32) registeredWormholeRelayers;\\n}\\n\\n//keccak256(\\\"RegisteredCoreRelayersState\\\") - 1\\nbytes32 constant REGISTERED_CORE_RELAYERS_STORAGE_SLOT =\\n    0x9e4e57806ba004485cfae8ca22fb13380f01c10b1b0ccf48c20464961643cf6d;\\n\\nfunction getRegisteredWormholeRelayersState()\\n    pure\\n    returns (RegisteredWormholeRelayersState storage state)\\n{\\n    assembly (\\\"memory-safe\\\") {\\n        state.slot := REGISTERED_CORE_RELAYERS_STORAGE_SLOT\\n    }\\n}\\n\\n// Replay Protection and Indexing\\n\\nstruct DeliverySuccessState {\\n    mapping(bytes32 => uint256) deliverySuccessBlock;\\n}\\n\\nstruct DeliveryFailureState {\\n    mapping(bytes32 => uint256) deliveryFailureBlock;\\n}\\n\\n//keccak256(\\\"DeliverySuccessState\\\") - 1\\nbytes32 constant DELIVERY_SUCCESS_STATE_STORAGE_SLOT =\\n    0x1b988580e74603c035f5a7f71f2ae4647578af97cd0657db620836b9955fd8f5;\\n\\n//keccak256(\\\"DeliveryFailureState\\\") - 1\\nbytes32 constant DELIVERY_FAILURE_STATE_STORAGE_SLOT =\\n    0x6c615753402911c4de18a758def0565f37c41834d6eff72b16cb37cfb697f2a5;\\n\\nfunction getDeliverySuccessState() pure returns (DeliverySuccessState storage state) {\\n    assembly (\\\"memory-safe\\\") {\\n        state.slot := DELIVERY_SUCCESS_STATE_STORAGE_SLOT\\n    }\\n}\\n\\nfunction getDeliveryFailureState() pure returns (DeliveryFailureState storage state) {\\n    assembly (\\\"memory-safe\\\") {\\n        state.slot := DELIVERY_FAILURE_STATE_STORAGE_SLOT\\n    }\\n}\\n\\nstruct ReentrancyGuardState {\\n    // if 0 address, no reentrancy guard is active\\n    // otherwise, the address of the contract that has locked the reentrancy guard (msg.sender)\\n    address lockedBy;\\n}\\n\\n//keccak256(\\\"ReentrancyGuardState\\\") - 1\\nbytes32 constant REENTRANCY_GUARD_STORAGE_SLOT =\\n    0x44dc27ebd67a87ad2af1d98fc4a5f971d9492fe12498e4c413ab5a05b7807a67;\\n\\nfunction getReentrancyGuardState() pure returns (ReentrancyGuardState storage state) {\\n    assembly (\\\"memory-safe\\\") {\\n        state.slot := REENTRANCY_GUARD_STORAGE_SLOT\\n    }\\n}\\n\\nstruct DeliveryTmpState {\\n    // the refund chain for the in-progress delivery\\n    uint16 refundChain;\\n    // the refund address for the in-progress delivery\\n    bytes32 refundAddress;\\n}\\n\\n//keccak256(\\\"DeliveryTmpState\\\") - 1\\nbytes32 constant DELIVERY_TMP_STORAGE_SLOT =\\n    0x1a2a8eb52f1d00a1242a3f8cc031e30a32870ff64f69009c4e06f75bd842fd22;\\n\\nfunction getDeliveryTmpState() pure returns (DeliveryTmpState storage state) {\\n    assembly (\\\"memory-safe\\\") {\\n        state.slot := DELIVERY_TMP_STORAGE_SLOT\\n    }\\n}\"\r\n    },\r\n    \"contracts/relayer/wormholeRelayer/WormholeRelayerGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\\\";\\n\\nimport {IWormhole} from \\\"../../interfaces/IWormhole.sol\\\";\\nimport {InvalidPayloadLength} from \\\"../../interfaces/relayer/IWormholeRelayerTyped.sol\\\";\\nimport {fromWormholeFormat} from \\\"../../relayer/libraries/Utils.sol\\\";\\nimport {BytesParsing} from \\\"../../relayer/libraries/BytesParsing.sol\\\";\\nimport {\\n    getGovernanceState,\\n    getRegisteredWormholeRelayersState,\\n    getDefaultDeliveryProviderState\\n} from \\\"./WormholeRelayerStorage.sol\\\";\\nimport {WormholeRelayerBase} from \\\"./WormholeRelayerBase.sol\\\";\\n\\nerror GovernanceActionAlreadyConsumed(bytes32 hash);\\nerror InvalidGovernanceVM(string reason);\\nerror InvalidGovernanceChainId(uint16 parsed, uint16 expected);\\nerror InvalidGovernanceContract(bytes32 parsed, bytes32 expected);\\n\\nerror InvalidPayloadChainId(uint16 parsed, uint16 expected);\\nerror InvalidPayloadAction(uint8 parsed, uint8 expected);\\nerror InvalidPayloadModule(bytes32 parsed, bytes32 expected);\\nerror InvalidFork();\\nerror ContractUpgradeFailed(bytes failure);\\nerror ChainAlreadyRegistered(uint16 chainId, bytes32 registeredWormholeRelayerContract);\\nerror InvalidDefaultDeliveryProvider(bytes32 defaultDeliveryProvider);\\n\\nabstract contract WormholeRelayerGovernance is WormholeRelayerBase, ERC1967Upgrade {\\n    //This constant should actually be defined in IWormhole. Alas, it isn't.\\n    uint16 private constant WORMHOLE_CHAINID_UNSET = 0;\\n\\n    /**\\n     * Governance VMs are encoded in a packed fashion using the general wormhole scheme:\\n     *   GovernancePacket = <Common Header|Action Parameters>\\n     *\\n     * For a more detailed explanation see here:\\n     *   - https://docs.wormhole.com/wormhole/governance\\n     *   - https://github.com/wormhole-foundation/wormhole/blob/main/whitepapers/0002_governance_messaging.md\\n     */\\n\\n    //Right shifted ascii encoding of \\\"WormholeRelayer\\\"\\n    bytes32 private constant module =\\n        0x0000000000000000000000000000000000576f726d686f6c6552656c61796572;\\n\\n    /**\\n     * The choice of action enumeration and parameters follows the scheme of the core bridge:\\n     *   - https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/bridge/BridgeGovernance.sol#L115\\n     */\\n\\n    /**\\n     * Registers a wormhole relayer contract that was deployed on another chain with the WormholeRelayer on\\n     *   this chain. The equivalent to the core bridge's registerChain action.\\n     *\\n     * Action Parameters:\\n     *   - uint16 foreignChainId\\n     *   - bytes32 foreignContractAddress\\n     */\\n    uint8 private constant GOVERNANCE_ACTION_REGISTER_WORMHOLE_RELAYER_CONTRACT = 1;\\n\\n    /**\\n     * Upgrades the WormholeRelayer contract to a new implementation. The equivalent to the core bridge's\\n     *   upgrade action.\\n     *\\n     * Action Parameters:\\n     *   - bytes32 newImplementation\\n     */\\n    uint8 private constant GOVERNANCE_ACTION_CONTRACT_UPGRADE = 2;\\n\\n    /**\\n     * Sets the default relay provider for the WormholeRelayer. Has no equivalent in the core bridge.\\n     *\\n     * Action Parameters:\\n     *   - bytes32 newProvider\\n     */\\n    uint8 private constant GOVERNANCE_ACTION_UPDATE_DEFAULT_PROVIDER = 3;\\n\\n    //By checking that only the contract can call itself, we can enforce that the migration code is\\n    //  executed upon program upgrade and that it can't be called externally by anyone else.\\n    function checkAndExecuteUpgradeMigration() external {\\n        assert(msg.sender == address(this));\\n        executeUpgradeMigration();\\n    }\\n\\n    function executeUpgradeMigration() internal virtual {\\n        //override and implement in WormholeRelayer upon contract upgrade (if required)\\n    }\\n\\n    function registerWormholeRelayerContract(bytes memory encodedVm) external {\\n        (uint16 foreignChainId, bytes32 foreignAddress) =\\n            parseAndCheckRegisterWormholeRelayerContractVm(encodedVm);\\n\\n        getRegisteredWormholeRelayersState().registeredWormholeRelayers[foreignChainId] =\\n            foreignAddress;\\n    }\\n\\n    event ContractUpgraded(address indexed oldContract, address indexed newContract);\\n\\n    function submitContractUpgrade(bytes memory encodedVm) external {\\n        address currentImplementation = _getImplementation();\\n        address newImplementation = parseAndCheckContractUpgradeVm(encodedVm);\\n\\n        _upgradeTo(newImplementation);\\n\\n        (bool success, bytes memory revertData) =\\n            address(this).call(abi.encodeCall(this.checkAndExecuteUpgradeMigration, ()));\\n\\n        if (!success) {\\n            revert ContractUpgradeFailed(revertData);\\n        }\\n\\n        emit ContractUpgraded(currentImplementation, newImplementation);\\n    }\\n\\n    function setDefaultDeliveryProvider(bytes memory encodedVm) external {\\n        address newProvider = parseAndCheckRegisterDefaultDeliveryProviderVm(encodedVm);\\n\\n        getDefaultDeliveryProviderState().defaultDeliveryProvider = newProvider;\\n    }\\n\\n    // ------------------------------------------- PRIVATE -------------------------------------------\\n    using BytesParsing for bytes;\\n\\n    function parseAndCheckRegisterWormholeRelayerContractVm(bytes memory encodedVm)\\n        private\\n        returns (uint16 foreignChainId, bytes32 foreignAddress)\\n    {\\n        bytes memory payload = verifyAndConsumeGovernanceVM(encodedVm);\\n        uint256 offset = parseAndCheckPayloadHeader(\\n            payload, GOVERNANCE_ACTION_REGISTER_WORMHOLE_RELAYER_CONTRACT, true\\n        );\\n\\n        (foreignChainId, offset) = payload.asUint16Unchecked(offset);\\n        (foreignAddress, offset) = payload.asBytes32Unchecked(offset);\\n\\n        checkLength(payload, offset);\\n\\n        if (getRegisteredWormholeRelayerContract(foreignChainId) != bytes32(0)) {\\n            revert ChainAlreadyRegistered(\\n                foreignChainId, getRegisteredWormholeRelayerContract(foreignChainId)\\n            );\\n        }\\n    }\\n\\n    function parseAndCheckContractUpgradeVm(bytes memory encodedVm)\\n        private\\n        returns (address newImplementation)\\n    {\\n        bytes memory payload = verifyAndConsumeGovernanceVM(encodedVm);\\n        uint256 offset =\\n            parseAndCheckPayloadHeader(payload, GOVERNANCE_ACTION_CONTRACT_UPGRADE, false);\\n\\n        bytes32 newImplementationWhFmt;\\n        (newImplementationWhFmt, offset) = payload.asBytes32Unchecked(offset);\\n        //fromWormholeFormat reverts if first 12 bytes aren't zero (i.e. if it's not an EVM address)\\n        newImplementation = fromWormholeFormat(newImplementationWhFmt);\\n\\n        checkLength(payload, offset);\\n    }\\n\\n    function parseAndCheckRegisterDefaultDeliveryProviderVm(bytes memory encodedVm)\\n        private\\n        returns (address newProvider)\\n    {\\n        bytes memory payload = verifyAndConsumeGovernanceVM(encodedVm);\\n        uint256 offset =\\n            parseAndCheckPayloadHeader(payload, GOVERNANCE_ACTION_UPDATE_DEFAULT_PROVIDER, false);\\n\\n        bytes32 newProviderWhFmt;\\n        (newProviderWhFmt, offset) = payload.asBytes32Unchecked(offset);\\n        //fromWormholeFormat reverts if first 12 bytes aren't zero (i.e. if it's not an EVM address)\\n        newProvider = fromWormholeFormat(newProviderWhFmt);\\n\\n        checkLength(payload, offset);\\n\\n        if (newProvider == address(0)) {\\n            revert InvalidDefaultDeliveryProvider(newProviderWhFmt);\\n        }\\n    }\\n\\n    function verifyAndConsumeGovernanceVM(bytes memory encodedVm)\\n        private\\n        returns (bytes memory payload)\\n    {\\n        (IWormhole.VM memory vm, bool valid, string memory reason) =\\n            getWormhole().parseAndVerifyVM(encodedVm);\\n\\n        if (!valid) {\\n            revert InvalidGovernanceVM(reason);\\n        }\\n\\n        uint16 governanceChainId = getWormhole().governanceChainId();\\n        if (vm.emitterChainId != governanceChainId) {\\n            revert InvalidGovernanceChainId(vm.emitterChainId, governanceChainId);\\n        }\\n\\n        bytes32 governanceContract = getWormhole().governanceContract();\\n        if (vm.emitterAddress != governanceContract) {\\n            revert InvalidGovernanceContract(vm.emitterAddress, governanceContract);\\n        }\\n\\n        bool consumed = getGovernanceState().consumedGovernanceActions[vm.hash];\\n        if (consumed) {\\n            revert GovernanceActionAlreadyConsumed(vm.hash);\\n        }\\n\\n        getGovernanceState().consumedGovernanceActions[vm.hash] = true;\\n\\n        return vm.payload;\\n    }\\n\\n    function parseAndCheckPayloadHeader(\\n        bytes memory encodedPayload,\\n        uint8 expectedAction,\\n        bool allowUnset\\n    ) private view returns (uint256 offset) {\\n        bytes32 parsedModule;\\n        (parsedModule, offset) = encodedPayload.asBytes32Unchecked(offset);\\n        if (parsedModule != module) {\\n            revert InvalidPayloadModule(parsedModule, module);\\n        }\\n\\n        uint8 parsedAction;\\n        (parsedAction, offset) = encodedPayload.asUint8Unchecked(offset);\\n        if (parsedAction != expectedAction) {\\n            revert InvalidPayloadAction(parsedAction, expectedAction);\\n        }\\n\\n        uint16 parsedChainId;\\n        (parsedChainId, offset) = encodedPayload.asUint16Unchecked(offset);\\n        if (!(parsedChainId == WORMHOLE_CHAINID_UNSET && allowUnset)) {\\n            if (getWormhole().isFork()) {\\n                revert InvalidFork();\\n            }\\n\\n            if (parsedChainId != getChainId()) {\\n                revert InvalidPayloadChainId(parsedChainId, getChainId());\\n            }\\n        }\\n    }\\n\\n    function checkLength(bytes memory payload, uint256 expected) private pure {\\n        if (payload.length != expected) {\\n            revert InvalidPayloadLength(payload.length, expected);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/relayer/wormholeRelayer/WormholeRelayerSend.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.19;\\n\\nimport {\\n    DeliveryProviderDoesNotSupportTargetChain,\\n    DeliveryProviderDoesNotSupportMessageKeyType,\\n    InvalidMsgValue,\\n    DeliveryProviderCannotReceivePayment,\\n    MessageKey,\\n    VaaKey,\\n    IWormholeRelayerSend\\n} from \\\"../../interfaces/relayer/IWormholeRelayerTyped.sol\\\";\\nimport {IDeliveryProvider} from \\\"../../interfaces/relayer/IDeliveryProviderTyped.sol\\\";\\n\\nimport {toWormholeFormat, fromWormholeFormat} from \\\"../../relayer/libraries/Utils.sol\\\";\\nimport {\\n    DeliveryInstruction,\\n    RedeliveryInstruction\\n} from \\\"../../relayer/libraries/RelayerInternalStructs.sol\\\";\\nimport {WormholeRelayerSerde} from \\\"./WormholeRelayerSerde.sol\\\";\\nimport {getDefaultDeliveryProviderState} from \\\"./WormholeRelayerStorage.sol\\\";\\nimport {WormholeRelayerBase} from \\\"./WormholeRelayerBase.sol\\\";\\nimport \\\"../../interfaces/relayer/TypedUnits.sol\\\";\\nimport \\\"../../relayer/libraries/ExecutionParameters.sol\\\";\\n\\nabstract contract WormholeRelayerSend is WormholeRelayerBase, IWormholeRelayerSend {\\n    using WormholeRelayerSerde for *;\\n    using WeiLib for Wei;\\n    using GasLib for Gas;\\n    using TargetNativeLib for TargetNative;\\n    using LocalNativeLib for LocalNative;\\n\\n    /*\\n    * Public convenience overloads\\n    */\\n\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        Gas gasLimit\\n    ) external payable returns (uint64 sequence) {\\n        return sendToEvm(\\n            targetChain,\\n            targetAddress,\\n            payload,\\n            receiverValue,\\n            LocalNative.wrap(0),\\n            gasLimit,\\n            targetChain,\\n            address(0x0),\\n            getDefaultDeliveryProvider(),\\n            new VaaKey[](0),\\n            CONSISTENCY_LEVEL_FINALIZED\\n        );\\n    }\\n\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        Gas gasLimit,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence) {\\n        return sendToEvm(\\n            targetChain,\\n            targetAddress,\\n            payload,\\n            receiverValue,\\n            LocalNative.wrap(0),\\n            gasLimit,\\n            refundChain,\\n            refundAddress,\\n            getDefaultDeliveryProvider(),\\n            new VaaKey[](0),\\n            CONSISTENCY_LEVEL_FINALIZED\\n        );\\n    }\\n\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        Gas gasLimit,\\n        VaaKey[] memory vaaKeys\\n    ) external payable returns (uint64 sequence) {\\n        return sendToEvm(\\n            targetChain,\\n            targetAddress,\\n            payload,\\n            receiverValue,\\n            LocalNative.wrap(0),\\n            gasLimit,\\n            targetChain,\\n            address(0x0),\\n            getDefaultDeliveryProvider(),\\n            vaaKeys,\\n            CONSISTENCY_LEVEL_FINALIZED\\n        );\\n    }\\n\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        Gas gasLimit,\\n        VaaKey[] memory vaaKeys,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence) {\\n        return sendToEvm(\\n            targetChain,\\n            targetAddress,\\n            payload,\\n            receiverValue,\\n            LocalNative.wrap(0),\\n            gasLimit,\\n            refundChain,\\n            refundAddress,\\n            getDefaultDeliveryProvider(),\\n            vaaKeys,\\n            CONSISTENCY_LEVEL_FINALIZED\\n        );\\n    }\\n\\n    function sendToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        LocalNative paymentForExtraReceiverValue,\\n        Gas gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) public payable returns (uint64 sequence) {\\n        sequence = send(\\n            targetChain,\\n            toWormholeFormat(targetAddress),\\n            payload,\\n            receiverValue,\\n            paymentForExtraReceiverValue,\\n            encodeEvmExecutionParamsV1(EvmExecutionParamsV1(gasLimit)),\\n            refundChain,\\n            toWormholeFormat(refundAddress),\\n            deliveryProviderAddress,\\n            vaaKeys,\\n            consistencyLevel\\n        );\\n    }\\n\\n    function sendToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        LocalNative paymentForExtraReceiverValue,\\n        Gas gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        MessageKey[] memory messageKeys,\\n        uint8 consistencyLevel\\n    ) public payable returns (uint64 sequence) {\\n        sequence = send(\\n            targetChain,\\n            toWormholeFormat(targetAddress),\\n            payload,\\n            receiverValue,\\n            paymentForExtraReceiverValue,\\n            encodeEvmExecutionParamsV1(EvmExecutionParamsV1(gasLimit)),\\n            refundChain,\\n            toWormholeFormat(refundAddress),\\n            deliveryProviderAddress,\\n            messageKeys,\\n            consistencyLevel\\n        );\\n    }\\n\\n    function resendToEvm(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        TargetNative newReceiverValue,\\n        Gas newGasLimit,\\n        address newDeliveryProviderAddress\\n    ) public payable returns (uint64 sequence) {\\n        sequence = resend(\\n            deliveryVaaKey,\\n            targetChain,\\n            newReceiverValue,\\n            encodeEvmExecutionParamsV1(EvmExecutionParamsV1(newGasLimit)),\\n            newDeliveryProviderAddress\\n        );\\n    }\\n\\n    function send(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        LocalNative paymentForExtraReceiverValue,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) public payable returns (uint64 sequence) {\\n        sequence = send(\\n            Send(\\n                targetChain,\\n                targetAddress,\\n                payload,\\n                receiverValue,\\n                paymentForExtraReceiverValue,\\n                encodedExecutionParameters,\\n                refundChain,\\n                refundAddress,\\n                deliveryProviderAddress,\\n                WormholeRelayerSerde.vaaKeyArrayToMessageKeyArray(vaaKeys),\\n                consistencyLevel\\n            )\\n        );\\n    }\\n\\n    function send(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        LocalNative paymentForExtraReceiverValue,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        MessageKey[] memory messageKeys,\\n        uint8 consistencyLevel\\n    ) public payable returns (uint64 sequence) {\\n        sequence = send(\\n            Send(\\n                targetChain,\\n                targetAddress,\\n                payload,\\n                receiverValue,\\n                paymentForExtraReceiverValue,\\n                encodedExecutionParameters,\\n                refundChain,\\n                refundAddress,\\n                deliveryProviderAddress,\\n                messageKeys,\\n                consistencyLevel\\n            )\\n        );\\n    }\\n\\n    /* \\n    * Non overload logic \\n    */\\n\\n    struct Send {\\n        uint16 targetChain;\\n        bytes32 targetAddress;\\n        bytes payload;\\n        TargetNative receiverValue;\\n        LocalNative paymentForExtraReceiverValue;\\n        bytes encodedExecutionParameters;\\n        uint16 refundChain;\\n        bytes32 refundAddress;\\n        address deliveryProviderAddress;\\n        MessageKey[] messageKeys;\\n        uint8 consistencyLevel;\\n    }\\n\\n    function send(Send memory sendParams) internal returns (uint64 sequence) {\\n        IDeliveryProvider provider = IDeliveryProvider(sendParams.deliveryProviderAddress);\\n\\n        // Revert if delivery provider does not support the target chain\\n        if (!provider.isChainSupported(sendParams.targetChain)) {\\n            revert DeliveryProviderDoesNotSupportTargetChain(\\n                sendParams.deliveryProviderAddress, sendParams.targetChain\\n            );\\n        }\\n\\n        // Obtain the delivery provider's fee for this delivery, as well as some encoded info (e.g. refund per unit of gas unused)\\n        (LocalNative deliveryPrice, bytes memory encodedExecutionInfo) = provider.quoteDeliveryPrice(\\n            sendParams.targetChain, sendParams.receiverValue, sendParams.encodedExecutionParameters\\n        );\\n\\n        // Check if user passed in 'one wormhole message fee' + 'delivery provider's fee'\\n        LocalNative wormholeMessageFee = getWormholeMessageFee();\\n        checkMsgValue(wormholeMessageFee, deliveryPrice, sendParams.paymentForExtraReceiverValue);\\n\\n        checkKeyTypesSupported(provider, sendParams.messageKeys);\\n\\n        // Encode all relevant info the delivery provider needs to perform the delivery as requested\\n        bytes memory encodedInstruction = DeliveryInstruction({\\n            targetChain: sendParams.targetChain,\\n            targetAddress: sendParams.targetAddress,\\n            payload: sendParams.payload,\\n            requestedReceiverValue: sendParams.receiverValue,\\n            extraReceiverValue: provider.quoteAssetConversion(\\n                sendParams.targetChain, sendParams.paymentForExtraReceiverValue\\n                ),\\n            encodedExecutionInfo: encodedExecutionInfo,\\n            refundChain: sendParams.refundChain,\\n            refundAddress: sendParams.refundAddress,\\n            refundDeliveryProvider: provider.getTargetChainAddress(sendParams.targetChain),\\n            sourceDeliveryProvider: toWormholeFormat(sendParams.deliveryProviderAddress),\\n            senderAddress: toWormholeFormat(msg.sender),\\n            messageKeys: sendParams.messageKeys\\n        }).encode();\\n\\n        // Publish the encoded delivery instruction as a wormhole message\\n        // and pay the delivery provider their fee\\n        bool paymentSucceeded;\\n        (sequence, paymentSucceeded) = publishAndPay(\\n            wormholeMessageFee,\\n            deliveryPrice,\\n            sendParams.paymentForExtraReceiverValue,\\n            encodedInstruction,\\n            sendParams.consistencyLevel,\\n            provider.getRewardAddress()\\n        );\\n\\n        if (!paymentSucceeded) {\\n            revert DeliveryProviderCannotReceivePayment();\\n        }\\n    }\\n\\n    function checkKeyTypesSupported(\\n        IDeliveryProvider provider,\\n        MessageKey[] memory messageKeys\\n    ) internal view {\\n        uint256 len = messageKeys.length;\\n        if (len == 0) {\\n            return;\\n        }\\n\\n        uint256 supportedKeyTypes = provider.getSupportedKeys();\\n        for (uint256 i = 0; i < len;) {\\n            uint8 keyType = messageKeys[i].keyType;\\n            if ((supportedKeyTypes & (1 << keyType)) == 0) {\\n                revert DeliveryProviderDoesNotSupportMessageKeyType(keyType);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function resend(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        TargetNative newReceiverValue,\\n        bytes memory newEncodedExecutionParameters,\\n        address newDeliveryProviderAddress\\n    ) public payable returns (uint64 sequence) {\\n        IDeliveryProvider provider = IDeliveryProvider(newDeliveryProviderAddress);\\n\\n        // Revert if delivery provider does not support the target chain\\n        if (!provider.isChainSupported(targetChain)) {\\n            revert DeliveryProviderDoesNotSupportTargetChain(\\n                newDeliveryProviderAddress, targetChain\\n            );\\n        }\\n\\n        // Obtain the delivery provider's fee for this delivery, as well as some encoded info (e.g. refund per unit of gas unused)\\n        (LocalNative deliveryPrice, bytes memory encodedExecutionInfo) = provider.quoteDeliveryPrice(\\n            targetChain, newReceiverValue, newEncodedExecutionParameters\\n        );\\n\\n        // Check if user passed in 'one wormhole message fee' + 'delivery provider's fee'\\n        LocalNative wormholeMessageFee = getWormholeMessageFee();\\n        checkMsgValue(wormholeMessageFee, deliveryPrice, LocalNative.wrap(0));\\n\\n        // Encode all relevant info the delivery provider needs to perform this redelivery as requested\\n        bytes memory encodedInstruction = RedeliveryInstruction({\\n            deliveryVaaKey: deliveryVaaKey,\\n            targetChain: targetChain,\\n            newRequestedReceiverValue: newReceiverValue,\\n            newEncodedExecutionInfo: encodedExecutionInfo,\\n            newSourceDeliveryProvider: toWormholeFormat(newDeliveryProviderAddress),\\n            newSenderAddress: toWormholeFormat(msg.sender)\\n        }).encode();\\n\\n        // Publish the encoded redelivery instruction as a wormhole message\\n        // and pay the delivery provider their fee\\n        bool paymentSucceeded;\\n        (sequence, paymentSucceeded) = publishAndPay(\\n            wormholeMessageFee,\\n            deliveryPrice,\\n            LocalNative.wrap(0),\\n            encodedInstruction,\\n            CONSISTENCY_LEVEL_INSTANT,\\n            provider.getRewardAddress()\\n        );\\n        if (!paymentSucceeded) {\\n            revert DeliveryProviderCannotReceivePayment();\\n        }\\n    }\\n\\n    function getDefaultDeliveryProvider() public view returns (address deliveryProvider) {\\n        deliveryProvider = getDefaultDeliveryProviderState().defaultDeliveryProvider;\\n    }\\n\\n    function quoteEVMDeliveryPrice(\\n        uint16 targetChain,\\n        TargetNative receiverValue,\\n        Gas gasLimit,\\n        address deliveryProviderAddress\\n    ) public view returns (LocalNative nativePriceQuote, GasPrice targetChainRefundPerGasUnused) {\\n        (LocalNative quote, bytes memory encodedExecutionInfo) = quoteDeliveryPrice(\\n            targetChain,\\n            receiverValue,\\n            encodeEvmExecutionParamsV1(EvmExecutionParamsV1(gasLimit)),\\n            deliveryProviderAddress\\n        );\\n        nativePriceQuote = quote;\\n        targetChainRefundPerGasUnused =\\n            decodeEvmExecutionInfoV1(encodedExecutionInfo).targetChainRefundPerGasUnused;\\n    }\\n\\n    function quoteEVMDeliveryPrice(\\n        uint16 targetChain,\\n        TargetNative receiverValue,\\n        Gas gasLimit\\n    ) public view returns (LocalNative nativePriceQuote, GasPrice targetChainRefundPerGasUnused) {\\n        return quoteEVMDeliveryPrice(\\n            targetChain, receiverValue, gasLimit, getDefaultDeliveryProvider()\\n        );\\n    }\\n\\n    function quoteDeliveryPrice(\\n        uint16 targetChain,\\n        TargetNative receiverValue,\\n        bytes memory encodedExecutionParameters,\\n        address deliveryProviderAddress\\n    ) public view returns (LocalNative nativePriceQuote, bytes memory encodedExecutionInfo) {\\n        IDeliveryProvider provider = IDeliveryProvider(deliveryProviderAddress);\\n        (LocalNative deliveryPrice, bytes memory _encodedExecutionInfo) =\\n            provider.quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters);\\n        encodedExecutionInfo = _encodedExecutionInfo;\\n        nativePriceQuote = deliveryPrice + getWormholeMessageFee();\\n    }\\n\\n    function quoteNativeForChain(\\n        uint16 targetChain,\\n        LocalNative currentChainAmount,\\n        address deliveryProviderAddress\\n    ) public view returns (TargetNative targetChainAmount) {\\n        return IDeliveryProvider(deliveryProviderAddress).quoteAssetConversion(\\n            targetChain, currentChainAmount\\n        );\\n    }\\n\\n    // Forwards\\n\\n    function forwardPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        Gas gasLimit\\n    ) external payable {\\n        forward(\\n            targetChain,\\n            toWormholeFormat(targetAddress),\\n            payload,\\n            receiverValue,\\n            LocalNative.wrap(0),\\n            encodeEvmExecutionParamsV1(EvmExecutionParamsV1(gasLimit)),\\n            getCurrentRefundChain(),\\n            getCurrentRefundAddress(),\\n            getDefaultDeliveryProvider(),\\n            new VaaKey[](0),\\n            CONSISTENCY_LEVEL_FINALIZED\\n        );\\n    }\\n\\n    function forwardVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        Gas gasLimit,\\n        VaaKey[] memory vaaKeys\\n    ) external payable {\\n        forward(\\n            targetChain,\\n            toWormholeFormat(targetAddress),\\n            payload,\\n            receiverValue,\\n            LocalNative.wrap(0),\\n            encodeEvmExecutionParamsV1(EvmExecutionParamsV1(gasLimit)),\\n            getCurrentRefundChain(),\\n            getCurrentRefundAddress(),\\n            getDefaultDeliveryProvider(),\\n            vaaKeys,\\n            CONSISTENCY_LEVEL_FINALIZED\\n        );\\n    }\\n\\n    function forwardToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        LocalNative paymentForExtraReceiverValue,\\n        Gas gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) public payable {\\n        forward(\\n            targetChain,\\n            toWormholeFormat(targetAddress),\\n            payload,\\n            receiverValue,\\n            paymentForExtraReceiverValue,\\n            encodeEvmExecutionParamsV1(EvmExecutionParamsV1(gasLimit)),\\n            refundChain,\\n            toWormholeFormat(refundAddress),\\n            deliveryProviderAddress,\\n            vaaKeys,\\n            consistencyLevel\\n        );\\n    }\\n\\n    function forward(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        TargetNative receiverValue,\\n        LocalNative,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) public payable {\\n        (LocalNative cost,) = quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress);\\n        send(\\n            targetChain,\\n            targetAddress,\\n            payload,\\n            receiverValue,\\n            LocalNative.wrap(msg.value) - cost, // include the extra value that is passed in\\n            encodedExecutionParameters,\\n            refundChain,\\n            refundAddress,\\n            deliveryProviderAddress,\\n            vaaKeys,\\n            consistencyLevel\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/relayer/wormholeRelayer/WormholeRelayerDelivery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.19;\\n\\nimport {IWormhole} from \\\"../../interfaces/IWormhole.sol\\\";\\nimport {\\n    InvalidDeliveryVaa,\\n    InvalidEmitter,\\n    InsufficientRelayerFunds,\\n    TargetChainIsNotThisChain,\\n    MessageKeysLengthDoesNotMatchMessagesLength,\\n    VaaKeysDoNotMatchVaas,\\n    InvalidOverrideGasLimit,\\n    InvalidOverrideReceiverValue,\\n    RequesterNotWormholeRelayer,\\n    DeliveryProviderCannotReceivePayment,\\n    MessageKey,\\n    VAA_KEY_TYPE,\\n    VaaKey,\\n    IWormholeRelayerDelivery,\\n    IWormholeRelayerSend,\\n    RETURNDATA_TRUNCATION_THRESHOLD\\n} from \\\"../../interfaces/relayer/IWormholeRelayerTyped.sol\\\";\\nimport {IWormholeReceiver} from \\\"../../interfaces/relayer/IWormholeReceiver.sol\\\";\\nimport {IDeliveryProvider} from \\\"../../interfaces/relayer/IDeliveryProviderTyped.sol\\\";\\n\\nimport {pay, pay, min, toWormholeFormat, fromWormholeFormat, returnLengthBoundedCall, returnLengthBoundedCall} from \\\"../../relayer/libraries/Utils.sol\\\";\\nimport {\\n    DeliveryInstruction,\\n    DeliveryOverride,\\n    EvmDeliveryInstruction\\n} from \\\"../../relayer/libraries/RelayerInternalStructs.sol\\\";\\nimport {BytesParsing} from \\\"../../relayer/libraries/BytesParsing.sol\\\";\\nimport {WormholeRelayerSerde} from \\\"./WormholeRelayerSerde.sol\\\";\\nimport {\\n    DeliverySuccessState,\\n    DeliveryFailureState,\\n    getDeliverySuccessState,\\n    getDeliveryFailureState\\n} from \\\"./WormholeRelayerStorage.sol\\\";\\nimport {WormholeRelayerBase} from \\\"./WormholeRelayerBase.sol\\\";\\nimport \\\"../../interfaces/relayer/TypedUnits.sol\\\";\\nimport \\\"../../relayer/libraries/ExecutionParameters.sol\\\";\\n\\nuint256 constant QUOTE_LENGTH_BYTES = 32;\\n\\nuint256 constant GAS_LIMIT_EXTERNAL_CALL = 100_000;\\n\\nabstract contract WormholeRelayerDelivery is WormholeRelayerBase, IWormholeRelayerDelivery {\\n    using WormholeRelayerSerde for *; \\n    using BytesParsing for bytes;\\n    using WeiLib for Wei;\\n    using GasLib for Gas;\\n    using GasPriceLib for GasPrice;\\n    using TargetNativeLib for TargetNative;\\n    using LocalNativeLib for LocalNative;\\n\\n    function deliver(\\n        bytes[] memory encodedVMs,\\n        bytes memory encodedDeliveryVAA,\\n        address payable relayerRefundAddress,\\n        bytes memory deliveryOverrides\\n    ) public payable nonReentrant {\\n\\n        // Parse and verify VAA containing delivery instructions, revert if invalid\\n        (IWormhole.VM memory vm, bool valid, string memory reason) =\\n            getWormhole().parseAndVerifyVM(encodedDeliveryVAA);\\n        if (!valid) {\\n            revert InvalidDeliveryVaa(reason);\\n        }\\n\\n        // Revert if the emitter of the VAA is not a Wormhole Relayer contract \\n        bytes32 registeredWormholeRelayer = getRegisteredWormholeRelayerContract(vm.emitterChainId);\\n        if (vm.emitterAddress != registeredWormholeRelayer) {\\n            revert InvalidEmitter(vm.emitterAddress, registeredWormholeRelayer, vm.emitterChainId);\\n        }\\n    \\n        DeliveryInstruction memory instruction = vm.payload.decodeDeliveryInstruction();\\n\\n        // Record information about the delivery's refund in temporary storage\\n        recordRefundInformation(\\n            instruction.refundChain,\\n            instruction.refundAddress\\n        );\\n\\n        DeliveryVAAInfo memory deliveryVaaInfo = DeliveryVAAInfo({\\n            sourceChain: vm.emitterChainId,\\n            sourceSequence: vm.sequence,\\n            deliveryVaaHash: vm.hash,\\n            relayerRefundAddress: relayerRefundAddress,\\n            encodedVMs: encodedVMs,\\n            deliveryInstruction: instruction,\\n            gasLimit: Gas.wrap(0),\\n            targetChainRefundPerGasUnused: GasPrice.wrap(0),\\n            totalReceiverValue: TargetNative.wrap(0),\\n            encodedOverrides: deliveryOverrides,\\n            redeliveryHash: bytes32(0)\\n        });\\n\\n        // Decode information from the execution parameters\\n        // (overriding them if there was an override requested)\\n        // Assumes execution parameters and info are of version EVM_V1\\n        (\\n            deliveryVaaInfo.gasLimit,\\n            deliveryVaaInfo.targetChainRefundPerGasUnused,\\n            deliveryVaaInfo.totalReceiverValue,\\n            deliveryVaaInfo.redeliveryHash\\n        ) = getDeliveryParametersEvmV1(instruction, deliveryOverrides);\\n\\n        // Revert if msg.value is not enough to fund both the receiver value\\n        // as well as the maximum possible refund \\n        // Note: instruction's TargetNative is delivery's LocalNative\\n        LocalNative requiredFunds = (deliveryVaaInfo.gasLimit.toWei(\\n            deliveryVaaInfo.targetChainRefundPerGasUnused\\n        ) + deliveryVaaInfo.totalReceiverValue.asNative()).asLocalNative();\\n        if (msgValue() < requiredFunds) {\\n            revert InsufficientRelayerFunds(msgValue(), requiredFunds);\\n        }\\n\\n        // Revert if the instruction's target chain is not this chain\\n        if (getChainId() != instruction.targetChain) {\\n            revert TargetChainIsNotThisChain(instruction.targetChain);\\n        }\\n\\n        // Revert if the VAAs delivered do not match the descriptions specified in the instruction\\n        checkMessageKeysWithMessages(instruction.messageKeys, encodedVMs);\\n\\n        executeDelivery(deliveryVaaInfo);\\n\\n        // Clear temporary storage of refund information\\n        clearRefundInformation();\\n    }\\n\\n    // ------------------------------------------- PRIVATE -------------------------------------------\\n\\n    struct DeliveryVAAInfo {\\n        uint16 sourceChain;\\n        uint64 sourceSequence;\\n        bytes32 deliveryVaaHash;\\n        address payable relayerRefundAddress;\\n        bytes[] encodedVMs;\\n        DeliveryInstruction deliveryInstruction;\\n        Gas gasLimit;\\n        GasPrice targetChainRefundPerGasUnused;\\n        TargetNative totalReceiverValue;\\n        bytes encodedOverrides;\\n        bytes32 redeliveryHash; //optional (0 if not present)\\n    }\\n\\n    function getDeliveryParametersEvmV1(\\n        DeliveryInstruction memory instruction,\\n        bytes memory encodedOverrides\\n    )\\n        internal\\n        pure\\n        returns (\\n            Gas gasLimit,\\n            GasPrice targetChainRefundPerGasUnused,\\n            TargetNative totalReceiverValue,\\n            bytes32 redeliveryHash\\n        )\\n    {\\n        ExecutionInfoVersion instructionExecutionInfoVersion =\\n            decodeExecutionInfoVersion(instruction.encodedExecutionInfo);\\n        if (instructionExecutionInfoVersion != ExecutionInfoVersion.EVM_V1) {\\n            revert UnexpectedExecutionInfoVersion(\\n                uint8(instructionExecutionInfoVersion), uint8(ExecutionInfoVersion.EVM_V1)\\n            );\\n        }\\n\\n        EvmExecutionInfoV1 memory executionInfo =\\n            decodeEvmExecutionInfoV1(instruction.encodedExecutionInfo);\\n\\n        // If present, apply redelivery deliveryOverrides to current instruction\\n        if (encodedOverrides.length != 0) {\\n            DeliveryOverride memory deliveryOverrides = encodedOverrides.decodeDeliveryOverride();\\n\\n            // Check to see if gasLimit >= original gas limit, receiver value >= original receiver value, and refund >= original refund\\n            // If so, replace the corresponding variables with the overriden variables\\n            // If not, revert\\n            (instruction.requestedReceiverValue, executionInfo) = decodeAndCheckOverridesEvmV1(\\n                instruction.requestedReceiverValue, executionInfo, deliveryOverrides\\n            );\\n            instruction.extraReceiverValue = TargetNative.wrap(0);\\n            redeliveryHash = deliveryOverrides.redeliveryHash;\\n        }\\n\\n        gasLimit = executionInfo.gasLimit;\\n        targetChainRefundPerGasUnused = executionInfo.targetChainRefundPerGasUnused;\\n        totalReceiverValue = instruction.requestedReceiverValue + instruction.extraReceiverValue;\\n    }\\n\\n    function decodeAndCheckOverridesEvmV1(\\n        TargetNative receiverValue,\\n        EvmExecutionInfoV1 memory executionInfo,\\n        DeliveryOverride memory deliveryOverrides\\n    )\\n        internal\\n        pure\\n        returns (\\n            TargetNative deliveryOverridesReceiverValue,\\n            EvmExecutionInfoV1 memory deliveryOverridesExecutionInfo\\n        )\\n    {\\n        if (deliveryOverrides.newReceiverValue.unwrap() < receiverValue.unwrap()) {\\n            revert InvalidOverrideReceiverValue();\\n        }\\n\\n        ExecutionInfoVersion deliveryOverridesExecutionInfoVersion =\\n            decodeExecutionInfoVersion(deliveryOverrides.newExecutionInfo);\\n        if (ExecutionInfoVersion.EVM_V1 != deliveryOverridesExecutionInfoVersion) {\\n            revert VersionMismatchOverride(\\n                uint8(ExecutionInfoVersion.EVM_V1), uint8(deliveryOverridesExecutionInfoVersion)\\n            );\\n        }\\n\\n        deliveryOverridesExecutionInfo =\\n            decodeEvmExecutionInfoV1(deliveryOverrides.newExecutionInfo);\\n        deliveryOverridesReceiverValue = deliveryOverrides.newReceiverValue;\\n\\n        if (deliveryOverridesExecutionInfo.gasLimit < executionInfo.gasLimit) {\\n            revert InvalidOverrideGasLimit();\\n        }\\n    }\\n\\n    struct DeliveryResults {\\n        Gas gasUsed;\\n        DeliveryStatus status;\\n        bytes additionalStatusInfo;\\n    }\\n\\n    /**\\n     * Performs the following actions:\\n     * - Calls the `receiveWormholeMessages` method on the contract\\n     *     `vaaInfo.deliveryInstruction.targetAddress` (with the gas limit and value specified in\\n     *     vaaInfo.gasLimit and vaaInfo.totalReceiverValue, and `encodedVMs` as the input)\\n     *\\n     * - Calculates how much gas from `vaaInfo.gasLimit` is left\\n     * - Refund anything leftover to the relayer\\n     *\\n     * @param vaaInfo struct specifying:\\n     *    - sourceChain chain id that the delivery originated from\\n     *    - sourceSequence sequence number of the delivery VAA on the source chain\\n     *    - deliveryVaaHash hash of delivery VAA\\n     *    - relayerRefundAddress address that should be paid for relayer refunds\\n     *    - encodedVMs list of signed wormhole messages (VAAs)\\n     *    - deliveryInstruction the specific instruction which is being executed\\n     *    - gasLimit the gas limit to call targetAddress with\\n     *    - targetChainRefundPerGasUnused the amount of (this chain) wei to refund to refundAddress\\n     *      per unit of gas unused (from gasLimit)\\n     *    - totalReceiverValue the msg.value to call targetAddress with\\n     *    - encodedOverrides any (encoded) overrides that were applied\\n     *    - (optional) redeliveryHash hash of redelivery Vaa\\n     */\\n\\n    function executeDelivery(DeliveryVAAInfo memory vaaInfo) private {\\n\\n        // If the targetAddress is the 0 address\\n        // Then emit event and return\\n        // (This is used for cross-chain refunds)\\n        if (vaaInfo.deliveryInstruction.targetAddress == 0x0) {\\n            handleCrossChainRefund(vaaInfo);\\n            return;\\n        }\\n\\n        DeliveryResults memory results;\\n\\n        // Check replay protection - if so, set status to receiver failure\\n        if(getDeliverySuccessState().deliverySuccessBlock[vaaInfo.deliveryVaaHash] != 0) {\\n            results = DeliveryResults(\\n                Gas.wrap(0),\\n                DeliveryStatus.RECEIVER_FAILURE,\\n                bytes(\\\"Delivery already performed\\\")\\n            );\\n        } else {\\n            results = executeInstruction(\\n                EvmDeliveryInstruction({\\n                    sourceChain: vaaInfo.sourceChain,\\n                    targetAddress: vaaInfo.deliveryInstruction.targetAddress,\\n                    payload: vaaInfo.deliveryInstruction.payload,\\n                    gasLimit: vaaInfo.gasLimit,\\n                    totalReceiverValue: vaaInfo.totalReceiverValue,\\n                    targetChainRefundPerGasUnused: vaaInfo.targetChainRefundPerGasUnused,\\n                    senderAddress: vaaInfo.deliveryInstruction.senderAddress,\\n                    deliveryHash: vaaInfo.deliveryVaaHash,\\n                    signedVaas: vaaInfo.encodedVMs\\n                })\\n            );\\n            setDeliveryBlock(results.status, vaaInfo.deliveryVaaHash);\\n        }\\n\\n        \\n\\n        RefundStatus refundStatus = payRefunds(\\n            vaaInfo.deliveryInstruction,\\n            vaaInfo.relayerRefundAddress,\\n            (vaaInfo.gasLimit - results.gasUsed).toWei(vaaInfo.targetChainRefundPerGasUnused).asLocalNative(),\\n            results.status\\n        );\\n        emitDeliveryEvent(vaaInfo, results, refundStatus);\\n    }\\n\\n    function executeInstruction(EvmDeliveryInstruction memory evmInstruction)\\n        internal\\n        returns (DeliveryResults memory results)\\n    {\\n\\n        Gas gasLimit = evmInstruction.gasLimit;\\n        bool success;\\n        {\\n            address payable deliveryTarget = payable(fromWormholeFormat(evmInstruction.targetAddress));\\n            bytes memory callData = abi.encodeCall(IWormholeReceiver.receiveWormholeMessages, (\\n                evmInstruction.payload,\\n                evmInstruction.signedVaas,\\n                evmInstruction.senderAddress,\\n                evmInstruction.sourceChain,\\n                evmInstruction.deliveryHash\\n            ));\\n\\n            // Measure gas usage of call\\n            Gas preGas = Gas.wrap(gasleft());\\n\\n            // Calls the `receiveWormholeMessages` endpoint on the contract `evmInstruction.targetAddress`\\n            // (with the gas limit and value specified in instruction, and `encodedVMs` as the input)\\n            // If it reverts, returns the first 132 bytes of the revert message\\n            (success, results.additionalStatusInfo) = returnLengthBoundedCall(\\n                deliveryTarget,\\n                callData,\\n                gasLimit.unwrap(),\\n                evmInstruction.totalReceiverValue.unwrap(),\\n                RETURNDATA_TRUNCATION_THRESHOLD\\n            );\\n\\n            Gas postGas = Gas.wrap(gasleft());\\n\\n            unchecked {\\n                results.gasUsed = (preGas - postGas).min(gasLimit);\\n            }\\n        }\\n\\n        if (success) {\\n            results.additionalStatusInfo = new bytes(0);\\n            results.status = DeliveryStatus.SUCCESS;\\n        } else {\\n            // Call to 'receiveWormholeMessages' on targetAddress reverted\\n            results.status = DeliveryStatus.RECEIVER_FAILURE;\\n        }\\n    }\\n\\n    function handleCrossChainRefund(DeliveryVAAInfo memory vaaInfo) internal {\\n        RefundStatus refundStatus = payRefunds(\\n            vaaInfo.deliveryInstruction,\\n            vaaInfo.relayerRefundAddress,\\n            LocalNative.wrap(0),\\n            DeliveryStatus.RECEIVER_FAILURE\\n        );\\n        emitDeliveryEvent(\\n            vaaInfo, \\n            DeliveryResults(\\n                Gas.wrap(0),\\n                DeliveryStatus.SUCCESS,\\n                bytes(\\\"\\\")\\n            ), \\n            refundStatus\\n        );\\n    }\\n\\n    function emitDeliveryEvent(DeliveryVAAInfo memory vaaInfo, DeliveryResults memory results, RefundStatus refundStatus) private {\\n        emit Delivery(\\n            fromWormholeFormat(vaaInfo.deliveryInstruction.targetAddress),\\n            vaaInfo.sourceChain,\\n            vaaInfo.sourceSequence,\\n            vaaInfo.deliveryVaaHash,\\n            results.status,\\n            results.gasUsed,\\n            refundStatus,\\n            results.additionalStatusInfo,\\n            (vaaInfo.redeliveryHash != 0) ? vaaInfo.encodedOverrides : new bytes(0)\\n        );\\n    }\\n\\n    function payRefunds(\\n        DeliveryInstruction memory deliveryInstruction,\\n        address payable relayerRefundAddress,\\n        LocalNative transactionFeeRefundAmount,\\n        DeliveryStatus status\\n    ) private returns (RefundStatus refundStatus) {\\n        //Amount of receiverValue that is refunded to the user (0 if the call to\\n        //  'receiveWormholeMessages' did not revert, or the full receiverValue otherwise)\\n        LocalNative receiverValueRefundAmount = LocalNative.wrap(0);\\n\\n        if (\\n            status == DeliveryStatus.RECEIVER_FAILURE\\n        ) {\\n            receiverValueRefundAmount = (\\n                deliveryInstruction.requestedReceiverValue + deliveryInstruction.extraReceiverValue\\n            ).asNative().asLocalNative(); // NOTE: instruction's target is delivery's local\\n        }\\n\\n        // Total refund to the user\\n        // (If the forward succeeded, the 'transactionFeeRefundAmount' was used there already)\\n        LocalNative refundToRefundAddress = receiverValueRefundAmount\\n            + transactionFeeRefundAmount;\\n\\n        //Refund the user\\n        refundStatus = deliveryInstruction.refundAddress == bytes32(0x0) ? RefundStatus.NO_REFUND_REQUESTED : payRefundToRefundAddress(\\n            deliveryInstruction.refundChain,\\n            deliveryInstruction.refundAddress,\\n            refundToRefundAddress,\\n            deliveryInstruction.refundDeliveryProvider\\n        );\\n\\n        //If sending the user's refund failed, this gets added to the relayer's refund\\n        LocalNative leftoverUserRefund = refundToRefundAddress;\\n        if (\\n            refundStatus == RefundStatus.REFUND_SENT\\n                || refundStatus == RefundStatus.CROSS_CHAIN_REFUND_SENT\\n        ) {\\n            leftoverUserRefund = LocalNative.wrap(0);\\n        }\\n\\n        // Refund the relayer all remaining funds\\n        LocalNative relayerRefundAmount = calcRelayerRefundAmount(deliveryInstruction, transactionFeeRefundAmount, leftoverUserRefund);\\n\\n        bool paymentSucceeded = pay(relayerRefundAddress, relayerRefundAmount);\\n        if(!paymentSucceeded) {\\n            revert DeliveryProviderCannotReceivePayment();\\n        }\\n    }\\n\\n    function calcRelayerRefundAmount(\\n        DeliveryInstruction memory deliveryInstruction,\\n        LocalNative transactionFeeRefundAmount,\\n        LocalNative leftoverUserRefund\\n    ) private view returns (LocalNative) {\\n        return msgValue()\\n            // Note: instruction's target is delivery's local\\n            - (deliveryInstruction.requestedReceiverValue + deliveryInstruction.extraReceiverValue).asNative().asLocalNative() \\n            - transactionFeeRefundAmount + leftoverUserRefund;\\n    }\\n\\n    function payRefundToRefundAddress(\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        LocalNative refundAmount,\\n        bytes32 deliveryProvider\\n    ) private returns (RefundStatus) {\\n        // User requested refund on this chain\\n        if (refundChain == getChainId()) {\\n            return pay(payable(fromWormholeFormat(refundAddress)), refundAmount, GAS_LIMIT_EXTERNAL_CALL)\\n                ? RefundStatus.REFUND_SENT\\n                : RefundStatus.REFUND_FAIL;\\n        }\\n\\n        // User requested refund on a different chain\\n        \\n        // Determine price of an 'empty' delivery\\n        // (Note: assumes refund chain is an EVM chain)\\n        (bool success, LocalNative baseDeliveryPrice) = untrustedBaseDeliveryPrice(fromWormholeFormat(deliveryProvider), refundChain);\\n        \\n        // If the unstrusted call failed, or the refundAmount is not greater than the 'empty delivery price', then the refund does not go through\\n        // Note: We first check 'refundAmount <= baseDeliveryPrice', in case an untrusted delivery provider returns a value that overflows once\\n        // the wormhole message fee is added to it\\n        unchecked {\\n            if (!success || (refundAmount <= baseDeliveryPrice) || (refundAmount <= getWormholeMessageFee() + baseDeliveryPrice)) {\\n                return RefundStatus.CROSS_CHAIN_REFUND_FAIL_NOT_ENOUGH;\\n            }\\n        }\\n        \\n        return sendCrossChainRefund(refundChain, refundAddress, refundAmount, refundAmount - getWormholeMessageFee() - baseDeliveryPrice, deliveryProvider);\\n    }\\n\\n    function untrustedBaseDeliveryPrice(address deliveryProvider, uint16 refundChain) internal returns (bool success, LocalNative baseDeliveryPrice) {\\n        (bool externalCallSuccess, bytes memory returnData) = returnLengthBoundedCall(\\n            deliveryProvider,\\n            abi.encodeCall(IDeliveryProvider.quoteDeliveryPrice, (refundChain, TargetNative.wrap(0), encodeEvmExecutionParamsV1(getEmptyEvmExecutionParamsV1()))),\\n            GAS_LIMIT_EXTERNAL_CALL,\\n            QUOTE_LENGTH_BYTES\\n        );\\n        \\n        if(externalCallSuccess && returnData.length == QUOTE_LENGTH_BYTES) {\\n            baseDeliveryPrice = abi.decode(returnData, (LocalNative));\\n            success = true;\\n        } else {\\n            success = false;\\n        }\\n    }\\n\\n    function sendCrossChainRefund(uint16 refundChain, bytes32 refundAddress, LocalNative sendAmount, LocalNative receiveAmount, bytes32 deliveryProvider) internal returns (RefundStatus status) {\\n        // Request a 'send' with 'paymentForExtraReceiverValue' equal to the refund minus the 'empty delivery price'\\n        // We limit the gas because we are within a delivery, so thus the trust assumptions on the delivery provider are different\\n        // Normally, in 'send', a revert is no problem; but here, we want to prevent such reverts in this try-catch\\n        try IWormholeRelayerSend(address(this)).send{value: sendAmount.unwrap(), gas: GAS_LIMIT_EXTERNAL_CALL}(\\n            refundChain,\\n            bytes32(0),\\n            bytes(\\\"\\\"),\\n            TargetNative.wrap(0),\\n            receiveAmount,\\n            encodeEvmExecutionParamsV1(getEmptyEvmExecutionParamsV1()),\\n            refundChain,\\n            refundAddress,\\n            fromWormholeFormat(deliveryProvider),\\n            new VaaKey[](0),\\n            CONSISTENCY_LEVEL_INSTANT\\n        ) returns (uint64) {\\n            return RefundStatus.CROSS_CHAIN_REFUND_SENT;\\n        } catch (bytes memory) {\\n            return RefundStatus.CROSS_CHAIN_REFUND_FAIL_PROVIDER_NOT_SUPPORTED;\\n        }\\n    }\\n\\n    function checkMessageKeysWithMessages(\\n        MessageKey[] memory messageKeys,\\n        bytes[] memory signedMessages\\n    ) private view {\\n        if (messageKeys.length != signedMessages.length) {\\n            revert MessageKeysLengthDoesNotMatchMessagesLength(messageKeys.length, signedMessages.length);\\n        }\\n\\n        uint256 len = messageKeys.length;\\n        for (uint256 i = 0; i < len;) {\\n            if (messageKeys[i].keyType == VAA_KEY_TYPE) {\\n                IWormhole.VM memory parsedVaa = getWormhole().parseVM(signedMessages[i]);\\n                (VaaKey memory vaaKey,) = WormholeRelayerSerde.decodeVaaKey(messageKeys[i].encodedKey, 0);\\n                \\n                if (\\n                    vaaKey.chainId != parsedVaa.emitterChainId\\n                        || vaaKey.emitterAddress != parsedVaa.emitterAddress\\n                        || vaaKey.sequence != parsedVaa.sequence\\n                ) {\\n                    revert VaaKeysDoNotMatchVaas(uint8(i));\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    // Ensures current block number is set to implement replay protection and for indexing purposes\\n    function setDeliveryBlock(DeliveryStatus status, bytes32 deliveryHash) private {\\n        if (status == DeliveryStatus.SUCCESS) {\\n            getDeliverySuccessState().deliverySuccessBlock[deliveryHash] = block.number;\\n            // Clear out failure block if it exists from previous delivery failure\\n            delete getDeliveryFailureState().deliveryFailureBlock[deliveryHash];\\n        } else {\\n            getDeliveryFailureState().deliveryFailureBlock[deliveryHash] = block.number;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/relayer/wormholeRelayer/WormholeRelayerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.19;\\n\\nimport {IWormhole} from \\\"../../interfaces/IWormhole.sol\\\";\\nimport {IDeliveryProvider} from \\\"../../interfaces/relayer/IDeliveryProviderTyped.sol\\\";\\nimport {toWormholeFormat, min, pay} from \\\"../../relayer/libraries/Utils.sol\\\";\\nimport {\\n    ReentrantDelivery,\\n    DeliveryProviderDoesNotSupportTargetChain,\\n    VaaKey,\\n    InvalidMsgValue,\\n    IWormholeRelayerBase\\n} from \\\"../../interfaces/relayer/IWormholeRelayerTyped.sol\\\";\\nimport {DeliveryInstruction} from \\\"../../relayer/libraries/RelayerInternalStructs.sol\\\";\\nimport {\\n    DeliveryTmpState,\\n    getDeliveryTmpState,\\n    getDeliverySuccessState,\\n    getDeliveryFailureState,\\n    getRegisteredWormholeRelayersState,\\n    getReentrancyGuardState\\n} from \\\"./WormholeRelayerStorage.sol\\\";\\nimport \\\"../../interfaces/relayer/TypedUnits.sol\\\";\\n\\nabstract contract WormholeRelayerBase is IWormholeRelayerBase {\\n    using WeiLib for Wei;\\n    using GasLib for Gas;\\n    using WeiPriceLib for WeiPrice;\\n    using GasPriceLib for GasPrice;\\n    using LocalNativeLib for LocalNative;\\n\\n    //see https://book.wormhole.com/wormhole/3_coreLayerContracts.html#consistency-levels\\n    //  15 is valid choice for now but ultimately we want something more canonical (202?)\\n    //  Also, these values should definitely not be defined here but should be provided by IWormhole!\\n    uint8 internal constant CONSISTENCY_LEVEL_FINALIZED = 15;\\n    uint8 internal constant CONSISTENCY_LEVEL_INSTANT = 200;\\n\\n    IWormhole private immutable wormhole_;\\n    uint16 private immutable chainId_;\\n\\n    constructor(address _wormhole) {\\n        wormhole_ = IWormhole(_wormhole);\\n        chainId_ = uint16(wormhole_.chainId());\\n    }\\n\\n    function getRegisteredWormholeRelayerContract(uint16 chainId) public view returns (bytes32) {\\n        return getRegisteredWormholeRelayersState().registeredWormholeRelayers[chainId];\\n    }\\n\\n    function deliveryAttempted(bytes32 deliveryHash) public view returns (bool attempted) {\\n        return getDeliverySuccessState().deliverySuccessBlock[deliveryHash] != 0 ||\\n            getDeliveryFailureState().deliveryFailureBlock[deliveryHash] != 0;\\n    }\\n\\n    function deliverySuccessBlock(bytes32 deliveryHash) public view returns (uint256 blockNumber) {\\n        return getDeliverySuccessState().deliverySuccessBlock[deliveryHash];\\n    }\\n\\n    function deliveryFailureBlock(bytes32 deliveryHash) public view returns (uint256 blockNumber) {\\n        return getDeliveryFailureState().deliveryFailureBlock[deliveryHash];\\n    }\\n\\n    //Our get functions require view instead of pure (despite not actually reading storage) because\\n    //  they can't be evaluated at compile time. (https://ethereum.stackexchange.com/a/120630/103366)\\n\\n    function getWormhole() internal view returns (IWormhole) {\\n        return wormhole_;\\n    }\\n\\n    function getChainId() internal view returns (uint16) {\\n        return chainId_;\\n    }\\n\\n    function getWormholeMessageFee() internal view returns (LocalNative) {\\n        return LocalNative.wrap(getWormhole().messageFee());\\n    }\\n\\n    function msgValue() internal view returns (LocalNative) {\\n        return LocalNative.wrap(msg.value);\\n    }\\n\\n    function checkMsgValue(\\n        LocalNative wormholeMessageFee,\\n        LocalNative deliveryPrice,\\n        LocalNative paymentForExtraReceiverValue\\n    ) internal view {\\n        if (msgValue() != deliveryPrice + paymentForExtraReceiverValue + wormholeMessageFee) {\\n            revert InvalidMsgValue(\\n                msgValue(), deliveryPrice + paymentForExtraReceiverValue + wormholeMessageFee\\n            );\\n        }\\n    }\\n\\n    function publishAndPay(\\n        LocalNative wormholeMessageFee,\\n        LocalNative deliveryQuote,\\n        LocalNative paymentForExtraReceiverValue,\\n        bytes memory encodedInstruction,\\n        uint8 consistencyLevel,\\n        address payable rewardAddress\\n    ) internal returns (uint64 sequence, bool paymentSucceeded) {\\n        sequence = getWormhole().publishMessage{value: wormholeMessageFee.unwrap()}(\\n            0, encodedInstruction, consistencyLevel\\n        );\\n\\n        paymentSucceeded = pay(\\n            rewardAddress,\\n            deliveryQuote + paymentForExtraReceiverValue\\n        );\\n\\n        emit SendEvent(sequence, deliveryQuote, paymentForExtraReceiverValue);\\n    }\\n\\n    modifier nonReentrant() {\\n        // Reentrancy guard\\n        if (getReentrancyGuardState().lockedBy != address(0)) {\\n            revert ReentrantDelivery(msg.sender, getReentrancyGuardState().lockedBy);\\n        }\\n        getReentrancyGuardState().lockedBy = msg.sender;\\n\\n        _;\\n\\n        getReentrancyGuardState().lockedBy = address(0);\\n    }\\n\\n     // ----------------------- delivery transaction temorary storage functions -----------------------\\n\\n    function recordRefundInformation(uint16 refundChain, bytes32 refundAddress) internal {\\n        DeliveryTmpState storage state = getDeliveryTmpState();\\n        state.refundChain = refundChain;\\n        state.refundAddress = refundAddress;\\n    }\\n\\n    function clearRefundInformation() internal {\\n        DeliveryTmpState storage state = getDeliveryTmpState();\\n        state.refundChain = 0;\\n        state.refundAddress = bytes32(0);\\n    }\\n\\n    function getCurrentRefundChain() internal view returns (uint16) {\\n        return getDeliveryTmpState().refundChain;\\n    }\\n\\n    function getCurrentRefundAddress() internal view returns (bytes32) {\\n        return getDeliveryTmpState().refundAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/relayer/TypedUnits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.19;\\n\\ntype WeiPrice is uint256;\\n\\ntype GasPrice is uint256;\\n\\ntype Gas is uint256;\\n\\ntype Dollar is uint256;\\n\\ntype Wei is uint256;\\n\\ntype LocalNative is uint256;\\n\\ntype TargetNative is uint256;\\n\\nusing {\\n    addWei as +,\\n    subWei as -,\\n    lteWei as <=,\\n    ltWei as <,\\n    gtWei as >,\\n    eqWei as ==,\\n    neqWei as !=\\n} for Wei global;\\nusing {addTargetNative as +, subTargetNative as -} for TargetNative global;\\nusing {\\n    leLocalNative as <,\\n    leqLocalNative as <=,\\n    neqLocalNative as !=,\\n    addLocalNative as +,\\n    subLocalNative as -\\n} for LocalNative global;\\nusing {\\n    ltGas as <,\\n    lteGas as <=,\\n    subGas as -\\n} for Gas global;\\n\\nusing WeiLib for Wei;\\nusing GasLib for Gas;\\nusing DollarLib for Dollar;\\nusing WeiPriceLib for WeiPrice;\\nusing GasPriceLib for GasPrice;\\n\\nfunction ltWei(Wei a, Wei b) pure returns (bool) {\\n    return Wei.unwrap(a) < Wei.unwrap(b);\\n}\\n\\nfunction eqWei(Wei a, Wei b) pure returns (bool) {\\n    return Wei.unwrap(a) == Wei.unwrap(b);\\n}\\n\\nfunction gtWei(Wei a, Wei b) pure returns (bool) {\\n    return Wei.unwrap(a) > Wei.unwrap(b);\\n}\\n\\nfunction lteWei(Wei a, Wei b) pure returns (bool) {\\n    return Wei.unwrap(a) <= Wei.unwrap(b);\\n}\\n\\nfunction subWei(Wei a, Wei b) pure returns (Wei) {\\n    return Wei.wrap(Wei.unwrap(a) - Wei.unwrap(b));\\n}\\n\\nfunction addWei(Wei a, Wei b) pure returns (Wei) {\\n    return Wei.wrap(Wei.unwrap(a) + Wei.unwrap(b));\\n}\\n\\nfunction neqWei(Wei a, Wei b) pure returns (bool) {\\n    return Wei.unwrap(a) != Wei.unwrap(b);\\n}\\n\\nfunction ltGas(Gas a, Gas b) pure returns (bool) {\\n    return Gas.unwrap(a) < Gas.unwrap(b);\\n}\\n\\nfunction lteGas(Gas a, Gas b) pure returns (bool) {\\n    return Gas.unwrap(a) <= Gas.unwrap(b);\\n}\\n\\nfunction subGas(Gas a, Gas b) pure returns (Gas) {\\n    return Gas.wrap(Gas.unwrap(a) - Gas.unwrap(b));\\n}\\n\\nfunction addTargetNative(TargetNative a, TargetNative b) pure returns (TargetNative) {\\n    return TargetNative.wrap(TargetNative.unwrap(a) + TargetNative.unwrap(b));\\n}\\n\\nfunction subTargetNative(TargetNative a, TargetNative b) pure returns (TargetNative) {\\n    return TargetNative.wrap(TargetNative.unwrap(a) - TargetNative.unwrap(b));\\n}\\n\\nfunction addLocalNative(LocalNative a, LocalNative b) pure returns (LocalNative) {\\n    return LocalNative.wrap(LocalNative.unwrap(a) + LocalNative.unwrap(b));\\n}\\n\\nfunction subLocalNative(LocalNative a, LocalNative b) pure returns (LocalNative) {\\n    return LocalNative.wrap(LocalNative.unwrap(a) - LocalNative.unwrap(b));\\n}\\n\\nfunction neqLocalNative(LocalNative a, LocalNative b) pure returns (bool) {\\n    return LocalNative.unwrap(a) != LocalNative.unwrap(b);\\n}\\n\\nfunction leLocalNative(LocalNative a, LocalNative b) pure returns (bool) {\\n    return LocalNative.unwrap(a) < LocalNative.unwrap(b);\\n}\\n\\nfunction leqLocalNative(LocalNative a, LocalNative b) pure returns (bool) {\\n    return LocalNative.unwrap(a) <= LocalNative.unwrap(b);\\n}\\n\\nlibrary WeiLib {\\n    using {\\n        toDollars,\\n        toGas,\\n        convertAsset,\\n        min,\\n        max,\\n        scale,\\n        unwrap,\\n        asGasPrice,\\n        asTargetNative,\\n        asLocalNative\\n    } for Wei;\\n\\n    function min(Wei x, Wei maxVal) internal pure returns (Wei) {\\n        return x > maxVal ? maxVal : x;\\n    }\\n\\n    function max(Wei x, Wei maxVal) internal pure returns (Wei) {\\n        return x < maxVal ? maxVal : x;\\n    }\\n\\n    function asTargetNative(Wei w) internal pure returns (TargetNative) {\\n        return TargetNative.wrap(Wei.unwrap(w));\\n    }\\n\\n    function asLocalNative(Wei w) internal pure returns (LocalNative) {\\n        return LocalNative.wrap(Wei.unwrap(w));\\n    }\\n\\n    function toDollars(Wei w, WeiPrice price) internal pure returns (Dollar) {\\n        return Dollar.wrap(Wei.unwrap(w) * WeiPrice.unwrap(price));\\n    }\\n\\n    function toGas(Wei w, GasPrice price) internal pure returns (Gas) {\\n        return Gas.wrap(Wei.unwrap(w) / GasPrice.unwrap(price));\\n    }\\n\\n    function scale(Wei w, Gas num, Gas denom) internal pure returns (Wei) {\\n        return Wei.wrap(Wei.unwrap(w) * Gas.unwrap(num) / Gas.unwrap(denom));\\n    }\\n\\n    function unwrap(Wei w) internal pure returns (uint256) {\\n        return Wei.unwrap(w);\\n    }\\n\\n    function asGasPrice(Wei w) internal pure returns (GasPrice) {\\n        return GasPrice.wrap(Wei.unwrap(w));\\n    }\\n\\n    function convertAsset(\\n        Wei w,\\n        WeiPrice fromPrice,\\n        WeiPrice toPrice,\\n        uint32 multiplierNum,\\n        uint32 multiplierDenom,\\n        bool roundUp\\n    ) internal pure returns (Wei) {\\n        Dollar numerator = w.toDollars(fromPrice).mul(multiplierNum);\\n        WeiPrice denom = toPrice.mul(multiplierDenom);\\n        Wei res = numerator.toWei(denom, roundUp);\\n        return res;\\n    }\\n}\\n\\nlibrary GasLib {\\n    using {toWei, unwrap} for Gas;\\n\\n    function min(Gas x, Gas maxVal) internal pure returns (Gas) {\\n        return x < maxVal ? x : maxVal;\\n    }\\n\\n    function toWei(Gas w, GasPrice price) internal pure returns (Wei) {\\n        return Wei.wrap(w.unwrap() * price.unwrap());\\n    }\\n\\n    function unwrap(Gas w) internal pure returns (uint256) {\\n        return Gas.unwrap(w);\\n    }\\n}\\n\\nlibrary DollarLib {\\n    using {toWei, mul, unwrap} for Dollar;\\n\\n    function mul(Dollar a, uint256 b) internal pure returns (Dollar) {\\n        return Dollar.wrap(a.unwrap() * b);\\n    }\\n\\n    function toWei(Dollar w, WeiPrice price, bool roundUp) internal pure returns (Wei) {\\n        return Wei.wrap((w.unwrap() + (roundUp ? price.unwrap() - 1 : 0)) / price.unwrap());\\n    }\\n\\n    function toGas(Dollar w, GasPrice price, WeiPrice weiPrice) internal pure returns (Gas) {\\n        return w.toWei(weiPrice, false).toGas(price);\\n    }\\n\\n    function unwrap(Dollar w) internal pure returns (uint256) {\\n        return Dollar.unwrap(w);\\n    }\\n}\\n\\nlibrary WeiPriceLib {\\n    using {mul, unwrap} for WeiPrice;\\n\\n    function mul(WeiPrice a, uint256 b) internal pure returns (WeiPrice) {\\n        return WeiPrice.wrap(a.unwrap() * b);\\n    }\\n\\n    function unwrap(WeiPrice w) internal pure returns (uint256) {\\n        return WeiPrice.unwrap(w);\\n    }\\n}\\n\\nlibrary GasPriceLib {\\n    using {unwrap, priceAsWei} for GasPrice;\\n\\n    function priceAsWei(GasPrice w) internal pure returns (Wei) {\\n        return Wei.wrap(w.unwrap());\\n    }\\n\\n    function unwrap(GasPrice w) internal pure returns (uint256) {\\n        return GasPrice.unwrap(w);\\n    }\\n}\\n\\nlibrary TargetNativeLib {\\n    using {unwrap, asNative} for TargetNative;\\n\\n    function unwrap(TargetNative w) internal pure returns (uint256) {\\n        return TargetNative.unwrap(w);\\n    }\\n\\n    function asNative(TargetNative w) internal pure returns (Wei) {\\n        return Wei.wrap(TargetNative.unwrap(w));\\n    }\\n}\\n\\nlibrary LocalNativeLib {\\n    using {unwrap, asNative} for LocalNative;\\n\\n    function unwrap(LocalNative w) internal pure returns (uint256) {\\n        return LocalNative.unwrap(w);\\n    }\\n\\n    function asNative(LocalNative w) internal pure returns (Wei) {\\n        return Wei.wrap(LocalNative.unwrap(w));\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallSecure(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        address oldImplementation = _getImplementation();\\n\\n        // Initial upgrade and setup call\\n        _setImplementation(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n\\n        // Perform rollback test if not already in progress\\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\\n        if (!rollbackTesting.value) {\\n            // Trigger rollback using upgradeTo from the new implementation\\n            rollbackTesting.value = true;\\n            Address.functionDelegateCall(\\n                newImplementation,\\n                abi.encodeWithSignature(\\\"upgradeTo(address)\\\", oldImplementation)\\n            );\\n            rollbackTesting.value = false;\\n            // Check rollback was effective\\n            require(oldImplementation == _getImplementation(), \\\"ERC1967Upgrade: upgrade breaks further upgrades\\\");\\n            // Finally reset to the new implementation and log the upgrade\\n            _upgradeTo(newImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWormhole.sol\": {\r\n      \"content\": \"// contracts/Messages.sol\\n// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\ninterface IWormhole {\\n    struct GuardianSet {\\n        address[] keys;\\n        uint32 expirationTime;\\n    }\\n\\n    struct Signature {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        uint8 guardianIndex;\\n    }\\n\\n    struct VM {\\n        uint8 version;\\n        uint32 timestamp;\\n        uint32 nonce;\\n        uint16 emitterChainId;\\n        bytes32 emitterAddress;\\n        uint64 sequence;\\n        uint8 consistencyLevel;\\n        bytes payload;\\n\\n        uint32 guardianSetIndex;\\n        Signature[] signatures;\\n\\n        bytes32 hash;\\n    }\\n\\n    struct ContractUpgrade {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n\\n        address newContract;\\n    }\\n\\n    struct GuardianSetUpgrade {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n\\n        GuardianSet newGuardianSet;\\n        uint32 newGuardianSetIndex;\\n    }\\n\\n    struct SetMessageFee {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n\\n        uint256 messageFee;\\n    }\\n\\n    struct TransferFees {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n\\n        uint256 amount;\\n        bytes32 recipient;\\n    }\\n\\n    struct RecoverChainId {\\n        bytes32 module;\\n        uint8 action;\\n\\n        uint256 evmChainId;\\n        uint16 newChainId;\\n    }\\n\\n    event LogMessagePublished(address indexed sender, uint64 sequence, uint32 nonce, bytes payload, uint8 consistencyLevel);\\n    event ContractUpgraded(address indexed oldContract, address indexed newContract);\\n    event GuardianSetAdded(uint32 indexed index);\\n\\n    function publishMessage(\\n        uint32 nonce,\\n        bytes memory payload,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    function initialize() external;\\n\\n    function parseAndVerifyVM(bytes calldata encodedVM) external view returns (VM memory vm, bool valid, string memory reason);\\n\\n    function verifyVM(VM memory vm) external view returns (bool valid, string memory reason);\\n\\n    function verifySignatures(bytes32 hash, Signature[] memory signatures, GuardianSet memory guardianSet) external pure returns (bool valid, string memory reason);\\n\\n    function parseVM(bytes memory encodedVM) external pure returns (VM memory vm);\\n\\n    function quorum(uint numGuardians) external pure returns (uint numSignaturesRequiredForQuorum);\\n\\n    function getGuardianSet(uint32 index) external view returns (GuardianSet memory);\\n\\n    function getCurrentGuardianSetIndex() external view returns (uint32);\\n\\n    function getGuardianSetExpiry() external view returns (uint32);\\n\\n    function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\\n\\n    function isInitialized(address impl) external view returns (bool);\\n\\n    function chainId() external view returns (uint16);\\n\\n    function isFork() external view returns (bool);\\n\\n    function governanceChainId() external view returns (uint16);\\n\\n    function governanceContract() external view returns (bytes32);\\n\\n    function messageFee() external view returns (uint256);\\n\\n    function evmChainId() external view returns (uint256);\\n\\n    function nextSequence(address emitter) external view returns (uint64);\\n\\n    function parseContractUpgrade(bytes memory encodedUpgrade) external pure returns (ContractUpgrade memory cu);\\n\\n    function parseGuardianSetUpgrade(bytes memory encodedUpgrade) external pure returns (GuardianSetUpgrade memory gsu);\\n\\n    function parseSetMessageFee(bytes memory encodedSetMessageFee) external pure returns (SetMessageFee memory smf);\\n\\n    function parseTransferFees(bytes memory encodedTransferFees) external pure returns (TransferFees memory tf);\\n\\n    function parseRecoverChainId(bytes memory encodedRecoverChainId) external pure returns (RecoverChainId memory rci);\\n\\n    function submitContractUpgrade(bytes memory _vm) external;\\n\\n    function submitSetMessageFee(bytes memory _vm) external;\\n\\n    function submitNewGuardianSet(bytes memory _vm) external;\\n\\n    function submitTransferFees(bytes memory _vm) external;\\n\\n    function submitRecoverChainId(bytes memory _vm) external;\\n}\\n\"\r\n    },\r\n    \"contracts/relayer/libraries/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/relayer/TypedUnits.sol\\\";\\n\\nerror NotAnEvmAddress(bytes32);\\n\\nfunction pay(address payable receiver, LocalNative amount) returns (bool success) {\\n  uint256 amount_ = LocalNative.unwrap(amount);\\n  if (amount_ != 0)\\n    // TODO: we currently ignore the return data. Some users of this function might want to bubble up the return value though.\\n    // Specifying a higher limit than 63/64 of the remaining gas caps it at that amount without throwing an exception.\\n    (success,) = returnLengthBoundedCall(receiver, new bytes(0), gasleft(), amount_, 0);\\n  else\\n    success = true;\\n}\\n\\nfunction pay(address payable receiver, LocalNative amount, uint256 gasBound) returns (bool success) {\\n  uint256 amount_ = LocalNative.unwrap(amount);\\n  if (amount_ != 0)\\n    // TODO: we currently ignore the return data. Some users of this function might want to bubble up the return value though.\\n    // Specifying a higher limit than 63/64 of the remaining gas caps it at that amount without throwing an exception.\\n    (success,) = returnLengthBoundedCall(receiver, new bytes(0), gasBound, amount_, 0);\\n  else\\n    success = true;\\n}\\n\\nfunction min(uint256 a, uint256 b) pure returns (uint256) {\\n  return a < b ? a : b;\\n}\\n\\nfunction min(uint64 a, uint64 b) pure returns (uint64) {\\n  return a < b ? a : b;\\n}\\n\\nfunction max(uint256 a, uint256 b) pure returns (uint256) {\\n  return a > b ? a : b;\\n}\\n\\nfunction toWormholeFormat(address addr) pure returns (bytes32) {\\n  return bytes32(uint256(uint160(addr)));\\n}\\n\\nfunction fromWormholeFormat(bytes32 whFormatAddress) pure returns (address) {\\n  if (uint256(whFormatAddress) >> 160 != 0)\\n    revert NotAnEvmAddress(whFormatAddress);\\n  return address(uint160(uint256(whFormatAddress)));\\n}\\n\\nfunction fromWormholeFormatUnchecked(bytes32 whFormatAddress) pure returns (address) {\\n  return address(uint160(uint256(whFormatAddress)));\\n}\\n\\n\\nuint256 constant freeMemoryPtr = 0x40;\\nuint256 constant memoryWord = 32;\\nuint256 constant maskModulo32 = 0x1f;\\n\\n/**\\n * Overload with no 'value' and non-payable address\\n */\\nfunction returnLengthBoundedCall(\\n  address callee,\\n  bytes memory callData,\\n  uint256 gasLimit,\\n  uint256 dataLengthBound\\n) returns (bool success, bytes memory returnedData) {\\n  return returnLengthBoundedCall(payable(callee), callData, gasLimit, 0, dataLengthBound);\\n}\\n\\n/**\\n * Implements call that truncates return data to a specific size to avoid excessive gas consumption for relayers\\n * when a revert or unexpectedly large return value is produced by the call.\\n *\\n * @param returnedData Buffer of returned data truncated to the first `dataLengthBound` bytes.\\n */\\nfunction returnLengthBoundedCall(\\n  address payable callee,\\n  bytes memory callData,\\n  uint256 gasLimit,\\n  uint256 value,\\n  uint256 dataLengthBound\\n) returns (bool success, bytes memory returnedData) {\\n  uint256 callDataLength = callData.length;\\n  assembly (\\\"memory-safe\\\") {\\n    returnedData := mload(freeMemoryPtr)\\n    let returnedDataBuffer := add(returnedData, memoryWord)\\n    let callDataBuffer := add(callData, memoryWord)\\n\\n    success := call(gasLimit, callee, value, callDataBuffer, callDataLength, returnedDataBuffer, dataLengthBound)\\n    let returnedDataSize := returndatasize()\\n    switch lt(dataLengthBound, returnedDataSize)\\n    case 1 {\\n      returnedDataSize := dataLengthBound\\n    } default {}\\n    mstore(returnedData, returnedDataSize)\\n\\n    // Here we update the free memory pointer.\\n    // We want to pad `returnedData` to memory word size, i.e. 32 bytes.\\n    // Note that negating bitwise `maskModulo32` produces a mask that aligns addressing to 32 bytes.\\n    // This allows us to pad the entire `bytes` structure (length + buffer) to 32 bytes at the end.\\n    // We add `maskModulo32` to get the next free memory \\\"slot\\\" in case the `returnedDataSize` is not a multiple of the memory word size.\\n    //\\n    // Rationale:\\n    // We do not care about the alignment of the free memory pointer. The solidity compiler documentation does not promise nor require alignment on it.\\n    // It does however lightly suggest to pad `bytes` structures to 32 bytes: https://docs.soliditylang.org/en/v0.8.20/assembly.html#example\\n    // Searching for \\\"alignment\\\" and \\\"padding\\\" in https://gitter.im/ethereum/solidity-dev\\n    // yielded the following at the time of writing \u2013 paraphrased:\\n    // > It's possible that the compiler cleans that padding in some cases. Users should not rely on the compiler never doing that.\\n    // This means that we want to ensure that the free memory pointer points to memory just after this padding for our `returnedData` `bytes` structure.\\n    let paddedPastTheEndOffset := and(add(returnedDataSize, maskModulo32), not(maskModulo32))\\n    let newFreeMemoryPtr := add(returnedDataBuffer, paddedPastTheEndOffset)\\n    mstore(freeMemoryPtr, newFreeMemoryPtr)\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/relayer/libraries/BytesParsing.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\n\\nlibrary BytesParsing {\\n  uint256 private constant freeMemoryPtr = 0x40;\\n  uint256 private constant wordSize = 32;\\n\\n  error OutOfBounds(uint256 offset, uint256 length);\\n\\n  function checkBound(uint offset, uint length) internal pure {\\n    if (offset > length)\\n      revert OutOfBounds(offset, length);\\n  }\\n\\n  function sliceUnchecked(\\n    bytes memory encoded,\\n    uint offset,\\n    uint length\\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\\n    //bail early for degenerate case\\n    if (length == 0)\\n      return (new bytes(0), offset);\\n\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, length)\\n      ret := mload(freeMemoryPtr)\\n\\n      //Explanation on how we copy data here:\\n      //  The bytes type has the following layout in memory:\\n      //    [length: 32 bytes, data: length bytes]\\n      //  So if we allocate `bytes memory foo = new bytes(1);` then `foo` will be a pointer to 33\\n      //    bytes where the first 32 bytes contain the length and the last byte is the actual data.\\n      //  Since mload always loads 32 bytes of memory at once, we use our shift variable to align\\n      //    our reads so that our last read lines up exactly with the last 32 bytes of `encoded`.\\n      //  However this also means that if the length of `encoded` is not a multiple of 32 bytes, our\\n      //    first read will necessarily partly contain bytes from `encoded`'s 32 length bytes that\\n      //    will be written into the length part of our `ret` slice.\\n      //  We remedy this issue by writing the length of our `ret` slice at the end, thus\\n      //    overwritting those garbage bytes.\\n      let shift := and(length, 31) //equivalent to `mod(length, 32)` but 2 gas cheaper\\n      if iszero(shift) {\\n        shift := wordSize\\n      }\\n\\n      let dest := add(ret, shift)\\n      let end := add(dest, length)\\n      for {\\n        let src := add(add(encoded, shift), offset)\\n      } lt(dest, end) {\\n        src := add(src, wordSize)\\n        dest := add(dest, wordSize)\\n      } {\\n        mstore(dest, mload(src))\\n      }\\n\\n      mstore(ret, length)\\n      //When compiling with --via-ir then normally allocated memory (i.e. via new) will have 32 byte\\n      //  memory alignment and so we enforce the same memory alignment here.\\n      mstore(freeMemoryPtr, and(add(dest, 31), not(31)))\\n    }\\n  }\\n\\n  function slice(\\n    bytes memory encoded,\\n    uint offset,\\n    uint length\\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\\n    (ret, nextOffset) = sliceUnchecked(encoded, offset, length);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asAddressUnchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (address, uint) {\\n    (uint160 ret, uint nextOffset) = asUint160(encoded, offset);\\n    return (address(ret), nextOffset);\\n  }\\n\\n  function asAddress(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (address ret, uint nextOffset) {\\n    (ret, nextOffset) = asAddressUnchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBoolUnckecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bool, uint) {\\n    (uint8 ret, uint nextOffset) = asUint8(encoded, offset);\\n    return (ret != 0, nextOffset);\\n  }\\n\\n  function asBool(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bool ret, uint nextOffset) {\\n    (ret, nextOffset) = asBoolUnckecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n/* -------------------------------------------------------------------------------------------------\\nRemaining library code below was auto-generated by via the following js/node code:\\n\\nfor (let bytes = 1; bytes <= 32; ++bytes) {\\n  const bits = bytes*8;\\n  console.log(\\n`function asUint${bits}Unchecked(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (uint${bits} ret, uint nextOffset) {\\n  assembly (\\\"memory-safe\\\") {\\n    nextOffset := add(offset, ${bytes})\\n    ret := mload(add(encoded, nextOffset))\\n  }\\n  return (ret, nextOffset);\\n}\\n\\nfunction asUint${bits}(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (uint${bits} ret, uint nextOffset) {\\n  (ret, nextOffset) = asUint${bits}Unchecked(encoded, offset);\\n  checkBound(nextOffset, encoded.length);\\n}\\n\\nfunction asBytes${bytes}Unchecked(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (bytes${bytes}, uint) {\\n  (uint${bits} ret, uint nextOffset) = asUint${bits}Unchecked(encoded, offset);\\n  return (bytes${bytes}(ret), nextOffset);\\n}\\n\\nfunction asBytes${bytes}(\\n  bytes memory encoded,\\n  uint offset\\n) internal pure returns (bytes${bytes}, uint) {\\n  (uint${bits} ret, uint nextOffset) = asUint${bits}(encoded, offset);\\n  return (bytes${bytes}(ret), nextOffset);\\n}\\n`\\n  );\\n}\\n------------------------------------------------------------------------------------------------- */\\n\\n  function asUint8Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint8 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 1)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint8(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint8 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint8Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes1Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes1, uint) {\\n    (uint8 ret, uint nextOffset) = asUint8Unchecked(encoded, offset);\\n    return (bytes1(ret), nextOffset);\\n  }\\n\\n  function asBytes1(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes1, uint) {\\n    (uint8 ret, uint nextOffset) = asUint8(encoded, offset);\\n    return (bytes1(ret), nextOffset);\\n  }\\n\\n  function asUint16Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint16 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 2)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint16(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint16 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint16Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes2Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes2, uint) {\\n    (uint16 ret, uint nextOffset) = asUint16Unchecked(encoded, offset);\\n    return (bytes2(ret), nextOffset);\\n  }\\n\\n  function asBytes2(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes2, uint) {\\n    (uint16 ret, uint nextOffset) = asUint16(encoded, offset);\\n    return (bytes2(ret), nextOffset);\\n  }\\n\\n  function asUint24Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint24 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 3)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint24(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint24 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint24Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes3Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes3, uint) {\\n    (uint24 ret, uint nextOffset) = asUint24Unchecked(encoded, offset);\\n    return (bytes3(ret), nextOffset);\\n  }\\n\\n  function asBytes3(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes3, uint) {\\n    (uint24 ret, uint nextOffset) = asUint24(encoded, offset);\\n    return (bytes3(ret), nextOffset);\\n  }\\n\\n  function asUint32Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint32 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 4)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint32(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint32 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint32Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes4Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes4, uint) {\\n    (uint32 ret, uint nextOffset) = asUint32Unchecked(encoded, offset);\\n    return (bytes4(ret), nextOffset);\\n  }\\n\\n  function asBytes4(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes4, uint) {\\n    (uint32 ret, uint nextOffset) = asUint32(encoded, offset);\\n    return (bytes4(ret), nextOffset);\\n  }\\n\\n  function asUint40Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint40 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 5)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint40(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint40 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint40Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes5Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes5, uint) {\\n    (uint40 ret, uint nextOffset) = asUint40Unchecked(encoded, offset);\\n    return (bytes5(ret), nextOffset);\\n  }\\n\\n  function asBytes5(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes5, uint) {\\n    (uint40 ret, uint nextOffset) = asUint40(encoded, offset);\\n    return (bytes5(ret), nextOffset);\\n  }\\n\\n  function asUint48Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint48 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 6)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint48(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint48 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint48Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes6Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes6, uint) {\\n    (uint48 ret, uint nextOffset) = asUint48Unchecked(encoded, offset);\\n    return (bytes6(ret), nextOffset);\\n  }\\n\\n  function asBytes6(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes6, uint) {\\n    (uint48 ret, uint nextOffset) = asUint48(encoded, offset);\\n    return (bytes6(ret), nextOffset);\\n  }\\n\\n  function asUint56Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint56 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 7)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint56(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint56 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint56Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes7Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes7, uint) {\\n    (uint56 ret, uint nextOffset) = asUint56Unchecked(encoded, offset);\\n    return (bytes7(ret), nextOffset);\\n  }\\n\\n  function asBytes7(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes7, uint) {\\n    (uint56 ret, uint nextOffset) = asUint56(encoded, offset);\\n    return (bytes7(ret), nextOffset);\\n  }\\n\\n  function asUint64Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint64 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 8)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint64(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint64 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint64Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes8Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes8, uint) {\\n    (uint64 ret, uint nextOffset) = asUint64Unchecked(encoded, offset);\\n    return (bytes8(ret), nextOffset);\\n  }\\n\\n  function asBytes8(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes8, uint) {\\n    (uint64 ret, uint nextOffset) = asUint64(encoded, offset);\\n    return (bytes8(ret), nextOffset);\\n  }\\n\\n  function asUint72Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint72 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 9)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint72(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint72 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint72Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes9Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes9, uint) {\\n    (uint72 ret, uint nextOffset) = asUint72Unchecked(encoded, offset);\\n    return (bytes9(ret), nextOffset);\\n  }\\n\\n  function asBytes9(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes9, uint) {\\n    (uint72 ret, uint nextOffset) = asUint72(encoded, offset);\\n    return (bytes9(ret), nextOffset);\\n  }\\n\\n  function asUint80Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint80 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 10)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint80(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint80 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint80Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes10Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes10, uint) {\\n    (uint80 ret, uint nextOffset) = asUint80Unchecked(encoded, offset);\\n    return (bytes10(ret), nextOffset);\\n  }\\n\\n  function asBytes10(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes10, uint) {\\n    (uint80 ret, uint nextOffset) = asUint80(encoded, offset);\\n    return (bytes10(ret), nextOffset);\\n  }\\n\\n  function asUint88Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint88 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 11)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint88(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint88 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint88Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes11Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes11, uint) {\\n    (uint88 ret, uint nextOffset) = asUint88Unchecked(encoded, offset);\\n    return (bytes11(ret), nextOffset);\\n  }\\n\\n  function asBytes11(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes11, uint) {\\n    (uint88 ret, uint nextOffset) = asUint88(encoded, offset);\\n    return (bytes11(ret), nextOffset);\\n  }\\n\\n  function asUint96Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint96 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 12)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint96(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint96 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint96Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes12Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes12, uint) {\\n    (uint96 ret, uint nextOffset) = asUint96Unchecked(encoded, offset);\\n    return (bytes12(ret), nextOffset);\\n  }\\n\\n  function asBytes12(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes12, uint) {\\n    (uint96 ret, uint nextOffset) = asUint96(encoded, offset);\\n    return (bytes12(ret), nextOffset);\\n  }\\n\\n  function asUint104Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint104 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 13)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint104(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint104 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint104Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes13Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes13, uint) {\\n    (uint104 ret, uint nextOffset) = asUint104Unchecked(encoded, offset);\\n    return (bytes13(ret), nextOffset);\\n  }\\n\\n  function asBytes13(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes13, uint) {\\n    (uint104 ret, uint nextOffset) = asUint104(encoded, offset);\\n    return (bytes13(ret), nextOffset);\\n  }\\n\\n  function asUint112Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint112 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 14)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint112(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint112 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint112Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes14Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes14, uint) {\\n    (uint112 ret, uint nextOffset) = asUint112Unchecked(encoded, offset);\\n    return (bytes14(ret), nextOffset);\\n  }\\n\\n  function asBytes14(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes14, uint) {\\n    (uint112 ret, uint nextOffset) = asUint112(encoded, offset);\\n    return (bytes14(ret), nextOffset);\\n  }\\n\\n  function asUint120Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint120 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 15)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint120(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint120 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint120Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes15Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes15, uint) {\\n    (uint120 ret, uint nextOffset) = asUint120Unchecked(encoded, offset);\\n    return (bytes15(ret), nextOffset);\\n  }\\n\\n  function asBytes15(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes15, uint) {\\n    (uint120 ret, uint nextOffset) = asUint120(encoded, offset);\\n    return (bytes15(ret), nextOffset);\\n  }\\n\\n  function asUint128Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint128 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 16)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint128(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint128 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint128Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes16Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes16, uint) {\\n    (uint128 ret, uint nextOffset) = asUint128Unchecked(encoded, offset);\\n    return (bytes16(ret), nextOffset);\\n  }\\n\\n  function asBytes16(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes16, uint) {\\n    (uint128 ret, uint nextOffset) = asUint128(encoded, offset);\\n    return (bytes16(ret), nextOffset);\\n  }\\n\\n  function asUint136Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint136 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 17)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint136(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint136 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint136Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes17Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes17, uint) {\\n    (uint136 ret, uint nextOffset) = asUint136Unchecked(encoded, offset);\\n    return (bytes17(ret), nextOffset);\\n  }\\n\\n  function asBytes17(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes17, uint) {\\n    (uint136 ret, uint nextOffset) = asUint136(encoded, offset);\\n    return (bytes17(ret), nextOffset);\\n  }\\n\\n  function asUint144Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint144 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 18)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint144(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint144 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint144Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes18Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes18, uint) {\\n    (uint144 ret, uint nextOffset) = asUint144Unchecked(encoded, offset);\\n    return (bytes18(ret), nextOffset);\\n  }\\n\\n  function asBytes18(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes18, uint) {\\n    (uint144 ret, uint nextOffset) = asUint144(encoded, offset);\\n    return (bytes18(ret), nextOffset);\\n  }\\n\\n  function asUint152Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint152 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 19)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint152(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint152 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint152Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes19Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes19, uint) {\\n    (uint152 ret, uint nextOffset) = asUint152Unchecked(encoded, offset);\\n    return (bytes19(ret), nextOffset);\\n  }\\n\\n  function asBytes19(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes19, uint) {\\n    (uint152 ret, uint nextOffset) = asUint152(encoded, offset);\\n    return (bytes19(ret), nextOffset);\\n  }\\n\\n  function asUint160Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint160 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 20)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint160(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint160 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint160Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes20Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes20, uint) {\\n    (uint160 ret, uint nextOffset) = asUint160Unchecked(encoded, offset);\\n    return (bytes20(ret), nextOffset);\\n  }\\n\\n  function asBytes20(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes20, uint) {\\n    (uint160 ret, uint nextOffset) = asUint160(encoded, offset);\\n    return (bytes20(ret), nextOffset);\\n  }\\n\\n  function asUint168Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint168 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 21)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint168(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint168 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint168Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes21Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes21, uint) {\\n    (uint168 ret, uint nextOffset) = asUint168Unchecked(encoded, offset);\\n    return (bytes21(ret), nextOffset);\\n  }\\n\\n  function asBytes21(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes21, uint) {\\n    (uint168 ret, uint nextOffset) = asUint168(encoded, offset);\\n    return (bytes21(ret), nextOffset);\\n  }\\n\\n  function asUint176Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint176 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 22)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint176(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint176 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint176Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes22Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes22, uint) {\\n    (uint176 ret, uint nextOffset) = asUint176Unchecked(encoded, offset);\\n    return (bytes22(ret), nextOffset);\\n  }\\n\\n  function asBytes22(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes22, uint) {\\n    (uint176 ret, uint nextOffset) = asUint176(encoded, offset);\\n    return (bytes22(ret), nextOffset);\\n  }\\n\\n  function asUint184Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint184 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 23)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint184(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint184 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint184Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes23Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes23, uint) {\\n    (uint184 ret, uint nextOffset) = asUint184Unchecked(encoded, offset);\\n    return (bytes23(ret), nextOffset);\\n  }\\n\\n  function asBytes23(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes23, uint) {\\n    (uint184 ret, uint nextOffset) = asUint184(encoded, offset);\\n    return (bytes23(ret), nextOffset);\\n  }\\n\\n  function asUint192Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint192 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 24)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint192(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint192 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint192Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes24Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes24, uint) {\\n    (uint192 ret, uint nextOffset) = asUint192Unchecked(encoded, offset);\\n    return (bytes24(ret), nextOffset);\\n  }\\n\\n  function asBytes24(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes24, uint) {\\n    (uint192 ret, uint nextOffset) = asUint192(encoded, offset);\\n    return (bytes24(ret), nextOffset);\\n  }\\n\\n  function asUint200Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint200 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 25)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint200(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint200 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint200Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes25Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes25, uint) {\\n    (uint200 ret, uint nextOffset) = asUint200Unchecked(encoded, offset);\\n    return (bytes25(ret), nextOffset);\\n  }\\n\\n  function asBytes25(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes25, uint) {\\n    (uint200 ret, uint nextOffset) = asUint200(encoded, offset);\\n    return (bytes25(ret), nextOffset);\\n  }\\n\\n  function asUint208Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint208 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 26)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint208(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint208 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint208Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes26Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes26, uint) {\\n    (uint208 ret, uint nextOffset) = asUint208Unchecked(encoded, offset);\\n    return (bytes26(ret), nextOffset);\\n  }\\n\\n  function asBytes26(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes26, uint) {\\n    (uint208 ret, uint nextOffset) = asUint208(encoded, offset);\\n    return (bytes26(ret), nextOffset);\\n  }\\n\\n  function asUint216Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint216 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 27)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint216(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint216 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint216Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes27Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes27, uint) {\\n    (uint216 ret, uint nextOffset) = asUint216Unchecked(encoded, offset);\\n    return (bytes27(ret), nextOffset);\\n  }\\n\\n  function asBytes27(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes27, uint) {\\n    (uint216 ret, uint nextOffset) = asUint216(encoded, offset);\\n    return (bytes27(ret), nextOffset);\\n  }\\n\\n  function asUint224Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint224 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 28)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint224(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint224 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint224Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes28Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes28, uint) {\\n    (uint224 ret, uint nextOffset) = asUint224Unchecked(encoded, offset);\\n    return (bytes28(ret), nextOffset);\\n  }\\n\\n  function asBytes28(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes28, uint) {\\n    (uint224 ret, uint nextOffset) = asUint224(encoded, offset);\\n    return (bytes28(ret), nextOffset);\\n  }\\n\\n  function asUint232Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint232 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 29)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint232(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint232 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint232Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes29Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes29, uint) {\\n    (uint232 ret, uint nextOffset) = asUint232Unchecked(encoded, offset);\\n    return (bytes29(ret), nextOffset);\\n  }\\n\\n  function asBytes29(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes29, uint) {\\n    (uint232 ret, uint nextOffset) = asUint232(encoded, offset);\\n    return (bytes29(ret), nextOffset);\\n  }\\n\\n  function asUint240Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint240 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 30)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint240(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint240 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint240Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes30Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes30, uint) {\\n    (uint240 ret, uint nextOffset) = asUint240Unchecked(encoded, offset);\\n    return (bytes30(ret), nextOffset);\\n  }\\n\\n  function asBytes30(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes30, uint) {\\n    (uint240 ret, uint nextOffset) = asUint240(encoded, offset);\\n    return (bytes30(ret), nextOffset);\\n  }\\n\\n  function asUint248Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint248 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 31)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint248(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint248 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint248Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes31Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes31, uint) {\\n    (uint248 ret, uint nextOffset) = asUint248Unchecked(encoded, offset);\\n    return (bytes31(ret), nextOffset);\\n  }\\n\\n  function asBytes31(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes31, uint) {\\n    (uint248 ret, uint nextOffset) = asUint248(encoded, offset);\\n    return (bytes31(ret), nextOffset);\\n  }\\n\\n  function asUint256Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint256 ret, uint nextOffset) {\\n    assembly (\\\"memory-safe\\\") {\\n      nextOffset := add(offset, 32)\\n      ret := mload(add(encoded, nextOffset))\\n    }\\n    return (ret, nextOffset);\\n  }\\n\\n  function asUint256(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (uint256 ret, uint nextOffset) {\\n    (ret, nextOffset) = asUint256Unchecked(encoded, offset);\\n    checkBound(nextOffset, encoded.length);\\n  }\\n\\n  function asBytes32Unchecked(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes32, uint) {\\n    (uint256 ret, uint nextOffset) = asUint256Unchecked(encoded, offset);\\n    return (bytes32(ret), nextOffset);\\n  }\\n\\n  function asBytes32(\\n    bytes memory encoded,\\n    uint offset\\n  ) internal pure returns (bytes32, uint) {\\n    (uint256 ret, uint nextOffset) = asUint256(encoded, offset);\\n    return (bytes32(ret), nextOffset);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/relayer/IDeliveryProviderTyped.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./TypedUnits.sol\\\";\\n\\ninterface IDeliveryProvider {\\n    \\n    /**\\n     * @notice This function returns \\n     *\\n     * 1) nativePriceQuote: the price of a delivery (by this delivery provider) to chain\\n     * 'targetChain', giving the user's contract 'receiverValue' target chain wei and performing the \\n     * relay with the execution parameters (e.g. the gas limit) specified in 'encodedExecutionParameters'\\n     * \\n     * 2) encodedExecutionInfo: information relating to how this delivery provider\\n     * will perform such a delivery (e.g. the gas limit, and the amount it will refund per gas unused)\\n     *\\n     * encodedExecutionParameters and encodedExecutionInfo both are encodings of versioned structs - \\n     * version EVM_V1 of ExecutionParameters specifies the gas limit,\\n     * and version EVM_V1 of ExecutionInfo specifies the gas limit and the amount that this delivery provider \\n     * will refund per unit of gas unused\\n     */\\n    function quoteDeliveryPrice(\\n        uint16 targetChain,\\n        TargetNative receiverValue,\\n        bytes memory encodedExecutionParams\\n    ) external view returns (LocalNative nativePriceQuote, bytes memory encodedExecutionInfo);\\n\\n    /**\\n     * @notice This function returns the amount of extra 'receiverValue' (msg.value on the target chain) \\n     * that will be sent to your contract, if you specify 'currentChainAmount' in the \\n     * 'paymentForExtraReceiverValue' field on 'send'\\n     */\\n    function quoteAssetConversion(\\n        uint16 targetChain,\\n        LocalNative currentChainAmount\\n    ) external view returns (TargetNative targetChainAmount);\\n\\n    /**\\n     * @notice This function should return a payable address on this (source) chain where all awards\\n     *     should be sent for the relay provider.\\n     */\\n    function getRewardAddress() external view returns (address payable rewardAddress);\\n\\n    /**\\n     * @notice This function determines whether a relay provider supports deliveries to a given chain\\n     *     or not.\\n     *\\n     * @param targetChain - The chain which is being delivered to.\\n     */\\n    function isChainSupported(uint16 targetChain) external view returns (bool supported);\\n\\n    /**\\n     * @notice This function determines whether a relay provider supports the given keyType.\\n     *      \\n     * Note: 0-127 are reserved for standardized keyTypes and 128-255 are allowed to be custom per DeliveryProvider\\n     *       Practically this means that 0-127 must mean the same thing for all DeliveryProviders,\\n     *       while x within 128-255 may have different meanings between DeliveryProviders \\n     *       (e.g. 130 for provider A means pyth price quotes while 130 for provider B means tweets, \\n     *       but 8 must mean the same for both)\\n     *\\n     * @param keyType - The keyType within MessageKey that specifies what the encodedKey within a MessageKey means\\n     */\\n    function isMessageKeyTypeSupported(uint8 keyType) external view returns (bool supported);\\n\\n    /**\\n     * @notice This function returns a bitmap encoding all the keyTypes this provider supports\\n     *      \\n     * Note: 0-127 are reserved for standardized keyTypes and 128-255 are allowed to be custom per DeliveryProvider\\n     *       Practically this means that 0-127 must mean the same thing for all DeliveryProviders,\\n     *       while x within 128-255 may have different meanings between DeliveryProviders \\n     *       (e.g. 130 for provider A means pyth price quotes while 130 for provider B means tweets, \\n     *       but 8 must mean the same for both)\\n     */\\n    function getSupportedKeys() external view returns (uint256 bitmap);\\n\\n    /**\\n     * @notice If a DeliveryProvider supports a given chain, this function should provide the contract\\n     *      address (in wormhole format) of the relay provider on that chain.\\n     *\\n     * @param targetChain - The chain which is being delivered to.\\n     */\\n    function getTargetChainAddress(uint16 targetChain)\\n        external\\n        view\\n        returns (bytes32 deliveryProviderAddress);\\n}\\n\"\r\n    },\r\n    \"contracts/relayer/libraries/RelayerInternalStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../../interfaces/relayer/TypedUnits.sol\\\";\\nimport \\\"../../interfaces/relayer/IWormholeRelayerTyped.sol\\\";\\n\\nstruct DeliveryInstruction {\\n    uint16 targetChain;\\n    bytes32 targetAddress;\\n    bytes payload;\\n    TargetNative requestedReceiverValue;\\n    TargetNative extraReceiverValue;\\n    bytes encodedExecutionInfo;\\n    uint16 refundChain;\\n    bytes32 refundAddress;\\n    bytes32 refundDeliveryProvider;\\n    bytes32 sourceDeliveryProvider;\\n    bytes32 senderAddress;\\n    MessageKey[] messageKeys;\\n}\\n\\n// Meant to hold all necessary values for `CoreRelayerDelivery::executeInstruction`\\n// Nothing more and nothing less.\\nstruct EvmDeliveryInstruction {\\n  uint16 sourceChain;\\n  bytes32 targetAddress;\\n  bytes payload;\\n  Gas gasLimit;\\n  TargetNative totalReceiverValue;\\n  GasPrice targetChainRefundPerGasUnused;\\n  bytes32 senderAddress;\\n  bytes32 deliveryHash;\\n  bytes[] signedVaas;\\n}\\n\\nstruct RedeliveryInstruction {\\n    VaaKey deliveryVaaKey;\\n    uint16 targetChain;\\n    TargetNative newRequestedReceiverValue;\\n    bytes newEncodedExecutionInfo;\\n    bytes32 newSourceDeliveryProvider;\\n    bytes32 newSenderAddress;\\n}\\n\\n/**\\n * @notice When a user requests a `resend()`, a `RedeliveryInstruction` is emitted by the\\n *     WormholeRelayer and in turn converted by the relay provider into an encoded (=serialized)\\n *     `DeliveryOverride` struct which is then passed to `delivery()` to override the parameters of\\n *     a previously failed delivery attempt.\\n *\\n * @custom:member newReceiverValue - must >= than the `receiverValue` specified in the original\\n *     `DeliveryInstruction`\\n * @custom:member newExecutionInfo - for EVM_V1, must contain a gasLimit and targetChainRefundPerGasUnused\\n * such that \\n * - gasLimit is >= the `gasLimit` specified in the `executionParameters`\\n *     of the original `DeliveryInstruction`\\n * - targetChainRefundPerGasUnused is >=  the `targetChainRefundPerGasUnused` specified in the original\\n *     `DeliveryInstruction`\\n * @custom:member redeliveryHash - the hash of the redelivery which is being performed\\n */\\nstruct DeliveryOverride {\\n    TargetNative newReceiverValue;\\n    bytes newExecutionInfo;\\n    bytes32 redeliveryHash;\\n}\\n\"\r\n    },\r\n    \"contracts/relayer/wormholeRelayer/WormholeRelayerSerde.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.19;\\n\\nimport {\\n    InvalidPayloadId,\\n    InvalidPayloadLength,\\n    InvalidVaaKeyType,\\n    TooManyMessageKeys,\\n    MessageKey,\\n    VAA_KEY_TYPE,\\n    VaaKey\\n} from \\\"../../interfaces/relayer/IWormholeRelayerTyped.sol\\\";\\nimport {\\n    DeliveryOverride,\\n    DeliveryInstruction,\\n    RedeliveryInstruction\\n} from \\\"../../relayer/libraries/RelayerInternalStructs.sol\\\";\\nimport {BytesParsing} from \\\"../../relayer/libraries/BytesParsing.sol\\\";\\nimport \\\"../../interfaces/relayer/TypedUnits.sol\\\";\\n\\nlibrary WormholeRelayerSerde {\\n    using BytesParsing for bytes;\\n    using WeiLib for Wei;\\n    using GasLib for Gas;\\n\\n    //The slightly subtle difference between `PAYLOAD_ID`s and `VERSION`s is that payload ids carry\\n    //  both type information _and_ version information, while `VERSION`s only carry the latter.\\n    //That is, when deserialing a \\\"version struct\\\" we already know the expected type, but since we\\n    //  publish both Delivery _and_ Redelivery instructions as serialized messages, we need a robust\\n    //  way to distinguish both their type and their version during deserialization.\\n    uint8 private constant VERSION_VAAKEY = 1;\\n    uint8 private constant VERSION_DELIVERY_OVERRIDE = 1;\\n    uint8 private constant PAYLOAD_ID_DELIVERY_INSTRUCTION = 1;\\n    uint8 private constant PAYLOAD_ID_REDELIVERY_INSTRUCTION = 2;\\n\\n    uint256 constant VAA_KEY_TYPE_LENGTH = 2 + 32 + 8;\\n\\n    // ---------------------- \\\"public\\\" (i.e implicitly internal) encode/decode -----------------------\\n\\n    //TODO GAS OPTIMIZATION: All the recursive abi.encodePacked calls in here are _insanely_ gas\\n    //    inefficient (unless the optimizer is smart enough to just concatenate them tail-recursion\\n    //    style which seems highly unlikely)\\n\\n    function encode(DeliveryInstruction memory strct)\\n        internal\\n        pure\\n        returns (bytes memory encoded)\\n    {\\n        encoded = abi.encodePacked(\\n            PAYLOAD_ID_DELIVERY_INSTRUCTION,\\n            strct.targetChain,\\n            strct.targetAddress,\\n            encodeBytes(strct.payload),\\n            strct.requestedReceiverValue,\\n            strct.extraReceiverValue\\n        );\\n        encoded = abi.encodePacked(\\n            encoded,\\n            encodeBytes(strct.encodedExecutionInfo),\\n            strct.refundChain,\\n            strct.refundAddress,\\n            strct.refundDeliveryProvider,\\n            strct.sourceDeliveryProvider,\\n            strct.senderAddress,\\n            encodeMessageKeyArray(strct.messageKeys)\\n        );\\n    }\\n\\n    function decodeDeliveryInstruction(bytes memory encoded)\\n        internal\\n        pure\\n        returns (DeliveryInstruction memory strct)\\n    {\\n        uint256 offset = checkUint8(encoded, 0, PAYLOAD_ID_DELIVERY_INSTRUCTION);\\n\\n        uint256 requestedReceiverValue;\\n        uint256 extraReceiverValue;\\n\\n        (strct.targetChain, offset) = encoded.asUint16Unchecked(offset);\\n        (strct.targetAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        (strct.payload, offset) = decodeBytes(encoded, offset);\\n        (requestedReceiverValue, offset) = encoded.asUint256Unchecked(offset);\\n        (extraReceiverValue, offset) = encoded.asUint256Unchecked(offset);\\n        (strct.encodedExecutionInfo, offset) = decodeBytes(encoded, offset);\\n        (strct.refundChain, offset) = encoded.asUint16Unchecked(offset);\\n        (strct.refundAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        (strct.refundDeliveryProvider, offset) = encoded.asBytes32Unchecked(offset);\\n        (strct.sourceDeliveryProvider, offset) = encoded.asBytes32Unchecked(offset);\\n        (strct.senderAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        (strct.messageKeys, offset) = decodeMessageKeyArray(encoded, offset);\\n\\n        strct.requestedReceiverValue = TargetNative.wrap(requestedReceiverValue);\\n        strct.extraReceiverValue = TargetNative.wrap(extraReceiverValue);\\n\\n        checkLength(encoded, offset);\\n    }\\n\\n    function encode(RedeliveryInstruction memory strct)\\n        internal\\n        pure\\n        returns (bytes memory encoded)\\n    {\\n        bytes memory vaaKey = abi.encodePacked(VAA_KEY_TYPE, encodeVaaKey(strct.deliveryVaaKey));\\n        encoded = abi.encodePacked(\\n            PAYLOAD_ID_REDELIVERY_INSTRUCTION,\\n            vaaKey,\\n            strct.targetChain,\\n            strct.newRequestedReceiverValue,\\n            encodeBytes(strct.newEncodedExecutionInfo),\\n            strct.newSourceDeliveryProvider,\\n            strct.newSenderAddress\\n        );\\n    }\\n\\n    function decodeRedeliveryInstruction(bytes memory encoded)\\n        internal\\n        pure\\n        returns (RedeliveryInstruction memory strct)\\n    {\\n        uint256 offset = checkUint8(encoded, 0, PAYLOAD_ID_REDELIVERY_INSTRUCTION);\\n\\n        uint256 newRequestedReceiverValue;\\n        offset = checkUint8(encoded, offset, VAA_KEY_TYPE);\\n        (strct.deliveryVaaKey, offset) = decodeVaaKey(encoded, offset);\\n        (strct.targetChain, offset) = encoded.asUint16Unchecked(offset);\\n        (newRequestedReceiverValue, offset) = encoded.asUint256Unchecked(offset);\\n        (strct.newEncodedExecutionInfo, offset) = decodeBytes(encoded, offset);\\n        (strct.newSourceDeliveryProvider, offset) = encoded.asBytes32Unchecked(offset);\\n        (strct.newSenderAddress, offset) = encoded.asBytes32Unchecked(offset);\\n\\n        strct.newRequestedReceiverValue = TargetNative.wrap(newRequestedReceiverValue);\\n\\n        checkLength(encoded, offset);\\n    }\\n\\n    function encode(DeliveryOverride memory strct) internal pure returns (bytes memory encoded) {\\n        encoded = abi.encodePacked(\\n            VERSION_DELIVERY_OVERRIDE,\\n            strct.newReceiverValue,\\n            encodeBytes(strct.newExecutionInfo),\\n            strct.redeliveryHash\\n        );\\n    }\\n\\n    function decodeDeliveryOverride(bytes memory encoded)\\n        internal\\n        pure\\n        returns (DeliveryOverride memory strct)\\n    {\\n        uint256 offset = checkUint8(encoded, 0, VERSION_DELIVERY_OVERRIDE);\\n\\n        uint256 receiverValue;\\n\\n        (receiverValue, offset) = encoded.asUint256Unchecked(offset);\\n        (strct.newExecutionInfo, offset) = decodeBytes(encoded, offset);\\n        (strct.redeliveryHash, offset) = encoded.asBytes32Unchecked(offset);\\n\\n        strct.newReceiverValue = TargetNative.wrap(receiverValue);\\n\\n        checkLength(encoded, offset);\\n    }\\n\\n    function vaaKeyArrayToMessageKeyArray(VaaKey[] memory vaaKeys)\\n        internal\\n        pure\\n        returns (MessageKey[] memory msgKeys)\\n    {\\n        msgKeys = new MessageKey[](vaaKeys.length);\\n        uint256 len = vaaKeys.length;\\n        for (uint256 i = 0; i < len;) {\\n            msgKeys[i] = MessageKey(VAA_KEY_TYPE, encodeVaaKey(vaaKeys[i]));\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function encodeMessageKey(\\n        MessageKey memory msgKey\\n    ) internal pure returns (bytes memory encoded) {\\n        if (msgKey.keyType == VAA_KEY_TYPE) {\\n            // known length\\n            encoded = abi.encodePacked(msgKey.keyType, msgKey.encodedKey);\\n        } else {\\n            encoded = abi.encodePacked(msgKey.keyType, encodeBytes(msgKey.encodedKey));\\n        }\\n    }\\n\\n    function decodeMessageKey(\\n        bytes memory encoded,\\n        uint256 startOffset\\n    ) internal pure returns (MessageKey memory msgKey, uint256 offset) {\\n        (msgKey.keyType, offset) = encoded.asUint8Unchecked(startOffset);\\n        if (msgKey.keyType == VAA_KEY_TYPE) {\\n            (msgKey.encodedKey, offset) = encoded.sliceUnchecked(offset, VAA_KEY_TYPE_LENGTH);\\n        } else {\\n            (msgKey.encodedKey, offset) = decodeBytes(encoded, offset);\\n        }\\n    }\\n\\n    function encodeVaaKey(VaaKey memory vaaKey) internal pure returns (bytes memory encoded) {\\n        encoded = abi.encodePacked(vaaKey.chainId, vaaKey.emitterAddress, vaaKey.sequence);\\n    }\\n\\n    function decodeVaaKey(\\n        bytes memory encoded,\\n        uint256 startOffset\\n    ) internal pure returns (VaaKey memory vaaKey, uint256 offset) {\\n        offset = startOffset;\\n        (vaaKey.chainId, offset) = encoded.asUint16Unchecked(offset);\\n        (vaaKey.emitterAddress, offset) = encoded.asBytes32Unchecked(offset);\\n        (vaaKey.sequence, offset) = encoded.asUint64Unchecked(offset);\\n    }\\n\\n    function encodeMessageKeyArray(MessageKey[] memory msgKeys)\\n        internal\\n        pure\\n        returns (bytes memory encoded)\\n    {\\n        uint256 len = msgKeys.length;\\n        if (len > type(uint8).max) {\\n            revert TooManyMessageKeys(len);\\n        }\\n        encoded = abi.encodePacked(uint8(msgKeys.length));\\n        for (uint256 i = 0; i < len;) {\\n            encoded = abi.encodePacked(encoded, encodeMessageKey(msgKeys[i]));\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function decodeMessageKeyArray(\\n        bytes memory encoded,\\n        uint256 startOffset\\n    ) internal pure returns (MessageKey[] memory msgKeys, uint256 offset) {\\n        uint8 msgKeysLength;\\n        (msgKeysLength, offset) = encoded.asUint8Unchecked(startOffset);\\n        msgKeys = new MessageKey[](msgKeysLength);\\n        for (uint256 i = 0; i < msgKeysLength;) {\\n            (msgKeys[i], offset) = decodeMessageKey(encoded, offset);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    // ------------------------------------------ private --------------------------------------------\\n\\n    function encodeBytes(bytes memory payload) private pure returns (bytes memory encoded) {\\n        //casting payload.length to uint32 is safe because you'll be hard-pressed to allocate 4 GB of\\n        //  EVM memory in a single transaction\\n        encoded = abi.encodePacked(uint32(payload.length), payload);\\n    }\\n\\n    function decodeBytes(\\n        bytes memory encoded,\\n        uint256 startOffset\\n    ) private pure returns (bytes memory payload, uint256 offset) {\\n        uint32 payloadLength;\\n        (payloadLength, offset) = encoded.asUint32Unchecked(startOffset);\\n        (payload, offset) = encoded.sliceUnchecked(offset, payloadLength);\\n    }\\n\\n    function checkUint8(\\n        bytes memory encoded,\\n        uint256 startOffset,\\n        uint8 expectedPayloadId\\n    ) private pure returns (uint256 offset) {\\n        uint8 parsedPayloadId;\\n        (parsedPayloadId, offset) = encoded.asUint8Unchecked(startOffset);\\n        if (parsedPayloadId != expectedPayloadId) {\\n            revert InvalidPayloadId(parsedPayloadId, expectedPayloadId);\\n        }\\n    }\\n\\n    function checkLength(bytes memory encoded, uint256 expected) private pure {\\n        if (encoded.length != expected) {\\n            revert InvalidPayloadLength(encoded.length, expected);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/relayer/libraries/ExecutionParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../../interfaces/relayer/TypedUnits.sol\\\";\\nimport {BytesParsing} from \\\"../../relayer/libraries/BytesParsing.sol\\\";\\n\\nerror UnexpectedExecutionParamsVersion(uint8 version, uint8 expectedVersion);\\nerror UnsupportedExecutionParamsVersion(uint8 version);\\nerror TargetChainAndExecutionParamsVersionMismatch(uint16 targetChain, uint8 version);\\nerror UnexpectedExecutionInfoVersion(uint8 version, uint8 expectedVersion);\\nerror UnsupportedExecutionInfoVersion(uint8 version);\\nerror TargetChainAndExecutionInfoVersionMismatch(uint16 targetChain, uint8 version);\\nerror VersionMismatchOverride(uint8 instructionVersion, uint8 overrideVersion);\\n\\nusing BytesParsing for bytes;\\n\\nenum ExecutionParamsVersion {EVM_V1}\\n\\nstruct EvmExecutionParamsV1 {\\n    Gas gasLimit;\\n}\\n\\nenum ExecutionInfoVersion {EVM_V1}\\n\\nstruct EvmExecutionInfoV1 {\\n    Gas gasLimit;\\n    GasPrice targetChainRefundPerGasUnused;\\n}\\n\\nfunction decodeExecutionParamsVersion(bytes memory data)\\n    pure\\n    returns (ExecutionParamsVersion version)\\n{\\n    (version) = abi.decode(data, (ExecutionParamsVersion));\\n}\\n\\nfunction decodeExecutionInfoVersion(bytes memory data)\\n    pure\\n    returns (ExecutionInfoVersion version)\\n{\\n    (version) = abi.decode(data, (ExecutionInfoVersion));\\n}\\n\\nfunction encodeEvmExecutionParamsV1(EvmExecutionParamsV1 memory executionParams)\\n    pure\\n    returns (bytes memory)\\n{\\n    return abi.encode(uint8(ExecutionParamsVersion.EVM_V1), executionParams.gasLimit);\\n}\\n\\nfunction decodeEvmExecutionParamsV1(bytes memory data)\\n    pure\\n    returns (EvmExecutionParamsV1 memory executionParams)\\n{\\n    uint8 version;\\n    (version, executionParams.gasLimit) = abi.decode(data, (uint8, Gas));\\n\\n    if (version != uint8(ExecutionParamsVersion.EVM_V1)) {\\n        revert UnexpectedExecutionParamsVersion(version, uint8(ExecutionParamsVersion.EVM_V1));\\n    }\\n}\\n\\nfunction encodeEvmExecutionInfoV1(EvmExecutionInfoV1 memory executionInfo)\\n    pure\\n    returns (bytes memory)\\n{\\n    return abi.encode(\\n        uint8(ExecutionInfoVersion.EVM_V1),\\n        executionInfo.gasLimit,\\n        executionInfo.targetChainRefundPerGasUnused\\n    );\\n}\\n\\nfunction decodeEvmExecutionInfoV1(bytes memory data)\\n    pure\\n    returns (EvmExecutionInfoV1 memory executionInfo)\\n{\\n    uint8 version;\\n    (version, executionInfo.gasLimit, executionInfo.targetChainRefundPerGasUnused) =\\n        abi.decode(data, (uint8, Gas, GasPrice));\\n\\n    if (version != uint8(ExecutionInfoVersion.EVM_V1)) {\\n        revert UnexpectedExecutionInfoVersion(version, uint8(ExecutionInfoVersion.EVM_V1));\\n    }\\n}\\n\\nfunction getEmptyEvmExecutionParamsV1()\\n    pure\\n    returns (EvmExecutionParamsV1 memory executionParams)\\n{\\n    executionParams.gasLimit = Gas.wrap(uint256(0));\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/relayer/IWormholeReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for a contract which can receive Wormhole messages.\\n */\\ninterface IWormholeReceiver {\\n    /**\\n     * @notice When a `send` is performed with this contract as the target, this function will be\\n     *     invoked by the WormholeRelayer contract\\n     *\\n     * NOTE: This function should be restricted such that only the Wormhole Relayer contract can call it.\\n     *\\n     * We also recommend that this function:\\n     *   - Stores all received `deliveryHash`s in a mapping `(bytes32 => bool)`, and\\n     *       on every call, checks that deliveryHash has not already been stored in the\\n     *       map (This is to prevent other users maliciously trying to relay the same message)\\n     *   - Checks that `sourceChain` and `sourceAddress` are indeed who\\n     *       you expect to have requested the calling of `send` on the source chain\\n     *\\n     * The invocation of this function corresponding to the `send` request will have msg.value equal\\n     *   to the receiverValue specified in the send request.\\n     *\\n     * If the invocation of this function reverts or exceeds the gas limit \\n     *   specified by the send requester, this delivery will result in a `ReceiverFailure`.\\n     *\\n     * @param payload - an arbitrary message which was included in the delivery by the\\n     *     requester.\\n     * @param additionalVaas - Additional VAAs which were requested to be included in this delivery.\\n     *   They are guaranteed to all be included and in the same order as was specified in the\\n     *     delivery request.\\n     * @param sourceAddress - the (wormhole format) address on the sending chain which requested\\n     *     this delivery.\\n     * @param sourceChain - the wormhole chain ID where this delivery was requested.\\n     * @param deliveryHash - the VAA hash of the deliveryVAA.\\n     *\\n     * NOTE: These signedVaas are NOT verified by the Wormhole core contract prior to being provided\\n     *     to this call. Always make sure `parseAndVerify()` is called on the Wormhole core contract\\n     *     before trusting the content of a raw VAA, otherwise the VAA may be invalid or malicious.\\n     */\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory additionalVaas,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@solidity-parser/=node_modules/@solidity-parser/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"truffle/=node_modules/truffle/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wormhole\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"registeredWormholeRelayerContract\",\"type\":\"bytes32\"}],\"name\":\"ChainAlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"failure\",\"type\":\"bytes\"}],\"name\":\"ContractUpgradeFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeliveryProviderCannotReceivePayment\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"keyType\",\"type\":\"uint8\"}],\"name\":\"DeliveryProviderDoesNotSupportMessageKeyType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"}],\"name\":\"DeliveryProviderDoesNotSupportTargetChain\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"GovernanceActionAlreadyConsumed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"LocalNative\",\"name\":\"msgValue\",\"type\":\"uint256\"},{\"internalType\":\"LocalNative\",\"name\":\"minimum\",\"type\":\"uint256\"}],\"name\":\"InsufficientRelayerFunds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"defaultDeliveryProvider\",\"type\":\"bytes32\"}],\"name\":\"InvalidDefaultDeliveryProvider\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"InvalidDeliveryVaa\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"emitter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"registered\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"}],\"name\":\"InvalidEmitter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFork\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"parsed\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"expected\",\"type\":\"uint16\"}],\"name\":\"InvalidGovernanceChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parsed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expected\",\"type\":\"bytes32\"}],\"name\":\"InvalidGovernanceContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"InvalidGovernanceVM\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"LocalNative\",\"name\":\"msgValue\",\"type\":\"uint256\"},{\"internalType\":\"LocalNative\",\"name\":\"totalFee\",\"type\":\"uint256\"}],\"name\":\"InvalidMsgValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOverrideGasLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOverrideReceiverValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"parsed\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"expected\",\"type\":\"uint8\"}],\"name\":\"InvalidPayloadAction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"parsed\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"expected\",\"type\":\"uint16\"}],\"name\":\"InvalidPayloadChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"parsed\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"expected\",\"type\":\"uint8\"}],\"name\":\"InvalidPayloadId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"InvalidPayloadLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parsed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expected\",\"type\":\"bytes32\"}],\"name\":\"InvalidPayloadModule\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keys\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaas\",\"type\":\"uint256\"}],\"name\":\"MessageKeysLengthDoesNotMatchMessagesLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"NotAnEvmAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lockedBy\",\"type\":\"address\"}],\"name\":\"ReentrantDelivery\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"}],\"name\":\"TargetChainIsNotThisChain\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numMessageKeys\",\"type\":\"uint256\"}],\"name\":\"TooManyMessageKeys\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"expectedVersion\",\"type\":\"uint8\"}],\"name\":\"UnexpectedExecutionInfoVersion\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"VaaKeysDoNotMatchVaas\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"instructionVersion\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"overrideVersion\",\"type\":\"uint8\"}],\"name\":\"VersionMismatchOverride\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipientContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"sourceChain\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"deliveryVaaHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enum IWormholeRelayerDelivery.DeliveryStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"Gas\",\"name\":\"gasUsed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IWormholeRelayerDelivery.RefundStatus\",\"name\":\"refundStatus\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"additionalStatusInfo\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"overridesInfo\",\"type\":\"bytes\"}],\"name\":\"Delivery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"LocalNative\",\"name\":\"deliveryQuote\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"LocalNative\",\"name\":\"paymentForExtraReceiverValue\",\"type\":\"uint256\"}],\"name\":\"SendEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"checkAndExecuteUpgradeMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"encodedVMs\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes\",\"name\":\"encodedDeliveryVAA\",\"type\":\"bytes\"},{\"internalType\":\"address payable\",\"name\":\"relayerRefundAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"deliveryOverrides\",\"type\":\"bytes\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"deliveryHash\",\"type\":\"bytes32\"}],\"name\":\"deliveryAttempted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"attempted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"deliveryHash\",\"type\":\"bytes32\"}],\"name\":\"deliveryFailureBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"deliveryHash\",\"type\":\"bytes32\"}],\"name\":\"deliverySuccessBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"targetAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"LocalNative\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"encodedExecutionParameters\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"refundChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"refundAddress\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"deliveryProviderAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"emitterAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"internalType\":\"struct VaaKey[]\",\"name\":\"vaaKeys\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"consistencyLevel\",\"type\":\"uint8\"}],\"name\":\"forward\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"forwardPayloadToEvm\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"LocalNative\",\"name\":\"paymentForExtraReceiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"refundChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deliveryProviderAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"emitterAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"internalType\":\"struct VaaKey[]\",\"name\":\"vaaKeys\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"consistencyLevel\",\"type\":\"uint8\"}],\"name\":\"forwardToEvm\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"emitterAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"internalType\":\"struct VaaKey[]\",\"name\":\"vaaKeys\",\"type\":\"tuple[]\"}],\"name\":\"forwardVaasToEvm\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultDeliveryProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deliveryProvider\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"}],\"name\":\"getRegisteredWormholeRelayerContract\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"defaultDeliveryProvider\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"encodedExecutionParameters\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"deliveryProviderAddress\",\"type\":\"address\"}],\"name\":\"quoteDeliveryPrice\",\"outputs\":[{\"internalType\":\"LocalNative\",\"name\":\"nativePriceQuote\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"encodedExecutionInfo\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"deliveryProviderAddress\",\"type\":\"address\"}],\"name\":\"quoteEVMDeliveryPrice\",\"outputs\":[{\"internalType\":\"LocalNative\",\"name\":\"nativePriceQuote\",\"type\":\"uint256\"},{\"internalType\":\"GasPrice\",\"name\":\"targetChainRefundPerGasUnused\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"quoteEVMDeliveryPrice\",\"outputs\":[{\"internalType\":\"LocalNative\",\"name\":\"nativePriceQuote\",\"type\":\"uint256\"},{\"internalType\":\"GasPrice\",\"name\":\"targetChainRefundPerGasUnused\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"LocalNative\",\"name\":\"currentChainAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"deliveryProviderAddress\",\"type\":\"address\"}],\"name\":\"quoteNativeForChain\",\"outputs\":[{\"internalType\":\"TargetNative\",\"name\":\"targetChainAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedVm\",\"type\":\"bytes\"}],\"name\":\"registerWormholeRelayerContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"emitterAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"internalType\":\"struct VaaKey\",\"name\":\"deliveryVaaKey\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"TargetNative\",\"name\":\"newReceiverValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"newEncodedExecutionParameters\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"newDeliveryProviderAddress\",\"type\":\"address\"}],\"name\":\"resend\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"emitterAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"internalType\":\"struct VaaKey\",\"name\":\"deliveryVaaKey\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"TargetNative\",\"name\":\"newReceiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"newGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newDeliveryProviderAddress\",\"type\":\"address\"}],\"name\":\"resendToEvm\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"targetAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"LocalNative\",\"name\":\"paymentForExtraReceiverValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"encodedExecutionParameters\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"refundChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"refundAddress\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"deliveryProviderAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"emitterAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"internalType\":\"struct VaaKey[]\",\"name\":\"vaaKeys\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"consistencyLevel\",\"type\":\"uint8\"}],\"name\":\"send\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"targetAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"LocalNative\",\"name\":\"paymentForExtraReceiverValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"encodedExecutionParameters\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"refundChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"refundAddress\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"deliveryProviderAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"keyType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"encodedKey\",\"type\":\"bytes\"}],\"internalType\":\"struct MessageKey[]\",\"name\":\"messageKeys\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"consistencyLevel\",\"type\":\"uint8\"}],\"name\":\"send\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"refundChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"}],\"name\":\"sendPayloadToEvm\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"sendPayloadToEvm\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"LocalNative\",\"name\":\"paymentForExtraReceiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"refundChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deliveryProviderAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"emitterAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"internalType\":\"struct VaaKey[]\",\"name\":\"vaaKeys\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"consistencyLevel\",\"type\":\"uint8\"}],\"name\":\"sendToEvm\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"LocalNative\",\"name\":\"paymentForExtraReceiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"refundChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deliveryProviderAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"keyType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"encodedKey\",\"type\":\"bytes\"}],\"internalType\":\"struct MessageKey[]\",\"name\":\"messageKeys\",\"type\":\"tuple[]\"},{\"internalType\":\"uint8\",\"name\":\"consistencyLevel\",\"type\":\"uint8\"}],\"name\":\"sendToEvm\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"emitterAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"internalType\":\"struct VaaKey[]\",\"name\":\"vaaKeys\",\"type\":\"tuple[]\"}],\"name\":\"sendVaasToEvm\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"TargetNative\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"Gas\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"emitterAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"internalType\":\"struct VaaKey[]\",\"name\":\"vaaKeys\",\"type\":\"tuple[]\"},{\"internalType\":\"uint16\",\"name\":\"refundChain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"}],\"name\":\"sendVaasToEvm\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedVm\",\"type\":\"bytes\"}],\"name\":\"setDefaultDeliveryProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedVm\",\"type\":\"bytes\"}],\"name\":\"submitContractUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WormholeRelayer", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a4b5a56256163f07b2c80a7ca55abe66c4ec4d7", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}