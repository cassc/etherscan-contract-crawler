{"SourceCode": "/**\r\n *Submitted for verification at polygonscan.com on 2023-01-07\r\n*/\r\n\r\n/**\r\n *Submitted for verification at polygonscan.com on 2022-12-13\r\n*/\r\n\r\n/**\r\n *Submitted for verification at polygonscan.com on 2022-11-22\r\n*/\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n\r\n/**\r\n *Submitted for verification at polygonscan.com on 2022-11-17\r\n*/\r\n\r\n/**\r\n *Submitted for verification at polygonscan.com on 2022-11-12\r\n*/\r\n\r\n// File: contracts/IERC20.sol\r\n\r\n\r\npragma solidity >=0.4.22 <0.8.19;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n// File: contracts/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/ADM.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract ADMGLOBAL {\r\n\r\n\r\n    using SafeMath for uint256; \r\n    IERC20 public usdt;\r\n    uint256 private constant baseDivider = 10000;\r\n    uint256[2] private feePercents = [180,20]; \r\n    uint256 private constant minDeposit = 50e6;\r\n    uint256 private constant maxDeposit = 2000e6;\r\n    uint256 private constant timeStep = 1 days;\r\n    uint256 private constant dayPerCycle = 7 days; \r\n    uint256 private constant dayRewardPercents = 150;\r\n    uint256 private constant maxAddFreeze = 30 days;\r\n    uint256 private constant referDepth = 20;\r\n    bool private freezeStaticReward;\r\n    bool private freezeDynamicReward;\r\n    \r\n    uint256 private constant directPercents = 250;\r\n    uint256[2] private level2Percents = [50, 100];\r\n    uint256[2] private level4Percents = [ 150, 50];\r\n    uint256[15] private level5Percents = [50, 50, 50, 50, 50, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25];\r\n\r\n    uint256 private constant luckPoolPercents = 50;\r\n    uint256 private constant stbPoolPercents = 30;\r\n    uint256 private constant topPoolPercents = 20;\r\n     \r\n    uint256[3] private balReached = [100e10, 500e10, 1000e10];\r\n    uint256[3] private balFreezeStatic = [70e10, 300e10, 500e10];\r\n    uint256[3] private balFreezeDynamic = [40e10, 150e10, 200e10];\r\n    uint256[3] private balRecover = [150e10, 500e10, 1000e10];\r\n\r\n    mapping(uint256=>bool) public balStatus; // bal=>status\r\n\r\n    address[2] public feeReceivers;\r\n    address public CSF_wallet;\r\n\r\n    address public defaultRefer;\r\n    uint256 public startTime;\r\n    uint256 public lastDistribute;\r\n    uint256 public totalUser; \r\n    uint256 public luckPool;\r\n    uint256 public stbPool;\r\n    uint256 public topPool;\r\n\r\n    mapping(uint256=>address[]) public dayLuckUsers;\r\n    mapping(uint256=>uint256[]) public dayLuckUsersDeposit;\r\n    mapping(uint256=>address[3]) public dayTopUsers;\r\n    mapping(address=>bool) private hasUpdateDownline;\r\n\r\n    address[] public level5Users;\r\n\r\n    struct OrderInfo {\r\n        uint256 amount; \r\n        uint256 start;\r\n        uint256 unfreeze; \r\n        bool isUnfreezed;\r\n    }\r\n\r\n    mapping(address => OrderInfo[]) public orderInfos;\r\n\r\n    address[] public depositors;\r\n\r\n    struct UserInfo {\r\n        address referrer;\r\n        uint256 start;\r\n        uint256 level; // 0, 1, 2, 3, 4, 5\r\n        uint256 maxDeposit;\r\n        uint256 totalDeposit;\r\n        uint256 teamNum;\r\n        uint256 maxDirectDeposit;\r\n        uint256 teamTotalDeposit;\r\n        uint256 totalFreezed;\r\n        uint256 totalRevenue;\r\n    }\r\n\r\n    mapping(address=>UserInfo) public userInfo;\r\n    mapping(uint256 => mapping(address => uint256)) public userLayer1DayDeposit; // day=>user=>amount\r\n    mapping(address => mapping(uint256 => address[])) public teamUsers;\r\n\r\n    struct RewardInfo{\r\n        uint256 capitals;\r\n        uint256 statics;\r\n        uint256 directs;\r\n        uint256 level2Freezed;\r\n        uint256 level2Released;\r\n        uint256 level4Freezed;\r\n        uint256 level4Released;\r\n        uint256 level5Left;\r\n        uint256 level5Freezed;\r\n        uint256 level5Released;\r\n        uint256 contributor;\r\n        uint256 luck;\r\n        uint256 top;\r\n    }\r\n\r\n    mapping(address=>RewardInfo) public rewardInfo;\r\n    \r\n    bool public isFreezeReward;\r\n\r\n    event Register(address user, address referral);\r\n    event Deposit(address user, uint256 amount);\r\n    event Withdraw(address user, uint256 withdrawable);\r\n\r\n    constructor(address _usdtAddr, address _defaultRefer, address _CSFFundWallet, address[2] memory _feeReceivers)  {\r\n        usdt = IERC20(_usdtAddr);\r\n        feeReceivers = _feeReceivers;\r\n        startTime = block.timestamp;\r\n        lastDistribute = block.timestamp;\r\n        defaultRefer = _defaultRefer;\r\n        CSF_wallet = _CSFFundWallet;\r\n    }\r\n\r\n    function register(address _referral) external {\r\n        require(userInfo[_referral].totalDeposit >= minDeposit || _referral == defaultRefer, \"invalid refer\");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.referrer == address(0), \"referrer bonded\");\r\n        user.referrer = _referral;\r\n        user.start = block.timestamp;\r\n        totalUser = totalUser.add(1);\r\n        emit Register(msg.sender, _referral);\r\n    }\r\n\r\n    function deposit(uint256 _amount) external {\r\n        usdt.transferFrom(msg.sender, address(this), _amount);\r\n        _deposit(msg.sender, _amount);\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n \r\n    function distributePoolRewards() public {\r\n        if(block.timestamp > lastDistribute.add(timeStep)){\r\n            uint256 dayNow = getCurDay();\r\n            _distributeStbPool();\r\n\r\n            _distributeLuckPool(dayNow);\r\n\r\n            _distributeTopPool(dayNow);\r\n            lastDistribute = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function withdraw() external {\r\n        distributePoolRewards();\r\n        uint256 staticReward = _calCurStaticRewards(msg.sender);\r\n        uint256 withdrawable = staticReward;\r\n        uint256 dynamicReward  = _calCurDynamicRewards(msg.sender);\r\n        withdrawable = withdrawable.add(dynamicReward);\r\n\r\n      \r\n        //subtract the 10%\r\n        uint256 _withdrawFee = withdrawable.mul(1000).div(baseDivider);\r\n        //subtract the 10% fee\r\n        withdrawable = withdrawable.sub(_withdrawFee);\r\n\r\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n        \r\n        \r\n        withdrawable = withdrawable.add(userRewards.capitals);\r\n      \r\n        if(withdrawable>=10e6)\r\n        {\r\n\r\n        userRewards.statics = 0;\r\n        userRewards.directs = 0;\r\n        userRewards.level2Released = 0;\r\n        userRewards.level4Released = 0;\r\n        userRewards.level5Released = 0;\r\n        userRewards.luck = 0;\r\n        userRewards.contributor= 0;\r\n        userRewards.top = 0;\r\n        userRewards.capitals = 0;\r\n\r\n            usdt.transfer(msg.sender, withdrawable);\r\n            usdt.transfer(CSF_wallet, _withdrawFee);\r\n            uint256 bal = usdt.balanceOf(address(this));\r\n            _setFreezeReward(bal);\r\n         }\r\n\r\n         emit Withdraw(msg.sender, withdrawable);\r\n    }\r\n\r\n    function getCurDay() public view returns(uint256) {\r\n        return (block.timestamp.sub(startTime)).div(timeStep);\r\n    }\r\n\r\n    function getDayLuckLength(uint256 _day) external view returns(uint256) {\r\n        return dayLuckUsers[_day].length;\r\n    }\r\n\r\n    function getTeamUsersLength(address _user, uint256 _layer) external view returns(uint256) {\r\n        return teamUsers[_user][_layer].length;\r\n    }\r\n\r\n    function getOrderLength(address _user) external view returns(uint256) {\r\n        return orderInfos[_user].length;\r\n    }\r\n\r\n    function getDepositorsLength() external view returns(uint256) {\r\n        return depositors.length;\r\n    }\r\n\r\n    function getMaxFreezing(address _user) public view returns(uint256) {\r\n        uint256 maxFreezing;\r\n        for(uint256 i = orderInfos[_user].length; i > 0; i--){\r\n            OrderInfo storage order = orderInfos[_user][i - 1];\r\n            if(order.unfreeze > block.timestamp){\r\n                if(order.amount > maxFreezing){\r\n                    maxFreezing = order.amount;\r\n                }\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n        return maxFreezing;\r\n    }\r\n\r\n    function getTeamDeposit(address _user) public view returns(uint256, uint256, uint256){\r\n        uint256 totalTeam;\r\n        uint256 maxTeam;\r\n        uint256 otherTeam;\r\n        \r\n        for(uint256 i = 0; i < teamUsers[_user][0].length; i++){\r\n            uint256 userTotalTeam = userInfo[teamUsers[_user][0][i]].teamTotalDeposit.add(userInfo[teamUsers[_user][0][i]].totalDeposit);\r\n            totalTeam = totalTeam.add(userTotalTeam);\r\n            if(userTotalTeam > maxTeam){\r\n                maxTeam = userTotalTeam;\r\n            }\r\n        }\r\n        otherTeam = totalTeam.sub(maxTeam);\r\n        return(maxTeam, otherTeam, totalTeam);\r\n    }\r\n\r\n    function getTeamDepositCount(address _user) public view returns(uint256, uint256, uint256){\r\n        uint256 totalTeam;\r\n        uint256 maxTeam;\r\n        uint256 otherTeam;\r\n        \r\n        for(uint256 i = 0; i < teamUsers[_user][0].length; i++){\r\n            uint256 userTotalTeam = userInfo[teamUsers[_user][0][i]].teamNum + 1;\r\n            totalTeam = totalTeam.add(userTotalTeam);\r\n            if(userTotalTeam > maxTeam){\r\n                maxTeam = userTotalTeam;\r\n            }\r\n        }\r\n        otherTeam = totalTeam.sub(maxTeam);\r\n        return(maxTeam, otherTeam, totalTeam);\r\n    }\r\n \r\n\r\n    function _calCurStaticRewards(address _user) private view returns(uint256) {\r\n        RewardInfo storage userRewards = rewardInfo[_user];\r\n        uint256 totalRewards = userRewards.statics;\r\n        uint256 withdrawable = totalRewards; //ADM\r\n        return withdrawable;\r\n    }\r\n\r\n    function _calCurDynamicRewards(address _user) private view returns(uint256) {\r\n        RewardInfo storage userRewards = rewardInfo[_user];\r\n        //add all the released rewards\r\n        uint256 totalRewards = userRewards.directs.add(userRewards.level2Released).add(userRewards.level4Released).add(userRewards.level5Released);\r\n        totalRewards = totalRewards.add(userRewards.luck.add(userRewards.contributor).add(userRewards.top));\r\n        uint256 withdrawable = totalRewards; //ADM\r\n        return withdrawable ;\r\n    }\r\n\r\n    function _updateTeamNum(address _user) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        if(user.totalDeposit >= minDeposit && hasUpdateDownline[_user] == false){\r\n            //only update downline if user makes deposit         \r\n            address upline = user.referrer;\r\n            for(uint256 i = 0; i < referDepth; i++){\r\n                if(upline != address(0)){\r\n                    //only do this if the user has deposited\r\n                    userInfo[upline].teamNum = userInfo[upline].teamNum.add(1);\r\n                    teamUsers[upline][i].push(_user);\r\n                    _updateLevel(upline);\r\n                    if(upline == defaultRefer) break;\r\n                    upline = userInfo[upline].referrer;\r\n                }else{\r\n                    break;\r\n                }\r\n            }\r\n            hasUpdateDownline[_user] = true;\r\n        }\r\n    }\r\n\r\n    function _updateTopUser(address _user, uint256 _amount, uint256 _dayNow) private {\r\n        userLayer1DayDeposit[_dayNow][_user] = userLayer1DayDeposit[_dayNow][_user].add(_amount);\r\n        bool updated;\r\n        for(uint256 i = 0; i < 3; i++){\r\n            address topUser = dayTopUsers[_dayNow][i];\r\n            if(topUser == _user){\r\n                _reOrderTop(_dayNow);\r\n                updated = true;\r\n                break;\r\n            }\r\n        }\r\n        if(!updated){\r\n            address lastUser = dayTopUsers[_dayNow][2];\r\n            if(userLayer1DayDeposit[_dayNow][lastUser] < userLayer1DayDeposit[_dayNow][_user]){\r\n                dayTopUsers[_dayNow][2] = _user;\r\n                _reOrderTop(_dayNow);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _reOrderTop(uint256 _dayNow) private {\r\n        for(uint256 i = 3; i > 1; i--){\r\n            address topUser1 = dayTopUsers[_dayNow][i - 1];\r\n            address topUser2 = dayTopUsers[_dayNow][i - 2];\r\n            uint256 amount1 = userLayer1DayDeposit[_dayNow][topUser1];\r\n            uint256 amount2 = userLayer1DayDeposit[_dayNow][topUser2];\r\n            if(amount1 > amount2){\r\n                dayTopUsers[_dayNow][i - 1] = topUser2;\r\n                dayTopUsers[_dayNow][i - 2] = topUser1;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _removeInvalidDeposit(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                if(userInfo[upline].teamTotalDeposit > _amount){\r\n                    userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.sub(_amount);\r\n                }else{\r\n                    userInfo[upline].teamTotalDeposit = 0;\r\n                }\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateReferInfo(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.add(_amount);\r\n                _updateLevel(upline);\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateLevel(address _user) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 levelNow = _calLevelNow(_user);\r\n        if(levelNow > user.level){\r\n            user.level = levelNow;\r\n            if(levelNow == 5){\r\n                level5Users.push(_user);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function getMaxDeposit(address _user) private view returns(uint256) {\r\n        uint256 _maxDeposit;\r\n        for(uint256 i = orderInfos[_user].length; i > 0; i--){\r\n            OrderInfo storage order = orderInfos[_user][i - 1];\r\n            if(order.amount > _maxDeposit){\r\n                    _maxDeposit = order.amount;\r\n            } \r\n        }\r\n        return _maxDeposit;\r\n    }\r\n\r\n    function _calLevelNow(address _user) private view returns(uint256) {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 total = getMaxDeposit(_user);\r\n        uint256 levelNow;\r\n        (uint256 maxTeam, uint256 otherTeam, ) = getTeamDeposit(_user);\r\n         (uint256 maxTeamC, uint256 otherTeamC, ) = getTeamDepositCount(_user);\r\n\r\n        if(total >= 2000e6 && user.teamNum >= 200 && maxTeam >= 70000e6 && otherTeam >= 70000e6 && maxTeamC >= 100 && otherTeamC >= 100){\r\n             levelNow = 5;\r\n        }else if(total >= 1500e6 && user.teamNum >= 60 && maxTeam >= 25000e6 && otherTeam >= 25000e6 && maxTeamC >= 30 && otherTeamC >= 30){\r\n             levelNow = 4;\r\n        }else if(total >= 1000e6 && user.teamNum >= 40 && maxTeam >= 18000e6 && otherTeam >= 18000e6 && maxTeamC >= 20 && otherTeamC >= 20){\r\n             levelNow = 3;\r\n        }\r\n        else if(total >= 500e6 && user.teamNum >= 20 && maxTeam >= 10000e6 && otherTeam >= 10000e6 && maxTeamC >= 10 && otherTeamC >= 10 ){\r\n           levelNow = 2;\r\n        }else if(total >= 50e6){\r\n            levelNow = 1;\r\n        }\r\n\r\n        return levelNow;\r\n    }\r\n   \r\n\r\n    function _deposit(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        require(user.referrer != address(0), \"register first\");\r\n        require(_amount >= minDeposit, \"less than min\");\r\n        require(_amount.mod(minDeposit) == 0 && _amount >= minDeposit, \"mod err\");\r\n        require(user.maxDeposit == 0 || _amount >= user.maxDeposit, \"less before\");\r\n\r\n        if(user.maxDeposit == 0){\r\n            user.maxDeposit = _amount;\r\n        }else if(user.maxDeposit < _amount){\r\n            user.maxDeposit = _amount;\r\n        }\r\n\r\n        _distributeDeposit(_amount);\r\n\r\n        if(user.totalDeposit == 0){\r\n            uint256 dayNow = getCurDay();\r\n            dayLuckUsers[dayNow].push(_user);\r\n            dayLuckUsersDeposit[dayNow].push(_amount);\r\n\r\n            _updateTopUser(user.referrer, _amount, dayNow);\r\n        }\r\n\r\n        depositors.push(_user);\r\n        \r\n        user.totalDeposit = user.totalDeposit.add(_amount);\r\n        user.totalFreezed = user.totalFreezed.add(_amount);\r\n        //update downlinw once\r\n        _updateTeamNum(msg.sender);\r\n        \r\n        uint256 addFreeze = (orderInfos[_user].length.div(2)).mul(timeStep);\r\n        if(addFreeze > maxAddFreeze){\r\n            addFreeze = maxAddFreeze;\r\n        }\r\n        uint256 unfreezeTime = block.timestamp.add(dayPerCycle).add(addFreeze);\r\n        orderInfos[_user].push(OrderInfo(\r\n            _amount, \r\n            block.timestamp, \r\n            unfreezeTime,\r\n            false\r\n        ));\r\n        \r\n        //change the level currently\r\n        _updateLevel(msg.sender);\r\n\r\n        _unfreezeFundAndUpdateReward(msg.sender, _amount);\r\n\r\n        distributePoolRewards();\r\n\r\n        _updateReferInfo(msg.sender, _amount);\r\n\r\n        _updateReward(msg.sender, _amount);\r\n\r\n        _releaseUpRewards(msg.sender, _amount);\r\n\r\n        uint256 bal = usdt.balanceOf(address(this));\r\n        _balActived(bal);\r\n        if(isFreezeReward){\r\n            _setFreezeReward(bal);\r\n        }\r\n    }\r\n\r\n    function getRewardInfos(address _address, uint256 _type) public view returns (uint256, uint256, uint256, uint256, uint256, uint256){\r\n     \r\n     if(_type == 1){\r\n         uint256 _release = rewardInfo[_address].level4Released.add(rewardInfo[_address].level2Released);\r\n         return (rewardInfo[_address].capitals, rewardInfo[_address].statics, rewardInfo[_address].directs, rewardInfo[_address].level4Freezed , _release, 0);\r\n      }\r\n      else{\r\n        return (rewardInfo[_address].level5Left, rewardInfo[_address].level5Freezed, rewardInfo[_address].level5Released, rewardInfo[_address].contributor, rewardInfo[_address].luck, rewardInfo[_address].top);\r\n      }\r\n    }\r\n\r\n    function _unfreezeFundAndUpdateReward(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        bool isUnfreezeCapital;\r\n        for(uint256 i = 0; i < orderInfos[_user].length; i++){\r\n            OrderInfo storage order = orderInfos[_user][i];\r\n            if(block.timestamp > order.unfreeze  && order.isUnfreezed == false && _amount >= order.amount){\r\n                order.isUnfreezed = true;\r\n                isUnfreezeCapital = true;\r\n                \r\n                if(user.totalFreezed > order.amount){\r\n                    user.totalFreezed = user.totalFreezed.sub(order.amount);\r\n                }else{\r\n                    user.totalFreezed = 0;\r\n                }\r\n                \r\n                _removeInvalidDeposit(_user, order.amount);\r\n\r\n                uint256 staticReward = order.amount.mul(dayRewardPercents).mul(dayPerCycle).div(timeStep).div(baseDivider);\r\n                if(isFreezeReward){\r\n                    if(user.totalFreezed > user.totalRevenue){\r\n                        uint256 leftCapital = user.totalFreezed.sub(user.totalRevenue);\r\n                        if(staticReward > leftCapital){\r\n                            staticReward = leftCapital;\r\n                        }\r\n                    }else{\r\n                        staticReward = 0;\r\n                    }\r\n                }\r\n                rewardInfo[_user].capitals = rewardInfo[_user].capitals.add(order.amount);\r\n\r\n                rewardInfo[_user].statics = rewardInfo[_user].statics.add(staticReward);\r\n                \r\n                user.totalRevenue = user.totalRevenue.add(staticReward);\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(!isUnfreezeCapital){ \r\n            RewardInfo storage userReward = rewardInfo[_user];\r\n            if(userReward.level5Freezed > 0){\r\n                uint256 release = _amount;\r\n                if(_amount >= userReward.level5Freezed){\r\n                    release = userReward.level5Freezed;\r\n                }\r\n                userReward.level5Freezed = userReward.level5Freezed.sub(release);\r\n                userReward.level5Released = userReward.level5Released.add(release);\r\n                user.totalRevenue = user.totalRevenue.add(release);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _distributeStbPool() private {\r\n        uint256 level5Count;\r\n        for(uint256 i = 0; i < level5Users.length; i++){\r\n            if(userInfo[level5Users[i]].level == 5){\r\n                level5Count = level5Count.add(1);\r\n            }\r\n        }\r\n        if(level5Count > 0){\r\n            uint256 reward = stbPool.div(level5Count);\r\n            uint256 totalReward;\r\n            for(uint256 i = 0; i < level5Users.length; i++){\r\n                if(userInfo[level5Users[i]].level == 5){\r\n                    rewardInfo[level5Users[i]].contributor= rewardInfo[level5Users[i]].contributor.add(reward);\r\n                    userInfo[level5Users[i]].totalRevenue = userInfo[level5Users[i]].totalRevenue.add(reward);\r\n                    totalReward = totalReward.add(reward);\r\n                }\r\n            }\r\n            if(stbPool > totalReward){\r\n                stbPool = stbPool.sub(totalReward);\r\n            }else{\r\n                stbPool = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n    function _distributeLuckPool(uint256 _dayNow) private {\r\n        uint256 dayDepositCount = dayLuckUsers[_dayNow - 1].length;\r\n        if(dayDepositCount > 0){\r\n            uint256 checkCount = 10;\r\n            if(dayDepositCount < 10){\r\n                checkCount = dayDepositCount;\r\n            }\r\n            uint256 totalDeposit;\r\n            uint256 totalReward;\r\n            for(uint256 i = dayDepositCount; i > dayDepositCount.sub(checkCount); i--){\r\n                totalDeposit = totalDeposit.add(dayLuckUsersDeposit[_dayNow - 1][i - 1]);\r\n            }\r\n\r\n            for(uint256 i = dayDepositCount; i > dayDepositCount.sub(checkCount); i--){\r\n                address userAddr = dayLuckUsers[_dayNow - 1][i - 1];\r\n                if(userAddr != address(0)){\r\n                    uint256 reward = luckPool.mul(dayLuckUsersDeposit[_dayNow - 1][i - 1]).div(totalDeposit);\r\n                    totalReward = totalReward.add(reward);\r\n                    rewardInfo[userAddr].luck = rewardInfo[userAddr].luck.add(reward);\r\n                    userInfo[userAddr].totalRevenue = userInfo[userAddr].totalRevenue.add(reward);\r\n                }\r\n            }\r\n            if(luckPool > totalReward){\r\n                luckPool = luckPool.sub(totalReward);\r\n            }else{\r\n                luckPool = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _distributeTopPool(uint256 _dayNow) private {\r\n        uint16[3] memory rates = [5000, 3000, 2000];\r\n        uint32[3] memory maxReward = [2000e6, 1000e6, 500e6];\r\n        uint256 totalReward;\r\n        for(uint256 i = 0; i < 3; i++){\r\n            address userAddr = dayTopUsers[_dayNow - 1][i];\r\n            if(userAddr != address(0)){\r\n                uint256 reward = topPool.mul(rates[i]).div(baseDivider);\r\n                if(reward > maxReward[i]){\r\n                    reward = maxReward[i];\r\n                }\r\n                rewardInfo[userAddr].top = rewardInfo[userAddr].top.add(reward);\r\n                userInfo[userAddr].totalRevenue = userInfo[userAddr].totalRevenue.add(reward);\r\n                totalReward = totalReward.add(reward);\r\n            }\r\n        }\r\n        if(topPool > totalReward){\r\n            topPool = topPool.sub(totalReward);\r\n        }else{\r\n            topPool = 0;\r\n        }\r\n    }\r\n\r\n    function _distributeDeposit(uint256 _amount) private {\r\n        uint256 fee_1 = _amount.mul(feePercents[0]).div(baseDivider); //1.8percents\r\n        uint256 fee_2 =  _amount.mul(feePercents[1]).div(baseDivider); //0.2percents\r\n        usdt.transfer(feeReceivers[0], fee_1);\r\n        usdt.transfer(feeReceivers[1], fee_2);\r\n        uint256 luck = _amount.mul(luckPoolPercents).div(baseDivider);\r\n        luckPool = luckPool.add(luck);\r\n        uint256 stb = _amount.mul(stbPoolPercents).div(baseDivider);\r\n        stbPool = stbPool.add(stb);\r\n        uint256 top = _amount.mul(topPoolPercents).div(baseDivider);\r\n        topPool = topPool.add(top);\r\n    }\r\n\r\n   \r\n   \r\n     function _updateReward(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n          \r\n        for(uint256 i = 0; i < referDepth; i++){\r\n\r\n                    if(upline != address(0)){\r\n\r\n                        uint256 newAmount = _amount;\r\n                        if(upline != defaultRefer){\r\n                            uint256 maxFreezing = getMaxFreezing(upline);\r\n                            if(maxFreezing < _amount){\r\n                                newAmount = maxFreezing;\r\n                            }\r\n                        }\r\n                        RewardInfo storage upRewards = rewardInfo[upline];\r\n                        uint256 reward;\r\n                    \r\n\r\n                    if(i==0){\r\n                            \r\n                            reward = newAmount.mul(directPercents).div(baseDivider);\r\n                            upRewards.directs = upRewards.directs.add(reward);                       \r\n                            userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n\r\n                    }\r\n                    else if( i==1 && userInfo[upline].level >= 2){\r\n                                                    reward = newAmount.mul(level2Percents[i - 1]).div(baseDivider);\r\n                                                    upRewards.level2Freezed = upRewards.level2Freezed.add(reward);\r\n                                                }\r\n                    else if( i==2 && userInfo[upline].level >= 3){\r\n                                                    reward = newAmount.mul(level2Percents[i - 1]).div(baseDivider);\r\n                                                    upRewards.level2Freezed = upRewards.level2Freezed.add(reward);\r\n                                                }\r\n                        \r\n                    else if( i >=3 && i<=4  && userInfo[upline].level >=4 ){\r\n                                                    reward = newAmount.mul(level4Percents[i - 3]).div(baseDivider);\r\n                                                    upRewards.level4Freezed = upRewards.level4Freezed.add(reward);\r\n                                                }\r\n                    else if( i >= 5 && userInfo[upline].level >=5){\r\n                                                    reward = newAmount.mul(level5Percents[i - 5]).div(baseDivider);\r\n                                                    upRewards.level5Freezed = upRewards.level5Freezed.add(reward);\r\n                                                }\r\n                        \r\n\r\n                        if(upline == defaultRefer) break;\r\n                    \r\n                        upline = userInfo[upline].referrer;\r\n                    }\r\n                    else \r\n                        break;\r\n            }\r\n     }\r\n\r\n       \r\n    function _releaseUpRewards(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                uint256 newAmount = _amount;\r\n                if(upline != defaultRefer){\r\n                    uint256 maxFreezing = getMaxFreezing(upline);\r\n                    if(maxFreezing < _amount){\r\n                        newAmount = maxFreezing;\r\n                    }\r\n                }\r\n\r\n                RewardInfo storage upRewards = rewardInfo[upline];\r\n                 \r\n                  if(i ==1 && userInfo[upline].level>= 2){\r\n                    if(upRewards.level2Freezed > 0){\r\n                        uint256 level3Reward = newAmount.mul(level2Percents[i - 1]).div(baseDivider);\r\n                        if(level3Reward > upRewards.level2Freezed){\r\n                            level3Reward = upRewards.level2Freezed;\r\n                        }\r\n                        upRewards.level2Freezed = upRewards.level2Freezed.sub(level3Reward); \r\n                        upRewards.level2Released = upRewards.level2Released.add(level3Reward);\r\n                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(level3Reward);\r\n                    }\r\n                }\r\n\r\n                if(i ==2 && userInfo[upline].level>=3){\r\n                    if(upRewards.level2Freezed > 0){\r\n                        uint256 level3Reward = newAmount.mul(level2Percents[i - 1]).div(baseDivider);\r\n                        if(level3Reward > upRewards.level2Freezed){\r\n                            level3Reward = upRewards.level2Freezed;\r\n                        }\r\n                        upRewards.level2Freezed = upRewards.level2Freezed.sub(level3Reward); \r\n                        upRewards.level2Released = upRewards.level2Released.add(level3Reward);\r\n                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(level3Reward);\r\n                    }\r\n                }\r\n\r\n\r\n                if(i >= 3 && i <=4 && userInfo[upline].level>=4){\r\n                    if(upRewards.level4Freezed > 0){\r\n                        uint256 level4Reward = newAmount.mul(level4Percents[i - 3]).div(baseDivider);\r\n                        if(level4Reward > upRewards.level4Freezed){\r\n                            level4Reward = upRewards.level4Freezed;\r\n                        }\r\n                        upRewards.level4Freezed = upRewards.level4Freezed.sub(level4Reward); \r\n                        upRewards.level4Released = upRewards.level4Released.add(level4Reward);\r\n                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(level4Reward);\r\n                    }\r\n                }\r\n\r\n                if(i >= 5 && userInfo[upline].level >=5 ){\r\n                    if(upRewards.level5Left > 0){\r\n                        uint256 level5Reward = newAmount.mul(level5Percents[i - 5]).div(baseDivider);\r\n                        if(level5Reward > upRewards.level5Left){\r\n                            level5Reward = upRewards.level5Left;\r\n                        }\r\n\r\n                        upRewards.level5Left = upRewards.level5Left.sub(level5Reward); \r\n                        upRewards.level5Freezed = upRewards.level5Freezed.add(level5Reward);\r\n                    }\r\n                }\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        } \r\n    } \r\n \r\n    function _balActived(uint256 _bal) private {\r\n        for(uint256 i = balReached.length; i > 0; i--){\r\n            if(_bal >= balReached[i - 1]){\r\n                balStatus[balReached[i - 1]] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _setFreezeReward(uint256 _bal) private {\r\n        for(uint256 i = balReached.length; i > 0; i--){\r\n            if(balStatus[balReached[i - 1]]){\r\n                if(_bal < balFreezeStatic[i - 1]){\r\n                    freezeStaticReward = true;\r\n                    if(_bal < balFreezeDynamic[i - 1]){\r\n                        freezeDynamicReward = true;\r\n                    }\r\n                }else{\r\n                    if((freezeStaticReward || freezeDynamicReward) && _bal >= balRecover[i - 1]){\r\n                        freezeStaticReward = false;\r\n                        freezeDynamicReward = false;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultRefer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_CSFFundWallet\",\"type\":\"address\"},{\"internalType\":\"address[2]\",\"name\":\"_feeReceivers\",\"type\":\"address[2]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CSF_wallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayLuckUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayLuckUsersDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayTopUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRefer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePoolRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeReceivers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getDayLuckLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositorsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMaxFreezing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"getRewardInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTeamDepositCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFreezeReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"level5Users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"luckPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"capitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level2Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level2Released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level4Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level4Released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level5Left\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level5Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level5Released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contributor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luck\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"top\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stbPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDirectDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLayer1DayDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ADMGLOBAL", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f00000000000000000000000025997203b65d5d1e0c5adb667166928e224f2e69000000000000000000000000e1fcbdcfe584e7ee6ed0e0ab8e0a6b5189b0cf3100000000000000000000000015b71b51890cc7367fc05f0d68f748b4310ca174000000000000000000000000e2e28ffde5d5ff1cd9c50add9ca0381a9241e602", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0fd445e3c62572152a79f0a91a0be846aa60fc82f55a8c6a1ea85da25340a259"}