{"SourceCode": "\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/EIP712Base.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract EIP712Base {\r\n    struct EIP712Domain {\r\n        string name;\r\n        string version;\r\n        address verifyingContract;\r\n        bytes32 salt;\r\n    }\r\n\r\n    string constant public ERC712_VERSION = \"1\";\r\n\r\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        bytes(\r\n            \"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\"\r\n        )\r\n    );\r\n    bytes32 internal domainSeperator;\r\n\r\n    constructor(string memory name) public {\r\n        _setDomainSeperator(name);\r\n    }\r\n    \r\n    function _setDomainSeperator(string memory name) internal {\r\n        domainSeperator = keccak256(\r\n            abi.encode(\r\n                EIP712_DOMAIN_TYPEHASH,\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(ERC712_VERSION)),\r\n                address(this),\r\n                bytes32(getChainId())\r\n            )\r\n        );\r\n    }\r\n\r\n    function getDomainSeperator() public view returns (bytes32) {\r\n        return domainSeperator;\r\n    }\r\n\r\n    function getChainId() public pure returns (uint256) {\r\n        uint256 id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Accept message hash and returns hash message in EIP712 compatible form\r\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\r\n     * https://eips.ethereum.org/EIPS/eip-712\r\n     * \"\\\\x19\" makes the encoding deterministic\r\n     * \"\\\\x01\" is the version byte to make it compatible to EIP-191\r\n     */\r\n    function toTypedMessageHash(bytes32 messageHash)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(), messageHash)\r\n            );\r\n    }\r\n}\r\n\r\n// File: contracts/NativeMetaTransaction.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ncontract NativeMetaTransaction is EIP712Base {\r\n    using SafeMath for uint256;\r\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\r\n        bytes(\r\n            \"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\"\r\n        )\r\n    );\r\n    event MetaTransactionExecuted(\r\n        address userAddress,\r\n        address payable relayerAddress,\r\n        bytes functionSignature\r\n    );\r\n    mapping(address => uint256) nonces;\r\n\r\n    /*\r\n     * Meta transaction structure.\r\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\r\n     * He should call the desired function directly in that case.\r\n     */\r\n    struct MetaTransaction {\r\n        uint256 nonce;\r\n        address from;\r\n        bytes functionSignature;\r\n    }\r\n\r\n    constructor(string memory name) public EIP712Base(name){\r\n    }\r\n\r\n    function executeMetaTransaction(\r\n        address userAddress,\r\n        bytes memory functionSignature,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) public payable returns (bytes memory) {\r\n        MetaTransaction memory metaTx = MetaTransaction({\r\n            nonce: nonces[userAddress],\r\n            from: userAddress,\r\n            functionSignature: functionSignature\r\n        });\r\n\r\n        require(\r\n            verify(userAddress, metaTx, sigR, sigS, sigV),\r\n            \"Signer and signature do not match\"\r\n        );\r\n\r\n        // increase nonce for user (to avoid re-use)\r\n        nonces[userAddress] = nonces[userAddress].add(1);\r\n\r\n        emit MetaTransactionExecuted(\r\n            userAddress,\r\n            msg.sender,\r\n            functionSignature\r\n        );\r\n\r\n        // Append userAddress and relayer address at the end to extract it from calling context\r\n        (bool success, bytes memory returnData) = address(this).call(\r\n            abi.encodePacked(functionSignature, userAddress)\r\n        );\r\n        require(success, \"Function call not successful\");\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function hashMetaTransaction(MetaTransaction memory metaTx)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    META_TRANSACTION_TYPEHASH,\r\n                    metaTx.nonce,\r\n                    metaTx.from,\r\n                    keccak256(metaTx.functionSignature)\r\n                )\r\n            );\r\n    }\r\n\r\n    function getNonce(address user) public view returns (uint256 nonce) {\r\n        nonce = nonces[user];\r\n    }\r\n\r\n    function verify(\r\n        address signer,\r\n        MetaTransaction memory metaTx,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) internal view returns (bool) {\r\n        require(signer != address(0), \"NativeMetaTransaction: INVALID_SIGNER\");\r\n        return\r\n            signer ==\r\n            ecrecover(\r\n                toTypedMessageHash(hashMetaTransaction(metaTx)),\r\n                sigV,\r\n                sigR,\r\n                sigS\r\n            );\r\n    }\r\n}\r\n\r\n// File: contracts/Context.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract Context {\r\n    function msgSender()\r\n        internal\r\n        view\r\n        returns (address payable sender)\r\n    {\r\n        if (msg.sender == address(this)) {\r\n            bytes memory array = msg.data;\r\n            uint256 index = msg.data.length;\r\n            assembly {\r\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\r\n                sender := and(\r\n                    mload(add(array, index)),\r\n                    0xffffffffffffffffffffffffffffffffffffffff\r\n                )\r\n            }\r\n        } else {\r\n            sender = msg.sender;\r\n        }\r\n        return sender;\r\n    }\r\n}\r\n\r\n// File: contracts/EthermonEnum.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract EthermonEnum {\r\n\r\n    enum ResultCode {\r\n        SUCCESS,\r\n        ERROR_CLASS_NOT_FOUND,\r\n        ERROR_LOW_BALANCE,\r\n        ERROR_SEND_FAIL,\r\n        ERROR_NOT_TRAINER,\r\n        ERROR_NOT_ENOUGH_MONEY,\r\n        ERROR_INVALID_AMOUNT\r\n    }\r\n    \r\n    enum ArrayType {\r\n        CLASS_TYPE,\r\n        STAT_STEP,\r\n        STAT_START,\r\n        STAT_BASE,\r\n        OBJ_SKILL\r\n    }\r\n\r\n    enum PropertyType {\r\n        ANCESTOR,\r\n        XFACTOR\r\n    }\r\n}\r\n\r\n// File: contracts/EthermonDataBase.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface EtheremonDataBase {\r\n\r\n    // write\r\n    function withdrawEther(address _sendTo, uint _amount) external returns(EthermonEnum.ResultCode);\r\n    function addElementToArrayType(EthermonEnum.ArrayType _type, uint64 _id, uint8 _value) external returns(uint);\r\n    function updateIndexOfArrayType(EthermonEnum.ArrayType _type, uint64 _id, uint _index, uint8 _value) external returns(uint);\r\n    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) external returns(uint32);\r\n    function addMonsterObj(uint32 _classId, address _trainer, string calldata _name) external returns(uint64);\r\n    function setMonsterObj(uint64 _objId, string calldata _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) external;\r\n    function increaseMonsterExp(uint64 _objId, uint32 amount) external;\r\n    function decreaseMonsterExp(uint64 _objId, uint32 amount) external;\r\n    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) external;\r\n    function addMonsterIdMapping(address _trainer, uint64 _monsterId) external;\r\n    function clearMonsterReturnBalance(uint64 _monsterId) external returns(uint256 amount);\r\n    function collectAllReturnBalance(address _trainer) external returns(uint256 amount);\r\n    function transferMonster(address _from, address _to, uint64 _monsterId) external returns(EthermonEnum.ResultCode);\r\n    function addExtraBalance(address _trainer, uint256 _amount) external returns(uint256);\r\n    function deductExtraBalance(address _trainer, uint256 _amount) external returns(uint256);\r\n    function setExtraBalance(address _trainer, uint256 _amount) external;\r\n    \r\n    // read\r\n    function totalMonster() external view returns(uint256);\r\n    function totalClass() external view returns(uint32);\r\n    function getSizeArrayType(EthermonEnum.ArrayType _type, uint64 _id) external view returns(uint);\r\n    function getElementInArrayType(EthermonEnum.ArrayType _type, uint64 _id, uint _index) external view returns(uint8);\r\n    function getMonsterClass(uint32 _classId) external view returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);\r\n    function getMonsterObj(uint64 _objId) external view returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\r\n    function getMonsterName(uint64 _objId) external view returns(string memory name);\r\n    function getExtraBalance(address _trainer) external view returns(uint256);\r\n    function getMonsterDexSize(address _trainer) external view returns(uint);\r\n    function getMonsterObjId(address _trainer, uint index) external view returns(uint64);\r\n    function getExpectedBalance(address _trainer) external view returns(uint256);\r\n    function getMonsterReturn(uint64 _objId) external view returns(uint256 current, uint256 total);\r\n}\r\n\r\n// File: contracts/BasicAccessControl.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ncontract BasicAccessControl is Context {\r\n    address payable public owner;\r\n    // address[] public moderators;\r\n    uint16 public totalModerators = 0;\r\n    mapping (address => bool) public moderators;\r\n    bool public isMaintaining = false;\r\n\r\n    constructor() public {\r\n        owner = msgSender();\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msgSender() == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyModerators() {\r\n        require(msgSender() == owner || moderators[msgSender()] == true);\r\n        _;\r\n    }\r\n\r\n    modifier isActive {\r\n        require(!isMaintaining);\r\n        _;\r\n    }\r\n\r\n    function ChangeOwner(address payable _newOwner) public onlyOwner {\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n\r\n\r\n    function AddModerator(address _newModerator) public onlyOwner {\r\n        if (moderators[_newModerator] == false) {\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }\r\n    }\r\n\r\n    function Kill() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\n// File: contracts/EtheremonMonsterToken.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n// copyright contact@Etheremon.com// copyright contact@Etheremon.com\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ERC721 {\r\n       \r\n    function transfer(address _to, uint256 _tokenId) external;\r\n  \r\n}\r\n\r\n\r\n\r\ninterface EtheremonBattle {\r\n    function isOnBattle(uint64 _objId) external view returns(bool);\r\n}\r\n\r\ninterface EtheremonTradeInterface {\r\n    function isOnTrading(uint64 _objId) external view returns(bool);\r\n}\r\n\r\n\r\ncontract EtheremonMonsterTokenBasic is IERC721, ERC721, ERC165, BasicAccessControl {\r\n\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    \r\n    struct MonsterClassAcc {\r\n        uint32 classId;\r\n        uint256 price;\r\n        uint256 returnPrice;\r\n        uint32 total;\r\n        bool catchable;\r\n    }\r\n\r\n    struct MonsterObjAcc {\r\n        uint64 monsterId;\r\n        uint32 classId;\r\n        address trainer;\r\n        string name;\r\n        uint32 exp;\r\n        uint32 createIndex;\r\n        uint32 lastClaimIndex;\r\n        uint createTime;\r\n    }\r\n\r\n    // data contract\r\n    address public dataContract;\r\n    address public battleContract;\r\n    address public tradeContract;\r\n    \r\n    // Mapping from NFT ID to approved address.\r\n    mapping (uint256 => address) internal idToApprovals;\r\n    \r\n    // Mapping from owner address to mapping of operator addresses.\r\n    mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n    \r\n    /**\r\n    * @dev Magic value of a smart contract that can recieve NFT.\r\n    * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n    */\r\n    bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    \r\n    \r\n    // internal function\r\n    function _canOperate(address _tokenOwner) internal view {\r\n        require(_tokenOwner == msgSender() || ownerToOperators[_tokenOwner][msgSender()]);\r\n    }\r\n    \r\n    function _canTransfer(uint256 _tokenId, address _tokenOwner) internal view {\r\n        EtheremonBattle battle = EtheremonBattle(battleContract);\r\n        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\r\n        require(!battle.isOnBattle(uint64(_tokenId)) && !trade.isOnTrading(uint64(_tokenId)));\r\n        require(_tokenOwner != address(0));\r\n        require(_tokenOwner == msgSender() || idToApprovals[_tokenId] == msgSender() || ownerToOperators[_tokenOwner][msgSender()]);\r\n    }\r\n    \r\n    function setOperationContracts(address _dataContract, address _battleContract, address _tradeContract) external onlyModerators {\r\n        dataContract = _dataContract;\r\n        battleContract = _battleContract;\r\n        tradeContract = _tradeContract;\r\n    }\r\n    \r\n    // public function\r\n\r\n    function isApprovable(address _owner, uint256 _tokenId) public view returns(bool) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\r\n        if (obj.monsterId != uint64(_tokenId))\r\n            return false;\r\n        if (obj.trainer != _owner)\r\n            return false;\r\n        // check battle & trade contract \r\n        EtheremonBattle battle = EtheremonBattle(battleContract);\r\n        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\r\n        return (!battle.isOnBattle(obj.monsterId) && !trade.isOnTrading(obj.monsterId));\r\n    }\r\n\r\n    function balanceOf(address _owner) external view override returns (uint256) {\r\n        require(_owner != address(0));\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        return data.getMonsterDexSize(_owner);\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) external view override returns (address _owner) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, _owner, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\r\n        require(_owner != address(0));\r\n    }\r\n\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external override {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\r\n        require(obj.trainer != address(0));\r\n        _canTransfer(_tokenId, obj.trainer);\r\n        \r\n        require(obj.trainer == _from);\r\n        require(_to != address(0));\r\n        _transfer(obj.trainer, _to, _tokenId);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokenId) external override {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\r\n        require(obj.trainer != address(0));\r\n        _canTransfer(_tokenId, obj.trainer);\r\n        \r\n        require(obj.trainer == msgSender());\r\n        require(_to != address(0));\r\n        _transfer(obj.trainer, _to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) external override {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\r\n        require(obj.trainer != address(0));\r\n        _canOperate(obj.trainer);\r\n        EtheremonBattle battle = EtheremonBattle(battleContract);\r\n        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\r\n        if(battle.isOnBattle(obj.monsterId) || trade.isOnTrading(obj.monsterId))\r\n            revert();\r\n        \r\n        require(_approved != obj.trainer);\r\n\r\n        idToApprovals[_tokenId] = _approved;\r\n        emit Approval(obj.trainer, _approved, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external override {\r\n        require(_operator != address(0));\r\n        ownerToOperators[msgSender()][_operator] = _approved;\r\n        emit ApprovalForAll(msgSender(), _operator, _approved);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) external view override returns (address) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\r\n        require(obj.trainer != address(0));\r\n        return idToApprovals[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {\r\n        require(_owner != address(0));\r\n        require(_operator != address(0));\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n\r\n    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) internal {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\r\n        require(obj.trainer != address(0));\r\n        _canTransfer(_tokenId, obj.trainer);\r\n        \r\n        require(obj.trainer == _from);\r\n        require(_to != address(0));\r\n\r\n        _transfer(obj.trainer, _to, _tokenId);\r\n\r\n        if (_to.isContract()) {\r\n            bytes4 retval = IERC721Receiver(_to).onERC721Received(msgSender(), _from, _tokenId, _data);\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n        }\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId) private {\r\n        _clearApproval(_tokenId);\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        data.removeMonsterIdMapping(_from, uint64(_tokenId));\r\n        data.addMonsterIdMapping(_to, uint64(_tokenId));\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n\r\n    function _burn(uint256 _tokenId) internal virtual { \r\n        _clearApproval(_tokenId);\r\n        \r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(uint64(_tokenId));\r\n        require(obj.trainer != address(0));\r\n        \r\n        EtheremonBattle battle = EtheremonBattle(battleContract);\r\n        EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\r\n        if(battle.isOnBattle(obj.monsterId) || trade.isOnTrading(obj.monsterId))\r\n            revert();\r\n        \r\n        data.removeMonsterIdMapping(obj.trainer, uint64(_tokenId));\r\n        \r\n        emit Transfer(obj.trainer, address(0), _tokenId);\r\n    }\r\n\r\n    function _clearApproval(uint256 _tokenId) internal {\r\n        if(idToApprovals[_tokenId] != address(0)) {\r\n            delete idToApprovals[_tokenId];\r\n        }\r\n    }\r\n\r\n}\r\n\r\nabstract contract EtheremonMonsterEnumerable is EtheremonMonsterTokenBasic, IERC721Enumerable {\r\n\r\n    constructor() public {\r\n        _registerInterface(0x780e9d63); // ERC721Enumerable\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        return data.totalMonster();\r\n    }\r\n\r\n    function tokenByIndex(uint256 _index) external view override returns (uint256) {\r\n        return _index;\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view override returns (uint256) {\r\n        require(_owner != address(0));\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        return data.getMonsterObjId(_owner, _index);\r\n    }\r\n\r\n}\r\n\r\n\r\nabstract contract EtheremonMonsterStandard is EtheremonMonsterEnumerable, IERC721Metadata {\r\n    string internal nftName;\r\n    string internal nftSymbol;\r\n    \r\n    mapping (uint256 => string) internal idToUri;\r\n    \r\n    constructor(string memory _name, string memory _symbol) public {\r\n        nftName = _name;\r\n        nftSymbol = _symbol;\r\n        _registerInterface(0x5b5e139f); // ERC721Metadata\r\n    }\r\n    \r\n    function _burn(uint256 _tokenId) internal override {\r\n        super._burn(_tokenId);\r\n        if (bytes(idToUri[_tokenId]).length != 0) {\r\n            delete idToUri[_tokenId];\r\n        }\r\n    }\r\n    \r\n    function _setTokenUri(uint256 _tokenId, string memory _uri) internal {\r\n        idToUri[_tokenId] = _uri;\r\n    }\r\n    \r\n    function name() external view override returns (string memory _name) {\r\n        _name = nftName;\r\n    }\r\n    \r\n    function symbol() external view override returns (string memory _symbol) {\r\n        _symbol = nftSymbol;\r\n    }\r\n    \r\n    function tokenURI(uint256 _tokenId) external view override returns (string memory) {\r\n        return idToUri[_tokenId];\r\n    }\r\n}\r\n\r\ncontract EtheremonMonsterToken is EtheremonMonsterStandard(\"EtheremonMonster\", \"EMONA\"), NativeMetaTransaction {\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint8 constant public STAT_COUNT = 6;\r\n    uint8 constant public STAT_MAX = 32;\r\n\r\n    uint seed = 0;\r\n\r\n    mapping(uint8 => uint32) public levelExps;\r\n    mapping(uint32 => bool) classWhitelist;\r\n    mapping(address => bool) addressWhitelist;\r\n\r\n    uint public gapFactor = 0.001 ether;\r\n    uint16 public priceIncreasingRatio = 1000;\r\n//wrapped ether on matic\r\n    IERC20 public weth;\r\n\r\n    constructor(\r\n        string memory name,\r\n        address _weth\r\n    )\r\n        public\r\n        NativeMetaTransaction(name)\r\n    {\r\n        weth = IERC20(_weth);\r\n        _registerInterface(0x80ac58cd); // ERC721\r\n    }\r\n    \r\n    function setPriceIncreasingRatio(uint16 _ratio) external onlyModerators {\r\n        priceIncreasingRatio = _ratio;\r\n    }\r\n\r\n    function setFactor(uint _gapFactor) public onlyModerators {\r\n        gapFactor = _gapFactor;\r\n    }\r\n    \r\n    function genLevelExp() external onlyModerators {\r\n        uint8 level = 1;\r\n        uint32 requirement = 100;\r\n        uint32 sum = requirement;\r\n        while(level <= 100) {\r\n            levelExps[level] = sum;\r\n            level += 1;\r\n            requirement = (requirement * 11) / 10 + 5;\r\n            sum += requirement;\r\n        }\r\n    }\r\n\r\n    function setClassWhitelist(uint32 _classId, bool _status) external onlyModerators {\r\n        classWhitelist[_classId] = _status;\r\n    }\r\n\r\n    function setAddressWhitelist(address _smartcontract, bool _status) external onlyModerators {\r\n        addressWhitelist[_smartcontract] = _status;\r\n    }\r\n\r\n    function setTokenURI(uint256 _tokenId, string calldata _uri) external onlyModerators {\r\n        _setTokenUri(_tokenId, _uri);\r\n    }\r\n\r\n    // write access\r\n    function withdrawEther(\r\n        address _sendTo,\r\n        uint _amount\r\n    )\r\n        public\r\n        onlyOwner\r\n    {   \r\n        uint256 balance = weth.balanceOf(address(this));\r\n\r\n        require(_amount <= balance);\r\n        \r\n        weth.safeTransfer(_sendTo, _amount);\r\n    }\r\n\r\n    function mintMonster(uint32 _classId, address _trainer, string calldata _name) external onlyModerators returns(uint){\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        // add monster\r\n        uint64 objId = data.addMonsterObj(_classId, _trainer, _name);\r\n        uint8 value;\r\n        seed = getRandom(_trainer, block.number-1, seed, objId);\r\n        // generate base stat for the previous one\r\n        for (uint i=0; i < STAT_COUNT; i+= 1) {\r\n            value = uint8(seed % STAT_MAX) + data.getElementInArrayType(EthermonEnum.ArrayType.STAT_START, uint64(_classId), i);\r\n            data.addElementToArrayType(EthermonEnum.ArrayType.STAT_BASE, objId, value);\r\n        }\r\n        emit Transfer(address(0), _trainer, objId);\r\n        return objId;\r\n    }\r\n\r\n    function burnMonster(uint64 _tokenId) external onlyModerators {\r\n        _burn(_tokenId);\r\n    }\r\n\r\n    function clearApproval(uint _tokenId) external onlyModerators {\r\n        _clearApproval(_tokenId);\r\n    }\r\n\r\n    function triggerTransferEvent(address _from, address _to, uint _tokenId) external onlyModerators {\r\n        _clearApproval(_tokenId);\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    // public api\r\n    function getRandom(address _player, uint _block, uint _seed, uint _count) view public returns(uint) {\r\n        return uint(keccak256(abi.encodePacked(blockhash(_block), _player, _seed, _count)));\r\n    }\r\n\r\n    function getLevel(uint32 exp) view public returns (uint8) {\r\n        uint8 minIndex = 1;\r\n        uint8 maxIndex = 100;\r\n        uint8 currentIndex;\r\n\r\n        while (minIndex < maxIndex) {\r\n            currentIndex = (minIndex + maxIndex) / 2;\r\n            if (exp < levelExps[currentIndex])\r\n                maxIndex = currentIndex;\r\n            else\r\n                minIndex = currentIndex + 1;\r\n        }\r\n\r\n        return minIndex;\r\n    }\r\n\r\n    function getMonsterBaseStats(uint64 _monsterId) external view returns(uint hp, uint pa, uint pd, uint sa, uint sd, uint speed) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        uint[6] memory stats;\r\n        for(uint i=0; i < STAT_COUNT; i+=1) {\r\n            stats[i] = data.getElementInArrayType(EthermonEnum.ArrayType.STAT_BASE, _monsterId, i);\r\n        }\r\n        return (stats[0], stats[1], stats[2], stats[3], stats[4], stats[5]);\r\n    }\r\n    \r\n    function getMonsterCurrentStats(uint64 _monsterId) external view returns(uint exp, uint level, uint hp, uint pa, uint pd, uint sa, uint sd, uint speed) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_monsterId);\r\n        \r\n        uint[6] memory stats;\r\n        uint i = 0;\r\n        level = getLevel(obj.exp);\r\n        for(i=0; i < STAT_COUNT; i+=1) {\r\n            stats[i] = data.getElementInArrayType(EthermonEnum.ArrayType.STAT_BASE, _monsterId, i);\r\n        }\r\n        for(i=0; i < STAT_COUNT; i++) {\r\n            stats[i] += uint(data.getElementInArrayType(EthermonEnum.ArrayType.STAT_STEP, obj.classId, i)) * level * 3;\r\n        }\r\n        \r\n        return (obj.exp, level, stats[0], stats[1], stats[2], stats[3], stats[4], stats[5]);\r\n    }\r\n    \r\n    function getMonsterCP(uint64 _monsterId) external view returns(uint cp) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_monsterId);\r\n        \r\n        uint[6] memory stats;\r\n        uint i = 0;\r\n        cp = getLevel(obj.exp);\r\n        for(i=0; i < STAT_COUNT; i+=1) {\r\n            stats[i] = data.getElementInArrayType(EthermonEnum.ArrayType.STAT_BASE, _monsterId, i);\r\n        }\r\n        for(i=0; i < STAT_COUNT; i++) {\r\n            stats[i] += uint(data.getElementInArrayType(EthermonEnum.ArrayType.STAT_STEP, obj.classId, i)) * cp * 3;\r\n        }\r\n        \r\n        cp = (stats[0] + stats[1] + stats[2] + stats[3] + stats[4] + stats[5]) / 6;\r\n    }\r\n    \r\n    function getPrice(uint32 _classId) external view returns(bool catchable, uint price) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterClassAcc memory class;\r\n        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\r\n        \r\n        price = class.price;\r\n        if (class.total > 0)\r\n            price += class.price*(class.total-1)/priceIncreasingRatio;\r\n        \r\n        if (class.catchable == false) {\r\n            if (addressWhitelist[msgSender()] == true && classWhitelist[_classId] == true) {\r\n                return (true, price);\r\n            }\r\n        }\r\n        \r\n        return (class.catchable, price);\r\n    }\r\n    \r\n    function getMonsterClassBasic(uint32 _classId) external view returns(uint256, uint256, uint256, bool) {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterClassAcc memory class;\r\n        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\r\n        return (class.price, class.returnPrice, class.total, class.catchable);\r\n    }\r\n    \r\n    function renameMonster(uint64 _objId, string calldata name) external isActive {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterObjAcc memory obj;\r\n        (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);\r\n        if (obj.monsterId != _objId || obj.trainer != msgSender()) {\r\n            revert();\r\n        }\r\n        data.setMonsterObj(_objId, name, obj.exp, obj.createIndex, obj.lastClaimIndex);\r\n    }\r\n    \r\n    //MATIC: CHANGES FOR ETHER\r\n    function catchMonster(\r\n        address _player,\r\n        uint32 _classId,\r\n        string calldata _name,\r\n        uint256 amount\r\n    )\r\n        external\r\n        isActive\r\n        returns(uint tokenId)\r\n    {\r\n        EtheremonDataBase data = EtheremonDataBase(dataContract);\r\n        MonsterClassAcc memory class;\r\n        (class.classId, class.price, class.returnPrice, class.total, class.catchable) = data.getMonsterClass(_classId);\r\n        if (class.classId == 0) {\r\n            revert();\r\n        }\r\n        \r\n        if (class.catchable == false) {\r\n            if (addressWhitelist[msgSender()] == false || classWhitelist[_classId] == false) {\r\n                revert();\r\n            }\r\n        }\r\n        \r\n        uint price = class.price;\r\n        if (class.total > 0)\r\n            price += class.price*(class.total-1)/priceIncreasingRatio;\r\n        weth.safeTransferFrom(msgSender(), address(this), amount);\r\n        if (amount + gapFactor < price) {\r\n            revert();\r\n        }\r\n        \r\n        // add new monster \r\n        uint64 objId = data.addMonsterObj(_classId, _player, _name);\r\n        uint8 value;\r\n        seed = getRandom(_player, block.number-1, seed, objId);\r\n        // generate base stat for the previous one\r\n        for (uint i=0; i < STAT_COUNT; i+= 1) {\r\n            value = uint8(seed % STAT_MAX) + data.getElementInArrayType(EthermonEnum.ArrayType.STAT_START, uint64(_classId), i);\r\n            data.addElementToArrayType(EthermonEnum.ArrayType.STAT_BASE, objId, value);\r\n        }\r\n        \r\n        emit Transfer(address(0), _player, objId);\r\n\r\n        return objId; \r\n    }\r\n    \r\n    \r\n}\r\n", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newModerator\",\"type\":\"address\"}],\"name\":\"AddModerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ChangeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC712_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAT_COUNT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAT_MAX\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"battleContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_tokenId\",\"type\":\"uint64\"}],\"name\":\"burnMonster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_classId\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"catchMonster\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"clearApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gapFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genLevelExp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDomainSeperator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"exp\",\"type\":\"uint32\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_monsterId\",\"type\":\"uint64\"}],\"name\":\"getMonsterBaseStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_monsterId\",\"type\":\"uint64\"}],\"name\":\"getMonsterCP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_classId\",\"type\":\"uint32\"}],\"name\":\"getMonsterClassBasic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_monsterId\",\"type\":\"uint64\"}],\"name\":\"getMonsterCurrentStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"exp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"speed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_classId\",\"type\":\"uint32\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"catchable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getRandom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isApprovable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMaintaining\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelExps\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_classId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_trainer\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"mintMonster\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"moderators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceIncreasingRatio\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_objId\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"renameMonster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartcontract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAddressWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_classId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setClassWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gapFactor\",\"type\":\"uint256\"}],\"name\":\"setFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dataContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_battleContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tradeContract\",\"type\":\"address\"}],\"name\":\"setOperationContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_ratio\",\"type\":\"uint16\"}],\"name\":\"setPriceIncreasingRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalModerators\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"triggerTransferEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sendTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EtheremonMonsterToken", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000000000000000000000000000000000000000000845544845524d4f4e000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}