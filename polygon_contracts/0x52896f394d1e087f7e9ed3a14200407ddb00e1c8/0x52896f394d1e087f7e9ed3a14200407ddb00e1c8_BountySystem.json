{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Farms/BountySystem.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.14;\\r\\n\\r\\n\\r\\n/** Interfaces */\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    \\r\\n    function symbol() external view returns(string memory);\\r\\n    \\r\\n    function name() external view returns(string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the number of decimal places\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Owner\\r\\n * @dev Set & change owner\\r\\n */\\r\\ncontract Ownable {\\r\\n\\r\\n    address private owner;\\r\\n    \\r\\n    // event for EVM logging\\r\\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\\r\\n    \\r\\n    // modifier to check if caller is owner\\r\\n    modifier onlyOwner() {\\r\\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\\r\\n        // changes to the state and to Ether balances are reverted.\\r\\n        // This used to consume all gas in old EVM versions, but not anymore.\\r\\n        // It is often a good idea to use 'require' to check if functions are called correctly.\\r\\n        // As a second argument, you can also provide an explanation about what went wrong.\\r\\n        require(msg.sender == owner, \\\"Caller is not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Set contract deployer as owner\\r\\n     */\\r\\n    constructor() {\\r\\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\\r\\n        emit OwnerSet(address(0), owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Change owner\\r\\n     * @param newOwner address of new owner\\r\\n     */\\r\\n    function changeOwner(address newOwner) public onlyOwner {\\r\\n        emit OwnerSet(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return owner address \\r\\n     * @return address of owner\\r\\n     */\\r\\n    function getOwner() external view returns (address) {\\r\\n        return owner;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IMultiClaim {\\r\\n    function multiClaim(uint256 iterations) external;\\r\\n}\\r\\n\\r\\ninterface ISTS {\\r\\n    function sellFeeRecipient() external view returns (address);\\r\\n    function buyFeeRecipient() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IFeeReceiver {\\r\\n    function trigger() external;\\r\\n}\\r\\n\\r\\ninterface INFT {\\r\\n    function claimRewards(uint256 iterations) external;\\r\\n}\\r\\n\\r\\ncontract BountySystem is Ownable {\\r\\n\\r\\n    /** UINT */\\r\\n    uint256 public iterations;\\r\\n    uint256 public bountyBleed = 300; // 30% of STS in this contract\\r\\n\\r\\n    /** ADDRESS */\\r\\n    address public immutable STS;\\r\\n\\r\\n    address public staking;\\r\\n    address public farming0;\\r\\n    address public farming1;\\r\\n    address public NFT;\\r\\n\\r\\n    /** BOOL */\\r\\n    /** Restricts the bounty to a list of allowed wallets if true, open to the public if false */\\r\\n    bool public privateBounty = true;\\r\\n\\r\\n    /** MAPPING */\\r\\n    mapping ( address => bool ) public approvedForPrivateBounty;\\r\\n\\r\\n\\r\\n    /** EVENTS */\\r\\n    event FarmsTriggered();\\r\\n    event FeeReceiversTriggered();\\r\\n    event BountyBleedSet(uint bleed);\\r\\n    event IterationsSet(uint iterations);\\r\\n    event PrivateBountySet(bool isPrivate);\\r\\n    event NFTTriggered(uint256 nftIterations);\\r\\n    event SystemTriggered(uint256 nftIterations);\\r\\n    event Withdrawn(address indexed token, uint256 amount);\\r\\n    event UserApprovedForPrivateBounty(address indexed user, bool isApproved);\\r\\n    event AddressesSet(address staking, address farming0, address farming1, address NFT);\\r\\n    event OwnerTriggered(uint256 iterations, uint256 nftIterations, uint256 bountyBleed);\\r\\n\\r\\n\\r\\n    /** CONSTRUCTOR */\\r\\n    constructor(address STS_, uint256 iterations_) {\\r\\n        require(STS_ != address(0), 'Zero Address');\\r\\n        STS = STS_;\\r\\n        iterations = iterations_;\\r\\n    }\\r\\n\\r\\n\\r\\n    /** EXTERNAL FUNCTIONS */\\r\\n    function setIsPrivateBounty(\\r\\n        bool isPrivateBounty\\r\\n        ) \\r\\n        external \\r\\n        onlyOwner \\r\\n    {\\r\\n        privateBounty = isPrivateBounty;\\r\\n\\r\\n        emit PrivateBountySet(isPrivateBounty);\\r\\n    }\\r\\n\\r\\n    function addToApprovedForPrivateBounty(\\r\\n        address user,\\r\\n        bool isApproved\\r\\n        ) \\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        approvedForPrivateBounty[user] = isApproved;\\r\\n        emit UserApprovedForPrivateBounty(user, isApproved);\\r\\n    }\\r\\n\\r\\n    function setIterations(\\r\\n        uint256 iterations_\\r\\n        )\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        iterations = iterations_;\\r\\n\\r\\n        emit IterationsSet(iterations_);\\r\\n    }\\r\\n\\r\\n    function setBountyBleed(\\r\\n        uint256 newBleed\\r\\n        ) \\r\\n        external \\r\\n        onlyOwner \\r\\n    {\\r\\n        bountyBleed = newBleed;\\r\\n\\r\\n        emit BountyBleedSet(newBleed);\\r\\n    }\\r\\n\\r\\n    function withdraw(\\r\\n        address token,\\r\\n        uint256 amount\\r\\n        ) \\r\\n        external\\r\\n        onlyOwner \\r\\n    {\\r\\n        IERC20(token).transfer(msg.sender, amount);\\r\\n\\r\\n        emit Withdrawn(token, amount);\\r\\n    }\\r\\n\\r\\n    function setAddresses(\\r\\n        address staking_,\\r\\n        address farming0_,\\r\\n        address farming1_,\\r\\n        address NFT_\\r\\n        ) \\r\\n        external \\r\\n        onlyOwner \\r\\n    {\\r\\n        staking = staking_;\\r\\n        farming0 = farming0_;\\r\\n        farming1 = farming1_;\\r\\n        NFT = NFT_;\\r\\n\\r\\n        emit AddressesSet(staking_, farming0_, farming1_, NFT_);\\r\\n    }\\r\\n\\r\\n    function ownerTrigger(\\r\\n        uint256 iterations_, \\r\\n        uint256 nftIterations_, \\r\\n        uint256 bountyBleed_\\r\\n        )\\r\\n        external\\r\\n        onlyOwner \\r\\n    {\\r\\n\\r\\n        // trigger fee recipients\\r\\n        triggerFeeReceivers();\\r\\n\\r\\n        // multi claim for various contracts\\r\\n        IMultiClaim(staking).multiClaim(iterations_);\\r\\n        IMultiClaim(farming0).multiClaim(iterations_);\\r\\n        IMultiClaim(farming1).multiClaim(iterations_);\\r\\n\\r\\n        // trigger NFT\\r\\n        INFT(NFT).claimRewards(nftIterations_);\\r\\n\\r\\n        // determine bounty bleed\\r\\n        uint256 bountyReward = ( IERC20(STS).balanceOf(address(this)) * bountyBleed_ ) / 1000;\\r\\n        if (bountyReward > 0) {\\r\\n            IERC20(STS).transfer(msg.sender, bountyReward);\\r\\n        }\\r\\n\\r\\n        emit OwnerTriggered(iterations_, nftIterations_, bountyBleed_);\\r\\n    }\\r\\n\\r\\n    function triggerFarms() \\r\\n    external \\r\\n    {\\r\\n        // ensure private bounty is preserved or not\\r\\n        if (privateBounty) {\\r\\n            require(approvedForPrivateBounty[msg.sender], 'Caller Not Approved To Trigger');\\r\\n        }\\r\\n\\r\\n        // trigger Fee Receivers\\r\\n        triggerFeeReceivers();\\r\\n\\r\\n        // determine bounty rewards\\r\\n        uint256 bountyReward = currentBounty();\\r\\n\\r\\n        // multi claim for various contracts\\r\\n        IMultiClaim(staking).multiClaim(iterations);\\r\\n        IMultiClaim(farming0).multiClaim(iterations);\\r\\n        IMultiClaim(farming1).multiClaim(iterations);\\r\\n\\r\\n        // send bounty reward to msg.sender\\r\\n        if (bountyReward > 0) {\\r\\n            IERC20(STS).transfer(msg.sender, bountyReward);\\r\\n        }\\r\\n\\r\\n        emit FarmsTriggered();\\r\\n    }\\r\\n\\r\\n    function triggerNFT(\\r\\n        uint256 nftIterations\\r\\n        ) \\r\\n        external \\r\\n    {\\r\\n\\r\\n        // ensure private bounty is preserved or not\\r\\n        if (privateBounty) {\\r\\n            require(approvedForPrivateBounty[msg.sender], 'Caller Not Approved To Trigger');\\r\\n        }\\r\\n\\r\\n        INFT(NFT).claimRewards(nftIterations);\\r\\n\\r\\n        emit NFTTriggered(nftIterations);\\r\\n    }\\r\\n\\r\\n    function triggerFeeReceivers() \\r\\n        public \\r\\n    {\\r\\n        IFeeReceiver(ISTS(STS).buyFeeRecipient()).trigger();\\r\\n        IFeeReceiver(ISTS(STS).sellFeeRecipient()).trigger();\\r\\n\\r\\n        emit FeeReceiversTriggered();\\r\\n    }\\r\\n\\r\\n    function trigger(\\r\\n        uint256 nftIterations\\r\\n        ) \\r\\n        external \\r\\n    {\\r\\n\\r\\n        // ensure private bounty is preserved or not\\r\\n        if (privateBounty) {\\r\\n            require(approvedForPrivateBounty[msg.sender], 'Caller Not Approved To Trigger');\\r\\n        }\\r\\n\\r\\n        // trigger receivers\\r\\n        triggerFeeReceivers();\\r\\n\\r\\n        // multi claim for various contracts\\r\\n        IMultiClaim(staking).multiClaim(iterations);\\r\\n        IMultiClaim(farming0).multiClaim(iterations);\\r\\n        IMultiClaim(farming1).multiClaim(iterations);\\r\\n\\r\\n        // trigger NFT\\r\\n        INFT(NFT).claimRewards(nftIterations);\\r\\n\\r\\n        // determine bounty rewards\\r\\n        uint256 bountyReward = currentBounty();\\r\\n\\r\\n        // send bounty reward to caller\\r\\n        if (bountyReward > 0) {\\r\\n            IERC20(STS).transfer(msg.sender, bountyReward);\\r\\n        }\\r\\n\\r\\n        emit SystemTriggered(nftIterations);\\r\\n    }\\r\\n\\r\\n\\r\\n    function currentBounty() \\r\\n        public\\r\\n        view\\r\\n        returns (uint256) {\\r\\n            return (IERC20(STS).balanceOf(address(this)) * bountyBleed ) / 1000;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"STS_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"iterations_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staking\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"farming0\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"farming1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"NFT\",\"type\":\"address\"}],\"name\":\"AddressesSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bleed\",\"type\":\"uint256\"}],\"name\":\"BountyBleedSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FarmsTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FeeReceiversTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"}],\"name\":\"IterationsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftIterations\",\"type\":\"uint256\"}],\"name\":\"NFTTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftIterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bountyBleed\",\"type\":\"uint256\"}],\"name\":\"OwnerTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPrivate\",\"type\":\"bool\"}],\"name\":\"PrivateBountySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftIterations\",\"type\":\"uint256\"}],\"name\":\"SystemTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"UserApprovedForPrivateBounty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"addToApprovedForPrivateBounty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedForPrivateBounty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bountyBleed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentBounty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farming0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farming1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iterations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"iterations_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftIterations_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bountyBleed_\",\"type\":\"uint256\"}],\"name\":\"ownerTrigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"privateBounty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staking_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"farming0_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"farming1_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"NFT_\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBleed\",\"type\":\"uint256\"}],\"name\":\"setBountyBleed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPrivateBounty\",\"type\":\"bool\"}],\"name\":\"setIsPrivateBounty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"iterations_\",\"type\":\"uint256\"}],\"name\":\"setIterations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftIterations\",\"type\":\"uint256\"}],\"name\":\"trigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerFarms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftIterations\",\"type\":\"uint256\"}],\"name\":\"triggerNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BountySystem", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000045ab8afc660b6c78b7de02cff88e963e34f794180000000000000000000000000000000000000000000000000000000000000064", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}