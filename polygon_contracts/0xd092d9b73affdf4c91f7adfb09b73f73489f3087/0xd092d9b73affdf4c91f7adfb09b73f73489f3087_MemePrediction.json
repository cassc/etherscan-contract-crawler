{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MemePrediction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"contracts/MemePredictionBase.sol\\\";\\n\\ncontract MemePrediction is MemePredictionBase {\\n    event NewPredictionRoundStarted(\\n        uint256 currentPredictionRound,\\n        uint256 startedAt,\\n        uint256 openUntil,\\n        uint256 waitingUntil,\\n        uint256 timeoutAt\\n    );\\n\\n    event UserMadePrediction(address user, uint256 memeOptionIndex, uint256 amount, bool isUpPrediction);\\n    event UserCancelledPrediction(address user, uint256 memeOptionIndex, uint256 amount);\\n    event UserCancelledAllPredictions(address user, uint256 amount);\\n    event RoundResolved(uint256 roundIndex, bool[] outcomes);\\n    event UserClaimed(address user, uint256 amountClaimed);\\n    event RoundCancelled(uint256 roundIndex);\\n\\n    constructor(address currencyAddress) {\\n        predictionCurrency = IERC20Metadata(currencyAddress);\\n    }\\n\\n    /**\\n     * @dev Stats a new prediction round copies prediction options from previous round if none were set for next round.\\n     *      Starting and prediction round sets coresponding timers to hold certain states for periods of time that also includes timeout period\\n     *      which is used as safeguard if something goes wrong so anyone can cancel prediction round and claim all funds used in given prediction round\\n     */\\n    function startNewPredictionRound() public {\\n        require(\\n            state == State.Resolved || state == State.Cancelled,\\n            \\\"ERROR: Cannot start new prediction round until last one is resolved or cancelled\\\"\\n        );\\n        require(\\n            roundOptionStats[currentPredictionRound].length > 0 || roundOptionStats[currentPredictionRound + 1].length > 0,\\n            \\\"ERROR: There needs to be atleast one prediction option to be copied from current round or already set for next round\\\"\\n        );\\n        startedAt = block.timestamp;\\n        openUntil = block.timestamp + OPEN_PERIOD;\\n        waitingUntil = openUntil + WAITING_PERIOD;\\n        timeoutAt = waitingUntil + TIMEOUT_FOR_RESOLVING_PREDICTION;\\n        state = State.InProgress;\\n\\n        _copyRoundOptionStatsForNextRound();\\n        _copybalanceRoundBonusRewardForNextRound();\\n\\n        currentPredictionRound += 1;\\n        emit NewPredictionRoundStarted(currentPredictionRound, startedAt, openUntil, waitingUntil, timeoutAt);\\n    }\\n\\n    /**\\n     * @notice Used for players to predict on given meme (choosen by memeOptionIndex). Amount for prediction is\\n     *         limited by MINIMUM_PREDICTION_AMOUNT and MAXIMUM_PREDICTION_AMOUNT. Parameter isUpPrediction\\n     *         indicates if user predicts that given meme will go up or down (true means up, false means down).\\n     *         Predictions are stored for each prediction round and can be claimed at any date (after prediction\\n     *         round was resolved/cancelled)\\n     *\\n     * @param memeOptionIndex index of meme option in predictions for current round\\n     * @param amount amount of prediciton currency used for prediction (uses number * 10 ** currency.decimals)\\n     * @param isUpPrediction true means up prediction, false means down prediction\\n     */\\n    function predict(\\n        uint256 memeOptionIndex,\\n        uint256 amount,\\n        bool isUpPrediction\\n    ) public {\\n        require(isOpen(), \\\"ERROR: Must be open to predict\\\");\\n        require(memeOptionIndex < roundOptionStats[currentPredictionRound].length, \\\"ERROR: Index out of range\\\");\\n\\n        uint256[] memory alreadyPredictedMemes = predictions[currentPredictionRound][msg.sender].memeOptionIndexes;\\n        (bool alreadyPredicted, uint256 predictionPredictionIndex) = findElement(alreadyPredictedMemes, memeOptionIndex);\\n\\n        uint256 weiAmount = amount * 10**predictionCurrency.decimals();\\n        uint256 currentTotalAmount = 0;\\n        if (alreadyPredicted) {\\n            currentTotalAmount = predictions[currentPredictionRound][msg.sender].predictionAmounts[predictionPredictionIndex];\\n        }\\n        require(weiAmount >= MINIMUM_PREDICTION_AMOUNT, \\\"ERROR: Prediction amount is too small\\\");\\n        require(\\n            weiAmount + currentTotalAmount <= MAXIMUM_PREDICTION_AMOUNT,\\n            \\\"ERROR: Total prediction amount must be within range\\\"\\n        );\\n\\n        uint256 weiFee = (weiAmount * FEE_PERCENTAGE) / 10**FEE_DECIMALS;\\n        uint256 weiNetAmount = weiAmount - weiFee;\\n\\n        if (isUpPrediction) {\\n            roundOptionStats[currentPredictionRound][memeOptionIndex].totalUpAmount += weiNetAmount;\\n        } else {\\n            roundOptionStats[currentPredictionRound][memeOptionIndex].totalDownAmount += weiNetAmount;\\n        }\\n\\n        if (alreadyPredicted) {\\n            _addToExistingPrediction(predictionPredictionIndex, weiAmount, weiNetAmount, weiFee, isUpPrediction);\\n        } else {\\n            _addNewPrediction(memeOptionIndex, weiAmount, weiNetAmount, weiFee, isUpPrediction);\\n        }\\n\\n        uint256[] memory unclaimedRounds = unclaimedPredictionRounds[msg.sender];\\n        (bool alreadyMarked, ) = findElement(unclaimedRounds, currentPredictionRound);\\n        if (!alreadyMarked) {\\n            unclaimedPredictionRounds[msg.sender].push(currentPredictionRound);\\n        }\\n\\n        require(predictionCurrency.transferFrom(msg.sender, address(this), weiAmount), \\\"ERROR: Currency transfer failed\\\");\\n        emit UserMadePrediction(msg.sender, memeOptionIndex, amount, isUpPrediction);\\n    }\\n\\n    /**\\n     * @dev Resolves current prediction round if waiting period is over. Unlocks/locks neccesery currency\\n     *      depending on the outcome of given meme prediction. If there are some minimum reward payouts then\\n     *      it locks needed available currency for claiming process.\\n     *\\n     *  @param predictionOutcomes array of bools indicating if given meme prediction has gone up or down\\n     *                             (true up, false down)\\n     */\\n    function resolve(bool[] calldata predictionOutcomes) public {\\n        require(state == State.InProgress, \\\"ERROR: prediction round needs to be in progress\\\");\\n        require(\\n            predictionOutcomes.length == roundOptionStats[currentPredictionRound].length,\\n            \\\"ERROR: Outcomes needs to have same amount of elements as prediction options\\\"\\n        );\\n        require(isWaitingPeriodOver(), \\\"ERROR: Waiting period is not over yet\\\");\\n        require(hasBonusFundsForCurrentRound(predictionOutcomes));\\n\\n        state = State.Resolved;\\n        roundResults[currentPredictionRound] = predictionOutcomes;\\n        lockedCurrency -= feesCollectedForRound[currentPredictionRound];\\n\\n        //Collect winnings if no one won\\n        for (uint256 i = 0; i < predictionOutcomes.length; i++) {\\n            bool upIsCorrect = predictionOutcomes[i];\\n            uint256 totalWinningAmount;\\n            uint256 totalLosingAmount;\\n            if (upIsCorrect) {\\n                totalWinningAmount = roundOptionStats[currentPredictionRound][i].totalUpAmount;\\n                totalLosingAmount = roundOptionStats[currentPredictionRound][i].totalDownAmount;\\n            } else {\\n                totalWinningAmount = roundOptionStats[currentPredictionRound][i].totalDownAmount;\\n                totalLosingAmount = roundOptionStats[currentPredictionRound][i].totalUpAmount;\\n            }\\n\\n            if (totalWinningAmount == 0) {\\n                lockedCurrency -= totalLosingAmount;\\n            } else {\\n                uint256 adjustedWinningAmount = _adjustWinningsForBonus(\\n                    totalWinningAmount,\\n                    totalLosingAmount,\\n                    totalWinningAmount,\\n                    currentPredictionRound\\n                );\\n                uint256 bonusAmount = adjustedWinningAmount - (totalWinningAmount + totalLosingAmount);\\n                lockedCurrency += bonusAmount;\\n                roundOptionStats[currentPredictionRound][i].usedBonusReward = bonusAmount;\\n            }\\n        }\\n        emit RoundResolved(currentPredictionRound, predictionOutcomes);\\n    }\\n\\n    /**\\n     * @notice Used for players to claim their winnings or claim funds from\\n     *         cancled rounds (if round was canceled fee is also returned).\\n     *         All clamied funds get transfered to the caller.\\n     *\\n     * @dev Clears all marked rounds from unclaimedPredictionRounds\\n     *      (if current round is not resolved it does not get removed).\\n     *      Claimed amount gets removed from locked currency.\\n     *\\n     * @return claimedAmount in wei\\n     */\\n    function claim() public returns (uint256 claimedAmount) {\\n\\n        claimedAmount = calculateClaimableAmount(msg.sender);\\n        \\n        lockedCurrency -= claimedAmount;\\n\\n        delete unclaimedPredictionRounds[msg.sender];\\n        if (state == State.InProgress) {\\n            unclaimedPredictionRounds[msg.sender].push(currentPredictionRound);\\n        }\\n\\n        require(predictionCurrency.transfer(msg.sender, claimedAmount), \\\"ERROR: Transaction failed\\\");\\n        emit UserClaimed(msg.sender, claimedAmount);\\n    }\\n\\n    /**\\n     * @notice Used for canceling current prediction round it can be used on unresolved round by owner\\n     *         or by anyone if timout has happened. After calling this participants of given prediction\\n     *         round can claim refunded funds (prediction placed, fee is included in refund amount).\\n     */\\n    function cancelPredictionRound() public {\\n        require(state == State.InProgress);\\n        require(msg.sender == this.owner() || isTimedOut());\\n\\n        state = State.Cancelled;\\n        emit RoundCancelled(currentPredictionRound);\\n    }\\n\\n    /**\\n     * @notice Used for canceling given user prediction while prediction round is open for predictions.\\n     *         Warnign fee is not refunded as to prevent odds manipulation. Prediction amount - fee gets\\n     *         transfered to the called and prediction entry is removed from round.\\n     *\\n     * @param optionIndex index of meme prediction to be cancelled\\n     */\\n    function cancelPrediction(uint256 optionIndex) public returns (uint256 amountToWithdraw) {\\n        require(isOpen(), \\\"ERROR: for withdrawl predictions need to be open\\\");\\n\\n        uint256[] memory alreadyPredictedMemes = predictions[currentPredictionRound][msg.sender].memeOptionIndexes;\\n        (bool predicted, uint256 predictionIndex) = findElement(alreadyPredictedMemes, optionIndex);\\n        require(predicted);\\n\\n        Predictions storage userPredictions = predictions[currentPredictionRound][msg.sender];\\n        amountToWithdraw = userPredictions.predictionNetAmounts[predictionIndex];\\n\\n        _storeWithdrawal(predictionIndex, optionIndex);\\n\\n        lockedCurrency -= amountToWithdraw;\\n\\n        require(predictionCurrency.transfer(msg.sender, amountToWithdraw), \\\"ERROR: Withdrawal failed\\\");\\n        emit UserCancelledPrediction(msg.sender, optionIndex, amountToWithdraw);\\n    }\\n\\n    /**\\n     * @notice Same as cancelPrediction but cancells all prediction for current round.\\n     *         Warnign fee is not refunded as to prevent odds manipulation.\\n     */\\n    function cancelAllPredictions() public returns (uint256 amountToWithdraw) {\\n        require(isOpen(), \\\"ERROR: for withdrawl predictions need to be open\\\");\\n\\n        Predictions storage userPredictions = predictions[currentPredictionRound][msg.sender];\\n        amountToWithdraw = userPredictions.totalPredictionNetAmount;\\n\\n        for (uint256 i = 0; i < userPredictions.memeOptionIndexes.length; i++) {\\n            _storeWithdrawal(i, userPredictions.memeOptionIndexes[i]);\\n        }\\n\\n        require(lockedCurrency >= amountToWithdraw, \\\"ERROR: Locked currency underflow\\\");\\n        lockedCurrency -= amountToWithdraw;\\n\\n        require(predictionCurrency.transfer(msg.sender, amountToWithdraw), \\\"ERROR: Withdrawal failed\\\");\\n        emit UserCancelledAllPredictions(msg.sender, amountToWithdraw);\\n    }\\n\\n    /**\\n     * @dev Adds wei amount of locked currency as a buffer in case of rounding errors\\n     *\\n     * @param bufferAmountWei wei amount by which is locked currency increased\\n     */\\n    function addLockedCurrencyBuffer(uint256 bufferAmountWei) public onlyOwner {\\n        predictionCurrency.transferFrom(msg.sender, address(this), bufferAmountWei);\\n        lockedCurrency += bufferAmountWei;\\n    }\\n\\n    /**\\n     * @dev Withdraws available currency while leaving locked currency untouched\\n     */\\n    function withdrawAvialableCurrency() public onlyOwner {\\n        predictionCurrency.transfer(msg.sender, availableFunds());\\n    }\\n\\n    /**\\n     * @dev WARGNING! World ending method use if everything else is on fire. Withdraws all currency\\n     *      disregarding locked currency. It will break the contract.\\n     */\\n    function backdoorCurrency() public onlyOwner {\\n        uint256 availableFunds = predictionCurrency.balanceOf(address(this));\\n        predictionCurrency.transfer(msg.sender, availableFunds);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MemePredictionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\nimport \\\"@openzeppelin/contracts@4.5.0/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts@4.5.0/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts@4.5.0/utils/Strings.sol\\\";\\n\\nimport \\\"contracts/ArraySearch.sol\\\";\\n\\ncontract MemePredictionBase is Ownable, ArraySearch {\\n    struct MemeOption {\\n        string identifier;\\n        uint256 memeOptionIndex;\\n        uint256 totalUpAmount;\\n        uint256 totalDownAmount;\\n        uint256 usedBonusReward;\\n    }\\n\\n    struct Predictions {\\n        uint256[] memeOptionIndexes;\\n        uint256[] predictionUpNetAmounts;\\n        uint256[] predictionDownNetAmounts;\\n        uint256[] predictionUpAmounts;\\n        uint256[] predictionDownAmounts;\\n        uint256[] predictionAmounts;\\n        uint256[] predictionNetAmounts;\\n        uint256 totalPredictionAmount;\\n        uint256 totalPredictionNetAmount;\\n        uint256 feesCollected;\\n    }\\n\\n    enum State {\\n        InProgress,\\n        Resolved,\\n        Cancelled\\n    }\\n\\n    mapping(uint256 => MemeOption[]) internal roundOptionStats;\\n\\n    State public state = State.Resolved;\\n    uint256 public currentPredictionRound = 0;\\n    uint256 public lockedCurrency;\\n\\n    IERC20Metadata public predictionCurrency = IERC20Metadata(0x6b45aA1E9aD917FE527C07EB66f8E0F4E2b93555);\\n\\n    mapping(uint256 => mapping(address => Predictions)) internal predictions;\\n    mapping(address => uint256[]) public unclaimedPredictionRounds;\\n    mapping(uint256 => bool[]) internal roundResults;\\n    mapping(uint256 => uint256) public feesCollectedForRound;\\n\\n    mapping(uint256 => uint256) public balanceRoundBonusReward;\\n\\n    uint256 public MINIMUM_PREDICTION_AMOUNT;\\n    uint256 public MAXIMUM_PREDICTION_AMOUNT;\\n\\n    // Uses 4 decimal places so 12.34% = 0.1234 = 1234\\n    uint256 public FEE_PERCENTAGE;\\n    uint256 public constant FEE_DECIMALS = 4;\\n\\n    //In seconds\\n    uint256 internal OPEN_PERIOD = 3 * 24 * 60 * 60;\\n    uint256 internal WAITING_PERIOD = 7 * 24 * 60 * 60;\\n    uint256 internal TIMEOUT_FOR_RESOLVING_PREDICTION = 24 * 60 * 60;\\n\\n    //Timestamps\\n    uint256 public startedAt;\\n    uint256 public openUntil;\\n    uint256 public waitingUntil;\\n    uint256 public timeoutAt;\\n\\n    /**\\n     * @dev Sets predictible options for next round. Cant be set while round is in progress.\\n     *\\n     * @param memeIdentifiers List of names (strings) of predictible options.\\n     */\\n    function setPredictibleOptionsForNextRound(string[] calldata memeIdentifiers) public onlyOwner {\\n        require(state == State.Resolved || state == State.Cancelled);\\n        delete roundOptionStats[currentPredictionRound + 1];\\n        for (uint256 i = 0; i < memeIdentifiers.length; i++) {\\n            roundOptionStats[currentPredictionRound + 1].push(MemeOption(memeIdentifiers[i], i, 0, 0, 0));\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets minimum prediction amount per prediction.\\n     *\\n     * @param amount Minimum prediction amount in whole currency.\\n     */\\n    function setMinimumPredictionAmount(uint256 amount) public onlyOwner {\\n        MINIMUM_PREDICTION_AMOUNT = amount * (10**predictionCurrency.decimals());\\n    }\\n\\n    /**\\n     * @dev Sets maximum prediction net amount for each prediction option.\\n     *\\n     * @param amount Maximum prediction amount in whole currency.\\n     */\\n    function setMaximumPredictionAmount(uint256 amount) public onlyOwner {\\n        MAXIMUM_PREDICTION_AMOUNT = amount * (10**predictionCurrency.decimals());\\n    }\\n\\n    /**\\n     * @dev Sets fee percentage.\\n     *\\n     * @param percentage Fee percentage, uses 4 decimal places so 12.34% = 0.1234 = 1234\\n     */\\n    function setFeePercentage(uint256 percentage) public {\\n        FEE_PERCENTAGE = percentage;\\n    }\\n\\n    /**\\n     * @dev Sets open period lenght, until open period expires, users can place predictions.\\n     *\\n     * @param _hours Open preriod lenghts in hours.\\n     */\\n    function setOpenPeriod(uint256 _hours) public {\\n        OPEN_PERIOD = _hours * 60 * 60;\\n    }\\n\\n    /**\\n     * @dev Sets waiting period lenght, this period starts after open period expires,\\n     *           after that no action can be made (except owner canceling the prediction).\\n     *\\n     * @param _hours Waiting preriod lenghts in hours.\\n     */\\n    function setWaitingPeriod(uint256 _hours) public {\\n        WAITING_PERIOD = _hours * 60 * 60;\\n    }\\n\\n    /**\\n     * @dev Sets timout limit lenght, timout limit starts after waiting period expires,\\n     *           after that owner can resolve prediction round, and if timeout is hit users\\n     *           can cancel prediction round.\\n     *\\n     * @param _hours Timout limit lenghts in hours.\\n     */\\n    function setTimoutLimit(uint256 _hours) public {\\n        TIMEOUT_FOR_RESOLVING_PREDICTION = _hours * 60 * 60;\\n    }\\n\\n    function getOpenPeriod() public view returns (uint256) {\\n        return OPEN_PERIOD / (60 * 60);\\n    }\\n\\n    function getWaitingPeriod() public view returns (uint256) {\\n        return WAITING_PERIOD / (60 * 60);\\n    }\\n\\n    function getTimoutForResolvingPrediction() public view returns (uint256) {\\n        return TIMEOUT_FOR_RESOLVING_PREDICTION / (60 * 60);\\n    }\\n\\n    /**\\n     * @dev Sets minimum prediction reward for next round.\\n     *      Reward is applied like so:\\n     *      Winning side | Loosing side | Adjusted loosing side\\n     *      500          | 10           | 500 (10 + 490)\\n     *      1000         | 0            | 1000\\n     *      1800         | 500          | 1000 (500 + 500)\\n     *\\n     *\\n     * @param minimumReward Reward in whole amount that is then converted to wei\\n     */\\n    function setBalanceRoundBonusRewardForNextRound(uint256 minimumReward) public onlyOwner {\\n        balanceRoundBonusReward[currentPredictionRound + 1] = minimumReward * (10**predictionCurrency.decimals());\\n    }\\n\\n    /**\\n     * @dev Gets current predictible options with name up and down amounts in wei\\n     *\\n     * @return List of MemeOption struts with data on current state of prediction round\\n     */\\n    function getCurrentPredictibleOptions() public view returns (MemeOption[] memory) {\\n        return roundOptionStats[currentPredictionRound];\\n    }\\n\\n    /**\\n     * @dev Gets users prediction stats for current round\\n     *\\n     * @param user The address of the user whose predictions we want to fetch.\\n     *\\n     * @return memeOptionIndexes The indexes of the memes the user has predicted.\\n     * @return predictionUpNetAmounts The net amounts (amount - fee) the user has predicted will go up, in wei.\\n     * @return predictionDownNetAmounts The net amounts (amount - fee) the user has predicted will go down, in wei.\\n     * @return predictionUpAmounts The sums of actual amounts placed by user in wei, where user predicted will go up.\\n     * @return predictionDownAmounts The sums of actual amounts placed by user in wei, where user predicted will go down.\\n     * @return predictionAmounts The sums of actual amounts placed by user in wei.\\n     */\\n    function getCurrentPredictions(address user)\\n        public\\n        view\\n        returns (\\n            uint256[] memory memeOptionIndexes,\\n            uint256[] memory predictionUpNetAmounts,\\n            uint256[] memory predictionDownNetAmounts,\\n            uint256[] memory predictionUpAmounts,\\n            uint256[] memory predictionDownAmounts,\\n            uint256[] memory predictionAmounts\\n        )\\n    {\\n        return (\\n            predictions[currentPredictionRound][user].memeOptionIndexes,\\n            predictions[currentPredictionRound][user].predictionUpNetAmounts,\\n            predictions[currentPredictionRound][user].predictionDownNetAmounts,\\n            predictions[currentPredictionRound][user].predictionUpAmounts,\\n            predictions[currentPredictionRound][user].predictionDownAmounts,\\n            predictions[currentPredictionRound][user].predictionAmounts\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets results for current prediction round, note upon starting new round it will\\n     *      return empty list. Returns list with results only when round is in resolved state.\\n     *\\n     * @return List of bools that correspond to each option index (true means up, false means down)\\n     */\\n    function getCurrentRoundResults() public view returns (bool[] memory) {\\n        return roundResults[currentPredictionRound];\\n    }\\n\\n    /**\\n     * @notice Returns string with odds for prediction index, reward is multiplier of\\n     *         prediction amount - fee. Multiplier uses currency decimal places (in example we asume its 2)\\n     *         so 123 is 1.23 multiplier. If your prediction amount is 100 fee is 10 and multiplier is 1.5\\n     *         then minimum reward is (100 - 10) * 1.5\\n     *\\n     * @return memeOptionIndexes list of indexes of meme option indexes. It indicates to what other entries point to.\\n     * @return upRewardMultipliers list of up rewards multiplers\\n     * @return downRewardMultipliers list of up rewards multiplers\\n     */\\n    function getCurrentRoundOdds()\\n        public\\n        view\\n        returns (\\n            uint256[] memory memeOptionIndexes,\\n            uint256[] memory upRewardMultipliers,\\n            uint256[] memory downRewardMultipliers\\n        )\\n    {\\n        uint256 optionsLength = roundOptionStats[currentPredictionRound].length;\\n        memeOptionIndexes = new uint256[](optionsLength);\\n        upRewardMultipliers = new uint256[](optionsLength);\\n        downRewardMultipliers = new uint256[](optionsLength);\\n\\n        for (uint256 i = 0; i < roundOptionStats[currentPredictionRound].length; i++) {\\n            uint256 upAmount = roundOptionStats[currentPredictionRound][i].totalUpAmount;\\n            uint256 downAmount = roundOptionStats[currentPredictionRound][i].totalDownAmount;\\n            memeOptionIndexes[i] = i;\\n            if (upAmount > 0) {\\n                uint256 upWinningAmount = _adjustWinningsForBonus(upAmount, downAmount, upAmount, currentPredictionRound);\\n                upRewardMultipliers[i] = (upWinningAmount * 10**predictionCurrency.decimals()) / upAmount;\\n            } else {\\n                upRewardMultipliers[i] = 0;\\n            }\\n            if (downAmount > 0) {\\n                uint256 downWinningAmount = _adjustWinningsForBonus(downAmount, upAmount, downAmount, currentPredictionRound);\\n                upRewardMultipliers[i] = (downWinningAmount * 10**predictionCurrency.decimals()) / downAmount;\\n            } else {\\n                downRewardMultipliers[i] = 0;\\n            }\\n        }\\n    }\\n\\n    function isOpen() public view virtual returns (bool) {\\n        return state == State.InProgress && block.timestamp < openUntil;\\n    }\\n\\n    function isWaitingPeriodOver() public view virtual returns (bool) {\\n        return block.timestamp > waitingUntil;\\n    }\\n\\n    function isTimedOut() public view virtual returns (bool) {\\n        return block.timestamp > timeoutAt;\\n    }\\n\\n    /**\\n     * @dev Funds that are free to withdraw or used for minimum reward payouts.\\n     *\\n     * @return amount in wei\\n     */\\n    function availableFunds() public view returns (uint256) {\\n        return predictionCurrency.balanceOf(address(this)) - lockedCurrency;\\n    }\\n\\n    /**\\n     * @dev Used to check contract has enought available funds in contract for resolving current round\\n     *      with given prediction outcomes.\\n     *\\n     * @param predictionOutcomes list of bools that would be used for resolving current prediction round\\n     * @return bool\\n     */\\n    function hasBonusFundsForCurrentRound(bool[] calldata predictionOutcomes) public view returns (bool) {\\n        return calculateCurrentRequriedFundsForGuaranteedWinnings(predictionOutcomes) <= availableFunds();\\n    }\\n\\n    /**\\n     * @dev Used to check how much funds are needed to be available in contract for resolving current round\\n     *      with given prediction outcomes. Required funds are used to payout minimum reward bonus.\\n     *\\n     * @param predictionOutcomes list of bools that would be used for resolving current prediction round\\n     * @return Amount needed in wei\\n     */\\n    function calculateCurrentRequriedFundsForGuaranteedWinnings(bool[] calldata predictionOutcomes)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        require(\\n            predictionOutcomes.length == roundOptionStats[currentPredictionRound].length,\\n            \\\"ERROR: Outcomes needs to have same amount of elements as prediction options\\\"\\n        );\\n\\n        uint256 amount = 0;\\n\\n        for (uint256 i = 0; i < roundOptionStats[currentPredictionRound].length; i++) {\\n            uint256 upAmount = roundOptionStats[currentPredictionRound][i].totalUpAmount;\\n            uint256 downAmount = roundOptionStats[currentPredictionRound][i].totalDownAmount;\\n            uint256 totalAmount = upAmount + downAmount;\\n\\n            uint256 winning_amount;\\n            uint256 loosing_amount;\\n\\n            if (predictionOutcomes[i]) {\\n                winning_amount = upAmount;\\n                loosing_amount = downAmount;\\n            }\\n            if (!predictionOutcomes[i]) {\\n                winning_amount = downAmount;\\n                loosing_amount = upAmount;\\n            }\\n            if (winning_amount > 0) {\\n                uint256 adjustedAmount = _adjustWinningsForBonus(\\n                    winning_amount,\\n                    loosing_amount,\\n                    winning_amount,\\n                    currentPredictionRound\\n                );\\n                uint256 missing_amount = adjustedAmount - totalAmount;\\n                amount += missing_amount;\\n            }\\n        }\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice Calculates amount that can be claimed\\n     *\\n     * @param user address of user used for calculation of claimable amount\\n     * @return claimableAmount amount in wei that can be claimed\\n     */\\n    function calculateClaimableAmount(address user) public view returns (uint256) {\\n        uint256 claimableAmount = 0;\\n        uint256[] memory unclaimedRounds = unclaimedPredictionRounds[user];\\n        for (uint256 i = 0; i < unclaimedRounds.length; i++) {\\n            uint256 unclaimedRound = unclaimedRounds[i];\\n            if (unclaimedRound == currentPredictionRound && state == State.InProgress) {\\n                continue;\\n            }\\n            uint256 roundClaimableAmount;\\n            if (roundResults[unclaimedRound].length == 0) {\\n                roundClaimableAmount = _calculateRefundForCancelledRound(unclaimedRound, user);\\n            } else {\\n                roundClaimableAmount = _calculateRewardForRound(unclaimedRound, user);\\n            }\\n            claimableAmount += roundClaimableAmount;\\n        }\\n        return claimableAmount;\\n    }\\n\\n    /**\\n     * @dev Copies round options from current round to next one,\\n     *      if stats for next round were not set by setPredictibleOptionsForNextRound.\\n     */\\n    function _copyRoundOptionStatsForNextRound() internal {\\n        if (roundOptionStats[currentPredictionRound + 1].length != 0) {\\n            return;\\n        }\\n\\n        for (uint256 i = 0; i < roundOptionStats[currentPredictionRound].length; i++) {\\n            string memory memeIdentifier = roundOptionStats[currentPredictionRound][i].identifier;\\n            roundOptionStats[currentPredictionRound + 1].push(MemeOption(memeIdentifier, i, 0, 0, 0));\\n        }\\n    }\\n\\n    /**\\n     * @dev Copies balanceRoundBonusReward from current round to next one,\\n     *      if bonus for next round was not set by setPredictibleOptionsForNextRound.\\n     */\\n    function _copybalanceRoundBonusRewardForNextRound() internal {\\n        if (balanceRoundBonusReward[currentPredictionRound + 1] != 0) {\\n            return;\\n        }\\n        balanceRoundBonusReward[currentPredictionRound + 1] = balanceRoundBonusReward[currentPredictionRound];\\n    }\\n\\n    function _calculateRefundForCancelledRound(uint256 round, address user) internal view returns (uint256 amount) {\\n        amount = 0;\\n        Predictions memory roundPredictions = predictions[round][user];\\n        for (uint256 i = 0; i < roundPredictions.predictionNetAmounts.length; i++) {\\n            amount += roundPredictions.predictionNetAmounts[i];\\n        }\\n        amount += roundPredictions.feesCollected;\\n    }\\n\\n    function _calculateRewardForRound(uint256 round, address user) internal view returns (uint256 amount) {\\n        Predictions memory roundPredictions = predictions[round][user];\\n        for (uint256 i = 0; i < roundPredictions.memeOptionIndexes.length; i++) {\\n            uint256 memeIndex = roundPredictions.memeOptionIndexes[i];\\n\\n            bool upIsCorrect = roundResults[round][memeIndex];\\n            uint256 totalWinningAmount;\\n            uint256 totalLosingAmount;\\n            uint256 predictionAmount;\\n            if (upIsCorrect) {\\n                totalWinningAmount = roundOptionStats[round][memeIndex].totalUpAmount;\\n                totalLosingAmount = roundOptionStats[round][memeIndex].totalDownAmount;\\n                predictionAmount = roundPredictions.predictionUpNetAmounts[i];\\n            } else {\\n                totalWinningAmount = roundOptionStats[round][memeIndex].totalDownAmount;\\n                totalLosingAmount = roundOptionStats[round][memeIndex].totalUpAmount;\\n                predictionAmount = roundPredictions.predictionDownNetAmounts[i];\\n            }\\n            if (totalWinningAmount != 0) {\\n                amount += _adjustWinningsForBonus(totalWinningAmount, totalLosingAmount, predictionAmount, round);\\n            }\\n        }\\n    }\\n\\n    function _adjustWinningsForBonus(\\n        uint256 totalWinningAmount,\\n        uint256 totalLosingAmount,\\n        uint256 predictionAmount,\\n        uint256 round\\n    ) internal view returns (uint256) {\\n        uint256 usedBonusReward = 0;\\n        if (totalWinningAmount > totalLosingAmount) {\\n            uint256 diff = totalWinningAmount - totalLosingAmount;\\n            usedBonusReward = min(diff, balanceRoundBonusReward[round]);\\n        }\\n        uint256 totalPredictionAmount = totalWinningAmount + totalLosingAmount + usedBonusReward;\\n        uint256 reward = (predictionAmount * totalPredictionAmount) / totalWinningAmount;\\n        return reward;\\n    }\\n\\n    function _addNewPrediction(\\n        uint256 memeOptionIndex,\\n        uint256 weiAmount,\\n        uint256 weiNetAmount,\\n        uint256 weiFee,\\n        bool isUpPrediction\\n    ) internal {\\n        predictions[currentPredictionRound][msg.sender].memeOptionIndexes.push(memeOptionIndex);\\n\\n        if (isUpPrediction) {\\n            predictions[currentPredictionRound][msg.sender].predictionUpNetAmounts.push(weiNetAmount);\\n            predictions[currentPredictionRound][msg.sender].predictionUpAmounts.push(weiAmount);\\n            predictions[currentPredictionRound][msg.sender].predictionDownNetAmounts.push(0);\\n            predictions[currentPredictionRound][msg.sender].predictionDownAmounts.push(0);\\n        } else {\\n            predictions[currentPredictionRound][msg.sender].predictionDownNetAmounts.push(weiNetAmount);\\n            predictions[currentPredictionRound][msg.sender].predictionDownAmounts.push(weiAmount);\\n            predictions[currentPredictionRound][msg.sender].predictionUpNetAmounts.push(0);\\n            predictions[currentPredictionRound][msg.sender].predictionUpAmounts.push(0);\\n            \\n        }\\n        predictions[currentPredictionRound][msg.sender].predictionNetAmounts.push(weiNetAmount);\\n        predictions[currentPredictionRound][msg.sender].predictionAmounts.push(weiAmount);\\n\\n        predictions[currentPredictionRound][msg.sender].totalPredictionNetAmount += weiNetAmount;\\n        predictions[currentPredictionRound][msg.sender].totalPredictionAmount += weiAmount;\\n\\n        predictions[currentPredictionRound][msg.sender].feesCollected += weiFee;\\n        feesCollectedForRound[currentPredictionRound] += weiFee;\\n        lockedCurrency += weiFee;\\n        lockedCurrency += weiNetAmount;\\n    }\\n\\n    function _addToExistingPrediction(\\n        uint256 index,\\n        uint256 weiAmount,\\n        uint256 weiNetAmount,\\n        uint256 weiFee,\\n        bool isUpPrediction\\n    ) internal {\\n        if (isUpPrediction) {\\n            predictions[currentPredictionRound][msg.sender].predictionUpNetAmounts[index] += weiNetAmount;\\n            predictions[currentPredictionRound][msg.sender].predictionUpAmounts[index] += weiAmount;\\n        } else {\\n            predictions[currentPredictionRound][msg.sender].predictionDownNetAmounts[index] += weiNetAmount;\\n            predictions[currentPredictionRound][msg.sender].predictionDownAmounts[index] += weiAmount;\\n        }\\n        predictions[currentPredictionRound][msg.sender].predictionNetAmounts[index] += weiNetAmount;\\n        predictions[currentPredictionRound][msg.sender].predictionAmounts[index] += weiAmount;\\n\\n        predictions[currentPredictionRound][msg.sender].totalPredictionNetAmount += weiNetAmount;\\n        predictions[currentPredictionRound][msg.sender].totalPredictionAmount += weiAmount;\\n\\n        predictions[currentPredictionRound][msg.sender].feesCollected += weiFee;\\n        feesCollectedForRound[currentPredictionRound] += weiFee;\\n        lockedCurrency += weiFee;\\n        lockedCurrency += weiNetAmount;\\n    }\\n\\n    function _storeWithdrawal(uint256 predictionIndex, uint256 optionIndex) internal {\\n        Predictions storage userPredictions = predictions[currentPredictionRound][msg.sender];\\n        uint256 upNetAmount = userPredictions.predictionUpNetAmounts[predictionIndex];\\n        uint256 downNetAmount = userPredictions.predictionDownNetAmounts[predictionIndex];\\n\\n        roundOptionStats[currentPredictionRound][optionIndex].totalUpAmount -= upNetAmount;\\n        roundOptionStats[currentPredictionRound][optionIndex].totalDownAmount -= downNetAmount;\\n\\n        userPredictions.totalPredictionAmount -= userPredictions.predictionAmounts[predictionIndex];\\n        userPredictions.totalPredictionNetAmount -= userPredictions.predictionNetAmounts[predictionIndex];\\n\\n        userPredictions.predictionNetAmounts[predictionIndex] = 0;\\n        userPredictions.predictionUpNetAmounts[predictionIndex] = 0;\\n        userPredictions.predictionDownNetAmounts[predictionIndex] = 0;\\n        userPredictions.predictionUpAmounts[predictionIndex] = 0;\\n        userPredictions.predictionDownAmounts[predictionIndex] = 0;\\n        userPredictions.predictionAmounts[predictionIndex] = 0;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ArraySearch.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract ArraySearch {\\n    function findElement(uint256[] memory array, uint256 element) public pure returns (bool exists, uint256 index) {\\n        for (uint256 i = 0; i < array.length; i++) {\\n            if (array[i] == element) {\\n                return (true, i);\\n            }\\n        }\\n        return (false, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.5.0/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.5.0/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.5.0/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.5.0/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.5.0/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currencyAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentPredictionRound\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"openUntil\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"waitingUntil\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeoutAt\",\"type\":\"uint256\"}],\"name\":\"NewPredictionRoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundIndex\",\"type\":\"uint256\"}],\"name\":\"RoundCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"outcomes\",\"type\":\"bool[]\"}],\"name\":\"RoundResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UserCancelledAllPredictions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"memeOptionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UserCancelledPrediction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"}],\"name\":\"UserClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"memeOptionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isUpPrediction\",\"type\":\"bool\"}],\"name\":\"UserMadePrediction\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_PREDICTION_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_PREDICTION_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bufferAmountWei\",\"type\":\"uint256\"}],\"name\":\"addLockedCurrencyBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backdoorCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceRoundBonusReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"calculateClaimableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool[]\",\"name\":\"predictionOutcomes\",\"type\":\"bool[]\"}],\"name\":\"calculateCurrentRequriedFundsForGuaranteedWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelAllPredictions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionIndex\",\"type\":\"uint256\"}],\"name\":\"cancelPrediction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelPredictionRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPredictionRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feesCollectedForRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"array\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"element\",\"type\":\"uint256\"}],\"name\":\"findElement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPredictibleOptions\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"identifier\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"memeOptionIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDownAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usedBonusReward\",\"type\":\"uint256\"}],\"internalType\":\"struct MemePredictionBase.MemeOption[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getCurrentPredictions\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"memeOptionIndexes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"predictionUpNetAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"predictionDownNetAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"predictionUpAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"predictionDownAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"predictionAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentRoundOdds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"memeOptionIndexes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"upRewardMultipliers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"downRewardMultipliers\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentRoundResults\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimoutForResolvingPrediction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWaitingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool[]\",\"name\":\"predictionOutcomes\",\"type\":\"bool[]\"}],\"name\":\"hasBonusFundsForCurrentRound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTimedOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWaitingPeriodOver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedCurrency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"memeOptionIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUpPrediction\",\"type\":\"bool\"}],\"name\":\"predict\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"predictionCurrency\",\"outputs\":[{\"internalType\":\"contract IERC20Metadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool[]\",\"name\":\"predictionOutcomes\",\"type\":\"bool[]\"}],\"name\":\"resolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumReward\",\"type\":\"uint256\"}],\"name\":\"setBalanceRoundBonusRewardForNextRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"setFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaximumPredictionAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinimumPredictionAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hours\",\"type\":\"uint256\"}],\"name\":\"setOpenPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"memeIdentifiers\",\"type\":\"string[]\"}],\"name\":\"setPredictibleOptionsForNextRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hours\",\"type\":\"uint256\"}],\"name\":\"setTimoutLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hours\",\"type\":\"uint256\"}],\"name\":\"setWaitingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startNewPredictionRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum MemePredictionBase.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeoutAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unclaimedPredictionRounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"waitingUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAvialableCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MemePrediction", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000042dbbd5ae373fea2fc320f62d44c058522bb3758", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}