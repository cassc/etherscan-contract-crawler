{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/BeaverRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract BeaverRouter {\\n    address internal _owner;\\n    address internal _defaultInitiator;\\n    bool internal _frozen;\\n\\n    constructor(address owner, address defaultInitiator) {\\n        _owner = owner;\\n        _defaultInitiator = defaultInitiator;\\n    }\\n\\n    // It's ugly, but the order of variables in the Product struct doesn't match\\n    // the order in other places, because we pack the variables here.\\n    struct Product {\\n        uint256 amount;\\n        address token;\\n        uint40 period;\\n        uint40 freeTrialLength;\\n        uint40 paymentPeriod; // How many seconds there is to make a payment\\n        address merchant;\\n        bytes32 productMetadata; // product metadata like product name\\n    }\\n\\n    struct Subscription {\\n        bytes32 productHash;\\n        address user;\\n        uint40 start;\\n        uint48 paymentsMade; // 1 - one payment has been made, 2 - two payments have been made, etc.\\n        bool terminated;\\n        bytes32 subscriptionMetadata; // subscription metadata like subscriptionId, userId\\n    }\\n\\n    struct MerchantSettings {\\n        address initiator;\\n    }\\n\\n    event ProductCreated(\\n        bytes32 indexed productHash,\\n        address indexed merchant,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 period,\\n        uint256 freeTrialLength,\\n        uint256 paymentPeriod,\\n        bytes32 productMetadata\\n    );\\n\\n    event SubscriptionStarted(\\n        bytes32 indexed subscriptionHash,\\n        bytes32 indexed productHash,\\n        address indexed user,\\n        uint256 start,\\n        bytes32 subscriptionMetadata\\n    );\\n\\n    event PaymentMade(\\n        bytes32 indexed subscriptionHash,\\n        uint256 indexed paymentNumber\\n    );\\n\\n    event SubscriptionTerminated(\\n        bytes32 indexed subscriptionHash,\\n        address indexed terminatedBy\\n    );\\n\\n    event InitiatorChanged(\\n        address indexed merchant,\\n        address indexed newInitiator,\\n        address indexed oldInitiator,\\n        address changedBy\\n    );\\n\\n    event OwnerChanged(address indexed newOwner, address indexed oldOwner);\\n\\n    event DefaultInitiatorChanged(\\n        address indexed newDefaultInitiator,\\n        address indexed oldDefaultInitiator\\n    );\\n\\n    event Froze();\\n    event Unfroze();\\n\\n    mapping(bytes32 => Product) public products;\\n    mapping(bytes32 => Subscription) public subscriptions;\\n    mapping(bytes32 => uint256) public productNonce;\\n    mapping(address => MerchantSettings) public merchantSettings;\\n\\n    function createProductIfDoesntExist(\\n        address merchant,\\n        address token,\\n        uint256 amount,\\n        uint40 period,\\n        uint40 freeTrialLength,\\n        uint40 paymentPeriod,\\n        bytes32 productMetadata\\n    ) external returns (bytes32 productHash) {\\n        productHash = keccak256(\\n            abi.encodePacked(\\n                block.chainid,\\n                merchant,\\n                token,\\n                amount,\\n                period,\\n                freeTrialLength,\\n                paymentPeriod,\\n                productMetadata\\n            )\\n        );\\n\\n        if (products[productHash].merchant != address(0)) {\\n            return productHash; // product already exists\\n        }\\n\\n        products[productHash] = Product({\\n            merchant: merchant,\\n            token: token,\\n            amount: amount,\\n            period: period,\\n            freeTrialLength: freeTrialLength,\\n            paymentPeriod: paymentPeriod,\\n            productMetadata: productMetadata\\n        });\\n\\n        emit ProductCreated(\\n            productHash,\\n            merchant,\\n            token,\\n            amount,\\n            period,\\n            freeTrialLength,\\n            paymentPeriod,\\n            productMetadata\\n        );\\n    }\\n\\n    function _startSubscription(\\n        bytes32 productHash,\\n        bytes32 subscriptionMetadata\\n    ) internal returns (bytes32 subscriptionHash) {\\n        Product storage product = products[productHash];\\n\\n        require(product.merchant != address(0), \\\"BR: product does not exist\\\");\\n\\n        // not hashing chainId since it is already included in productHash.\\n        subscriptionHash = keccak256(\\n            abi.encodePacked(productHash, productNonce[productHash]++)\\n        );\\n\\n        uint256 start = block.timestamp + product.freeTrialLength;\\n        subscriptions[subscriptionHash] = Subscription({\\n            productHash: productHash,\\n            user: msg.sender,\\n            start: uint40(start),\\n            paymentsMade: 0,\\n            terminated: false,\\n            subscriptionMetadata: subscriptionMetadata\\n        });\\n\\n        emit SubscriptionStarted(\\n            subscriptionHash,\\n            productHash,\\n            msg.sender,\\n            start,\\n            subscriptionMetadata\\n        );\\n\\n        if (product.freeTrialLength == 0) this.makePayment(subscriptionHash, 0);\\n    }\\n\\n    function startSubscription(\\n        bytes32 productHash,\\n        bytes32 subscriptionMetadata\\n    ) external returns (bytes32 subscriptionHash) {\\n        subscriptionHash = _startSubscription(\\n            productHash,\\n            subscriptionMetadata\\n        );\\n    }\\n\\n    function setupEnvironmentAndStartSubscription(\\n        address merchant,\\n        address token,\\n        uint256 amount,\\n        uint40 period,\\n        uint40 freeTrialLength,\\n        uint40 paymentPeriod,\\n        bytes32 productMetadata,\\n        bytes32 subscriptionMetadata\\n    ) external returns (bytes32 subscriptionHash) {\\n        if (merchantSettings[merchant].initiator == address(0)) {\\n            this.changeInitiator(merchant, _defaultInitiator);\\n        }\\n\\n        bytes32 productHash = this.createProductIfDoesntExist(\\n            merchant,\\n            token,\\n            amount,\\n            period,\\n            freeTrialLength,\\n            paymentPeriod,\\n            productMetadata\\n        );\\n\\n        subscriptionHash = _startSubscription(\\n            productHash,\\n            subscriptionMetadata\\n        );\\n    }\\n\\n    function makePayment(\\n        bytes32 subscriptionHash,\\n        uint256 compensation\\n    ) external returns (uint48) {\\n        require(!_frozen, \\\"BR: router is frozen\\\");\\n\\n        Subscription storage sub = subscriptions[subscriptionHash];\\n        Product storage product = products[sub.productHash];\\n        address initiator = merchantSettings[product.merchant].initiator;\\n\\n        require(\\n            msg.sender == address(this) || msg.sender == initiator,\\n            \\\"BR: not permitted\\\"\\n        );\\n\\n        require(!sub.terminated, \\\"BR: subscription is terminated\\\");\\n\\n        uint256 paymentTimestamp = sub.start +\\n            sub.paymentsMade *\\n            product.period;\\n\\n        require(\\n            block.timestamp >= paymentTimestamp,\\n            \\\"BR: too early to make payment\\\"\\n        );\\n\\n        require(\\n            block.timestamp < paymentTimestamp + product.paymentPeriod,\\n            \\\"BR: subscription has expired\\\"\\n        );\\n\\n        // prevent initiators from making the compensation too high\\n        require(compensation < product.amount, \\\"BR: too high compensation\\\");\\n\\n        uint256 toMerchant = product.amount - compensation;\\n\\n        IERC20(product.token).transferFrom(\\n            sub.user,\\n            product.merchant,\\n            toMerchant\\n        );\\n\\n        if (compensation > 0) {\\n            IERC20(product.token).transferFrom(\\n                sub.user,\\n                initiator,\\n                compensation\\n            );\\n        }\\n\\n        sub.paymentsMade += 1;\\n        emit PaymentMade(subscriptionHash, sub.paymentsMade);\\n\\n        return sub.paymentsMade;\\n    }\\n\\n    function terminateSubscription(bytes32 subscriptionHash) external {\\n        Subscription storage sub = subscriptions[subscriptionHash];\\n        Product storage product = products[sub.productHash];\\n\\n        require(\\n            msg.sender == sub.user || msg.sender == product.merchant,\\n            \\\"BR: not permitted\\\"\\n        );\\n\\n        sub.terminated = true;\\n        emit SubscriptionTerminated(subscriptionHash, msg.sender);\\n    }\\n\\n    function changeInitiator(address merchant, address newInitiator) external {\\n        address initiator = merchantSettings[merchant].initiator;\\n\\n        require(\\n            msg.sender == initiator ||\\n                msg.sender == merchant ||\\n                (initiator == address(0) && newInitiator == _defaultInitiator),\\n            \\\"BR: not permitted\\\"\\n        );\\n\\n        emit InitiatorChanged(merchant, newInitiator, initiator, msg.sender);\\n        merchantSettings[merchant].initiator = newInitiator;\\n    }\\n\\n    function changeOwner(address newOwner) external {\\n        require(msg.sender == _owner, \\\"BR: not permitted\\\");\\n\\n        emit OwnerChanged(newOwner, _owner);\\n\\n        _owner = newOwner;\\n    }\\n\\n    function freeze() external {\\n        require(msg.sender == _owner, \\\"BR: not permitted\\\");\\n\\n        emit Froze();\\n\\n        _frozen = true;\\n    }\\n\\n    function unfreeze() external {\\n        require(msg.sender == _owner, \\\"BR: not permitted\\\");\\n\\n        emit Unfroze();\\n\\n        _frozen = false;\\n    }\\n\\n    function changeDefaultInitiator(address newDefaultInitiator) external {\\n        require(msg.sender == _owner, \\\"BR: not permitted\\\");\\n\\n        emit DefaultInitiatorChanged(newDefaultInitiator, _defaultInitiator);\\n\\n        _defaultInitiator = newDefaultInitiator;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defaultInitiator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDefaultInitiator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldDefaultInitiator\",\"type\":\"address\"}],\"name\":\"DefaultInitiatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Froze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newInitiator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldInitiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"changedBy\",\"type\":\"address\"}],\"name\":\"InitiatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"subscriptionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"paymentNumber\",\"type\":\"uint256\"}],\"name\":\"PaymentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"productHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"freeTrialLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"productMetadata\",\"type\":\"bytes32\"}],\"name\":\"ProductCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"subscriptionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"productHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"subscriptionMetadata\",\"type\":\"bytes32\"}],\"name\":\"SubscriptionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"subscriptionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"terminatedBy\",\"type\":\"address\"}],\"name\":\"SubscriptionTerminated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unfroze\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDefaultInitiator\",\"type\":\"address\"}],\"name\":\"changeDefaultInitiator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newInitiator\",\"type\":\"address\"}],\"name\":\"changeInitiator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"period\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"freeTrialLength\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"paymentPeriod\",\"type\":\"uint40\"},{\"internalType\":\"bytes32\",\"name\":\"productMetadata\",\"type\":\"bytes32\"}],\"name\":\"createProductIfDoesntExist\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"productHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"subscriptionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"compensation\",\"type\":\"uint256\"}],\"name\":\"makePayment\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"merchantSettings\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"productNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"products\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"period\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"freeTrialLength\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"paymentPeriod\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"productMetadata\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"period\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"freeTrialLength\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"paymentPeriod\",\"type\":\"uint40\"},{\"internalType\":\"bytes32\",\"name\":\"productMetadata\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"subscriptionMetadata\",\"type\":\"bytes32\"}],\"name\":\"setupEnvironmentAndStartSubscription\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"subscriptionHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"productHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"subscriptionMetadata\",\"type\":\"bytes32\"}],\"name\":\"startSubscription\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"subscriptionHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"subscriptions\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"productHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"start\",\"type\":\"uint40\"},{\"internalType\":\"uint48\",\"name\":\"paymentsMade\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"terminated\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"subscriptionMetadata\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"subscriptionHash\",\"type\":\"bytes32\"}],\"name\":\"terminateSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BeaverRouter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "0000000000000000000000004bba290826c253bd854121346c370a9886d1bc260000000000000000000000006ef7caadbc1e82cf288d756e42481cb8dce9b827", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}