{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/XENStake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Base64.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@faircrypto/xen-crypto/contracts/XENCrypto.sol\\\";\\nimport \\\"@faircrypto/xen-crypto/contracts/interfaces/IBurnableToken.sol\\\";\\nimport \\\"@faircrypto/magic-numbers/contracts/MagicNumbers.sol\\\";\\nimport \\\"operator-filter-registry/src/DefaultOperatorFilterer.sol\\\";\\nimport \\\"./libs/ERC2771Context.sol\\\";\\nimport \\\"./interfaces/IERC2771.sol\\\";\\nimport \\\"./libs/StakeInfo.sol\\\";\\nimport \\\"./libs/StakeMetadata.sol\\\";\\nimport \\\"./libs/Array.sol\\\";\\nimport \\\"./interfaces/IXENStake.sol\\\";\\nimport \\\"./interfaces/IXENStakeProxying.sol\\\";\\n\\n/*\\n\\n        \\\\\\\\      //   |||||||||||   |\\\\      ||       A CRYPTOCURRENCY FOR THE MASSES\\n         \\\\\\\\    //    ||            |\\\\\\\\     ||\\n          \\\\\\\\  //     ||            ||\\\\\\\\    ||       PRINCIPLES OF XEN:\\n           \\\\\\\\//      ||            || \\\\\\\\   ||       - No pre-mint; starts with zero supply\\n            XX       ||||||||      ||  \\\\\\\\  ||       - No admin keys\\n           //\\\\\\\\      ||            ||   \\\\\\\\ ||       - Immutable contract\\n          //  \\\\\\\\     ||            ||    \\\\\\\\||\\n         //    \\\\\\\\    ||            ||     \\\\\\\\|\\n        //      \\\\\\\\   |||||||||||   ||      \\\\|       Copyright (C) FairCrypto Foundation 2022-23\\n\\n\\n    XENFT XEN Stake props:\\n    - amount, term, maturityTs, APY, rarityScore\\n */\\n\\ncontract XENStake is\\n    DefaultOperatorFilterer, // required to support OpenSea royalties\\n    IXENStake,\\n    IXENStakeProxying,\\n    IBurnableToken,\\n    ERC2771Context, // required to support meta transactions\\n    IERC2981, // required to support NFT royalties\\n    ERC721(\\\"XEN Stake\\\", \\\"mXENS\\\")\\n{\\n    using Strings for uint256;\\n    using StakeInfo for uint256;\\n    using MagicNumbers for uint256;\\n    using Array for uint256[];\\n\\n    // PUBLIC CONSTANTS\\n\\n    // XENFT common business logic\\n    uint256 public constant SECONDS_IN_DAY = 24 * 3_600;\\n    uint256 public constant BLACKOUT_TERM = 7 * SECONDS_IN_DAY;\\n\\n    string public constant AUTHORS = \\\"@MrJackLevin @lbelyaev faircrypto.org\\\";\\n\\n    uint256 public constant ROYALTY_BP = 500;\\n\\n    // PUBLIC MUTABLE STATE\\n\\n    // increasing counter for NFT tokenIds, also used as salt for proxies' spinning\\n    uint256 public tokenIdCounter = 1;\\n\\n    // tokenId => stakeInfo\\n    mapping(uint256 => uint256) public stakeInfo;\\n\\n    // PUBLIC IMMUTABLE STATE\\n\\n    // pointer to XEN Crypto contract\\n    XENCrypto public immutable xenCrypto;\\n\\n    // PRIVATE STATE\\n\\n    // original contract marking to distinguish from proxy copies\\n    address private immutable _original;\\n    // original deployer address to be used for setting trusted forwarder\\n    address private immutable _deployer;\\n    // address to be used for royalties' tracking\\n    address private immutable _royaltyReceiver;\\n\\n    // mapping Address => tokenId[]\\n    mapping(address => uint256[]) private _ownedTokens;\\n\\n    constructor(address xenCrypto_, address forwarder_, address royaltyReceiver_) ERC2771Context(forwarder_) {\\n        require(xenCrypto_ != address(0), \\\"bad address\\\");\\n        _original = address(this);\\n        _deployer = msg.sender;\\n        _royaltyReceiver = royaltyReceiver_ == address(0) ? msg.sender : royaltyReceiver_;\\n        xenCrypto = XENCrypto(xenCrypto_);\\n    }\\n\\n    // INTERFACES & STANDARDS\\n    // IERC165 IMPLEMENTATION\\n\\n    /**\\n        @dev confirms support for IERC-165, IERC-721, IERC2981, IERC2771 and IBurnRedeemable interfaces\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return\\n            interfaceId == type(IBurnRedeemable).interfaceId ||\\n            interfaceId == type(IERC2981).interfaceId ||\\n            interfaceId == type(IERC2771).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    // ERC2771 IMPLEMENTATION\\n\\n    /**\\n        @dev use ERC2771Context implementation of _msgSender()\\n     */\\n    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address) {\\n        return ERC2771Context._msgSender();\\n    }\\n\\n    /**\\n        @dev use ERC2771Context implementation of _msgData()\\n     */\\n    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {\\n        return ERC2771Context._msgData();\\n    }\\n\\n    // OWNABLE IMPLEMENTATION\\n\\n    /**\\n        @dev public getter to check for deployer / owner (Opensea, etc.)\\n     */\\n    function owner() external view returns (address) {\\n        return _deployer;\\n    }\\n\\n    // ERC-721 METADATA IMPLEMENTATION\\n    /**\\n        @dev compliance with ERC-721 standard (NFT); returns NFT metadata, including SVG-encoded image\\n     */\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        uint256 info = stakeInfo[tokenId];\\n\\n        bytes memory dataURI = abi.encodePacked(\\n            \\\"{\\\",\\n            '\\\"name\\\": \\\"XEN Stake #',\\n            tokenId.toString(),\\n            '\\\",',\\n            '\\\"description\\\": \\\"XENFT: XEN Crypto Proof Of Stake\\\",',\\n            '\\\"image\\\": \\\"',\\n            \\\"data:image/svg+xml;base64,\\\",\\n            Base64.encode(StakeMetadata.svgData(tokenId, info, address(xenCrypto))),\\n            '\\\",',\\n            '\\\"attributes\\\": ',\\n            StakeMetadata.attributes(info),\\n            \\\"}\\\"\\n        );\\n        return string(abi.encodePacked(\\\"data:application/json;base64,\\\", Base64.encode(dataURI)));\\n    }\\n\\n    // IMPLEMENTATION OF XENStakeProxying INTERFACE\\n    // FUNCTIONS IN PROXY COPY CONTRACTS (VMU), CALLING ORIGINAL XEN CRYPTO CONTRACT\\n    /**\\n        @dev function callable only in proxy contracts from the original one => XENCrypto.stake(amount, term)\\n     */\\n    function callStake(uint256 amount, uint256 term) external {\\n        require(msg.sender == _original, \\\"XEN Proxy: unauthorized\\\");\\n        bytes memory callData = abi.encodeWithSignature(\\\"stake(uint256,uint256)\\\", amount, term);\\n        (bool success, ) = address(xenCrypto).call(callData);\\n        require(success, \\\"stake call failed\\\");\\n    }\\n\\n    /**\\n        @dev function callable only in proxy contracts from the original one => XENCrypto.withdraw()\\n     */\\n    function callWithdraw() external {\\n        require(msg.sender == _original, \\\"XEN Proxy: unauthorized\\\");\\n        bytes memory callData = abi.encodeWithSignature(\\\"withdraw()\\\");\\n        (bool success, ) = address(xenCrypto).call(callData);\\n        require(success, \\\"withdraw call failed\\\");\\n    }\\n\\n    /**\\n        @dev function callable only in proxy contracts from the original one => XENCrypto.transfer(to, amount)\\n     */\\n    function callTransfer(address to) external {\\n        require(msg.sender == _original, \\\"XEN Proxy: unauthorized\\\");\\n        uint256 balance = xenCrypto.balanceOf(address(this));\\n        bytes memory callData = abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", to, balance);\\n        (bool success, ) = address(xenCrypto).call(callData);\\n        require(success, \\\"transfer call failed\\\");\\n    }\\n\\n    /**\\n        @dev function callable only in proxy contracts from the original one => destroys the proxy contract\\n     */\\n    function powerDown() external {\\n        require(msg.sender == _original, \\\"XEN Proxy: unauthorized\\\");\\n        selfdestruct(payable(address(0)));\\n    }\\n\\n    // OVERRIDING OF ERC-721 IMPLEMENTATION\\n    // ENFORCEMENT OF TRANSFER BLACKOUT PERIOD\\n\\n    /**\\n        @dev overrides OZ ERC-721 before transfer hook to check if there's no blackout period\\n     */\\n    function _beforeTokenTransfer(address from, address, uint256 tokenId) internal virtual override {\\n        if (from != address(0)) {\\n            uint256 maturityTs = StakeInfo.getMaturityTs(stakeInfo[tokenId]);\\n            uint256 delta = maturityTs > block.timestamp ? maturityTs - block.timestamp : block.timestamp - maturityTs;\\n            require(delta > BLACKOUT_TERM, \\\"XENFT: transfer prohibited in blackout period\\\");\\n        }\\n    }\\n\\n    /**\\n        @dev overrides OZ ERC-721 after transfer hook to allow token enumeration for owner\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\\n        _ownedTokens[from].removeItem(tokenId);\\n        _ownedTokens[to].addItem(tokenId);\\n    }\\n\\n    // IBurnableToken IMPLEMENTATION\\n\\n    /**\\n        @dev burns XENTorrent XENFT which can be used by connected contracts services\\n     */\\n    function burn(address user, uint256 tokenId) public {\\n        require(\\n            IERC165(_msgSender()).supportsInterface(type(IBurnRedeemable).interfaceId),\\n            \\\"XENFT burn: not a supported contract\\\"\\n        );\\n        require(user != address(0), \\\"XENFT burn: illegal owner address\\\");\\n        require(tokenId > 0, \\\"XENFT burn: illegal tokenId\\\");\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"XENFT burn: not an approved operator\\\");\\n        require(ownerOf(tokenId) == user, \\\"XENFT burn: user is not tokenId owner\\\");\\n        _ownedTokens[user].removeItem(tokenId);\\n        _burn(tokenId);\\n        IBurnRedeemable(_msgSender()).onTokenBurned(user, tokenId);\\n    }\\n\\n    // OVERRIDING ERC-721 IMPLEMENTATION TO ALLOW OPENSEA ROYALTIES ENFORCEMENT PROTOCOL\\n\\n    /**\\n        @dev implements `setApprovalForAll` with additional approved Operator checking\\n     */\\n    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {\\n        super.setApprovalForAll(operator, approved);\\n    }\\n\\n    /**\\n        @dev implements `approve` with additional approved Operator checking\\n     */\\n    function approve(address operator, uint256 tokenId) public override onlyAllowedOperatorApproval(operator) {\\n        super.approve(operator, tokenId);\\n    }\\n\\n    /**\\n        @dev implements `transferFrom` with additional approved Operator checking\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {\\n        super.transferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n        @dev implements `safeTransferFrom` with additional approved Operator checking\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n        @dev implements `safeTransferFrom` with additional approved Operator checking\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public override onlyAllowedOperator(from) {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    // SUPPORT FOR ERC2771 META-TRANSACTIONS\\n\\n    /**\\n        @dev Implements setting a `Trusted Forwarder` for meta-txs. Settable only once\\n     */\\n    function addForwarder(address trustedForwarder) external {\\n        require(msg.sender == _deployer, \\\"XENFT: not an deployer\\\");\\n        require(_trustedForwarder == address(0), \\\"XENFT: Forwarder is already set\\\");\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    // SUPPORT FOR ERC2981 ROYALTY INFO\\n\\n    /**\\n        @dev Implements getting Royalty Info by supported operators. ROYALTY_BP is expressed in basis points\\n     */\\n    function royaltyInfo(uint256, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount) {\\n        receiver = _royaltyReceiver;\\n        royaltyAmount = (salePrice * ROYALTY_BP) / 10_000;\\n    }\\n\\n    // XEN TORRENT PRIVATE / INTERNAL HELPERS\\n\\n    /**\\n        @dev internal torrent interface. calculates rarityBits and rarityScore\\n     */\\n    function _calcRarity(uint256 tokenId) private view returns (uint256 rarityScore, uint256 rarityBits) {\\n        bool isPrime = tokenId.isPrime();\\n        bool isFib = tokenId.isFib();\\n        bool blockIsPrime = block.number.isPrime();\\n        bool blockIsFib = block.number.isFib();\\n        rarityScore += (isPrime ? 500 : 0);\\n        rarityScore += (blockIsPrime ? 1_000 : 0);\\n        rarityScore += (isFib ? 5_000 : 0);\\n        rarityScore += (blockIsFib ? 10_000 : 0);\\n        rarityBits = StakeInfo.encodeRarityBits(isPrime, isFib, blockIsPrime, blockIsFib);\\n    }\\n\\n    /**\\n        @dev internal torrent interface. composes StakeInfo\\n     */\\n    function _stakeInfo(\\n        address proxy,\\n        uint256 tokenId,\\n        uint256 amount,\\n        uint256 term\\n    ) private view returns (uint256 info) {\\n        (, uint256 maturityTs, , uint256 apy) = xenCrypto.userStakes(proxy);\\n        (uint256 rarityScore, uint256 rarityBits) = _calcRarity(tokenId);\\n        info = StakeInfo.encodeStakeInfo(term, maturityTs, amount / 10 ** 18, apy, rarityScore, rarityBits);\\n    }\\n\\n    /**\\n        @dev internal helper. Creates bytecode for minimal proxy contract\\n     */\\n    function _bytecode() private view returns (bytes memory) {\\n        return\\n            bytes.concat(\\n                bytes20(0x3D602d80600A3D3981F3363d3d373d3D3D363d73),\\n                bytes20(address(this)),\\n                bytes15(0x5af43d82803e903d91602b57fd5bf3)\\n            );\\n    }\\n\\n    /**\\n        @dev internal torrent interface. initiates Stake Operation\\n     */\\n    function _createStake(uint256 amount, uint256 term, uint256 tokenId) private {\\n        bytes memory bytecode = _bytecode();\\n        bytes memory callData = abi.encodeWithSignature(\\\"callStake(uint256,uint256)\\\", amount, term);\\n        address proxy;\\n        bool succeeded;\\n        bytes32 salt = keccak256(abi.encodePacked(tokenId));\\n        assembly {\\n            proxy := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(proxy != address(0), \\\"XENFT: Error creating VSU\\\");\\n        require(xenCrypto.transferFrom(_msgSender(), proxy, amount), \\\"XENFT: Error transferring XEN to VSU\\\");\\n        assembly {\\n            succeeded := call(gas(), proxy, 0, add(callData, 0x20), mload(callData), 0, 0)\\n        }\\n        require(succeeded, \\\"XENFT: Error while staking\\\");\\n\\n        stakeInfo[tokenId] = _stakeInfo(proxy, tokenId, amount, term);\\n    }\\n\\n    /**\\n        @dev internal torrent interface. initiates Stake Operation\\n     */\\n    function _endStake(uint256 tokenId) private {\\n        bytes memory bytecode = _bytecode();\\n        bytes memory callData = abi.encodeWithSignature(\\\"callWithdraw()\\\");\\n        bytes memory callData1 = abi.encodeWithSignature(\\\"callTransfer(address)\\\", _msgSender());\\n        bytes memory callData2 = abi.encodeWithSignature(\\\"powerDown()\\\");\\n        bytes32 salt = keccak256(abi.encodePacked(tokenId));\\n        bytes32 hash = keccak256(abi.encodePacked(hex\\\"ff\\\", address(this), salt, keccak256(bytecode)));\\n        address proxy = address(uint160(uint256(hash)));\\n\\n        bool succeeded;\\n        assembly {\\n            succeeded := call(gas(), proxy, 0, add(callData, 0x20), mload(callData), 0, 0)\\n        }\\n        require(succeeded, \\\"XENFT: Error while withdrawing\\\");\\n        assembly {\\n            succeeded := call(gas(), proxy, 0, add(callData1, 0x20), mload(callData1), 0, 0)\\n        }\\n        require(succeeded, \\\"XENFT: Error while transferring\\\");\\n        assembly {\\n            succeeded := call(gas(), proxy, 0, add(callData2, 0x20), mload(callData2), 0, 0)\\n        }\\n        require(succeeded, \\\"XENFT: Error while powering down\\\");\\n\\n        delete stakeInfo[tokenId];\\n    }\\n\\n    // PUBLIC GETTERS\\n\\n    /**\\n        @dev public getter for tokens owned by address\\n     */\\n    function ownedTokens() external view returns (uint256[] memory) {\\n        return _ownedTokens[_msgSender()];\\n    }\\n\\n    // PUBLIC TRANSACTIONAL INTERFACE\\n\\n    /**\\n        @dev    public XEN Stake interface\\n                initiates XEN Crypto Stake\\n     */\\n    function createStake(uint256 amount, uint256 term) public returns (uint256 tokenId) {\\n        require(amount > 0, \\\"XENFT: Illegal amount\\\");\\n        require(term > 0, \\\"XENFT: Illegal term\\\");\\n\\n        _createStake(amount, term, tokenIdCounter);\\n        _ownedTokens[_msgSender()].addItem(tokenIdCounter);\\n        _safeMint(_msgSender(), tokenIdCounter);\\n        tokenId = tokenIdCounter;\\n        tokenIdCounter++;\\n        emit CreateStake(_msgSender(), tokenId, amount, term);\\n    }\\n\\n    /**\\n        @dev    public XEN Stake interface\\n                ends XEN Crypto Stake, withdraws principal and reward amounts\\n     */\\n    function endStake(uint256 tokenId) public {\\n        require(tokenId > 0, \\\"XENFT: Illegal tokenId\\\");\\n        require(ownerOf(tokenId) == _msgSender(), \\\"XENFT: Incorrect owner\\\");\\n        uint256 maturityTs = StakeInfo.getMaturityTs(stakeInfo[tokenId]);\\n        require(block.timestamp > maturityTs, \\\"XENFT: Maturity not reached\\\");\\n\\n        _endStake(tokenId);\\n        _ownedTokens[_msgSender()].removeItem(tokenId);\\n        _burn(tokenId);\\n        emit EndStake(_msgSender(), tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/StakeSVG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./DateTime.sol\\\";\\nimport \\\"./FormattedStrings.sol\\\";\\n\\n/*\\n    @dev        Library to create SVG image for XENFT metadata\\n    @dependency depends on DataTime.sol and StringData.sol libraries\\n */\\nlibrary StakeSVG {\\n    // Type to encode all data params for SVG image generation\\n    struct SvgParams {\\n        string symbol;\\n        address xenAddress;\\n        uint256 tokenId;\\n        uint256 term;\\n        uint256 maturityTs;\\n        uint256 amount;\\n        uint256 apy;\\n        uint256 rarityScore;\\n        uint256 rarityBits;\\n    }\\n\\n    // Type to encode SVG gradient stop color on HSL color scale\\n    struct Color {\\n        uint256 h;\\n        uint256 s;\\n        uint256 l;\\n        uint256 a;\\n        uint256 off;\\n    }\\n\\n    // Type to encode SVG gradient\\n    struct Gradient {\\n        Color[] colors;\\n        uint256 id;\\n        uint256[4] coords;\\n    }\\n\\n    using DateTime for uint256;\\n    using Strings for uint256;\\n    using FormattedStrings for uint256;\\n    using Strings for address;\\n\\n    string private constant _STYLE =\\n        \\\"<style> \\\"\\n        \\\".base {fill: #ededed;font-family:Montserrat,arial,sans-serif;font-size:30px;font-weight:400;} \\\"\\n        \\\".series {text-transform: uppercase} \\\"\\n        \\\".logo {font-size:200px;font-weight:100;} \\\"\\n        \\\".meta {font-size:12px;} \\\"\\n        \\\".small {font-size:8px;} \\\"\\n        \\\".burn {font-weight:500;font-size:16px;} }\\\"\\n        \\\"</style>\\\";\\n\\n    string private constant _STAKE =\\n        \\\"<g>\\\"\\n        \\\"<path \\\"\\n        'stroke=\\\"#ededed\\\" '\\n        'fill=\\\"none\\\" '\\n        'transform=\\\"translate(250,379), scale(0.7)\\\" '\\n        'd=\\\"m 0 5 a 5 5 0 0 1 5 -5 l 40 0 a 5 5 0 0 1 5 5 l 0 40 a 5 5 0 0 1 -5 5 l -40 0 a 5 5 0 0 1 -5 -5 l 0 -40z m 25 0 l 20 10 l -20 10 l -20 -10 l 20 -10 m 10 15 l 10 5 l -20 10 l -20 -10 l 10 -5 m 20 10 l 10 5 l -20 10 l -20 -10 l 10 -5\\\"/>'\\n        \\\"</g>\\\";\\n\\n    string private constant _LOGO =\\n        '<path fill=\\\"#ededed\\\" '\\n        'd=\\\"M122.7,227.1 l-4.8,0l55.8,-74l0,3.2l-51.8,-69.2l5,0l48.8,65.4l-1.2,0l48.8,-65.4l4.8,0l-51.2,68.4l0,-1.6l55.2,73.2l-5,0l-52.8,-70.2l1.2,0l-52.8,70.2z\\\" '\\n        'vector-effect=\\\"non-scaling-stroke\\\" />';\\n\\n    /**\\n        @dev internal helper to create HSL-encoded color prop for SVG tags\\n     */\\n    function colorHSL(Color memory c) internal pure returns (bytes memory) {\\n        return abi.encodePacked(\\\"hsl(\\\", c.h.toString(), \\\", \\\", c.s.toString(), \\\"%, \\\", c.l.toString(), \\\"%)\\\");\\n    }\\n\\n    /**\\n        @dev internal helper to create `stop` SVG tag\\n     */\\n    function colorStop(Color memory c) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                '<stop stop-color=\\\"',\\n                colorHSL(c),\\n                '\\\" stop-opacity=\\\"',\\n                c.a.toString(),\\n                '\\\" offset=\\\"',\\n                c.off.toString(),\\n                '%\\\"/>'\\n            );\\n    }\\n\\n    /**\\n        @dev internal helper to encode position for `Gradient` SVG tag\\n     */\\n    function pos(uint256[4] memory coords) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                'x1=\\\"',\\n                coords[0].toString(),\\n                '%\\\" '\\n                'y1=\\\"',\\n                coords[1].toString(),\\n                '%\\\" '\\n                'x2=\\\"',\\n                coords[2].toString(),\\n                '%\\\" '\\n                'y2=\\\"',\\n                coords[3].toString(),\\n                '%\\\" '\\n            );\\n    }\\n\\n    /**\\n        @dev internal helper to create `Gradient` SVG tag\\n     */\\n    function linearGradient(\\n        Color[] memory colors,\\n        uint256 id,\\n        uint256[4] memory coords\\n    ) internal pure returns (bytes memory) {\\n        string memory stops = \\\"\\\";\\n        for (uint256 i = 0; i < colors.length; i++) {\\n            if (colors[i].h != 0) {\\n                stops = string.concat(stops, string(colorStop(colors[i])));\\n            }\\n        }\\n        return\\n            abi.encodePacked(\\n                \\\"<linearGradient  \\\",\\n                pos(coords),\\n                'id=\\\"g',\\n                id.toString(),\\n                '\\\">',\\n                stops,\\n                \\\"</linearGradient>\\\"\\n            );\\n    }\\n\\n    /**\\n        @dev internal helper to create `Defs` SVG tag\\n     */\\n    function defs(Gradient memory grad) internal pure returns (bytes memory) {\\n        return abi.encodePacked(\\\"<defs>\\\", linearGradient(grad.colors, 0, grad.coords), \\\"</defs>\\\");\\n    }\\n\\n    /**\\n        @dev internal helper to create `Rect` SVG tag\\n     */\\n    function rect(uint256 id) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                \\\"<rect \\\"\\n                'width=\\\"100%\\\" '\\n                'height=\\\"100%\\\" '\\n                'fill=\\\"url(#g',\\n                id.toString(),\\n                ')\\\" '\\n                'rx=\\\"10px\\\" '\\n                'ry=\\\"10px\\\" '\\n                'stroke-linejoin=\\\"round\\\" '\\n                \\\"/>\\\"\\n            );\\n    }\\n\\n    /**\\n        @dev internal helper to create border `Rect` SVG tag\\n     */\\n    function border() internal pure returns (string memory) {\\n        return\\n            \\\"<rect \\\"\\n            'width=\\\"94%\\\" '\\n            'height=\\\"96%\\\" '\\n            'fill=\\\"transparent\\\" '\\n            'rx=\\\"10px\\\" '\\n            'ry=\\\"10px\\\" '\\n            'stroke-linejoin=\\\"round\\\" '\\n            'x=\\\"3%\\\" '\\n            'y=\\\"2%\\\" '\\n            'stroke-dasharray=\\\"1,6\\\" '\\n            'stroke=\\\"white\\\" '\\n            \\\"/>\\\";\\n    }\\n\\n    /**\\n        @dev internal helper to create group `G` SVG tag\\n     */\\n    function g(uint256 gradientsCount) internal pure returns (bytes memory) {\\n        string memory background = \\\"\\\";\\n        for (uint256 i = 0; i < gradientsCount; i++) {\\n            background = string.concat(background, string(rect(i)));\\n        }\\n        return abi.encodePacked(\\\"<g>\\\", background, border(), \\\"</g>\\\");\\n    }\\n\\n    /**\\n        @dev internal helper to create XEN logo line pattern with 2 SVG `lines`\\n     */\\n    function logo() internal pure returns (bytes memory) {\\n        return abi.encodePacked();\\n    }\\n\\n    /**\\n        @dev internal helper to create `Text` SVG tag with XEN Crypto contract data\\n     */\\n    function contractData(string memory symbol, address xenAddress) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                \\\"<text \\\"\\n                'x=\\\"50%\\\" '\\n                'y=\\\"5%\\\" '\\n                'class=\\\"base small\\\" '\\n                'dominant-baseline=\\\"middle\\\" '\\n                'text-anchor=\\\"middle\\\">',\\n                symbol,\\n                unicode\\\"\u30fb\\\",\\n                xenAddress.toHexString(),\\n                \\\"</text>\\\"\\n            );\\n    }\\n\\n    /**\\n        @dev internal helper to create 1st part of metadata section of SVG\\n     */\\n    function meta1(\\n        uint256 tokenId,\\n        uint256 amount,\\n        uint256 apy,\\n        uint256 rarityScore\\n    ) internal pure returns (bytes memory) {\\n        bytes memory part1 = abi.encodePacked(\\n            \\\"<text \\\"\\n            'x=\\\"50%\\\" '\\n            'y=\\\"50%\\\" '\\n            'class=\\\"base \\\" '\\n            'dominant-baseline=\\\"middle\\\" '\\n            'text-anchor=\\\"middle\\\">'\\n            \\\"XEN CRYPTO\\\"\\n            \\\"</text>\\\"\\n            \\\"<text \\\"\\n            'x=\\\"50%\\\" '\\n            'y=\\\"56%\\\" '\\n            'class=\\\"base burn\\\" '\\n            'text-anchor=\\\"middle\\\" '\\n            'dominant-baseline=\\\"middle\\\"> ',\\n            amount > 0 ? string.concat(amount.toFormattedString(), \\\" X\\\") : \\\"\\\",\\n            \\\"</text>\\\"\\n            \\\"<text \\\"\\n            'x=\\\"18%\\\" '\\n            'y=\\\"62%\\\" '\\n            'class=\\\"base meta\\\" '\\n            'dominant-baseline=\\\"middle\\\"> '\\n            \\\"#\\\",\\n            tokenId.toString(),\\n            \\\"</text>\\\"\\n            \\\"<text \\\"\\n            'x=\\\"82%\\\" '\\n            'y=\\\"62%\\\" '\\n            'class=\\\"base meta series\\\" '\\n            'dominant-baseline=\\\"middle\\\" '\\n            'text-anchor=\\\"end\\\" >STAKE</text>'\\n        );\\n        bytes memory part2 = abi.encodePacked(\\n            \\\"<text \\\"\\n            'x=\\\"18%\\\" '\\n            'y=\\\"68%\\\" '\\n            'class=\\\"base meta\\\" '\\n            'dominant-baseline=\\\"middle\\\" >'\\n            \\\"APY: \\\",\\n            apy.toString(),\\n            \\\"%\\\"\\n            \\\"</text>\\\"\\n            \\\"<text \\\"\\n            'x=\\\"18%\\\" '\\n            'y=\\\"72%\\\" '\\n            'class=\\\"base meta\\\" '\\n            'dominant-baseline=\\\"middle\\\" >'\\n            \\\"Rarity: \\\",\\n            rarityScore.toString(),\\n            \\\"</text>\\\"\\n        );\\n        return abi.encodePacked(part1, part2);\\n    }\\n\\n    /**\\n        @dev internal helper to create 2nd part of metadata section of SVG\\n     */\\n    function meta2(uint256 term, uint256 maturityTs) internal pure returns (bytes memory) {\\n        bytes memory part3 = abi.encodePacked(\\n            \\\"<text \\\"\\n            'x=\\\"18%\\\" '\\n            'y=\\\"76%\\\" '\\n            'class=\\\"base meta\\\" '\\n            'dominant-baseline=\\\"middle\\\" >'\\n            \\\"Term: \\\",\\n            term.toString(),\\n            \\\" days\\\"\\n            \\\"</text>\\\"\\n            \\\"<text \\\"\\n            'x=\\\"18%\\\" '\\n            'y=\\\"80%\\\" '\\n            'class=\\\"base meta\\\" '\\n            'dominant-baseline=\\\"middle\\\" >'\\n            \\\"Maturity: \\\",\\n            maturityTs.asString(),\\n            \\\"</text>\\\"\\n        );\\n        return abi.encodePacked(part3);\\n    }\\n\\n    /**\\n        @dev main internal helper to create SVG file representing XENFT\\n     */\\n    function image(SvgParams memory params, Gradient[] memory gradients) internal pure returns (bytes memory) {\\n        string memory mark = _STAKE;\\n        bytes memory graphics = abi.encodePacked(defs(gradients[0]), _STYLE, g(gradients.length), _LOGO, mark);\\n        bytes memory metadata = abi.encodePacked(\\n            contractData(params.symbol, params.xenAddress),\\n            meta1(params.tokenId, params.amount, params.apy, params.rarityScore),\\n            meta2(params.term, params.maturityTs)\\n        );\\n        return\\n            abi.encodePacked(\\n                \\\"<svg \\\"\\n                'xmlns=\\\"http://www.w3.org/2000/svg\\\" '\\n                'preserveAspectRatio=\\\"xMinYMin meet\\\" '\\n                'viewBox=\\\"0 0 350 566\\\">',\\n                graphics,\\n                metadata,\\n                \\\"</svg>\\\"\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/StakeMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./StakeInfo.sol\\\";\\nimport \\\"./DateTime.sol\\\";\\nimport \\\"./FormattedStrings.sol\\\";\\nimport \\\"./StakeSVG.sol\\\";\\n\\n/**\\n    @dev Library contains methods to generate on-chain NFT metadata\\n*/\\nlibrary StakeMetadata {\\n    using DateTime for uint256;\\n    using StakeInfo for uint256;\\n    using Strings for uint256;\\n\\n    // PRIVATE HELPERS\\n\\n    // The following pure methods returning arrays are workaround to use array constants,\\n    // not yet available in Solidity\\n\\n    /**\\n        @dev private helper to generate SVG gradients\\n     */\\n    function _commonCategoryGradients() private pure returns (StakeSVG.Gradient[] memory gradients) {\\n        StakeSVG.Color[] memory colors = new StakeSVG.Color[](3);\\n        colors[0] = StakeSVG.Color({h: 50, s: 10, l: 36, a: 1, off: 0});\\n        colors[1] = StakeSVG.Color({h: 50, s: 10, l: 12, a: 1, off: 50});\\n        colors[2] = StakeSVG.Color({h: 50, s: 10, l: 5, a: 1, off: 100});\\n        gradients = new StakeSVG.Gradient[](1);\\n        gradients[0] = StakeSVG.Gradient({colors: colors, id: 0, coords: [uint256(50), 0, 50, 100]});\\n    }\\n\\n    // PUBLIC INTERFACE\\n\\n    /**\\n        @dev public interface to generate SVG image based on XENFT params\\n     */\\n    function svgData(uint256 tokenId, uint256 info, address token) external view returns (bytes memory) {\\n        string memory symbol = IERC20Metadata(token).symbol();\\n        StakeSVG.SvgParams memory params = StakeSVG.SvgParams({\\n            symbol: symbol,\\n            xenAddress: token,\\n            tokenId: tokenId,\\n            term: info.getTerm(),\\n            maturityTs: info.getMaturityTs(),\\n            amount: info.getAmount(),\\n            apy: info.getAPY(),\\n            rarityScore: info.getRarityScore(),\\n            rarityBits: info.getRarityBits()\\n        });\\n        return StakeSVG.image(params, _commonCategoryGradients());\\n    }\\n\\n    function _attr1(uint256 amount, uint256 apy) private pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                '{\\\"trait_type\\\":\\\"Amount\\\",\\\"value\\\":\\\"',\\n                amount.toString(),\\n                '\\\"},'\\n                '{\\\"trait_type\\\":\\\"APY\\\",\\\"value\\\":\\\"',\\n                apy.toString(),\\n                '%\\\"},'\\n            );\\n    }\\n\\n    function _attr2(uint256 term, uint256 maturityTs) private pure returns (bytes memory) {\\n        (uint256 year, string memory month) = DateTime.yearAndMonth(maturityTs);\\n        return\\n            abi.encodePacked(\\n                '{\\\"trait_type\\\":\\\"Maturity DateTime\\\",\\\"value\\\":\\\"',\\n                maturityTs.asString(),\\n                '\\\"},'\\n                '{\\\"trait_type\\\":\\\"Term\\\",\\\"value\\\":\\\"',\\n                term.toString(),\\n                '\\\"},'\\n                '{\\\"trait_type\\\":\\\"Maturity Year\\\",\\\"value\\\":\\\"',\\n                year.toString(),\\n                '\\\"},'\\n                '{\\\"trait_type\\\":\\\"Maturity Month\\\",\\\"value\\\":\\\"',\\n                month,\\n                '\\\"},'\\n            );\\n    }\\n\\n    function _attr3(uint256 rarityScore, uint256) private pure returns (bytes memory) {\\n        return abi.encodePacked('{\\\"trait_type\\\":\\\"Rarity\\\",\\\"value\\\":\\\"', rarityScore.toString(), '\\\"}');\\n    }\\n\\n    /**\\n        @dev private helper to construct attributes portion of NFT metadata\\n     */\\n    function attributes(uint256 stakeInfo) external pure returns (bytes memory) {\\n        (\\n            uint256 term,\\n            uint256 maturityTs,\\n            uint256 amount,\\n            uint256 apy,\\n            uint256 rarityScore,\\n            uint256 rarityBits\\n        ) = StakeInfo.decodeStakeInfo(stakeInfo);\\n        return\\n            abi.encodePacked(\\\"[\\\", _attr1(amount, apy), _attr2(term, maturityTs), _attr3(rarityScore, rarityBits), \\\"]\\\");\\n    }\\n\\n    function formattedString(uint256 n) public pure returns (string memory) {\\n        return FormattedStrings.toFormattedString(n);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/StakeInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\n// mapping: NFT tokenId => StakeInfo (used in tokenURI generation + other contracts)\\n// StakeInfo encoded as:\\n//      term (uint16)\\n//      | maturityTs (uint64)\\n//      | amount (uint128) TODO: storing here vs. separately as full uint256 ???\\n//      | apy (uint16)\\n//      | rarityScore (uint16)\\n//      | rarityBits (uint16):\\n//          [15] tokenIdIsPrime\\n//          [14] tokenIdIsFib\\n//          [14] blockIdIsPrime\\n//          [13] blockIdIsFib\\n//          [0-13] ...\\nlibrary StakeInfo {\\n    /**\\n        @dev helper to convert Bool to U256 type and make compiler happy\\n     */\\n    // TODO: remove if not needed ???\\n    function toU256(bool x) internal pure returns (uint256 r) {\\n        assembly {\\n            r := x\\n        }\\n    }\\n\\n    /**\\n        @dev encodes StakeInfo record from its props\\n     */\\n    function encodeStakeInfo(\\n        uint256 term,\\n        uint256 maturityTs,\\n        uint256 amount,\\n        uint256 apy,\\n        uint256 rarityScore,\\n        uint256 rarityBits\\n    ) public pure returns (uint256 info) {\\n        info = info | (rarityBits & 0xFFFF);\\n        info = info | ((rarityScore & 0xFFFF) << 16);\\n        info = info | ((apy & 0xFFFF) << 32);\\n        info = info | ((amount & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) << 48);\\n        info = info | ((maturityTs & 0xFFFFFFFFFFFFFFFF) << 176);\\n        info = info | ((term & 0xFFFF) << 240);\\n    }\\n\\n    /**\\n        @dev decodes StakeInfo record and extracts all of its props\\n     */\\n    function decodeStakeInfo(\\n        uint256 info\\n    )\\n        public\\n        pure\\n        returns (uint256 term, uint256 maturityTs, uint256 amount, uint256 apy, uint256 rarityScore, uint256 rarityBits)\\n    {\\n        term = uint16(info >> 240);\\n        maturityTs = uint64(info >> 176);\\n        amount = uint128(info >> 48);\\n        apy = uint16(info >> 32);\\n        rarityScore = uint16(info >> 16);\\n        rarityBits = uint16(info);\\n    }\\n\\n    /**\\n        @dev extracts `term` prop from encoded StakeInfo\\n     */\\n    function getTerm(uint256 info) public pure returns (uint256 term) {\\n        (term, , , , , ) = decodeStakeInfo(info);\\n    }\\n\\n    /**\\n        @dev extracts `maturityTs` prop from encoded StakeInfo\\n     */\\n    function getMaturityTs(uint256 info) public pure returns (uint256 maturityTs) {\\n        (, maturityTs, , , , ) = decodeStakeInfo(info);\\n    }\\n\\n    /**\\n        @dev extracts `amount` prop from encoded StakeInfo\\n     */\\n    function getAmount(uint256 info) public pure returns (uint256 amount) {\\n        (, , amount, , , ) = decodeStakeInfo(info);\\n    }\\n\\n    /**\\n        @dev extracts `APY` prop from encoded StakeInfo\\n     */\\n    function getAPY(uint256 info) public pure returns (uint256 apy) {\\n        (, , , apy, , ) = decodeStakeInfo(info);\\n    }\\n\\n    /**\\n        @dev extracts `rarityScore` prop from encoded StakeInfo\\n     */\\n    function getRarityScore(uint256 info) public pure returns (uint256 rarityScore) {\\n        (, , , , rarityScore, ) = decodeStakeInfo(info);\\n    }\\n\\n    /**\\n        @dev extracts `rarityBits` prop from encoded StakeInfo\\n     */\\n    function getRarityBits(uint256 info) public pure returns (uint256 rarityBits) {\\n        (, , , , , rarityBits) = decodeStakeInfo(info);\\n    }\\n\\n    /**\\n        @dev decodes boolean flags from `rarityBits` prop\\n     */\\n    function decodeRarityBits(\\n        uint256 rarityBits\\n    ) public pure returns (bool isPrime, bool isFib, bool blockIsPrime, bool blockIsFib) {\\n        isPrime = rarityBits & 0x0008 > 0;\\n        isFib = rarityBits & 0x0004 > 0;\\n        blockIsPrime = rarityBits & 0x0002 > 0;\\n        blockIsFib = rarityBits & 0x0001 > 0;\\n    }\\n\\n    /**\\n        @dev encodes boolean flags to `rarityBits` prop\\n     */\\n    function encodeRarityBits(\\n        bool isPrime,\\n        bool isFib,\\n        bool blockIsPrime,\\n        bool blockIsFib\\n    ) public pure returns (uint256 rarityBits) {\\n        rarityBits = rarityBits | ((toU256(isPrime) << 3) & 0xFFFF);\\n        rarityBits = rarityBits | ((toU256(isFib) << 2) & 0xFFFF);\\n        rarityBits = rarityBits | ((toU256(blockIsPrime) << 1) & 0xFFFF);\\n        rarityBits = rarityBits | ((toU256(blockIsFib)) & 0xFFFF);\\n    }\\n\\n    /**\\n        @dev extracts `rarityBits` prop from encoded StakeInfo\\n     */\\n    function getRarityBitsDecoded(\\n        uint256 info\\n    ) public pure returns (bool isPrime, bool isFib, bool blockIsPrime, bool blockIsFib) {\\n        (, , , , , uint256 rarityBits) = decodeStakeInfo(info);\\n        (isPrime, isFib, blockIsPrime, blockIsFib) = decodeRarityBits(rarityBits);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/FormattedStrings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nlibrary FormattedStrings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n            Base on OpenZeppelin `toString` method from `String` library\\n     */\\n    function toFormattedString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        uint256 pos;\\n        uint256 comas = digits / 3;\\n        digits = digits + (digits % 3 == 0 ? comas - 1 : comas);\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            if (pos == 3) {\\n                buffer[digits] = \\\",\\\";\\n                pos = 0;\\n            } else {\\n                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n                value /= 10;\\n                pos++;\\n            }\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/ERC2771Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\nabstract contract ERC2771Context is Context {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    // one-time settable var\\n    address internal _trustedForwarder;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(address trustedForwarder) {\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual override returns (address sender) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return super._msgSender();\\n        }\\n    }\\n\\n    function _msgData() internal view virtual override returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return super._msgData();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./BokkyPooBahsDateTimeLibrary.sol\\\";\\n\\n/*\\n    @dev        Library to convert epoch timestamp to a human-readable Date-Time string\\n    @dependency uses BokkyPooBahsDateTimeLibrary.sol library internally\\n */\\nlibrary DateTime {\\n    using Strings for uint256;\\n\\n    bytes public constant MONTHS = bytes(\\\"JanFebMarAprMayJunJulAugSepOctNovDec\\\");\\n\\n    /**\\n     *   @dev returns month as short (3-letter) string\\n     */\\n    function monthAsString(uint256 idx) internal pure returns (string memory) {\\n        require(idx > 0, \\\"bad idx\\\");\\n        bytes memory str = new bytes(3);\\n        uint256 offset = (idx - 1) * 3;\\n        str[0] = bytes1(MONTHS[offset]);\\n        str[1] = bytes1(MONTHS[offset + 1]);\\n        str[2] = bytes1(MONTHS[offset + 2]);\\n        return string(str);\\n    }\\n\\n    /**\\n     *   @dev returns string representation of number left-padded for 2 symbols\\n     */\\n    function asPaddedString(uint256 n) internal pure returns (string memory) {\\n        if (n == 0) return \\\"00\\\";\\n        if (n < 10) return string.concat(\\\"0\\\", n.toString());\\n        return n.toString();\\n    }\\n\\n    /**\\n     *   @dev returns string of format 'Jan 01, 2022 18:00 UTC' for a given timestamp\\n     */\\n    function asString(uint256 ts) external pure returns (string memory) {\\n        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, ) = BokkyPooBahsDateTimeLibrary\\n            .timestampToDateTime(ts);\\n        return\\n            string(\\n                abi.encodePacked(\\n                    monthAsString(month),\\n                    \\\" \\\",\\n                    day.toString(),\\n                    \\\", \\\",\\n                    year.toString(),\\n                    \\\" \\\",\\n                    asPaddedString(hour),\\n                    \\\":\\\",\\n                    asPaddedString(minute),\\n                    \\\" UTC\\\"\\n                )\\n            );\\n    }\\n\\n    /**\\n     *   @dev returns (year, month as string) components of a date by timestamp\\n     */\\n    function yearAndMonth(uint256 ts) external pure returns (uint256, string memory) {\\n        (uint256 year, uint256 month, , , , ) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(ts);\\n        return (year, monthAsString(month));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/BokkyPooBahsDateTimeLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\n// ----------------------------------------------------------------------------\\n// BokkyPooBah's DateTime Library v1.01\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n\\nlibrary BokkyPooBahsDateTimeLibrary {\\n    uint256 constant _SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 constant _SECONDS_PER_HOUR = 60 * 60;\\n    uint256 constant _SECONDS_PER_MINUTE = 60;\\n    int256 constant _OFFSET19700101 = 2440588;\\n\\n    uint256 constant _DOW_FRI = 5;\\n    uint256 constant _DOW_SAT = 6;\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\n    // the date conversion algorithm from\\n    //   https://aa.usno.navy.mil/faq/JD_formula.html\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // days = day\\n    //      - 32075\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n    //      - offset\\n    // ------------------------------------------------------------------------\\n    function _daysFromDate(uint256 year, uint256 month, uint256 day) private pure returns (uint256 _days) {\\n        require(year >= 1970);\\n        int256 _year = int256(year);\\n        int256 _month = int256(month);\\n        int256 _day = int256(day);\\n\\n        int256 __days = _day -\\n            32075 +\\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\\n            4 +\\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\n            12 -\\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\n            4 -\\n            _OFFSET19700101;\\n\\n        _days = uint256(__days);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    function _daysToDate(uint256 _days) private pure returns (uint256 year, uint256 month, uint256 day) {\\n        int256 __days = int256(_days);\\n\\n        int256 L = __days + 68569 + _OFFSET19700101;\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n\\n    function timestampFromDate(uint256 year, uint256 month, uint256 day) internal pure returns (uint256 timestamp) {\\n        timestamp = _daysFromDate(year, month, day) * _SECONDS_PER_DAY;\\n    }\\n\\n    function timestampFromDateTime(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 hour,\\n        uint256 minute,\\n        uint256 second\\n    ) internal pure returns (uint256 timestamp) {\\n        timestamp =\\n            _daysFromDate(year, month, day) *\\n            _SECONDS_PER_DAY +\\n            hour *\\n            _SECONDS_PER_HOUR +\\n            minute *\\n            _SECONDS_PER_MINUTE +\\n            second;\\n    }\\n\\n    function timestampToDate(uint256 timestamp) internal pure returns (uint256 year, uint256 month, uint256 day) {\\n        (year, month, day) = _daysToDate(timestamp / _SECONDS_PER_DAY);\\n    }\\n\\n    function timestampToDateTime(\\n        uint256 timestamp\\n    ) internal pure returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) {\\n        (year, month, day) = _daysToDate(timestamp / _SECONDS_PER_DAY);\\n        uint256 secs = timestamp % _SECONDS_PER_DAY;\\n        hour = secs / _SECONDS_PER_HOUR;\\n        secs = secs % _SECONDS_PER_HOUR;\\n        minute = secs / _SECONDS_PER_MINUTE;\\n        second = secs % _SECONDS_PER_MINUTE;\\n    }\\n\\n    function isValidDate(uint256 year, uint256 month, uint256 day) internal pure returns (bool valid) {\\n        if (year >= 1970 && month > 0 && month <= 12) {\\n            uint256 daysInMonth = _getDaysInMonth(year, month);\\n            if (day > 0 && day <= daysInMonth) {\\n                valid = true;\\n            }\\n        }\\n    }\\n\\n    function isValidDateTime(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 hour,\\n        uint256 minute,\\n        uint256 second\\n    ) internal pure returns (bool valid) {\\n        if (isValidDate(year, month, day)) {\\n            if (hour < 24 && minute < 60 && second < 60) {\\n                valid = true;\\n            }\\n        }\\n    }\\n\\n    function isLeapYear(uint256 timestamp) internal pure returns (bool leapYear) {\\n        (uint256 year, , ) = _daysToDate(timestamp / _SECONDS_PER_DAY);\\n        leapYear = _isLeapYear(year);\\n    }\\n\\n    function _isLeapYear(uint256 year) private pure returns (bool leapYear) {\\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\\n    }\\n\\n    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\\n        weekDay = getDayOfWeek(timestamp) <= _DOW_FRI;\\n    }\\n\\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\\n        weekEnd = getDayOfWeek(timestamp) >= _DOW_SAT;\\n    }\\n\\n    function getDaysInMonth(uint256 timestamp) internal pure returns (uint256 daysInMonth) {\\n        (uint256 year, uint256 month, ) = _daysToDate(timestamp / _SECONDS_PER_DAY);\\n        daysInMonth = _getDaysInMonth(year, month);\\n    }\\n\\n    function _getDaysInMonth(uint256 year, uint256 month) private pure returns (uint256 daysInMonth) {\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\n            daysInMonth = 31;\\n        } else if (month != 2) {\\n            daysInMonth = 30;\\n        } else {\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\n        }\\n    }\\n\\n    // 1 = Monday, 7 = Sunday\\n    function getDayOfWeek(uint256 timestamp) internal pure returns (uint256 dayOfWeek) {\\n        uint256 _days = timestamp / _SECONDS_PER_DAY;\\n        dayOfWeek = ((_days + 3) % 7) + 1;\\n    }\\n\\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\\n        (year, , ) = _daysToDate(timestamp / _SECONDS_PER_DAY);\\n    }\\n\\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\\n        (, month, ) = _daysToDate(timestamp / _SECONDS_PER_DAY);\\n    }\\n\\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\\n        (, , day) = _daysToDate(timestamp / _SECONDS_PER_DAY);\\n    }\\n\\n    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\\n        uint256 secs = timestamp % _SECONDS_PER_DAY;\\n        hour = secs / _SECONDS_PER_HOUR;\\n    }\\n\\n    function getMinute(uint256 timestamp) internal pure returns (uint256 minute) {\\n        uint256 secs = timestamp % _SECONDS_PER_HOUR;\\n        minute = secs / _SECONDS_PER_MINUTE;\\n    }\\n\\n    function getSecond(uint256 timestamp) internal pure returns (uint256 second) {\\n        second = timestamp % _SECONDS_PER_MINUTE;\\n    }\\n\\n    function addYears(uint256 timestamp, uint256 _years) internal pure returns (uint256 newTimestamp) {\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / _SECONDS_PER_DAY);\\n        year += _years;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * _SECONDS_PER_DAY + (timestamp % _SECONDS_PER_DAY);\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addMonths(uint256 timestamp, uint256 _months) internal pure returns (uint256 newTimestamp) {\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / _SECONDS_PER_DAY);\\n        month += _months;\\n        year += (month - 1) / 12;\\n        month = ((month - 1) % 12) + 1;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * _SECONDS_PER_DAY + (timestamp % _SECONDS_PER_DAY);\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addDays(uint256 timestamp, uint256 _days) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp + _days * _SECONDS_PER_DAY;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addHours(uint256 timestamp, uint256 _hours) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp + _hours * _SECONDS_PER_HOUR;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addMinutes(uint256 timestamp, uint256 _minutes) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp + _minutes * _SECONDS_PER_MINUTE;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp + _seconds;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function subYears(uint256 timestamp, uint256 _years) internal pure returns (uint256 newTimestamp) {\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / _SECONDS_PER_DAY);\\n        year -= _years;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * _SECONDS_PER_DAY + (timestamp % _SECONDS_PER_DAY);\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subMonths(uint256 timestamp, uint256 _months) internal pure returns (uint256 newTimestamp) {\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / _SECONDS_PER_DAY);\\n        uint256 yearMonth = year * 12 + (month - 1) - _months;\\n        year = yearMonth / 12;\\n        month = (yearMonth % 12) + 1;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * _SECONDS_PER_DAY + (timestamp % _SECONDS_PER_DAY);\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subDays(uint256 timestamp, uint256 _days) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp - _days * _SECONDS_PER_DAY;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subHours(uint256 timestamp, uint256 _hours) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp - _hours * _SECONDS_PER_HOUR;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subMinutes(uint256 timestamp, uint256 _minutes) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp - _minutes * _SECONDS_PER_MINUTE;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {\\n        newTimestamp = timestamp - _seconds;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _years) {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint256 fromYear, , ) = _daysToDate(fromTimestamp / _SECONDS_PER_DAY);\\n        (uint256 toYear, , ) = _daysToDate(toTimestamp / _SECONDS_PER_DAY);\\n        _years = toYear - fromYear;\\n    }\\n\\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _months) {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint256 fromYear, uint256 fromMonth, ) = _daysToDate(fromTimestamp / _SECONDS_PER_DAY);\\n        (uint256 toYear, uint256 toMonth, ) = _daysToDate(toTimestamp / _SECONDS_PER_DAY);\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\n    }\\n\\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _days) {\\n        require(fromTimestamp <= toTimestamp);\\n        _days = (toTimestamp - fromTimestamp) / _SECONDS_PER_DAY;\\n    }\\n\\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _hours) {\\n        require(fromTimestamp <= toTimestamp);\\n        _hours = (toTimestamp - fromTimestamp) / _SECONDS_PER_HOUR;\\n    }\\n\\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _minutes) {\\n        require(fromTimestamp <= toTimestamp);\\n        _minutes = (toTimestamp - fromTimestamp) / _SECONDS_PER_MINUTE;\\n    }\\n\\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _seconds) {\\n        require(fromTimestamp <= toTimestamp);\\n        _seconds = toTimestamp - fromTimestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/Array.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nlibrary Array {\\n    function idx(uint256[] memory arr, uint256 item) internal pure returns (uint256 i) {\\n        for (i = 1; i <= arr.length; i++) {\\n            if (arr[i - 1] == item) {\\n                return i;\\n            }\\n        }\\n        i = 0;\\n    }\\n\\n    function addItem(uint256[] storage arr, uint256 item) internal {\\n        if (idx(arr, item) == 0) {\\n            arr.push(item);\\n        }\\n    }\\n\\n    function removeItem(uint256[] storage arr, uint256 item) internal {\\n        uint256 i = idx(arr, item);\\n        if (i > 0) {\\n            arr[i - 1] = arr[arr.length - 1];\\n            arr.pop();\\n        }\\n    }\\n\\n    function contains(uint256[] memory container, uint256[] memory items) internal pure returns (bool) {\\n        if (items.length == 0) return true;\\n        for (uint256 i = 0; i < items.length; i++) {\\n            bool itemIsContained = false;\\n            for (uint256 j = 0; j < container.length; j++) {\\n                itemIsContained = items[i] == container[j];\\n            }\\n            if (!itemIsContained) return false;\\n        }\\n        return true;\\n    }\\n\\n    function asSingletonArray(uint256 element) internal pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n        return array;\\n    }\\n\\n    function hasDuplicatesOrZeros(uint256[] memory array) internal pure returns (bool) {\\n        for (uint256 i = 0; i < array.length; i++) {\\n            if (array[i] == 0) return true;\\n            for (uint256 j = 0; j < array.length; j++) {\\n                if (array[i] == array[j] && i != j) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function hasRoguesOrZeros(uint256[] memory array) internal pure returns (bool) {\\n        uint256 _first = array[0];\\n        for (uint256 i = 0; i < array.length; i++) {\\n            if (array[i] == 0 || array[i] != _first) return true;\\n        }\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IXENStakeProxying.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IXENStakeProxying {\\n    function callStake(uint256 amount, uint256 term) external;\\n\\n    function callTransfer(address to) external;\\n\\n    function callWithdraw() external;\\n\\n    function powerDown() external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IXENStake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IXENStake {\\n    event CreateStake(address indexed user, uint256 indexed tokenId, uint256 amount, uint256 term);\\n    event EndStake(address indexed user, uint256 indexed tokenId);\\n\\n    function createStake(uint256 amount, uint256 term) external returns (uint256);\\n\\n    function endStake(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IERC2771.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IERC2771 {\\n    function isTrustedForwarder(address forwarder) external;\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\n\\n/**\\n * @title  OperatorFilterer\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\n *         registrant's entries in the OperatorFilterRegistry.\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\n */\\nabstract contract OperatorFilterer {\\n    error OperatorNotAllowed(address operator);\\n\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\n        IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\\n\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (subscribe) {\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\n            } else {\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\n                } else {\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\n                }\\n            }\\n        }\\n    }\\n\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        _checkFilterOperator(operator);\\n        _;\\n    }\\n\\n    function _checkFilterOperator(address operator) internal view virtual {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n    function register(address registrant) external;\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n    function unregister(address addr) external;\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n    function subscriptionOf(address addr) external returns (address registrant);\\n    function subscribers(address registrant) external returns (address[] memory);\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n    function filteredOperators(address addr) external returns (address[] memory);\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n    function isRegistered(address addr) external returns (bool);\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"operator-filter-registry/src/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\n\\n/**\\n * @title  DefaultOperatorFilterer\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\n */\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\n    address constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);\\n\\n    constructor() OperatorFilterer(DEFAULT_SUBSCRIPTION, true) {}\\n}\\n\"\r\n    },\r\n    \"abdk-libraries-solidity/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n  /*\\n   * Minimum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n  /*\\n   * Maximum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromInt (int256 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n      return int128 (x << 64);\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n   * rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64-bit integer number\\n   */\\n  function toInt (int128 x) internal pure returns (int64) {\\n    unchecked {\\n      return int64 (x >> 64);\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x <= 0x7FFFFFFFFFFFFFFF);\\n      return int128 (int256 (x << 64));\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n   * number rounding down.  Revert on underflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return unsigned 64-bit integer number\\n   */\\n  function toUInt (int128 x) internal pure returns (uint64) {\\n    unchecked {\\n      require (x >= 0);\\n      return uint64 (uint128 (x >> 64));\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n   * number rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 128.128-bin fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function from128x128 (int256 x) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = x >> 64;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n   * number.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 128.128 fixed point number\\n   */\\n  function to128x128 (int128 x) internal pure returns (int256) {\\n    unchecked {\\n      return int256 (x) << 64;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) + y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) - y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) * y >> 64;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y signed 256-bit integer number\\n   * @return signed 256-bit integer number\\n   */\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\n    unchecked {\\n      if (x == MIN_64x64) {\\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n          y <= 0x1000000000000000000000000000000000000000000000000);\\n        return -y << 63;\\n      } else {\\n        bool negativeResult = false;\\n        if (x < 0) {\\n          x = -x;\\n          negativeResult = true;\\n        }\\n        if (y < 0) {\\n          y = -y; // We rely on overflow behavior here\\n          negativeResult = !negativeResult;\\n        }\\n        uint256 absoluteResult = mulu (x, uint256 (y));\\n        if (negativeResult) {\\n          require (absoluteResult <=\\n            0x8000000000000000000000000000000000000000000000000000000000000000);\\n          return -int256 (absoluteResult); // We rely on overflow behavior here\\n        } else {\\n          require (absoluteResult <=\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n          return int256 (absoluteResult);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\n    unchecked {\\n      if (y == 0) return 0;\\n\\n      require (x >= 0);\\n\\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\\n\\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      hi <<= 64;\\n\\n      require (hi <=\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\n      return hi + lo;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n      int256 result = (int256 (x) << 64) / y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @param y signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n\\n      bool negativeResult = false;\\n      if (x < 0) {\\n        x = -x; // We rely on overflow behavior here\\n        negativeResult = true;\\n      }\\n      if (y < 0) {\\n        y = -y; // We rely on overflow behavior here\\n        negativeResult = !negativeResult;\\n      }\\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\n      if (negativeResult) {\\n        require (absoluteResult <= 0x80000000000000000000000000000000);\\n        return -int128 (absoluteResult); // We rely on overflow behavior here\\n      } else {\\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (absoluteResult); // We rely on overflow behavior here\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n      uint128 result = divuu (x, y);\\n      require (result <= uint128 (MAX_64x64));\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function neg (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != MIN_64x64);\\n      return -x;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function abs (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != MIN_64x64);\\n      return x < 0 ? -x : x;\\n    }\\n  }\\n\\n  /**\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function inv (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != 0);\\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      return int128 ((int256 (x) + int256 (y)) >> 1);\\n    }\\n  }\\n\\n  /**\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n   * Revert on overflow or in case x * y is negative.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 m = int256 (x) * int256 (y);\\n      require (m >= 0);\\n      require (m <\\n          0x4000000000000000000000000000000000000000000000000000000000000000);\\n      return int128 (sqrtu (uint256 (m)));\\n    }\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y uint256 value\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\n    unchecked {\\n      bool negative = x < 0 && y & 1 == 1;\\n\\n      uint256 absX = uint128 (x < 0 ? -x : x);\\n      uint256 absResult;\\n      absResult = 0x100000000000000000000000000000000;\\n\\n      if (absX <= 0x10000000000000000) {\\n        absX <<= 63;\\n        while (y != 0) {\\n          if (y & 0x1 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x2 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x4 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x8 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          y >>= 4;\\n        }\\n\\n        absResult >>= 64;\\n      } else {\\n        uint256 absXShift = 63;\\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\\n\\n        uint256 resultShift = 0;\\n        while (y != 0) {\\n          require (absXShift < 64);\\n\\n          if (y & 0x1 != 0) {\\n            absResult = absResult * absX >> 127;\\n            resultShift += absXShift;\\n            if (absResult > 0x100000000000000000000000000000000) {\\n              absResult >>= 1;\\n              resultShift += 1;\\n            }\\n          }\\n          absX = absX * absX >> 127;\\n          absXShift <<= 1;\\n          if (absX >= 0x100000000000000000000000000000000) {\\n              absX >>= 1;\\n              absXShift += 1;\\n          }\\n\\n          y >>= 1;\\n        }\\n\\n        require (resultShift < 64);\\n        absResult >>= 64 - resultShift;\\n      }\\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x >= 0);\\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function log_2 (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x > 0);\\n\\n      int256 msb = 0;\\n      int256 xc = x;\\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      int256 result = msb - 64 << 64;\\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n        ux *= ux;\\n        uint256 b = ux >> 255;\\n        ux >>= 127 + b;\\n        result += bit * int256 (b);\\n      }\\n\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function ln (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x > 0);\\n\\n      return int128 (int256 (\\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp_2 (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x < 0x400000000000000000); // Overflow\\n\\n      if (x < -0x400000000000000000) return 0; // Underflow\\n\\n      uint256 result = 0x80000000000000000000000000000000;\\n\\n      if (x & 0x8000000000000000 > 0)\\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n      if (x & 0x4000000000000000 > 0)\\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n      if (x & 0x2000000000000000 > 0)\\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n      if (x & 0x1000000000000000 > 0)\\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n      if (x & 0x800000000000000 > 0)\\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n      if (x & 0x400000000000000 > 0)\\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n      if (x & 0x200000000000000 > 0)\\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n      if (x & 0x100000000000000 > 0)\\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n      if (x & 0x80000000000000 > 0)\\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n      if (x & 0x40000000000000 > 0)\\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n      if (x & 0x20000000000000 > 0)\\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n      if (x & 0x10000000000000 > 0)\\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n      if (x & 0x8000000000000 > 0)\\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n      if (x & 0x4000000000000 > 0)\\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n      if (x & 0x2000000000000 > 0)\\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\n      if (x & 0x1000000000000 > 0)\\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n      if (x & 0x800000000000 > 0)\\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n      if (x & 0x400000000000 > 0)\\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n      if (x & 0x200000000000 > 0)\\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n      if (x & 0x100000000000 > 0)\\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n      if (x & 0x80000000000 > 0)\\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n      if (x & 0x40000000000 > 0)\\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n      if (x & 0x20000000000 > 0)\\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n      if (x & 0x10000000000 > 0)\\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n      if (x & 0x8000000000 > 0)\\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n      if (x & 0x4000000000 > 0)\\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n      if (x & 0x2000000000 > 0)\\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n      if (x & 0x1000000000 > 0)\\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n      if (x & 0x800000000 > 0)\\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n      if (x & 0x400000000 > 0)\\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n      if (x & 0x200000000 > 0)\\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n      if (x & 0x100000000 > 0)\\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n      if (x & 0x80000000 > 0)\\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n      if (x & 0x40000000 > 0)\\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n      if (x & 0x20000000 > 0)\\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n      if (x & 0x10000000 > 0)\\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n      if (x & 0x8000000 > 0)\\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n      if (x & 0x4000000 > 0)\\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n      if (x & 0x2000000 > 0)\\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n      if (x & 0x1000000 > 0)\\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n      if (x & 0x800000 > 0)\\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n      if (x & 0x400000 > 0)\\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n      if (x & 0x200000 > 0)\\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n      if (x & 0x100000 > 0)\\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n      if (x & 0x80000 > 0)\\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n      if (x & 0x40000 > 0)\\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n      if (x & 0x20000 > 0)\\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n      if (x & 0x10000 > 0)\\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n      if (x & 0x8000 > 0)\\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n      if (x & 0x4000 > 0)\\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n      if (x & 0x2000 > 0)\\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n      if (x & 0x1000 > 0)\\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n      if (x & 0x800 > 0)\\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n      if (x & 0x400 > 0)\\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n      if (x & 0x200 > 0)\\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n      if (x & 0x100 > 0)\\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n      if (x & 0x80 > 0)\\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n      if (x & 0x40 > 0)\\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n      if (x & 0x20 > 0)\\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\n      if (x & 0x10 > 0)\\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n      if (x & 0x8 > 0)\\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n      if (x & 0x4 > 0)\\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n      if (x & 0x2 > 0)\\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n      if (x & 0x1 > 0)\\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n\\n      result >>= uint256 (int256 (63 - (x >> 64)));\\n      require (result <= uint256 (int256 (MAX_64x64)));\\n\\n      return int128 (int256 (result));\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x < 0x400000000000000000); // Overflow\\n\\n      if (x < -0x400000000000000000) return 0; // Underflow\\n\\n      return exp_2 (\\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 64.64-bit fixed point number\\n   */\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\n    unchecked {\\n      require (y != 0);\\n\\n      uint256 result;\\n\\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        result = (x << 64) / y;\\n      else {\\n        uint256 msb = 192;\\n        uint256 xc = x >> 192;\\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n        uint256 hi = result * (y >> 128);\\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n        uint256 xh = x >> 192;\\n        uint256 xl = x << 64;\\n\\n        if (xl < lo) xh -= 1;\\n        xl -= lo; // We rely on overflow behavior here\\n        lo = hi << 128;\\n        if (xl < lo) xh -= 1;\\n        xl -= lo; // We rely on overflow behavior here\\n\\n        assert (xh == hi >> 128);\\n\\n        result += xl / y;\\n      }\\n\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return uint128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x) private pure returns (uint128) {\\n    unchecked {\\n      if (x == 0) return 0;\\n      else {\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\\n        if (xx >= 0x4) { r <<= 1; }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return uint128 (r < r1 ? r : r1);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"@faircrypto/xen-crypto/contracts/interfaces/IStakingToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IStakingToken {\\n    event Staked(address indexed user, uint256 amount, uint256 term);\\n\\n    event Withdrawn(address indexed user, uint256 amount, uint256 reward);\\n\\n    function stake(uint256 amount, uint256 term) external;\\n\\n    function withdraw() external;\\n}\\n\"\r\n    },\r\n    \"@faircrypto/xen-crypto/contracts/interfaces/IRankedMintingToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IRankedMintingToken {\\n    event RankClaimed(address indexed user, uint256 term, uint256 rank);\\n\\n    event MintClaimed(address indexed user, uint256 rewardAmount);\\n\\n    function claimRank(uint256 term) external;\\n\\n    function claimMintReward() external;\\n}\\n\"\r\n    },\r\n    \"@faircrypto/xen-crypto/contracts/interfaces/IBurnableToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IBurnableToken {\\n    function burn(address user, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@faircrypto/xen-crypto/contracts/interfaces/IBurnRedeemable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IBurnRedeemable {\\n    event Redeemed(\\n        address indexed user,\\n        address indexed xenContract,\\n        address indexed tokenContract,\\n        uint256 xenAmount,\\n        uint256 tokenAmount\\n    );\\n\\n    function onTokenBurned(address user, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@faircrypto/xen-crypto/contracts/XENCrypto.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"./Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"abdk-libraries-solidity/ABDKMath64x64.sol\\\";\\nimport \\\"./interfaces/IStakingToken.sol\\\";\\nimport \\\"./interfaces/IRankedMintingToken.sol\\\";\\nimport \\\"./interfaces/IBurnableToken.sol\\\";\\nimport \\\"./interfaces/IBurnRedeemable.sol\\\";\\n\\ncontract XENCrypto is Context, IRankedMintingToken, IStakingToken, IBurnableToken, ERC20(\\\"XEN Crypto\\\", \\\"XEN\\\") {\\n    using Math for uint256;\\n    using ABDKMath64x64 for int128;\\n    using ABDKMath64x64 for uint256;\\n\\n    // INTERNAL TYPE TO DESCRIBE A XEN MINT INFO\\n    struct MintInfo {\\n        address user;\\n        uint256 term;\\n        uint256 maturityTs;\\n        uint256 rank;\\n        uint256 amplifier;\\n        uint256 eaaRate;\\n    }\\n\\n    // INTERNAL TYPE TO DESCRIBE A XEN STAKE\\n    struct StakeInfo {\\n        uint256 term;\\n        uint256 maturityTs;\\n        uint256 amount;\\n        uint256 apy;\\n    }\\n\\n    // PUBLIC CONSTANTS\\n\\n    uint256 public constant SECONDS_IN_DAY = 3_600 * 24;\\n    uint256 public constant DAYS_IN_YEAR = 365;\\n\\n    uint256 public constant GENESIS_RANK = 1;\\n\\n    uint256 public constant MIN_TERM = 1 * SECONDS_IN_DAY - 1;\\n    uint256 public constant MAX_TERM_START = 100 * SECONDS_IN_DAY;\\n    uint256 public constant MAX_TERM_END = 1_000 * SECONDS_IN_DAY;\\n    uint256 public constant TERM_AMPLIFIER = 15;\\n    uint256 public constant TERM_AMPLIFIER_THRESHOLD = 5_000;\\n    uint256 public constant REWARD_AMPLIFIER_START = 3_000;\\n    uint256 public constant REWARD_AMPLIFIER_END = 1;\\n    uint256 public constant EAA_PM_START = 100;\\n    uint256 public constant EAA_PM_STEP = 1;\\n    uint256 public constant EAA_RANK_STEP = 100_000;\\n    uint256 public constant WITHDRAWAL_WINDOW_DAYS = 7;\\n    uint256 public constant MAX_PENALTY_PCT = 99;\\n\\n    uint256 public constant XEN_MIN_STAKE = 0;\\n\\n    uint256 public constant XEN_MIN_BURN = 0;\\n\\n    uint256 public constant XEN_APY_START = 20;\\n    uint256 public constant XEN_APY_DAYS_STEP = 90;\\n    uint256 public constant XEN_APY_END = 2;\\n\\n    string public constant AUTHORS = \\\"@MrJackLevin @lbelyaev faircrypto.org\\\";\\n\\n    // PUBLIC STATE, READABLE VIA NAMESAKE GETTERS\\n\\n    uint256 public immutable genesisTs;\\n    uint256 public globalRank = GENESIS_RANK;\\n    uint256 public activeMinters;\\n    uint256 public activeStakes;\\n    uint256 public totalXenStaked;\\n    // user address => XEN mint info\\n    mapping(address => MintInfo) public userMints;\\n    // user address => XEN stake info\\n    mapping(address => StakeInfo) public userStakes;\\n    // user address => XEN burn amount\\n    mapping(address => uint256) public userBurns;\\n\\n    // CONSTRUCTOR\\n    constructor() {\\n        genesisTs = block.timestamp;\\n    }\\n\\n    // PRIVATE METHODS\\n\\n    /**\\n     * @dev calculates current MaxTerm based on Global Rank\\n     *      (if Global Rank crosses over TERM_AMPLIFIER_THRESHOLD)\\n     */\\n    function _calculateMaxTerm() private view returns (uint256) {\\n        if (globalRank > TERM_AMPLIFIER_THRESHOLD) {\\n            uint256 delta = globalRank.fromUInt().log_2().mul(TERM_AMPLIFIER.fromUInt()).toUInt();\\n            uint256 newMax = MAX_TERM_START + delta * SECONDS_IN_DAY;\\n            return Math.min(newMax, MAX_TERM_END);\\n        }\\n        return MAX_TERM_START;\\n    }\\n\\n    /**\\n     * @dev calculates Withdrawal Penalty depending on lateness\\n     */\\n    function _penalty(uint256 secsLate) private pure returns (uint256) {\\n        // =MIN(2^(daysLate+3)/window-1,99)\\n        uint256 daysLate = secsLate / SECONDS_IN_DAY;\\n        if (daysLate > WITHDRAWAL_WINDOW_DAYS - 1) return MAX_PENALTY_PCT;\\n        uint256 penalty = (uint256(1) << (daysLate + 3)) / WITHDRAWAL_WINDOW_DAYS - 1;\\n        return Math.min(penalty, MAX_PENALTY_PCT);\\n    }\\n\\n    /**\\n     * @dev calculates net Mint Reward (adjusted for Penalty)\\n     */\\n    function _calculateMintReward(\\n        uint256 cRank,\\n        uint256 term,\\n        uint256 maturityTs,\\n        uint256 amplifier,\\n        uint256 eeaRate\\n    ) private view returns (uint256) {\\n        uint256 secsLate = block.timestamp - maturityTs;\\n        uint256 penalty = _penalty(secsLate);\\n        uint256 rankDelta = Math.max(globalRank - cRank, 2);\\n        uint256 EAA = (1_000 + eeaRate);\\n        uint256 reward = getGrossReward(rankDelta, amplifier, term, EAA);\\n        return (reward * (100 - penalty)) / 100;\\n    }\\n\\n    /**\\n     * @dev cleans up User Mint storage (gets some Gas credit;))\\n     */\\n    function _cleanUpUserMint() private {\\n        delete userMints[_msgSender()];\\n        activeMinters--;\\n    }\\n\\n    /**\\n     * @dev calculates XEN Stake Reward\\n     */\\n    function _calculateStakeReward(\\n        uint256 amount,\\n        uint256 term,\\n        uint256 maturityTs,\\n        uint256 apy\\n    ) private view returns (uint256) {\\n        if (block.timestamp > maturityTs) {\\n            uint256 rate = (apy * term * 1_000_000) / DAYS_IN_YEAR;\\n            return (amount * rate) / 100_000_000;\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev calculates Reward Amplifier\\n     */\\n    function _calculateRewardAmplifier() private view returns (uint256) {\\n        uint256 amplifierDecrease = (block.timestamp - genesisTs) / SECONDS_IN_DAY;\\n        if (amplifierDecrease < REWARD_AMPLIFIER_START) {\\n            return Math.max(REWARD_AMPLIFIER_START - amplifierDecrease, REWARD_AMPLIFIER_END);\\n        } else {\\n            return REWARD_AMPLIFIER_END;\\n        }\\n    }\\n\\n    /**\\n     * @dev calculates Early Adopter Amplifier Rate (in 1/000ths)\\n     *      actual EAA is (1_000 + EAAR) / 1_000\\n     */\\n    function _calculateEAARate() private view returns (uint256) {\\n        uint256 decrease = (EAA_PM_STEP * globalRank) / EAA_RANK_STEP;\\n        if (decrease > EAA_PM_START) return 0;\\n        return EAA_PM_START - decrease;\\n    }\\n\\n    /**\\n     * @dev calculates APY (in %)\\n     */\\n    function _calculateAPY() private view returns (uint256) {\\n        uint256 decrease = (block.timestamp - genesisTs) / (SECONDS_IN_DAY * XEN_APY_DAYS_STEP);\\n        if (XEN_APY_START - XEN_APY_END < decrease) return XEN_APY_END;\\n        return XEN_APY_START - decrease;\\n    }\\n\\n    /**\\n     * @dev creates User Stake\\n     */\\n    function _createStake(uint256 amount, uint256 term) private {\\n        userStakes[_msgSender()] = StakeInfo({\\n            term: term,\\n            maturityTs: block.timestamp + term * SECONDS_IN_DAY,\\n            amount: amount,\\n            apy: _calculateAPY()\\n        });\\n        activeStakes++;\\n        totalXenStaked += amount;\\n    }\\n\\n    // PUBLIC CONVENIENCE GETTERS\\n\\n    /**\\n     * @dev calculates gross Mint Reward\\n     */\\n    function getGrossReward(\\n        uint256 rankDelta,\\n        uint256 amplifier,\\n        uint256 term,\\n        uint256 eaa\\n    ) public pure returns (uint256) {\\n        int128 log128 = rankDelta.fromUInt().log_2();\\n        int128 reward128 = log128.mul(amplifier.fromUInt()).mul(term.fromUInt()).mul(eaa.fromUInt());\\n        return reward128.div(uint256(1_000).fromUInt()).toUInt();\\n    }\\n\\n    /**\\n     * @dev returns User Mint object associated with User account address\\n     */\\n    function getUserMint() external view returns (MintInfo memory) {\\n        return userMints[_msgSender()];\\n    }\\n\\n    /**\\n     * @dev returns XEN Stake object associated with User account address\\n     */\\n    function getUserStake() external view returns (StakeInfo memory) {\\n        return userStakes[_msgSender()];\\n    }\\n\\n    /**\\n     * @dev returns current AMP\\n     */\\n    function getCurrentAMP() external view returns (uint256) {\\n        return _calculateRewardAmplifier();\\n    }\\n\\n    /**\\n     * @dev returns current EAA Rate\\n     */\\n    function getCurrentEAAR() external view returns (uint256) {\\n        return _calculateEAARate();\\n    }\\n\\n    /**\\n     * @dev returns current APY\\n     */\\n    function getCurrentAPY() external view returns (uint256) {\\n        return _calculateAPY();\\n    }\\n\\n    /**\\n     * @dev returns current MaxTerm\\n     */\\n    function getCurrentMaxTerm() external view returns (uint256) {\\n        return _calculateMaxTerm();\\n    }\\n\\n    // PUBLIC STATE-CHANGING METHODS\\n\\n    /**\\n     * @dev accepts User cRank claim provided all checks pass (incl. no current claim exists)\\n     */\\n    function claimRank(uint256 term) external {\\n        uint256 termSec = term * SECONDS_IN_DAY;\\n        require(termSec > MIN_TERM, \\\"CRank: Term less than min\\\");\\n        require(termSec < _calculateMaxTerm() + 1, \\\"CRank: Term more than current max term\\\");\\n        require(userMints[_msgSender()].rank == 0, \\\"CRank: Mint already in progress\\\");\\n\\n        // create and store new MintInfo\\n        MintInfo memory mintInfo = MintInfo({\\n            user: _msgSender(),\\n            term: term,\\n            maturityTs: block.timestamp + termSec,\\n            rank: globalRank,\\n            amplifier: _calculateRewardAmplifier(),\\n            eaaRate: _calculateEAARate()\\n        });\\n        userMints[_msgSender()] = mintInfo;\\n        activeMinters++;\\n        emit RankClaimed(_msgSender(), term, globalRank++);\\n    }\\n\\n    /**\\n     * @dev ends minting upon maturity (and within permitted Withdrawal Time Window), gets minted XEN\\n     */\\n    function claimMintReward() external {\\n        MintInfo memory mintInfo = userMints[_msgSender()];\\n        require(mintInfo.rank > 0, \\\"CRank: No mint exists\\\");\\n        require(block.timestamp > mintInfo.maturityTs, \\\"CRank: Mint maturity not reached\\\");\\n\\n        // calculate reward and mint tokens\\n        uint256 rewardAmount = _calculateMintReward(\\n            mintInfo.rank,\\n            mintInfo.term,\\n            mintInfo.maturityTs,\\n            mintInfo.amplifier,\\n            mintInfo.eaaRate\\n        ) * 1 ether;\\n        _mint(_msgSender(), rewardAmount);\\n\\n        _cleanUpUserMint();\\n        emit MintClaimed(_msgSender(), rewardAmount);\\n    }\\n\\n    /**\\n     * @dev  ends minting upon maturity (and within permitted Withdrawal time Window)\\n     *       mints XEN coins and splits them between User and designated other address\\n     */\\n    function claimMintRewardAndShare(address other, uint256 pct) external {\\n        MintInfo memory mintInfo = userMints[_msgSender()];\\n        require(other != address(0), \\\"CRank: Cannot share with zero address\\\");\\n        require(pct > 0, \\\"CRank: Cannot share zero percent\\\");\\n        require(pct < 101, \\\"CRank: Cannot share 100+ percent\\\");\\n        require(mintInfo.rank > 0, \\\"CRank: No mint exists\\\");\\n        require(block.timestamp > mintInfo.maturityTs, \\\"CRank: Mint maturity not reached\\\");\\n\\n        // calculate reward\\n        uint256 rewardAmount = _calculateMintReward(\\n            mintInfo.rank,\\n            mintInfo.term,\\n            mintInfo.maturityTs,\\n            mintInfo.amplifier,\\n            mintInfo.eaaRate\\n        ) * 1 ether;\\n        uint256 sharedReward = (rewardAmount * pct) / 100;\\n        uint256 ownReward = rewardAmount - sharedReward;\\n\\n        // mint reward tokens\\n        _mint(_msgSender(), ownReward);\\n        _mint(other, sharedReward);\\n\\n        _cleanUpUserMint();\\n        emit MintClaimed(_msgSender(), rewardAmount);\\n    }\\n\\n    /**\\n     * @dev  ends minting upon maturity (and within permitted Withdrawal time Window)\\n     *       mints XEN coins and stakes 'pct' of it for 'term'\\n     */\\n    function claimMintRewardAndStake(uint256 pct, uint256 term) external {\\n        MintInfo memory mintInfo = userMints[_msgSender()];\\n        // require(pct > 0, \\\"CRank: Cannot share zero percent\\\");\\n        require(pct < 101, \\\"CRank: Cannot share >100 percent\\\");\\n        require(mintInfo.rank > 0, \\\"CRank: No mint exists\\\");\\n        require(block.timestamp > mintInfo.maturityTs, \\\"CRank: Mint maturity not reached\\\");\\n\\n        // calculate reward\\n        uint256 rewardAmount = _calculateMintReward(\\n            mintInfo.rank,\\n            mintInfo.term,\\n            mintInfo.maturityTs,\\n            mintInfo.amplifier,\\n            mintInfo.eaaRate\\n        ) * 1 ether;\\n        uint256 stakedReward = (rewardAmount * pct) / 100;\\n        uint256 ownReward = rewardAmount - stakedReward;\\n\\n        // mint reward tokens part\\n        _mint(_msgSender(), ownReward);\\n        _cleanUpUserMint();\\n        emit MintClaimed(_msgSender(), rewardAmount);\\n\\n        // nothing to burn since we haven't minted this part yet\\n        // stake extra tokens part\\n        require(stakedReward > XEN_MIN_STAKE, \\\"XEN: Below min stake\\\");\\n        require(term * SECONDS_IN_DAY > MIN_TERM, \\\"XEN: Below min stake term\\\");\\n        require(term * SECONDS_IN_DAY < MAX_TERM_END + 1, \\\"XEN: Above max stake term\\\");\\n        require(userStakes[_msgSender()].amount == 0, \\\"XEN: stake exists\\\");\\n\\n        _createStake(stakedReward, term);\\n        emit Staked(_msgSender(), stakedReward, term);\\n    }\\n\\n    /**\\n     * @dev initiates XEN Stake in amount for a term (days)\\n     */\\n    function stake(uint256 amount, uint256 term) external {\\n        require(balanceOf(_msgSender()) >= amount, \\\"XEN: not enough balance\\\");\\n        require(amount > XEN_MIN_STAKE, \\\"XEN: Below min stake\\\");\\n        require(term * SECONDS_IN_DAY > MIN_TERM, \\\"XEN: Below min stake term\\\");\\n        require(term * SECONDS_IN_DAY < MAX_TERM_END + 1, \\\"XEN: Above max stake term\\\");\\n        require(userStakes[_msgSender()].amount == 0, \\\"XEN: stake exists\\\");\\n\\n        // burn staked XEN\\n        _burn(_msgSender(), amount);\\n        // create XEN Stake\\n        _createStake(amount, term);\\n        emit Staked(_msgSender(), amount, term);\\n    }\\n\\n    /**\\n     * @dev ends XEN Stake and gets reward if the Stake is mature\\n     */\\n    function withdraw() external {\\n        StakeInfo memory userStake = userStakes[_msgSender()];\\n        require(userStake.amount > 0, \\\"XEN: no stake exists\\\");\\n\\n        uint256 xenReward = _calculateStakeReward(\\n            userStake.amount,\\n            userStake.term,\\n            userStake.maturityTs,\\n            userStake.apy\\n        );\\n        activeStakes--;\\n        totalXenStaked -= userStake.amount;\\n\\n        // mint staked XEN (+ reward)\\n        _mint(_msgSender(), userStake.amount + xenReward);\\n        emit Withdrawn(_msgSender(), userStake.amount, xenReward);\\n        delete userStakes[_msgSender()];\\n    }\\n\\n    /**\\n     * @dev burns XEN tokens and creates Proof-Of-Burn record to be used by connected DeFi services\\n     */\\n    function burn(address user, uint256 amount) public {\\n        require(amount > XEN_MIN_BURN, \\\"Burn: Below min limit\\\");\\n        require(\\n            IERC165(_msgSender()).supportsInterface(type(IBurnRedeemable).interfaceId),\\n            \\\"Burn: not a supported contract\\\"\\n        );\\n\\n        _spendAllowance(user, _msgSender(), amount);\\n        _burn(user, amount);\\n        userBurns[user] += amount;\\n        IBurnRedeemable(_msgSender()).onTokenBurned(user, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@faircrypto/xen-crypto/contracts/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMath64x64.sol\\\";\\n\\nlibrary Math {\\n\\n    function min(uint256 a, uint256 b) external pure returns (uint256) {\\n        if (a > b) return b;\\n        return a;\\n    }\\n\\n    function max(uint256 a, uint256 b) external pure returns (uint256) {\\n        if (a > b) return a;\\n        return b;\\n    }\\n\\n    function logX64(uint256 x) external pure returns (int128) {\\n        return ABDKMath64x64.log_2(ABDKMath64x64.fromUInt(x));\\n    }\\n}\\n\"\r\n    },\r\n    \"@faircrypto/magic-numbers/contracts/MagicNumbers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\n/*\\n\\n        \\\\\\\\      //   |||||||||||   |\\\\      ||       A CRYPTOCURRENCY FOR THE MASSES\\n         \\\\\\\\    //    ||            |\\\\\\\\     ||\\n          \\\\\\\\  //     ||            ||\\\\\\\\    ||       PRINCIPLES OF XEN:\\n           \\\\\\\\//      ||            || \\\\\\\\   ||       - No pre-mint; starts with zero supply\\n            XX       ||||||||      ||  \\\\\\\\  ||       - No admin keys\\n           //\\\\\\\\      ||            ||   \\\\\\\\ ||       - Immutable contract\\n          //  \\\\\\\\     ||            ||    \\\\\\\\||\\n         //    \\\\\\\\    ||            ||     \\\\\\\\|\\n        //      \\\\\\\\   |||||||||||   ||      \\\\|       Copyright (C) FairCrypto Foundation 2022-2023\\n\\n */\\n\\nlibrary MagicNumbers {\\n\\n    uint256 constant VERSION = 1;\\n    string public constant AUTHORS = \\\"@MrJackLevin @lbelyaev faircrypto.org\\\";\\n\\n    // There's 370 fibs that fit in uint256 number\\n    uint256 constant MAX_UINT256_FIB_IDX = 370;\\n    // Max fib number that fits into uint256 size\\n    uint256 constant MAX_UINT256_FIB = 94611056096305838013295371573764256526437182762229865607320618320601813254535;\\n    // Max fib index supported by this Library\\n    uint256 constant MAX_FIB_IDX = 90;\\n    // Max number that could be safely tested by this Library\\n    uint256 constant MAX_SUPPORTED_FIB_CANDIDATE = 2 ** 62 - 1;\\n\\n    /**\\n        @dev First 60 Fibonacci numbers, which fit into uint64\\n    */\\n    function fibs64() internal pure returns (uint64[60] memory) {\\n        return [\\n            uint64(0),            1,                     1,\\n            2,                    3,                     5,\\n            8,                    13,                    21,\\n            34,                   55,                    89,\\n            144,                  233,                   377,\\n            610,                  987,                   1597,\\n            2584,                 4181,                  6765,\\n            10946,                17711,                 28657,\\n            46368,                75025,                 121393,\\n            196418,               317811,                514229,\\n            832040,               1346269,               2178309,\\n            3524578,              5702887,               9227465,\\n            14930352,             24157817,              39088169,\\n            63245986,             102334155,             165580141,\\n            267914296,            433494437,             701408733,\\n            1134903170,           1836311903,            2971215073,\\n            4807526976,           7778742049,            12586269025,\\n            20365011074,          32951280099,           53316291173,\\n            86267571272,          139583862445,          225851433717,\\n            365435296162,         591286729879,          956722026041\\n        ];\\n    }\\n\\n    /**\\n        @dev Tests if number is a fib via a linear lookup in the table above\\n    */\\n    function isFibs64(uint256 n) internal pure returns (bool) {\\n        for(uint i = 0; i < 60; i++) if (fibs64()[i] == n) return true;\\n        return false;\\n    }\\n\\n    /**\\n        @dev Next 38 Fibonacci numbers, which fit into uint128\\n    */\\n    function fibs128() internal pure returns (uint128[39] memory) {\\n        return [\\n            uint128(1548008755920),2504730781961,        4052739537881,\\n            6557470319842,        10610209857723,        17167680177565,\\n            27777890035288,       44945570212853,        72723460248141,\\n            117669030460994,      190392490709135,       308061521170129,\\n            498454011879264,      806515533049393,       1304969544928657,\\n            2111485077978050,     3416454622906707,      5527939700884757,\\n            8944394323791464,     14472334024676221,     23416728348467685,\\n            37889062373143906,    61305790721611591,     99194853094755497,\\n            160500643816367088,   259695496911122585,    420196140727489673,\\n            679891637638612258,   1100087778366101931,   1779979416004714189,\\n            2880067194370816120,  4660046610375530309,   7540113804746346429,\\n            12200160415121876738, 19740274219868223167,  31940434634990099905,\\n            51680708854858323072, 83621143489848422977,  135301852344706746049\\n        ];\\n    }\\n\\n    /**\\n        @dev Tests if number is a fib via a linear lookup in the table above\\n    */\\n    function isFibs128(uint256 n) internal pure returns (bool) {\\n        for(uint i = 0; i < 39; i++) if (fibs128()[i] == n) return true;\\n        return false;\\n    }\\n\\n    /**\\n        @dev Helper for Miller-Rabin probabilistic primality test\\n    */\\n    // Write (n - 1) as 2^s * d\\n    function getValues(uint256 n) internal pure returns (uint256[2] memory) {\\n        uint256 s = 0;\\n        uint256 d = n - 1;\\n        while (d % 2 == 0) {\\n            d = d / 2;\\n            s++;\\n        }\\n        uint256[2] memory ret;\\n        ret[0] = s;\\n        ret[1] = d;\\n        return ret;\\n    }\\n\\n    /**\\n        @dev Wrapper around EVM precompiled function for modular exponentiation, deployed at 0x05 address\\n    */\\n    function modExp(uint256 base, uint256 e, uint256 m) internal view returns (uint o) {\\n        assembly {\\n        // define pointer\\n            let p := mload(0x40)\\n        // store data assembly-favouring ways\\n            mstore(p, 0x20)             // Length of Base\\n            mstore(add(p, 0x20), 0x20)  // Length of Exponent\\n            mstore(add(p, 0x40), 0x20)  // Length of Modulus\\n            mstore(add(p, 0x60), base)  // Base\\n            mstore(add(p, 0x80), e)     // Exponent\\n            mstore(add(p, 0xa0), m)     // Modulus\\n        if iszero(staticcall(sub(gas(), 2000), 0x05, p, 0xc0, p, 0x20)) {\\n           revert(0, 0)\\n        }\\n        // data\\n            o := mload(p)\\n        }\\n    }\\n\\n    /**\\n      @dev  Miller-Rabin test probabilistic primality test\\n            see https://en.wikipedia.org/wiki/Miller\u2013Rabin_primality_test\\n    */\\n    function probablyPrime(uint256 n, uint256 prime) internal view returns (bool) {\\n        if (n == 2 || n == 3) {\\n            return true;\\n        }\\n\\n        if (n % 2 == 0 || n < 2) {\\n            return false;\\n        }\\n\\n        uint256[2] memory values = getValues(n);\\n        uint256 s = values[0];\\n        uint256 d = values[1];\\n\\n        uint256 x = modExp(prime, d, n);\\n\\n        if (x == 1 || x == n - 1) {\\n            return true;\\n        }\\n\\n        for (uint256 i = s - 1; i > 0; i--) {\\n            x = modExp(x, 2, n);\\n            if (x == 1) {\\n                return false;\\n            }\\n            if (x == n - 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n      @dev  Determines if a number is prime, using Miller-Rabin test probabilistic primality test\\n            plus deterministic checking to sift out pseudo-primes\\n            see https://en.wikipedia.org/wiki/Miller\u2013Rabin_primality_test\\n    */\\n    function isPrime(uint256 n) public view returns (bool) {\\n        if (n < 2_047)\\n            return probablyPrime(n, 2);\\n        else if (n < 1_373_653)\\n            return probablyPrime(n, 2) && probablyPrime(n, 3);\\n        else if (n < 9_080_191)\\n            return probablyPrime(n, 31) && probablyPrime(n, 73);\\n        else if (n < 25_326_001)\\n            return probablyPrime(n, 2) && probablyPrime(n, 3)\\n            && probablyPrime(n, 5);\\n        else if (n < 3_215_031_751)\\n            return probablyPrime(n, 2) && probablyPrime(n, 3)\\n            && probablyPrime(n, 5) && probablyPrime(n, 7);\\n        else if (n < 4_759_123_141)\\n            return probablyPrime(n, 2) && probablyPrime(n, 7)\\n            && probablyPrime(n, 61);\\n        else if (n < 1_122_004_669_633)\\n            return probablyPrime(n, 2) && probablyPrime(n, 13)\\n            && probablyPrime(n, 23) && probablyPrime(n, 1662803);\\n        else if (n < 2_152_302_898_747)\\n            return probablyPrime(n, 2) && probablyPrime(n, 3)\\n            && probablyPrime(n, 5) && probablyPrime(n, 7)\\n            && probablyPrime(n, 11);\\n        else if (n < 3_474_749_660_383)\\n            return probablyPrime(n, 2) && probablyPrime(n, 3)\\n            && probablyPrime(n, 5) && probablyPrime(n, 7)\\n            && probablyPrime(n, 11) && probablyPrime(n, 13);\\n        else if (n < 341_550_071_728_321)\\n            return probablyPrime(n, 2) && probablyPrime(n, 3)\\n            && probablyPrime(n, 5) && probablyPrime(n, 7)\\n            && probablyPrime(n, 11) && probablyPrime(n, 13)\\n            && probablyPrime(n, 17);\\n        return false;\\n        // TODO: consider reverting ???\\n        // revert('number too big');\\n    }\\n\\n    /**\\n        @dev Count prime numbers occurring between `from` and `to` numbers\\n    */\\n    function findPrimes(uint256 from, uint256 to) external view returns (uint256 count) {\\n        require(to > 0, \\\"findPrimes: to should be natural\\\");\\n        require(to > from, \\\"findPrimes: to should be larger than from\\\");\\n        count = 0;\\n        for(uint i = from; i < to; i++) {\\n            if (isPrime(i)) count++;\\n        }\\n    }\\n\\n    /**\\n        @dev Helper to get N-th Fibonacci number (0 returns 0)\\n    */\\n    function getFib(uint256 n) internal pure returns (uint256 a) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        uint256 h = n / 2;\\n        uint256 mask = 1;\\n        // find highest set bit in n\\n        while(mask <= h) {\\n            mask <<= 1;\\n        }\\n        mask >>= 1;\\n        a = 1;\\n        uint256 b = 1;\\n        uint256 c;\\n        while(mask > 0) {\\n            c = a * a+b * b;\\n            if (n & mask > 0) {\\n                b = b * (b + 2 * a);\\n                a = c;\\n            } else {\\n                a = a * (2 * b - a);\\n                b = c;\\n            }\\n            mask >>= 1;\\n        }\\n        return a;\\n    }\\n\\n    /**\\n        @dev Helper to check if a number is a perfect square\\n    */\\n    function isPerfectSquare(uint256 n) internal pure returns (bool) {\\n       uint256 low = 0;\\n       uint256 high = n;\\n       while (low <= high) {\\n           uint mid = (low + high) / 2;\\n           uint square = mid * mid;\\n           if (square == n) {\\n               return true;\\n           } else if (square > n) {\\n               high = mid - 1;\\n           } else {\\n               low = mid + 1;\\n           }\\n       }\\n       return false;\\n   }\\n\\n    /**\\n        @dev Test if the number is a fib\\n        note the upper limit of 2 ** 62 - 1, to avoid overflow while preforming tests\\n    */\\n   function isFib(uint256 n) public pure returns (bool) {\\n       if (n == 0) return false;\\n       require(n < MAX_SUPPORTED_FIB_CANDIDATE, 'isFib: number too big');\\n       uint256 base = n * n * 5;\\n       uint256 p1 = base + 4;\\n       uint256 p2 = base - 4;\\n       return (isPerfectSquare(p1) || isPerfectSquare(p2));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {\r\n      \"/contracts/libs/StakeInfo.sol\": {\r\n        \"StakeInfo\": \"0xAF18644083151cf57F914CCCc23c42A1892C218e\"\r\n      },\r\n      \"/contracts/libs/StakeMetadata.sol\": {\r\n        \"StakeMetadata\": \"0x379002701BF6f2862e3dFdd1f96d3C5E1BF450B6\"\r\n      },\r\n      \"@faircrypto/magic-numbers/contracts/MagicNumbers.sol\": {\r\n        \"MagicNumbers\": \"0xA7216B82f9C5391ba9aBa8BB42E2095B2198f919\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"xenCrypto_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"forwarder_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"royaltyReceiver_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"CreateStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"EndStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AUTHORS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BLACKOUT_TERM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPERATOR_FILTER_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IOperatorFilterRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROYALTY_BP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_IN_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trustedForwarder\",\"type\":\"address\"}],\"name\":\"addForwarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"callStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"callTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"callWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"createStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"endStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownedTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"powerDown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenIdCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xenCrypto\",\"outputs\":[{\"internalType\":\"contract XENCrypto\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "XENStake", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "20", "ConstructorArguments": "0000000000000000000000002ab0e9e4ee70fff1fb9d67031e44f6410170d00e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c73fc08c931efe3fce850c09278472e8a81c2e05", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}