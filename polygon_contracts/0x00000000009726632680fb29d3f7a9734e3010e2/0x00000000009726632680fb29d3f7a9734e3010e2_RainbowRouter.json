{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RainbowRouter.sol\": {\r\n      \"content\": \"/*\\n\\n                                                            \u2590\u2588\u2588\u2592           \u2588\u2588\u2588\\n                                            ,\u2553, \u2584\u2584  ,\u2584\u2584\u2584,   .\u2584\u2584. ,\u2553, \u2584\u2584\u2584   \u2588\u2588\u258c \u2584\u2584\u2584     ,\u2584\u2584\u2584,  ,\u2553\u2553   \u2553\u2553   ,\u2553\\n                                            \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2310 \u2590\u2588\u2588\u2310 \u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2310 \u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588 \u2553\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2584`\u2588\u2588\u258c \u2590\u2588\u2588\u258c \u2590\u2588\u2588\\n                                            \u2588\u2588\u2588    \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u258c \u2590\u2588\u2588\u2310 \u2588\u2588\u258c  \u2590\u2588\u2588\u258c \u2588\u2588\u258c   \u2551\u2588\u2588\u2310\u2588\u2588\u2588   \u2593\u2588\u2588 \u2559\u2588\u2588\u2584\u2588\u258c\u2588\u2588\u2584\u2588\u2588\u2310\\n                                            \u2588\u2588\u258c   \u2590\u2588\u2588\u2584\u2584\u2588\u2588\u2588\u258c,\u2590\u2588\u2588\u2310 \u2588\u2588\u258c  \u2590\u2588\u2588\u258c \u2588\u2588\u2588\u2593\u2584\u2584\u2588\u2588\u2588 \u2559\u2588\u2588\u2584\u2584\u2584\u2588\u2588\u2580  \u2551\u2588\u2588\u2588\u00ac\u2559\u2588\u2588\u2588\u258c\\n                                            \u2559\u2559\u2514    \u2559\u2559\u2580\u2559\u2500\u2559\u2580\u2580\u2514\\\"\u2559\u2559` \u2559\u2559\u2514   \u2559\u2559\\\" \u2559\u2559`\u2559\u2559\u2580\u2580\u2514    \u2559\u2559\u2580\u2580\u2559`    \u2559\u2559\u2514  \u2559\u2559\u2559\\n                                            \\n\\n        \\n                                            _,\\\" _   _\\\"\\\"\\\"\u207f=-,  _\\n                                            \u2320            _    __\\\"=.__\\n                                            \u2590\u2591......   _  _          \\\"=._\\n                                            \u2590\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591.           \\\"= _\\n                                            \u255a\u2569\u2569\u2569\u2569\u2569\u2569\u03b4\u03c6\u03c6\u03c6\u03c6\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591          >__\\n                                            \u2590\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591__ _ \u2559\u2559\u255a\u2569\u03c6\u03c6\u2591\u2591\u2591\u2591\u2591\u2591\u2591        ^=_\\n                                            \u2590\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591,\u2591  `\u2559\u2560\u03c6\u2591\u2591\u2591\u2591\u2591\u2591\u2591       \u207f\\n                                            \u2590\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591._ `\u255a\u00c5\u03c6\u2591\u2591\u2591\u2591\u2591       \\\" _\\n                                            \u255a\u2560\u2560\u2560\u2560\u2560\u2560\u2560\u256c\u256c\u256c\u2592\u2592\u03c6\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \u2559\u2560\u2591\u2591\u2591\u2591\u2591       \\\"\\n                                            \u255a\u255d\u255d\u255d\u255d\u255d\u255d\u255d\u256c\u256c\u256c\u2560\u2562\u256c\u2560\u256c\u2560\u256c\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 \\\"\u255a\u03c6\u2591\u2591\u2591\u2591       \u00bd_\\n                                            \u2590\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591;\u2591\u2559\u2559\u255d\u256c\u2560\u256c\u2560\u2560\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591_ \u255a\u03c6\u2591\u2591\u2591\u2591      \\\"_\\n                                            \u255a\u2592\u03c6\u03c6\u03c6\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591-\u2559\u255a\u256c\u2560\u2560\u2560\u256c\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591 `\u2560\u2592\u2591\u2591\u2591\u2591      ,\\n                                            \u255e\u256c\u256c\u256c\u2560\u2560\u2560\u256c\u256c\u256c\u256c\u2592\u03c6\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2559\u255a\u256c\u256c\u2560\u256c\u2592\u2592\u2591\u2591\u2591\u2591\u2591 .\u2559\u2560\u2591\u2591\u2591\u2591      \u2265\\n                                            _\u2592\u2591\u2591\u2591\u0393\u0393\u2559\u2559\u2559\u255a\u2569\u256c\u2560\u256c\u2560\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2559\u256c\u256c\u2560\u256c\u2592\u2592\u2591\u2591\u2591\u2591\u2591' \u2560\u2592\u2591\u2591\u2591\u2591     \u2265\\n                                            `\u2559\u207f\u207f\u2248\u2248\u03c3\u2553\u2591 '\u2559\u2559\u255a\u256c\u2560\u256c\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2559\u256c\u256c\u2560\u256c\u2592\u2591\u2591\u2591\u2591\u2591  \u2560\u2592\u2591\u2591\u2591\u2591     [\\n                                                        _\u2559\u0398\u2591 \u2591\u2559\u2560\u2560\u256c\u256c\u2592\u2591\u2591\u2591\u2591\u2591\u256c\u2560\u2560\u2560\u2592\u2592\u2591\u2591\u2591\u2591  \u2560\u2592\u2591\u2591\u2591\u2591    '_\\n                                                        _\u2559\u03c6\u2591'\u2559\u2560\u2560\u256c\u2592\u2591\u2591\u2591\u2591\u2591\u255f\u2560\u2560\u2560\u2592\u2591\u2591\u2591\u2591\u2591 _\u2560\u2592\u2591\u2591\u2591     \u2591_\\n                                                            _`\u03c6 \u2591\u255a\u256c\u2560\u2560\u2592\u2591\u2591\u2591\u2591\u2551\u2560\u2560\u2560\u2592\u2591\u2591\u2591\u2591\u2591.`\u2560\u2591\u2591\u2591\u2591     [\\n                                                            _\u255a\u2591\u2321\u255a\u2560\u256c\u256c\u2592\u2591\u2591\u2591\u2591\u2560\u2560\u2560\u256c\u2592\u2591\u2591\u2591\u2591\u2591 \u2560\u2592\u2591\u2591\u2591\u2591    \u2591\\n                                                                _\u2559\u2591\u2321\u255a\u2560\u2560\u256c\u2592\u2591\u2591\u2591\\\"\u2592\u2560\u2560\u256c\u2592\u2591\u2591\u2591\u2591 \u2320\u2560\u2591\u2591\u2591\u2591    \u2321_\\n                                                                \u2560 \u2591\u2560\u2560\u2560\u256c\u2592\u2591\u2591\u2591\u2551\u2560\u256c\u2560\u256c\u2592\u2591\u2591\u2591 _\u2560\u2592\u2591\u2591\u2591     \u0393\\n                                                                \u2590\u2591\u2591\u2591\u2560\u2560\u2560\u2592\u2591\u2591\u2591\u255f\u2560\u2560\u2560\u256c\u2592\u2591\u2591\u2591\u2591 \u2560\u2592\u2591\u2591\u2591\u2591    [\\n                                                                _\u2591.\u2591\u2560\u2560\u2560\u2592\u2591\u2591\u2591\u2590\u256c\u2560\u2560\u256c\u2592\u2591\u2591\u2591\u2591[\u2560\u256c\u2591\u2591\u2591\u2591    \u2502\\n                                                                _\u2559\u03c6\u2591\u2560\u2560\u2560\u256c\u2592\u2591\u2591\u2590\u256c\u256c\u2560\u256c\u256c\u2592\u2591\u2591\u2591[\u2560\u256c\u2591\u2591\u2591\u2591  \u2591\u2265_\\n                                                                    ____ ____  __ _______ ____\\n\\n\\n    /$$$$$$                                           /$$$$$$                                                                /$$                        \\n    /$$__  $$                                         /$$__  $$                                                              | $$                        \\n    | $$  \\\\__/ /$$  /$$  /$$  /$$$$$$   /$$$$$$       | $$  \\\\ $$  /$$$$$$   /$$$$$$   /$$$$$$   /$$$$$$   /$$$$$$   /$$$$$$  /$$$$$$    /$$$$$$   /$$$$$$ \\n    |  $$$$$$ | $$ | $$ | $$ |____  $$ /$$__  $$      | $$$$$$$$ /$$__  $$ /$$__  $$ /$$__  $$ /$$__  $$ /$$__  $$ |____  $$|_  $$_/   /$$__  $$ /$$__  $$\\n    \\\\____  $$| $$ | $$ | $$  /$$$$$$$| $$  \\\\ $$      | $$__  $$| $$  \\\\ $$| $$  \\\\ $$| $$  \\\\__/| $$$$$$$$| $$  \\\\ $$  /$$$$$$$  | $$    | $$  \\\\ $$| $$  \\\\__/\\n    /$$  \\\\ $$| $$ | $$ | $$ /$$__  $$| $$  | $$      | $$  | $$| $$  | $$| $$  | $$| $$      | $$_____/| $$  | $$ /$$__  $$  | $$ /$$| $$  | $$| $$      \\n    |  $$$$$$/|  $$$$$/$$$$/|  $$$$$$$| $$$$$$$/      | $$  | $$|  $$$$$$$|  $$$$$$$| $$      |  $$$$$$$|  $$$$$$$|  $$$$$$$  |  $$$$/|  $$$$$$/| $$      \\n    \\\\______/  \\\\_____/\\\\___/  \\\\_______/| $$____/       |__/  |__/ \\\\____  $$ \\\\____  $$|__/       \\\\_______/ \\\\____  $$ \\\\_______/   \\\\___/   \\\\______/ |__/      \\n                                    | $$                       /$$  \\\\ $$ /$$  \\\\ $$                     /$$  \\\\ $$                                        \\n                                    | $$                      |  $$$$$$/|  $$$$$$/                    |  $$$$$$/                                        \\n                                    |__/                       \\\\______/  \\\\______/                      \\\\______/                                         \\n                \\n     \\n*/\\n\\n//SPDX-License-Identifier: GPL-3.0\\npragma solidity =0.8.11;\\nimport \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport \\\"./routers/BaseAggregator.sol\\\";\\n\\n/// @title Rainbow swap aggregator contract\\ncontract RainbowRouter is BaseAggregator {\\n    /// @dev The address that is the current owner of this contract\\n    address public owner;\\n\\n    /// @dev Event emitted when the owner changes\\n    event OwnerChanged(address indexed newOwner, address indexed oldOwner);\\n\\n    /// @dev Event emitted when a swap target gets added\\n    event SwapTargetAdded(address indexed target);\\n\\n    /// @dev Event emitted when a swap target gets removed\\n    event SwapTargetRemoved(address indexed target);\\n\\n    /// @dev Event emitted when token fees are withdrawn\\n    event TokenWithdrawn(\\n        address indexed token,\\n        address indexed target,\\n        uint256 amount\\n    );\\n\\n    /// @dev Event emitted when ETH fees are withdrawn\\n    event EthWithdrawn(address indexed target, uint256 amount);\\n\\n    /// @dev modifier that ensures only the owner is allowed to call a specific method\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"ONLY_OWNER\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        owner = msg.sender;\\n        status = 1;\\n    }\\n\\n    /// @dev We don't want to accept any ETH, except refunds from aggregators\\n    /// or the owner (for testing purposes), which can also withdraw\\n    /// This is done by evaluating the value of status, which is set to 2\\n    /// only during swaps due to the \\\"nonReentrant\\\" modifier\\n    receive() external payable {\\n        require(status == 2 || msg.sender == owner, \\\"NO_RECEIVE\\\");\\n    }\\n\\n    /// @dev method to add or remove swap targets from swapTargets\\n    /// This is required so we only approve \\\"trusted\\\" swap targets\\n    /// to transfer tokens out of this contract\\n    /// @param target address of the swap target to add\\n    /// @param add flag to add or remove the swap target\\n    function updateSwapTargets(address target, bool add) external onlyOwner {\\n        swapTargets[target] = add;\\n        if (add) {\\n            emit SwapTargetAdded(target);\\n        } else {\\n            emit SwapTargetRemoved(target);\\n        }\\n    }\\n\\n    /// @dev method to withdraw ERC20 tokens (from the fees)\\n    /// @param token address of the token to withdraw\\n    /// @param to address that's receiving the tokens\\n    /// @param amount amount of tokens to withdraw\\n    function withdrawToken(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external onlyOwner {\\n        require(to != address(0), \\\"ZERO_ADDRESS\\\");\\n        SafeTransferLib.safeTransfer(ERC20(token), to, amount);\\n        emit TokenWithdrawn(token, to, amount);\\n    }\\n\\n    /// @dev method to withdraw ETH (from the fees)\\n    /// @param to address that's receiving the ETH\\n    /// @param amount amount of ETH to withdraw\\n    function withdrawEth(address to, uint256 amount) external onlyOwner {\\n        require(to != address(0), \\\"ZERO_ADDRESS\\\");\\n        SafeTransferLib.safeTransferETH(to, amount);\\n        emit EthWithdrawn(to, amount);\\n    }\\n\\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\\n    /// @param newOwner address of the new owner\\n    /// Can only be called by the current owner.\\n    function transferOwnership(address newOwner) external virtual onlyOwner {\\n        require(newOwner != address(0), \\\"ZERO_ADDRESS\\\");\\n        require(newOwner != owner, \\\"SAME_OWNER\\\");\\n        address previousOwner = owner;\\n        owner = newOwner;\\n        emit OwnerChanged(newOwner, previousOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/routers/BaseAggregator.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\npragma solidity =0.8.11;\\n\\nimport \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport \\\"../libraries/PermitHelper.sol\\\";\\n\\n/// @title Rainbow base aggregator contract\\ncontract BaseAggregator {\\n    /// @dev Used to prevent re-entrancy\\n    uint256 internal status;\\n\\n    /// @dev Set of allowed swapTargets.\\n    mapping(address => bool) public swapTargets;\\n\\n    /// @dev modifier that prevents reentrancy attacks on specific methods\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, status will be 1\\n        require(status != 2, \\\"NON_REENTRANT\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        status = 2;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        status = 1;\\n    }\\n\\n    /// @dev modifier that ensures only approved targets can be called\\n    modifier onlyApprovedTarget(address target) {\\n        require(swapTargets[target], \\\"TARGET_NOT_AUTH\\\");\\n        _;\\n    }\\n\\n    /** EXTERNAL **/\\n\\n    /// @param buyTokenAddress the address of token that the user should receive\\n    /// @param target the address of the aggregator contract that will exec the swap\\n    /// @param swapCallData the calldata that will be passed to the aggregator contract\\n    /// @param feeAmount the amount of ETH that we will take as a fee\\n    function fillQuoteEthToToken(\\n        address buyTokenAddress,\\n        address payable target,\\n        bytes calldata swapCallData,\\n        uint256 feeAmount\\n    ) external payable nonReentrant onlyApprovedTarget(target) {\\n        // 1 - Get the initial balances\\n        uint256 initialTokenBalance = ERC20(buyTokenAddress).balanceOf(\\n            address(this)\\n        );\\n        uint256 initialEthAmount = address(this).balance - msg.value;\\n        uint256 sellAmount = msg.value - feeAmount;\\n\\n        // 2 - Call the encoded swap function call on the contract at `target`,\\n        // passing along any ETH attached to this function call to cover protocol fees\\n        // minus our fees, which are kept in this contract\\n        (bool success, bytes memory res) = target.call{value: sellAmount}(\\n            swapCallData\\n        );\\n\\n        // Get the revert message of the call and revert with it if the call failed\\n        if (!success) {\\n            assembly {\\n                let returndata_size := mload(res)\\n                revert(add(32, res), returndata_size)\\n            }\\n        }\\n\\n        // 3 - Make sure we received the tokens\\n        {\\n            uint256 finalTokenBalance = ERC20(buyTokenAddress).balanceOf(\\n                address(this)\\n            );\\n            require(initialTokenBalance < finalTokenBalance, \\\"NO_TOKENS\\\");\\n        }\\n\\n        // 4 - Send the received tokens back to the user\\n        SafeTransferLib.safeTransfer(\\n            ERC20(buyTokenAddress),\\n            msg.sender,\\n            ERC20(buyTokenAddress).balanceOf(address(this)) -\\n                initialTokenBalance\\n        );\\n\\n        // 5 - Return the remaining ETH to the user (if any)\\n        {\\n            uint256 finalEthAmount = address(this).balance - feeAmount;\\n            if (finalEthAmount > initialEthAmount) {\\n                SafeTransferLib.safeTransferETH(\\n                    msg.sender,\\n                    finalEthAmount - initialEthAmount\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @param sellTokenAddress the address of token that the user is selling\\n    /// @param buyTokenAddress the address of token that the user should receive\\n    /// @param target the address of the aggregator contract that will exec the swap\\n    /// @param swapCallData the calldata that will be passed to the aggregator contract\\n    /// @param sellAmount the amount of tokens that the user is selling\\n    /// @param feeAmount the amount of the tokens to sell that we will take as a fee\\n    function fillQuoteTokenToToken(\\n        address sellTokenAddress,\\n        address buyTokenAddress,\\n        address payable target,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feeAmount\\n    ) external payable nonReentrant onlyApprovedTarget(target) {\\n        _fillQuoteTokenToToken(\\n            sellTokenAddress,\\n            buyTokenAddress,\\n            target,\\n            swapCallData,\\n            sellAmount,\\n            feeAmount\\n        );\\n    }\\n\\n    /// @dev method that executes ERC20 to ERC20 token swaps with the ability to take a fee from the input\\n    // and accepts a signature to use permit, so the user doesn't have to make an previous approval transaction\\n    /// @param sellTokenAddress the address of token that the user is selling\\n    /// @param buyTokenAddress the address of token that the user should receive\\n    /// @param target the address of the aggregator contract that will exec the swap\\n    /// @param swapCallData the calldata that will be passed to the aggregator contract\\n    /// @param sellAmount the amount of tokens that the user is selling\\n    /// @param feeAmount the amount of the tokens to sell that we will take as a fee\\n    /// @param permitData struct containing the value, nonce, deadline, v, r and s values of the permit data\\n    function fillQuoteTokenToTokenWithPermit(\\n        address sellTokenAddress,\\n        address buyTokenAddress,\\n        address payable target,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feeAmount,\\n        PermitHelper.Permit calldata permitData\\n    ) external payable nonReentrant onlyApprovedTarget(target) {\\n        // 1 - Apply permit\\n        PermitHelper.permit(\\n            permitData,\\n            sellTokenAddress,\\n            msg.sender,\\n            address(this)\\n        );\\n\\n        //2 - Call fillQuoteTokenToToken\\n        _fillQuoteTokenToToken(\\n            sellTokenAddress,\\n            buyTokenAddress,\\n            target,\\n            swapCallData,\\n            sellAmount,\\n            feeAmount\\n        );\\n    }\\n\\n    /// @dev method that executes ERC20 to ETH token swaps with the ability to take a fee from the output\\n    /// @param sellTokenAddress the address of token that the user is selling\\n    /// @param target the address of the aggregator contract that will exec the swap\\n    /// @param swapCallData the calldata that will be passed to the aggregator contract\\n    /// @param sellAmount the amount of tokens that the user is selling\\n    /// @param feePercentageBasisPoints the amount of ETH that we will take as a fee in 1e18 basis points (basis points with 4 decimals plus 14 extra decimals of precision)\\n    function fillQuoteTokenToEth(\\n        address sellTokenAddress,\\n        address payable target,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feePercentageBasisPoints\\n    ) external payable nonReentrant onlyApprovedTarget(target) {\\n        _fillQuoteTokenToEth(\\n            sellTokenAddress,\\n            target,\\n            swapCallData,\\n            sellAmount,\\n            feePercentageBasisPoints\\n        );\\n    }\\n\\n    /// @dev method that executes ERC20 to ETH token swaps with the ability to take a fee from the output\\n    // and accepts a signature to use permit, so the user doesn't have to make an previous approval transaction\\n    /// @param sellTokenAddress the address of token that the user is selling\\n    /// @param target the address of the aggregator contract that will exec the swap\\n    /// @param swapCallData the calldata that will be passed to the aggregator contract\\n    /// @param sellAmount the amount of tokens that the user is selling\\n    /// @param feePercentageBasisPoints the amount of ETH that we will take as a fee in 1e18 basis points (basis points with 4 decimals plus 14 extra decimals of precision)\\n    /// @param permitData struct containing the amount, nonce, deadline, v, r and s values of the permit data\\n    function fillQuoteTokenToEthWithPermit(\\n        address sellTokenAddress,\\n        address payable target,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feePercentageBasisPoints,\\n        PermitHelper.Permit calldata permitData\\n    ) external payable nonReentrant onlyApprovedTarget(target) {\\n        // 1 - Apply permit\\n        PermitHelper.permit(\\n            permitData,\\n            sellTokenAddress,\\n            msg.sender,\\n            address(this)\\n        );\\n\\n        // 2 - call fillQuoteTokenToEth\\n        _fillQuoteTokenToEth(\\n            sellTokenAddress,\\n            target,\\n            swapCallData,\\n            sellAmount,\\n            feePercentageBasisPoints\\n        );\\n    }\\n\\n    /** INTERNAL **/\\n\\n    /// @dev internal method that executes ERC20 to ETH token swaps with the ability to take a fee from the output\\n    function _fillQuoteTokenToEth(\\n        address sellTokenAddress,\\n        address payable target,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feePercentageBasisPoints\\n    ) internal {\\n        // 1 - Get the initial ETH amount\\n        uint256 initialEthAmount = address(this).balance - msg.value;\\n\\n        // 2 - Move the tokens to this contract\\n        // NOTE: This implicitly assumes that the the necessary approvals have been granted\\n        // from msg.sender to the BaseAggregator\\n        SafeTransferLib.safeTransferFrom(\\n            ERC20(sellTokenAddress),\\n            msg.sender,\\n            address(this),\\n            sellAmount\\n        );\\n\\n        // 3 - Approve the aggregator's contract to swap the tokens\\n        SafeTransferLib.safeApprove(\\n            ERC20(sellTokenAddress),\\n            target,\\n            sellAmount\\n        );\\n\\n        // 4 - Call the encoded swap function call on the contract at `target`,\\n        // passing along any ETH attached to this function call to cover protocol fees.\\n        (bool success, bytes memory res) = target.call{value: msg.value}(\\n            swapCallData\\n        );\\n\\n        // Get the revert message of the call and revert with it if the call failed\\n        if (!success) {\\n            assembly {\\n                let returndata_size := mload(res)\\n                revert(add(32, res), returndata_size)\\n            }\\n        }\\n\\n        // 5 - Check that the tokens were fully spent during the swap\\n        uint256 allowance = ERC20(sellTokenAddress).allowance(\\n            address(this),\\n            target\\n        );\\n        require(allowance == 0, \\\"ALLOWANCE_NOT_ZERO\\\");\\n\\n        // 6 - Subtract the fees and send the rest to the user\\n        // Fees will be held in this contract\\n        uint256 finalEthAmount = address(this).balance;\\n        uint256 ethDiff = finalEthAmount - initialEthAmount;\\n\\n        require(ethDiff > 0, \\\"NO_ETH_BACK\\\");\\n\\n        if (feePercentageBasisPoints > 0) {\\n            uint256 fees = (ethDiff * feePercentageBasisPoints) / 1e18;\\n            uint256 amountMinusFees = ethDiff - fees;\\n            SafeTransferLib.safeTransferETH(msg.sender, amountMinusFees);\\n            // when there's no fee, 1inch sends the funds directly to the user\\n            // we check to prevent sending 0 ETH in that case\\n        } else if (ethDiff > 0) {\\n            SafeTransferLib.safeTransferETH(msg.sender, ethDiff);\\n        }\\n    }\\n\\n    /// @dev internal method that executes ERC20 to ERC20 token swaps with the ability to take a fee from the input\\n    function _fillQuoteTokenToToken(\\n        address sellTokenAddress,\\n        address buyTokenAddress,\\n        address payable target,\\n        bytes calldata swapCallData,\\n        uint256 sellAmount,\\n        uint256 feeAmount\\n    ) internal {\\n        // 1 - Get the initial output token balance\\n        uint256 initialOutputTokenAmount = ERC20(buyTokenAddress).balanceOf(\\n            address(this)\\n        );\\n\\n        // 2 - Move the tokens to this contract (which includes our fees)\\n        // NOTE: This implicitly assumes that the the necessary approvals have been granted\\n        // from msg.sender to the BaseAggregator\\n        SafeTransferLib.safeTransferFrom(\\n            ERC20(sellTokenAddress),\\n            msg.sender,\\n            address(this),\\n            sellAmount\\n        );\\n\\n        // 3 - Approve the aggregator's contract to swap the tokens if needed\\n        SafeTransferLib.safeApprove(\\n            ERC20(sellTokenAddress),\\n            target,\\n            sellAmount - feeAmount\\n        );\\n\\n        // 4 - Call the encoded swap function call on the contract at `target`,\\n        // passing along any ETH attached to this function call to cover protocol fees.\\n        (bool success, bytes memory res) = target.call{value: msg.value}(\\n            swapCallData\\n        );\\n\\n        // Get the revert message of the call and revert with it if the call failed\\n        if (!success) {\\n            assembly {\\n                let returndata_size := mload(res)\\n                revert(add(32, res), returndata_size)\\n            }\\n        }\\n\\n        // 5 - Check that the tokens were fully spent during the swap\\n        uint256 allowance = ERC20(sellTokenAddress).allowance(\\n            address(this),\\n            target\\n        );\\n        require(allowance == 0, \\\"ALLOWANCE_NOT_ZERO\\\");\\n\\n        // 6 - Make sure we received the tokens\\n        uint256 finalOutputTokenAmount = ERC20(buyTokenAddress).balanceOf(\\n            address(this)\\n        );\\n        require(initialOutputTokenAmount < finalOutputTokenAmount, \\\"NO_TOKENS\\\");\\n\\n        // 7 - Send tokens to the user\\n        SafeTransferLib.safeTransfer(\\n            ERC20(buyTokenAddress),\\n            msg.sender,\\n            finalOutputTokenAmount - initialOutputTokenAmount\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/PermitHelper.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\npragma solidity =0.8.11;\\nimport \\\"../interfaces/IERC2612.sol\\\";\\nimport \\\"../interfaces/IDAI.sol\\\";\\n\\n/// @title PermitHelper\\n/// @dev Helper methods for using ERC20 Permit (ERC2612 or DAI/CHAI like)\\nlibrary PermitHelper {\\n    struct Permit {\\n        uint256 value;\\n        uint256 nonce;\\n        uint256 deadline;\\n        bool isDaiStylePermit;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @dev permit method helper that will handle both known implementations\\n    // DAI vs ERC2612 tokens\\n    /// @param permitData bytes containing the encoded permit signature\\n    /// @param tokenAddress address of the token that will be permitted\\n    /// @param holder address that holds the tokens to be permitted\\n    /// @param spender address that will be permitted to spend the tokens\\n    function permit(\\n        Permit memory permitData,\\n        address tokenAddress,\\n        address holder,\\n        address spender\\n    ) internal {\\n        if (permitData.isDaiStylePermit) {\\n            IDAI(tokenAddress).permit(\\n                holder,\\n                spender,\\n                permitData.nonce,\\n                permitData.deadline,\\n                true,\\n                permitData.v,\\n                permitData.r,\\n                permitData.s\\n            );\\n        } else {\\n            IERC2612(tokenAddress).permit(\\n                holder,\\n                spender,\\n                permitData.value,\\n                permitData.deadline,\\n                permitData.v,\\n                permitData.r,\\n                permitData.s\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC2612.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\npragma solidity =0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\n\\ninterface IERC2612 is IERC20Metadata, IERC20Permit {\\n    function _nonces(address owner) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDAI.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\npragma solidity =0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/external/IERC20PermitAllowed.sol\\\";\\n\\ninterface IDAI is IERC20Metadata, IERC20PermitAllowed {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/interfaces/external/IERC20PermitAllowed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Interface for permit\\n/// @notice Interface used by DAI/CHAI for permit\\ninterface IERC20PermitAllowed {\\n    /// @notice Approve the spender to spend some tokens via the holder signature\\n    /// @dev This is the permit interface used by DAI and CHAI\\n    /// @param holder The address of the token holder, the token owner\\n    /// @param spender The address of the token spender\\n    /// @param nonce The holder's nonce, increases at each call to permit\\n    /// @param expiry The timestamp at which the permit is no longer valid\\n    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"SwapTargetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"SwapTargetRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"fillQuoteEthToToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePercentageBasisPoints\",\"type\":\"uint256\"}],\"name\":\"fillQuoteTokenToEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePercentageBasisPoints\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDaiStylePermit\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct PermitHelper.Permit\",\"name\":\"permitData\",\"type\":\"tuple\"}],\"name\":\"fillQuoteTokenToEthWithPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"fillQuoteTokenToToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sellTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isDaiStylePermit\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct PermitHelper.Permit\",\"name\":\"permitData\",\"type\":\"tuple\"}],\"name\":\"fillQuoteTokenToTokenWithPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"swapTargets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"updateSwapTargets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RainbowRouter", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}