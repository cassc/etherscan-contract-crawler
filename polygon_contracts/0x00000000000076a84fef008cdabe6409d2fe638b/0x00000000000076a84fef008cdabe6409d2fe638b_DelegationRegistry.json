{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DelegationRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.17;\\n\\nimport {IDelegationRegistry} from \\\"./IDelegationRegistry.sol\\\";\\nimport {EnumerableSet} from \\\"openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {ERC165} from \\\"openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @title DelegationRegistry\\n * @custom:version 1.0\\n * @notice An immutable registry contract to be deployed as a standalone primitive.\\n * @dev See EIP-5639, new project launches can read previous cold wallet -> hot wallet delegations\\n * from here and integrate those permissions into their flow.\\n * @custom:coauthor foobar (0xfoobar)\\n * @custom:coauthor wwchung (manifoldxyz)\\n * @custom:coauthor purplehat (artblocks)\\n * @custom:coauthor ryley-o (artblocks)\\n * @custom:coauthor andy8052 (tessera)\\n * @custom:coauthor punk6529 (open metaverse)\\n * @custom:coauthor loopify (loopiverse)\\n * @custom:coauthor emiliano (nftrentals)\\n * @custom:coauthor arran (proof)\\n * @custom:coauthor james (collabland)\\n * @custom:coauthor john (gnosis safe)\\n * @custom:coauthor 0xrusowsky\\n */\\ncontract DelegationRegistry is IDelegationRegistry, ERC165 {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    /// @notice The global mapping and single source of truth for delegations\\n    /// @dev vault -> vaultVersion -> delegationHash\\n    mapping(address => mapping(uint256 => EnumerableSet.Bytes32Set)) internal delegations;\\n\\n    /// @notice A mapping of wallets to versions (for cheap revocation)\\n    mapping(address => uint256) internal vaultVersion;\\n\\n    /// @notice A mapping of wallets to delegates to versions (for cheap revocation)\\n    mapping(address => mapping(address => uint256)) internal delegateVersion;\\n\\n    /// @notice A secondary mapping to return onchain enumerability of delegations that a given address can perform\\n    /// @dev delegate -> delegationHashes\\n    mapping(address => EnumerableSet.Bytes32Set) internal delegationHashes;\\n\\n    /// @notice A secondary mapping used to return delegation information about a delegation\\n    /// @dev delegationHash -> DelegateInfo\\n    mapping(bytes32 => IDelegationRegistry.DelegationInfo) internal delegationInfo;\\n\\n    /**\\n     * @inheritdoc ERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override (ERC165) returns (bool) {\\n        return interfaceId == type(IDelegationRegistry).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * -----------  WRITE -----------\\n     */\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function delegateForAll(address delegate, bool value) external override {\\n        bytes32 delegationHash = _computeAllDelegationHash(msg.sender, delegate);\\n        _setDelegationValues(\\n            delegate, delegationHash, value, IDelegationRegistry.DelegationType.ALL, msg.sender, address(0), 0\\n        );\\n        emit IDelegationRegistry.DelegateForAll(msg.sender, delegate, value);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function delegateForContract(address delegate, address contract_, bool value) external override {\\n        bytes32 delegationHash = _computeContractDelegationHash(msg.sender, delegate, contract_);\\n        _setDelegationValues(\\n            delegate, delegationHash, value, IDelegationRegistry.DelegationType.CONTRACT, msg.sender, contract_, 0\\n        );\\n        emit IDelegationRegistry.DelegateForContract(msg.sender, delegate, contract_, value);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function delegateForToken(address delegate, address contract_, uint256 tokenId, bool value) external override {\\n        bytes32 delegationHash = _computeTokenDelegationHash(msg.sender, delegate, contract_, tokenId);\\n        _setDelegationValues(\\n            delegate, delegationHash, value, IDelegationRegistry.DelegationType.TOKEN, msg.sender, contract_, tokenId\\n        );\\n        emit IDelegationRegistry.DelegateForToken(msg.sender, delegate, contract_, tokenId, value);\\n    }\\n\\n    /**\\n     * @dev Helper function to set all delegation values and enumeration sets\\n     */\\n    function _setDelegationValues(\\n        address delegate,\\n        bytes32 delegateHash,\\n        bool value,\\n        IDelegationRegistry.DelegationType type_,\\n        address vault,\\n        address contract_,\\n        uint256 tokenId\\n    ) internal {\\n        if (value) {\\n            delegations[vault][vaultVersion[vault]].add(delegateHash);\\n            delegationHashes[delegate].add(delegateHash);\\n            delegationInfo[delegateHash] =\\n                DelegationInfo({vault: vault, delegate: delegate, type_: type_, contract_: contract_, tokenId: tokenId});\\n        } else {\\n            delegations[vault][vaultVersion[vault]].remove(delegateHash);\\n            delegationHashes[delegate].remove(delegateHash);\\n            delete delegationInfo[delegateHash];\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper function to compute delegation hash for wallet delegation\\n     */\\n    function _computeAllDelegationHash(address vault, address delegate) internal view returns (bytes32) {\\n        uint256 vaultVersion_ = vaultVersion[vault];\\n        uint256 delegateVersion_ = delegateVersion[vault][delegate];\\n        return keccak256(abi.encode(delegate, vault, vaultVersion_, delegateVersion_));\\n    }\\n\\n    /**\\n     * @dev Helper function to compute delegation hash for contract delegation\\n     */\\n    function _computeContractDelegationHash(address vault, address delegate, address contract_)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        uint256 vaultVersion_ = vaultVersion[vault];\\n        uint256 delegateVersion_ = delegateVersion[vault][delegate];\\n        return keccak256(abi.encode(delegate, vault, contract_, vaultVersion_, delegateVersion_));\\n    }\\n\\n    /**\\n     * @dev Helper function to compute delegation hash for token delegation\\n     */\\n    function _computeTokenDelegationHash(address vault, address delegate, address contract_, uint256 tokenId)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        uint256 vaultVersion_ = vaultVersion[vault];\\n        uint256 delegateVersion_ = delegateVersion[vault][delegate];\\n        return keccak256(abi.encode(delegate, vault, contract_, tokenId, vaultVersion_, delegateVersion_));\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function revokeAllDelegates() external override {\\n        ++vaultVersion[msg.sender];\\n        emit IDelegationRegistry.RevokeAllDelegates(msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function revokeDelegate(address delegate) external override {\\n        _revokeDelegate(delegate, msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function revokeSelf(address vault) external override {\\n        _revokeDelegate(msg.sender, vault);\\n    }\\n\\n    /**\\n     * @dev Revoke the `delegate` hotwallet from the `vault` coldwallet.\\n     */\\n    function _revokeDelegate(address delegate, address vault) internal {\\n        ++delegateVersion[vault][delegate];\\n        // For enumerations, filter in the view functions\\n        emit IDelegationRegistry.RevokeDelegate(vault, msg.sender);\\n    }\\n\\n    /**\\n     * -----------  READ -----------\\n     */\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getDelegationsByDelegate(address delegate)\\n        external\\n        view\\n        returns (IDelegationRegistry.DelegationInfo[] memory info)\\n    {\\n        EnumerableSet.Bytes32Set storage potentialDelegationHashes = delegationHashes[delegate];\\n        uint256 potentialDelegationHashesLength = potentialDelegationHashes.length();\\n        uint256 delegationCount = 0;\\n        info = new IDelegationRegistry.DelegationInfo[](potentialDelegationHashesLength);\\n        for (uint256 i = 0; i < potentialDelegationHashesLength;) {\\n            bytes32 delegateHash = potentialDelegationHashes.at(i);\\n            IDelegationRegistry.DelegationInfo memory delegationInfo_ = delegationInfo[delegateHash];\\n            address vault = delegationInfo_.vault;\\n            IDelegationRegistry.DelegationType type_ = delegationInfo_.type_;\\n            bool valid = false;\\n            if (type_ == IDelegationRegistry.DelegationType.ALL) {\\n                if (delegateHash == _computeAllDelegationHash(vault, delegate)) {\\n                    valid = true;\\n                }\\n            } else if (type_ == IDelegationRegistry.DelegationType.CONTRACT) {\\n                if (delegateHash == _computeContractDelegationHash(vault, delegate, delegationInfo_.contract_)) {\\n                    valid = true;\\n                }\\n            } else if (type_ == IDelegationRegistry.DelegationType.TOKEN) {\\n                if (\\n                    delegateHash\\n                        == _computeTokenDelegationHash(vault, delegate, delegationInfo_.contract_, delegationInfo_.tokenId)\\n                ) {\\n                    valid = true;\\n                }\\n            }\\n            if (valid) {\\n                info[delegationCount++] = delegationInfo_;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (potentialDelegationHashesLength > delegationCount) {\\n            assembly {\\n                let decrease := sub(potentialDelegationHashesLength, delegationCount)\\n                mstore(info, sub(mload(info), decrease))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getDelegatesForAll(address vault) external view returns (address[] memory delegates) {\\n        return _getDelegatesForLevel(vault, IDelegationRegistry.DelegationType.ALL, address(0), 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getDelegatesForContract(address vault, address contract_)\\n        external\\n        view\\n        override\\n        returns (address[] memory delegates)\\n    {\\n        return _getDelegatesForLevel(vault, IDelegationRegistry.DelegationType.CONTRACT, contract_, 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getDelegatesForToken(address vault, address contract_, uint256 tokenId)\\n        external\\n        view\\n        override\\n        returns (address[] memory delegates)\\n    {\\n        return _getDelegatesForLevel(vault, IDelegationRegistry.DelegationType.TOKEN, contract_, tokenId);\\n    }\\n\\n    function _getDelegatesForLevel(\\n        address vault,\\n        IDelegationRegistry.DelegationType delegationType,\\n        address contract_,\\n        uint256 tokenId\\n    ) internal view returns (address[] memory delegates) {\\n        EnumerableSet.Bytes32Set storage delegationHashes_ = delegations[vault][vaultVersion[vault]];\\n        uint256 potentialDelegatesLength = delegationHashes_.length();\\n        uint256 delegatesCount = 0;\\n        delegates = new address[](potentialDelegatesLength);\\n        for (uint256 i = 0; i < potentialDelegatesLength;) {\\n            bytes32 delegationHash = delegationHashes_.at(i);\\n            DelegationInfo storage delegationInfo_ = delegationInfo[delegationHash];\\n            if (delegationInfo_.type_ == delegationType) {\\n                if (delegationType == IDelegationRegistry.DelegationType.ALL) {\\n                    // check delegate version by validating the hash\\n                    if (delegationHash == _computeAllDelegationHash(vault, delegationInfo_.delegate)) {\\n                        delegates[delegatesCount++] = delegationInfo_.delegate;\\n                    }\\n                } else if (delegationType == IDelegationRegistry.DelegationType.CONTRACT) {\\n                    if (delegationInfo_.contract_ == contract_) {\\n                        // check delegate version by validating the hash\\n                        if (\\n                            delegationHash == _computeContractDelegationHash(vault, delegationInfo_.delegate, contract_)\\n                        ) {\\n                            delegates[delegatesCount++] = delegationInfo_.delegate;\\n                        }\\n                    }\\n                } else if (delegationType == IDelegationRegistry.DelegationType.TOKEN) {\\n                    if (delegationInfo_.contract_ == contract_ && delegationInfo_.tokenId == tokenId) {\\n                        // check delegate version by validating the hash\\n                        if (\\n                            delegationHash\\n                                == _computeTokenDelegationHash(vault, delegationInfo_.delegate, contract_, tokenId)\\n                        ) {\\n                            delegates[delegatesCount++] = delegationInfo_.delegate;\\n                        }\\n                    }\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (potentialDelegatesLength > delegatesCount) {\\n            assembly {\\n                let decrease := sub(potentialDelegatesLength, delegatesCount)\\n                mstore(delegates, sub(mload(delegates), decrease))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getContractLevelDelegations(address vault)\\n        external\\n        view\\n        returns (IDelegationRegistry.ContractDelegation[] memory contractDelegations)\\n    {\\n        EnumerableSet.Bytes32Set storage delegationHashes_ = delegations[vault][vaultVersion[vault]];\\n        uint256 potentialLength = delegationHashes_.length();\\n        uint256 delegationCount = 0;\\n        contractDelegations = new IDelegationRegistry.ContractDelegation[](potentialLength);\\n        for (uint256 i = 0; i < potentialLength;) {\\n            bytes32 delegationHash = delegationHashes_.at(i);\\n            DelegationInfo storage delegationInfo_ = delegationInfo[delegationHash];\\n            if (delegationInfo_.type_ == IDelegationRegistry.DelegationType.CONTRACT) {\\n                // check delegate version by validating the hash\\n                if (\\n                    delegationHash\\n                        == _computeContractDelegationHash(vault, delegationInfo_.delegate, delegationInfo_.contract_)\\n                ) {\\n                    contractDelegations[delegationCount++] = IDelegationRegistry.ContractDelegation({\\n                        contract_: delegationInfo_.contract_,\\n                        delegate: delegationInfo_.delegate\\n                    });\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (potentialLength > delegationCount) {\\n            assembly {\\n                let decrease := sub(potentialLength, delegationCount)\\n                mstore(contractDelegations, sub(mload(contractDelegations), decrease))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function getTokenLevelDelegations(address vault)\\n        external\\n        view\\n        returns (IDelegationRegistry.TokenDelegation[] memory tokenDelegations)\\n    {\\n        EnumerableSet.Bytes32Set storage delegationHashes_ = delegations[vault][vaultVersion[vault]];\\n        uint256 potentialLength = delegationHashes_.length();\\n        uint256 delegationCount = 0;\\n        tokenDelegations = new IDelegationRegistry.TokenDelegation[](potentialLength);\\n        for (uint256 i = 0; i < potentialLength;) {\\n            bytes32 delegationHash = delegationHashes_.at(i);\\n            DelegationInfo storage delegationInfo_ = delegationInfo[delegationHash];\\n            if (delegationInfo_.type_ == IDelegationRegistry.DelegationType.TOKEN) {\\n                // check delegate version by validating the hash\\n                if (\\n                    delegationHash\\n                        == _computeTokenDelegationHash(\\n                            vault, delegationInfo_.delegate, delegationInfo_.contract_, delegationInfo_.tokenId\\n                        )\\n                ) {\\n                    tokenDelegations[delegationCount++] = IDelegationRegistry.TokenDelegation({\\n                        contract_: delegationInfo_.contract_,\\n                        tokenId: delegationInfo_.tokenId,\\n                        delegate: delegationInfo_.delegate\\n                    });\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (potentialLength > delegationCount) {\\n            assembly {\\n                let decrease := sub(potentialLength, delegationCount)\\n                mstore(tokenDelegations, sub(mload(tokenDelegations), decrease))\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function checkDelegateForAll(address delegate, address vault) public view override returns (bool) {\\n        bytes32 delegateHash =\\n            keccak256(abi.encode(delegate, vault, vaultVersion[vault], delegateVersion[vault][delegate]));\\n        return delegations[vault][vaultVersion[vault]].contains(delegateHash);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function checkDelegateForContract(address delegate, address vault, address contract_)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        bytes32 delegateHash =\\n            keccak256(abi.encode(delegate, vault, contract_, vaultVersion[vault], delegateVersion[vault][delegate]));\\n        return delegations[vault][vaultVersion[vault]].contains(delegateHash)\\n            ? true\\n            : checkDelegateForAll(delegate, vault);\\n    }\\n\\n    /**\\n     * @inheritdoc IDelegationRegistry\\n     */\\n    function checkDelegateForToken(address delegate, address vault, address contract_, uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        bytes32 delegateHash = keccak256(\\n            abi.encode(delegate, vault, contract_, tokenId, vaultVersion[vault], delegateVersion[vault][delegate])\\n        );\\n        return delegations[vault][vaultVersion[vault]].contains(delegateHash)\\n            ? true\\n            : checkDelegateForContract(delegate, vault, contract_);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IDelegationRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title An immutable registry contract to be deployed as a standalone primitive\\n * @dev See EIP-5639, new project launches can read previous cold wallet -> hot wallet delegations\\n * from here and integrate those permissions into their flow\\n */\\ninterface IDelegationRegistry {\\n    /// @notice Delegation type\\n    enum DelegationType {\\n        NONE,\\n        ALL,\\n        CONTRACT,\\n        TOKEN\\n    }\\n\\n    /// @notice Info about a single delegation, used for onchain enumeration\\n    struct DelegationInfo {\\n        DelegationType type_;\\n        address vault;\\n        address delegate;\\n        address contract_;\\n        uint256 tokenId;\\n    }\\n\\n    /// @notice Info about a single contract-level delegation\\n    struct ContractDelegation {\\n        address contract_;\\n        address delegate;\\n    }\\n\\n    /// @notice Info about a single token-level delegation\\n    struct TokenDelegation {\\n        address contract_;\\n        uint256 tokenId;\\n        address delegate;\\n    }\\n\\n    /// @notice Emitted when a user delegates their entire wallet\\n    event DelegateForAll(address vault, address delegate, bool value);\\n\\n    /// @notice Emitted when a user delegates a specific contract\\n    event DelegateForContract(address vault, address delegate, address contract_, bool value);\\n\\n    /// @notice Emitted when a user delegates a specific token\\n    event DelegateForToken(address vault, address delegate, address contract_, uint256 tokenId, bool value);\\n\\n    /// @notice Emitted when a user revokes all delegations\\n    event RevokeAllDelegates(address vault);\\n\\n    /// @notice Emitted when a user revoes all delegations for a given delegate\\n    event RevokeDelegate(address vault, address delegate);\\n\\n    /**\\n     * -----------  WRITE -----------\\n     */\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for all contracts\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForAll(address delegate, bool value) external;\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for a specific contract\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForContract(address delegate, address contract_, bool value) external;\\n\\n    /**\\n     * @notice Allow the delegate to act on your behalf for a specific token\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param tokenId The token id for the token you're delegating\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\n     */\\n    function delegateForToken(address delegate, address contract_, uint256 tokenId, bool value) external;\\n\\n    /**\\n     * @notice Revoke all delegates\\n     */\\n    function revokeAllDelegates() external;\\n\\n    /**\\n     * @notice Revoke a specific delegate for all their permissions\\n     * @param delegate The hotwallet to revoke\\n     */\\n    function revokeDelegate(address delegate) external;\\n\\n    /**\\n     * @notice Remove yourself as a delegate for a specific vault\\n     * @param vault The vault which delegated to the msg.sender, and should be removed\\n     */\\n    function revokeSelf(address vault) external;\\n\\n    /**\\n     * -----------  READ -----------\\n     */\\n\\n    /**\\n     * @notice Returns all active delegations a given delegate is able to claim on behalf of\\n     * @param delegate The delegate that you would like to retrieve delegations for\\n     * @return info Array of DelegationInfo structs\\n     */\\n    function getDelegationsByDelegate(address delegate) external view returns (DelegationInfo[] memory);\\n\\n    /**\\n     * @notice Returns an array of wallet-level delegates for a given vault\\n     * @param vault The cold wallet who issued the delegation\\n     * @return addresses Array of wallet-level delegates for a given vault\\n     */\\n    function getDelegatesForAll(address vault) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns an array of contract-level delegates for a given vault and contract\\n     * @param vault The cold wallet who issued the delegation\\n     * @param contract_ The address for the contract you're delegating\\n     * @return addresses Array of contract-level delegates for a given vault and contract\\n     */\\n    function getDelegatesForContract(address vault, address contract_) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Returns an array of contract-level delegates for a given vault's token\\n     * @param vault The cold wallet who issued the delegation\\n     * @param contract_ The address for the contract holding the token\\n     * @param tokenId The token id for the token you're delegating\\n     * @return addresses Array of contract-level delegates for a given vault's token\\n     */\\n    function getDelegatesForToken(address vault, address contract_, uint256 tokenId)\\n        external\\n        view\\n        returns (address[] memory);\\n\\n    /**\\n     * @notice Returns all contract-level delegations for a given vault\\n     * @param vault The cold wallet who issued the delegations\\n     * @return delegations Array of ContractDelegation structs\\n     */\\n    function getContractLevelDelegations(address vault)\\n        external\\n        view\\n        returns (ContractDelegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns all token-level delegations for a given vault\\n     * @param vault The cold wallet who issued the delegations\\n     * @return delegations Array of TokenDelegation structs\\n     */\\n    function getTokenLevelDelegations(address vault) external view returns (TokenDelegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on the entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on your behalf for a token contract or an entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForContract(address delegate, address vault, address contract_)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address is delegated to act on your behalf for a specific token, the token's contract or an entire vault\\n     * @param delegate The hotwallet to act on your behalf\\n     * @param contract_ The address for the contract you're delegating\\n     * @param tokenId The token id for the token you're delegating\\n     * @param vault The cold wallet who issued the delegation\\n     */\\n    function checkDelegateForToken(address delegate, address vault, address contract_, uint256 tokenId)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"DelegateForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"DelegateForContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"DelegateForToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"RevokeAllDelegates\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"RevokeDelegate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"checkDelegateForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"}],\"name\":\"checkDelegateForContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"checkDelegateForToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"delegateForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"delegateForContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"delegateForToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getContractLevelDelegations\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"internalType\":\"struct IDelegationRegistry.ContractDelegation[]\",\"name\":\"contractDelegations\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getDelegatesForAll\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"delegates\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"}],\"name\":\"getDelegatesForContract\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"delegates\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getDelegatesForToken\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"delegates\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"getDelegationsByDelegate\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IDelegationRegistry.DelegationType\",\"name\":\"type_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct IDelegationRegistry.DelegationInfo[]\",\"name\":\"info\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getTokenLevelDelegations\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"internalType\":\"struct IDelegationRegistry.TokenDelegation[]\",\"name\":\"tokenDelegations\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeAllDelegates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"revokeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"revokeSelf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DelegationRegistry", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}