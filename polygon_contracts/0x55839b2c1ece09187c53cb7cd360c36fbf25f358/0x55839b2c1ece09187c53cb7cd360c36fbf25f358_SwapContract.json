{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n \r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n \r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n \r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n \r\ninterface AggregatorV3Interface {\r\n  function decimals()\r\n    external\r\n    view\r\n    returns (\r\n      uint8\r\n    );\r\n  function description()\r\n    external\r\n    view\r\n    returns (\r\n      string memory\r\n    );\r\n  function version()\r\n    external\r\n    view\r\n    returns (\r\n      uint256\r\n    );\r\n  function getRoundData(\r\n    uint80 _roundId\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n    function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}\r\n\r\ncontract SwapContract is Ownable {\r\n\r\n    IERC20 public weToken;\r\n    AggregatorV3Interface private priceFeed;\r\n    mapping(address => uint256) public depositsMATIC;\r\n    mapping(address => uint256) public depositsUSDC;\r\n    mapping(address => uint256) public lockedMeac;\r\n    mapping(address => uint256) public deposittimes;\r\n    uint256 public  totalLockedMeac = 0 ether;\r\n    uint256 public  totallockTime = 180 days;\r\n    uint256 public  minDepositAmount = 25 / 10 * (10 ** 6); \r\n    uint256       tokensAmountForUSDC = 0.12 ether; \r\n    uint256 public  totalSwapedMATIC;\r\n    uint256 public  totalSwapedUSDC;\r\n    address private usdcAddress = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\r\n    \r\n    struct TranData {\r\n        string date;\r\n        address sender;\r\n        uint tokenAmount;\r\n        string privateNote;\r\n    }\r\n    TranData[] public transacData;\r\n\r\n    constructor(IERC20 _token) {\r\n        weToken = _token;\r\n        priceFeed = AggregatorV3Interface(0xAB594600376Ec9fD91F8e885dADF0CE036862dE0);\r\n    }\r\n\r\n    function changeWeToken(address _newMeacAdd) external onlyOwner{\r\n        weToken = IERC20(_newMeacAdd);\r\n    }\r\n\r\n    function depositUSDCForLockToken(uint256 amnt) public {\r\n        require(amnt >= minDepositAmount, \"Minimum amount is 2.5USDC\");\r\n        IERC20(usdcAddress).transferFrom(msg.sender, address(this), amnt);\r\n        uint256 tokenAmount = (getTokensAmount(amnt));\r\n        depositsUSDC[msg.sender] = depositsUSDC[msg.sender]+amnt;\r\n        lockedMeac[msg.sender] = lockedMeac[msg.sender]+tokenAmount;\r\n        deposittimes[msg.sender] = block.timestamp;\r\n        totalLockedMeac = totalLockedMeac+tokenAmount;\r\n    }\r\n    function depositMATICForLockToken() public payable {\r\n       require(theUSDCAmount(msg.value) >= minDepositAmount, \"Minimum amount is 2.5USDC\");\r\n        uint256 usdcAmount =  getUSDCAmount(msg.value);\r\n        uint256 tokenAmount = (MaticTokensAmount(usdcAmount));\r\n        depositsMATIC[msg.sender] = depositsMATIC[msg.sender]+msg.value;\r\n        lockedMeac[msg.sender] = lockedMeac[msg.sender]+tokenAmount;\r\n        deposittimes[msg.sender] = block.timestamp;\r\n        totalLockedMeac = totalLockedMeac+tokenAmount;\r\n    }\r\n    function approve(address tokenAddress, address spender, uint256 amount) public onlyOwner returns (bool) {\r\n      IERC20(tokenAddress).approve(spender, amount);\r\n      return true;\r\n    }\r\n    function depositUSDCForUnlockToken(uint256 amnt, string memory date, string memory _privateNote) public {\r\n        require(amnt >= minDepositAmount, \"Minimum amount is 2.5USDC\");\r\n        IERC20(usdcAddress).transferFrom(msg.sender, address(this), amnt);\r\n        uint256 tokenAmount = (getTokensAmount(amnt));\r\n        weToken.transfer(msg.sender, tokenAmount);\r\n        totalSwapedUSDC = totalSwapedUSDC+amnt;\r\n\r\n        transacData.push(TranData({\r\n            date: date,\r\n            sender: msg.sender,\r\n            tokenAmount: tokenAmount,\r\n            privateNote: _privateNote\r\n        }));\r\n    }\r\n    function depositMATICForUnlockToken(string memory date, string memory _privateNote) public payable {\r\n        require(theUSDCAmount(msg.value) >= minDepositAmount, \"Minimum amount is 2.5USDC\");\r\n        uint256 usdcAmount = getUSDCAmount(msg.value);\r\n        uint256 tokenAmount = (MaticTokensAmount(usdcAmount));\r\n        weToken.transfer(msg.sender, tokenAmount);\r\n        totalSwapedMATIC = totalSwapedMATIC+msg.value;\r\n\r\n        transacData.push(TranData({\r\n            date: date,\r\n            sender: msg.sender,\r\n            tokenAmount: tokenAmount,\r\n            privateNote: _privateNote\r\n        }));\r\n    }\r\n\r\n    function readData () public view returns (TranData[] memory) {\r\n        return transacData;\r\n    }\r\n\r\n    function claimTokens() public {\r\n        require(lockedMeac[msg.sender] > 0, \"There are no deposited tokens for you.\");\r\n        require(checkTime(msg.sender), \"Your tokens are locked now.\");\r\n        weToken.transfer(msg.sender, lockedMeac[msg.sender]);\r\n        totalLockedMeac = totalLockedMeac-lockedMeac[msg.sender];\r\n        lockedMeac[msg.sender] = 0;\r\n        depositsMATIC[msg.sender] = 0;\r\n        depositsUSDC[msg.sender] = 0;\r\n        deposittimes[msg.sender] = 0;\r\n    }\r\n    function read(address add) public view returns(uint256 _depositMATIC, uint256 _depositUSDC, uint256 _lockedMeac, uint256 _restTime, bool _checkTime) {\r\n        _depositMATIC = depositsMATIC[add];\r\n        _depositUSDC = depositsUSDC[add];\r\n        _lockedMeac = lockedMeac[add];\r\n        _restTime = 0;\r\n        if(totallockTime >= (block.timestamp - deposittimes[add]))\r\n            _restTime = totallockTime - (block.timestamp - deposittimes[add]);\r\n        _checkTime = checkTime(add);\r\n    }\r\n    function getUSDCPerMATIC() public view returns (uint256) {\r\n        (\r\n            ,\r\n            int256 price,\r\n            ,\r\n            ,\r\n        ) = priceFeed.latestRoundData();\r\n        return (uint256(price));\r\n    }\r\n\r\n    function getUSDCAmount(uint256 maticAmount) public view returns(uint256){\r\n        uint256 usdcAmount = maticAmount*getUSDCPerMATIC();\r\n        return (usdcAmount);\r\n    }\r\n\r\n    function theUSDCAmount(uint256 maticAmount) private view returns(uint256){\r\n        uint256 maticrate= getUSDCPerMATIC()/1e2;\r\n        uint256 usdcAmount = maticAmount*maticrate;\r\n        return (usdcAmount/1e18);\r\n    }\r\n\r\n    function getTokensAmount(uint256 usdcAmount) private view returns(uint256) {\r\n        uint256 tokensAmount = ((usdcAmount*1e12)*1e18)/tokensAmountForUSDC;\r\n        return tokensAmount;\r\n    }\r\n\r\n    function MaticTokensAmount(uint256 usdcAmount) private view returns(uint256) {\r\n        uint256 tokensAmount = usdcAmount*1e18/tokensAmountForUSDC;\r\n        return (tokensAmount/1e8);\r\n    }\r\n\r\n    function checkTime(address add) private view returns(bool) {\r\n        bool ret = ((deposittimes[add] != 0) && (block.timestamp >= (deposittimes[add] + totallockTime)));\r\n        return ret;\r\n    }\r\n\r\n    function releaseFunds(uint256 amount) external onlyOwner {\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    function releaseFundsAll() external onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\r\n      require(IERC20(tokenAddress).balanceOf(address(this))>0, \"Not this amount in contract!\");\r\n        IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\r\n        emit Recovered(tokenAddress, tokenAmount);\r\n    }\r\n\r\n    function recoverUSDC(uint256 tokenAmount) external onlyOwner {\r\n      require(IERC20(usdcAddress).balanceOf(address(this))>0, \"Not this amount in contract!\");\r\n        IERC20(usdcAddress).transfer(msg.sender, tokenAmount);\r\n        emit Recovered(usdcAddress, tokenAmount);\r\n    }\r\n    \r\n    event Recovered(address token, uint256 amount);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMeacAdd\",\"type\":\"address\"}],\"name\":\"changeWeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositMATICForLockToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"date\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_privateNote\",\"type\":\"string\"}],\"name\":\"depositMATICForUnlockToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amnt\",\"type\":\"uint256\"}],\"name\":\"depositUSDCForLockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amnt\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"date\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_privateNote\",\"type\":\"string\"}],\"name\":\"depositUSDCForUnlockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositsMATIC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositsUSDC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposittimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maticAmount\",\"type\":\"uint256\"}],\"name\":\"getUSDCAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUSDCPerMATIC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedMeac\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"read\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositMATIC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositUSDC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockedMeac\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_restTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_checkTime\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"readData\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"date\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"privateNote\",\"type\":\"string\"}],\"internalType\":\"struct SwapContract.TranData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverUSDC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"releaseFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseFundsAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedMeac\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSwapedMATIC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSwapedUSDC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totallockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transacData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"date\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"privateNote\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SwapContract", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000005783597ba1a5e5f5182db58dbce47657a9535eec", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://36d3bc0cb68c3590b2c6d4f2d8fe3a454a4e6e528c22be449ee4a526a5030b40"}