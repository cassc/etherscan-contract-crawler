{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"StakingWithHolderCount.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\r\\n// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\ninterface IERC721 {\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function setApprovalForAll(address operator,bool _approved) external;\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\nabstract contract Ownable is Context {\\r\\n    event OwnershipTransferred(address oldOwner, address newOwner);\\r\\n    address private _owner;\\r\\n    constructor(address initialOwner) {\\r\\n        _transferOwnership(initialOwner);\\r\\n    }\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface Interface_Rival_Bears_Staking {\\r\\n    struct UserStake{\\r\\n        address nft;\\r\\n        uint256 tokenId;\\r\\n        uint256 timestamp;\\r\\n        uint256 lastHarvest;\\r\\n        uint256 lastHarvestStakingSeasonIndex;\\r\\n    }\\r\\n    //redundant settings avoided\\r\\n    error NoChangesMade();\\r\\n    //input parameter arrays [nft] + [tokenId] for managing multiple stakes must be the same length\\r\\n    error UnevenArraySizes();\\r\\n    //redeemLocation contract call or return failed using mint() / harvest()...\\r\\n    error RedemptionFailed(address redemptionLocation, uint256 redemptionPointsAmount);\\r\\n    //attempt to manage stake which doesn't exist\\r\\n    error NotStaked(address nft, uint256 tokenId);\\r\\n    //staking season end time is set before current block timestamp and is not infinite (set as 0)\\r\\n    error InvalidStakingEndTime();\\r\\n    //staking rate is set at 0. Staking season end time is manipulated to end season\\r\\n    error InvalidStakingRate_EndSeasonInstead();\\r\\n    //contract owner has banned tokenId\\r\\n    error TokenIdNotAllowed(address nft, uint256 tokenId);\\r\\n    //nft has not been added for staking\\r\\n    error NFTNotAllowed(address nft);\\r\\n    //attempted to update or end staking for an nft without an active season\\r\\n    error NoActiveStakingSeason(address nft);\\r\\n    //max staking number of staking season edge case\\r\\n    error MaxStakingSeasonReached(address nft);\\r\\n    //no points to harvest\\r\\n    error NoPointsToHarvest();\\r\\n    //no points to harvest\\r\\n    error InsufficientPointBalance();\\r\\n\\r\\n    event BeginStakingSeason(address indexed nft, uint256 dailyPoints, uint256 endTime);\\r\\n    event SetStakingPercentMultiplier(address indexed nft, uint256 indexed tokenId, uint256 indexed stakingSeason, uint256 multiplier);\\r\\n    event SetRedeemLocation(address location);\\r\\n    event EnableStaking(address indexed nft,uint256 indexed tokenId);\\r\\n    event DisableStaking(address indexed nft, uint256 indexed tokenId);\\r\\n    event Harvest(address indexed staker, uint256 points);\\r\\n    event Redeem(address indexed staker, uint256 points, address indexed redeemLocation);\\r\\n    event Stake(address indexed staker, address indexed nft, uint256 indexed tokenId);\\r\\n    event Unstake(address indexed staker, address indexed nft, uint256 indexed tokenId);\\r\\n    \\r\\n    function beginNewStakingSeason(address nft, uint256 dailyPoints, uint256 endTime) external;\\r\\n    function updateStakingSeasonEndTime(address nft, uint256 endTime) external;\\r\\n    function endStakingSeason(address nft) external;\\r\\n    //set stakingPercentMultiplier for new season\\r\\n    //daily rewards will be multiplied by stakingPercentMultiplier and divided by 100\\r\\n    // daily points = [stakingPercentMultiplier %] * [dailyPoints]\\r\\n    //multiplier of 0 is equal to multiplier of 100\\r\\n    //last updated staking multiplier is used\\r\\n    function setStakingPercentMultiplier(address nft, uint256 tokenId, uint256 stakingPercentMultiplier) external;\\r\\n    function setStakingPercentMultiplierMultiple(address [] memory nft, uint256 [] memory tokenId, uint256 [] memory stakingPercentMultiplier) external;\\r\\n    function setTokenStakingDisabled(address nft, uint256 tokenId, bool disabled) external;\\r\\n    function setTokenStakingDisabledMultiple(address  [] memory nft, uint256  [] memory tokenId, bool disabled) external;\\r\\n    //change contract points will be redeemed & withdrawn to\\r\\n    function setRedeemLocation(address redeemLocation) external;\\r\\n    function setRedeemFunction(string memory redeemFunction) external;\\r\\n    //transfer token onwnership if required for using mint function\\r\\n    function transferOwnershipRedeemLocation(address newOwner) external;\\r\\n    //viewable functions for lookups\\r\\n    function getTotalStaked() external returns(uint256);\\r\\n    function getAllowednfts()  external returns (address [] memory nfts);\\r\\n    function getStakingSeason(address nft) external returns (uint256 stakingSeason);\\r\\n    function getCurrentStakingSeasonEndTime(address nft) external returns (uint256 stakingEndTime);\\r\\n    function getStakingSeasonEndTime(address nft,uint256 stakingSeasonIndex) external returns (uint256 stakingEndTime);\\r\\n    function getRedeemLocation() external returns (address redeemLocation);\\r\\n    function getRedeemFunction() external returns (string memory redeemFunction);\\r\\n    function getStakingPercentMultiplier(address nft, uint256 tokenId, uint256 stakingSeasonIndex) external returns(uint256 multiplier);\\r\\n    function getStakingPercentMultiplierMultiple(address [] memory nft, uint256 [] memory tokenId, uint256 [] memory stakingSeasonIndex) external returns(uint256 [] memory multiplier );\\r\\n    function getStakes(address staker)  external returns (UserStake [] memory);\\r\\n    function getAccumulatedHarvestedPoints() external returns (uint256 points);//allowed to overflow\\r\\n    function getStakerAccumulatedHarvestedPoints(address staker) external returns (uint256 points);\\r\\n    function getAccumulatedRedeemedPoints() external returns (uint256 points);//allowed to overflow\\r\\n    function getStakerAccumulatedRedeemedPoints(address staker) external returns (uint256 points);\\r\\n    //unharvested points also includes \\r\\n    function getStakerUnharvestedPoints(address staker) external returns (uint256 points);\\r\\n    function getEarnedPointsFromStake(address staker, uint256 stakingIndex) external returns (uint256 points);\\r\\n    //address of stake owner\\r\\n    function getStaker(address nft, uint256 tokenId) external returns (address staker);\\r\\n    //staker list for snapshots\\r\\n    function getAllStakers() external returns (address [] memory staker);//head\\r\\n    //end-user interactive functions\\r\\n    function stake(address nft, uint256 tokenId) external;\\r\\n    function stakeMultiple(address [] calldata nft, uint256 [] calldata tokenId) external;\\r\\n    function harvestStake(uint256 stakingIndex) external;\\r\\n    function harvestAllStakes() external;\\r\\n    function redeem(uint256 points) external;//  redeem a certain amount of points\\r\\n    function unstake(uint256 stakingIndex) external;\\r\\n    function unstakeMultiple(uint256 [] memory stakingIndex) external;\\r\\n    function emergencyUnstake(uint256 stakingIndex) external;\\r\\n}\\r\\n\\r\\ncontract proxyHolderWallet{\\r\\n    address immutable parent;\\r\\n    constructor(address nft){\\r\\n        parent = msg.sender;\\r\\n        IERC721(nft).setApprovalForAll(msg.sender,true);\\r\\n    }\\r\\n    function approveUnstake(address nft) external{\\r\\n        IERC721(nft).setApprovalForAll(parent,true);\\r\\n    }\\r\\n}\\r\\ninterface ProxyHolderWallet {\\r\\n    function approveUnstake(address nft) external;\\r\\n}\\r\\n\\r\\ncontract Rival_Bears_Staking is Interface_Rival_Bears_Staking, Ownable{\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    struct StakingSeason{\\r\\n        uint256 dailyPoints;\\r\\n        uint256 startTime;\\r\\n        uint256 endTime;\\r\\n    }\\r\\n\\r\\n    /* \\r\\n    struct UserStake{\\r\\n        address nft;\\r\\n        uint256 tokenId;\\r\\n        uint256 timestamp;\\r\\n        uint256 lastHarvest;\\r\\n        uint256 lastHarvestStakingSeasonIndex;\\r\\n    }\\r\\n    */\\r\\n\\r\\n    struct UserPoints{\\r\\n        uint256 harvested;\\r\\n        uint256 redeemed;\\r\\n    }\\r\\n    mapping(address=>address) private holderVaults;\\r\\n    mapping(address=>mapping(address=>bool)) private holderApprovals;\\r\\n\\r\\n    mapping(address=>StakingSeason[]) private stakingSeasons;\\r\\n    address [] private allowedNFTS;\\r\\n    mapping(address=>mapping(uint256=>bool)) disabledTokens;\\r\\n    //nft -> tokenId -> stakingSeason = multiplier\\r\\n    mapping(address=>mapping(uint256=>mapping(uint256=>uint256))) private stakingPercentMultipliers;\\r\\n    \\r\\n    address private redeemLocation;\\r\\n    string private redeemFunction = \\\"mint\\\";\\r\\n\\r\\n    uint256 private totalStakes;\\r\\n    mapping(address=>UserStake[]) private stakes;\\r\\n    UserPoints private totalPoints;\\r\\n    mapping(address=>UserPoints) private points;\\r\\n    \\r\\n    mapping(address=>mapping(uint256=>address)) private stakerOfToken;\\r\\n    address [] private stakers;\\r\\n    mapping(address=>uint256) private stakersListIndex;\\r\\n\\r\\n    constructor() Ownable(msg.sender) {}\\r\\n\\r\\n    function beginNewStakingSeason(address nft, uint256 dailyPoints, uint256 endTime) external onlyOwner{\\r\\n        uint length = stakingSeasons[nft].length;\\r\\n        //require end of staing to be \\r\\n        if(endTime!=0 && block.timestamp >= endTime){\\r\\n            revert InvalidStakingEndTime();\\r\\n        }\\r\\n        //require positive staking rate\\r\\n        if(dailyPoints==0){\\r\\n            revert InvalidStakingRate_EndSeasonInstead();\\r\\n        }\\r\\n        //first staking season msut be added to allowedNFTS list\\r\\n        if(length==0){\\r\\n            allowedNFTS.push(nft);\\r\\n        }\\r\\n        StakingSeason memory season;\\r\\n        season.dailyPoints = dailyPoints;\\r\\n        season.startTime = block.timestamp;\\r\\n        season.endTime = endTime;\\r\\n        stakingSeasons[nft].push(season);\\r\\n    }\\r\\n\\r\\n    function _updateStakingSeasonEndTime(address nft, uint256 endTime) private onlyOwner{\\r\\n        uint length = stakingSeasons[nft].length;\\r\\n        if(length==0){\\r\\n            revert NoActiveStakingSeason(nft);\\r\\n        }\\r\\n        uint index = length - 1;\\r\\n        if(block.timestamp > stakingSeasons[nft][index].endTime){\\r\\n            revert NoActiveStakingSeason(nft);\\r\\n        }\\r\\n        stakingSeasons[nft][index].endTime = endTime;\\r\\n    }\\r\\n    function endStakingSeason(address nft) external onlyOwner{\\r\\n        //set endTime to immediate past\\r\\n        _updateStakingSeasonEndTime(nft, block.timestamp - 1);\\r\\n    }\\r\\n\\r\\n    function updateStakingSeasonEndTime(address nft, uint256 endTime) external onlyOwner{\\r\\n        if(endTime!=0 && block.timestamp >= endTime){\\r\\n            revert InvalidStakingEndTime();\\r\\n        }\\r\\n        //set endTime to immediate past\\r\\n        _updateStakingSeasonEndTime(nft, endTime);\\r\\n    }\\r\\n    function _setStakingPercentMultiplier(address nft, uint256 tokenId, uint256 stakingPercentMultiplier, uint256 index) private{\\r\\n        stakingPercentMultipliers[nft][tokenId][index] = stakingPercentMultiplier;\\r\\n    }\\r\\n    function setStakingPercentMultiplier(address nft, uint256 tokenId, uint256 stakingPercentMultiplier) external onlyOwner{\\r\\n        uint index = stakingSeasons[nft].length;\\r\\n        if(index==type(uint256).max){\\r\\n            revert MaxStakingSeasonReached(nft);\\r\\n        }\\r\\n        if(stakingPercentMultiplier == stakingPercentMultipliers[nft][tokenId][index]){\\r\\n            revert NoChangesMade();\\r\\n        }\\r\\n        _setStakingPercentMultiplier(nft,tokenId,stakingPercentMultiplier,index);\\r\\n    }\\r\\n\\r\\n    function setStakingPercentMultiplierMultiple(address [] memory nft, uint256 [] memory tokenId, uint256 [] memory stakingPercentMultiplier) external onlyOwner{\\r\\n        if(nft.length!=tokenId.length || tokenId.length!= stakingPercentMultiplier.length){\\r\\n            revert UnevenArraySizes();\\r\\n        }\\r\\n        uint index;\\r\\n        for(uint i=0;i<nft.length;i++){\\r\\n            index = stakingSeasons[nft[i]].length;\\r\\n            if(index==type(uint256).max){\\r\\n                revert MaxStakingSeasonReached(nft[i]);\\r\\n            }\\r\\n            _setStakingPercentMultiplier(nft[i],tokenId[i],stakingPercentMultiplier[i],index);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setTokenStakingDisabled(address nft, uint256 tokenId, bool disabled) public onlyOwner{\\r\\n        disabledTokens[nft][tokenId] = disabled;\\r\\n        if(disabled==true){\\r\\n            emit DisableStaking(nft,tokenId);\\r\\n        }\\r\\n        else{\\r\\n            emit EnableStaking(nft,tokenId);\\r\\n        }\\r\\n    }\\r\\n    function setTokenStakingDisabledMultiple(address  [] memory nft, uint256  [] memory tokenId, bool disabled) external onlyOwner{\\r\\n        if(nft.length!=tokenId.length){\\r\\n            revert UnevenArraySizes();\\r\\n        }\\r\\n        for(uint i=0;i<nft.length;i++){\\r\\n            setTokenStakingDisabled(nft[i],tokenId[i],disabled);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function setRedeemLocation(address _redeemLocation) external onlyOwner{\\r\\n        if(redeemLocation == _redeemLocation){\\r\\n            revert NoChangesMade();\\r\\n        }\\r\\n        redeemLocation = _redeemLocation;\\r\\n        emit SetRedeemLocation(_redeemLocation);\\r\\n\\r\\n    }\\r\\n\\r\\n    function setRedeemFunction(string memory _redeemFunction) external onlyOwner{\\r\\n        if(keccak256(bytes(redeemFunction)) == keccak256(bytes(_redeemFunction))){\\r\\n            revert NoChangesMade();\\r\\n        }\\r\\n        redeemFunction = string.concat(_redeemFunction,\\\"(address,uint256)\\\");\\r\\n    }\\r\\n\\r\\n    function transferOwnershipRedeemLocation(address newOwner) external onlyOwner{\\r\\n        Ownable(redeemLocation).transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function getTotalStaked() external view returns(uint256){\\r\\n        return totalStakes;\\r\\n    }\\r\\n\\r\\n    function getAllowednfts()  external view returns (address [] memory){\\r\\n        address [] memory nfts;\\r\\n        uint length = allowedNFTS.length;\\r\\n        uint len;\\r\\n        address a;\\r\\n        uint count;\\r\\n        uint time;\\r\\n        for(uint i=0;i<length;i++){\\r\\n            a = allowedNFTS[i];\\r\\n            len = stakingSeasons[a].length;\\r\\n            //must stake before end time\\r\\n            time = stakingSeasons[a][len-1].endTime;\\r\\n            if(len>1 && (time == 0 || block.timestamp < time)){\\r\\n                nfts[count]=a;\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n        return nfts;\\r\\n    }\\r\\n\\r\\n    function getStakingSeason(address nft) external view returns (uint256){\\r\\n        return stakingSeasons[nft].length;\\r\\n    }\\r\\n\\r\\n    function getCurrentStakingSeasonEndTime(address nft) external view returns (uint256){\\r\\n        return stakingSeasons[nft][stakingSeasons[nft].length-1].endTime;\\r\\n    }\\r\\n\\r\\n    function getStakingSeasonEndTime(address nft,uint256 stakingSeasonIndex) external view returns (uint256){\\r\\n        return stakingSeasons[nft][stakingSeasonIndex].endTime;\\r\\n    }\\r\\n\\r\\n    function getRedeemLocation() external view returns (address){\\r\\n        return redeemLocation;\\r\\n    }\\r\\n\\r\\n    function getRedeemFunction() external view returns (string memory){\\r\\n        return redeemFunction;\\r\\n    }\\r\\n\\r\\n    function getStakingPercentMultiplier(address nft, uint256 tokenId, uint256 stakingSeasonIndex) public view returns(uint256) {\\r\\n        uint256 multiplier = stakingPercentMultipliers[nft][tokenId][stakingSeasonIndex];\\r\\n        return multiplier == 0 ? 100 : multiplier;\\r\\n    }\\r\\n    function getStakingPercentMultiplierMultiple(address [] memory nft, uint256 [] memory tokenId, uint256 [] memory stakingSeasonIndex) external view returns(uint256 [] memory){\\r\\n        if(nft.length!=tokenId.length || tokenId.length!= stakingSeasonIndex.length){\\r\\n            revert UnevenArraySizes();\\r\\n        }\\r\\n        uint256 [] memory multiplier;\\r\\n        uint length = 0;\\r\\n        unchecked{\\r\\n            for(uint i=0;i<length;i++){\\r\\n            multiplier[i] = getStakingPercentMultiplier(nft[i], tokenId[i], stakingSeasonIndex[i]);\\r\\n            }\\r\\n        }\\r\\n        return multiplier;\\r\\n    }\\r\\n\\r\\n    function getStakes(address staker)  external view returns (UserStake [] memory){\\r\\n        return stakes[staker];\\r\\n    }\\r\\n\\r\\n    function getAccumulatedHarvestedPoints() external view returns (uint256){\\r\\n        return totalPoints.harvested;\\r\\n    }\\r\\n\\r\\n    function getStakerAccumulatedHarvestedPoints(address staker) external view returns (uint256){\\r\\n        return points[staker].harvested;\\r\\n    }\\r\\n    function getAccumulatedRedeemedPoints() external view returns (uint256){\\r\\n        return totalPoints.redeemed;\\r\\n    }\\r\\n    function getStakerAccumulatedRedeemedPoints(address staker) external view returns (uint256){\\r\\n        return points[staker].redeemed;\\r\\n    }\\r\\n    function getStakerUnharvestedPoints(address staker) external view returns (uint256){\\r\\n        uint256 total;\\r\\n        uint256 length = stakes[staker].length;\\r\\n        UserStake memory s;\\r\\n        StakingSeason memory S;\\r\\n        uint totalStakingSeasons;\\r\\n        uint256 startTime;\\r\\n        uint256 endTime;\\r\\n        for(uint i=0;i<length;i++){\\r\\n            s = stakes[staker][i];\\r\\n            totalStakingSeasons = stakingSeasons[s.nft].length;\\r\\n            for(uint j=s.lastHarvestStakingSeasonIndex;j<totalStakingSeasons;j++){\\r\\n                S = stakingSeasons[s.nft][j];\\r\\n                if(s.lastHarvest > S.startTime){\\r\\n                    startTime = s.lastHarvest;\\r\\n                }\\r\\n                else {\\r\\n                    startTime = S.startTime;\\r\\n                }\\r\\n\\r\\n                if(S.endTime==0 || S.endTime < block.timestamp){\\r\\n                    endTime = block.timestamp;\\r\\n                }\\r\\n                else{\\r\\n                    endTime = S.endTime;\\r\\n                }\\r\\n                uint256 multiplier = getStakingPercentMultiplier(s.nft,s.tokenId,j);\\r\\n                total += (endTime - startTime).mul(S.dailyPoints).div(86400).mul(multiplier).div(100);\\r\\n            }\\r\\n        }\\r\\n        return total;\\r\\n    }\\r\\n    function getEarnedPointsFromStake(address staker, uint256 stakingIndex) public view returns(uint256) {\\r\\n        UserStake memory s = stakes[staker][stakingIndex];\\r\\n        StakingSeason memory S;\\r\\n        uint totalStakingSeasons;\\r\\n        uint256 startTime;\\r\\n        uint256 endTime;\\r\\n        uint256 total;\\r\\n        totalStakingSeasons = stakingSeasons[s.nft].length;\\r\\n            for(uint j=s.lastHarvestStakingSeasonIndex;j<totalStakingSeasons;j++){\\r\\n                S = stakingSeasons[s.nft][j];\\r\\n                if(s.lastHarvest > S.startTime){\\r\\n                    startTime = s.lastHarvest;\\r\\n                }\\r\\n                else {\\r\\n                    startTime = S.startTime;\\r\\n                }\\r\\n\\r\\n                if(S.endTime==0 || S.endTime < block.timestamp){\\r\\n                    endTime = block.timestamp;\\r\\n                }\\r\\n                else{\\r\\n                    endTime = S.endTime;\\r\\n                }\\r\\n                uint256 multiplier = getStakingPercentMultiplier(s.nft,s.tokenId,j);\\r\\n                total += (endTime - startTime).mul(S.dailyPoints).div(86400).mul(multiplier).div(100);\\r\\n            }\\r\\n        return total;\\r\\n    }\\r\\n\\r\\n    function getStaker(address nft, uint256 tokenId) external view returns (address staker){\\r\\n        return stakerOfToken[nft][tokenId];\\r\\n    }\\r\\n    \\r\\n    function getAllStakers() external view returns (address [] memory staker){\\r\\n        return stakers;\\r\\n    }\\r\\n\\r\\n    function _stake(address nft, uint256 tokenId) private{\\r\\n        if(disabledTokens[nft][tokenId]==true){\\r\\n            revert NFTNotAllowed(nft);\\r\\n        }\\r\\n        uint256 length = stakingSeasons[nft].length;\\r\\n        if(length < 1){\\r\\n            revert NoActiveStakingSeason(nft);\\r\\n        }\\r\\n        uint256 stakingSeasonIndex = length-1;\\r\\n        uint256 endTime = stakingSeasons[nft][stakingSeasonIndex].endTime;\\r\\n        if(endTime != 0 && block.timestamp >= endTime){\\r\\n            revert NoActiveStakingSeason(nft);\\r\\n        }\\r\\n        UserStake memory newStake = UserStake(\\r\\n            nft,\\r\\n            tokenId,\\r\\n            block.timestamp,\\r\\n            block.timestamp,\\r\\n            stakingSeasonIndex\\r\\n        );\\r\\n        if(stakes[msg.sender].length==0){\\r\\n            stakersListIndex[msg.sender] = stakers.length;\\r\\n            stakers.push(msg.sender);\\r\\n        }\\r\\n        stakes[msg.sender].push(newStake);\\r\\n        stakerOfToken[nft][tokenId]=msg.sender;\\r\\n\\r\\n        if(holderVaults[msg.sender]==address(0)){\\r\\n            proxyHolderWallet location = new proxyHolderWallet(nft);\\r\\n            holderVaults[msg.sender] = address(location);\\r\\n            holderApprovals[msg.sender][nft]=true;\\r\\n        }\\r\\n        else if(holderApprovals[msg.sender][nft]==false){\\r\\n            proxyHolderWallet(holderVaults[msg.sender]).approveUnstake(nft);\\r\\n            holderApprovals[msg.sender][nft]=true;\\r\\n        }\\r\\n        //IERC721(nft).transferFrom(msg.sender,address(this),tokenId);\\r\\n        IERC721(nft).transferFrom(msg.sender,holderVaults[msg.sender],tokenId);\\r\\n        emit Stake(msg.sender,nft,tokenId);\\r\\n    }\\r\\n\\r\\n    function stake(address nft, uint256 tokenId) public{\\r\\n        _stake(nft,tokenId);\\r\\n        totalStakes++;\\r\\n    }\\r\\n\\r\\n    function stakeMultiple(address [] calldata nft, uint256 [] calldata tokenId) external{\\r\\n        if(nft.length!=tokenId.length){\\r\\n            revert UnevenArraySizes();\\r\\n        }\\r\\n        for(uint i=0;i<nft.length;i++){\\r\\n            _stake(nft[i],tokenId[i]);\\r\\n        }\\r\\n        totalStakes+=nft.length;\\r\\n    }\\r\\n\\r\\n    function _harvestStake(address staker, uint256 stakingIndex,uint256 harvestPoints) private{\\r\\n        uint256 maxHarvest = type(uint256).max - points[staker].harvested;\\r\\n        if(harvestPoints > maxHarvest){\\r\\n            harvestPoints = maxHarvest;\\r\\n        }\\r\\n        points[staker].harvested+=harvestPoints;\\r\\n        stakes[staker][stakingIndex].lastHarvest=block.timestamp;\\r\\n        stakes[staker][stakingIndex].lastHarvestStakingSeasonIndex = stakingSeasons[stakes[staker][stakingIndex].nft].length-1;\\r\\n        totalPoints.harvested += harvestPoints;\\r\\n    }\\r\\n\\r\\n    function harvestStake(uint256 stakingIndex) external{\\r\\n        address staker = msg.sender;\\r\\n        uint256 harvestPoints = getEarnedPointsFromStake(staker,stakingIndex);\\r\\n        if(harvestPoints == 0){\\r\\n            revert NoPointsToHarvest();\\r\\n        }\\r\\n        _harvestStake(staker,stakingIndex,harvestPoints);\\r\\n        emit Harvest(staker,harvestPoints);\\r\\n    }\\r\\n\\r\\n    function harvestAllStakes() external{\\r\\n        address staker = msg.sender;\\r\\n        uint length = stakes[msg.sender].length;\\r\\n        uint256 harvestPoints;\\r\\n        uint256 maxHarvest = type(uint256).max - points[staker].harvested;\\r\\n        uint stakeHarvest;\\r\\n        for(uint i=0;i<length && maxHarvest>0;i++){\\r\\n            stakeHarvest = getEarnedPointsFromStake(staker,i);\\r\\n            if(stakeHarvest > maxHarvest){\\r\\n                harvestPoints += maxHarvest;\\r\\n                maxHarvest=0;\\r\\n            }\\r\\n            else{\\r\\n                harvestPoints += stakeHarvest;\\r\\n                maxHarvest -= stakeHarvest;\\r\\n            }\\r\\n            stakes[staker][i].lastHarvest=block.timestamp;\\r\\n            stakes[staker][i].lastHarvestStakingSeasonIndex = stakingSeasons[stakes[staker][i].nft].length-1;\\r\\n        }\\r\\n        if(harvestPoints == 0){\\r\\n            revert NoPointsToHarvest();\\r\\n        }\\r\\n        points[staker].harvested += harvestPoints;\\r\\n        emit Harvest(staker,harvestPoints);\\r\\n    }\\r\\n\\r\\n    function redeem(uint256 _points) external {\\r\\n        address staker = msg.sender;\\r\\n        if(points[staker].harvested < _points){\\r\\n            revert InsufficientPointBalance();\\r\\n        }\\r\\n        points[staker].harvested -= _points;\\r\\n        (bool success, bytes memory data) = redeemLocation.call(abi.encodeWithSignature(redeemFunction,staker,_points));\\r\\n        if(!success) {\\r\\n            //fallback handler for redemption target contract to return corrected amount to redeem\\r\\n            uint256 _points2 = abi.decode(data,(uint256));\\r\\n            points[staker].harvested += _points;\\r\\n            points[staker].harvested -= _points2;\\r\\n            (success,) = redeemLocation.call(abi.encodeWithSignature(redeemFunction,staker,_points2));\\r\\n            if(!success){\\r\\n                revert RedemptionFailed(redeemLocation,_points);\\r\\n            }\\r\\n            totalPoints.redeemed += _points2;\\r\\n            return;\\r\\n        }\\r\\n        totalPoints.redeemed += _points;\\r\\n    }\\r\\n    \\r\\n    function unstake(uint256 stakingIndex) external{\\r\\n        address staker = msg.sender;\\r\\n        uint256 harvestPoints = getEarnedPointsFromStake(staker,stakingIndex);\\r\\n        UserStake memory s = stakes[staker][stakingIndex];\\r\\n        emit Unstake(staker,s.nft,s.tokenId);\\r\\n\\r\\n        if(harvestPoints>0){\\r\\n            _harvestStake(staker, stakingIndex, harvestPoints);\\r\\n            emit Harvest(staker,harvestPoints);\\r\\n        }\\r\\n        //remove stake from user's list of stakes\\r\\n        if(stakingIndex!=stakes[staker].length-1){\\r\\n            stakes[staker][stakingIndex]=stakes[staker][stakes[staker].length-1];\\r\\n        }\\r\\n        stakes[staker].pop();\\r\\n\\r\\n        //if user has no more stakes, remove user from staker list\\r\\n        if(stakes[staker].length==0){\\r\\n            if(stakersListIndex[staker]!=stakers.length-1){\\r\\n                stakers[stakersListIndex[staker]]=stakers[stakers.length-1];\\r\\n            }\\r\\n            stakers.pop();\\r\\n        }\\r\\n        totalStakes--;\\r\\n        delete stakerOfToken[s.nft][s.tokenId];\\r\\n        //IERC721(s.nft).transferFrom(address(this),staker,s.tokenId);\\r\\n        IERC721(s.nft).transferFrom(holderVaults[staker],staker,s.tokenId);\\r\\n    }\\r\\n\\r\\n    function unstakeMultiple(uint256 [] memory stakingIndex) external{\\r\\n        address staker = msg.sender;\\r\\n        uint length = stakingIndex.length;\\r\\n        uint256 harvestPoints;\\r\\n        uint256 stakeEarnings;\\r\\n        UserStake [] memory s;\\r\\n        for(uint i=0;i<length;i++){\\r\\n\\r\\n            s[i] = stakes[staker][stakingIndex[i]];\\r\\n            stakeEarnings = getEarnedPointsFromStake(staker,i);\\r\\n\\r\\n            if(stakeEarnings>0){\\r\\n                _harvestStake(staker, stakingIndex[i], harvestPoints);\\r\\n                harvestPoints += stakeEarnings;\\r\\n            }\\r\\n            //replace current index with half-swap if not last in array\\r\\n            if(stakingIndex[i]!=stakes[staker].length-1){\\r\\n                stakes[staker][stakingIndex[i]]=stakes[staker][stakes[staker].length-1];\\r\\n            }\\r\\n\\r\\n            stakes[staker].pop();\\r\\n            delete stakerOfToken[s[i].nft][s[i].tokenId];\\r\\n\\r\\n            //IERC721(s[i].nft).transferFrom(address(this),staker,s[i].tokenId);\\r\\n            IERC721(s[i].nft).transferFrom(holderVaults[staker],staker,s[i].tokenId);\\r\\n            emit Unstake(staker,s[i].nft,s[i].tokenId);\\r\\n        }\\r\\n\\r\\n        //if user has no more stakes, remove user from staker list\\r\\n        if(stakes[staker].length==0){\\r\\n            if(stakersListIndex[staker]!=stakers.length-1){\\r\\n                stakers[stakersListIndex[staker]]=stakers[stakers.length-1];\\r\\n            }\\r\\n            stakers.pop();\\r\\n        }\\r\\n        \\r\\n        totalStakes -= length;\\r\\n        emit Harvest(staker,harvestPoints);\\r\\n    }\\r\\n\\r\\n    function emergencyUnstake(uint256 stakingIndex) external{\\r\\n        address staker = msg.sender;\\r\\n        UserStake memory s = stakes[staker][stakingIndex];\\r\\n        //remove stake from user's list of stakes\\r\\n        if(stakingIndex!=stakes[staker].length-1){\\r\\n            stakes[staker][stakingIndex]=stakes[staker][stakes[staker].length-1];\\r\\n        }\\r\\n        stakes[staker].pop();\\r\\n\\r\\n        //if user has no more stakes, remove user from staker list\\r\\n        if(stakes[staker].length==0){\\r\\n            if(stakersListIndex[staker]!=stakers.length-1){\\r\\n                stakers[stakersListIndex[staker]]=stakers[stakers.length-1];\\r\\n            }\\r\\n            stakers.pop();\\r\\n        }\\r\\n        totalStakes--;\\r\\n        delete stakerOfToken[s.nft][s.tokenId];\\r\\n        //IERC721(s.nft).transferFrom(address(this),staker,s.tokenId);\\r\\n        IERC721(s.nft).transferFrom(holderVaults[staker],staker,s.tokenId);\\r\\n        emit Unstake(staker,s.nft,s.tokenId);\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InsufficientPointBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStakingEndTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStakingRate_EndSeasonInstead\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"}],\"name\":\"MaxStakingSeasonReached\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"}],\"name\":\"NFTNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"}],\"name\":\"NoActiveStakingSeason\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoChangesMade\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoPointsToHarvest\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NotStaked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"redemptionLocation\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redemptionPointsAmount\",\"type\":\"uint256\"}],\"name\":\"RedemptionFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenIdNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnevenArraySizes\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dailyPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"BeginStakingSeason\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"DisableStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"EnableStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemLocation\",\"type\":\"address\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"location\",\"type\":\"address\"}],\"name\":\"SetRedeemLocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakingSeason\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"SetStakingPercentMultiplier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dailyPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"beginNewStakingSeason\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingIndex\",\"type\":\"uint256\"}],\"name\":\"emergencyUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"}],\"name\":\"endStakingSeason\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccumulatedHarvestedPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccumulatedRedeemedPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllStakers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"staker\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllowednfts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"}],\"name\":\"getCurrentStakingSeasonEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingIndex\",\"type\":\"uint256\"}],\"name\":\"getEarnedPointsFromStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRedeemFunction\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRedeemLocation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getStaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStakerAccumulatedHarvestedPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStakerAccumulatedRedeemedPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStakerUnharvestedPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastHarvestStakingSeasonIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct Interface_Rival_Bears_Staking.UserStake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingSeasonIndex\",\"type\":\"uint256\"}],\"name\":\"getStakingPercentMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nft\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakingSeasonIndex\",\"type\":\"uint256[]\"}],\"name\":\"getStakingPercentMultiplierMultiple\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"}],\"name\":\"getStakingSeason\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingSeasonIndex\",\"type\":\"uint256\"}],\"name\":\"getStakingSeasonEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestAllStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingIndex\",\"type\":\"uint256\"}],\"name\":\"harvestStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_points\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_redeemFunction\",\"type\":\"string\"}],\"name\":\"setRedeemFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_redeemLocation\",\"type\":\"address\"}],\"name\":\"setRedeemLocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingPercentMultiplier\",\"type\":\"uint256\"}],\"name\":\"setStakingPercentMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nft\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakingPercentMultiplier\",\"type\":\"uint256[]\"}],\"name\":\"setStakingPercentMultiplierMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"setTokenStakingDisabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nft\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"setTokenStakingDisabledMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nft\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"}],\"name\":\"stakeMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnershipRedeemLocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingIndex\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"stakingIndex\",\"type\":\"uint256[]\"}],\"name\":\"unstakeMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"updateStakingSeasonEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Rival_Bears_Staking", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}