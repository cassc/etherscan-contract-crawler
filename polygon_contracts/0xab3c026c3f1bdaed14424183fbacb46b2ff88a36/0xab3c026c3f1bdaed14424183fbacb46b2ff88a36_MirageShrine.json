{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\r\n      \"keccak256\": \"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\r\n      \"keccak256\": \"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\"\r\n    },\r\n    \"@reality.eth/contracts/development/contracts/IBalanceHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.10;\\n\\ninterface IBalanceHolder {\\n  function withdraw (  ) external;\\n  function balanceOf ( address ) external view returns ( uint256 );\\n}\\n\",\r\n      \"keccak256\": \"0x2a92823fd5f205d47e5f1b7a5945dade130a31c8ac6ae8d218b1715ed2213518\"\r\n    },\r\n    \"@reality.eth/contracts/development/contracts/IRealityETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.10;\\n\\nimport './IBalanceHolder.sol';\\n\\ninterface IRealityETH is IBalanceHolder {\\n     event LogAnswerReveal (bytes32 indexed question_id, address indexed user, bytes32 indexed answer_hash, bytes32 answer, uint256 nonce, uint256 bond);\\n     event LogCancelArbitration (bytes32 indexed question_id);\\n     event LogClaim (bytes32 indexed question_id, address indexed user, uint256 amount);\\n     event LogFinalize (bytes32 indexed question_id, bytes32 indexed answer);\\n     event LogFundAnswerBounty (bytes32 indexed question_id, uint256 bounty_added, uint256 bounty, address indexed user);\\n     event LogMinimumBond (bytes32 indexed question_id, uint256 min_bond);\\n     event LogNewAnswer (bytes32 answer, bytes32 indexed question_id, bytes32 history_hash, address indexed user, uint256 bond, uint256 ts, bool is_commitment);\\n     event LogNewQuestion (bytes32 indexed question_id, address indexed user, uint256 template_id, string question, bytes32 indexed content_hash, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 created);\\n     event LogNewTemplate (uint256 indexed template_id, address indexed user, string question_text);\\n     event LogNotifyOfArbitrationRequest (bytes32 indexed question_id, address indexed user);\\n     event LogReopenQuestion (bytes32 indexed question_id, bytes32 indexed reopened_question_id);\\n     event LogSetQuestionFee (address arbitrator, uint256 amount);\\n\\n     function assignWinnerAndSubmitAnswerByArbitrator (bytes32 question_id, bytes32 answer, address payee_if_wrong, bytes32 last_history_hash, bytes32 last_answer_or_commitment_id, address last_answerer) external;\\n     function cancelArbitration (bytes32 question_id) external;\\n     function claimMultipleAndWithdrawBalance (bytes32[] calldata question_ids, uint256[] calldata lengths, bytes32[] calldata hist_hashes, address[] calldata addrs, uint256[] calldata bonds, bytes32[] calldata answers) external;\\n     function claimWinnings (bytes32 question_id, bytes32[] calldata history_hashes, address[] calldata addrs, uint256[] calldata bonds, bytes32[] calldata answers) external;\\n     function createTemplate (string calldata content) external returns (uint256);\\n     function notifyOfArbitrationRequest (bytes32 question_id, address requester, uint256 max_previous) external;\\n     function setQuestionFee (uint256 fee) external;\\n     function submitAnswerByArbitrator (bytes32 question_id, bytes32 answer, address answerer) external;\\n     function submitAnswerReveal (bytes32 question_id, bytes32 answer, uint256 nonce, uint256 bond) external;\\n     function askQuestion (uint256 template_id, string calldata question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce) external payable returns (bytes32);\\n     function askQuestionWithMinBond (uint256 template_id, string calldata question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 min_bond) external payable returns (bytes32);\\n     function createTemplateAndAskQuestion (string calldata content, string calldata question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce) external payable returns (bytes32);\\n     function fundAnswerBounty (bytes32 question_id) external payable;\\n     function reopenQuestion (uint256 template_id, string calldata question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 min_bond, bytes32 reopens_question_id) external payable returns (bytes32);\\n     function submitAnswer (bytes32 question_id, bytes32 answer, uint256 max_previous) external payable;\\n     function submitAnswerCommitment (bytes32 question_id, bytes32 answer_hash, uint256 max_previous, address _answerer) external payable;\\n     function submitAnswerFor (bytes32 question_id, bytes32 answer, uint256 max_previous, address answerer) external payable;\\n     function arbitrator_question_fees (address) external view returns (uint256);\\n     function commitments (bytes32) external view returns (uint32 reveal_ts, bool is_revealed, bytes32 revealed_answer);\\n     function getArbitrator (bytes32 question_id) external view returns (address);\\n     function getBestAnswer (bytes32 question_id) external view returns (bytes32);\\n     function getBond (bytes32 question_id) external view returns (uint256);\\n     function getBounty (bytes32 question_id) external view returns (uint256);\\n     function getContentHash (bytes32 question_id) external view returns (bytes32);\\n     function getFinalAnswer (bytes32 question_id) external view returns (bytes32);\\n     function getFinalAnswerIfMatches (bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond) external view returns (bytes32);\\n     function getFinalizeTS (bytes32 question_id) external view returns (uint32);\\n     function getHistoryHash (bytes32 question_id) external view returns (bytes32);\\n     function getMinBond (bytes32 question_id) external view returns (uint256);\\n     function getOpeningTS (bytes32 question_id) external view returns (uint32);\\n     function getTimeout (bytes32 question_id) external view returns (uint32);\\n     function isFinalized (bytes32 question_id) external view returns (bool);\\n     function isPendingArbitration (bytes32 question_id) external view returns (bool);\\n     function isSettledTooSoon (bytes32 question_id) external view returns (bool);\\n     function question_claims (bytes32) external view returns (address payee, uint256 last_bond, uint256 queued_funds);\\n     function questions (bytes32) external view returns (bytes32 content_hash, address arbitrator, uint32 opening_ts, uint32 timeout, uint32 finalize_ts, bool is_pending_arbitration, uint256 bounty, bytes32 best_answer, bytes32 history_hash, uint256 bond, uint256 min_bond);\\n     function reopened_questions (bytes32) external view returns (bytes32);\\n     function reopener_questions (bytes32) external view returns (bool);\\n     function resultFor (bytes32 question_id) external view returns (bytes32);\\n     function resultForOnceSettled (bytes32 question_id) external view returns (bytes32);\\n     function template_hashes (uint256) external view returns (bytes32);\\n     function templates (uint256) external view returns (uint256);\\n}\\n\",\r\n      \"keccak256\": \"0xfe0466173eb5a3f2a5dc6a9520dd21cfe3497b8b9c189de356dbea7e5ade73e0\"\r\n    },\r\n    \"contracts/Fate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Mirage Shrine Vow\\n\\n// This scroll grants you the power to wield this creation as you see fit.\\n// Be warned, the winds of fate may turn against those who misuse it.\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"./MirageShrine.sol\\\";\\nimport \\\"./Stringer.sol\\\";\\n\\ncontract Fate is IERC20Metadata {\\n    struct Info {\\n        bytes23 rune;\\n        uint64 prophecyId;\\n        bool yes;\\n    }\\n\\n    MirageShrine immutable public SHRINE;\\n    address constant internal PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n    Info public info;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) internal allowanceOf;\\n\\n    modifier onlyShrine {\\n        require(msg.sender == address(SHRINE), \\\"Begone, unholy spirits\\\");\\n        _;\\n    }\\n\\n    constructor (MirageShrine shrine) {\\n        SHRINE = shrine;\\n    }\\n\\n    // Have faith in the Shrine. Names are powerful things.\\n    function initialize(bytes23 rune, uint64 id, bool yes) external onlyShrine {\\n        info.rune = rune;\\n        info.prophecyId = id;\\n        info.yes = yes;\\n    }\\n\\n    // Fate will lose count when the time comes.\\n    function totalSupply() external view returns (uint256) {\\n        (, , , , , uint256 supply,) = SHRINE.prophecies(info.prophecyId);\\n        return (supply);\\n    }\\n\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        allowanceOf[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return (true);\\n    }\\n\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        if (spender == PERMIT2) {\\n            return (type(uint256).max);\\n        } else {\\n            return (allowanceOf[owner][spender]);\\n        }\\n    }\\n\\n    function transfer(address to, uint256 amount) external returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n        balanceOf[to] += amount;\\n        emit Transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\\n        if (msg.sender != PERMIT2) {\\n            allowanceOf[from][msg.sender] -= amount;\\n        }\\n        balanceOf[from] -= amount;\\n        balanceOf[to] += amount;\\n        emit Transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    // Let the different realms flourish.\\n    function mint(address to, uint256 amount) external onlyShrine {\\n        balanceOf[to] += amount;\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    // Crystallize, become matter!\\n    function burn(address from, uint256 amount) external onlyShrine {\\n        balanceOf[from] -= amount;\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    function decimals() external view returns(uint8) {\\n        (IERC20Metadata essence, , , , , ,) = SHRINE.prophecies(info.prophecyId);\\n        return essence.decimals();\\n    }\\n\\n    // YES Lemon Fate\\n    // NO Lemon Fate\\n    function name() public view returns(string memory) {\\n        return string(abi.encodePacked(\\n            info.yes ? \\\"YES\\\" : \\\"NO\\\",\\n            Stringer.bytes23ToString(info.rune),\\n            \\\" Fate\\\"\\n        ));\\n    }\\n\\n    // Y:Lemon=WETH\\n    // N:Lemon=WETH\\n    function symbol() external view returns(string memory) {\\n        (IERC20Metadata essence, , , , , ,) = SHRINE.prophecies(info.prophecyId);\\n        return string(abi.encodePacked(\\n            info.yes ? \\\"Y:\\\" : \\\"N:\\\",\\n            Stringer.bytes23ToString(bytes23(bytes6(info.rune))),\\n            \\\"=\\\",\\n            essence.symbol()\\n        ));\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x0990c4fccb4c0709b2f55dc15025dba5a3c018b04bf435e27be4707a6ec7f449\"\r\n    },\r\n    \"contracts/MirageShrine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Mirage Shrine Vow\\n\\n// This scroll grants you the power to wield this creation as you see fit.\\n// Be warned, the winds of fate may turn against those who misuse it.\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@reality.eth/contracts/development/contracts/IRealityETH.sol\\\";\\nimport \\\"./Fate.sol\\\";\\n\\ncontract MirageShrine {\\n\\n    enum Aura {\\n        Forthcoming,\\n        Blighted,\\n        Reality,\\n        Mirage\\n    }\\n\\n    struct Prophecy {\\n        IERC20Metadata essence;\\n        uint32 horizon;\\n        Aura aura;\\n        //\\n        Fate no;\\n        //\\n        Fate yes;\\n        //\\n        uint256 fateSupply;\\n        //\\n        bytes32 inquiryId;\\n    }\\n\\n    event Offering(address donor, uint256 amount);\\n    // Prophecy data is meant to remain, no need to proclaim it.\\n    event Scry(uint64 indexed prophecyId, address indexed essence);\\n    // No utility has been found in celebrating distillments and blendings.\\n    // The shrine does not indulge in vanity. \\n    event Emergence(uint64 indexed prophecyId, Aura indexed aura);\\n\\n    address immutable mirager;\\n    address immutable fateMonument;\\n    IRealityETH immutable reality;\\n    uint256 immutable templateId;\\n    uint256 immutable tribute;\\n    uint256 immutable minBond;\\n    address immutable arbitrator;\\n\\n    bytes32 constant NO = 0x0000000000000000000000000000000000000000000000000000000000000000;\\n    bytes32 constant YES = 0x0000000000000000000000000000000000000000000000000000000000000001;\\n\\n    Prophecy[] public prophecies;\\n\\n    constructor (IRealityETH _reality, address _fateMonument, uint256 _templateId, address _arbitrator,  uint256 _tribute, uint256 _minBond) {\\n        mirager = msg.sender;\\n        reality = _reality;\\n        fateMonument = _fateMonument;\\n        templateId = _templateId;\\n        arbitrator = _arbitrator;\\n        tribute = _tribute;\\n        minBond = _minBond;\\n    }\\n\\n    receive() external payable {\\n        emit Offering(msg.sender, msg.value);\\n    }\\n\\n    function relayOffering() external {\\n        payable(mirager).transfer(address(this).balance);\\n    }\\n\\n    function deployFate() internal returns (address result) {\\n        bytes20 fateAt = bytes20(fateMonument);\\n        assembly (\\\"memory-safe\\\") {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(clone, 0x14), fateAt)\\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            result := create(0, clone, 0x37)\\n        }\\n    }\\n\\n    function scry(uint32 _horizon, IERC20Metadata _essence, bytes23 _rune, string calldata _inquiry) external payable returns (uint64 id) {\\n        require(msg.value >= tribute, \\\"Leave a coin to honor the divine\\\");\\n        emit Offering(msg.sender, msg.value);\\n        require(block.timestamp < _horizon);\\n        id = uint64(prophecies.length);\\n        emit Scry(id, address(_essence));\\n    \\n        Prophecy storage prophecy = prophecies.push();\\n        prophecy.essence = _essence;\\n        prophecy.horizon = _horizon;\\n        prophecy.inquiryId = reality.askQuestionWithMinBond(\\n            templateId,\\n            _inquiry,\\n            arbitrator,\\n            2 days,\\n            _horizon,\\n            0,\\n            minBond\\n        );\\n\\n        // deploying minimal proxy is ~40k.\\n        prophecy.yes = Fate(deployFate());\\n        // initializing is ~20k (+ delegate)\\n        prophecy.yes.initialize(_rune, id, true);\\n        prophecy.no = Fate(deployFate());\\n        prophecy.no.initialize(_rune, id, false);\\n    }\\n\\n    function distill(uint64 _prophecy, uint256 _amount) external {\\n        Prophecy storage prophecy = prophecies[_prophecy];\\n        require(prophecy.essence.transferFrom(msg.sender, address(this), _amount));\\n        require(block.timestamp < prophecy.horizon, \\\"Alas! The essence defied decouplement!\\\");\\n\\n        prophecy.yes.mint(msg.sender, _amount);\\n        prophecy.no.mint(msg.sender, _amount);\\n        prophecy.fateSupply += _amount;\\n    }\\n\\n    function blend(uint64 _prophecy, uint256 _amount) external {\\n        Prophecy storage prophecy = prophecies[_prophecy];\\n        require(block.timestamp < prophecy.horizon, \\\"The fates repel each other!\\\");\\n\\n        prophecy.yes.burn(msg.sender, _amount);\\n        prophecy.no.burn(msg.sender, _amount);\\n\\n        prophecy.essence.transfer(msg.sender, _amount);\\n        prophecy.fateSupply -= _amount;\\n    }\\n\\n    function ascend(uint64 _prophecy) external {\\n        Prophecy storage prophecy = prophecies[_prophecy];\\n        if (prophecy.aura == Aura.Forthcoming) {\\n            // If truth has not arrived, halt!\\n            bytes32 truth = reality.resultFor(prophecy.inquiryId);\\n\\n            if (truth == NO) {\\n                // Destiny is elusive.\\n                prophecy.aura = Aura.Mirage;\\n            } else if (truth == YES) {\\n                // As predicted by the Shrine.\\n                prophecy.aura = Aura.Reality;\\n            } else {\\n                // Fool! You were told not to bring certainty to the profane.\\n                prophecy.aura = Aura.Blighted;\\n                prophecy.essence.transfer(mirager, prophecy.fateSupply);\\n            }\\n            emit Emergence(_prophecy, prophecy.aura);\\n            if (prophecy.aura == Aura.Blighted) return();\\n        }\\n        \\n        Fate fate;\\n        if (prophecy.aura == Aura.Mirage) {\\n            fate = prophecy.no;\\n        } else if (prophecy.aura == Aura.Reality) {\\n            fate = prophecy.yes;\\n        } else {\\n            // Depart from this holy site.\\n            revert();\\n        }\\n\\n        uint256 grace = fate.balanceOf(msg.sender);\\n        fate.burn(msg.sender, grace);\\n        prophecy.essence.transfer(msg.sender, grace);\\n    }\\n\\n    function count() external view returns(uint256) {\\n        return prophecies.length;\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x6b58927d160f8210cdcb7fff116c7ab7ae9d91bc450fe3b2da39ff222a2e5454\"\r\n    },\r\n    \"contracts/Stringer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Mirage Shrine Vow\\n\\n// This scroll grants you the power to wield this creation as you see fit.\\n// Be warned, the winds of fate may turn against those who misuse it.\\n\\npragma solidity ^0.8.19;\\n\\nlibrary Stringer {\\n    function bytes23ToString(bytes23 _x) internal pure returns (string memory) {\\n        unchecked {\\n            bytes memory bytesString = new bytes(23);\\n            uint charCount = 0;\\n            for (uint j = 0; j < 23; j++) {\\n                bytes1 currentChar = bytes1(_x << (8 * j));\\n                if (currentChar != 0) {\\n                    bytesString[charCount] = currentChar;\\n                    charCount++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            bytes memory bytesStringTrimmed = new bytes(charCount);\\n            for (uint j = 0; j < charCount; j++) {\\n                bytesStringTrimmed[j] = bytesString[j];\\n            }\\n            return string(bytesStringTrimmed);\\n        }\\n    }\\n}\",\r\n      \"keccak256\": \"0xcb893e9aa79b9d14ad1873a136c8c32cd186913b6b731c3345ad235aab406b76\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IRealityETH\",\"name\":\"_reality\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fateMonument\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_templateId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tribute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBond\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"prophecyId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"enum MirageShrine.Aura\",\"name\":\"aura\",\"type\":\"uint8\"}],\"name\":\"Emergence\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"donor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Offering\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"prophecyId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"essence\",\"type\":\"address\"}],\"name\":\"Scry\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_prophecy\",\"type\":\"uint64\"}],\"name\":\"ascend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_prophecy\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"blend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_prophecy\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"distill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prophecies\",\"outputs\":[{\"internalType\":\"contract IERC20Metadata\",\"name\":\"essence\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"horizon\",\"type\":\"uint32\"},{\"internalType\":\"enum MirageShrine.Aura\",\"name\":\"aura\",\"type\":\"uint8\"},{\"internalType\":\"contract Fate\",\"name\":\"no\",\"type\":\"address\"},{\"internalType\":\"contract Fate\",\"name\":\"yes\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fateSupply\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"inquiryId\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayOffering\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_horizon\",\"type\":\"uint32\"},{\"internalType\":\"contract IERC20Metadata\",\"name\":\"_essence\",\"type\":\"address\"},{\"internalType\":\"bytes23\",\"name\":\"_rune\",\"type\":\"bytes23\"},{\"internalType\":\"string\",\"name\":\"_inquiry\",\"type\":\"string\"}],\"name\":\"scry\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MirageShrine", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000060573b8dce539ae5bf9ad7932310668997ef04280000000000000000000000003dcec2e2208158e9e18726e04c84c81758f8bf7900000000000000000000000000000000000000000000000000000000000000610000000000000000000000005afa42b30955f137e10f89dfb5ef1542a186f90e0000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000001bc16d674ec80000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f06948b3437e7471ab9f4ce988b0c4d1cd4e3d0ef9ef430e4bbde1628915c2f9"}