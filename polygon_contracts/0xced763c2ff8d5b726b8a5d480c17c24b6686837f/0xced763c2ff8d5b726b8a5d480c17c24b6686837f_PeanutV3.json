{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"PeanutV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n//////////////////////////////////////////////////////////////////////////////////////\\n// @title   Peanut Protocol\\n// @notice  This contract is used to send non front-runnable link payments. These can\\n//          be erc20, erc721, erc1155 or just plain eth. The recipient address is arbitrary.\\n//          Links use asymmetric ECDSA encryption by default to be secure & enable trustless,\\n//          gasless claiming.\\n//          more at: https://peanut.to\\n// @version 0.3\\n// @author  H & K\\n//////////////////////////////////////////////////////////////////////////////////////\\n//\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n//                         \u2800\u2800\u2880\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28c0\u28e4\u28f6\u28f6\u28e6\u28cc\u2819\u280b\u28a1\u28f4\u28f6\u2844\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u2800\u28ff\u28ff\u28ff\u287f\u288b\u28e0\u28f6\u28f6\u284c\u283b\u28ff\u281f\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u2846\u2838\u281f\u2881\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u2866\u2809\u28f4\u2847\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u281f\u2800\u2830\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u28e0\u2844\u2839\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2840\u28b8\u287f\u288b\u28e4\u28ff\u28c4\u2819\u28ff\u28ff\u287f\u281f\u28e1\u28fe\u28ff\u28ff\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28e0\u28f4\u28fe\u283f\u2800\u28a0\u28fe\u28ff\u28ff\u28ff\u28e6\u2808\u2809\u28a0\u28fe\u28ff\u28ff\u28ff\u280f\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u28c0\u28e4\u28e6\u28c4\u2819\u280b\u28e0\u28f4\u28ff\u28ff\u28ff\u28ff\u283f\u281b\u2881\u28f4\u28e6\u2844\u2819\u281b\u280b\u2801\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2880\u28fe\u28ff\u28ff\u281f\u2881\u28f4\u28e6\u2848\u283b\u28ff\u28ff\u287f\u2801\u2840\u281a\u281b\u2809\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2818\u28ff\u281f\u2881\u28f4\u28ff\u28ff\u28ff\u28ff\u28e6\u2848\u281b\u2881\u28fc\u285f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u28b0\u2866\u2800\u28b4\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u2880\u2818\u283f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2818\u2880\u28f6\u2840\u283b\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28e0\u28ff\u28f7\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u28bf\u28ff\u28ff\u28e6\u2848\u283b\u28ff\u281f\u2881\u28fc\u28ff\u28ff\u281f\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2808\u283b\u28ff\u28ff\u28ff\u2816\u2880\u2810\u283f\u281f\u280b\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\\n// \u2800\u2800\u2800\u2800\u2808\u2809\u2801\u2800\u2800\u2800\u2800\u2800\\n//\\n//////////////////////////////////////////////////////////////////////////////////////\\n\\n// imports\\nimport \\\"ECDSA.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IERC721.sol\\\";\\nimport \\\"IERC721Receiver.sol\\\";\\nimport \\\"IERC1155.sol\\\";\\nimport \\\"IERC1155Receiver.sol\\\";\\n\\ncontract PeanutV3 is IERC721Receiver, IERC1155Receiver {\\n    struct deposit {\\n        address pubKey20; // last 20 bytes of the hash of the public key for the deposit\\n        uint256 amount; // amount of the asset being sent\\n        address tokenAddress; // address of the asset being sent. 0x0 for eth\\n        uint8 contractType; // 0 for eth, 1 for erc20, 2 for erc721, 3 for erc1155\\n        uint256 tokenId; // id of the token being sent (if erc721 or erc1155)\\n        // TODO: Can also potentially add link time expiry here. Future approach.\\n    }\\n\\n    deposit[] public deposits; // array of deposits\\n\\n    // events\\n    event DepositEvent(\\n        uint256 _index,\\n        uint8 _contractType,\\n        uint256 _amount,\\n        address indexed _senderAddress\\n    );\\n    event WithdrawEvent(\\n        uint256 _index,\\n        uint8 _contractType,\\n        uint256 _amount,\\n        address indexed _recipientAddress\\n    );\\n    event MessageEvent(string message);\\n\\n    // constructor\\n    constructor() {\\n        emit MessageEvent(\\\"Hello World, have a nutty day!\\\");\\n    }\\n\\n    /**\\n        @notice supportsInterface function\\n        @dev ERC165 interface detection\\n        @param _interfaceId bytes4 the interface identifier, as specified in ERC-165\\n        @return bool true if the contract implements the interface specified in _interfaceId\\n     */\\n    function supportsInterface(bytes4 _interfaceId)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return\\n            _interfaceId == type(IERC165).interfaceId ||\\n            _interfaceId == type(IERC721Receiver).interfaceId ||\\n            _interfaceId == type(IERC1155Receiver).interfaceId;\\n    }\\n\\n    /**\\n     * @notice Function to make a deposit\\n     * @dev For token deposits, allowance must be set before calling this function\\n     * @param _tokenAddress address of the token being sent. 0x0 for eth\\n     * @param _contractType uint8 for the type of contract being sent. 0 for eth, 1 for erc20, 2 for erc721, 3 for erc1155\\n     * @param _amount uint256 of the amount of tokens being sent (if erc20)\\n     * @param _tokenId uint256 of the id of the token being sent if erc721 or erc1155\\n     * @param _pubKey20 last 20 bytes of the public key of the deposit signer\\n     * @return uint256 index of the deposit\\n     */\\n    function makeDeposit(\\n        address _tokenAddress,\\n        uint8 _contractType,\\n        uint256 _amount,\\n        uint256 _tokenId,\\n        address _pubKey20\\n    ) external payable returns (uint256) {\\n        // check that the contract type is valid\\n        require(_contractType < 4, \\\"INVALID CONTRACT TYPE\\\");\\n\\n        // handle deposit types\\n        if (_contractType == 0) {\\n            // check that the amount sent is equal to the amount being deposited\\n            require(msg.value > 0, \\\"NO ETH SENT\\\");\\n            // override amount with msg.value\\n            _amount = msg.value;\\n        } else if (_contractType == 1) {\\n            // REMINDER: User must approve this contract to spend the tokens before calling this function\\n            // Unfortunately there's no way of doing this in just one transaction.\\n            // Wallet abstraction pls\\n\\n            IERC20 token = IERC20(_tokenAddress);\\n\\n            // require users token balance to be greater than or equal to the amount being deposited\\n            require(\\n                token.balanceOf(msg.sender) >= _amount,\\n                \\\"INSUFFICIENT TOKEN BALANCE\\\"\\n            );\\n\\n            // require allowance to be at least the amount being deposited\\n            require(\\n                token.allowance(msg.sender, address(this)) >= _amount,\\n                \\\"INSUFFICIENT ALLOWANCE\\\"\\n            );\\n\\n            // transfer the tokens to the contract\\n            require(\\n                token.transferFrom(msg.sender, address(this), _amount),\\n                \\\"TRANSFER FAILED. CHECK ALLOWANCE & BALANCE\\\"\\n            );\\n        } else if (_contractType == 2) {\\n            // REMINDER: User must approve this contract to spend the tokens before calling this function.\\n            // alternatively, the user can call the safeTransferFrom function directly and append the appropriate calldata\\n\\n            IERC721 token = IERC721(_tokenAddress);\\n            // require(token.ownerOf(_tokenId) == msg.sender, \\\"Invalid token id\\\");\\n            token.safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                _tokenId,\\n                \\\"Internal transfer\\\"\\n            );\\n        } else if (_contractType == 3) {\\n            // REMINDER: User must approve this contract to spend the tokens before calling this function.\\n            // alternatively, the user can call the safeTransferFrom function directly and append the appropriate calldata\\n\\n            IERC1155 token = IERC1155(_tokenAddress);\\n            token.safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                _tokenId,\\n                _amount,\\n                \\\"Internal transfer\\\"\\n            );\\n        }\\n\\n        // create deposit\\n        deposits.push(\\n            deposit({\\n                tokenAddress: _tokenAddress,\\n                contractType: _contractType,\\n                amount: _amount,\\n                tokenId: _tokenId,\\n                pubKey20: _pubKey20\\n            })\\n        );\\n\\n        // emit the deposit event\\n        emit DepositEvent(\\n            deposits.length - 1,\\n            _contractType,\\n            _amount,\\n            msg.sender\\n        );\\n\\n        // return id of new deposit\\n        return deposits.length - 1;\\n    }\\n\\n    /**\\n     * @notice Erc721 token receiver function\\n     * @dev These functions are called by the token contracts when a token is sent to this contract\\n     * @dev If calldata is \\\"Internal transfer\\\" then the token was sent by this contract and we don't need to do anything\\n     * @dev Otherwise, calldata needs a 20 byte pubkey20\\n     * @param _operator address operator requesting the transfer\\n     * @param _from address address which previously owned the token\\n     * @param _tokenId uint256 ID of the token being transferred\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    function onERC721Received(\\n        address _operator,\\n        address _from,\\n        uint256 _tokenId,\\n        bytes calldata _data\\n    ) external override returns (bytes4) {\\n        if (keccak256(_data) == keccak256(\\\"Internal transfer\\\")) {\\n            // if data is \\\"Internal transfer\\\", nothing to do, return\\n            return this.onERC721Received.selector;\\n        } else if (_data.length != 20) {\\n            // if data is not 20 bytes, revert (don't want to accept and lock up tokens!)\\n            revert(\\\"INVALID CALLDATA\\\");\\n        }\\n\\n        // get the params from calldata and make a deposit\\n        address _tokenAddress = msg.sender;\\n        uint8 _contractType = 2;\\n        uint256 _amount = 1;\\n        address _pubKey20 = abi.decode(_data, (address));\\n\\n        // create deposit\\n        deposits.push(\\n            deposit({\\n                tokenAddress: _tokenAddress,\\n                contractType: _contractType,\\n                amount: _amount,\\n                tokenId: _tokenId,\\n                pubKey20: _pubKey20\\n            })\\n        );\\n\\n        // emit the deposit event\\n        emit DepositEvent(\\n            deposits.length - 1,\\n            _contractType,\\n            _amount,\\n            _operator\\n        );\\n\\n        // return correct bytes4\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /**\\n        @notice Erc1155 token receiver function\\n        @dev These functions are called by the token contracts when a token is sent to this contract\\n        @dev If calldata is \\\"Internal transfer\\\" then the token was sent by this contract and we don't need to do anything\\n        @dev Otherwise, calldata needs 20 bytes pubKey20\\n        @param _operator address operator requesting the transfer\\n        @param _from address address which previously owned the token\\n        @param _tokenId uint256 ID of the token being transferred\\n        @param _value uint256 amount of tokens being transferred\\n        @param _data bytes data passed with the call\\n     */\\n    function onERC1155Received(\\n        address _operator,\\n        address _from,\\n        uint256 _tokenId,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external override returns (bytes4) {\\n        if (keccak256(_data) == keccak256(\\\"Internal transfer\\\")) {\\n            // if data is \\\"Internal transfer\\\", nothing to do, return\\n            return this.onERC1155Received.selector;\\n        } else if (_data.length != 20) {\\n            // if data is not 20 bytes, revert (don't want to accept and lock up tokens!)\\n            revert(\\\"INVALID CALLDATA\\\");\\n        }\\n\\n        // get the params from calldata and make a deposit\\n        address _tokenAddress = msg.sender;\\n        uint8 _contractType = 3;\\n        uint256 _amount = _value;\\n        address _pubKey20;\\n        _pubKey20 = abi.decode(_data, (address));\\n\\n        // create deposit\\n        deposits.push(\\n            deposit({\\n                tokenAddress: _tokenAddress,\\n                contractType: _contractType,\\n                amount: _amount,\\n                tokenId: _tokenId,\\n                pubKey20: _pubKey20\\n            })\\n        );\\n\\n        // emit the deposit event\\n        emit DepositEvent(deposits.length - 1, _contractType, _amount, _from);\\n\\n        // return correct bytes4\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    /**\\n     * @notice Erc1155 token receiver function\\n     * @dev These functions are called by the token contracts when a set of tokens is sent to this contract\\n     * @dev If calldata is \\\"Internal transfer\\\" then the token was sent by this contract and we don't need to do anything\\n     * @param _operator address operator requesting the transfer\\n     * @param _from address address which previously owned the token\\n     * @param _ids uint256[] IDs of each token being transferred (order and length must match _values array)\\n     * @param _values uint256[] amount of each token being transferred (order and length must match _ids array)\\n     * @param _data bytes data forwarded from the caller\\n     * @dev _data needs to contain array of 20 byte pubKey20s (length must match _ids and _values arrays)\\n     */\\n    function onERC1155BatchReceived(\\n        address _operator,\\n        address _from,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _values,\\n        bytes calldata _data\\n    ) external override returns (bytes4) {\\n        if (keccak256(_data) == keccak256(\\\"Internal transfer\\\")) {\\n            // if data is \\\"Internal transfer\\\", nothing to do, return\\n            return this.onERC1155BatchReceived.selector;\\n        } else if (_data.length != (_ids.length * 20)) {\\n            // dont accept if data is not 20 bytes per token\\n            revert(\\\"INVALID CALLDATA\\\");\\n        }\\n\\n        // get the params from calldata and make a deposit\\n        address _tokenAddress = msg.sender;\\n        uint8 _contractType = 4;\\n        address _pubKey20;\\n        uint256 _amount;\\n        uint256 _tokenId;\\n\\n        for (uint256 i = 0; i < _ids.length; i++) {\\n            _amount = _values[i];\\n            _tokenId = _ids[i];\\n            uint256 _offset = i * 20;\\n            bytes memory _pubKey20Bytes = new bytes(20);\\n            for (uint256 j = 0; j < 20; j++) {\\n                _pubKey20Bytes[j] = _data[_offset + j];\\n            }\\n            _pubKey20 = abi.decode(_pubKey20Bytes, (address));\\n\\n            // create deposit\\n            deposits.push(\\n                deposit({\\n                    tokenAddress: _tokenAddress,\\n                    contractType: _contractType,\\n                    amount: _amount,\\n                    tokenId: _tokenId,\\n                    pubKey20: _pubKey20\\n                })\\n            );\\n\\n            // emit the deposit event\\n            emit DepositEvent(\\n                deposits.length - 1,\\n                _contractType,\\n                _amount,\\n                _from\\n            );\\n        }\\n\\n        // return correct bytes4\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    /**\\n     * @notice Function to withdraw a deposit. Withdraws the deposit to the recipient address.\\n     * @dev _recipientAddressHash is hash(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\" + hash(_recipientAddress))\\n     * @dev The signature should be signed with the private key corresponding to the public key stored in the deposit\\n     * @dev We don't check the unhashed address for security reasons. It's preferable to sign a hash of the address.\\n     * @param _index uint256 index of the deposit\\n     * @param _recipientAddress address of the recipient\\n     * @param _recipientAddressHash bytes32 hash of the recipient address (prefixed with \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n     * @param _signature bytes signature of the recipient address (65 bytes)\\n     * @return bool true if successful\\n     */\\n    function withdrawDeposit(\\n        uint256 _index,\\n        address _recipientAddress,\\n        bytes32 _recipientAddressHash,\\n        bytes memory _signature\\n    ) external returns (bool) {\\n        // check that the deposit exists and that it isn't already withdrawn\\n        require(_index < deposits.length, \\\"DEPOSIT INDEX DOES NOT EXIST\\\");\\n        require(deposits[_index].amount > 0, \\\"DEPOSIT ALREADY WITHDRAWN\\\");\\n        // check that the recipientAddress hashes to the same value as recipientAddressHash\\n        require(\\n            _recipientAddressHash ==\\n                ECDSA.toEthSignedMessageHash(\\n                    keccak256(abi.encodePacked(_recipientAddress))\\n                ),\\n            \\\"HASHES DO NOT MATCH\\\"\\n        );\\n        // check that the signer is the same as the one stored in the deposit\\n        address depositSigner = getSigner(_recipientAddressHash, _signature);\\n        require(depositSigner == deposits[_index].pubKey20, \\\"WRONG SIGNATURE\\\");\\n\\n        // Deposit request is valid. Withdraw the deposit to the recipient address.\\n        if (deposits[_index].contractType == 0) {\\n            /// handle eth deposits\\n            payable(_recipientAddress).transfer(deposits[_index].amount);\\n        } else if (deposits[_index].contractType == 1) {\\n            /// handle erc20 deposits\\n            IERC20 token = IERC20(deposits[_index].tokenAddress);\\n            token.transfer(_recipientAddress, deposits[_index].amount);\\n        } else if (deposits[_index].contractType == 2) {\\n            /// handle erc721 deposits\\n            IERC721 token = IERC721(deposits[_index].tokenAddress);\\n            token.transferFrom(\\n                address(this),\\n                _recipientAddress,\\n                deposits[_index].tokenId\\n            );\\n        } else if (deposits[_index].contractType == 3) {\\n            /// handle erc1155 deposits\\n            IERC1155 token = IERC1155(deposits[_index].tokenAddress);\\n            token.safeTransferFrom(\\n                address(this),\\n                _recipientAddress,\\n                deposits[_index].tokenId,\\n                deposits[_index].amount,\\n                \\\"\\\"\\n            );\\n        }\\n\\n        // emit the withdraw event\\n        emit WithdrawEvent(\\n            _index,\\n            deposits[_index].contractType,\\n            deposits[_index].amount,\\n            _recipientAddress\\n        );\\n\\n        // delete the deposit\\n        delete deposits[_index];\\n\\n        return true;\\n    }\\n\\n    //// Some utility functions ////\\n\\n    /**\\n     * @notice Gets the signer of a messageHash. Used for signature verification.\\n     * @dev Uses ECDSA.recover. On Frontend, use secp256k1 to sign the messageHash\\n     * @dev also remember to prepend the messageHash with \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\"\\n     * @param messageHash bytes32 hash of the message\\n     * @param signature bytes signature of the message\\n     * @return address of the signer\\n     */\\n    function getSigner(bytes32 messageHash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        address signer = ECDSA.recover(messageHash, signature);\\n        return signer;\\n    }\\n\\n    /**\\n     * @notice Simple way to get the total number of deposits\\n     * @return uint256 number of deposits\\n     */\\n    function getDepositCount() external view returns (uint256) {\\n        return deposits.length;\\n    }\\n\\n    // and that's all! Have a nutty day!\\n}\\n\"\r\n    },\r\n    \"ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"PeanutV3.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_contractType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_senderAddress\",\"type\":\"address\"}],\"name\":\"DepositEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"MessageEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_contractType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_recipientAddress\",\"type\":\"address\"}],\"name\":\"WithdrawEvent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pubKey20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_contractType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_pubKey20\",\"type\":\"address\"}],\"name\":\"makeDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipientAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_recipientAddressHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"withdrawDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PeanutV3", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}