{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.18;\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10**64) {\r\n                value /= 10**64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10**32) {\r\n                value /= 10**32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10**16) {\r\n                value /= 10**16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10**8) {\r\n                value /= 10**8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10**4) {\r\n                value /= 10**4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10**2) {\r\n                value /= 10**2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10**1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\ncontract Governance {\r\n    event GovernanceTransferred(\r\n        address indexed previousGovernance,\r\n        address indexed newGovernance\r\n    );\r\n\r\n    modifier onlyGovernance() {\r\n        _checkGovernance();\r\n        _;\r\n    }\r\n\r\n    function _checkGovernance() internal view virtual {\r\n        require(governance == msg.sender, \"!governance\");\r\n    }\r\n\r\n    // Address that can set the default base fee and provider\r\n    address public governance;\r\n\r\n    constructor(address _governance) {\r\n        governance = _governance;\r\n\r\n        emit GovernanceTransferred(address(0), _governance);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a new address as the governance of the contract.\r\n     * @dev Throws if the caller is not current governance.\r\n     * @param _newGovernance The new governance address.\r\n     */\r\n    function transferGovernance(\r\n        address _newGovernance\r\n    ) external onlyGovernance {\r\n        require(_newGovernance != address(0), \"ZERO ADDRESS\");\r\n        address oldGovernance = governance;\r\n        governance = _newGovernance;\r\n\r\n        emit GovernanceTransferred(oldGovernance, _newGovernance);\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\r\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\r\n *\r\n * _Available since v4.7._\r\n */\r\ninterface IERC4626 is IERC20, IERC20Metadata {\r\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\r\n     *\r\n     * - MUST be an ERC-20 token contract.\r\n     * - MUST NOT revert.\r\n     */\r\n    function asset() external view returns (address assetTokenAddress);\r\n\r\n    /**\r\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\r\n     *\r\n     * - SHOULD include any compounding that occurs from yield.\r\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT revert.\r\n     */\r\n    function totalAssets() external view returns (uint256 totalManagedAssets);\r\n\r\n    /**\r\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\r\n     * through a deposit call.\r\n     *\r\n     * - MUST return a limited value if receiver is subject to some deposit limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\r\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\r\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   deposit execution, and are accounted for during deposit.\r\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\r\n     * - MUST return a limited value if receiver is subject to some mint limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxMint(address receiver) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\r\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\r\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\r\n     */\r\n    function previewMint(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\r\n     *   execution, and are accounted for during mint.\r\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\r\n     * Vault, through a withdraw call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\r\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\r\n     *   called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\r\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   withdraw execution, and are accounted for during withdraw.\r\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner\r\n    ) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\r\n     * through a redeem call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\r\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\r\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\r\n     */\r\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   redeem execution, and are accounted for during redeem.\r\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner\r\n    ) external returns (uint256 assets);\r\n}\r\n\r\ninterface IVault is IERC4626 {\r\n    // STRATEGY EVENTS\r\n    event StrategyChanged(address indexed strategy, uint256 change_type);\r\n    event StrategyReported(\r\n        address indexed strategy,\r\n        uint256 gain,\r\n        uint256 loss,\r\n        uint256 current_debt,\r\n        uint256 protocol_fees,\r\n        uint256 total_fees,\r\n        uint256 total_refunds\r\n    );\r\n    // DEBT MANAGEMENT EVENTS\r\n    event DebtUpdated(\r\n        address indexed strategy,\r\n        uint256 current_debt,\r\n        uint256 new_debt\r\n    );\r\n    // ROLE UPDATES\r\n    event RoleSet(address indexed account, uint256 role);\r\n    event RoleStatusChanged(uint256 role, uint256 status);\r\n    event UpdateRoleManager(address indexed role_manager);\r\n\r\n    event UpdateAccountant(address indexed accountant);\r\n    event UpdateDefaultQueue(address[] new_default_queue);\r\n    event UpdateUseDefaultQueue(bool use_default_queue);\r\n    event UpdatedMaxDebtForStrategy(\r\n        address indexed sender,\r\n        address indexed strategy,\r\n        uint256 new_debt\r\n    );\r\n    event UpdateDepositLimit(uint256 deposit_limit);\r\n    event UpdateMinimumTotalIdle(uint256 minimum_total_idle);\r\n    event UpdateProfitMaxUnlockTime(uint256 profit_max_unlock_time);\r\n    event DebtPurchased(address indexed strategy, uint256 amount);\r\n    event Shutdown();\r\n\r\n    struct StrategyParams {\r\n        uint256 activation;\r\n        uint256 last_report;\r\n        uint256 current_debt;\r\n        uint256 max_debt;\r\n    }\r\n\r\n    function FACTORY() external view returns (uint256);\r\n\r\n    function strategies(address) external view returns (StrategyParams memory);\r\n\r\n    function default_queue(uint256) external view returns (address);\r\n\r\n    function use_default_queue() external view returns (bool);\r\n\r\n    function total_supply() external view returns (uint256);\r\n\r\n    function minimum_total_idle() external view returns (uint256);\r\n\r\n    function deposit_limit() external view returns (uint256);\r\n\r\n    function deposit_limit_module() external view returns (address);\r\n\r\n    function withdraw_limit_module() external view returns (address);\r\n\r\n    function accountant() external view returns (address);\r\n\r\n    function roles(address) external view returns (uint256);\r\n\r\n    function open_roles(uint256) external view returns (bool);\r\n\r\n    function role_manager() external view returns (address);\r\n\r\n    function future_role_manager() external view returns (address);\r\n\r\n    function isShutdown() external view returns (bool);\r\n\r\n    function nonces(address) external view returns (uint256);\r\n\r\n    function set_accountant(address new_accountant) external;\r\n\r\n    function set_default_queue(address[] memory new_default_queue) external;\r\n\r\n    function set_use_default_queue(bool) external;\r\n\r\n    function set_deposit_limit(uint256 deposit_limit) external;\r\n\r\n    function set_deposit_limit_module(\r\n        address new_deposit_limit_module\r\n    ) external;\r\n\r\n    function set_withdraw_limit_module(\r\n        address new_withdraw_limit_module\r\n    ) external;\r\n\r\n    function set_minimum_total_idle(uint256 minimum_total_idle) external;\r\n\r\n    function setProfitMaxUnlockTime(\r\n        uint256 new_profit_max_unlock_time\r\n    ) external;\r\n\r\n    function set_role(address account, uint256 role) external;\r\n\r\n    function add_role(address account, uint256 role) external;\r\n\r\n    function remove_role(address account, uint256 role) external;\r\n\r\n    function set_open_role(uint256 role) external;\r\n\r\n    function close_open_role(uint256 role) external;\r\n\r\n    function transfer_role_manager(address role_manager) external;\r\n\r\n    function accept_role_manager() external;\r\n\r\n    function unlockedShares() external view returns (uint256);\r\n\r\n    function pricePerShare() external view returns (uint256);\r\n\r\n    function get_default_queue() external view returns (address[] memory);\r\n\r\n    function process_report(\r\n        address strategy\r\n    ) external returns (uint256, uint256);\r\n\r\n    function buy_debt(address strategy, uint256 amount) external;\r\n\r\n    function add_strategy(address new_strategy) external;\r\n\r\n    function revoke_strategy(address strategy) external;\r\n\r\n    function force_revoke_strategy(address strategy) external;\r\n\r\n    function update_max_debt_for_strategy(\r\n        address strategy,\r\n        uint256 new_max_debt\r\n    ) external;\r\n\r\n    function update_debt(\r\n        address strategy,\r\n        uint256 target_debt\r\n    ) external returns (uint256);\r\n\r\n    function shutdown_vault() external;\r\n\r\n    function totalIdle() external view returns (uint256);\r\n\r\n    function totalDebt() external view returns (uint256);\r\n\r\n    function apiVersion() external view returns (string memory);\r\n\r\n    function assess_share_of_unrealised_losses(\r\n        address strategy,\r\n        uint256 assets_needed\r\n    ) external view returns (uint256);\r\n\r\n    function profitMaxUnlockTime() external view returns (uint256);\r\n\r\n    function fullProfitUnlockDate() external view returns (uint256);\r\n\r\n    function profitUnlockingRate() external view returns (uint256);\r\n\r\n    function lastProfitUpdate() external view returns (uint256);\r\n\r\n    //// NON-STANDARD ERC-4626 FUNCTIONS \\\\\\\\\r\n\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner,\r\n        uint256 max_loss\r\n    ) external returns (uint256);\r\n\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner,\r\n        uint256 max_loss,\r\n        address[] memory strategies\r\n    ) external returns (uint256);\r\n\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner,\r\n        uint256 max_loss\r\n    ) external returns (uint256);\r\n\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner,\r\n        uint256 max_loss,\r\n        address[] memory strategies\r\n    ) external returns (uint256);\r\n\r\n    function maxWithdraw(\r\n        address owner,\r\n        uint256 max_loss\r\n    ) external view returns (uint256);\r\n\r\n    function maxWithdraw(\r\n        address owner,\r\n        uint256 max_loss,\r\n        address[] memory strategies\r\n    ) external view returns (uint256);\r\n\r\n    function maxRedeem(\r\n        address owner,\r\n        uint256 max_loss\r\n    ) external view returns (uint256);\r\n\r\n    function maxRedeem(\r\n        address owner,\r\n        uint256 max_loss,\r\n        address[] memory strategies\r\n    ) external view returns (uint256);\r\n\r\n    //// NON-STANDARD ERC-20 FUNCTIONS \\\\\\\\\r\n\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title YearnV3 Generic Debt Allocator\r\n * @author yearn.finance\r\n * @notice\r\n *  This Generic Debt Allocator is meant to be used alongside\r\n *  a Yearn V3 vault to provide the needed triggers for a keeper\r\n *  to perform automated debt updates for the vaults strategies.\r\n *\r\n *  Each allocator contract will serve one Vault and each strategy\r\n *  that should be managed by this allocator will need to be added\r\n *  manually by setting a `minimumChange` and a `targetRatio`.\r\n *\r\n *  The allocator aims to allocate debt between the strategies\r\n *  based on their set target ratios. Which are denominated in basis\r\n *  points and represent the percent of total assets that specific\r\n *  strategy should hold.\r\n */\r\ncontract GenericDebtAllocator is Governance {\r\n    event SetTargetDebtRatio(\r\n        address indexed strategy,\r\n        uint256 targetRatio,\r\n        uint256 totalDebtRatio\r\n    );\r\n\r\n    event SetMinimumChange(address indexed strategy, uint256 minimumChange);\r\n\r\n    event SetMaxAcceptableBaseFee(uint256 maxAcceptableBaseFee);\r\n\r\n    // Struct for each strategies info.\r\n    struct Config {\r\n        // The percent in Basis Points the strategy should have.\r\n        uint256 targetRatio;\r\n        // The minimum amount denominated in asset that will\r\n        // need to be moved to trigger a debt update.\r\n        uint256 minimumChange;\r\n    }\r\n\r\n    uint256 internal constant MAX_BPS = 10_000;\r\n\r\n    // Mapping of strategy => its config.\r\n    mapping(address => Config) public configs;\r\n\r\n    // Address of the vault this serves as allocator for.\r\n    address public vault;\r\n\r\n    // Total debt ratio currently allocated in basis points.\r\n    // Can't be more than 10_000.\r\n    uint256 public debtRatio;\r\n\r\n    // Max the chains base fee can be during debt update.\r\n    // Will default to max uint256 and need to be set to be used.\r\n    uint256 public maxAcceptableBaseFee;\r\n\r\n    constructor(address _vault, address _governance) Governance(_governance) {\r\n        initialize(_vault, _governance);\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes the debt allocator.\r\n     * @dev Should be called atomically after cloning.\r\n     * @param _vault Address of the vault this allocates debt for.\r\n     * @param _governance Address to govern this contract.\r\n     */\r\n    function initialize(address _vault, address _governance) public {\r\n        require(address(vault) == address(0), \"!initialized\");\r\n        vault = _vault;\r\n        governance = _governance;\r\n        // Default max base fee to uint256 max\r\n        maxAcceptableBaseFee = type(uint256).max;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if a strategy's debt should be updated.\r\n     * @dev This should be called by a keeper to decide if a strategies\r\n     * debt should be updated and if so by how much.\r\n     *\r\n     * This cannot be used to withdraw down to 0 debt.\r\n     *\r\n     * @param _strategy Address of the strategy to check.\r\n     * @return . Bool representing if the debt should be updated.\r\n     * @return . Calldata if `true` or reason if `false`.\r\n     */\r\n    function shouldUpdateDebt(\r\n        address _strategy\r\n    ) external view returns (bool, bytes memory) {\r\n        // Check the base fee isn't too high.\r\n        if (block.basefee > maxAcceptableBaseFee) {\r\n            return (false, bytes(\"Base Fee\"));\r\n        }\r\n\r\n        // Cache the vault variable.\r\n        IVault _vault = IVault(vault);\r\n        // Retrieve the strategy specific parameters.\r\n        IVault.StrategyParams memory params = _vault.strategies(_strategy);\r\n        // Make sure its an active strategy.\r\n        require(params.activation != 0, \"!active\");\r\n\r\n        // Get the strategy specific debt config.\r\n        Config memory config = configs[_strategy];\r\n        // Make sure we have a target debt.\r\n        require(config.targetRatio != 0, \"no targetRatio\");\r\n\r\n        // Get the target debt for the strategy based on vault assets.\r\n        uint256 targetDebt = Math.min(\r\n            (_vault.totalAssets() * config.targetRatio) / MAX_BPS,\r\n            // Make sure it is not more than the max allowed.\r\n            params.max_debt\r\n        );\r\n\r\n        // If we need to add more.\r\n        if (targetDebt > params.current_debt) {\r\n            uint256 currentIdle = _vault.totalIdle();\r\n            uint256 minIdle = _vault.minimum_total_idle();\r\n\r\n            // We can't add more than the available idle.\r\n            if (minIdle >= currentIdle) {\r\n                return (false, bytes(\"No Idle\"));\r\n            }\r\n\r\n            uint256 toAdd = Math.min(\r\n                targetDebt - params.current_debt,\r\n                // Can't take more than is available.\r\n                Math.min(\r\n                    currentIdle - minIdle,\r\n                    IVault(_strategy).maxDeposit(vault)\r\n                )\r\n            );\r\n\r\n            // If the amount to add is over our threshold.\r\n            if (toAdd > config.minimumChange) {\r\n                // Return true and the calldata.\r\n                return (\r\n                    true,\r\n                    abi.encodeCall(\r\n                        _vault.update_debt,\r\n                        (_strategy, params.current_debt + toAdd)\r\n                    )\r\n                );\r\n            }\r\n            // If target debt is lower than the current.\r\n        } else if (targetDebt < params.current_debt) {\r\n            // Find out by how much.\r\n            uint256 toPull = Math.min(\r\n                params.current_debt - targetDebt,\r\n                // Account for the current liquidity constraints.\r\n                IVault(_strategy).maxWithdraw(address(_vault))\r\n            );\r\n\r\n            // Check if it's over the threshold.\r\n            if (toPull > config.minimumChange) {\r\n                // Can't lower debt if there is unrealised losses.\r\n                if (\r\n                    _vault.assess_share_of_unrealised_losses(\r\n                        _strategy,\r\n                        params.current_debt\r\n                    ) > 0\r\n                ) {\r\n                    return (false, bytes(\"unrealised loss\"));\r\n                }\r\n\r\n                // If so return true and the calldata.\r\n                return (\r\n                    true,\r\n                    abi.encodeCall(\r\n                        _vault.update_debt,\r\n                        (_strategy, params.current_debt - toPull)\r\n                    )\r\n                );\r\n            }\r\n        }\r\n\r\n        // Either no change or below our minimumChange.\r\n        return (false, bytes(\"Below Min\"));\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a new target debt ratio for a strategy.\r\n     * @dev A `minimumChange` for that strategy must be set first.\r\n     * This is to prevent debt from being updated too frequently.\r\n     *\r\n     * @param _strategy Address of the strategy to set.\r\n     * @param _targetRatio Amount in Basis points to allocate.\r\n     */\r\n    function setTargetDebtRatio(\r\n        address _strategy,\r\n        uint256 _targetRatio\r\n    ) external onlyGovernance {\r\n        // Make sure the strategy is added to the vault.\r\n        require(IVault(vault).strategies(_strategy).activation != 0, \"!active\");\r\n        // Make sure a minimumChange has been set.\r\n        require(configs[_strategy].minimumChange != 0, \"!minimum\");\r\n\r\n        // Get what will be the new total debt ratio.\r\n        uint256 newDebtRatio = debtRatio -\r\n            configs[_strategy].targetRatio +\r\n            _targetRatio;\r\n\r\n        // Make sure it is under 100% allocated\r\n        require(newDebtRatio <= MAX_BPS, \"ratio too high\");\r\n\r\n        // Write to storage.\r\n        configs[_strategy].targetRatio = _targetRatio;\r\n        debtRatio = newDebtRatio;\r\n\r\n        emit SetTargetDebtRatio(_strategy, _targetRatio, newDebtRatio);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the minimum change variable for a strategy.\r\n     * @dev This is the amount of debt that will needed to be\r\n     * added or pulled for it to trigger an update.\r\n     *\r\n     * @param _strategy The address of the strategy to update.\r\n     * @param _minimumChange The new minimum to set for the strategy.\r\n     */\r\n    function setMinimumChange(\r\n        address _strategy,\r\n        uint256 _minimumChange\r\n    ) external onlyGovernance {\r\n        // Make sure the strategy is added to the vault.\r\n        require(IVault(vault).strategies(_strategy).activation != 0, \"!active\");\r\n\r\n        // Set the new minimum.\r\n        configs[_strategy].minimumChange = _minimumChange;\r\n\r\n        emit SetMinimumChange(_strategy, _minimumChange);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the max acceptable base fee.\r\n     * @dev This defaults to max uint256 and will need to\r\n     * be set for it to be used.\r\n     *\r\n     * Is denominated in gwei. So 50gwei would be set as 50e9.\r\n     *\r\n     * @param _maxAcceptableBaseFee The new max base fee.\r\n     */\r\n    function setMaxAcceptableBaseFee(\r\n        uint256 _maxAcceptableBaseFee\r\n    ) external onlyGovernance {\r\n        maxAcceptableBaseFee = _maxAcceptableBaseFee;\r\n\r\n        emit SetMaxAcceptableBaseFee(_maxAcceptableBaseFee);\r\n    }\r\n}\r\n\r\n/**\r\n * @title YearnV3 Generic Debt Allocator Factory\r\n * @author yearn.finance\r\n * @notice\r\n *  Factory for anyone to easily deploy their own generic\r\n *  debt allocator for a Yearn V3 Vault.\r\n */\r\ncontract GenericDebtAllocatorFactory {\r\n    event NewDebtAllocator(address indexed allocator, address indexed vault);\r\n\r\n    // Original allocator to use for cloning.\r\n    address public immutable original;\r\n\r\n    constructor() {\r\n        // Deploy dummy version for original.\r\n        original = address(new GenericDebtAllocator(address(1), address(2)));\r\n    }\r\n\r\n    /**\r\n     * @notice Clones a new debt allocator.\r\n     * @dev defaults to msg.sender as the governance role.\r\n     *\r\n     * @param _vault The vault for the allocator to be hooked to.\r\n     * @return Address of the new generic debt allocator\r\n     */\r\n    function newGenericDebtAllocator(\r\n        address _vault\r\n    ) external returns (address) {\r\n        return newGenericDebtAllocator(_vault, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Clones a new debt allocator.\r\n     * @param _vault The vault for the allocator to be hooked to.\r\n     * @param _governance Address to serve as governance.\r\n     * @return newAllocator Address of the new generic debt allocator\r\n     */\r\n    function newGenericDebtAllocator(\r\n        address _vault,\r\n        address _governance\r\n    ) public returns (address newAllocator) {\r\n        // Copied from https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\r\n        bytes20 addressBytes = bytes20(original);\r\n        assembly {\r\n            // EIP-1167 bytecode\r\n            let clone_code := mload(0x40)\r\n            mstore(\r\n                clone_code,\r\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\r\n            )\r\n            mstore(add(clone_code, 0x14), addressBytes)\r\n            mstore(\r\n                add(clone_code, 0x28),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n            newAllocator := create(0, clone_code, 0x37)\r\n        }\r\n\r\n        GenericDebtAllocator(newAllocator).initialize(_vault, _governance);\r\n\r\n        emit NewDebtAllocator(newAllocator, _vault);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"allocator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"NewDebtAllocator\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"newGenericDebtAllocator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"newGenericDebtAllocator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newAllocator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"original\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GenericDebtAllocatorFactory", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a11763bdc24069f36270174108e8eef0bf042f852679909069953966fe02601d"}