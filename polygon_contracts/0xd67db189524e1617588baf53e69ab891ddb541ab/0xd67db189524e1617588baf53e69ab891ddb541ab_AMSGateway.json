{"SourceCode": "// Sources flattened with hardhat v2.0.8 https://hardhat.org\r\n\r\n// File contracts/roles/Roles.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping(address => bool) bearer;\r\n    }\r\n\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"role already has the account\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"role dosen't have the account\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    function has(Role storage role, address account)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n\r\n// File contracts/roles/IERC165.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/roles/ERC165.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/roles/ERC173.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\ninterface IERC173 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return The address of the owner.\r\n    function owner() external view returns (address);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n\r\nabstract contract ERC173 is IERC173, ERC165  {\r\n    address private _owner;\r\n\r\n    constructor() {\r\n        _registerInterface(0x7f5828d0);\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner(), \"Must be owner\");\r\n        _;\r\n    }\r\n\r\n    function owner() override public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) virtual override public onlyOwner() {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address _newOwner) internal {\r\n        address previousOwner = owner();\r\n\t_owner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/roles/Operatable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract Operatable is ERC173 {\r\n    using Roles for Roles.Role;\r\n\r\n    event OperatorAdded(address indexed account);\r\n    event OperatorRemoved(address indexed account);\r\n\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n    Roles.Role private operators;\r\n\r\n    constructor() {\r\n        operators.add(msg.sender);\r\n        _paused = false;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(isOperator(msg.sender), \"Must be operator\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner)\r\n        public\r\n        override\r\n        onlyOperator()\r\n    {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    function isOperator(address account) public view returns (bool) {\r\n        return operators.has(account);\r\n    }\r\n\r\n    function addOperator(address account) public onlyOperator() {\r\n        operators.add(account);\r\n        emit OperatorAdded(account);\r\n    }\r\n\r\n    function removeOperator(address account) public onlyOperator() {\r\n        operators.remove(account);\r\n        emit OperatorRemoved(account);\r\n    }\r\n\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    function pause() public onlyOperator() whenNotPaused() {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    function unpause() public onlyOperator() whenPaused() {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/erc/IERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/erc/IERC721.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC721 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n\r\n// File contracts/roles/OperatableWithApprove.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nabstract contract OperatableWithApprove is Operatable {\r\n\r\n    // able to transfer ERC20 token\r\n    function erc20Approve(\r\n        address _assetContract, \r\n        address _spender, \r\n        uint256 _amount\r\n    ) public onlyOperator {\r\n        IERC20 assetContract = IERC20(_assetContract);\r\n        assetContract.approve(_spender, _amount);\r\n    }\r\n\r\n    // able to transfer ERC721 token\r\n    function erc721Approve(\r\n        address _assetContract, \r\n        address _spender, \r\n        bool _approved\r\n    ) public onlyOperator {\r\n        IERC721 assetContract = IERC721(_assetContract);\r\n        assetContract.setApprovalForAll(_spender, _approved);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/erc/IERC721Gateway.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC721Asset {\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes calldata data\r\n    ) external payable;\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external payable;\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external payable;\r\n\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function exists(uint256 _tokenId) external view returns (bool);\r\n\r\n    function mint(address _to, uint256 _tokenId) external;\r\n}\r\n\r\ninterface IERC721Gateway {\r\n    function isTransactedEventHash(bytes32 _eventHash)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function setTransactedEventHash(bytes32 _eventHash, bool _desired) external;\r\n\r\n    function transferFrom(\r\n        address _assetContract,\r\n        address payable _from,\r\n        address payable _to,\r\n        uint256 _valueOrTokenId,\r\n        bytes32 _eventHash\r\n    ) external payable;\r\n\r\n    function bulkTransferFrom(\r\n        address[] calldata _assetContracts,\r\n        address payable[] calldata _froms,\r\n        address payable[] calldata _tos,\r\n        uint256[] calldata _tokenIds,\r\n        bytes32[] calldata _eventHashes\r\n    ) external payable;\r\n}\r\n\r\n\r\n// File contracts/erc/IERC721Receiver.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n\r\n// File contracts/erc/ERC721Holder.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n  /**\r\n   * @dev Implementation of the {IERC721Receiver} interface.\r\n   *\r\n   * Accepts all token transfers. \r\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\r\n   */\r\ncontract ERC721Holder is IERC721Receiver {\r\n\r\n    /**\r\n     * @dev See {IERC721Receiver-onERC721Received}.\r\n     *\r\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/utils/TransactedEventHash.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract TransactedEventHash is Operatable {\r\n    mapping(bytes32 => bool) private transactedEventHash;\r\n\r\n    event SetTransactedEventHash(bytes32 _eventHash, bool _desired);\r\n\r\n    function isTransactedEventHash(bytes32 _eventHash)\r\n        virtual\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return transactedEventHash[_eventHash];\r\n    }\r\n\r\n    function setTransactedEventHash(bytes32 _eventHash, bool _desired)\r\n        virtual\r\n        public\r\n        onlyOperator()\r\n    {\r\n        transactedEventHash[_eventHash] = _desired;\r\n        emit SetTransactedEventHash(_eventHash, _desired);\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/AMSGateway.sol\r\n\r\npragma solidity 0.8.1;\r\n\r\n\r\n\r\n\r\ncontract AMSGateway is IERC721Gateway, OperatableWithApprove, ERC721Holder, TransactedEventHash {\r\n    function transferFrom(\r\n        address _assetContract,\r\n        address payable _from,\r\n        address payable _to,\r\n        uint256 _tokenId,\r\n        bytes32 _eventHash\r\n    ) public payable override onlyOperator() {\r\n        if (isTransactedEventHash(_eventHash)) return;\r\n\r\n        IERC721Asset assetContract = IERC721Asset(_assetContract);\r\n\r\n        try assetContract.exists(_tokenId) returns (bool isExist) {\r\n            if (isExist) {\r\n                assetContract.safeTransferFrom(_from, _to, _tokenId);\r\n            } else {\r\n                assetContract.mint(_to, _tokenId);\r\n            }\r\n            // if assetContract doesn't have \"exists\" function\r\n        } catch (bytes memory) {\r\n            try assetContract.ownerOf(_tokenId) {\r\n                assetContract.safeTransferFrom(_from, _to, _tokenId);\r\n                // catch ownerOf error\r\n            } catch Error(string memory) {\r\n                assetContract.mint(_to, _tokenId);\r\n            }\r\n        }\r\n\r\n        setTransactedEventHash(_eventHash, true);\r\n    }\r\n\r\n    function bulkTransferFrom(\r\n        address[] calldata _assetContracts,\r\n        address payable[] calldata _froms,\r\n        address payable[] calldata _tos,\r\n        uint256[] calldata _tokenIds,\r\n        bytes32[] calldata _eventHashes\r\n    ) public payable override onlyOperator() {\r\n        require(\r\n            _tokenIds.length == _assetContracts.length &&\r\n                _tokenIds.length == _froms.length &&\r\n                _tokenIds.length == _tos.length &&\r\n                _tokenIds.length == _eventHashes.length,\r\n            \"invalid length\"\r\n        );\r\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n            transferFrom(\r\n                _assetContracts[i],\r\n                _froms[i],\r\n                _tos[i],\r\n                _tokenIds[i],\r\n                _eventHashes[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    //override\r\n    function isTransactedEventHash(bytes32 _eventHash)\r\n        override(IERC721Gateway, TransactedEventHash)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return super.isTransactedEventHash(_eventHash);\r\n    }\r\n\r\n    function setTransactedEventHash(bytes32 _eventHash, bool _desired)\r\n        override(IERC721Gateway, TransactedEventHash)\r\n        public\r\n        onlyOperator()\r\n    {\r\n        super.setTransactedEventHash(_eventHash, _desired);\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_eventHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_desired\",\"type\":\"bool\"}],\"name\":\"SetTransactedEventHash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assetContracts\",\"type\":\"address[]\"},{\"internalType\":\"address payable[]\",\"name\":\"_froms\",\"type\":\"address[]\"},{\"internalType\":\"address payable[]\",\"name\":\"_tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_eventHashes\",\"type\":\"bytes32[]\"}],\"name\":\"bulkTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"erc20Approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"erc721Approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_eventHash\",\"type\":\"bytes32\"}],\"name\":\"isTransactedEventHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_eventHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_desired\",\"type\":\"bool\"}],\"name\":\"setTransactedEventHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetContract\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_eventHash\",\"type\":\"bytes32\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AMSGateway", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d8482131eed60a9d0701a713bf4cb93765e040cb165b83ef8ebec4d894785170"}