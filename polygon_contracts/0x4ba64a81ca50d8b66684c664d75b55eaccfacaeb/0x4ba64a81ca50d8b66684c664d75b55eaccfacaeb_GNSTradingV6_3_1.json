{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/ChainlinkFeedInterfaceV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface ChainlinkFeedInterfaceV5{\\r\\n    function latestRoundData() external view returns (uint80,int,uint,uint,uint80);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/GNSPairInfosInterfaceV6.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface GNSPairInfosInterfaceV6{\\r\\n    function maxNegativePnlOnOpenP() external view returns(uint); // PRECISION (%)\\r\\n\\r\\n    function storeTradeInitialAccFees(\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        bool long\\r\\n    ) external;\\r\\n\\r\\n    function getTradePriceImpact(\\r\\n        uint openPrice,   // PRECISION\\r\\n        uint pairIndex,\\r\\n        bool long,\\r\\n        uint openInterest // 1e18 (DAI)\\r\\n    ) external view returns(\\r\\n        uint priceImpactP,      // PRECISION (%)\\r\\n        uint priceAfterImpact   // PRECISION\\r\\n    );\\r\\n\\r\\n   function getTradeLiquidationPrice(\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        uint openPrice,  // PRECISION\\r\\n        bool long,\\r\\n        uint collateral, // 1e18 (DAI)\\r\\n        uint leverage\\r\\n    ) external view returns(uint); // PRECISION\\r\\n\\r\\n    function getTradeValue(\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        bool long,\\r\\n        uint collateral,   // 1e18 (DAI)\\r\\n        uint leverage,\\r\\n        int percentProfit, // PRECISION (%)\\r\\n        uint closingFee    // 1e18 (DAI)\\r\\n    ) external returns(uint); // 1e18 (DAI)\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/GNSReferralsInterfaceV6_2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface GNSReferralsInterfaceV6_2{\\r\\n    function registerPotentialReferrer(address trader, address referral) external;\\r\\n   \\tfunction distributePotentialReward(\\r\\n        address trader,\\r\\n        uint volumeDai,\\r\\n        uint pairOpenFeeP,\\r\\n        uint tokenPriceDai\\r\\n    ) external returns(uint);\\r\\n    function getPercentOfOpenFeeP(address trader) external view returns(uint);\\r\\n    function getTraderReferrer(address trader) external view returns(address referrer);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IArbSys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.4.21 <0.9.0;\\r\\n\\r\\n/**\\r\\n* @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\\r\\n */\\r\\ninterface IArbSys {\\r\\n    /**\\r\\n    * @notice Get internal version number identifying an ArbOS build\\r\\n    * @return version number as int\\r\\n     */\\r\\n    function arbOSVersion() external pure returns (uint);\\r\\n\\r\\n    function arbChainID() external view returns(uint);\\r\\n\\r\\n    /**\\r\\n    * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\r\\n    * @return block number as int\\r\\n     */\\r\\n    function arbBlockNumber() external view returns (uint);\\r\\n\\r\\n    /** \\r\\n    * @notice Send given amount of Eth to dest from sender.\\r\\n    * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\\r\\n    * @param destination recipient address on L1\\r\\n    * @return unique identifier for this L2-to-L1 transaction.\\r\\n    */\\r\\n    function withdrawEth(address destination) external payable returns(uint);\\r\\n\\r\\n    /** \\r\\n    * @notice Send a transaction to L1\\r\\n    * @param destination recipient address on L1 \\r\\n    * @param calldataForL1 (optional) calldata for L1 contract call\\r\\n    * @return a unique identifier for this L2-to-L1 transaction.\\r\\n    */\\r\\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns(uint);\\r\\n\\r\\n    /** \\r\\n    * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\\r\\n    * @param account target account\\r\\n    * @return the number of transactions issued by the given external account or the account sequence number of the given contract\\r\\n    */\\r\\n    function getTransactionCount(address account) external view returns(uint256);\\r\\n\\r\\n    /**  \\r\\n    * @notice get the value of target L2 storage slot \\r\\n    * This function is only callable from address 0 to prevent contracts from being able to call it\\r\\n    * @param account target account\\r\\n    * @param index target index of storage slot \\r\\n    * @return stotage value for the given account at the given index\\r\\n    */\\r\\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n    * @notice check if current call is coming from l1\\r\\n    * @return true if the caller of this was called directly from L1\\r\\n    */\\r\\n    function isTopLevelCall() external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\\r\\n     * @return true iff the caller's address is an alias for an L1 contract address\\r\\n     */\\r\\n    function wasMyCallersAddressAliased() external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\\r\\n     * @return address of the caller's caller, without applying L1 contract address aliasing\\r\\n     */\\r\\n    function myCallersAddressWithoutAliasing() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice map L1 sender contract address to its L2 alias\\r\\n     * @param sender sender address\\r\\n     * @param dest destination address\\r\\n     * @return aliased sender address\\r\\n     */\\r\\n    function mapL1SenderContractAddressToL2Alias(address sender, address dest) external pure returns(address);\\r\\n\\r\\n    /**\\r\\n     * @notice get the caller's amount of available storage gas\\r\\n     * @return amount of storage gas available to the caller\\r\\n     */\\r\\n    function getStorageGasAvailable() external view returns(uint);\\r\\n\\r\\n    event L2ToL1Transaction(address caller, address indexed destination, uint indexed uniqueId,\\r\\n        uint indexed batchNumber, uint indexInBatch,\\r\\n        uint arbBlockNum, uint ethBlockNum, uint timestamp,\\r\\n        uint callvalue, bytes data);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IGToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IGToken{\\r\\n    function manager() external view returns(address);\\r\\n    function admin() external view returns(address);\\r\\n    function currentEpoch() external view returns(uint);\\r\\n    function currentEpochStart() external view returns(uint);\\r\\n    function currentEpochPositiveOpenPnl() external view returns(uint);\\r\\n    function updateAccPnlPerTokenUsed(uint prevPositiveOpenPnl, uint newPositiveOpenPnl) external returns(uint);\\r\\n\\r\\n    struct LockedDeposit {\\r\\n        address owner;\\r\\n        uint shares;          // 1e18\\r\\n        uint assetsDeposited; // 1e18\\r\\n        uint assetsDiscount;  // 1e18\\r\\n        uint atTimestamp;     // timestamp\\r\\n        uint lockDuration;    // timestamp\\r\\n    }\\r\\n    function getLockedDeposit(uint depositId) external view returns(LockedDeposit memory);\\r\\n\\r\\n    function sendAssets(uint assets, address receiver) external;\\r\\n    function receiveAssets(uint assets, address user) external;\\r\\n    function distributeReward(uint assets) external;\\r\\n\\r\\n    function currentBalanceDai() external view returns(uint);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/NftInterfaceV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface NftInterfaceV5{\\r\\n    function balanceOf(address) external view returns (uint);\\r\\n    function ownerOf(uint) external view returns (address);\\r\\n    function transferFrom(address, address, uint) external;\\r\\n    function tokenOfOwnerByIndex(address, uint) external view returns(uint);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/PairsStorageInterfaceV6.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface PairsStorageInterfaceV6{\\r\\n    enum FeedCalculation { DEFAULT, INVERT, COMBINE }    // FEED 1, 1 / (FEED 1), (FEED 1)/(FEED 2)\\r\\n    struct Feed{ address feed1; address feed2; FeedCalculation feedCalculation; uint maxDeviationP; } // PRECISION (%)\\r\\n    function incrementCurrentOrderId() external returns(uint);\\r\\n    function updateGroupCollateral(uint, uint, bool, bool) external;\\r\\n    function pairJob(uint) external returns(string memory, string memory, bytes32, uint);\\r\\n    function pairFeed(uint) external view returns(Feed memory);\\r\\n    function pairSpreadP(uint) external view returns(uint);\\r\\n    function pairMinLeverage(uint) external view returns(uint);\\r\\n    function pairMaxLeverage(uint) external view returns(uint);\\r\\n    function groupMaxCollateral(uint) external view returns(uint);\\r\\n    function groupCollateral(uint, bool) external view returns(uint);\\r\\n    function guaranteedSlEnabled(uint) external view returns(bool);\\r\\n    function pairOpenFeeP(uint) external view returns(uint);\\r\\n    function pairCloseFeeP(uint) external view returns(uint);\\r\\n    function pairOracleFeeP(uint) external view returns(uint);\\r\\n    function pairNftLimitOrderFeeP(uint) external view returns(uint);\\r\\n    function pairReferralFeeP(uint) external view returns(uint);\\r\\n    function pairMinLevPosDai(uint) external view returns(uint);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/StorageInterfaceV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\nimport './TokenInterfaceV5.sol';\\r\\nimport './NftInterfaceV5.sol';\\r\\nimport './IGToken.sol';\\r\\nimport './PairsStorageInterfaceV6.sol';\\r\\nimport './ChainlinkFeedInterfaceV5.sol';\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface PoolInterfaceV5{\\r\\n    function increaseAccTokensPerLp(uint) external;\\r\\n}\\r\\n\\r\\ninterface PausableInterfaceV5{\\r\\n    function isPaused() external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface StorageInterfaceV5{\\r\\n    enum LimitOrder { TP, SL, LIQ, OPEN }\\r\\n    struct Trade{\\r\\n        address trader;\\r\\n        uint pairIndex;\\r\\n        uint index;\\r\\n        uint initialPosToken;       // 1e18\\r\\n        uint positionSizeDai;       // 1e18\\r\\n        uint openPrice;             // PRECISION\\r\\n        bool buy;\\r\\n        uint leverage;\\r\\n        uint tp;                    // PRECISION\\r\\n        uint sl;                    // PRECISION\\r\\n    }\\r\\n    struct TradeInfo{\\r\\n        uint tokenId;\\r\\n        uint tokenPriceDai;         // PRECISION\\r\\n        uint openInterestDai;       // 1e18\\r\\n        uint tpLastUpdated;\\r\\n        uint slLastUpdated;\\r\\n        bool beingMarketClosed;\\r\\n    }\\r\\n    struct OpenLimitOrder{\\r\\n        address trader;\\r\\n        uint pairIndex;\\r\\n        uint index;\\r\\n        uint positionSize;          // 1e18 (DAI or GFARM2)\\r\\n        uint spreadReductionP;\\r\\n        bool buy;\\r\\n        uint leverage;\\r\\n        uint tp;                    // PRECISION (%)\\r\\n        uint sl;                    // PRECISION (%)\\r\\n        uint minPrice;              // PRECISION\\r\\n        uint maxPrice;              // PRECISION\\r\\n        uint block;\\r\\n        uint tokenId;               // index in supportedTokens\\r\\n    }\\r\\n    struct PendingMarketOrder{\\r\\n        Trade trade;\\r\\n        uint block;\\r\\n        uint wantedPrice;           // PRECISION\\r\\n        uint slippageP;             // PRECISION (%)\\r\\n        uint spreadReductionP;\\r\\n        uint tokenId;               // index in supportedTokens\\r\\n    }\\r\\n    struct PendingNftOrder{\\r\\n        address nftHolder;\\r\\n        uint nftId;\\r\\n        address trader;\\r\\n        uint pairIndex;\\r\\n        uint index;\\r\\n        LimitOrder orderType;\\r\\n    }\\r\\n    function PRECISION() external pure returns(uint);\\r\\n    function gov() external view returns(address);\\r\\n    function dev() external view returns(address);\\r\\n    function dai() external view returns(TokenInterfaceV5);\\r\\n    function token() external view returns(TokenInterfaceV5);\\r\\n    function linkErc677() external view returns(TokenInterfaceV5);\\r\\n    function priceAggregator() external view returns(AggregatorInterfaceV6_2);\\r\\n    function vault() external view returns(IGToken);\\r\\n    function trading() external view returns(address);\\r\\n    function callbacks() external view returns(address);\\r\\n    function handleTokens(address,uint,bool) external;\\r\\n    function transferDai(address, address, uint) external;\\r\\n    function transferLinkToAggregator(address, uint, uint) external;\\r\\n    function unregisterTrade(address, uint, uint) external;\\r\\n    function unregisterPendingMarketOrder(uint, bool) external;\\r\\n    function unregisterOpenLimitOrder(address, uint, uint) external;\\r\\n    function hasOpenLimitOrder(address, uint, uint) external view returns(bool);\\r\\n    function storePendingMarketOrder(PendingMarketOrder memory, uint, bool) external;\\r\\n    function openTrades(address, uint, uint) external view returns(Trade memory);\\r\\n    function openTradesInfo(address, uint, uint) external view returns(TradeInfo memory);\\r\\n    function updateSl(address, uint, uint, uint) external;\\r\\n    function updateTp(address, uint, uint, uint) external;\\r\\n    function getOpenLimitOrder(address, uint, uint) external view returns(OpenLimitOrder memory);\\r\\n    function spreadReductionsP(uint) external view returns(uint);\\r\\n    function storeOpenLimitOrder(OpenLimitOrder memory) external;\\r\\n    function reqID_pendingMarketOrder(uint) external view returns(PendingMarketOrder memory);\\r\\n    function storePendingNftOrder(PendingNftOrder memory, uint) external;\\r\\n    function updateOpenLimitOrder(OpenLimitOrder calldata) external;\\r\\n    function firstEmptyTradeIndex(address, uint) external view returns(uint);\\r\\n    function firstEmptyOpenLimitIndex(address, uint) external view returns(uint);\\r\\n    function increaseNftRewards(uint, uint) external;\\r\\n    function nftSuccessTimelock() external view returns(uint);\\r\\n    function reqID_pendingNftOrder(uint) external view returns(PendingNftOrder memory);\\r\\n    function updateTrade(Trade memory) external;\\r\\n    function nftLastSuccess(uint) external view returns(uint);\\r\\n    function unregisterPendingNftOrder(uint) external;\\r\\n    function handleDevGovFees(uint, uint, bool, bool) external returns(uint);\\r\\n    function distributeLpRewards(uint) external;\\r\\n    function storeTrade(Trade memory, TradeInfo memory) external;\\r\\n    function openLimitOrdersCount(address, uint) external view returns(uint);\\r\\n    function openTradesCount(address, uint) external view returns(uint);\\r\\n    function pendingMarketOpenCount(address, uint) external view returns(uint);\\r\\n    function pendingMarketCloseCount(address, uint) external view returns(uint);\\r\\n    function maxTradesPerPair() external view returns(uint);\\r\\n    function pendingOrderIdsCount(address) external view returns(uint);\\r\\n    function maxPendingMarketOrders() external view returns(uint);\\r\\n    function openInterestDai(uint, uint) external view returns(uint);\\r\\n    function getPendingOrderIds(address) external view returns(uint[] memory);\\r\\n    function nfts(uint) external view returns(NftInterfaceV5);\\r\\n    function fakeBlockNumber() external view returns(uint); // Testing\\r\\n}\\r\\n\\r\\ninterface IStateCopyUtils {\\r\\n    function getOpenLimitOrders() external view returns(StorageInterfaceV5.OpenLimitOrder[] memory);\\r\\n    function nftRewards() external view returns(NftRewardsInterfaceV6_3_1);\\r\\n}\\r\\n\\r\\ninterface AggregatorInterfaceV6_2{\\r\\n    enum OrderType { MARKET_OPEN, MARKET_CLOSE, LIMIT_OPEN, LIMIT_CLOSE, UPDATE_SL }\\r\\n    function pairsStorage() external view returns(PairsStorageInterfaceV6);\\r\\n    function getPrice(uint,OrderType,uint) external returns(uint);\\r\\n    function tokenPriceDai() external returns(uint);\\r\\n    function linkFee(uint,uint) external view returns(uint);\\r\\n    function openFeeP(uint) external view returns(uint);\\r\\n    function pendingSlOrders(uint) external view returns(PendingSl memory);\\r\\n    function storePendingSlOrder(uint orderId, PendingSl calldata p) external;\\r\\n    function unregisterPendingSlOrder(uint orderId) external;\\r\\n    struct PendingSl{address trader; uint pairIndex; uint index; uint openPrice; bool buy; uint newSl; }\\r\\n}\\r\\n\\r\\ninterface AggregatorInterfaceV6_3_1 is AggregatorInterfaceV6_2 {\\r\\n    function linkPriceFeed() external view returns (ChainlinkFeedInterfaceV5);\\r\\n}\\r\\n\\r\\ninterface NftRewardsInterfaceV6_3_1{\\r\\n    struct TriggeredLimitId{ address trader; uint pairIndex; uint index; StorageInterfaceV5.LimitOrder order; }\\r\\n    enum OpenLimitOrderType{ LEGACY, REVERSAL, MOMENTUM }\\r\\n    function storeFirstToTrigger(TriggeredLimitId calldata, address, uint) external;\\r\\n    function storeTriggerSameBlock(TriggeredLimitId calldata, address) external;\\r\\n    function unregisterTrigger(TriggeredLimitId calldata) external;\\r\\n    function distributeNftReward(TriggeredLimitId calldata, uint, uint) external;\\r\\n    function openLimitOrderTypes(address, uint, uint) external view returns(OpenLimitOrderType);\\r\\n    function setOpenLimitOrderType(address, uint, uint, OpenLimitOrderType) external;\\r\\n    function triggered(TriggeredLimitId calldata) external view returns(bool);\\r\\n    function timedOut(TriggeredLimitId calldata) external view returns(bool);\\r\\n    function botInUse(bytes32) external view returns(bool);\\r\\n    function getNftBotHashes(uint, address, uint, address, uint, uint) external pure returns(bytes32, bytes32);\\r\\n    function setNftBotInUse(bytes32, bytes32) external;\\r\\n    function nftBotInUse(bytes32, bytes32) external view returns(bool);\\r\\n    function linkToTokenRewards(uint, uint) external view returns(uint);\\r\\n}\\r\\n\\r\\ninterface TradingCallbacksV6_3_1 {\\r\\n    enum TradeType {MARKET, LIMIT}\\r\\n    struct SimplifiedTradeId{ address trader; uint pairIndex; uint index; TradeType tradeType; }\\r\\n    struct LastUpdated{ uint32 tp; uint32 sl; uint32 limit; uint32 created; }\\r\\n    function tradeLastUpdated(address, uint, uint, TradeType) external view returns(LastUpdated memory);\\r\\n    function setTradeLastUpdated(SimplifiedTradeId calldata, LastUpdated memory) external;\\r\\n    function canExecuteTimeout() external view returns(uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/TokenInterfaceV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface TokenInterfaceV5{\\r\\n    function burn(address, uint256) external;\\r\\n    function mint(address, uint256) external;\\r\\n    function transfer(address, uint256) external returns (bool);\\r\\n    function transferFrom(address, address, uint256) external returns(bool);\\r\\n    function balanceOf(address) external view returns(uint256);\\r\\n    function hasRole(bytes32, address) external view returns (bool);\\r\\n    function approve(address, uint256) external returns (bool);\\r\\n    function allowance(address, address) external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/ChainUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"../interfaces/IArbSys.sol\\\";\\r\\n\\r\\nlibrary ChainUtils {\\r\\n\\r\\n    uint256 constant public ARBITRUM_MAINNET = 42161;\\r\\n    uint256 constant public ARBITRUM_GOERLI = 421613;\\r\\n    IArbSys constant public ARB_SYS = IArbSys(address(100));\\r\\n\\r\\n    function getBlockNumber() internal view returns (uint) {\\r\\n        if (block.chainid == ARBITRUM_MAINNET || block.chainid == ARBITRUM_GOERLI) {\\r\\n            return ARB_SYS.arbBlockNumber();\\r\\n        }\\r\\n\\r\\n        return block.number;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/TradeUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport '../interfaces/StorageInterfaceV5.sol';\\r\\n\\r\\nlibrary TradeUtils {\\r\\n    function _getTradeLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_1.TradeType _type\\r\\n    ) internal view returns (\\r\\n        TradingCallbacksV6_3_1,\\r\\n        TradingCallbacksV6_3_1.LastUpdated memory,\\r\\n        TradingCallbacksV6_3_1.SimplifiedTradeId memory\\r\\n    ) {\\r\\n        TradingCallbacksV6_3_1 callbacks = TradingCallbacksV6_3_1(_callbacks);\\r\\n        TradingCallbacksV6_3_1.LastUpdated memory l = callbacks.tradeLastUpdated(trader, pairIndex, index, _type);\\r\\n\\r\\n        return (callbacks, l, TradingCallbacksV6_3_1.SimplifiedTradeId(trader, pairIndex, index, _type));\\r\\n    }\\r\\n\\r\\n    function getTradeLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_1.TradeType _type\\r\\n    ) external view returns (\\r\\n        TradingCallbacksV6_3_1,\\r\\n        TradingCallbacksV6_3_1.LastUpdated memory,\\r\\n        TradingCallbacksV6_3_1.SimplifiedTradeId memory\\r\\n    ) {\\r\\n        return _getTradeLastUpdated(_callbacks, trader, pairIndex, index, _type);\\r\\n    }\\r\\n\\r\\n    function setTradeLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_1.TradeType _type,\\r\\n        uint blockNumber\\r\\n    ) external {\\r\\n        uint32 b = uint32(blockNumber);\\r\\n        TradingCallbacksV6_3_1 callbacks = TradingCallbacksV6_3_1(_callbacks);\\r\\n        callbacks.setTradeLastUpdated(\\r\\n            TradingCallbacksV6_3_1.SimplifiedTradeId(trader, pairIndex, index, _type),\\r\\n            TradingCallbacksV6_3_1.LastUpdated(b, b, b, b)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setSlLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_1.TradeType _type,\\r\\n        uint blockNumber\\r\\n    ) external {\\r\\n        (\\r\\n            TradingCallbacksV6_3_1 callbacks,\\r\\n            TradingCallbacksV6_3_1.LastUpdated memory l,\\r\\n            TradingCallbacksV6_3_1.SimplifiedTradeId memory id\\r\\n        ) = _getTradeLastUpdated(_callbacks, trader, pairIndex, index, _type);\\r\\n\\r\\n        l.sl = uint32(blockNumber);\\r\\n        callbacks.setTradeLastUpdated(id, l);\\r\\n    }\\r\\n\\r\\n    function setTpLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_1.TradeType _type,\\r\\n        uint blockNumber\\r\\n    ) external {\\r\\n        (\\r\\n            TradingCallbacksV6_3_1 callbacks,\\r\\n            TradingCallbacksV6_3_1.LastUpdated memory l,\\r\\n            TradingCallbacksV6_3_1.SimplifiedTradeId memory id\\r\\n        ) = _getTradeLastUpdated(\\r\\n            _callbacks, trader, pairIndex, index, _type\\r\\n        );\\r\\n\\r\\n        l.tp = uint32(blockNumber);\\r\\n        callbacks.setTradeLastUpdated(id, l);\\r\\n    }\\r\\n\\r\\n    function setLimitLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_1.TradeType _type,\\r\\n        uint blockNumber\\r\\n    ) external {\\r\\n        (\\r\\n            TradingCallbacksV6_3_1 callbacks,\\r\\n            TradingCallbacksV6_3_1.LastUpdated memory l,\\r\\n            TradingCallbacksV6_3_1.SimplifiedTradeId memory id\\r\\n        ) = _getTradeLastUpdated(\\r\\n            _callbacks, trader, pairIndex, index, _type\\r\\n        );\\r\\n\\r\\n        l.limit = uint32(blockNumber);\\r\\n        callbacks.setTradeLastUpdated(id, l);\\r\\n    }\\r\\n\\r\\n    function isTpInTimeout(\\r\\n        address _callbacks,\\r\\n        TradingCallbacksV6_3_1.SimplifiedTradeId memory id,\\r\\n        uint currentBlock\\r\\n    ) external view returns (bool) {\\r\\n        (\\r\\n            TradingCallbacksV6_3_1 callbacks,\\r\\n            TradingCallbacksV6_3_1.LastUpdated memory l,\\r\\n        ) = _getTradeLastUpdated(\\r\\n            _callbacks, id.trader, id.pairIndex, id.index, id.tradeType\\r\\n        );\\r\\n\\r\\n        return currentBlock < uint256(l.tp) + callbacks.canExecuteTimeout();\\r\\n    }\\r\\n\\r\\n    function isSlInTimeout(\\r\\n        address _callbacks,\\r\\n        TradingCallbacksV6_3_1.SimplifiedTradeId memory id,\\r\\n        uint currentBlock\\r\\n    ) external view returns (bool) {\\r\\n        (\\r\\n            TradingCallbacksV6_3_1 callbacks,\\r\\n            TradingCallbacksV6_3_1.LastUpdated memory l,\\r\\n        ) = _getTradeLastUpdated(\\r\\n            _callbacks, id.trader, id.pairIndex, id.index, id.tradeType\\r\\n        );\\r\\n\\r\\n        return currentBlock < uint256(l.sl) + callbacks.canExecuteTimeout();\\r\\n    }\\r\\n\\r\\n    function isLimitInTimeout(\\r\\n        address _callbacks,\\r\\n        TradingCallbacksV6_3_1.SimplifiedTradeId memory id,\\r\\n        uint currentBlock\\r\\n    ) external view returns (bool) {\\r\\n        (\\r\\n            TradingCallbacksV6_3_1 callbacks,\\r\\n            TradingCallbacksV6_3_1.LastUpdated memory l,\\r\\n        ) = _getTradeLastUpdated(\\r\\n            _callbacks, id.trader, id.pairIndex, id.index, id.tradeType\\r\\n        );\\r\\n\\r\\n        return currentBlock < uint256(l.limit) + callbacks.canExecuteTimeout();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v6.2/Delegatable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nabstract contract Delegatable {\\r\\n    mapping (address => address) public delegations;\\r\\n    address private senderOverride;\\r\\n\\r\\n    function setDelegate(address delegate) external {\\r\\n        require(tx.origin == msg.sender, \\\"NO_CONTRACT\\\");\\r\\n\\r\\n        delegations[msg.sender] = delegate;\\r\\n    }\\r\\n\\r\\n    function removeDelegate() external {\\r\\n        delegations[msg.sender] = address(0);\\r\\n    }\\r\\n\\r\\n    function delegatedAction(address trader, bytes calldata call_data) external returns (bytes memory) {\\r\\n        require(delegations[trader] == msg.sender, \\\"DELEGATE_NOT_APPROVED\\\");\\r\\n\\r\\n        senderOverride = trader;\\r\\n        (bool success, bytes memory result) = address(this).delegatecall(call_data);\\r\\n        if (!success) {\\r\\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577 (return the original revert reason)\\r\\n            if (result.length < 68) revert();\\r\\n            assembly {\\r\\n                result := add(result, 0x04)\\r\\n            }\\r\\n            revert(abi.decode(result, (string)));\\r\\n        }\\r\\n\\r\\n        senderOverride = address(0);\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n\\r\\n    function _msgSender() public view returns (address) {\\r\\n        if (senderOverride == address(0)) {\\r\\n            return msg.sender;\\r\\n        } else {\\r\\n            return senderOverride;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/v6.3.1/GNSTradingV6_3_1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\nimport '../interfaces/StorageInterfaceV5.sol';\\r\\nimport '../interfaces/GNSPairInfosInterfaceV6.sol';\\r\\nimport '../interfaces/GNSReferralsInterfaceV6_2.sol';\\r\\nimport '../v6.2/Delegatable.sol';\\r\\nimport '../libraries/ChainUtils.sol';\\r\\nimport '../libraries/TradeUtils.sol';\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ncontract GNSTradingV6_3_1 is Delegatable {\\r\\n    using TradeUtils for address;\\r\\n\\r\\n    // Contracts (constant)\\r\\n    StorageInterfaceV5 public immutable storageT;\\r\\n    NftRewardsInterfaceV6_3_1 public immutable nftRewards;\\r\\n    GNSPairInfosInterfaceV6 public immutable pairInfos;\\r\\n    GNSReferralsInterfaceV6_2 public immutable referrals;\\r\\n\\r\\n    // Params (constant)\\r\\n    uint constant PRECISION = 1e10;\\r\\n    uint constant MAX_SL_P = 75;  // -75% PNL\\r\\n\\r\\n    // Params (adjustable)\\r\\n    uint public maxPosDai;            // 1e18 (eg. 75000 * 1e18)\\r\\n    uint public marketOrdersTimeout;  // block (eg. 30)\\r\\n\\r\\n    // State\\r\\n    bool public isPaused;  // Prevent opening new trades\\r\\n    bool public isDone;    // Prevent any interaction with the contract\\r\\n\\r\\n    // Events\\r\\n    event Done(bool done);\\r\\n    event Paused(bool paused);\\r\\n\\r\\n    event NumberUpdated(string name, uint value);\\r\\n\\r\\n    event MarketOrderInitiated(\\r\\n        uint indexed orderId,\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        bool open\\r\\n    );\\r\\n\\r\\n    event OpenLimitPlaced(\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        uint index\\r\\n    );\\r\\n    event OpenLimitUpdated(\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        uint index,\\r\\n        uint newPrice,\\r\\n        uint newTp,\\r\\n        uint newSl\\r\\n    );\\r\\n    event OpenLimitCanceled(\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        uint index\\r\\n    );\\r\\n\\r\\n    event TpUpdated(\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        uint index,\\r\\n        uint newTp\\r\\n    );\\r\\n    event SlUpdated(\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        uint index,\\r\\n        uint newSl\\r\\n    );\\r\\n    event SlUpdateInitiated(\\r\\n        uint indexed orderId,\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        uint index,\\r\\n        uint newSl\\r\\n    );\\r\\n\\r\\n    event NftOrderInitiated(\\r\\n        uint orderId,\\r\\n        address indexed nftHolder,\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex\\r\\n    );\\r\\n    event NftOrderSameBlock(\\r\\n        address indexed nftHolder,\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex\\r\\n    );\\r\\n\\r\\n    event ChainlinkCallbackTimeout(\\r\\n        uint indexed orderId,\\r\\n        StorageInterfaceV5.PendingMarketOrder order\\r\\n    );\\r\\n    event CouldNotCloseTrade(\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        uint index\\r\\n    );\\r\\n\\r\\n    constructor(\\r\\n        StorageInterfaceV5 _storageT,\\r\\n        NftRewardsInterfaceV6_3_1 _nftRewards,\\r\\n        GNSPairInfosInterfaceV6 _pairInfos,\\r\\n        GNSReferralsInterfaceV6_2 _referrals,\\r\\n        uint _maxPosDai,\\r\\n        uint _marketOrdersTimeout\\r\\n    ) {\\r\\n        require(address(_storageT) != address(0)\\r\\n            && address(_nftRewards) != address(0)\\r\\n            && address(_pairInfos) != address(0)\\r\\n            && address(_referrals) != address(0)\\r\\n            && _maxPosDai > 0\\r\\n            && _marketOrdersTimeout > 0, \\\"WRONG_PARAMS\\\");\\r\\n\\r\\n        storageT = _storageT;\\r\\n        nftRewards = _nftRewards;\\r\\n        pairInfos = _pairInfos;\\r\\n        referrals = _referrals;\\r\\n\\r\\n        maxPosDai = _maxPosDai;\\r\\n        marketOrdersTimeout = _marketOrdersTimeout;\\r\\n    }\\r\\n\\r\\n    // Modifiers\\r\\n    modifier onlyGov(){\\r\\n        isGov();\\r\\n        _;\\r\\n    }\\r\\n    modifier notContract(){\\r\\n        isNotContract();\\r\\n        _;\\r\\n    }\\r\\n    modifier notDone(){\\r\\n        isNotDone();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Saving code size by calling these functions inside modifiers\\r\\n    function isGov() private view {\\r\\n        require(msg.sender == storageT.gov(), \\\"GOV_ONLY\\\");\\r\\n    }\\r\\n    function isNotContract() private view {\\r\\n        require(tx.origin == msg.sender);\\r\\n    }\\r\\n    function isNotDone() private view {\\r\\n        require(!isDone, \\\"DONE\\\");\\r\\n    }\\r\\n\\r\\n    // Manage params\\r\\n    function setMaxPosDai(uint value) external onlyGov{\\r\\n        require(value > 0, \\\"VALUE_0\\\");\\r\\n        maxPosDai = value;\\r\\n\\r\\n        emit NumberUpdated(\\\"maxPosDai\\\", value);\\r\\n    }\\r\\n    function setMarketOrdersTimeout(uint value) external onlyGov{\\r\\n        require(value > 0, \\\"VALUE_0\\\");\\r\\n        marketOrdersTimeout = value;\\r\\n\\r\\n        emit NumberUpdated(\\\"marketOrdersTimeout\\\", value);\\r\\n    }\\r\\n\\r\\n    // Manage state\\r\\n    function pause() external onlyGov{\\r\\n        isPaused = !isPaused;\\r\\n\\r\\n        emit Paused(isPaused);\\r\\n    }\\r\\n    function done() external onlyGov{\\r\\n        isDone = !isDone;\\r\\n\\r\\n        emit Done(isDone);\\r\\n    }\\r\\n\\r\\n    // Open new trade (MARKET/LIMIT)\\r\\n    function openTrade(\\r\\n        StorageInterfaceV5.Trade memory t,\\r\\n        NftRewardsInterfaceV6_3_1.OpenLimitOrderType orderType, // LEGACY => market\\r\\n        uint spreadReductionId,\\r\\n        uint slippageP, // for market orders only\\r\\n        address referrer\\r\\n    ) external notContract notDone {\\r\\n\\r\\n        require(!isPaused, \\\"PAUSED\\\");\\r\\n        require(t.openPrice * slippageP < type(uint256).max, \\\"OVERFLOW\\\");\\r\\n\\r\\n        AggregatorInterfaceV6_2 aggregator = storageT.priceAggregator();\\r\\n        PairsStorageInterfaceV6 pairsStored = aggregator.pairsStorage();\\r\\n\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        require(storageT.openTradesCount(sender, t.pairIndex)\\r\\n            + storageT.pendingMarketOpenCount(sender, t.pairIndex)\\r\\n            + storageT.openLimitOrdersCount(sender, t.pairIndex)\\r\\n            < storageT.maxTradesPerPair(),\\r\\n            \\\"MAX_TRADES_PER_PAIR\\\");\\r\\n\\r\\n        require(storageT.pendingOrderIdsCount(sender)\\r\\n            < storageT.maxPendingMarketOrders(),\\r\\n            \\\"MAX_PENDING_ORDERS\\\");\\r\\n\\r\\n        require(t.positionSizeDai <= maxPosDai, \\\"ABOVE_MAX_POS\\\");\\r\\n        require(t.positionSizeDai * t.leverage\\r\\n            >= pairsStored.pairMinLevPosDai(t.pairIndex), \\\"BELOW_MIN_POS\\\");\\r\\n\\r\\n        require(t.leverage > 0 && t.leverage >= pairsStored.pairMinLeverage(t.pairIndex)\\r\\n            && t.leverage <= pairsStored.pairMaxLeverage(t.pairIndex),\\r\\n            \\\"LEVERAGE_INCORRECT\\\");\\r\\n\\r\\n        require(spreadReductionId == 0\\r\\n            || storageT.nfts(spreadReductionId - 1).balanceOf(sender) > 0,\\r\\n            \\\"NO_CORRESPONDING_NFT_SPREAD_REDUCTION\\\");\\r\\n\\r\\n        require(t.tp == 0 || (t.buy ?\\r\\n                t.tp > t.openPrice :\\r\\n                t.tp < t.openPrice), \\\"WRONG_TP\\\");\\r\\n\\r\\n        require(t.sl == 0 || (t.buy ?\\r\\n                t.sl < t.openPrice :\\r\\n                t.sl > t.openPrice), \\\"WRONG_SL\\\");\\r\\n\\r\\n        (uint priceImpactP, ) = pairInfos.getTradePriceImpact(\\r\\n            0,\\r\\n            t.pairIndex,\\r\\n            t.buy,\\r\\n            t.positionSizeDai * t.leverage\\r\\n        );\\r\\n\\r\\n        require(priceImpactP * t.leverage\\r\\n            <= pairInfos.maxNegativePnlOnOpenP(), \\\"PRICE_IMPACT_TOO_HIGH\\\");\\r\\n\\r\\n        storageT.transferDai(sender, address(storageT), t.positionSizeDai);\\r\\n\\r\\n        if(orderType != NftRewardsInterfaceV6_3_1.OpenLimitOrderType.LEGACY){\\r\\n            uint index = storageT.firstEmptyOpenLimitIndex(sender, t.pairIndex);\\r\\n\\r\\n            storageT.storeOpenLimitOrder(\\r\\n                StorageInterfaceV5.OpenLimitOrder(\\r\\n                    sender,\\r\\n                    t.pairIndex,\\r\\n                    index,\\r\\n                    t.positionSizeDai,\\r\\n                    spreadReductionId > 0 ?\\r\\n                        storageT.spreadReductionsP(spreadReductionId - 1) :\\r\\n                        0,\\r\\n                    t.buy,\\r\\n                    t.leverage,\\r\\n                    t.tp,\\r\\n                    t.sl,\\r\\n                    t.openPrice,\\r\\n                    t.openPrice,\\r\\n                    block.number,\\r\\n                    0\\r\\n                )\\r\\n            );\\r\\n\\r\\n            nftRewards.setOpenLimitOrderType(sender, t.pairIndex, index, orderType);\\r\\n            storageT.callbacks().setTradeLastUpdated(\\r\\n                sender,\\r\\n                t.pairIndex,\\r\\n                index,\\r\\n                TradingCallbacksV6_3_1.TradeType.LIMIT,\\r\\n                ChainUtils.getBlockNumber()\\r\\n            );\\r\\n\\r\\n            emit OpenLimitPlaced(\\r\\n                sender,\\r\\n                t.pairIndex,\\r\\n                index\\r\\n            );\\r\\n\\r\\n        }else{\\r\\n            uint orderId = aggregator.getPrice(\\r\\n                t.pairIndex,\\r\\n                AggregatorInterfaceV6_2.OrderType.MARKET_OPEN,\\r\\n                t.positionSizeDai * t.leverage\\r\\n            );\\r\\n\\r\\n            storageT.storePendingMarketOrder(\\r\\n                StorageInterfaceV5.PendingMarketOrder(\\r\\n                    StorageInterfaceV5.Trade(\\r\\n                        sender,\\r\\n                        t.pairIndex,\\r\\n                        0,\\r\\n                        0,\\r\\n                        t.positionSizeDai,\\r\\n                        0,\\r\\n                        t.buy,\\r\\n                        t.leverage,\\r\\n                        t.tp,\\r\\n                        t.sl\\r\\n                    ),\\r\\n                    0,\\r\\n                    t.openPrice,\\r\\n                    slippageP,\\r\\n                    spreadReductionId > 0 ?\\r\\n                        storageT.spreadReductionsP(spreadReductionId - 1) :\\r\\n                        0,\\r\\n                    0\\r\\n                ), orderId, true\\r\\n            );\\r\\n\\r\\n            emit MarketOrderInitiated(\\r\\n                orderId,\\r\\n                sender,\\r\\n                t.pairIndex,\\r\\n                true\\r\\n            );\\r\\n        }\\r\\n\\r\\n        referrals.registerPotentialReferrer(sender, referrer);\\r\\n    }\\r\\n\\r\\n    // Close trade (MARKET)\\r\\n    function closeTradeMarket(\\r\\n        uint pairIndex,\\r\\n        uint index\\r\\n    ) external notContract notDone {\\r\\n\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        StorageInterfaceV5.Trade memory t = storageT.openTrades(\\r\\n            sender, pairIndex, index\\r\\n        );\\r\\n\\r\\n        StorageInterfaceV5.TradeInfo memory i = storageT.openTradesInfo(\\r\\n            sender, pairIndex, index\\r\\n        );\\r\\n\\r\\n        require(storageT.pendingOrderIdsCount(sender)\\r\\n            < storageT.maxPendingMarketOrders(), \\\"MAX_PENDING_ORDERS\\\");\\r\\n\\r\\n        require(!i.beingMarketClosed, \\\"ALREADY_BEING_CLOSED\\\");\\r\\n        require(t.leverage > 0, \\\"NO_TRADE\\\");\\r\\n\\r\\n        uint orderId = storageT.priceAggregator().getPrice(\\r\\n            pairIndex,\\r\\n            AggregatorInterfaceV6_2.OrderType.MARKET_CLOSE,\\r\\n            t.initialPosToken * i.tokenPriceDai * t.leverage / PRECISION\\r\\n        );\\r\\n\\r\\n        storageT.storePendingMarketOrder(\\r\\n            StorageInterfaceV5.PendingMarketOrder(\\r\\n                StorageInterfaceV5.Trade(\\r\\n                    sender, pairIndex, index, 0, 0, 0, false, 0, 0, 0\\r\\n                ),\\r\\n                0, 0, 0, 0, 0\\r\\n            ), orderId, false\\r\\n        );\\r\\n\\r\\n        emit MarketOrderInitiated(\\r\\n            orderId,\\r\\n            sender,\\r\\n            pairIndex,\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // Manage limit order (OPEN)\\r\\n    function updateOpenLimitOrder(\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        uint price,  // PRECISION\\r\\n        uint tp,\\r\\n        uint sl\\r\\n    ) external notContract notDone {\\r\\n\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        require(storageT.hasOpenLimitOrder(sender, pairIndex, index),\\r\\n            \\\"NO_LIMIT\\\");\\r\\n\\r\\n        StorageInterfaceV5.OpenLimitOrder memory o = storageT.getOpenLimitOrder(\\r\\n            sender, pairIndex, index\\r\\n        );\\r\\n\\r\\n        require(tp == 0 || (o.buy ?\\r\\n            tp > price :\\r\\n            tp < price), \\\"WRONG_TP\\\");\\r\\n\\r\\n        require(sl == 0 || (o.buy ?\\r\\n            sl < price :\\r\\n            sl > price), \\\"WRONG_SL\\\");\\r\\n\\r\\n        checkNoPendingTrigger(sender, pairIndex, index, StorageInterfaceV5.LimitOrder.OPEN);\\r\\n\\r\\n        o.minPrice = price;\\r\\n        o.maxPrice = price;\\r\\n        o.tp = tp;\\r\\n        o.sl = sl;\\r\\n\\r\\n        storageT.updateOpenLimitOrder(o);\\r\\n        storageT.callbacks().setTradeLastUpdated(\\r\\n            sender,\\r\\n            pairIndex,\\r\\n            index,\\r\\n            TradingCallbacksV6_3_1.TradeType.LIMIT,\\r\\n            ChainUtils.getBlockNumber()\\r\\n        );\\r\\n\\r\\n        emit OpenLimitUpdated(\\r\\n            sender,\\r\\n            pairIndex,\\r\\n            index,\\r\\n            price,\\r\\n            tp,\\r\\n            sl\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function cancelOpenLimitOrder(\\r\\n        uint pairIndex,\\r\\n        uint index\\r\\n    ) external notContract notDone {\\r\\n\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        require(storageT.hasOpenLimitOrder(sender, pairIndex, index),\\r\\n            \\\"NO_LIMIT\\\");\\r\\n\\r\\n        StorageInterfaceV5.OpenLimitOrder memory o = storageT.getOpenLimitOrder(\\r\\n            sender, pairIndex, index\\r\\n        );\\r\\n\\r\\n        checkNoPendingTrigger(sender, pairIndex, index, StorageInterfaceV5.LimitOrder.OPEN);\\r\\n\\r\\n        storageT.unregisterOpenLimitOrder(sender, pairIndex, index);\\r\\n        storageT.transferDai(address(storageT), sender, o.positionSize);\\r\\n\\r\\n        emit OpenLimitCanceled(\\r\\n            sender,\\r\\n            pairIndex,\\r\\n            index\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // Manage limit order (TP/SL)\\r\\n    function updateTp(\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        uint newTp\\r\\n    ) external notContract notDone {\\r\\n\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        checkNoPendingTrigger(sender, pairIndex, index, StorageInterfaceV5.LimitOrder.TP);\\r\\n\\r\\n        StorageInterfaceV5.Trade memory t = storageT.openTrades(\\r\\n            sender, pairIndex, index\\r\\n        );\\r\\n\\r\\n        require(t.leverage > 0, \\\"NO_TRADE\\\");\\r\\n\\r\\n        storageT.updateTp(sender, pairIndex, index, newTp);\\r\\n        storageT.callbacks().setTpLastUpdated(\\r\\n            sender,\\r\\n            pairIndex,\\r\\n            index,\\r\\n            TradingCallbacksV6_3_1.TradeType.MARKET,\\r\\n            ChainUtils.getBlockNumber()\\r\\n        );\\r\\n\\r\\n        emit TpUpdated(\\r\\n            sender,\\r\\n            pairIndex,\\r\\n            index,\\r\\n            newTp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function updateSl(\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        uint newSl\\r\\n    ) external notContract notDone {\\r\\n\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        checkNoPendingTrigger(sender, pairIndex, index, StorageInterfaceV5.LimitOrder.SL);\\r\\n\\r\\n        StorageInterfaceV5.Trade memory t = storageT.openTrades(\\r\\n            sender, pairIndex, index\\r\\n        );\\r\\n\\r\\n        StorageInterfaceV5.TradeInfo memory i = storageT.openTradesInfo(\\r\\n            sender, pairIndex, index\\r\\n        );\\r\\n\\r\\n        require(t.leverage > 0, \\\"NO_TRADE\\\");\\r\\n\\r\\n        uint maxSlDist = t.openPrice * MAX_SL_P / 100 / t.leverage;\\r\\n\\r\\n        require(newSl == 0 || (t.buy ?\\r\\n            newSl >= t.openPrice - maxSlDist :\\r\\n            newSl <= t.openPrice + maxSlDist), \\\"SL_TOO_BIG\\\");\\r\\n\\r\\n        AggregatorInterfaceV6_2 aggregator = storageT.priceAggregator();\\r\\n\\r\\n        if(newSl == 0\\r\\n        || !aggregator.pairsStorage().guaranteedSlEnabled(pairIndex)){\\r\\n\\r\\n            storageT.updateSl(sender, pairIndex, index, newSl);\\r\\n            storageT.callbacks().setSlLastUpdated(\\r\\n                sender,\\r\\n                pairIndex,\\r\\n                index,\\r\\n                TradingCallbacksV6_3_1.TradeType.MARKET,\\r\\n                ChainUtils.getBlockNumber()\\r\\n            );\\r\\n\\r\\n            emit SlUpdated(\\r\\n                sender,\\r\\n                pairIndex,\\r\\n                index,\\r\\n                newSl\\r\\n            );\\r\\n\\r\\n        }else{\\r\\n            uint orderId = aggregator.getPrice(\\r\\n                pairIndex,\\r\\n                AggregatorInterfaceV6_2.OrderType.UPDATE_SL,\\r\\n                t.initialPosToken * i.tokenPriceDai * t.leverage / PRECISION\\r\\n            );\\r\\n\\r\\n            aggregator.storePendingSlOrder(\\r\\n                orderId,\\r\\n                AggregatorInterfaceV6_2.PendingSl(\\r\\n                    sender, pairIndex, index, t.openPrice, t.buy, newSl\\r\\n                )\\r\\n            );\\r\\n\\r\\n            emit SlUpdateInitiated(\\r\\n                orderId,\\r\\n                sender,\\r\\n                pairIndex,\\r\\n                index,\\r\\n                newSl\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Execute limit order\\r\\n    function executeNftOrder(\\r\\n        StorageInterfaceV5.LimitOrder orderType,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        uint nftId,\\r\\n        uint nftType\\r\\n    ) external notContract notDone {\\r\\n\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        require(nftType >= 1 && nftType <= 5, \\\"WRONG_NFT_TYPE\\\");\\r\\n        require(storageT.nfts(nftType - 1).ownerOf(nftId) == sender, \\\"NO_NFT\\\");\\r\\n\\r\\n        require(block.number >=\\r\\n            storageT.nftLastSuccess(nftId) + storageT.nftSuccessTimelock(),\\r\\n            \\\"SUCCESS_TIMELOCK\\\");\\r\\n        require(\\r\\n            canExecute(\\r\\n                orderType,\\r\\n                TradingCallbacksV6_3_1.SimplifiedTradeId(\\r\\n                    trader,\\r\\n                    pairIndex,\\r\\n                    index,\\r\\n                    orderType == StorageInterfaceV5.LimitOrder.OPEN\\r\\n                        ? TradingCallbacksV6_3_1.TradeType.LIMIT\\r\\n                        : TradingCallbacksV6_3_1.TradeType.MARKET\\r\\n                )\\r\\n            ),\\r\\n            \\\"IN_TIMEOUT\\\"\\r\\n        );\\r\\n\\r\\n        {\\r\\n            (bytes32 nftHash, bytes32 botHash) = nftRewards.getNftBotHashes(\\r\\n                block.number,\\r\\n                sender,\\r\\n                nftId,\\r\\n                trader,\\r\\n                pairIndex,\\r\\n                index\\r\\n            );\\r\\n            require(!nftRewards.nftBotInUse(nftHash, botHash), \\\"BOT_IN_USE\\\");\\r\\n\\r\\n            nftRewards.setNftBotInUse(nftHash, botHash);\\r\\n        }\\r\\n\\r\\n        StorageInterfaceV5.Trade memory t;\\r\\n\\r\\n        if(orderType == StorageInterfaceV5.LimitOrder.OPEN){\\r\\n            require(storageT.hasOpenLimitOrder(trader, pairIndex, index),\\r\\n                \\\"NO_LIMIT\\\");\\r\\n\\r\\n        }else{\\r\\n            t = storageT.openTrades(trader, pairIndex, index);\\r\\n\\r\\n            require(t.leverage > 0, \\\"NO_TRADE\\\");\\r\\n\\r\\n            if(orderType == StorageInterfaceV5.LimitOrder.LIQ){\\r\\n                uint liqPrice = pairInfos.getTradeLiquidationPrice(\\r\\n                    t.trader,\\r\\n                    t.pairIndex,\\r\\n                    t.index,\\r\\n                    t.openPrice,\\r\\n                    t.buy,\\r\\n                    t.initialPosToken * storageT.openTradesInfo(\\r\\n                        t.trader, t.pairIndex, t.index\\r\\n                    ).tokenPriceDai / PRECISION,\\r\\n                    t.leverage\\r\\n                );\\r\\n\\r\\n                require(t.sl == 0 || (t.buy ?\\r\\n                    liqPrice > t.sl :\\r\\n                    liqPrice < t.sl), \\\"HAS_SL\\\");\\r\\n\\r\\n            }else{\\r\\n                require(orderType != StorageInterfaceV5.LimitOrder.SL || t.sl > 0,\\r\\n                    \\\"NO_SL\\\");\\r\\n                require(orderType != StorageInterfaceV5.LimitOrder.TP || t.tp > 0,\\r\\n                    \\\"NO_TP\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        NftRewardsInterfaceV6_3_1.TriggeredLimitId memory triggeredLimitId =\\r\\n            NftRewardsInterfaceV6_3_1.TriggeredLimitId(\\r\\n                trader, pairIndex, index, orderType\\r\\n            );\\r\\n\\r\\n        if(!nftRewards.triggered(triggeredLimitId)\\r\\n        || nftRewards.timedOut(triggeredLimitId)){\\r\\n\\r\\n            uint leveragedPosDai;\\r\\n\\r\\n            if(orderType == StorageInterfaceV5.LimitOrder.OPEN){\\r\\n\\r\\n                StorageInterfaceV5.OpenLimitOrder memory l = storageT.getOpenLimitOrder(\\r\\n                    trader, pairIndex, index\\r\\n                );\\r\\n\\r\\n                leveragedPosDai = l.positionSize * l.leverage;\\r\\n\\r\\n                (uint priceImpactP, ) = pairInfos.getTradePriceImpact(\\r\\n                    0,\\r\\n                    l.pairIndex,\\r\\n                    l.buy,\\r\\n                    leveragedPosDai\\r\\n                );\\r\\n\\r\\n                require(priceImpactP * l.leverage <= pairInfos.maxNegativePnlOnOpenP(),\\r\\n                    \\\"PRICE_IMPACT_TOO_HIGH\\\");\\r\\n\\r\\n            }else{\\r\\n                leveragedPosDai = t.initialPosToken * storageT.openTradesInfo(\\r\\n                    trader, pairIndex, index\\r\\n                ).tokenPriceDai * t.leverage / PRECISION;\\r\\n            }\\r\\n\\r\\n            storageT.transferLinkToAggregator(sender, pairIndex, leveragedPosDai);\\r\\n\\r\\n            AggregatorInterfaceV6_2 aggregator = storageT.priceAggregator();\\r\\n            uint orderId = aggregator.getPrice(\\r\\n                pairIndex,\\r\\n                orderType == StorageInterfaceV5.LimitOrder.OPEN ?\\r\\n                    AggregatorInterfaceV6_2.OrderType.LIMIT_OPEN :\\r\\n                    AggregatorInterfaceV6_2.OrderType.LIMIT_CLOSE,\\r\\n                leveragedPosDai\\r\\n            );\\r\\n\\r\\n            storageT.storePendingNftOrder(\\r\\n                StorageInterfaceV5.PendingNftOrder(\\r\\n                    sender,\\r\\n                    nftId,\\r\\n                    trader,\\r\\n                    pairIndex,\\r\\n                    index,\\r\\n                    orderType\\r\\n                ), orderId\\r\\n            );\\r\\n\\r\\n            nftRewards.storeFirstToTrigger(triggeredLimitId, sender, aggregator.linkFee(pairIndex, leveragedPosDai));\\r\\n\\r\\n            emit NftOrderInitiated(\\r\\n                orderId,\\r\\n                sender,\\r\\n                trader,\\r\\n                pairIndex\\r\\n            );\\r\\n\\r\\n        }else{\\r\\n            nftRewards.storeTriggerSameBlock(triggeredLimitId, sender);\\r\\n\\r\\n            emit NftOrderSameBlock(\\r\\n                sender,\\r\\n                trader,\\r\\n                pairIndex\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Market timeout\\r\\n    function openTradeMarketTimeout(uint _order) external notContract notDone {\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        StorageInterfaceV5.PendingMarketOrder memory o =\\r\\n            storageT.reqID_pendingMarketOrder(_order);\\r\\n\\r\\n        StorageInterfaceV5.Trade memory t = o.trade;\\r\\n\\r\\n        require(o.block > 0\\r\\n            && block.number >= o.block + marketOrdersTimeout, \\\"WAIT_TIMEOUT\\\");\\r\\n\\r\\n        require(t.trader == sender, \\\"NOT_YOUR_ORDER\\\");\\r\\n        require(t.leverage > 0, \\\"WRONG_MARKET_ORDER_TYPE\\\");\\r\\n\\r\\n        storageT.unregisterPendingMarketOrder(_order, true);\\r\\n        storageT.transferDai(address(storageT), sender, t.positionSizeDai);\\r\\n\\r\\n        emit ChainlinkCallbackTimeout(\\r\\n            _order,\\r\\n            o\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function closeTradeMarketTimeout(uint _order) external notContract notDone {\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        StorageInterfaceV5.PendingMarketOrder memory o =\\r\\n            storageT.reqID_pendingMarketOrder(_order);\\r\\n\\r\\n        StorageInterfaceV5.Trade memory t = o.trade;\\r\\n\\r\\n        require(o.block > 0\\r\\n            && block.number >= o.block + marketOrdersTimeout, \\\"WAIT_TIMEOUT\\\");\\r\\n\\r\\n        require(t.trader == sender, \\\"NOT_YOUR_ORDER\\\");\\r\\n        require(t.leverage == 0, \\\"WRONG_MARKET_ORDER_TYPE\\\");\\r\\n\\r\\n        storageT.unregisterPendingMarketOrder(_order, false);\\r\\n\\r\\n        (bool success, ) = address(this).delegatecall(\\r\\n            abi.encodeWithSignature(\\r\\n                \\\"closeTradeMarket(uint256,uint256)\\\",\\r\\n                t.pairIndex,\\r\\n                t.index\\r\\n            )\\r\\n        );\\r\\n\\r\\n        if(!success){\\r\\n            emit CouldNotCloseTrade(\\r\\n                sender,\\r\\n                t.pairIndex,\\r\\n                t.index\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit ChainlinkCallbackTimeout(\\r\\n            _order,\\r\\n            o\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // Helpers\\r\\n    function checkNoPendingTrigger(\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        StorageInterfaceV5.LimitOrder orderType\\r\\n    ) private view {\\r\\n        NftRewardsInterfaceV6_3_1.TriggeredLimitId memory triggeredLimitId =\\r\\n            NftRewardsInterfaceV6_3_1.TriggeredLimitId(\\r\\n                trader, pairIndex, index, orderType\\r\\n            );\\r\\n        require(!nftRewards.triggered(triggeredLimitId)\\r\\n            || nftRewards.timedOut(triggeredLimitId), \\\"PENDING_TRIGGER\\\");\\r\\n    }\\r\\n\\r\\n    function canExecute(\\r\\n        StorageInterfaceV5.LimitOrder orderType,\\r\\n        TradingCallbacksV6_3_1.SimplifiedTradeId memory id\\r\\n    ) private view returns(bool) {\\r\\n        if (orderType == StorageInterfaceV5.LimitOrder.LIQ)\\r\\n            return true;\\r\\n\\r\\n        uint b = ChainUtils.getBlockNumber();\\r\\n        address cb = storageT.callbacks();\\r\\n\\r\\n        if (orderType == StorageInterfaceV5.LimitOrder.TP)\\r\\n            return !cb.isTpInTimeout(\\r\\n                id,\\r\\n                b\\r\\n            );\\r\\n\\r\\n        if (orderType == StorageInterfaceV5.LimitOrder.SL)\\r\\n            return !cb.isSlInTimeout(\\r\\n                id,\\r\\n                b\\r\\n            );\\r\\n\\r\\n        return !cb.isLimitInTimeout(\\r\\n            id,\\r\\n            b\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 275\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/TradeUtils.sol\": {\r\n        \"TradeUtils\": \"0x7abb4710b79195da2c38f86f77ffcb42d830bee5\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract StorageInterfaceV5\",\"name\":\"_storageT\",\"type\":\"address\"},{\"internalType\":\"contract NftRewardsInterfaceV6_3_1\",\"name\":\"_nftRewards\",\"type\":\"address\"},{\"internalType\":\"contract GNSPairInfosInterfaceV6\",\"name\":\"_pairInfos\",\"type\":\"address\"},{\"internalType\":\"contract GNSReferralsInterfaceV6_2\",\"name\":\"_referrals\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxPosDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketOrdersTimeout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialPosToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionSizeDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sl\",\"type\":\"uint256\"}],\"internalType\":\"struct StorageInterfaceV5.Trade\",\"name\":\"trade\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wantedPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippageP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spreadReductionP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct StorageInterfaceV5.PendingMarketOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"ChainlinkCallbackTimeout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"CouldNotCloseTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"Done\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"MarketOrderInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftHolder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"}],\"name\":\"NftOrderInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftHolder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"}],\"name\":\"NftOrderSameBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NumberUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"OpenLimitCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"OpenLimitPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSl\",\"type\":\"uint256\"}],\"name\":\"OpenLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSl\",\"type\":\"uint256\"}],\"name\":\"SlUpdateInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSl\",\"type\":\"uint256\"}],\"name\":\"SlUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTp\",\"type\":\"uint256\"}],\"name\":\"TpUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_msgSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"cancelOpenLimitOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"closeTradeMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_order\",\"type\":\"uint256\"}],\"name\":\"closeTradeMarketTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call_data\",\"type\":\"bytes\"}],\"name\":\"delegatedAction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"done\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StorageInterfaceV5.LimitOrder\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftType\",\"type\":\"uint256\"}],\"name\":\"executeNftOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketOrdersTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPosDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftRewards\",\"outputs\":[{\"internalType\":\"contract NftRewardsInterfaceV6_3_1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialPosToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionSizeDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sl\",\"type\":\"uint256\"}],\"internalType\":\"struct StorageInterfaceV5.Trade\",\"name\":\"t\",\"type\":\"tuple\"},{\"internalType\":\"enum NftRewardsInterfaceV6_3_1.OpenLimitOrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"spreadReductionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippageP\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"openTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_order\",\"type\":\"uint256\"}],\"name\":\"openTradeMarketTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairInfos\",\"outputs\":[{\"internalType\":\"contract GNSPairInfosInterfaceV6\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referrals\",\"outputs\":[{\"internalType\":\"contract GNSReferralsInterfaceV6_2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"setDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMarketOrdersTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMaxPosDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storageT\",\"outputs\":[{\"internalType\":\"contract StorageInterfaceV5\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sl\",\"type\":\"uint256\"}],\"name\":\"updateOpenLimitOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSl\",\"type\":\"uint256\"}],\"name\":\"updateSl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newTp\",\"type\":\"uint256\"}],\"name\":\"updateTp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GNSTradingV6_3_1", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "275", "ConstructorArguments": "000000000000000000000000aee4d11a16b2bc65edd6416fb626eb404a6d65bd0000000000000000000000008103c0665a544201bbf606d90845d1b2d8005f1c000000000000000000000000ee7442accc1c27f2c69423576d3b1d25b563e9770000000000000000000000000f9498b1206bf9ffde2a2321fdb56f573a05242500000000000000000000000000000000000000000000152d02c7e14af6800000000000000000000000000000000000000000000000000000000000000000001e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}