{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@adrastia-oracle/adrastia-core/contracts/interfaces/IPeriodic.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\n/**\\n * @title IPeriodic\\n * @notice An interface that defines a contract containing a period.\\n * @dev This typically refers to an update period.\\n */\\ninterface IPeriodic {\\n    /// @notice Gets the period, in seconds.\\n    /// @return periodSeconds The period, in seconds.\\n    function period() external view returns (uint256 periodSeconds);\\n\\n    // @notice Gets the number of observations made every period.\\n    // @return granularity The number of observations made every period.\\n    function granularity() external view returns (uint256 granularity);\\n}\\n\"\r\n    },\r\n    \"@adrastia-oracle/adrastia-core/contracts/interfaces/IUpdateable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\n/// @title IUpdateByToken\\n/// @notice An interface that defines a contract that is updateable as per the input data.\\nabstract contract IUpdateable {\\n    /// @notice Performs an update as per the input data.\\n    /// @param data Any data needed for the update.\\n    /// @return b True if anything was updated; false otherwise.\\n    function update(bytes memory data) public virtual returns (bool b);\\n\\n    /// @notice Checks if an update needs to be performed.\\n    /// @param data Any data relating to the update.\\n    /// @return b True if an update needs to be performed; false otherwise.\\n    function needsUpdate(bytes memory data) public view virtual returns (bool b);\\n\\n    /// @notice Check if an update can be performed by the caller (if needed).\\n    /// @dev Tries to determine if the caller can call update with a valid observation being stored.\\n    /// @dev This is not meant to be called by state-modifying functions.\\n    /// @param data Any data relating to the update.\\n    /// @return b True if an update can be performed by the caller; false otherwise.\\n    function canUpdate(bytes memory data) public view virtual returns (bool b);\\n\\n    /// @notice Gets the timestamp of the last update.\\n    /// @param data Any data relating to the update.\\n    /// @return A unix timestamp.\\n    function lastUpdateTime(bytes memory data) public view virtual returns (uint256);\\n\\n    /// @notice Gets the amount of time (in seconds) since the last update.\\n    /// @param data Any data relating to the update.\\n    /// @return Time in seconds.\\n    function timeSinceLastUpdate(bytes memory data) public view virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-v4/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-v4/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\\n        if (result.length < 32) return false;\\n        return success && abi.decode(result, (bool));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-v4/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-v4/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rates/controllers/proto/aave/AaveCapController.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.8.13;\\n\\nimport \\\"./AaveRateController.sol\\\";\\nimport \\\"../../../../vendor/aave/IAaveV3ConfigEngine.sol\\\";\\nimport {EngineFlags} from \\\"../../../../vendor/aave/AaveV3EngineFlags.sol\\\";\\n\\n/**\\n * @title AaveCapController\\n * @notice A smart contract that extends AaveRateController to implement functionality specific to Aave v3's supply and\\n *   borrow cap management.\\n * @dev This contract overrides `willAnythingChange` to only check if the next rate changes by more than the configured\\n *   threshold. This changes the behavior of the rate queue where old rates do not necessarily relate to the period.\\n *   i.e. If the period is a day, the rate at index 1 is not necessarily the rate from the previous day.\\n */\\ncontract AaveCapController is AaveRateController {\\n    uint256 public constant CHANGE_PRECISION = 10 ** 8;\\n\\n    /// @notice The Aave Config Engine instance.\\n    IAaveV3ConfigEngine public immutable configEngine;\\n\\n    /// @notice True if this controller updates supply caps, false if it updates borrow caps.\\n    bool public immutable forSupplyCaps;\\n\\n    /**\\n     * @notice An event emitted when the change threshold for a token is updated.\\n     * @param token The token whose change threshold was updated.\\n     * @param oldChangeThreshold The old change threshold.\\n     * @param newChangeThreshold The new change threshold.\\n     */\\n    event ChangeThresholdUpdated(address indexed token, uint256 oldChangeThreshold, uint256 newChangeThreshold);\\n\\n    /**\\n     * @notice Constructs the AaveCapController contract.\\n     * @param configEngine_ The Aave Config Engine instance.\\n     * @param forSupplyCaps_ True if this controller updates supply caps, false if it updates borrow caps.\\n     * @param aclManager_ The Aave ACL Manager instance.\\n     * @param period_ The period of the rate controller.\\n     * @param initialBufferCardinality_ The initial cardinality of the rate buffers.\\n     * @param updatersMustBeEoa_ Whether or not the updaters must be EOA.\\n     */\\n    constructor(\\n        IAaveV3ConfigEngine configEngine_,\\n        bool forSupplyCaps_,\\n        IACLManager aclManager_,\\n        uint32 period_,\\n        uint8 initialBufferCardinality_,\\n        bool updatersMustBeEoa_\\n    ) AaveRateController(aclManager_, period_, initialBufferCardinality_, updatersMustBeEoa_) {\\n        configEngine = configEngine_;\\n        forSupplyCaps = forSupplyCaps_;\\n    }\\n\\n    /**\\n     * @notice Sets the change threshold for the specified token. When the rate changes by more than the threshold, an\\n     *   update is triggered, assuming the period has been surpassed.\\n     * @param token The token to set the change threshold for.\\n     * @param changeThreshold Percent change that allows an update to make place, respresented as the numerator of a\\n     *   fraction with a denominator of `CHANGE_PRECISION`. Ex: With `CHANGE_PRECISION` of 1e8, a change threshold of\\n     *   2% would be represented as 2e6 (2000000).\\n     */\\n    function setChangeThreshold(address token, uint32 changeThreshold) external virtual {\\n        checkSetChangeThreshold();\\n\\n        BufferMetadata storage metadata = rateBufferMetadata[token];\\n\\n        uint256 oldChangeThreshold = metadata.changeThreshold;\\n\\n        if (oldChangeThreshold != changeThreshold) {\\n            metadata.changeThreshold = changeThreshold;\\n\\n            emit ChangeThresholdUpdated(token, oldChangeThreshold, changeThreshold);\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the change threshold for the specified token.\\n     * @param token The token to get the change threshold for.\\n     * @return uint32 Percent change that allows an update to make place, respresented as the numerator of a\\n     *   fraction with a denominator of `CHANGE_PRECISION`. Ex: With `CHANGE_PRECISION` of 1e8, a change threshold of\\n     *   2% would be represented as 2e6 (2000000).\\n     */\\n    function getChangeThreshold(address token) external view virtual returns (uint32) {\\n        return rateBufferMetadata[token].changeThreshold;\\n    }\\n\\n    /// @notice Checks if the sender has the required role to set the change threshold, namely, the POOL_ADMIN role.\\n    function checkSetChangeThreshold() internal view virtual {\\n        if (!aclManager.isPoolAdmin(msg.sender)) {\\n            revert NotAuthorized(msg.sender, aclManager.POOL_ADMIN_ROLE());\\n        }\\n    }\\n\\n    /// @dev Overridden to push the rate to the Aave Config Engine.\\n    function push(address token, RateLibrary.Rate memory rate) internal virtual override {\\n        super.push(token, rate);\\n\\n        // Push the latest rate to the Aave Config Engine\\n        pushToConfigEngine(token, rate);\\n    }\\n\\n    /**\\n     * @notice Pushes the rate to the Aave Config Engine.\\n     * @dev Whether the rate is for supply caps or borrow caps is determined by the `forSupplyCaps` field.\\n     * @param token The token to push the rate for.\\n     * @param rate The rate to push.\\n     */\\n    function pushToConfigEngine(address token, RateLibrary.Rate memory rate) internal virtual {\\n        IAaveV3ConfigEngine.CapsUpdate[] memory capsUpdates = new IAaveV3ConfigEngine.CapsUpdate[](1);\\n\\n        capsUpdates[0] = IAaveV3ConfigEngine.CapsUpdate({\\n            asset: token,\\n            supplyCap: forSupplyCaps ? rate.current : EngineFlags.KEEP_CURRENT,\\n            borrowCap: forSupplyCaps ? EngineFlags.KEEP_CURRENT : rate.current\\n        });\\n\\n        IAaveV3ConfigEngine(configEngine).updateCaps(capsUpdates);\\n    }\\n\\n    /// @dev Overridden to only check if the the rate changes by at least the desired threshold.\\n    function willAnythingChange(bytes memory data) internal view virtual override returns (bool) {\\n        address token = abi.decode(data, (address));\\n\\n        BufferMetadata memory meta = rateBufferMetadata[token];\\n\\n        // No rates in the buffer, so the rate will change.\\n        if (meta.size == 0) return true;\\n\\n        uint256 lastRate = _getRates(token, 1, 0, 1)[0].current;\\n        (, uint64 nextRate) = computeRateAndClamp(token);\\n\\n        return changeThresholdSurpassed(lastRate, nextRate, meta.changeThreshold);\\n    }\\n\\n    /// @dev Overridden to allow anyone to extend the capacity of the rate buffers. Since `willAnythingChange` only\\n    ///   compares the previous rate to the next rate, extending the capacity of the rate buffers does not affect the\\n    ///   gas consumption of the rate controller (by much).\\n    function checkSetRatesCapacity() internal view virtual override {\\n        // Anyone can extend the capacity of the rate buffers.\\n    }\\n\\n    /// @dev Taken from adrastia-core/contracts/accumulators/AbstractAccumulator.\\n    /// @custom:todo Add this to a library upstream.\\n    function calculateChange(uint256 a, uint256 b) internal view virtual returns (uint256 change, bool isInfinite) {\\n        // Ensure a is never smaller than b\\n        if (a < b) {\\n            uint256 temp = a;\\n            a = b;\\n            b = temp;\\n        }\\n\\n        // a >= b\\n\\n        if (a == 0) {\\n            // a == b == 0 (since a >= b), therefore no change\\n            return (0, false);\\n        } else if (b == 0) {\\n            // (a > 0 && b == 0) => change threshold passed\\n            // Zero to non-zero always returns true\\n            return (0, true);\\n        }\\n\\n        unchecked {\\n            uint256 delta = a - b; // a >= b, therefore no underflow\\n            uint256 preciseDelta = delta * CHANGE_PRECISION;\\n\\n            // If the delta is so large that multiplying by CHANGE_PRECISION overflows, we assume that\\n            // the change threshold has been surpassed.\\n            // If our assumption is incorrect, the accumulator will be extra-up-to-date, which won't\\n            // really break anything, but will cost more gas in keeping this accumulator updated.\\n            if (preciseDelta < delta) return (0, true);\\n\\n            change = preciseDelta / b;\\n            isInfinite = false;\\n        }\\n    }\\n\\n    /// @dev Taken from adrastia-core/contracts/accumulators/AbstractAccumulator.\\n    /// @custom:todo Add this to a library upstream.\\n    function changeThresholdSurpassed(\\n        uint256 a,\\n        uint256 b,\\n        uint256 changeThreshold\\n    ) internal view virtual returns (bool) {\\n        (uint256 change, bool isInfinite) = calculateChange(a, b);\\n\\n        return isInfinite || change >= changeThreshold;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rates/controllers/proto/aave/AaveRateController.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.8.13;\\n\\nimport \\\"../../../RateController.sol\\\";\\nimport \\\"../../../../vendor/aave/IACLManager.sol\\\";\\n\\n/**\\n * @title AaveRateController\\n * @notice A smart contract that extends RateController to implement access control based on Aave's ACL Manager.\\n */\\ncontract AaveRateController is RateController {\\n    /// @notice The Aave ACL Manager instance.\\n    IACLManager public immutable aclManager;\\n\\n    /// @notice An error that is thrown if the account is not authorized for the required role.\\n    /// @param account The account that is not authorized.\\n    /// @param requiredRole The required role (hash) that the account is missing.\\n    error NotAuthorized(address account, bytes32 requiredRole);\\n\\n    /**\\n     * @notice Constructs the AaveRateController contract.\\n     * @param aclManager_ The Aave ACL Manager instance.\\n     * @param period_ The period of the rate controller.\\n     * @param initialBufferCardinality_ The initial cardinality of the rate buffers.\\n     * @param updatersMustBeEoa_ Whether or not the updaters must be EOA.\\n     */\\n    constructor(\\n        IACLManager aclManager_,\\n        uint32 period_,\\n        uint8 initialBufferCardinality_,\\n        bool updatersMustBeEoa_\\n    ) RateController(period_, initialBufferCardinality_, updatersMustBeEoa_) {\\n        aclManager = aclManager_;\\n    }\\n\\n    /**\\n     * @notice Checks if the sender has the required role to set the rate, namely, the POOL_ADMIN role.\\n     */\\n    function checkSetConfig() internal view virtual override {\\n        if (!aclManager.isPoolAdmin(msg.sender)) {\\n            revert NotAuthorized(msg.sender, aclManager.POOL_ADMIN_ROLE());\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the sender has the required role to manually push rates, namely, the POOL_ADMIN role.\\n     */\\n    function checkManuallyPushRate() internal view virtual override {\\n        if (!aclManager.isPoolAdmin(msg.sender)) {\\n            revert NotAuthorized(msg.sender, aclManager.POOL_ADMIN_ROLE());\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the sender has the required role to [un]pause updates, namely, the EMERGENCY_ADMIN role.\\n     */\\n    function checkSetUpdatesPaused() internal view virtual override {\\n        if (!aclManager.isPoolAdmin(msg.sender) && !aclManager.isEmergencyAdmin(msg.sender)) {\\n            revert NotAuthorized(msg.sender, aclManager.EMERGENCY_ADMIN_ROLE());\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the sender has the required role change the rate buffer capacity, namely, the POOL_ADMIN role.\\n     */\\n    function checkSetRatesCapacity() internal view virtual override {\\n        if (!aclManager.isPoolAdmin(msg.sender)) {\\n            revert NotAuthorized(msg.sender, aclManager.POOL_ADMIN_ROLE());\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if the sender has the required role to poke rate updates, which is anyone.\\n     */\\n    function checkUpdate() internal view virtual override {\\n        // Anyone can poke updates (provided they are not paused)\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rates/HistoricalRates.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.8.13;\\n\\nimport \\\"./IHistoricalRates.sol\\\";\\n\\n/**\\n * @title HistoricalRates\\n * @notice The HistoricalRates contract is an abstract contract designed to store historical rate data for various\\n * tokens on the blockchain. It provides functionalities for initializing, updating, and querying historical rate\\n * data in a circular buffer with a fixed capacity.\\n * @dev This contract implements the IHistoricalRates interface and maintains a mapping of tokens to their respective\\n * rate buffers and metadata. Each rate buffer holds an array of Rate structs containing target rate, current rate, and\\n * timestamp data. The metadata includes information about the buffer's start, end, size, maximum size, and a pause\\n * flag, which can be used to pause updates in extended contracts.\\n */\\nabstract contract HistoricalRates is IHistoricalRates {\\n    struct BufferMetadata {\\n        uint16 start;\\n        uint16 end;\\n        uint16 size;\\n        uint16 maxSize;\\n        uint16 flags; // Bit flags\\n        uint32 changeThreshold;\\n        uint80 __reserved; // Reserved for future use\\n        uint64 extra; // For user extensions\\n    }\\n\\n    /// @notice Event emitted when a rate buffer's capacity is increased past the initial capacity.\\n    /// @dev Buffer initialization does not emit an event.\\n    /// @param token The token for which the rate buffer's capacity was increased.\\n    /// @param oldCapacity The previous capacity of the rate buffer.\\n    /// @param newCapacity The new capacity of the rate buffer.\\n    event RatesCapacityIncreased(address indexed token, uint256 oldCapacity, uint256 newCapacity);\\n\\n    /// @notice Event emitted when a rate buffer's capacity is initialized.\\n    /// @param token The token for which the rate buffer's capacity was initialized.\\n    /// @param capacity The capacity of the rate buffer.\\n    event RatesCapacityInitialized(address indexed token, uint256 capacity);\\n\\n    /// @notice Event emitted when a new rate is pushed to the rate buffer.\\n    /// @param token The token for which the rate was pushed.\\n    /// @param target The target rate.\\n    /// @param current The current rate, which may be different from the target rate if the rate change is capped.\\n    /// @param timestamp The timestamp at which the rate was pushed.\\n    event RateUpdated(address indexed token, uint256 target, uint256 current, uint256 timestamp);\\n\\n    /// @notice An error that is thrown if we try to initialize a rate buffer that has already been initialized.\\n    /// @param token The token for which we tried to initialize the rate buffer.\\n    error BufferAlreadyInitialized(address token);\\n\\n    /// @notice An error that is thrown if we try to retrieve a rate at an invalid index.\\n    /// @param token The token for which we tried to retrieve the rate.\\n    /// @param index The index of the rate that we tried to retrieve.\\n    /// @param size The size of the rate buffer.\\n    error InvalidIndex(address token, uint256 index, uint256 size);\\n\\n    /// @notice An error that is thrown if we try to decrease the capacity of a rate buffer.\\n    /// @param token The token for which we tried to decrease the capacity of the rate buffer.\\n    /// @param amount The capacity that we tried to decrease the rate buffer to.\\n    /// @param currentCapacity The current capacity of the rate buffer.\\n    error CapacityCannotBeDecreased(address token, uint256 amount, uint256 currentCapacity);\\n\\n    /// @notice An error that is thrown if we try to increase the capacity of a rate buffer past the maximum capacity.\\n    /// @param token The token for which we tried to increase the capacity of the rate buffer.\\n    /// @param amount The capacity that we tried to increase the rate buffer to.\\n    /// @param maxCapacity The maximum capacity of the rate buffer.\\n    error CapacityTooLarge(address token, uint256 amount, uint256 maxCapacity);\\n\\n    /// @notice An error that is thrown if we try to retrieve more rates than are available in the rate buffer.\\n    /// @param token The token for which we tried to retrieve the rates.\\n    /// @param size The size of the rate buffer.\\n    /// @param minSizeRequired The minimum size of the rate buffer that we require.\\n    error InsufficientData(address token, uint256 size, uint256 minSizeRequired);\\n\\n    /// @notice The initial capacity of the rate buffer.\\n    uint16 internal immutable initialBufferCardinality;\\n\\n    /// @notice Maps a token to its metadata.\\n    mapping(address => BufferMetadata) internal rateBufferMetadata;\\n\\n    /// @notice Maps a token to a buffer of rates.\\n    mapping(address => RateLibrary.Rate[]) internal rateBuffers;\\n\\n    /**\\n     * @notice Constructs the HistoricalRates contract with a specified initial buffer capacity.\\n     * @param initialBufferCardinality_ The initial capacity of the rate buffer.\\n     */\\n    constructor(uint16 initialBufferCardinality_) {\\n        initialBufferCardinality = initialBufferCardinality_;\\n    }\\n\\n    /// @inheritdoc IHistoricalRates\\n    function getRateAt(address token, uint256 index) external view virtual override returns (RateLibrary.Rate memory) {\\n        BufferMetadata memory meta = rateBufferMetadata[token];\\n\\n        if (index >= meta.size) {\\n            revert InvalidIndex(token, index, meta.size);\\n        }\\n\\n        uint256 bufferIndex = meta.end < index ? meta.end + meta.size - index : meta.end - index;\\n\\n        return rateBuffers[token][bufferIndex];\\n    }\\n\\n    /// @inheritdoc IHistoricalRates\\n    function getRates(\\n        address token,\\n        uint256 amount\\n    ) external view virtual override returns (RateLibrary.Rate[] memory) {\\n        return _getRates(token, amount, 0, 1);\\n    }\\n\\n    /// @inheritdoc IHistoricalRates\\n    function getRates(\\n        address token,\\n        uint256 amount,\\n        uint256 offset,\\n        uint256 increment\\n    ) external view virtual override returns (RateLibrary.Rate[] memory) {\\n        return _getRates(token, amount, offset, increment);\\n    }\\n\\n    /// @inheritdoc IHistoricalRates\\n    function getRatesCount(address token) external view override returns (uint256) {\\n        return rateBufferMetadata[token].size;\\n    }\\n\\n    /// @inheritdoc IHistoricalRates\\n    function getRatesCapacity(address token) external view virtual override returns (uint256) {\\n        uint256 maxSize = rateBufferMetadata[token].maxSize;\\n        if (maxSize == 0) return initialBufferCardinality;\\n\\n        return maxSize;\\n    }\\n\\n    /// @param amount The new capacity of rates for the token. Must be greater than the current capacity, but\\n    ///   less than 256.\\n    /// @inheritdoc IHistoricalRates\\n    function setRatesCapacity(address token, uint256 amount) external virtual {\\n        _setRatesCapacity(token, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to set the capacity of the rate buffer for a token.\\n     * @param token The token for which to set the new capacity.\\n     * @param amount The new capacity of rates for the token. Must be greater than the current capacity, but\\n     * less than 256.\\n     */\\n    function _setRatesCapacity(address token, uint256 amount) internal virtual {\\n        BufferMetadata storage meta = rateBufferMetadata[token];\\n\\n        if (amount < meta.maxSize) revert CapacityCannotBeDecreased(token, amount, meta.maxSize);\\n        if (amount > type(uint16).max) revert CapacityTooLarge(token, amount, type(uint16).max);\\n\\n        RateLibrary.Rate[] storage rateBuffer = rateBuffers[token];\\n\\n        // Add new slots to the buffer\\n        uint256 capacityToAdd = amount - meta.maxSize;\\n        for (uint256 i = 0; i < capacityToAdd; ++i) {\\n            // Push a dummy rate with non-zero values to put most of the gas cost on the caller\\n            rateBuffer.push(RateLibrary.Rate({target: 1, current: 1, timestamp: 1}));\\n        }\\n\\n        if (meta.maxSize != amount) {\\n            emit RatesCapacityIncreased(token, meta.maxSize, amount);\\n\\n            // Update the metadata\\n            meta.maxSize = uint16(amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to get historical rates with specified amount, offset, and increment.\\n     * @param token The token for which to retrieve the rates.\\n     * @param amount The number of historical rates to retrieve.\\n     * @param offset The number of rates to skip before starting to collect the rates.\\n     * @param increment The step size between the rates to collect.\\n     * @return observations An array of Rate structs containing the retrieved historical rates.\\n     */\\n    function _getRates(\\n        address token,\\n        uint256 amount,\\n        uint256 offset,\\n        uint256 increment\\n    ) internal view virtual returns (RateLibrary.Rate[] memory) {\\n        if (amount == 0) return new RateLibrary.Rate[](0);\\n\\n        BufferMetadata memory meta = rateBufferMetadata[token];\\n        if (meta.size <= (amount - 1) * increment + offset)\\n            revert InsufficientData(token, meta.size, (amount - 1) * increment + offset + 1);\\n\\n        RateLibrary.Rate[] memory observations = new RateLibrary.Rate[](amount);\\n\\n        uint256 count = 0;\\n\\n        for (\\n            uint256 i = meta.end < offset ? meta.end + meta.size - offset : meta.end - offset;\\n            count < amount;\\n            i = (i < increment) ? (i + meta.size) - increment : i - increment\\n        ) {\\n            observations[count++] = rateBuffers[token][i];\\n        }\\n\\n        return observations;\\n    }\\n\\n    /**\\n     * @dev Internal function to initialize rate buffers for a token.\\n     * @param token The token for which to initialize the rate buffer.\\n     */\\n    function initializeBuffers(address token) internal virtual {\\n        if (rateBuffers[token].length != 0) {\\n            revert BufferAlreadyInitialized(token);\\n        }\\n\\n        BufferMetadata storage meta = rateBufferMetadata[token];\\n\\n        // Initialize the buffers\\n        RateLibrary.Rate[] storage observationBuffer = rateBuffers[token];\\n\\n        for (uint256 i = 0; i < initialBufferCardinality; ++i) {\\n            observationBuffer.push();\\n        }\\n\\n        // Initialize the metadata\\n        meta.start = 0;\\n        meta.end = 0;\\n        meta.size = 0;\\n        meta.maxSize = initialBufferCardinality;\\n\\n        emit RatesCapacityInitialized(token, meta.maxSize);\\n    }\\n\\n    /**\\n     * @dev Internal function to push a new rate data into the rate buffer and update metadata accordingly.\\n     * @param token The token for which to push the new rate data.\\n     * @param rate The Rate struct containing target rate, current rate, and timestamp data to be pushed.\\n     */\\n    function push(address token, RateLibrary.Rate memory rate) internal virtual {\\n        BufferMetadata storage meta = rateBufferMetadata[token];\\n\\n        if (meta.size == 0) {\\n            if (meta.maxSize == 0) {\\n                // Initialize the buffers\\n                initializeBuffers(token);\\n            }\\n        } else {\\n            meta.end = (meta.end + 1) % meta.maxSize;\\n        }\\n\\n        rateBuffers[token][meta.end] = rate;\\n\\n        emit RateUpdated(token, rate.target, rate.current, block.timestamp);\\n\\n        if (meta.size < meta.maxSize && meta.end == meta.size) {\\n            // We are at the end of the array and we have not yet filled it\\n            meta.size++;\\n        } else {\\n            // start was just overwritten\\n            meta.start = (meta.start + 1) % meta.size;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rates/IHistoricalRates.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\nimport \\\"./RateLibrary.sol\\\";\\n\\n/**\\n * @title IHistoricalRates\\n * @notice An interface that defines a contract that stores historical rates.\\n */\\ninterface IHistoricalRates {\\n    /// @notice Gets an rate for a token at a specific index.\\n    /// @param token The address of the token to get the rates for.\\n    /// @param index The index of the rate to get, where index 0 contains the latest rate, and the last\\n    ///   index contains the oldest rate (uses reverse chronological ordering).\\n    /// @return rate The rate for the token at the specified index.\\n    function getRateAt(address token, uint256 index) external view returns (RateLibrary.Rate memory);\\n\\n    /// @notice Gets the latest rates for a token.\\n    /// @param token The address of the token to get the rates for.\\n    /// @param amount The number of rates to get.\\n    /// @return rates The latest rates for the token, in reverse chronological order, from newest to oldest.\\n    function getRates(address token, uint256 amount) external view returns (RateLibrary.Rate[] memory);\\n\\n    /// @notice Gets the latest rates for a token.\\n    /// @param token The address of the token to get the rates for.\\n    /// @param amount The number of rates to get.\\n    /// @param offset The index of the first rate to get (default: 0).\\n    /// @param increment The increment between rates to get (default: 1).\\n    /// @return rates The latest rates for the token, in reverse chronological order, from newest to oldest.\\n    function getRates(\\n        address token,\\n        uint256 amount,\\n        uint256 offset,\\n        uint256 increment\\n    ) external view returns (RateLibrary.Rate[] memory);\\n\\n    /// @notice Gets the number of rates for a token.\\n    /// @param token The address of the token to get the number of rates for.\\n    /// @return count The number of rates for the token.\\n    function getRatesCount(address token) external view returns (uint256);\\n\\n    /// @notice Gets the capacity of rates for a token.\\n    /// @param token The address of the token to get the capacity of rates for.\\n    /// @return capacity The capacity of rates for the token.\\n    function getRatesCapacity(address token) external view returns (uint256);\\n\\n    /// @notice Sets the capacity of rates for a token.\\n    /// @param token The address of the token to set the capacity of rates for.\\n    /// @param amount The new capacity of rates for the token.\\n    function setRatesCapacity(address token, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/rates/IRateComputer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\n/**\\n * @title IRateComputer\\n * @notice An interface that defines a contract that computes rates.\\n */\\ninterface IRateComputer {\\n    /// @notice Computes the rate for a token.\\n    /// @param token The address of the token to compute the rate for.\\n    /// @return rate The rate for the token.\\n    function computeRate(address token) external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"contracts/rates/RateController.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.8.13;\\n\\nimport \\\"@adrastia-oracle/adrastia-core/contracts/interfaces/IPeriodic.sol\\\";\\nimport \\\"@adrastia-oracle/adrastia-core/contracts/interfaces/IUpdateable.sol\\\";\\n\\nimport \\\"@openzeppelin-v4/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin-v4/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@openzeppelin-v4/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"./HistoricalRates.sol\\\";\\nimport \\\"./IRateComputer.sol\\\";\\n\\n/// @title RateController\\n/// @notice A contract that periodically computes and stores rates for tokens.\\n/// @dev This contract is abstract because it lacks restrictions on sensitive functions. Please override checkSetConfig,\\n/// checkSetUpdatesPaused, checkSetRatesCapacity, and checkUpdate to add restrictions.\\nabstract contract RateController is ERC165, HistoricalRates, IRateComputer, IUpdateable, IPeriodic {\\n    using SafeCast for uint256;\\n\\n    struct RateConfig {\\n        uint64 max;\\n        uint64 min;\\n        uint64 maxIncrease;\\n        uint64 maxDecrease;\\n        uint32 maxPercentIncrease; // 10000 = 100%\\n        uint16 maxPercentDecrease; // 10000 = 100%\\n        uint64 base;\\n        uint16[] componentWeights; // 10000 = 100%\\n        IRateComputer[] components;\\n    }\\n\\n    /// @notice The flag that indicates whether rate updates are paused.\\n    uint16 internal constant PAUSE_FLAG_MASK = 0x0000000000000001;\\n\\n    /// @notice The period of the rate controller, in seconds. This is the frequency at which rates are updated.\\n    uint256 public immutable override period;\\n\\n    /// @notice True if all rate updaters must be EOA accounts; false otherwise.\\n    /// @dev This is a security feature to prevent malicious contracts from updating rates.\\n    bool public immutable updatersMustBeEoa;\\n\\n    /// @notice Maps a token to its rate configuration.\\n    mapping(address => RateConfig) internal rateConfigs;\\n\\n    /// @notice Event emitted when a new rate is manually pushed to the rate buffer.\\n    /// @param token The token for which the rate was pushed.\\n    /// @param target The target rate.\\n    /// @param current The effective rate.\\n    /// @param timestamp The timestamp at which the rate was pushed.\\n    /// @param amount The amount of times the rate was pushed.\\n    event RatePushedManually(address indexed token, uint256 target, uint256 current, uint256 timestamp, uint256 amount);\\n\\n    /// @notice Event emitted when the pause status of rate updates for a token is changed.\\n    /// @param token The token for which the pause status of rate updates was changed.\\n    /// @param areUpdatesPaused Whether rate updates are paused for the token.\\n    event PauseStatusChanged(address indexed token, bool areUpdatesPaused);\\n\\n    /// @notice Event emitted when the rate configuration for a token is updated.\\n    /// @param token The token for which the rate configuration was updated.\\n    event RateConfigUpdated(address indexed token, RateConfig oldConfig, RateConfig newConfig);\\n\\n    /// @notice An error that is thrown if we try to set a rate configuration with invalid parameters.\\n    /// @param token The token for which we tried to set the rate configuration.\\n    error InvalidConfig(address token);\\n\\n    /// @notice An error that is thrown if we require a rate configuration that has not been set.\\n    /// @param token The token for which we require a rate configuration.\\n    error MissingConfig(address token);\\n\\n    /// @notice An error that is thrown if we require that all rate updaters be EOA accounts, but the updater is not.\\n    /// @param txOrigin The address of the transaction origin.\\n    /// @param updater The address of the rate updater.\\n    error UpdaterMustBeEoa(address txOrigin, address updater);\\n\\n    /// @notice Creates a new rate controller.\\n    /// @param period_ The period of the rate controller, in seconds. This is the frequency at which rates are updated.\\n    /// @param initialBufferCardinality_ The initial capacity of the rate buffer.\\n    /// @param updatersMustBeEoa_ True if all rate updaters must be EOA accounts; false otherwise.\\n    constructor(\\n        uint32 period_,\\n        uint8 initialBufferCardinality_,\\n        bool updatersMustBeEoa_\\n    ) HistoricalRates(initialBufferCardinality_) {\\n        period = period_;\\n        updatersMustBeEoa = updatersMustBeEoa_;\\n    }\\n\\n    /// @notice Returns the rate configuration for a token.\\n    /// @param token The token for which to get the rate configuration.\\n    /// @return The rate configuration for the token.\\n    function getConfig(address token) external view virtual returns (RateConfig memory) {\\n        BufferMetadata memory meta = rateBufferMetadata[token];\\n        if (meta.maxSize == 0) {\\n            revert MissingConfig(token);\\n        }\\n\\n        return rateConfigs[token];\\n    }\\n\\n    /// @notice Sets the rate configuration for a token. This can only be called by the rate admin.\\n    /// @param token The token for which to set the rate configuration.\\n    /// @param config The rate configuration to set.\\n    function setConfig(address token, RateConfig calldata config) external virtual {\\n        checkSetConfig();\\n\\n        if (config.components.length != config.componentWeights.length) {\\n            revert InvalidConfig(token);\\n        }\\n\\n        if (config.maxPercentDecrease > 10000) {\\n            // The maximum percent decrease must be less than or equal to 100%.\\n            revert InvalidConfig(token);\\n        }\\n\\n        if (config.max < config.min) {\\n            // The maximum rate must be greater than or equal to the minimum rate.\\n            revert InvalidConfig(token);\\n        }\\n\\n        // Ensure that the sum of the component weights less than or equal to 10000 (100%)\\n        // Notice: It's possible to have the sum of the component weights be less than 10000 (100%). It's also possible\\n        // to have the component weights be 100% and the base rate be non-zero. This is intentional because we don't\\n        // have a hard cap on the rate.\\n        uint256 sum = 0;\\n        for (uint256 i = 0; i < config.componentWeights.length; ++i) {\\n            if (\\n                address(config.components[i]) == address(0) ||\\n                !ERC165Checker.supportsInterface(address(config.components[i]), type(IRateComputer).interfaceId)\\n            ) {\\n                revert InvalidConfig(token);\\n            }\\n\\n            sum += config.componentWeights[i];\\n        }\\n        if (sum > 10000) {\\n            revert InvalidConfig(token);\\n        }\\n\\n        // Ensure that the base rate plus the sum of the maximum component rates won't overflow\\n        if (uint256(config.base) + ((sum * type(uint64).max) / 10000) > type(uint64).max) {\\n            revert InvalidConfig(token);\\n        }\\n\\n        RateConfig memory oldConfig = rateConfigs[token];\\n\\n        rateConfigs[token] = config;\\n\\n        emit RateConfigUpdated(token, oldConfig, config);\\n\\n        BufferMetadata memory meta = rateBufferMetadata[token];\\n        if (meta.maxSize == 0) {\\n            // We require that the buffer is initialized before allowing rate updates to occur\\n            initializeBuffers(token);\\n        }\\n    }\\n\\n    /// @notice Manually pushes new rates for a token, bypassing the update logic, clamp logic, pause logic, and\\n    /// other restrictions.\\n    /// @dev WARNING: This function is very powerful and should only be used in emergencies. It is intended to be used\\n    /// to manually push rates when the rate controller is in a bad state. It should not be used to push rates\\n    /// regularly. Make sure to lock it down with the highest level of security.\\n    /// @param token The token for which to push rates.\\n    /// @param target The target rate to push.\\n    /// @param current The current rate to push.\\n    /// @param amount The number of times to push the rate.\\n    function manuallyPushRate(address token, uint64 target, uint64 current, uint256 amount) external {\\n        checkManuallyPushRate();\\n\\n        BufferMetadata storage meta = rateBufferMetadata[token];\\n        if (meta.maxSize == 0) {\\n            // Uninitialized buffer means that the rate config is missing\\n            revert MissingConfig(token);\\n        }\\n\\n        // Note: We don't check the pause status here because we want to allow rate updates to be manually pushed even\\n        // if rate updates are paused.\\n\\n        RateLibrary.Rate memory rate = RateLibrary.Rate({\\n            target: target,\\n            current: current,\\n            timestamp: uint32(block.timestamp)\\n        });\\n\\n        for (uint256 i = 0; i < amount; ++i) {\\n            push(token, rate);\\n        }\\n\\n        if (amount > 0) {\\n            emit RatePushedManually(token, target, current, block.timestamp, amount);\\n        }\\n    }\\n\\n    /// @notice Determines whether rate updates are paused for a token.\\n    /// @param token The token for which to determine whether rate updates are paused.\\n    /// @return Whether rate updates are paused for the given token.\\n    function areUpdatesPaused(address token) external view virtual returns (bool) {\\n        return _areUpdatesPaused(token);\\n    }\\n\\n    /// @notice Changes the pause state of rate updates for a token. This can only be called by the update pause admin.\\n    /// @param token The token for which to change the pause state.\\n    /// @param paused Whether rate updates should be paused.\\n    function setUpdatesPaused(address token, bool paused) external virtual {\\n        checkSetUpdatesPaused();\\n\\n        BufferMetadata storage meta = rateBufferMetadata[token];\\n        if (meta.maxSize == 0) {\\n            // Uninitialized buffer means that the rate config is missing\\n            // It doesn't make sense to pause updates if they can't occur in the first place\\n            revert MissingConfig(token);\\n        }\\n\\n        uint16 flags = rateBufferMetadata[token].flags;\\n\\n        bool currentlyPaused = (flags & PAUSE_FLAG_MASK) != 0;\\n        if (currentlyPaused != paused) {\\n            if (paused) {\\n                flags |= PAUSE_FLAG_MASK;\\n            } else {\\n                flags &= ~PAUSE_FLAG_MASK;\\n            }\\n\\n            rateBufferMetadata[token].flags = flags;\\n\\n            emit PauseStatusChanged(token, paused);\\n\\n            onPaused(token, paused);\\n        }\\n    }\\n\\n    /// @inheritdoc IRateComputer\\n    function computeRate(address token) external view virtual override returns (uint64) {\\n        (, uint64 newRate) = computeRateAndClamp(token);\\n\\n        return newRate;\\n    }\\n\\n    /// @inheritdoc IPeriodic\\n    function granularity() external view virtual override returns (uint256) {\\n        return 1;\\n    }\\n\\n    /// @inheritdoc IUpdateable\\n    function update(bytes memory data) public virtual override returns (bool b) {\\n        checkUpdate();\\n\\n        if (needsUpdate(data)) return performUpdate(data);\\n\\n        return false;\\n    }\\n\\n    /// @inheritdoc IUpdateable\\n    function needsUpdate(bytes memory data) public view virtual override returns (bool b) {\\n        address token = abi.decode(data, (address));\\n\\n        BufferMetadata memory meta = rateBufferMetadata[token];\\n\\n        // Requires that:\\n        //   0. The update period has elapsed.\\n        //   1. The buffer is initialized. We do this to prevent zero values from being pushed to the buffer.\\n        //   2. Updates are not paused.\\n        //   3. Something will change. Otherwise, updating is a waste of gas.\\n        return\\n            timeSinceLastUpdate(data) >= period &&\\n            meta.maxSize > 0 &&\\n            !_areUpdatesPaused(token) &&\\n            willAnythingChange(data);\\n    }\\n\\n    /// @inheritdoc IUpdateable\\n    function canUpdate(bytes memory data) public view virtual override returns (bool b) {\\n        return\\n            // Can only update if the update is needed\\n            needsUpdate(data) &&\\n            // Can only update if the sender is an EOA or the contract allows EOA updates\\n            (!updatersMustBeEoa || msg.sender == tx.origin);\\n    }\\n\\n    /// @inheritdoc IUpdateable\\n    function lastUpdateTime(bytes memory data) public view virtual override returns (uint256) {\\n        address token = abi.decode(data, (address));\\n\\n        return getLatestRate(token).timestamp;\\n    }\\n\\n    /// @inheritdoc IUpdateable\\n    function timeSinceLastUpdate(bytes memory data) public view virtual override returns (uint256) {\\n        return block.timestamp - lastUpdateTime(data);\\n    }\\n\\n    /// @inheritdoc ERC165\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IHistoricalRates).interfaceId ||\\n            interfaceId == type(IRateComputer).interfaceId ||\\n            interfaceId == type(IUpdateable).interfaceId ||\\n            interfaceId == type(IPeriodic).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Internal function to set the capacity of the rate buffer for a token. Only callable by the admin because the\\n     * updating logic is O(n) on the capacity. Only callable when the rate config is set.\\n     * @param token The token for which to set the new capacity.\\n     * @param amount The new capacity of rates for the token. Must be greater than the current capacity, but\\n     * less than 256.\\n     */\\n    function _setRatesCapacity(address token, uint256 amount) internal virtual override {\\n        checkSetRatesCapacity();\\n\\n        BufferMetadata storage meta = rateBufferMetadata[token];\\n        if (meta.maxSize == 0) {\\n            // Buffer is not initialized yet\\n            // Buffer can only be initialized when the rate config is set\\n            revert MissingConfig(token);\\n        }\\n\\n        super._setRatesCapacity(token, amount);\\n    }\\n\\n    /// @notice Determines if rate updates are paused for a token.\\n    /// @return bool A boolean value indicating whether rate updates are paused for the given token.\\n    function _areUpdatesPaused(address token) internal view virtual returns (bool) {\\n        return (rateBufferMetadata[token].flags & PAUSE_FLAG_MASK) != 0;\\n    }\\n\\n    /// @notice Determines if any changes will occur in the rate buffer after a new rate is added.\\n    /// @dev This function is used to reduce the amount of gas used by updaters when the rate is not changing.\\n    /// @param data A bytes array containing the token address to be decoded.\\n    /// @return bool A boolean value indicating whether any changes will occur in the rate buffer.\\n    function willAnythingChange(bytes memory data) internal view virtual returns (bool) {\\n        address token = abi.decode(data, (address));\\n\\n        BufferMetadata memory meta = rateBufferMetadata[token];\\n\\n        // If the buffer has empty slots, they can be filled\\n        if (meta.size != meta.maxSize) return true;\\n\\n        // All current rates in the buffer should match the next rate. Otherwise, the rate will change.\\n        // We don't check target rates because if the rate is capped, the current rate may never reach the target rate.\\n        (, uint64 nextRate) = computeRateAndClamp(token);\\n        RateLibrary.Rate[] memory rates = _getRates(token, meta.size, 0, 1);\\n        for (uint256 i = 0; i < rates.length; ++i) {\\n            if (rates[i].current != nextRate) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Gets the latest rate for a token. If the buffer is empty, returns a zero rate.\\n    /// @param token The token to get the latest rate for.\\n    /// @return The latest rate for the token, or a zero rate if the buffer is empty.\\n    function getLatestRate(address token) internal view virtual returns (RateLibrary.Rate memory) {\\n        BufferMetadata storage meta = rateBufferMetadata[token];\\n\\n        if (meta.size == 0) {\\n            // If the buffer is empty, return the default (zero) rate\\n            return RateLibrary.Rate({target: 0, current: 0, timestamp: 0});\\n        }\\n\\n        return rateBuffers[token][meta.end];\\n    }\\n\\n    /// @notice Computes the rate for the given token.\\n    /// @dev This function calculates the rate for the specified token by summing its base rate\\n    /// and the weighted rates of its components. The component rates are computed using the `computeRate`\\n    /// function of each component and multiplied by the corresponding weight, then divided by 10,000.\\n    /// @param token The address of the token for which to compute the rate.\\n    /// @return uint64 The computed rate for the given token.\\n    function computeRateInternal(address token) internal view virtual returns (uint64) {\\n        RateConfig memory config = rateConfigs[token];\\n\\n        uint64 rate = config.base;\\n\\n        for (uint256 i = 0; i < config.componentWeights.length; ++i) {\\n            uint64 componentRate = ((uint256(config.components[i].computeRate(token)) * config.componentWeights[i]) /\\n                10000).toUint64();\\n\\n            rate += componentRate;\\n        }\\n\\n        return rate;\\n    }\\n\\n    /// @notice Computes the target rate and clamps it based on the specified token's rate configuration.\\n    /// @dev This function calculates the target rate by calling `computeRateInternal`. It then clamps the new rate\\n    /// to ensure it is within the specified bounds for maximum constant and percentage increases or decreases.\\n    /// This helps to prevent sudden or extreme rate fluctuations.\\n    /// @param token The address of the token for which to compute the clamped rate.\\n    /// @return target The computed target rate for the given token.\\n    /// @return newRate The clamped rate for the given token, taking into account the maximum increase and decrease\\n    /// constraints.\\n    function computeRateAndClamp(address token) internal view virtual returns (uint64 target, uint64 newRate) {\\n        // Compute the target rate\\n        target = computeRateInternal(token);\\n        // Clamp it\\n        newRate = clamp(token, target);\\n    }\\n\\n    /// @notice Clamps a rate based on the specified token's rate configuration, with respect to the provided last rate\\n    ///   if clampChange is true.\\n    /// @dev Clamps the new rate to ensure it is within the specified bounds for maximum constant and percentage\\n    /// increases or decreases. This helps to prevent sudden or extreme rate fluctuations.\\n    /// @param token The address of the token for which to compute the clamped rate.\\n    /// @param target The computed target rate for the given token.\\n    /// @param clampChange Whether to clamp the rate change. If false, only min and max are used.\\n    /// @param last The last rate for the given token. Ignored if clampChange is false.\\n    /// @return newRate The clamped rate for the given token, taking into account the maximum increase and decrease\\n    /// constraints.\\n    function clampWrtLast(\\n        address token,\\n        uint64 target,\\n        bool clampChange,\\n        uint64 last\\n    ) internal view virtual returns (uint64 newRate) {\\n        newRate = target;\\n\\n        RateConfig memory config = rateConfigs[token];\\n\\n        // Clamp the rate to the minimum and maximum rates\\n        // We do this before clamping the rate to the maximum constant and percentage increases or decreases because\\n        // we don't want a change in the minimum or maximum rate to cause a sudden change in the rate.\\n        if (newRate < config.min) {\\n            // The new rate is too low, so we change it to the minimum rate\\n            newRate = config.min;\\n        } else if (newRate > config.max) {\\n            // The new rate is too high, so we change it to the maximum rate\\n            newRate = config.max;\\n        }\\n\\n        if (clampChange) {\\n            // We have a previous rate, so let's make sure we don't change it too much\\n            if (newRate > last) {\\n                // Clamp the rate to the maximum constant increase\\n                if (newRate - last > config.maxIncrease) {\\n                    // The new rate is too high, so we change it by the maximum increase\\n                    newRate = last + config.maxIncrease;\\n                }\\n\\n                if (last == 0 && config.maxPercentIncrease > 0) {\\n                    // If the last rate was zero, we don't want to clamp the rate to the maximum percentage increase\\n                    // because that would prevent the rate from ever increasing. Instead, we clamp it to the maximum\\n                    // constant increase, without taking into account the maximum percentage increase.\\n                    return newRate;\\n                }\\n                // Clamp the rate to the maximum percentage increase\\n                uint256 maxIncreaseAbsolute = (uint256(last) * config.maxPercentIncrease) / 10000;\\n                if (newRate - last > maxIncreaseAbsolute) {\\n                    // The new rate is too high, so we change it by the maximum percentage increase\\n                    newRate = last + uint64(maxIncreaseAbsolute);\\n                }\\n            } else if (newRate < last) {\\n                // Clamp the rate to the maximum constant decrease\\n                if (last - newRate > config.maxDecrease) {\\n                    // The new rate is too low, so we change it by the maximum decrease\\n                    newRate = last - config.maxDecrease;\\n                }\\n\\n                // Clamp the rate to the maximum percentage decrease\\n                uint256 maxDecreaseAbsolute = (uint256(last) * config.maxPercentDecrease) / 10000;\\n                if (last - newRate > maxDecreaseAbsolute) {\\n                    // The new rate is too low, so we change it by the maximum percentage decrease\\n                    newRate = last - uint64(maxDecreaseAbsolute);\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Clamps a rate based on the specified token's rate configuration.\\n    /// @dev Clamps the new rate to ensure it is within the specified bounds for maximum constant and percentage\\n    /// increases or decreases. This helps to prevent sudden or extreme rate fluctuations.\\n    /// @param token The address of the token for which to compute the clamped rate.\\n    /// @param target The computed target rate for the given token.\\n    /// @return newRate The clamped rate for the given token, taking into account the maximum increase and decrease\\n    /// constraints.\\n    function clamp(address token, uint64 target) internal view virtual returns (uint64 newRate) {\\n        BufferMetadata memory meta = rateBufferMetadata[token];\\n        if (meta.size > 0) {\\n            // We have a previous rate, so let's make sure we don't change it too much\\n            uint64 last = rateBuffers[token][meta.end].current;\\n\\n            return clampWrtLast(token, target, true, last);\\n        } else {\\n            // We don't have a previous rate, so we don't need to clamp the rate change\\n            return clampWrtLast(token, target, false, 0);\\n        }\\n    }\\n\\n    function updateAndCompute(address token) internal virtual returns (uint64 target, uint64 newRate) {\\n        // Compute the new rate and clamp it\\n        (target, newRate) = computeRateAndClamp(token);\\n    }\\n\\n    /// @notice Performs an update of the token's rate based on the provided data.\\n    /// @dev This function ensures that only EOAs (Externally Owned Accounts) can update the rate\\n    /// if `updatersMustBeEoa` is set to true. It decodes the token address from the input data, computes\\n    /// the new clamped rate using `computeRateAndClamp`, and then pushes the new rate to the rate buffer.\\n    /// @param data The input data, containing the token address to be updated.\\n    /// @return bool Returns true if the update is successful.\\n    function performUpdate(bytes memory data) internal virtual returns (bool) {\\n        if (updatersMustBeEoa && msg.sender != tx.origin) {\\n            // Only EOA can update\\n            revert UpdaterMustBeEoa(tx.origin, msg.sender);\\n        }\\n\\n        address token = abi.decode(data, (address));\\n\\n        // Compute the new rates and do any other necessary work\\n        (uint64 target, uint64 newRate) = updateAndCompute(token);\\n\\n        // Push the new rate\\n        push(token, RateLibrary.Rate({target: target, current: newRate, timestamp: uint32(block.timestamp)}));\\n\\n        return true;\\n    }\\n\\n    /// @notice Called after the pause state is changed.\\n    /// @param token The token for which the pause state was changed.\\n    /// @param paused Whether rate updates are paused.\\n    function onPaused(address token, bool paused) internal virtual {}\\n\\n    /// @notice Checks if the caller is authorized to set the configuration.\\n    /// @dev This function should contain the access control logic for the setConfig function.\\n    function checkSetConfig() internal view virtual;\\n\\n    /// @notice Checks if the caller is authorized to manually push rates.\\n    /// @dev This function should contain the access control logic for the manuallyPushRate function.\\n    /// WARNING: The manuallyPushRate function is very dangerous and should only be used in emergencies. Ensure that\\n    /// this function is implemented correctly and that the access control logic is sufficient to prevent abuse.\\n    function checkManuallyPushRate() internal view virtual;\\n\\n    /// @notice Checks if the caller is authorized to pause or resume updates.\\n    /// @dev This function should contain the access control logic for the setUpdatesPaused function.\\n    function checkSetUpdatesPaused() internal view virtual;\\n\\n    /// @notice Checks if the caller is authorized to set the rates capacity.\\n    /// @dev This function should contain the access control logic for the setRatesCapacity function.\\n    function checkSetRatesCapacity() internal view virtual;\\n\\n    /// @notice Checks if the caller is authorized to perform an update.\\n    /// @dev This function should contain the access control logic for the update function.\\n    function checkUpdate() internal view virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/rates/RateLibrary.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nlibrary RateLibrary {\\n    struct Rate {\\n        uint64 target;\\n        uint64 current;\\n        uint32 timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/aave/AaveV3EngineFlags.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary EngineFlags {\\n    /// @dev magic value to be used as flag to keep unchanged any current configuration\\n    /// Strongly assumes that the value `type(uint256).max - 42` will never be used, which seems reasonable\\n    uint256 internal constant KEEP_CURRENT = type(uint256).max - 42;\\n\\n    /// @dev value to be used as flag for bool value true\\n    uint256 internal constant ENABLED = 1;\\n\\n    /// @dev value to be used as flag for bool value false\\n    uint256 internal constant DISABLED = 0;\\n\\n    /// @dev converts flag ENABLED DISABLED to bool\\n    function toBool(uint256 flag) internal pure returns (bool) {\\n        require(flag == 0 || flag == 1, \\\"INVALID_CONVERSION_TO_BOOL\\\");\\n        return flag == 1;\\n    }\\n\\n    /// @dev converts bool to ENABLED DISABLED flags\\n    function fromBool(bool isTrue) internal pure returns (uint256) {\\n        return isTrue ? ENABLED : DISABLED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/aave/IAaveV3ConfigEngine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAaveV3ConfigEngine {\\n    /**\\n     * @dev Example (mock):\\n     * CapsUpdate({\\n     *   asset: AaveV3EthereumAssets.AAVE_UNDERLYING,\\n     *   supplyCap: 1_000_000,\\n     *   borrowCap: EngineFlags.KEEP_CURRENT\\n     * }\\n     */\\n    struct CapsUpdate {\\n        address asset;\\n        uint256 supplyCap; // Pass any value, of EngineFlags.KEEP_CURRENT to keep it as it is\\n        uint256 borrowCap; // Pass any value, of EngineFlags.KEEP_CURRENT to keep it as it is\\n    }\\n\\n    /**\\n     * @notice Performs an update of the caps (supply, borrow) of the assets, in the Aave pool configured in this engine instance\\n     * @param updates `CapsUpdate[]` list of declarative updates containing the new caps\\n     *   More information on the documentation of the struct.\\n     */\\n    function updateCaps(CapsUpdate[] memory updates) external;\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/aave/IACLManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IACLManager\\n * @author Aave\\n * @notice Defines the basic interface for the ACL Manager\\n */\\ninterface IACLManager {\\n    /**\\n     * @notice Returns the contract address of the PoolAddressesProvider\\n     * @return The address of the PoolAddressesProvider\\n     */\\n    function ADDRESSES_PROVIDER() external view returns (address);\\n\\n    /**\\n     * @notice Returns the identifier of the PoolAdmin role\\n     * @return The id of the PoolAdmin role\\n     */\\n    function POOL_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the identifier of the EmergencyAdmin role\\n     * @return The id of the EmergencyAdmin role\\n     */\\n    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the identifier of the RiskAdmin role\\n     * @return The id of the RiskAdmin role\\n     */\\n    function RISK_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the identifier of the FlashBorrower role\\n     * @return The id of the FlashBorrower role\\n     */\\n    function FLASH_BORROWER_ROLE() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the identifier of the Bridge role\\n     * @return The id of the Bridge role\\n     */\\n    function BRIDGE_ROLE() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the identifier of the AssetListingAdmin role\\n     * @return The id of the AssetListingAdmin role\\n     */\\n    function ASSET_LISTING_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /**\\n     * @notice Set the role as admin of a specific role.\\n     * @dev By default the admin role for all roles is `DEFAULT_ADMIN_ROLE`.\\n     * @param role The role to be managed by the admin role\\n     * @param adminRole The admin role\\n     */\\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\\n\\n    /**\\n     * @notice Adds a new admin as PoolAdmin\\n     * @param admin The address of the new admin\\n     */\\n    function addPoolAdmin(address admin) external;\\n\\n    /**\\n     * @notice Removes an admin as PoolAdmin\\n     * @param admin The address of the admin to remove\\n     */\\n    function removePoolAdmin(address admin) external;\\n\\n    /**\\n     * @notice Returns true if the address is PoolAdmin, false otherwise\\n     * @param admin The address to check\\n     * @return True if the given address is PoolAdmin, false otherwise\\n     */\\n    function isPoolAdmin(address admin) external view returns (bool);\\n\\n    /**\\n     * @notice Adds a new admin as EmergencyAdmin\\n     * @param admin The address of the new admin\\n     */\\n    function addEmergencyAdmin(address admin) external;\\n\\n    /**\\n     * @notice Removes an admin as EmergencyAdmin\\n     * @param admin The address of the admin to remove\\n     */\\n    function removeEmergencyAdmin(address admin) external;\\n\\n    /**\\n     * @notice Returns true if the address is EmergencyAdmin, false otherwise\\n     * @param admin The address to check\\n     * @return True if the given address is EmergencyAdmin, false otherwise\\n     */\\n    function isEmergencyAdmin(address admin) external view returns (bool);\\n\\n    /**\\n     * @notice Adds a new admin as RiskAdmin\\n     * @param admin The address of the new admin\\n     */\\n    function addRiskAdmin(address admin) external;\\n\\n    /**\\n     * @notice Removes an admin as RiskAdmin\\n     * @param admin The address of the admin to remove\\n     */\\n    function removeRiskAdmin(address admin) external;\\n\\n    /**\\n     * @notice Returns true if the address is RiskAdmin, false otherwise\\n     * @param admin The address to check\\n     * @return True if the given address is RiskAdmin, false otherwise\\n     */\\n    function isRiskAdmin(address admin) external view returns (bool);\\n\\n    /**\\n     * @notice Adds a new address as FlashBorrower\\n     * @param borrower The address of the new FlashBorrower\\n     */\\n    function addFlashBorrower(address borrower) external;\\n\\n    /**\\n     * @notice Removes an address as FlashBorrower\\n     * @param borrower The address of the FlashBorrower to remove\\n     */\\n    function removeFlashBorrower(address borrower) external;\\n\\n    /**\\n     * @notice Returns true if the address is FlashBorrower, false otherwise\\n     * @param borrower The address to check\\n     * @return True if the given address is FlashBorrower, false otherwise\\n     */\\n    function isFlashBorrower(address borrower) external view returns (bool);\\n\\n    /**\\n     * @notice Adds a new address as Bridge\\n     * @param bridge The address of the new Bridge\\n     */\\n    function addBridge(address bridge) external;\\n\\n    /**\\n     * @notice Removes an address as Bridge\\n     * @param bridge The address of the bridge to remove\\n     */\\n    function removeBridge(address bridge) external;\\n\\n    /**\\n     * @notice Returns true if the address is Bridge, false otherwise\\n     * @param bridge The address to check\\n     * @return True if the given address is Bridge, false otherwise\\n     */\\n    function isBridge(address bridge) external view returns (bool);\\n\\n    /**\\n     * @notice Adds a new admin as AssetListingAdmin\\n     * @param admin The address of the new admin\\n     */\\n    function addAssetListingAdmin(address admin) external;\\n\\n    /**\\n     * @notice Removes an admin as AssetListingAdmin\\n     * @param admin The address of the admin to remove\\n     */\\n    function removeAssetListingAdmin(address admin) external;\\n\\n    /**\\n     * @notice Returns true if the address is AssetListingAdmin, false otherwise\\n     * @param admin The address to check\\n     * @return True if the given address is AssetListingAdmin, false otherwise\\n     */\\n    function isAssetListingAdmin(address admin) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IAaveV3ConfigEngine\",\"name\":\"configEngine_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"forSupplyCaps_\",\"type\":\"bool\"},{\"internalType\":\"contract IACLManager\",\"name\":\"aclManager_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"period_\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"initialBufferCardinality_\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"updatersMustBeEoa_\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"BufferAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentCapacity\",\"type\":\"uint256\"}],\"name\":\"CapacityCannotBeDecreased\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCapacity\",\"type\":\"uint256\"}],\"name\":\"CapacityTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSizeRequired\",\"type\":\"uint256\"}],\"name\":\"InsufficientData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"InvalidConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"InvalidIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"MissingConfig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"requiredRole\",\"type\":\"bytes32\"}],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"txOrigin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"UpdaterMustBeEoa\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldChangeThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newChangeThreshold\",\"type\":\"uint256\"}],\"name\":\"ChangeThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"areUpdatesPaused\",\"type\":\"bool\"}],\"name\":\"PauseStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"min\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxIncrease\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxDecrease\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"maxPercentIncrease\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"maxPercentDecrease\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"base\",\"type\":\"uint64\"},{\"internalType\":\"uint16[]\",\"name\":\"componentWeights\",\"type\":\"uint16[]\"},{\"internalType\":\"contract IRateComputer[]\",\"name\":\"components\",\"type\":\"address[]\"}],\"indexed\":false,\"internalType\":\"struct RateController.RateConfig\",\"name\":\"oldConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"min\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxIncrease\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxDecrease\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"maxPercentIncrease\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"maxPercentDecrease\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"base\",\"type\":\"uint64\"},{\"internalType\":\"uint16[]\",\"name\":\"componentWeights\",\"type\":\"uint16[]\"},{\"internalType\":\"contract IRateComputer[]\",\"name\":\"components\",\"type\":\"address[]\"}],\"indexed\":false,\"internalType\":\"struct RateController.RateConfig\",\"name\":\"newConfig\",\"type\":\"tuple\"}],\"name\":\"RateConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RatePushedManually\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCapacity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCapacity\",\"type\":\"uint256\"}],\"name\":\"RatesCapacityIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"capacity\",\"type\":\"uint256\"}],\"name\":\"RatesCapacityInitialized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHANGE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aclManager\",\"outputs\":[{\"internalType\":\"contract IACLManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"areUpdatesPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"canUpdate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"computeRate\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configEngine\",\"outputs\":[{\"internalType\":\"contract IAaveV3ConfigEngine\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forSupplyCaps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getChangeThreshold\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"min\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxIncrease\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxDecrease\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"maxPercentIncrease\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"maxPercentDecrease\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"base\",\"type\":\"uint64\"},{\"internalType\":\"uint16[]\",\"name\":\"componentWeights\",\"type\":\"uint16[]\"},{\"internalType\":\"contract IRateComputer[]\",\"name\":\"components\",\"type\":\"address[]\"}],\"internalType\":\"struct RateController.RateConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRateAt\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"target\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"current\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct RateLibrary.Rate\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"increment\",\"type\":\"uint256\"}],\"name\":\"getRates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"target\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"current\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct RateLibrary.Rate[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getRates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"target\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"current\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct RateLibrary.Rate[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getRatesCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getRatesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"target\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"current\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manuallyPushRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"needsUpdate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"changeThreshold\",\"type\":\"uint32\"}],\"name\":\"setChangeThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"min\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxIncrease\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxDecrease\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"maxPercentIncrease\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"maxPercentDecrease\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"base\",\"type\":\"uint64\"},{\"internalType\":\"uint16[]\",\"name\":\"componentWeights\",\"type\":\"uint16[]\"},{\"internalType\":\"contract IRateComputer[]\",\"name\":\"components\",\"type\":\"address[]\"}],\"internalType\":\"struct RateController.RateConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setRatesCapacity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"setUpdatesPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"timeSinceLastUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"update\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatersMustBeEoa\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AaveCapController", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "0000000000000000000000007edc9806db4cda54681cfe09d31d12341eafb67500000000000000000000000000000000000000000000000000000000000000000000000000000000000000005f77fceab2fdf1839f00453ede3e884810f51146000000000000000000000000000000000000000000000000000000000001518000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}