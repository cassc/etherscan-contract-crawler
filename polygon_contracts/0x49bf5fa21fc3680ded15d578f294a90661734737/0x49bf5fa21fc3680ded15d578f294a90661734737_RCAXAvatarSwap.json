{"SourceCode": "// File: libraries/AvatarContracts.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\nlibrary AvatarContracts {\r\n    function getAwwDripMemeSinguContracts() public pure returns (address[4] memory) {\r\n        address[4] memory AWW_DRIP_MEME_SINGU_CONTRACTS = [\r\n            0x6acB8fb82880d39c2B8446F8778A14d34Ee6cFb7,\r\n            0xbfd670667053e517a97AFE56C91e4f83f1160Bd3,\r\n            0xb9C042c3275BC49799688EEA1A29b1405D02946B,\r\n            0x466a330887bDF62D53f968EA824793150f07762e\r\n        ];\r\n\r\n        return AWW_DRIP_MEME_SINGU_CONTRACTS;\r\n    }\r\n\r\n    function getAvatarGen1Contracts() public pure returns (address[29] memory) {\r\n        address[29] memory GEN_1_CONTRACTS = [\r\n            0x8D0501d85becDA92B89E56177dDfcEA5Fc1f0AF2,\r\n            0x5846728730366d686CdC95dae80a70b44Ec9eAb2,\r\n            0xfbEd9640e37666fe2AC78e1d263670976354Cb69,\r\n            0xe0743141DF04a6B9f3dF890429cC994e46DB03D9,\r\n            0x97439Ee4c93Ff9f76417696cE648aa6f35AB3B25,\r\n            0xf43bc3f4F1edb7d4C373C8510A2888d69d83cEB7,\r\n            0x425bf054Ef7bAD65B7BDd8E6587B1c3500E4F4CA,\r\n            0x2956409293da98603025Cc0121C06A4244752039,\r\n            0xa7Bb50d90B43752199c45Be04053641C3cb5f53f,\r\n            0x47749C5B970e63F3a0ed57Cd6ceF773E74FaFe9d,\r\n            0x838c1CD42929543daF9C3ef294Fee8c1b3224B37,\r\n            0xC5Aa1F91b0d52e26D2847f8e51f505d6e2ECe795,\r\n            0xeE1Ee80338958fA596471CEb70F0177DafF80323,\r\n            0x4670e4890Bc1b76F3aE5c7660aA98E0B6668C6F3,\r\n            0x2D58a44d6c0A355de25761fB33A1f6269A97e2C5,\r\n            0xD8cF23bF309DE778609d234BD2410B0156118c26,\r\n            0x91E51B92a2EfEA89bF1B6f66ad719737264724bE,\r\n            0xd6261320F49d38c137f6e229a2EA4Ab0F4Fae6DE,\r\n            0xFC190440E8f357fFE8A75940e7D8A291E165d019,\r\n            0x808ED3E23aac685126524aA4416d8eaeB2E767B9,\r\n            0x65a83530Ca8abc27969907913Fe5E641a5DA2e9f,\r\n            0x6d1c3646e8Cce8537E6ec9eCAb26762bfAf1f891,\r\n            0x63e2f0C058Ce9A194eC68F04320b7Eb8cA555BD3,\r\n            0x45308788743bBDAe5DE7ba9e565c0502d0EBb81F,\r\n            0x907808732079863886443057C65827a0F1c64357,\r\n            0x6ad08588568E258b2BdF065e7769FCE398F68A1C,\r\n            0x946aD8E53db653053E8ef7C02DFCA83ce8bA8022,\r\n            0x27B37E4Befacc50B02102d1E2117c4EA8A54bEFf,\r\n            0x71DC46607F31f30510f0ccc670B0963F431b212A\r\n        ];\r\n\r\n        return GEN_1_CONTRACTS;\r\n    }\r\n\r\n    function getAvatarGen2Contracts() public pure returns (address[27] memory) {\r\n        address[27] memory GEN_2_CONTRACTS = [\r\n            0xE4989961ebFDAc3E65Fcf0059c916452C77D8503,\r\n            0x621CE7e7E44d43A428A183D5390c4F4572C9ff9d,\r\n            0x04F7a676Af597F847053B6c02ED42D02fa4046Aa,\r\n            0xE1b5E23FdBC003Aec16E6E79726A0b5f75ff93f5,\r\n            0x8264E2bad3d2f7aFD72a00233b9f841Fe4b388Cd,\r\n            0x334Ad326A787dD332f26CbE8B4d7ADfA8bD25F92,\r\n            0xD5ae5A16fBAf964f96E242645a4a6F10b98fD0C4,\r\n            0x04f087e3191d7a050800A2e04cb20046D2633E35,\r\n            0x37dB2523D221d19838632Eb62d1af911e52632C3,\r\n            0x21d426e2B88Fbf8b93adf0591A2D5B08d58F089f,\r\n            0x91aC106090fE2b0Fa7d01efdf4487a5bfAfAd7FA,\r\n            0xBC096988fa38c78D65C0637453fd3D3C38B1CfD4,\r\n            0x150AfA2DfCaAadA471472dFA6Ad4b79E718A197c,\r\n            0x5Fd4D6fEF3b87B91c7DF8658727b5Edd7210cF5a,\r\n            0x2E90e8AF4C319095942C84cFA446E1f206795517,\r\n            0x3e4627665Bf2E52c69bE03788e664Ab545F2be71,\r\n            0x45EE1CAeD83525673843321107bccaDecb9065D7,\r\n            0xdAA6e4bA2D4022ED820460BB501B9E061D9614fB,\r\n            0x83fEEA011BAEB1C6d1df7D23903efaD83d3C781F,\r\n            0x81BA34b90876F42F34a4f232CfC0FE4b6ec949a3,\r\n            0xdDbDB65138131DBf2d01b4a5140E1979680c90Bb,\r\n            0xFeC90bc707Fc93AeFeb0C18c2Eb56bc79d32163e,\r\n            0x04125a97a0F2583CD485BE2C34b651cC13c38A27,\r\n            0x7E680862c572e4B945CF45912130C8D884109b59,\r\n            0x3458161f2Dc5D7eAfA48E7c8d9Acd7f415CF6dA6,\r\n            0x0985cb10C5d57dbF44AA473F33839eD38d80F111,\r\n            0xC70A7496716B3e25546901fE88215531ABbD5a10\r\n        ];\r\n\r\n        return GEN_2_CONTRACTS;\r\n    }\r\n\r\n    function getAvatarGen3Contracts() public pure returns (address[100] memory) {\r\n        address[100] memory GEN_3_CONTRACTS = [\r\n            0x12ACf83f5e855bE05dBc24b9Fee087049DeDfBf8,\r\n            0x96E55659845cA96dEbA2b8748D8987A7d2d94f4A,\r\n            0x6a73da4e3d49baA2485d975Af1AE71CeE638ebBf,\r\n            0xc3127DC36f1333f3a34FFcc21c0920ba9A6Dd837,\r\n            0x7c035E6DE5e6B80307747BF9C23E74CC65A3B763,\r\n            0x07ad84Fd47727A2733dC2043373Af7295E267374,\r\n            0xEeA14F2a8cfaf73736397832aB890Bb28CE263bC,\r\n            0x4dB1E32Bdb33D6B76AE6e5d7fA7f18bcd9f4B905,\r\n            0xe2A98Ba4f46FA47D938BE8dfc82C82C35700C5F0,\r\n            0x06607F8c97ca2AAB4CE17F91ACEA50f2261F1E1d,\r\n            0xC374e996A79Fe8f91b9d78c4Ec29F6219e5Bd57f,\r\n            0xC2148d2DB71D7B8CEbabc896ee4D62133D6bC42B,\r\n            0xa7CE4385C0293e95A909b42091dA2186b8d49C2C,\r\n            0x8CdaA0BEe4C5742ed8196b3FC1f2E3d91E6cf869,\r\n            0xcbE4e48e6C883B313C06a002009289501178339D,\r\n            0x27931513a87B62889992A76c3D975B6C712D909d,\r\n            0x80bE35056D9467841a74dcd80253729C508cad32,\r\n            0x248E6D478578216822635B95C7A1970A16223836,\r\n            0x5FD0102E00EC829ef34aC4f0056a1698DFE210d9,\r\n            0x6F7164b378FDbEED629806c9bbCBBbaE318Dc87C,\r\n            0x2400FC8417A12C1A483d8923F61019f4bD86dB30,\r\n            0x7F8cbA17511Ac40270BB4EF13EBa47165E577cc8,\r\n            0x3E249Ae5a200230A1F25b3dEE35755463156b382,\r\n            0xfDe389b3E688f12c8EfD5548b93540c3f06BfbB0,\r\n            0x9C11774f5813CaB12318Ee6D23FB7768f95AE906,\r\n            0x0b73e49a7F0fB6533A33e0bAE2dC30130604FB0c,\r\n            0xEf90F515cEb7c02f112b277553Fa0Ee774bCa7eA,\r\n            0x495A0E16eAC093f2FBF99b3F8da1aa5fAfa4A4fe,\r\n            0x4Dc89CE97d15361bCa0BA357ea3daC6044B9Fd1F,\r\n            0xa123d85f522a55A556ccba1E15cffc67c7aFdCD8,\r\n            0xA7570feD5eeb2516302E1b0fdBcB8C25ec539191,\r\n            0xf4d215A4E75BeDa4Bc99609b2af2702e7D2D1111,\r\n            0x5BbaE18120A52755DEBa69dD1fF2628FBA229D33,\r\n            0x750314B875E8cFF5baa385Db3E172686Ca1fcE40,\r\n            0x7F44bcE8c31386500B30e02F371E797ad3410349,\r\n            0x0F4Ea45F6B9828Ba6ac7400504A66D93f4C93C25,\r\n            0xD854adD818Cc7c1225624e5c6b61BA81f656ba62,\r\n            0xe7484F96D20Ee75e146C1917d094aC64F59699cD,\r\n            0x8dA1DA24Ef2c0E39aaF9c89aF6CbF966CF0Dcd0C,\r\n            0xd56c6a3B189AEA44993F2EeC9B3baf721BA9B5ab,\r\n            0x2218e323ab826775e9Fd026098a200606D4dd32c,\r\n            0xfFD17d9dd02c6bB3096528f36D0c2cB9335Fac9D,\r\n            0x155bAB02984Bcaf25c60ca643688b0E4339c3bC8,\r\n            0x9F5dcd096e85aCceCf7F2b2EC0a132CF44fe7996,\r\n            0x6B6bA11ffBCbdc0f22517B972278fA40650AC00f,\r\n            0x1a5DEC5283A686a7EFeAD3F25e407e7dA7fB4b5f,\r\n            0xfFe99A2604ae1B606490675475B4Db1Aa0b9917B,\r\n            0xA32e8ef4b15820Cee80FA0573A957F11CaeC6007,\r\n            0x139F7693cB689922D04831c339f5AE7ea3EeFb79,\r\n            0x02a898554A3122a07764Ef1B4ceDb123Cbb1D075,\r\n            0x2F2E8B6B0Bb62598753621CEb7c1025212E6267b,\r\n            0xBf5450A58e660740CB9EeD444BC3658f2a1B7bB3,\r\n            0x86B7C641eFe718ec7d8d4972fDFbeDa3669587B6,\r\n            0x4b5504E8619cD65692c6bBBedc54E6d7aFe5BFF5,\r\n            0x7D4CAAf1D9291071452A4f11A3D0DA7AA881AAAd,\r\n            0x91028695E1C266f02DFF4C481669b1a48bA96D64,\r\n            0xf3f1798eE4D40b78d32A2fE321d045a591E7103a,\r\n            0xfdba313e9d2E52299Ec317a6Fa05a141767E61b4,\r\n            0x2C2C60f114ae3c857Bf301D1a1b6c3069D5308Dc,\r\n            0x9172d60b2475060f3671E07028340c4cBaA4E263,\r\n            0xdc61b17587975317Fb621b725C6D5Be51Ac9A55B,\r\n            0x517CEdc05f38211113e58663eD4EAbed854c0F77,\r\n            0x44f62B14382c764364D35eB98B31Afe5299A76F2,\r\n            0x3c7a63bc43943322970770f932133d0dDd4f3D60,\r\n            0xDC1CDd1196B3f44C69D49548f5f70b96F04B3fEc,\r\n            0xC807ce5F1FD6515cBBe9dEF35e086E60E720b60B,\r\n            0x932f05045a01e679Ab95A29bA383D9c0954502bf,\r\n            0xBe418B221Bf5b2d570066160DA2676Bb51D9B254,\r\n            0xEfDed257Ca71b9E3BbC9C0959A1Ef4Ad494C8897,\r\n            0x4be1E01C4068C731A218C496EEe56Fcc8D1D2C19,\r\n            0xC229a141d49dfb08F06bc2F03Cd912b0cfC7A29f,\r\n            0x021a832F2aA9826BdF1a07bC41274bA4B4Fef68c,\r\n            0x16c309B6B01402eC196e4aE9a05946f5a0f4d6c4,\r\n            0xc1894ded8F0b81fD174b23d510f08Ed722CE63ef,\r\n            0xcBe6cBD8C3E73d0A3e2cd4F24e4C0Dbb61299643,\r\n            0x255e01E07A279449486dB6F236b9fE09ee6B67d3,\r\n            0xf897E2Cd445Bdc5ac02A8D116caA2c2FB767FDf1,\r\n            0x9d8542Ef1237933BadBe867291F6c0434b8D315C,\r\n            0xF6775aD730637420C6D63FA948B564189D3a456d,\r\n            0xdbBDbd48e2a66B95DC44b4376C06D147421EeD3E,\r\n            0xBA01c17942F63fcb6f67513e5B0646b4dDf7C8c7,\r\n            0xBd8437ca41B43BdAE92D1Fb68bd8B36225e78F62,\r\n            0x5B9C3Ef22C4f8C5308552d6E595C04Ed4CBC7aa2,\r\n            0xe2559f4B2f78e139cA3128b5F32D0b7D4D2Bd234,\r\n            0xe83a546513CC1dC8F9D3d3dDAB898B54e6153cfE,\r\n            0xa5c875A893b082edcbDF70a23b01cb10e4768865,\r\n            0x96C0EB1D1c7E0fdF7ECebA3474f1E681A3BF854c,\r\n            0xBA6a05ef46AeDD91960E7E4f7D7258fc35a9A15b,\r\n            0x6A1C801Ec142596046B0327d50b1fa6DCFD368Bf,\r\n            0x7044A182EB235A86713e05F25eE44531f838a9eB,\r\n            0x9254b70b68f5b695dCdc62447dA0Aa2969f96a12,\r\n            0x7eE1c07be8Bf6c16C1Cb3075aEa488309f48b12e,\r\n            0x698Be66243d4431AF18C377b1DB82Fc09af85db6,\r\n            0x352a956fec11a743f739cD5C30a54090DEec45f2,\r\n            0xf16AB2D54E95CF9d8922a244C1c09107c3B96888,\r\n            0x5669e294dCc7a0cEaE4BFBb00a68C1dbca2d45c0,\r\n            0xDb65b48446DC4fc383D7E91fFa64c812A1b36a4E,\r\n            0x2147C822EEe346c137c6903CCC5e32522310fAa3,\r\n            0x50D724067402543a16162A51F545A5A596Cf2705,\r\n            0x3372a12009195d912C0b8F0D275806777824f90F\r\n        ];\r\n\r\n        return GEN_3_CONTRACTS;\r\n    }\r\n\r\n    function getAvatarGen4Contracts() public pure returns (address[136] memory) {\r\n        address[136] memory GEN_4_CONTRACTS = [\r\n            0xf9B3dF29971FE3F930db52C9C47FFC0AEe8d4913,\r\n            0x8ED11AE32aE005CC9F66d4cC3f01467D14bD8142,\r\n            0x81759E5c953D9050cB48739fbbFeD99E740Bc5CC,\r\n            0x0f9CC0F240d0E51faF6fa5277D80988fC91d62a6,\r\n            0xECdE8eaf42A8c993c7d15545ff2125AEfb1764c0,\r\n            0x5D31A466019Da42412072789DCDC7Dd60FF4ea6c,\r\n            0x61aa617FFAf11A8da9255C59638F165e5ffbC823,\r\n            0xC317dF945115d5e8e136c7E83a18f7eCEe4D26B7,\r\n            0x8A469152E2C775668F5De8fae1B56B36fB97E0B8,\r\n            0xeF77d5D816d48477ba7DAe61Cad9884e32CCc1fB,\r\n            0x6C52020e476eb31C2E1EE3b59EaCfd1f4d643Da9,\r\n            0xE901f71EF6ddc85a28F369B46d026241a8d46080,\r\n            0xF77335cD36385022Df7A9192C8fA0dF0E9268bf9,\r\n            0x49d97D6431bb8b67073ef7e0eb457af52D8394BA,\r\n            0x9e8848C10Db66921810A63d9fC4a5A04459ad74a,\r\n            0x13447Bfa0c11730EDe1C6FA02d42BfE6220Db7d5,\r\n            0x6Bd01ea6F1f2d2a8F885A9f9f17eC5Cfe89A9e19,\r\n            0xAec2D59Cc3cDd7d272163C1C41Ba1d68561006D8,\r\n            0xfed0157409C984a58b2E0b950D3574709BA02EB7,\r\n            0xE0281DD3Be8C48Fd61745C660D2E74Ff0B29892e,\r\n            0xbc1916b49693a3D64330fA6d7A30cA628e4B8dCA,\r\n            0xb1B4b38Ae1129f8275974f642E0F7E8C1f86E26c,\r\n            0xA687660f9c9fcF7370210D358f1279088e851e58,\r\n            0x4672448A48c561010F4aa7E327820C803D991625,\r\n            0xb57DEb6d2Bc19cc78A756131eee87d16FB0bD21E,\r\n            0x315738E9Ce1A4F39EB4ba881d7B50B24cD4b8519,\r\n            0xa11a4582425F0dbE27B05Fb74123f36D46b857e8,\r\n            0xF2A6f2B02Cee70F81B5B8FD8e695b12e0583ac7e,\r\n            0xf6d634527c6454CecF242E43AEc59C50f8e79b73,\r\n            0xdc203b920aBC823051E5D28EaCf565E9Cb59c769,\r\n            0xB804Ca814e4C7722ADeF25e96Bd727432D66eFb1,\r\n            0xE28f8EDe789985e07458a668b1c3270f8F0e0525,\r\n            0x5b630a89cA2073E203a2117860E3a011Cb97731C,\r\n            0x2eE6263359EAbB57CB2748E4F044005478499883,\r\n            0x5F624882213Dd5bdC93216476ee0eBcE0fE20bdC,\r\n            0xC94e1bE3AE0200BE6D55da9473b127F7C0D9beeB,\r\n            0xCdd59c6791Ae4505375F06443ef72750C58235f9,\r\n            0xEA0084a4971656630267E6e6981Df565172cA64B,\r\n            0x0e9FdC46a211a875eb6a0a7dAb378d7D1860C466,\r\n            0x07F5437Ff648A0554C4faE110aDE5adcCB6Bd36b,\r\n            0x14227Ba7f8D09fda4e91D410B7b834A2855783E1,\r\n            0xA58E0F0CC71a98690bF2158793cAbcc133f485f4,\r\n            0xa4ecC9afB7fE29022aA586350832eE471392E71F,\r\n            0x83D323489bb0C071d47d4Ba30faf4EeD30296623,\r\n            0xb1e99FF98a9fa3E260bCa609e5aFdD6d0e2aC976,\r\n            0xC58dBD531E3945Fd19d404B03Fa7c278a3bd6c5f,\r\n            0x2128c27d9D5095CE730465636F0ADecD32FC886e,\r\n            0x7e23b270502F555F0F0Be9a73de846A5D9692a29,\r\n            0x0717D3C79ccB5EDC650344498f18076493B63989,\r\n            0x1c576E0728f11F348292337FBa129D3f933312f8,\r\n            0x19cb47f2251a54E1101a8095597F7B63Cb959bb3,\r\n            0x0705Da3199fEf10dcaa3655Fc48751fD4dbcf057,\r\n            0x72681818D657a28aE5e02a23b82373BB45E2998b,\r\n            0xec974f5cC666752F81A9c8107212C45dD5cbD9B1,\r\n            0xFcc6A9a8C25ece89cF222944B313fF140d26894F,\r\n            0xc342405BB48E9a98fe574A9Ca19e03915c62Adb8,\r\n            0x4b1E7dcdbb33F9e3008Fec99a440da6374854efc,\r\n            0x797d776Ec236B4118fe34c41fD9d27541ad54D65,\r\n            0x3e72cfC26e23d00130DA802a29fC7F421C5Bf847,\r\n            0x064F977FFF4385Bb757702cCD62Bd576D24990df,\r\n            0xA5118B39815650b52f6C1E191d0Cd06398A2b542,\r\n            0xe1B6D0E8CE5b75d73A6FA5F05b6BD24Bfb1fAD7a,\r\n            0x16fB660268Fbe681F4A5cef5DF86577C6213689A,\r\n            0xbb1Da48e7229aE3775542577c2FfB688b622BD5C,\r\n            0x6393E0b603A5A7C7101B25Fe7fe9772Bc916E614,\r\n            0xFEB47Aad920b537F3f00913528ab13551BAB7C18,\r\n            0x37a63D92Fd6e1e2ECBb71E9B606F1DF02bDFc3f3,\r\n            0x9C71842Ad0d3DFD949F8EAf893517f58a24c8Cbc,\r\n            0xe48CD867A1B7A330eca95f7b1381A86799F238f1,\r\n            0xdE28135fe07F061Df1668E5fF8b3d874F7cd4fa7,\r\n            0x0EB70F7b62Ae057C89F32d2ad92471645436eDA0,\r\n            0x332457058168533fB2738BbcA58Fa2507e0eee8c,\r\n            0x934a07F559D4e637158d2D01F62eEF97573f89eC,\r\n            0xF5bC11CfAF45DA13415d3DC810B09B2CEfF8BCe4,\r\n            0x8C80ad1979Fe5af75687576Bc428E3a16c09e947,\r\n            0x1043C9eC3197d9bFDB2F9F872e7F69b249249e04,\r\n            0x9A0033a4e986bDAe539d4F588FE5028F8B6fEC9D,\r\n            0xc78C419382702A70B40FA6F7D67c845a19FA676e,\r\n            0x6D5c332cB8BD3D601116e7a017EDf364ad239E78,\r\n            0xa58D3152Ec0318A5bD53ab47385CD71eedEE5230,\r\n            0xc82c481D47D446d21385d07A79d60619E7201b96,\r\n            0xDd25E3BB8Ca0fB96d37f3a199DA434d98E33C36a,\r\n            0x53c24125f68BD49bA79Afe95A4B23F5e419d89B9,\r\n            0x2f3180730e1ebfD4761dC9F646443A1e693A5E86,\r\n            0x9097F8594e4609Bb1487749a3dA9DffD479d4b13,\r\n            0x7fa1a6A92AA12176Cb10e9D63DBD8BcB06De7563,\r\n            0xF74586214e227f13ad990Ea46A506Bd2d50619B3,\r\n            0x36F60A6F2EAdECbFD580C91174D2F7c081633137,\r\n            0x79F6Bd4a2FeDc686E11d15756C477d5167B717D1,\r\n            0x23d10918dc081665EbCe46dD135e6A19069D9c7e,\r\n            0x4993047f73fCbbd9C9801f5757eB810724e1494a,\r\n            0x1Ef6F9379AA228E08507F53E70c109979a35e512,\r\n            0x71e2ee123cFFb75501CBEc943C0710B55f0e6750,\r\n            0xD2c92b0d773EE0e9D4E2Ad4038f38feB66AdCD56,\r\n            0x2d113F9820D17b193934DA6A664FaBa9B8D7F7A7,\r\n            0xb998E8a4687ED17869dB6238432BdDE79197ad77,\r\n            0x097A4A948806B760A8070C998839EB015E2EBbD1,\r\n            0xbE3750E8a8CA69476B41751C8c13b14f308a76e5,\r\n            0x33bc69E1df9c05350F27f806528787b2FBE74Fb5,\r\n            0x13bEF354789314b2E70af1DcA78BF17bcC3D5334,\r\n            0xf3f9d7878358023aAD1E130a7F403bFfd671a843,\r\n            0x84B385fBb95dbf724351Cadd8a196D4C40758C29,\r\n            0x3Cb7A1D4880e1d5479d3a708880cf4dD2BC7D2d0,\r\n            0x9560f1DE72D40b05815Ea3FAB54297D83aC80cf6,\r\n            0x5dE96Ca330A72E09435dB2452e80f4Cb1b714e8c,\r\n            0xD2530f4296FbFfa508ac3C02E065d389c6F0447C,\r\n            0xB1b2df907f774B4aD6C6385a19d86EF12f0D9163,\r\n            0xf5CDEFf8AAe05ceC289Aa008d23233E83F10B71B,\r\n            0x5bF284Ee3E1287AF74C2A68A5C36eaD1bE3Ae642,\r\n            0x70869238783Dc6ABf94ebE0527CF964f40a39A0c,\r\n            0xf14B813cFa39baf6321eD8bB110fCCf6FCBe4a50,\r\n            0x46039626c743f0A7f8ea9E95366695FE82DFa997,\r\n            0x0B0F05f544F6730aD06fEe8F40f4A774D662350b,\r\n            0x0E79B9a6b12357e62E38812D0424f604546Fe88A,\r\n            0x75Eb7B323328F750C9bDfaee22b49fE728B0209a,\r\n            0xB15f2c10acccD1b72D7C2187131F4f2F8Ea370C5,\r\n            0xd4B308Aa4b383136aFA69332cD169703Fad86496,\r\n            0x2FE1c430a14128CA36B7B893A8098d7b5581739c,\r\n            0x26295aD1a65465676c38ccb2aA29dbeBcE5a7923,\r\n            0xE582C9cA50f5A7351d0ADdDAE0451ADF2774a9f1,\r\n            0xc6801a4dd08035156fdb2557D938307F52B99138,\r\n            0x5a7E0981eDE6134795cF4eC5665A1635a2477722,\r\n            0x67dC90a90d3787670636B1Be8Cb19B3a508280cb,\r\n            0x6Dc402c0a881F668eEf0728B0928c179BefaD3b3,\r\n            0xB1D806F73387b0c958a3D066219e70b9833C99c4,\r\n            0x8a3E73dDB3837E8f3c133f6dFCB142b90571bce5,\r\n            0x2Da0157eEC166AB588Da5234149cFaACD1F828Da,\r\n            0xFd760795De07685919132c134c5DC4C047C6cD3D,\r\n            0x662Abf91256B03DE73D36C88eB4D3090b1e745C2,\r\n            0xA481B99bE3581d90d47946e7000Eb426087f4d69,\r\n            0x75fBddD1F61E8Ff0A02AEC580C10F612aaBBE5ff,\r\n            0x2E30a06065c49a31fbF49118a7a9F4Df7EE47488,\r\n            0xD400058Ec5658D6199F13B86376192657f84A0f9,\r\n            0xe87c6634276C46Db809B825645CF040C51E888FE,\r\n            0x7FcFf37f8dde57bbEb6A5D66608190a0962ccD0F,\r\n            0xe7c5C26Aa8A9B8918E7EED14DC4E4241f6e471FA\r\n        ];\r\n\r\n        return GEN_4_CONTRACTS;\r\n    }\r\n\r\n    function isAvatarAwwDripMemeSingu(address targetAddress) external pure returns (bool) {\r\n        address[4] memory contracts = getAwwDripMemeSinguContracts();\r\n\r\n        for (uint256 i = 0; i < contracts.length; i++) {\r\n            if (contracts[i] == targetAddress) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function isAvatarGen1(address targetAddress) external pure returns (bool) {\r\n        address[29] memory contracts = getAvatarGen1Contracts();\r\n\r\n        for (uint256 i = 0; i < contracts.length; i++) {\r\n            if (contracts[i] == targetAddress) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function isAvatarGen2(address targetAddress) external pure returns (bool) {\r\n        address[27] memory contracts = getAvatarGen2Contracts();\r\n\r\n        for (uint256 i = 0; i < contracts.length; i++) {\r\n            if (contracts[i] == targetAddress) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function isAvatarGen3(address targetAddress) external pure returns (bool) {\r\n        address[100] memory contracts = getAvatarGen3Contracts();\r\n\r\n        for (uint256 i = 0; i < contracts.length; i++) {\r\n            if (contracts[i] == targetAddress) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function isAvatarGen4(address targetAddress) external pure returns (bool) {\r\n        address[136] memory contracts = getAvatarGen4Contracts();\r\n\r\n        for (uint256 i = 0; i < contracts.length; i++) {\r\n            if (contracts[i] == targetAddress) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```solidity\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableSet.\r\n * ====\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165Upgradeable {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\r\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for reading and writing primitive types to specific storage slots.\r\n *\r\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\r\n * This library helps with reading and writing to such slots without the need for inline assembly.\r\n *\r\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\r\n *\r\n * Example usage to set ERC1967 implementation slot:\r\n * ```solidity\r\n * contract ERC1967 {\r\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n *\r\n *     function _getImplementation() internal view returns (address) {\r\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n *     }\r\n *\r\n *     function _setImplementation(address newImplementation) internal {\r\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\r\n * _Available since v4.9 for `string`, `bytes`._\r\n */\r\nlibrary StorageSlotUpgradeable {\r\n    struct AddressSlot {\r\n        address value;\r\n    }\r\n\r\n    struct BooleanSlot {\r\n        bool value;\r\n    }\r\n\r\n    struct Bytes32Slot {\r\n        bytes32 value;\r\n    }\r\n\r\n    struct Uint256Slot {\r\n        uint256 value;\r\n    }\r\n\r\n    struct StringSlot {\r\n        string value;\r\n    }\r\n\r\n    struct BytesSlot {\r\n        bytes value;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\r\n     */\r\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\r\n     */\r\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\r\n     */\r\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\r\n     */\r\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\r\n     */\r\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := store.slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\r\n     */\r\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := store.slot\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\r\n *\r\n * _Available since v4.8.3._\r\n */\r\ninterface IERC1967Upgradeable {\r\n    /**\r\n     * @dev Emitted when the implementation is upgraded.\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Emitted when the admin account has changed.\r\n     */\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @dev Emitted when the beacon is changed.\r\n     */\r\n    event BeaconUpgraded(address indexed beacon);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\r\n */\r\ninterface IBeaconUpgradeable {\r\n    /**\r\n     * @dev Must return an address that can be used as a delegate call target.\r\n     *\r\n     * {BeaconProxy} will check that this address is a contract.\r\n     */\r\n    function implementation() external view returns (address);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\r\n * proxy whose upgrades are fully controlled by the current implementation.\r\n */\r\ninterface IERC1822ProxiableUpgradeable {\r\n    /**\r\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\r\n     * address.\r\n     *\r\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\r\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\r\n     * function revert if invoked through a proxy.\r\n     */\r\n    function proxiableUUID() external view returns (bytes32);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```solidity\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n *\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\r\n     * constructor.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint8 version) {\r\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\r\n        _initialized = version;\r\n        _initializing = true;\r\n        _;\r\n        _initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized != type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint8) {\r\n        return _initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _initializing;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\r\n    function __ERC165_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __ERC165_init_unchained() internal onlyInitializing {\r\n    }\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\r\n    function __ERC1155Receiver_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\r\n    }\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\r\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev This abstract contract provides getters and event emitting update functions for\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\r\n *\r\n * _Available since v4.1._\r\n */\r\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\r\n    function __ERC1967Upgrade_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\r\n    }\r\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\r\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _getImplementation() internal view returns (address) {\r\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 implementation slot.\r\n     */\r\n    function _setImplementation(address newImplementation) private {\r\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\r\n        _upgradeTo(newImplementation);\r\n        if (data.length > 0 || forceCall) {\r\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\r\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\r\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\r\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\r\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\r\n            _setImplementation(newImplementation);\r\n        } else {\r\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\r\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\r\n            } catch {\r\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\r\n            }\r\n            _upgradeToAndCall(newImplementation, data, forceCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Storage slot with the admin of the contract.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     */\r\n    function _getAdmin() internal view returns (address) {\r\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 admin slot.\r\n     */\r\n    function _setAdmin(address newAdmin) private {\r\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\r\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     */\r\n    function _changeAdmin(address newAdmin) internal {\r\n        emit AdminChanged(_getAdmin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\r\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\r\n     */\r\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\r\n\r\n    /**\r\n     * @dev Returns the current beacon.\r\n     */\r\n    function _getBeacon() internal view returns (address) {\r\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\r\n     */\r\n    function _setBeacon(address newBeacon) private {\r\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\r\n        require(\r\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\r\n            \"ERC1967: beacon implementation is not a contract\"\r\n        );\r\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\r\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\r\n     *\r\n     * Emits a {BeaconUpgraded} event.\r\n     */\r\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\r\n        _setBeacon(newBeacon);\r\n        emit BeaconUpgraded(newBeacon);\r\n        if (data.length > 0 || forceCall) {\r\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\r\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\r\n *\r\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\r\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\r\n * `UUPSUpgradeable` with a custom implementation of upgrades.\r\n *\r\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\r\n *\r\n * _Available since v4.1._\r\n */\r\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\r\n    function __UUPSUpgradeable_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\r\n    }\r\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\r\n    address private immutable __self = address(this);\r\n\r\n    /**\r\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\r\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\r\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\r\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\r\n     * fail.\r\n     */\r\n    modifier onlyProxy() {\r\n        require(address(this) != __self, \"Function must be called through delegatecall\");\r\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\r\n     * callable on the implementing contract but not through proxies.\r\n     */\r\n    modifier notDelegated() {\r\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\r\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\r\n     *\r\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\r\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\r\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\r\n     */\r\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\r\n        return _IMPLEMENTATION_SLOT;\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\r\n     *\r\n     * Calls {_authorizeUpgrade}.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     *\r\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\r\n     */\r\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\r\n        _authorizeUpgrade(newImplementation);\r\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\r\n     * encoded in `data`.\r\n     *\r\n     * Calls {_authorizeUpgrade}.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     *\r\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\r\n     */\r\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\r\n        _authorizeUpgrade(newImplementation);\r\n        _upgradeToAndCallUUPS(newImplementation, data, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\r\n     * {upgradeTo} and {upgradeToAndCall}.\r\n     *\r\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\r\n     *\r\n     * ```solidity\r\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\r\n     * ```\r\n     */\r\n    function _authorizeUpgrade(address newImplementation) internal virtual;\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal onlyInitializing {\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal onlyInitializing {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    function __Pausable_init() internal onlyInitializing {\r\n        __Pausable_init_unchained();\r\n    }\r\n\r\n    function __Pausable_init_unchained() internal onlyInitializing {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n\r\n// File: contracts/RCAXAvatarSwap.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Users can swap their Aww/Drip/Meme/Singu and paid avatars instantly with an avatar in from the same pool.\r\n// First swap is free, then it will cost a RCAX fee per swap.\r\n// Half of the fee will go to the liquidity provider.\r\n// Other half of the fees will go to the contract owner.\r\n\r\ncontract RCAXAvatarSwap is Initializable, PausableUpgradeable, OwnableUpgradeable, ERC1155ReceiverUpgradeable, UUPSUpgradeable {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    \r\n    struct AvatarToken {\r\n        address owner;\r\n        address tokenAddress;\r\n        uint256 tokenId;\r\n    }\r\n\r\n    address public constant RCAX_TOKEN_ADDRESS = 0x875f123220024368968d9f1aB1f3F9C2f3fd190d;\r\n    address public constant RCAX_DEV_FUND_WALLET = 0xB5C42f30cEAE2032F22d364E33A5BaEfA1A043FF;\r\n    string public constant AWW_DRIP_MEME_SINGU_POOL_IDENTIFIER = \"awwdripmemesingu\";\r\n    string public constant GEN_1_POOL_IDENTIFIER = \"gen1\";\r\n    string public constant GEN_2_POOL_IDENTIFIER = \"gen2\";\r\n    string public constant GEN_3_POOL_IDENTIFIER = \"gen3\";\r\n    uint256 public constant AWW_DRIP_MEME_SINGU_POOL_FEE = 20 * 10**18;\r\n    uint256 public constant GEN_1_POOL_FEE = 80 * 10**18;\r\n    uint256 public constant GEN_2_POOL_FEE = 40 * 10**18;\r\n    uint256 public constant GEN_3_POOL_FEE = 20 * 10**18;\r\n\r\n    mapping(address => bool) private _freeDemoUsed;\r\n    mapping(address => bool) private _isLiquidityProvider;\r\n    mapping(string => AvatarToken[]) _avatarPools;\r\n\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    function initialize() initializer public {\r\n        __Pausable_init();\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n    }\r\n\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        onlyOwner\r\n        override\r\n    {}\r\n\r\n    // Get the pool identifier for an avatar contract address\r\n    function getPoolIdentifier(address tokenAddress) public pure returns (string memory) {\r\n        if (AvatarContracts.isAvatarAwwDripMemeSingu(tokenAddress)) {\r\n            return AWW_DRIP_MEME_SINGU_POOL_IDENTIFIER;\r\n        } else if (AvatarContracts.isAvatarGen1(tokenAddress)) {\r\n            return GEN_1_POOL_IDENTIFIER;\r\n        } else if (AvatarContracts.isAvatarGen2(tokenAddress)) {\r\n            return GEN_2_POOL_IDENTIFIER;\r\n        } else if (AvatarContracts.isAvatarGen3(tokenAddress)) {\r\n            return GEN_3_POOL_IDENTIFIER;\r\n        } else {\r\n            revert(\"RCA is not eligible for a swap\");\r\n        }\r\n    }\r\n\r\n    function getPoolFeeForToken(address tokenAddress) public pure returns (uint256) {\r\n        if (AvatarContracts.isAvatarAwwDripMemeSingu(tokenAddress)) {\r\n            return AWW_DRIP_MEME_SINGU_POOL_FEE;\r\n        } else if (AvatarContracts.isAvatarGen1(tokenAddress)) {\r\n            return GEN_1_POOL_FEE;\r\n        } else if (AvatarContracts.isAvatarGen2(tokenAddress)) {\r\n            return GEN_2_POOL_FEE;\r\n        } else if (AvatarContracts.isAvatarGen3(tokenAddress)) {\r\n            return GEN_3_POOL_FEE;\r\n        } else {\r\n            revert(\"RCA is not eligible for a swap\");\r\n        }\r\n    }\r\n\r\n    // Check if there is enough avatars in the pool\r\n    // Perform a swap if so\r\n    function _checkDoSwap(address initiator, AvatarToken memory initiatorAvatar) internal {\r\n        string memory poolIdentifier = getPoolIdentifier(initiatorAvatar.tokenAddress);\r\n\r\n        require(_avatarPools[poolIdentifier].length >= 1, \"Pool size is too small for a swap\");\r\n\r\n        _performSwap(initiator, initiatorAvatar);\r\n    }\r\n\r\n    // Generate a pseudo-random index based on block information\r\n    function _getRandomIndex(uint256 maxIndex) internal view returns (uint256) {\r\n        uint256 blockValue = uint256(blockhash(block.number - 1));\r\n        return blockValue % maxIndex;\r\n    }\r\n\r\n    // Send avatar to recipient\r\n    function _sendAvatar(address recipient, address tokenAddress, uint256 tokenId) internal {\r\n        require(IERC1155(tokenAddress).balanceOf(address(this), tokenId) == 1, \"Avatar is not owned by the contract\");\r\n\r\n        try IERC1155(tokenAddress).safeTransferFrom(address(this), recipient, tokenId, 1, \"\") {\r\n            // Successful transfer\r\n        } catch (bytes memory revertReason) {\r\n            // Handle the revert reason, e.g., by emitting an event or reverting with an error message\r\n            revert(string(revertReason));\r\n        }\r\n    }\r\n\r\n    function setLiquidityProviderStatus(bool status) external {\r\n        require(status != _isLiquidityProvider[msg.sender], \"Liquidity provider status is already set\");\r\n\r\n        _isLiquidityProvider[msg.sender] = status;\r\n    }\r\n\r\n    function getLiquidityProviderStatus(address wallet) external view returns (bool) {\r\n        return _isLiquidityProvider[wallet];\r\n    }\r\n\r\n    function getFreeDemoUsedStatus(address wallet) external view returns (bool) {\r\n        return _freeDemoUsed[wallet];\r\n    }\r\n\r\n    function withdrawAllAvatars() external {\r\n        _withdrawAllAvatarsFromPool(AWW_DRIP_MEME_SINGU_POOL_IDENTIFIER);\r\n        _withdrawAllAvatarsFromPool(GEN_1_POOL_IDENTIFIER);\r\n        _withdrawAllAvatarsFromPool(GEN_2_POOL_IDENTIFIER);\r\n        _withdrawAllAvatarsFromPool(GEN_3_POOL_IDENTIFIER);\r\n    }\r\n\r\n    function _withdrawAllAvatarsFromPool(string memory poolIdentifier) internal {\r\n        AvatarToken[] memory poolAvatars = getAllAvatarsInPoolForOwner(msg.sender, poolIdentifier);\r\n\r\n        for (uint256 i = 0; i < poolAvatars.length; i++) {\r\n            _withdrawAvatar(poolAvatars[i]);\r\n        }\r\n    }\r\n\r\n    function getAllAvatarsInPoolForOwner(address owner, string memory poolIdentifer) public view returns (AvatarToken[] memory) {\r\n        uint256 ownedAvatarsAmount = 0;\r\n\r\n        for (uint256 i = 0; i < _avatarPools[poolIdentifer].length; i++) {\r\n            if (_avatarPools[poolIdentifer][i].owner == owner) {\r\n                ownedAvatarsAmount += 1;\r\n            }\r\n        }\r\n\r\n        uint256 foundOwnedAvatarsAmount = 0;\r\n        AvatarToken[] memory ownedAvatars = new AvatarToken[](ownedAvatarsAmount);\r\n\r\n        for (uint256 i = 0; i < _avatarPools[poolIdentifer].length; i++) {\r\n            if (_avatarPools[poolIdentifer][i].owner == owner) {\r\n                ownedAvatars[foundOwnedAvatarsAmount] = AvatarToken({\r\n                    owner: _avatarPools[poolIdentifer][i].owner,\r\n                    tokenAddress: _avatarPools[poolIdentifer][i].tokenAddress,\r\n                    tokenId: _avatarPools[poolIdentifer][i].tokenId\r\n                }); \r\n\r\n                foundOwnedAvatarsAmount += 1;\r\n            }\r\n        }\r\n\r\n        return ownedAvatars;\r\n    }\r\n\r\n    function _withdrawAvatar(AvatarToken memory avatar) internal {\r\n        require(avatar.owner == msg.sender, \"Only the owner can withdraw their avatars\");\r\n\r\n        string memory poolIdentifier = getPoolIdentifier(avatar.tokenAddress);\r\n\r\n        bool avatarFound = false;\r\n\r\n        // Remove the avatar from the pool\r\n        for (uint256 i = 0; i < _avatarPools[poolIdentifier].length; i++) {\r\n            if (_avatarPools[poolIdentifier][i].tokenAddress == avatar.tokenAddress && _avatarPools[poolIdentifier][i].tokenId == avatar.tokenId) {\r\n                _avatarPools[poolIdentifier][i] = _avatarPools[poolIdentifier][_avatarPools[poolIdentifier].length - 1];\r\n                avatarFound = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(avatarFound, \"Could not find to be withdrawn avatar\");\r\n\r\n        _avatarPools[poolIdentifier].pop();\r\n\r\n        _sendAvatar(msg.sender, avatar.tokenAddress, avatar.tokenId);\r\n    }\r\n\r\n    function _sendRCAXTokens(address from, address to, uint256 amount) internal {\r\n        require(IERC20(RCAX_TOKEN_ADDRESS).balanceOf(from) >= amount, \"Wallet does not have enough RCAX tokens\");\r\n\r\n        if (from != address(this)) {\r\n            require(IERC20(RCAX_TOKEN_ADDRESS).allowance(from, address(this)) >= amount, \"Contract is not allowed to spend enough tokens\");\r\n        }\r\n\r\n        try IERC20(RCAX_TOKEN_ADDRESS).transferFrom(from, to, amount) {\r\n            // Successful transfer\r\n        } catch (bytes memory revertReason) {\r\n            // Handle the revert reason, e.g., by emitting an event or reverting with an error message\r\n            revert(string(revertReason));\r\n        }\r\n    }\r\n\r\n    function _processServiceFee(address liquidityProvider, address initiator, uint256 amount) internal {\r\n        uint256 contractOwnerFee = amount / 2;\r\n\r\n        _sendRCAXTokens(initiator, liquidityProvider, amount - contractOwnerFee);\r\n        _sendRCAXTokens(initiator, RCAX_DEV_FUND_WALLET, contractOwnerFee);\r\n    }\r\n\r\n    // Swap avatars between owners until no more swaps are available\r\n    function _performSwap(address initiator, AvatarToken memory initiatorAvatar) internal {\r\n        string memory poolIdentifier = getPoolIdentifier(initiatorAvatar.tokenAddress);\r\n\r\n        uint256 randomPoolAvatarIndex = _getRandomIndex(_avatarPools[poolIdentifier].length);\r\n\r\n        AvatarToken memory randomPoolAvatar = AvatarToken({\r\n            owner: _avatarPools[poolIdentifier][randomPoolAvatarIndex].owner,\r\n            tokenAddress: _avatarPools[poolIdentifier][randomPoolAvatarIndex].tokenAddress,\r\n            tokenId: _avatarPools[poolIdentifier][randomPoolAvatarIndex].tokenId\r\n        });\r\n\r\n        if (!_freeDemoUsed[initiator]) {\r\n            _freeDemoUsed[initiator] = true;\r\n        } else {\r\n            // todo: get dynamic service fee\r\n\r\n            uint256 serviceFee = getPoolFeeForToken(initiatorAvatar.tokenAddress);\r\n\r\n            _processServiceFee(randomPoolAvatar.owner, initiator, serviceFee);\r\n        }\r\n\r\n        initiatorAvatar.owner = randomPoolAvatar.owner;\r\n\r\n        _avatarPools[poolIdentifier][randomPoolAvatarIndex] = initiatorAvatar;\r\n\r\n        _sendAvatar(initiator, randomPoolAvatar.tokenAddress, randomPoolAvatar.tokenId);\r\n    }\r\n\r\n    function _addAvatarToPool(AvatarToken memory avatar) internal {\r\n        string memory poolIdentifier = getPoolIdentifier(avatar.tokenAddress);\r\n        _avatarPools[poolIdentifier].push(avatar);\r\n    }\r\n\r\n    function _handleReceivedAvatar(address from, address tokenAddress, uint256 tokenId) internal whenNotPaused() {\r\n        AvatarToken memory avatar = AvatarToken ({\r\n            owner: from,\r\n            tokenAddress: tokenAddress,\r\n            tokenId: tokenId\r\n        });\r\n\r\n        // If liquidity provider sends an RCA, add it to the pool directly\r\n        // Else try and do a swap\r\n        if (_isLiquidityProvider[from]) {\r\n            _addAvatarToPool(avatar);\r\n        } else {\r\n            _checkDoSwap(from, avatar);\r\n        }\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata\r\n    ) public override returns (bytes4) {\r\n        require(value == 1, \"Value must be 1\");\r\n\r\n        _handleReceivedAvatar(from, msg.sender, id);\r\n\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata\r\n    ) public override returns (bytes4) {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            require(values[i] == 1, \"Every value must be 1\");\r\n        }\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            _handleReceivedAvatar(from, msg.sender, ids[i]);\r\n        }\r\n        \r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    function getAllAvatarsInPool(string memory poolIdentifer) external view returns (AvatarToken[] memory) {\r\n        return _avatarPools[poolIdentifer];\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AWW_DRIP_MEME_SINGU_POOL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AWW_DRIP_MEME_SINGU_POOL_IDENTIFIER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_1_POOL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_1_POOL_IDENTIFIER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_2_POOL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_2_POOL_IDENTIFIER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_3_POOL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_3_POOL_IDENTIFIER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RCAX_DEV_FUND_WALLET\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RCAX_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"poolIdentifer\",\"type\":\"string\"}],\"name\":\"getAllAvatarsInPool\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct RCAXAvatarSwap.AvatarToken[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"poolIdentifer\",\"type\":\"string\"}],\"name\":\"getAllAvatarsInPoolForOwner\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct RCAXAvatarSwap.AvatarToken[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getFreeDemoUsedStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getLiquidityProviderStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getPoolFeeForToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getPoolIdentifier\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setLiquidityProviderStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllAvatars\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RCAXAvatarSwap", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "AvatarContracts:aa01becc9a2eb28d587b697a1a6860f945131a2c", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cdc68f568983064f0ba72490fdacbfa2e60660c322fd363fa58e6d850c5213e6"}