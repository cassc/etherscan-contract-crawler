{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\n/**\\n * @author  Shubhankar Banerjee\\n * @title   Context\\n * @dev     This contract provides the address and data of the sender of the transaction\\n */\\n\\nabstract contract Context {\\n    /**\\n     * @notice  Returns the address of the message sender\\n     */\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    /**\\n     * @notice  Returns the data of the message sender in bytes\\n     */\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\n/**\\n * @author  Shubhankar Banerjee\\n * @title   Interface ERC20\\n * @dev     Contains the necessary functions and events which are specified according to ERC20 token standard.\\n */\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function transfer(address recipient, uint amount) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint);\\n\\n    function approve(address spender, uint amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\"},\"MainTokenContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\nimport {Pausable} from \\\"./Pausable.sol\\\";\\n\\n/**\\n * @author  Shubhankar Banerjee\\n * @title   Main Token Contract\\n * @dev     This contract defines the token and its activities\\n * @dev     This contract contains all the function present in the interface and is following the token standard\\n */\\n\\ncontract MainTokenContract is IERC20, Ownable, Pausable {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n    uint256 private _totalSupply;\\n\\n    mapping(address =\\u003e uint256) private _balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n\\n    event Burn(address indexed burnerAddress, uint256 indexed amount);\\n\\n    constructor(string memory tokenName, string memory tokenSymbol) {\\n        _name = tokenName;\\n        _symbol = tokenSymbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev  This function returns the name of the token\\n     * @return  string\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev     This function returns the symbol of the token\\n     * @return  string\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev  This function returns the decimal places the token holds\\n     * @return  uint8\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev  This function returns the current total supply of the token along with its decimal places\\n     * @return  uint256\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev  This function returns the balance of a particular accunt address\\n     * @param   account  .address type parameter, takes in the address of the account holder\\n     * @return  uint256  .the token amount that the account holds\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @notice     This function is used to transfer tokens from the one account address to another\\n     * @dev     The token transfer occurs from the function caller\\u0027s address to the receiver address provided in the function parameter\\n     * @param   to  .address type paremeter, takes the address of the token receiver\\n     * @param   amount  .uint256 type parameter, takes the amount of tokens to be transferred\\n     * @return  bool  .\\n     */\\n    function transfer(\\n        address to,\\n        uint256 amount\\n    ) external virtual returns (bool) {\\n        if (beforeTransfer()) {\\n            revert(\\\"Transfer Paused by owner\\\");\\n        }\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev  This function returns the allowance amount of tokens which is set for an owner and spener\\n     * @param   owner  .address type parameter, takes the address of the actual address of the owner of tokens\\n     * @param   spender  .address type parameter, takes the address that is approved by the owner to spend tokens\\n     * @return  uint256  .amount of tokens approved by the owner for a particular spender\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev  This function approves an token allowance amount for an address\\n     * @param   spender  address type parameter, takes the address of the spender allowance account\\n     * @param   amount   uint256 type parameter, takes the amount of tokens that is set to be allowed as allowance\\n     * @return  bool\\n     */\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        if (beforeTransfer()) {\\n            revert(\\\"Transfer Paused by owner\\\");\\n        }\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev     This function is used to transfer allowance tokens from the spender address to the receiver address\\n     * @param   from  address type parameter, takes the address of the actual token holder the address that allowed the allowance\\n     * @param   to  address type parameter, takes the address of the receiver of the tokens\\n     * @param   amount  uint256 type parameter, takes the amount of tokens to be transferred\\n     * @return  bool\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external virtual returns (bool) {\\n        if (beforeTransfer()) {\\n            revert(\\\"Transfer Paused by owner\\\");\\n        }\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev     This function is used to increase the allowance amount for a spender\\n     * @param   spender  address type parameter, takes the address of the spender who is allowed by the token owner\\n     * @param   addedAmount  uint256 type parameter, takes in the increased amount\\n     * @return  bool\\n     */\\n    function increaseAllowance(\\n        address spender,\\n        uint256 addedAmount\\n    ) external virtual returns (bool) {\\n        if (beforeTransfer()) {\\n            revert(\\\"Transfer Paused by owner\\\");\\n        }\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedAmount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev     This function is used to decrease the allowance amount of a spender\\n     * @param   spender  .address type parameter, takes the address of the spender who is allowed by the token owner\\n     * @param   requestedDecrease  uint256 type parameter, takes in the amount which is to be subtracted fron the current amount\\n     * @return  bool  .\\n     */\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 requestedDecrease\\n    ) external virtual returns (bool) {\\n        if (beforeTransfer()) {\\n            revert(\\\"Transfer Paused by owner\\\");\\n        }\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance \\u003c requestedDecrease) {\\n            revert(\\\"current allowance is less than requested decrease\\\");\\n        }\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - requestedDecrease);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice     This function is used to burn tokens from the total supply\\n     * @dev     This function can only be called by the owner of the contract\\n     * @dev     The amount to be burned cannot be greater than the total supply of the token\\n     * @param   amount  .uint256 type parameter, takes in the amount of tokens to be burned\\n     * @return  bool\\n     */\\n    function burn(uint256 amount) public virtual onlyOwner returns (bool) {\\n        require(amount \\u003c= _totalSupply, \\\"Burn amount greater than token count\\\");\\n        _burn(_msgSender(), amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice  This function is used to mint new tokens in the network\\n     * @dev     This function can only be called by the owner of the contract\\n     * @dev     The minting amount cannot be 0\\n     * @dev     The minting amount and the available total supply amount cannot exceed a certain fixed amount (i.e 100 Billion)\\n     * @param   amount  .uint256 type parameter, takes in the amount to be minted\\n     * @return  bool\\n     */\\n    function mint(uint256 amount) public virtual onlyOwner returns (bool) {\\n        if (_msgSender() == address(0)) {\\n            revert(\\\"Invalid address\\\");\\n        }\\n        uint256 minting_amount = amount * (10 ** 18);\\n        if (minting_amount == 0) {\\n            revert(\\\"Cannot mint 0 tokens\\\");\\n        }\\n        require(\\n            _totalSupply + minting_amount \\u003c= 100000000000 * 10 ** 18,\\n            \\\"Mint amount exceeds the maximum supply\\\"\\n        );\\n        _mint(_msgSender(), minting_amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice  This function is used to start the ownership transfer process.\\n     * @dev     This function can only be called by the owner of the contract\\n     * @param   addr  .address type parameter, takes in the address of the new contract owner\\n     * @return  bool\\n     */\\n    function StartTransferOwnership(\\n        address addr\\n    ) public virtual onlyOwner returns (bool) {\\n        require(addr != address(0), \\\"Invalid address\\\");\\n        startTransferOwnership(addr);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice  This function is used to accept the transfer ownership of the contract.\\n     * @dev     This function can only be called by the Authorized new owner.\\n     * @dev     After the ownership is transferred, all the owners tokens are transferred to the new owner as well\\n     * @return  bool  .\\n     */\\n    function AcceptOwnership() public virtual returns (bool) {\\n        address owner = owner();\\n        if (acceptOwnership()) {\\n            _transfer(owner, _msgSender(), _balances[owner]);\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice  This is an internal function which is called during token transfer.\\n     * @dev     This function validates the address provided to itself.\\n     * @param   from  .address type parameter, takes in the address of the token sender\\n     * @param   to  .address type parameter, takes in the address of the token receiver\\n     * @param   amount  .uint256 type parameter, takes in the amount to be send\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal {\\n        if (from == address(0)) {\\n            revert(\\\"Invalid Sender\\\");\\n        }\\n        if (to == address(0)) {\\n            revert(\\\"Invalid Receiver\\\");\\n        }\\n        _update(from, to, amount);\\n    }\\n\\n    /**\\n     * @notice  This is an internal function which is used to update the token balances of the accounts among which the transfer is initiated.\\n     * @dev     This function sends the tokens\\n     * @param   from  .address type parameter, takes in the address of the account from which the tokens are to be subtracted.\\n     * @param   to  .address type parameter, takes in the address of the account to which the tokens are to be added.\\n     * @param   amount  .uint256 type parameter, takes the amount of tokens to be transferred\\n     */\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        // checking if sender\\u0027s address is 0x000000000000....\\n        if (from == address(0)) {\\n            _totalSupply += amount;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance \\u003c amount) {\\n                revert(\\\"Insufficient balance\\\");\\n            }\\n            if (amount == 0) {\\n                revert(\\\"Cannot send 0 tokens\\\");\\n            }\\n            unchecked {\\n                _balances[from] = fromBalance - amount;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            _totalSupply -= amount;\\n        } else {\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /**\\n     * @notice  This is an internal function which is called during token minting\\n     * @dev     This function calls the internal update function\\n     * @param   account  .address type parameter, takes in the account address on which new tokens are to be minted.\\n     * @param   value  .uint256 type parameter, takes in the amount of the tokens to be minted.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @notice  This is an internal function which is called during token burn\\n     * @dev     This function validates the account and calles the internal update function\\n     * @param   account  .address type parameter, takes in the contract owners account address\\n     * @param   value  .uint256 type parameter, takes the amount of tokens to be burnt.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert(\\\"Invalid Sender\\\");\\n        }\\n        _update(account, address(0), value);\\n        emit Burn(account, value);\\n    }\\n\\n    /**\\n     * @notice  This is an internal function which is used to approve allowance tokens for an address\\n     * @dev     This function calls another internal function\\n     * @param   owner  .address type parameter, takes in the address of the actual token owner\\n     * @param   spender  .address type parameter, takes in the address of the spender allowed by the owner\\n     * @param   amount  .uint256 type parameter, takes in the token amount\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        _approve(owner, spender, amount, true);\\n    }\\n\\n    /**\\n     * @notice  This function approves allowance token for an address\\n     * @param   owner  .address type parameter, takes in the address of the actual token owner\\n     * @param   spender  .address type parameter, takes in the address of the spender allowed by the owner\\n     * @param   amount  .uint256 type parameter, takes in the amount that is to be allowed for spending\\n     * @param   accessEvent  .boolean type parameter\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        bool accessEvent\\n    ) internal virtual {\\n        if (owner == address(0)) {\\n            revert(\\\"Invalid Owner\\\");\\n        }\\n        if (spender == address(0)) {\\n            revert(\\\"Invalid Spender\\\");\\n        }\\n\\n        _allowances[owner][spender] = amount;\\n        if (accessEvent) {\\n            emit Approval(owner, spender, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice  This internal function is used to spend allowance approved for an address\\n     * @dev     This function is called during transferFrom where allowance tokens are transferred\\n     * @param   owner  .address type parameter, takes in the address of the actual token owner\\n     * @param   spender  .address type parameter, takes in the address of the spender allowed by the owner\\n     * @param   amount  .uint256 type parameter, takes in the amount that is to be allowed for spending\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance \\u003c amount) {\\n                revert(\\\"Insufficient allowance\\\");\\n            }\\n            unchecked {\\n                // unchecked is used to remove the compiler checks thus reducing gas fees\\n                _approve(owner, spender, currentAllowance - amount, false);\\n            }\\n        }\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\nimport {Context} from \\\"./Context.sol\\\";\\n\\n/**\\n * @title   Ownable Contract\\n * @author  Shubhankar Banerjee\\n * @notice  This is an ownable contract which sets an owner to the contract and transfers or removes it as per the owner\\u0027s requirements. \\n * @dev     The transfer ownership is a two-way process, where the transfer starts and then the newOwner has to accept the ownership transfer.\\n */\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed peviousOwner, address indexed newOwner);\\n    event OwnershipTransferred(address indexed previousOwner,\\n                                address indexed CurrentOwner);\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0),msgSender);\\n    }\\n\\n    /**\\n     * @notice  Modifier to check the message sender is owner of the contract or not\\n     */\\n    modifier onlyOwner() {\\n        require((_owner == msg.sender || _owner == address(0)), \\n                \\\"Not the Owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice  Returns the current owner of the contract\\n     */\\n    function owner() public view virtual returns(address){\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice  Returns the pending owner address\\n     */\\n    function PendingOwner() public view  virtual  returns(address){\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @notice  Called when the ownership is to be transferred. Initiates the transfer of ownership\\n     * @dev     This function can only be called by the owner of the contract\\n     * @param   newOwnerAddress  .\\n     */\\n    function startTransferOwnership(address newOwnerAddress) internal virtual onlyOwner {\\n        address oldOwner = _msgSender();\\n        _pendingOwner = newOwnerAddress;\\n        emit OwnershipTransferStarted(oldOwner,newOwnerAddress);\\n    }\\n\\n\\n    /**\\n     * @notice  Called to accept ownership of the contract by the new owner, only the pending owner can accept ownership\\n     * @dev     After ownership is accepted, ownership and token transfer is completed\\n     */\\n    function acceptOwnership() internal virtual returns(bool){\\n        address acceptingOwner = _msgSender();\\n        if(acceptingOwner != PendingOwner()){\\n            revert(\\\"Unauthorized account for Ownership\\\");\\n        }\\n        return _transferOwnership(acceptingOwner);\\n    }\\n\\n    /**\\n     * @notice  Internal Function called after accepting the ownership transfer, transfers the ownersip\\n     * @param   addr  .\\n     */\\n    function _transferOwnership(address addr) internal  virtual \\n        returns(bool){\\n        delete _pendingOwner; \\n        address previousOwner = owner();   \\n        _owner = addr;\\n        emit OwnershipTransferred(previousOwner,addr);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice  Called when ownership is to be revoked or removed. \\n     * @dev     This function can only be called by the owner of the contract\\n     */\\n    function renounceOwnership() public virtual onlyOwner returns(bool){\\n        _owner = address(0);\\n        emit OwnershipTransferred(_msgSender(), address(0));\\n        return true;\\n    }\\n}\"},\"Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @author  Shubhankar\\n * @title   Pausable Contract\\n * @dev     Contract defining the pause and unpause functionality.\\n * @dev     This contract inherits the Ownable contract for ownership access control\\n * @dev     The contract pauses the token transfer for desired amount of time and can resume it wheneevr needed\\n */\\n\\nabstract contract Pausable is Ownable {\\n    bool private _paused;\\n    event Paused(\\n        address indexed currentOwner,\\n        uint indexed timeStamp,\\n        bool indexed paused\\n    );\\n\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @notice  Returns the state of the _paused variable, telling if the user paused the actions of the contract or not\\n     */\\n    function beforeTransfer() internal view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @notice  Pauses the token activity, changes the state of the paused variable\\n     * @dev     This function can only be called by the owner of the contract\\n     */\\n    function Pause() public virtual onlyOwner returns (bool) {\\n        _paused = true;\\n        emit Paused(_msgSender(), block.timestamp, true);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice  Remove the pause from the token activity\\n     * @dev     This function can only be called by the owner of the contract\\n     */\\n    function unPause() public virtual onlyOwner returns (bool) {\\n        _paused = false;\\n        emit Paused(_msgSender(), block.timestamp, false);\\n        return true;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burnerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"peviousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"CurrentOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AcceptOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"StartTransferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestedDecrease\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedAmount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MainTokenContract", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000a436865636b696e673130000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007436865636b313000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b7d89cd75d11f9beb614645480a3a47f70968a391e850e25218aa2bfe8933c31"}