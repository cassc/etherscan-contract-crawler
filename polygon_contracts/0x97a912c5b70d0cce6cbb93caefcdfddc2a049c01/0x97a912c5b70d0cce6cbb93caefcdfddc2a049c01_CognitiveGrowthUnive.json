{"SourceCode": "{\"CognitiveGrowthUniverse.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract CognitiveGrowthUniverse {\\r\\n    using SafeMath for uint256;\\r\\n    uint constant REFEREE_BONUS_LEVEL = 3; // percent\\r\\n    uint constant DIRECT_BONUS = 3; // percent\\r\\n    uint constant IN_DIRECT_BONUS = 1; // percent\\r\\n    uint constant fLASH_OUT = 3; //count\\r\\n    uint WithdrowFEE = 5; // percent\\r\\n    uint goldPoolInputPrecent = 15; // percent\\r\\n    uint platinumPoolInputPrecent = 5; // percent\\r\\n    uint platinumPoolTopUpPrecent = 15;\\r\\n    uint diamondPoolInputPrecent = 10; // percent\\r\\n    uint diamondPoolTopUpPrecent = 5; // percent\\r\\n    address[] private _usersAddresses;\\r\\n\\r\\n    address private owner;\\r\\n\\r\\n    address[] public developmentWallets;\\r\\n    uint developmentWalletsconfirm = 0;\\r\\n\\r\\n    struct Pool {\\r\\n        uint256 period;\\r\\n        uint256 balance;\\r\\n        uint256 start_date;\\r\\n        uint256 period_expiration;\\r\\n        uint256 total_point;\\r\\n    }\\r\\n    mapping(uint256 =\\u003e Pool) public pools;\\r\\n\\r\\n    mapping(uint256 =\\u003e uint256) public packages;\\r\\n\\r\\n    struct Account {\\r\\n        address wallet_address;\\r\\n        address parent;\\r\\n        address left;\\r\\n        address right;\\r\\n        uint256 account_amount;\\r\\n        uint256 reward;\\r\\n        uint256 Totalreward;\\r\\n        bool activeStatus;\\r\\n        bool platinumPointstatus;\\r\\n        uint256 goldPoint;\\r\\n        uint256 platinumPoint;\\r\\n        uint256 diamoundPoint;\\r\\n        uint256 flashOut;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e address[]) directs;\\r\\n    mapping(address =\\u003e Account) public accounts;\\r\\n\\r\\n    struct Transaction {\\r\\n        uint256 amount;\\r\\n        uint256 blockNumber;\\r\\n        uint256 time;\\r\\n    }\\r\\n    mapping(address =\\u003e Transaction[]) Transactions;\\r\\n\\r\\n    struct buyLog {\\r\\n        uint256 amount;\\r\\n        uint256 time;\\r\\n    }\\r\\n    mapping(address =\\u003e buyLog[]) buyLogs;\\r\\n\\r\\n    event RegisteredReferrer(address referee, address referrer);\\r\\n    event PaidReferral(address from, address to, uint256 amount, uint256 level);\\r\\n    event SendBonusFailed(address referee, address referrer, string reason);\\r\\n    event RegisteredReferrerFailed(\\r\\n        address referee,\\r\\n        address referrer,\\r\\n        string reason\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n        packages[30 ether] = 6;\\r\\n        packages[150 ether] = 10;\\r\\n        packages[750 ether] = 15;\\r\\n        packages[1500 ether] = 20;\\r\\n        owner = msg.sender;\\r\\n\\r\\n        pools[1] = Pool(30 days, 0,block.timestamp, block.timestamp + 30 days, 0);\\r\\n        pools[2] = Pool(90 days, 0,block.timestamp, block.timestamp + 90 days, 0);\\r\\n        pools[3] = Pool(180 days, 0,block.timestamp, block.timestamp + 180 days, 0);\\r\\n       \\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"Just Owner Can Run This Order!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function buyPackage(address parent, uint256 node_direction) public payable {\\r\\n        //  node_direction left 0  ,right 1\\r\\n        require(owner != msg.sender,\\\"The parent address cannot be the same as the owner address\\\");\\r\\n        require(parent != msg.sender,\\\"The parent address cannot be the same as the sender\\u0027s address\\\");\\r\\n        if(_usersAddresses.length \\u003e 0 \\u0026\\u0026 msg.sender != _usersAddresses[0] ){ \\r\\n            // just for starter account\\r\\n            require(parent != address(0), \\\"The parent address cannot be empty\\\");\\r\\n            require(accounts[parent].account_amount \\u003e 0,\\\"Your parent has not purchased an account\\\");\\r\\n            require(node_direction == 0 || node_direction == 1,\\\"Please specify the type of position\\\"); \\r\\n        }\\r\\n        require(packages[msg.value] \\u003e 0, \\\"The input amount is incorrect !\\\");\\r\\n        require(directs[parent].length \\u003c 2, \\\"Your parent does not have an empty direct\\\");\\r\\n        require(msg.value \\u003e= accounts[msg.sender].account_amount,\\\"You cannot buy a lower package\\\");\\r\\n\\r\\n        buyLogs[msg.sender].push(buyLog(msg.value, block.timestamp));\\r\\n        uint reward_amount = 0;\\r\\n        if (accounts[msg.sender].account_amount \\u003e 0) {\\r\\n            accounts[msg.sender].account_amount = msg.value;\\r\\n            accounts[msg.sender].reward = 0;\\r\\n            accounts[msg.sender].activeStatus = true;\\r\\n            reward_amount = payReferral(msg.value, true);\\r\\n           \\r\\n           // sendDevelopmentAmount(msg.value,true,false);\\r\\n        } else {\\r\\n            if (node_direction == 0) {\\r\\n                accounts[parent].left = msg.sender;\\r\\n            } else {\\r\\n                accounts[parent].right = msg.sender;\\r\\n            }\\r\\n            directs[parent].push(msg.sender);\\r\\n            accounts[msg.sender] = Account(msg.sender,parent,address(0),address(0),msg.value,0,0,true,false,0,0,0,0);\\r\\n            _usersAddresses.push(msg.sender);\\r\\n            reward_amount =  payReferral(msg.value, false);\\r\\n           \\r\\n        }\\r\\n\\r\\n        sendDevelopmentAmount(msg.value - reward_amount);\\r\\n        \\r\\n    }\\r\\n\\r\\n    function payReferral(uint256 value, bool topUp) internal returns(uint) {\\r\\n        Account memory userAccount = accounts[msg.sender];\\r\\n        uint256 bouus_amount = value.mul(REFEREE_BONUS_LEVEL).div(100);\\r\\n        uint rewards_amount = 0;\\r\\n        for (uint256 i = 0; i \\u003c 20; i++) {\\r\\n            address parent = userAccount.parent;\\r\\n\\r\\n            if (parent == address(0)) {\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            Account storage parentAccount = accounts[userAccount.parent];\\r\\n\\r\\n            if (parentAccount.activeStatus == true \\u0026\\u0026i \\u003c packages[parentAccount.account_amount]){\\r\\n               rewards_amount += sendAmount(bouus_amount, parent, i + 1);\\r\\n            }\\r\\n            userAccount = parentAccount;\\r\\n        }\\r\\n        if (topUp == true) {\\r\\n            rewards_amount += sendDirctBonus(value, msg.sender);\\r\\n        }\\r\\n        rewards_amount += sendPoolAmount(value,topUp);\\r\\n        return rewards_amount;\\r\\n\\r\\n    }\\r\\n\\r\\n    function sendDirctBonus(uint256 value, address _account) internal returns (uint) {\\r\\n        uint256 directAmount = value.mul(DIRECT_BONUS).div(100);\\r\\n        uint256 inDirectAmount = value.mul(IN_DIRECT_BONUS).div(100);\\r\\n        uint send_amounts = 0;\\r\\n        for (uint256 i = 0; i \\u003c directs[_account].length; i++) {\\r\\n            send_amounts += sendAmount(directAmount, directs[_account][i], 0);\\r\\n\\r\\n            for (uint256 j = 0; j \\u003c directs[directs[_account][i]].length; j++) {\\r\\n                send_amounts += sendAmount(inDirectAmount, directs[directs[_account][i]][j], 0);\\r\\n            }\\r\\n        }\\r\\n        return  send_amounts;\\r\\n    }\\r\\n\\r\\n    function sendAmount(uint256 value,address _account,uint256 _level) public returns (uint) {\\r\\n        Account storage account = accounts[_account];\\r\\n        uint256 flash_amount = account.account_amount.mul(fLASH_OUT);\\r\\n        uint256 total_gift_amount = flash_amount.sub(account.reward);\\r\\n        if (value \\u003c= total_gift_amount) {\\r\\n            uint256 _value = value.sub(value.mul(WithdrowFEE).div(100));\\r\\n            if (_value \\u003e 0) {\\r\\n                payable(_account).transfer(_value);\\r\\n            }\\r\\n            accounts[_account].reward = accounts[_account].reward.add(value);\\r\\n            accounts[_account].Totalreward = accounts[_account].Totalreward.add(value);\\r\\n            Transactions[_account].push(Transaction(value, block.number, block.timestamp));\\r\\n            setFlashOut(_account);\\r\\n            emit PaidReferral(msg.sender, _account, value, _level);\\r\\n            return _value;\\r\\n        }\\r\\n        if (total_gift_amount \\u003e 0) {\\r\\n            uint256 _value = total_gift_amount.sub(total_gift_amount.mul(WithdrowFEE).div(100));\\r\\n            if (_value \\u003e 0) {\\r\\n                payable(_account).transfer(_value);\\r\\n            }\\r\\n            accounts[_account].reward = accounts[_account].reward.add(total_gift_amount);\\r\\n            accounts[_account].Totalreward = accounts[_account].Totalreward.add(total_gift_amount);\\r\\n            accounts[_account].activeStatus = false;\\r\\n            Transactions[_account].push(Transaction(total_gift_amount, block.number, block.timestamp));\\r\\n            setFlashOut(_account);\\r\\n            emit PaidReferral(msg.sender, _account, total_gift_amount, _level);\\r\\n            return _value;\\r\\n        }\\r\\n        emit SendBonusFailed(msg.sender,_account,\\\"Parent account has been flashed out\\\");\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function setFlashOut(address _account) internal {\\r\\n        uint256 flashOut = accounts[_account].reward / accounts[_account].account_amount;\\r\\n        if (accounts[_account].flashOut \\u003c flashOut) {\\r\\n            uint flash = flashOut - accounts[_account].flashOut;\\r\\n            uint256 point = flash *(accounts[_account].account_amount / 30 ether);\\r\\n\\r\\n            if (accounts[_account].platinumPointstatus == true) {\\r\\n                accounts[_account].platinumPoint = accounts[_account].platinumPoint.add(point);\\r\\n                accounts[_account].platinumPointstatus = false;\\r\\n            } else {\\r\\n                accounts[_account].goldPoint = accounts[_account].goldPoint.add(point);\\r\\n                pools[1].total_point = pools[1].total_point.add(point);\\r\\n                if (packages[accounts[_account].account_amount] == 20) {\\r\\n                    accounts[_account].diamoundPoint = accounts[_account].diamoundPoint.add(flash);\\r\\n                    pools[3].total_point = pools[3].total_point.add(flash);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        accounts[_account].flashOut = flashOut;\\r\\n    }\\r\\n\\r\\n    function sendDevelopmentAmount(uint value) internal {\\r\\n        for (uint i = 0; i \\u003c developmentWallets.length; i++) {\\r\\n            if (developmentWallets[i] != address(0)) {\\r\\n\\r\\n                payable(developmentWallets[i]).transfer(value.div(developmentWallets.length));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function sendPoolAmount(uint256 _value, bool is_topUp) internal returns (uint) {\\r\\n       \\r\\n        if(!is_topUp){\\r\\n            pools[1].balance += _value.mul(goldPoolInputPrecent).div(100);\\r\\n            pools[2].balance += _value.mul(platinumPoolInputPrecent).div(100);\\r\\n            pools[3].balance += _value.mul(diamondPoolInputPrecent).div(100);\\r\\n            return _value.mul(goldPoolInputPrecent).div(100) + _value.mul(platinumPoolInputPrecent).div(100) +_value.mul(diamondPoolInputPrecent).div(100);\\r\\n        }else {\\r\\n            pools[2].balance += _value.mul(platinumPoolTopUpPrecent).div(100);\\r\\n            pools[3].balance += _value.mul(diamondPoolTopUpPrecent).div(100);\\r\\n            return _value.mul(platinumPoolTopUpPrecent).div(100) +  _value.mul(diamondPoolTopUpPrecent).div(100);\\r\\n        }\\r\\n        \\r\\n    }\\r\\n\\r\\n    // Setter functions\\r\\n\\r\\n    function changeOwner(address _owner) public onlyOwner {\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    function changeGoldInputPrecent(uint _percent) public onlyOwner {\\r\\n        require(_percent \\u003e= 10, \\\"Observe the minimum percentage\\\");\\r\\n        goldPoolInputPrecent = _percent;\\r\\n    }\\r\\n\\r\\n    function changeDiamondInputPrecent(uint _percent) public onlyOwner {\\r\\n        require(_percent \\u003e= 10, \\\"Observe the minimum percentage\\\");\\r\\n        diamondPoolInputPrecent = _percent;\\r\\n    }\\r\\n\\r\\n    function changePlatinumTopUpPrecent(uint _percent) public onlyOwner {\\r\\n        require(_percent \\u003e= 10, \\\"Observe the minimum percentage\\\");\\r\\n        platinumPoolTopUpPrecent = _percent;\\r\\n    }\\r\\n\\r\\n    function changePlatinumInputPrecent(uint _percent) public onlyOwner {\\r\\n        require(_percent \\u003e= 5, \\\"Observe the minimum percentage\\\");\\r\\n        platinumPoolInputPrecent = _percent;\\r\\n    }\\r\\n\\r\\n    function changeDiamondTopUpPrecent(uint _percent) public onlyOwner {\\r\\n        require(_percent \\u003e= 5, \\\"Observe the minimum percentage\\\");\\r\\n        diamondPoolTopUpPrecent = _percent;\\r\\n    }\\r\\n\\r\\n    function changeWithdrowFEEPrecent(uint _percent) public onlyOwner {\\r\\n        require(_percent \\u003c= 10, \\\"Observe the maximum percentage\\\");\\r\\n        WithdrowFEE = _percent;\\r\\n    }\\r\\n\\r\\n    function changeDevelopmentWallet(address _old_address, address _new_address) public onlyOwner {\\r\\n        require(_old_address != _new_address);\\r\\n        if(developmentWallets.length \\u003e= 2 ){\\r\\n            require(developmentWalletsconfirm \\u003e= 2,\\\"Minimal approval is required for implementation\\\");\\r\\n        }\\r\\n        for (uint256 i = 0; i \\u003c developmentWallets.length; i++) {\\r\\n            if (developmentWallets[i] == _old_address) {\\r\\n                developmentWallets[i] = _new_address;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n         developmentWalletsconfirm = 0;\\r\\n        \\r\\n    }\\r\\n\\r\\n    function addDevelopmentWallet(address _new_address) public onlyOwner {\\r\\n        require(_new_address != address(0));\\r\\n\\r\\n        if(developmentWallets.length \\u003e= 2 \\u0026\\u0026 _usersAddresses.length \\u003e 0 ){\\r\\n             require(developmentWalletsconfirm \\u003e= 2,\\\"Minimal approval is required for implementation\\\");\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c developmentWallets.length; i++) {\\r\\n            if (developmentWallets[i] == _new_address) {\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n        developmentWallets.push(_new_address);\\r\\n        developmentWalletsconfirm = 0;\\r\\n    }\\r\\n\\r\\n    function confirmDevelopmentWallet() public {\\r\\n        for (uint256 i = 0; i \\u003c developmentWallets.length; i++) {\\r\\n            if (developmentWallets[i] == msg.sender) {\\r\\n                developmentWalletsconfirm += 1;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function runGoldenPool() public {\\r\\n        require(\\r\\n            pools[1].period_expiration \\u003c= block.timestamp \\u0026\\u0026\\r\\n            pools[1].balance \\u003e 0,\\r\\n            \\\"It\\u0027s not time to run yet.\\\"\\r\\n        );\\r\\n        if (pools[1].total_point \\u003e 0) {\\r\\n            uint256 point_amount = pools[1].balance.div(pools[1].total_point);\\r\\n            for (uint256 i = 0; i \\u003c _usersAddresses.length; i++) {\\r\\n                if (accounts[_usersAddresses[i]].goldPoint \\u003e 0) {\\r\\n                    payable(_usersAddresses[i]).transfer(\\r\\n                        accounts[_usersAddresses[i]].goldPoint.mul(point_amount)\\r\\n                    );\\r\\n                    Transactions[_usersAddresses[i]].push(Transaction( accounts[_usersAddresses[i]].goldPoint.mul(point_amount), block.number, block.timestamp));\\r\\n                    accounts[_usersAddresses[i]].goldPoint = 0;\\r\\n                }\\r\\n            }\\r\\n        }else {\\r\\n            sendDevelopmentAmount(pools[1].balance);\\r\\n        }\\r\\n\\r\\n        pools[1].period_expiration = block.timestamp + pools[1].period;\\r\\n        pools[1].balance = 0;\\r\\n        pools[1].total_point = 0;\\r\\n    }\\r\\n\\r\\n    function runPlatinumPool() public {\\r\\n        require(\\r\\n            pools[2].period_expiration \\u003c= block.timestamp \\u0026\\u0026\\r\\n            pools[2].balance \\u003e 0,\\r\\n            \\\"It\\u0027s not time to run yet.\\\"\\r\\n        );\\r\\n        if (pools[2].total_point \\u003e 0) {\\r\\n            uint256 point_amount = pools[2].balance.div(pools[2].total_point);\\r\\n            for (uint256 i = 0; i \\u003c _usersAddresses.length; i++) {\\r\\n                if (accounts[_usersAddresses[i]].platinumPoint \\u003e 0) {\\r\\n                    payable(_usersAddresses[i]).transfer(\\r\\n                        accounts[_usersAddresses[i]].platinumPoint.mul(\\r\\n                            point_amount\\r\\n                        )\\r\\n                    );\\r\\n                    Transactions[_usersAddresses[i]].push(Transaction( accounts[_usersAddresses[i]].platinumPoint.mul(point_amount), block.number, block.timestamp));\\r\\n                    accounts[_usersAddresses[i]].platinumPoint = 0;\\r\\n                }\\r\\n            }\\r\\n        }else {\\r\\n            sendDevelopmentAmount(pools[2].balance);\\r\\n        }\\r\\n        pools[2].period_expiration = block.timestamp + pools[2].period;\\r\\n        pools[2].balance = 0;\\r\\n        pools[2].total_point = 0;\\r\\n    }\\r\\n\\r\\n    function runDiamoundPool() public {\\r\\n        require(\\r\\n            pools[3].period_expiration \\u003c= block.timestamp \\u0026\\u0026\\r\\n            pools[3].balance \\u003e 0,\\r\\n            \\\"It\\u0027s not time to run yet.\\\"\\r\\n        );\\r\\n        if (pools[3].total_point \\u003e 0) {\\r\\n            uint256 point_amount = pools[3].balance.div(pools[3].total_point);\\r\\n            for (uint256 i = 0; i \\u003c _usersAddresses.length; i++) {\\r\\n                if (accounts[_usersAddresses[i]].diamoundPoint \\u003e 0) {\\r\\n                    payable(_usersAddresses[i]).transfer(\\r\\n                        accounts[_usersAddresses[i]].diamoundPoint.mul(\\r\\n                            point_amount\\r\\n                        )\\r\\n                    );\\r\\n                    Transactions[_usersAddresses[i]].push(Transaction( accounts[_usersAddresses[i]].diamoundPoint.mul(point_amount), block.number, block.timestamp));\\r\\n                    accounts[_usersAddresses[i]].diamoundPoint = 0;\\r\\n                }\\r\\n            }\\r\\n        }else {\\r\\n            sendDevelopmentAmount(pools[3].balance);\\r\\n        }\\r\\n        pools[3].period_expiration = block.timestamp + pools[3].period;\\r\\n        pools[3].balance = 0;\\r\\n        pools[3].total_point = 0;\\r\\n    }\\r\\n\\r\\n    //Geter functions\\r\\n\\r\\n    function searchNode(address parent, uint256 node_direction) public view returns (address) {\\r\\n        //  node_direction left 0 ,right 1\\r\\n        require(\\r\\n            node_direction == 0 || node_direction == 1,\\r\\n            \\\"Please specify the type of position\\\"\\r\\n        );\\r\\n        if (node_direction == 1) {\\r\\n            if (accounts[parent].right == address(0)) {\\r\\n                return parent;\\r\\n            } else {\\r\\n                return searchNode(accounts[parent].right, node_direction);\\r\\n            }\\r\\n        } else {\\r\\n            if (accounts[parent].left == address(0)) {\\r\\n                return parent;\\r\\n            } else {\\r\\n                return searchNode(accounts[parent].left, node_direction);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserBuyLogs(address _address) public view returns (buyLog[] memory){\\r\\n        return buyLogs[_address];\\r\\n    }\\r\\n\\r\\n    function getUserTransections(address _address) public view returns (Transaction[] memory){\\r\\n        return Transactions[_address];\\r\\n    }\\r\\n\\r\\n    function getUserdirects(address _address) public view returns (address[] memory){\\r\\n        return directs[_address];\\r\\n    }\\r\\n\\r\\n    function getUsers() public view returns (Account[] memory) {\\r\\n        Account[] memory users = new Account[](_usersAddresses.length);\\r\\n        for (uint256 i = 0; i \\u003c _usersAddresses.length; i++) {\\r\\n            users[i] = accounts[_usersAddresses[i]];\\r\\n        }\\r\\n        return users;\\r\\n    }\\r\\n\\r\\n    function getDevelopmentWallets() public view returns (address[] memory) {\\r\\n        address[] memory wallets = new address[](developmentWallets.length);\\r\\n        for (uint256 i = 0; i \\u003c developmentWallets.length; i++) {\\r\\n            wallets[i] = developmentWallets[i];\\r\\n        }\\r\\n        return wallets;\\r\\n    }\\r\\n\\r\\n    function getPools() public view returns (Pool[] memory) {\\r\\n        Pool[] memory m_pools = new Pool[](3);\\r\\n        for (uint256 i = 0; i \\u003c 3; i++) {\\r\\n            m_pools[i] = pools[i + 1];\\r\\n        }\\r\\n        return m_pools;\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"PaidReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"RegisteredReferrer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"RegisteredReferrerFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"SendBonusFailed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"left\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"right\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"account_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Totalreward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"activeStatus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"platinumPointstatus\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"goldPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"platinumPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"diamoundPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flashOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new_address\",\"type\":\"address\"}],\"name\":\"addDevelopmentWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"node_direction\",\"type\":\"uint256\"}],\"name\":\"buyPackage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_old_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_new_address\",\"type\":\"address\"}],\"name\":\"changeDevelopmentWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"changeDiamondInputPrecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"changeDiamondTopUpPrecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"changeGoldInputPrecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"changePlatinumInputPrecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"changePlatinumTopUpPrecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"changeWithdrowFEEPrecent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmDevelopmentWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"developmentWallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDevelopmentWallets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start_date\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period_expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_point\",\"type\":\"uint256\"}],\"internalType\":\"struct CognitiveGrowthUniverse.Pool[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserBuyLogs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct CognitiveGrowthUniverse.buyLog[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserTransections\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct CognitiveGrowthUniverse.Transaction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserdirects\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"left\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"right\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"account_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Totalreward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"activeStatus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"platinumPointstatus\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"goldPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"platinumPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"diamoundPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flashOut\",\"type\":\"uint256\"}],\"internalType\":\"struct CognitiveGrowthUniverse.Account[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"packages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start_date\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period_expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_point\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"runDiamoundPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"runGoldenPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"runPlatinumPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"node_direction\",\"type\":\"uint256\"}],\"name\":\"searchNode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"sendAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CognitiveGrowthUniverse", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fac1d66ce3c9232386372007411da45aa21f5c54560a6ced6341fdea9178c693"}