{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract TokenSale {\r\n    address payable public contractOwner;\r\n    address payable public marketing;\r\n    uint256 public tokenPrice;\r\n    IERC20 public token;\r\n\r\n    event TokensPurchased(address indexed buyer, uint256 amount);\r\n    event TokensWithdrawn(address indexed receiver, uint256 amount);\r\n    event TokenPriceSet(uint256 newTokenPrice);\r\n    event ReferralBonusPaid(address indexed referrer, uint256 amount);\r\n\r\n    constructor(\r\n        uint256 _tokenPrice,\r\n        address _tokenAddress,\r\n        address _marketing\r\n    ) {\r\n        contractOwner = payable(msg.sender);\r\n        tokenPrice = _tokenPrice;\r\n        token = IERC20(_tokenAddress);\r\n        marketing = payable(_marketing);\r\n    }\r\n\r\n    function buyTokens(address payable referralAddress) external payable {\r\n        uint256 tokensToBuy = msg.value * tokenPrice;\r\n    \r\n        // Calculate referral bonuses\r\n        uint256 referralBonusTokens = 0;\r\n        uint256 ethReferralBonus = 0;\r\n    \r\n        if (\r\n            referralAddress != address(0) &&\r\n            referralAddress != msg.sender\r\n        ) {\r\n            // Calculate token referral bonus (10% of the tokens purchased)\r\n            referralBonusTokens = (tokensToBuy * 10) / 100;\r\n            emit ReferralBonusPaid(referralAddress, referralBonusTokens);\r\n    \r\n            // Calculate ETH referral bonus (30% of the transaction value)\r\n            ethReferralBonus = (msg.value * 30) / 100;\r\n            referralAddress.transfer(ethReferralBonus);\r\n    \r\n            // Distribute 35% of the transaction value in MATIC to marketing address\r\n            uint256 marketingMATIC = (msg.value * 35) / 100;\r\n            marketing.transfer(marketingMATIC);\r\n    \r\n            // Distribute 35% of the transaction value in MATIC to contract owner\r\n            uint256 ownerMATIC = (msg.value * 35) / 100;\r\n            contractOwner.transfer(ownerMATIC);\r\n        }\r\n    \r\n            uint256 totalTokens = tokensToBuy;\r\n        require(totalTokens > 0, \"No tokens to buy\");\r\n    \r\n        // Transfer tokens to the buyer and emit an event with the original tokensToBuy amount\r\n        require(token.transfer(msg.sender, totalTokens), \"Token transfer failed\");\r\n        require(token.transfer(referralAddress, referralBonusTokens), \"Token transfer failed\");\r\n       emit TokensPurchased(msg.sender, totalTokens);\r\n        emit TokensPurchased(referralAddress, referralBonusTokens);\r\n    \r\n        // Ensure that the ETH referral bonus is non-zero before emitting the event\r\n        if (ethReferralBonus > 0) {\r\n            emit ReferralBonusPaid(referralAddress, ethReferralBonus);\r\n        }\r\n    }\r\n    modifier onlyOwner() {\r\n        require(msg.sender == contractOwner, \"Only contract owner can call this function\");\r\n        _;\r\n    }\r\n    function withdrawTokens() external onlyOwner {\r\n        uint256 balanceToWithdraw = token.balanceOf(address(this));\r\n        require(balanceToWithdraw > 0, \"No tokens to withdraw\");\r\n    \r\n        require(token.transfer(contractOwner, balanceToWithdraw), \"Token transfer failed\");\r\n        emit TokensWithdrawn(contractOwner, balanceToWithdraw);\r\n    }\r\n    \r\n    function withdrawEther() external onlyOwner {\r\n        uint256 balanceToWithdraw = address(this).balance;\r\n        require(balanceToWithdraw > 0, \"No balance to withdraw\");\r\n    \r\n        contractOwner.transfer(balanceToWithdraw);\r\n    }\r\n        \r\n    function setTokenPrice(uint256 newTokenPrice) external {\r\n        require(\r\n            msg.sender == contractOwner,\r\n            \"Only contract owner can set token price\"\r\n        );\r\n\r\n        tokenPrice = newTokenPrice;\r\n\r\n        emit TokenPriceSet(newTokenPrice);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketing\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferralBonusPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTokenPrice\",\"type\":\"uint256\"}],\"name\":\"TokenPriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"referralAddress\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketing\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTokenPrice\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenSale", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000800000000000000000000000019971b392740a28a1ca3bab43c42cd7e96ccd3fe00000000000000000000000042a11307c7e3bd6cc39767ee30262b5d1147dda4", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cf786ca5b56bf09127d707086ab4be97bdfd9763ae03c8aae463c3a32f337d16"}