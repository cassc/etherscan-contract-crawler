{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/facades/ChapterStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract ChapterStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n\\n    // ( Double checked! )\\n    // Mapping of current state of the contracts ( 2nd iteration of NFT cosmetics - should be final for `Chapter` )\\n    // ChapterStorage1 = 1 - 366\\n    // ChapterStorage2 = 367 - 739\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory chapterStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < chapterStorage.length; i++) \\n        {\\n            Range memory chapterStorageRange = Range({storageContract:chapterStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(chapterStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/FigureStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract FigureStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts ( Should be final )\\n    // FigureStorage1 = 1 - 367 ( + 2 units, + 4)\\n    // FigureStorage2 = 368 - 369\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory figureStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < figureStorage.length; i++) \\n        {\\n            Range memory figureStorageRange = Range({storageContract:figureStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(figureStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/HeadingStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract HeadingStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts\\n    // HeadingStorage1 = 1 - 359\\n    // HeadingStorage2 = 360 - 726\\n\\n    // Mapping of current state of the contracts ( after 2nd iteration, should be final )\\n    // HeadingStorage1 = 1 - 360\\n    // HeadingStorage2 = 361 - 739\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory headingStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < headingStorage.length; i++) \\n        {\\n            Range memory headingStorageRange = Range({storageContract:headingStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(headingStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/IncludesFigureStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract IncludesFigureStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts\\n    // IncludesFigureStorage1 = 1 - 369\\n    // IncludesFigureStorage2 = 370 - 726\\n\\n    // Mapping of current state of the contracts ( should be final )\\n    // IncludesFigureStorage1 = 1 - 350\\n    // IncludesFigureStorage2 = 351 - 739\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory includesFigureStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < includesFigureStorage.length; i++) \\n        {\\n            Range memory includesFigureStorageRange = Range({storageContract:includesFigureStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(includesFigureStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/LengthStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract LengthStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts\\n    // LengthStorage1 = 1 - 369\\n    // LengthStorage2 = 370 - 726\\n\\n    // Mapping of current state of the contracts ( should be finalized )\\n    // LengthStorage1 = 1 - 369\\n    // LengthStorage2 = 370 - 739\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory lengthStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < lengthStorage.length; i++) \\n        {\\n            Range memory lengthStorageRange = Range({storageContract:lengthStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(lengthStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/NetwordedAStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract NetwordedAStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts ( should be final! )\\n    // NetwordedAStorage1 = 1 - 370\\n    // NetwordedAStorage2 = 371 - 729\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory chapterStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < chapterStorage.length; i++) \\n        {\\n            Range memory chapterStorageRange = Range({storageContract:chapterStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(chapterStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/NetwordedBStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract NetwordedBStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts ( should be final! )\\n    // NetwordedBStorage1 = 1 - 370\\n    // NetwordedBStorage2 = 371 - 729\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory networdedBStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < networdedBStorage.length; i++) \\n        {\\n            Range memory networdedBStorageRange = Range({storageContract:networdedBStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(networdedBStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/NumFootnotesStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract NumFootnotesStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts\\n    // NumFootnotesStorage1 = 1 - 360\\n    // NumFootnotesStorage2 = 361 - 726\\n\\n    // Mapping of current state of the contracts ( should be finalized )\\n    // NumFootnotesStorage1 = 1 - 360\\n    // NumFootnotesStorage2 = 361 - 739\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory numFootnotesStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < numFootnotesStorage.length; i++) \\n        {\\n            Range memory numFootnotesStorageRange = Range({storageContract:numFootnotesStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(numFootnotesStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/SectionStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract SectionStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts ( should be finalized )\\n    // sectionStorage1 = 1 - 365\\n    // sectionStorage2 = 366 - 738\\n\\n    // Mapping of current state of the contracts ( after 2nd iteration, should be final! ) [ Double checked ]\\n    // sectionStorage1 = 1 - 366\\n    // sectionStorage2 = 367 - 739\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory sectionStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < sectionStorage.length; i++) \\n        {\\n            Range memory sectionStorageRange = Range({storageContract:sectionStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(sectionStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/UnitDescriptorStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract UnitDescriptorStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts ( should be final! )\\n    // UnitDescriptorStorage1 = 1 - 365\\n    // UnitDescriptorStorage2 = 366 - 739\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory unitDescriptorStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < unitDescriptorStorage.length; i++) \\n        {\\n            Range memory unitDescriptorStorageRange = Range({storageContract:unitDescriptorStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(unitDescriptorStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/UnitStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract UnitStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n\\n    // Mapping after Cosmetics of metadata ( 3rd iteration ) ( final for `UnitText` )\\n    // UnitStorage1 = 1 - 20\\n    // UnitStorage2 = 21 - 39\\n    // UnitStorage3 = 40 - 58\\n    // UnitStorage4 = 59 - 77\\n    // UnitStorage5 = 78 - 96\\n    // UnitStorage6 = 97 - 116\\n    // UnitStorage7 = 117 - 135\\n    // UnitStorage8 = 136 - 154\\n    // UnitStorage9 = 155 - 173\\n    // UnitStorage10 = 174 - 192\\n    // UnitStorage11 = 193 - 211\\n    // UnitStorage12 = 212 - 230\\n    // UnitStorage13 = 231 - 249\\n    // UnitStorage14 = 250 - 268\\n    // UnitStorage15 = 269 - 287\\n    // UnitStorage16 = 288 - 306\\n    // UnitStorage17 = 307 - 326\\n    // UnitStorage18 = 327 - 345\\n    // UnitStorage19 = 346 - 364\\n    // UnitStorage20 = 365 - 383\\n    // UnitStorage21 = 384 - 402\\n    // UnitStorage22 = 403 - 421\\n    // UnitStorage23 = 422 - 440\\n    // UnitStorage24 = 441 - 459\\n    // UnitStorage25 = 460 - 478\\n    // UnitStorage26 = 479 - 497\\n    // UnitStorage27 = 498 - 517\\n    // UnitStorage28 = 518 - 536\\n    // UnitStorage29 = 537 - 555\\n    // UnitStorage30 = 556 - 574\\n    // UnitStorage31 = 575 - 593\\n    // UnitStorage32 = 594 - 612\\n    // UnitStorage33 = 613 - 635\\n    // UnitStorage34 = 636 - 654\\n    // UnitStorage35 = 655 - 674\\n    // UnitStorage36 = 675 - 693\\n    // UnitStorage37 = 694 - 714\\n    // UnitStorage38 = 715 - 735\\n    // UnitStorage39 = 736 - 739\\n\\n    // Logic: \\n\\n    // ... examples - id = 456\\n    // for eachStorageContract get it's range\\n    // if `id` ( 456 ) fits the range, we first can store address of a contract ( unitStorage7 ).\\n    // contract found - address unitStorage7; // 410 - 489\\n    // then for range 410-489 ( difference is 79 ), ids are actually ( 0 - 79 )\\n    // so if it's not first contract ( it starts with 1 ), requested id = 456, in actual range of ids ( 0 - 79 ) is 33 ( if deduced by - toRange ), 46 if it is desired - from range  \\n    \\n    // set to onlyOwner()\\n    // check if value exists - \\n\\n    // this must be replaced by arrays unitStorageAddress[], startRange[], endRange[]\\n    // and then for...\\n\\n\\n    // ! previously working mapping -> Currently organizing mapping!\\n    \\n    Range[] ranges;\\n\\n    constructor(address[] memory unitStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < unitStorage.length; i++) \\n        {\\n            Range memory unitStorageRange = Range({storageContract:unitStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(unitStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/XStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract XStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts ( should be finalized! )\\n    // XStorage1 = 1 - 370\\n    // XStorage2 = 371 - 729\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory xStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < xStorage.length; i++) \\n        {\\n            Range memory xStorageRange = Range({storageContract:xStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(xStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/YStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDy-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract YStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts ( should be finalized !)\\n    // yStorage1 = 1 - 370\\n    // yStorage2 = 371 - 739\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory yStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < yStorage.length; i++) \\n        {\\n            Range memory yStorageRange = Range({storageContract:yStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(yStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    \\n\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/facades/ZStorageFacade.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDy-License-Identifier: GPL-3.0-or-later\\nimport \\\"../storage/IStorage.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract ZStorageFacade is Ownable{\\n    struct Range {\\n        // rename this\\n        address storageContract;\\n        uint256 start;\\n        uint256 end;\\n    }\\n    // Mapping of current state of the contracts ( should be finalized! )\\n    // yStorage1 = 1 - 370\\n    // yStorage2 = 371 - 739\\n\\n    Range[] ranges;\\n\\n    constructor(address[] memory zStorage, uint256[] memory startRange, uint256[] memory endRange){\\n        for (uint256 i = 0; i < zStorage.length; i++) \\n        {\\n            Range memory zStorageRange = Range({storageContract:zStorage[i], start:startRange[i], end: endRange[i] });\\n            ranges.push(zStorageRange);\\n        }\\n    }\\n    function updateRange(uint256 index, address newStorageContract, uint256 newStart, uint256 newEnd) public onlyOwner {\\n        require(index < ranges.length, \\\"Invalid index\\\");\\n\\n        ranges[index].storageContract = newStorageContract;\\n        ranges[index].start = newStart;\\n        ranges[index].end = newEnd;\\n    }\\n    function _getBasedOnId(uint256 id) public view returns (address storageAddress, uint256 storageInterpolatedId){\\n    // only if it's 2nd, 3rd or nth contract - there is no need for idInterpolation for the first contract\\n    if(id > ranges[0].end){\\n        for(uint256 i = 0; i < ranges.length; i++){\\n            if(id >= ranges[i].start && id <= ranges[i].end){\\n                // return the address\\n                storageAddress = ranges[i].storageContract;\\n                storageInterpolatedId = id - ranges[i].start;\\n            }\\n        }\\n        // Add a return statement here to handle the case when id doesn't match any range\\n        return (storageAddress, storageInterpolatedId);\\n    } else {\\n        return (ranges[0].storageContract, id);\\n    }\\n    }\\n\\n    function getUnitBasedOnId(uint256 id) public returns (string memory){\\n        (address storageAddress, uint256 storageInterpolatedId) = _getBasedOnId(id);\\n        IStorage unit = IStorage(storageAddress);\\n        return unit.getById(storageInterpolatedId);\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/storage/IStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// https://soliditytips.com/articles/solidity-interface-interact-with-other-contracts/\\ninterface IStorage {\\n    function getById(uint256 id) external returns (string memory unit);\\n    // Add more function signatures as needed.\\n}\"\r\n    },\r\n    \"contracts/StorageFacadeManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n/// ============ Imports ============\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\"; // OZ: Ownable\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\"; // OZ: IERC20\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\"; // OZ: IERC721;\\nimport { ChapterStorageFacade } from \\\"./facades/ChapterStorageFacade.sol\\\";\\nimport { FigureStorageFacade } from \\\"./facades/FigureStorageFacade.sol\\\";\\n// import { FootnoteStorageFacade } from \\\"./facades/FootnoteStorageFacade.sol\\\";\\nimport { HeadingStorageFacade } from \\\"./facades/HeadingStorageFacade.sol\\\";\\nimport { LengthStorageFacade } from \\\"./facades/LengthStorageFacade.sol\\\";\\nimport { NetwordedAStorageFacade } from \\\"./facades/NetwordedAStorageFacade.sol\\\";\\nimport { NetwordedBStorageFacade } from \\\"./facades/NetwordedBStorageFacade.sol\\\";\\nimport { NumFootnotesStorageFacade } from \\\"./facades/NumFootnotesStorageFacade.sol\\\";\\nimport { IncludesFigureStorageFacade } from \\\"./facades/IncludesFigureStorageFacade.sol\\\";\\nimport { SectionStorageFacade } from \\\"./facades/SectionStorageFacade.sol\\\";\\nimport { UnitStorageFacade } from \\\"./facades/UnitStorageFacade.sol\\\";\\nimport { UnitDescriptorStorageFacade } from \\\"./facades/UnitDescriptorStorageFacade.sol\\\";\\nimport { XStorageFacade } from \\\"./facades/XStorageFacade.sol\\\";\\nimport { YStorageFacade } from \\\"./facades/YStorageFacade.sol\\\";\\nimport { ZStorageFacade } from \\\"./facades/ZStorageFacade.sol\\\";\\n\\ncontract StorageFacadeManager is Ownable{\\n    address []storageFacades;\\n    // FootnoteStorageFacade foonoteStorageFacade;\\n    FigureStorageFacade  figureStorageFacade;\\n    ChapterStorageFacade chapterStorageFacade;\\n    SectionStorageFacade sectionStorageFacade;\\n    HeadingStorageFacade headingStorageFacade;\\n    NumFootnotesStorageFacade numFootnotesStorageFacade;\\n    IncludesFigureStorageFacade includesFigureStorageFacade;\\n    LengthStorageFacade lengthStorageFacade;\\n    XStorageFacade xStorageFacade;\\n    YStorageFacade yStorageFacade;\\n    ZStorageFacade zStorageFacade;\\n    UnitDescriptorStorageFacade unitDescriptorStorageFacade;\\n    NetwordedAStorageFacade networdedAStorageFacade;\\n    NetwordedBStorageFacade networdedBStorageFacade;\\n    UnitStorageFacade unitStorageFacade;\\n\\n    // Unit ( Not a metadata )\\n    // Metadata:\\n    // - Footnote \\n    // - Figure\\n    // - Chapter\\n    // - Section\\n    // - Heading\\n    // - NumFootnotes\\n    // - Inlcudes figure\\n    // - Length\\n    // - X\\n    // - Y\\n    // - Z\\n    // - Unit descriptor: Nodewords\\n    // - NetwordedA\\n    // - Networded B\\n\\n    constructor(address[] memory _storageFacades){\\n        storageFacades = _storageFacades;\\n        // foonoteStorageFacade = FootnoteStorageFacade(storageFacades[0]); \\n        figureStorageFacade = FigureStorageFacade(storageFacades[0]); \\n        chapterStorageFacade = ChapterStorageFacade(storageFacades[1]); \\n        sectionStorageFacade = SectionStorageFacade(storageFacades[2]); \\n        headingStorageFacade = HeadingStorageFacade(storageFacades[3]); \\n        numFootnotesStorageFacade = NumFootnotesStorageFacade(storageFacades[4]); \\n        includesFigureStorageFacade = IncludesFigureStorageFacade(storageFacades[5]); \\n        lengthStorageFacade = LengthStorageFacade(storageFacades[6]); \\n        xStorageFacade = XStorageFacade(storageFacades[7]); \\n        yStorageFacade = YStorageFacade(storageFacades[8]); \\n        zStorageFacade = ZStorageFacade(storageFacades[9]); \\n        unitDescriptorStorageFacade = UnitDescriptorStorageFacade(storageFacades[10]);\\n        networdedAStorageFacade = NetwordedAStorageFacade(storageFacades[11]); \\n        networdedBStorageFacade = NetwordedBStorageFacade(storageFacades[12]); \\n        unitStorageFacade = UnitStorageFacade(storageFacades[13]);\\n    }\\n    // Getter for the entire array\\n    function getStorageFacades() external view returns (address[] memory) {\\n        return storageFacades;\\n    }\\n\\n    // Getter for a specific index in the array\\n    function getStorageFacadeAt(uint256 index) external view returns (address) {\\n        require(index < storageFacades.length, \\\"Index out of bounds\\\");\\n        return storageFacades[index];\\n    }\\n\\n    // Setter for the entire array\\n    function setStorageFacades(address[] memory _storageFacades) external onlyOwner {\\n        storageFacades = _storageFacades;\\n    }\\n\\n    // Setter to update a specific index in the array\\n    function setStorageFacadeAt(uint256 index, address _storageFacade) external onlyOwner {\\n        require(index < storageFacades.length, \\\"Index out of bounds\\\");\\n        storageFacades[index] = _storageFacade;\\n    }\\n\\n    // Function to add a new address to the array\\n    function addStorageFacade(address _storageFacade) external onlyOwner {\\n        storageFacades.push(_storageFacade);\\n    }\\n\\n    // Function to remove the last address from the array\\n    function removeLastStorageFacade() external onlyOwner {\\n        require(storageFacades.length > 0, \\\"No items to remove\\\");\\n        storageFacades.pop();\\n    }\\n    // Getters\\n    // function getFootnoteStorageFacade() external view returns (FootnoteStorageFacade) {\\n    //     return foonoteStorageFacade;\\n    // }\\n    function getFigureStorageFacade() external view returns (FigureStorageFacade) {\\n        return figureStorageFacade;\\n    }\\n\\n    function getChapterStorageFacade() external view returns (ChapterStorageFacade) {\\n        return chapterStorageFacade;\\n    }\\n\\n    function getSectionStorageFacade() external view returns (SectionStorageFacade) {\\n        return sectionStorageFacade;\\n    }\\n\\n    function getHeadingStorageFacade() external view returns (HeadingStorageFacade) {\\n        return headingStorageFacade;\\n    }\\n\\n    function getNumFootnotesStorageFacade() external view returns (NumFootnotesStorageFacade) {\\n        return numFootnotesStorageFacade;\\n    }\\n\\n    function getIncludesFigureStorageFacade() external view returns (IncludesFigureStorageFacade) {\\n        return includesFigureStorageFacade;\\n    }\\n\\n    function getLengthStorageFacade() external view returns (LengthStorageFacade) {\\n        return lengthStorageFacade;\\n    }\\n\\n    function getXStorageFacade() external view returns (XStorageFacade) {\\n        return xStorageFacade;\\n    }\\n\\n    function getYStorageFacade() external view returns (YStorageFacade) {\\n        return yStorageFacade;\\n    }\\n\\n    function getZStorageFacade() external view returns (ZStorageFacade) {\\n        return zStorageFacade;\\n    }\\n\\n    function getUnitDescriptorStorageFacade() external view returns (UnitDescriptorStorageFacade) {\\n        return unitDescriptorStorageFacade;\\n    }\\n\\n    function getNetwordedAStorageFacade() external view returns (NetwordedAStorageFacade) {\\n        return networdedAStorageFacade;\\n    }\\n\\n    function getNetwordedBStorageFacade() external view returns (NetwordedBStorageFacade) {\\n        return networdedBStorageFacade;\\n    }\\n\\n    function getUnitStorageFacade() external view returns (UnitStorageFacade) {\\n        return unitStorageFacade;\\n    }\\n    // Setters\\n\\n    function setFigureStorageFacade(address _figureStorageFacade) external onlyOwner {\\n        figureStorageFacade = FigureStorageFacade(_figureStorageFacade);\\n    }\\n\\n    function setChapterStorageFacade(address _chapterStorageFacade) external onlyOwner {\\n        chapterStorageFacade = ChapterStorageFacade(_chapterStorageFacade);\\n    }\\n\\n    function setSectionStorageFacade(address _sectionStorageFacade) external onlyOwner {\\n        sectionStorageFacade = SectionStorageFacade(_sectionStorageFacade);\\n    }\\n\\n    function setHeadingStorageFacade(address _headingStorageFacade) external onlyOwner {\\n        headingStorageFacade = HeadingStorageFacade(_headingStorageFacade);\\n    }\\n\\n    function setNumFootnotesStorageFacade(address _numFootnotesStorageFacade) external onlyOwner {\\n        numFootnotesStorageFacade = NumFootnotesStorageFacade(_numFootnotesStorageFacade);\\n    }\\n\\n    function setIncludesFigureStorageFacade(address _includesFigureStorageFacade) external onlyOwner {\\n        includesFigureStorageFacade = IncludesFigureStorageFacade(_includesFigureStorageFacade);\\n    }\\n\\n    function setLengthStorageFacade(address _lengthStorageFacade) external onlyOwner {\\n        lengthStorageFacade = LengthStorageFacade(_lengthStorageFacade);\\n    }\\n\\n    function setXStorageFacade(address _xStorageFacade) external onlyOwner {\\n        xStorageFacade = XStorageFacade(_xStorageFacade);\\n    }\\n\\n    function setYStorageFacade(address _yStorageFacade) external onlyOwner {\\n        yStorageFacade = YStorageFacade(_yStorageFacade);\\n    }\\n\\n    function setZStorageFacade(address _zStorageFacade) external onlyOwner {\\n        zStorageFacade = ZStorageFacade(_zStorageFacade);\\n    }\\n\\n    function setUnitDescriptorStorageFacade(address _unitDescriptorStorageFacade) external onlyOwner {\\n        unitDescriptorStorageFacade = UnitDescriptorStorageFacade(_unitDescriptorStorageFacade);\\n    }\\n\\n    function setNetwordedAStorageFacade(address _networdedAStorageFacade) external onlyOwner {\\n        networdedAStorageFacade = NetwordedAStorageFacade(_networdedAStorageFacade);\\n    }\\n\\n    function setNetwordedBStorageFacade(address _networdedBStorageFacade) external onlyOwner {\\n        networdedBStorageFacade = NetwordedBStorageFacade(_networdedBStorageFacade);\\n    }\\n\\n    function setUnitStorageFacade(address _unitStorageFacade) external onlyOwner {\\n        unitStorageFacade = UnitStorageFacade(_unitStorageFacade);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_storageFacades\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_storageFacade\",\"type\":\"address\"}],\"name\":\"addStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChapterStorageFacade\",\"outputs\":[{\"internalType\":\"contract ChapterStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFigureStorageFacade\",\"outputs\":[{\"internalType\":\"contract FigureStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHeadingStorageFacade\",\"outputs\":[{\"internalType\":\"contract HeadingStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIncludesFigureStorageFacade\",\"outputs\":[{\"internalType\":\"contract IncludesFigureStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLengthStorageFacade\",\"outputs\":[{\"internalType\":\"contract LengthStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNetwordedAStorageFacade\",\"outputs\":[{\"internalType\":\"contract NetwordedAStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNetwordedBStorageFacade\",\"outputs\":[{\"internalType\":\"contract NetwordedBStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumFootnotesStorageFacade\",\"outputs\":[{\"internalType\":\"contract NumFootnotesStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSectionStorageFacade\",\"outputs\":[{\"internalType\":\"contract SectionStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getStorageFacadeAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStorageFacades\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnitDescriptorStorageFacade\",\"outputs\":[{\"internalType\":\"contract UnitDescriptorStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnitStorageFacade\",\"outputs\":[{\"internalType\":\"contract UnitStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getXStorageFacade\",\"outputs\":[{\"internalType\":\"contract XStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getYStorageFacade\",\"outputs\":[{\"internalType\":\"contract YStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getZStorageFacade\",\"outputs\":[{\"internalType\":\"contract ZStorageFacade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLastStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chapterStorageFacade\",\"type\":\"address\"}],\"name\":\"setChapterStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_figureStorageFacade\",\"type\":\"address\"}],\"name\":\"setFigureStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_headingStorageFacade\",\"type\":\"address\"}],\"name\":\"setHeadingStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_includesFigureStorageFacade\",\"type\":\"address\"}],\"name\":\"setIncludesFigureStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lengthStorageFacade\",\"type\":\"address\"}],\"name\":\"setLengthStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_networdedAStorageFacade\",\"type\":\"address\"}],\"name\":\"setNetwordedAStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_networdedBStorageFacade\",\"type\":\"address\"}],\"name\":\"setNetwordedBStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_numFootnotesStorageFacade\",\"type\":\"address\"}],\"name\":\"setNumFootnotesStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sectionStorageFacade\",\"type\":\"address\"}],\"name\":\"setSectionStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_storageFacade\",\"type\":\"address\"}],\"name\":\"setStorageFacadeAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_storageFacades\",\"type\":\"address[]\"}],\"name\":\"setStorageFacades\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_unitDescriptorStorageFacade\",\"type\":\"address\"}],\"name\":\"setUnitDescriptorStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_unitStorageFacade\",\"type\":\"address\"}],\"name\":\"setUnitStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_xStorageFacade\",\"type\":\"address\"}],\"name\":\"setXStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yStorageFacade\",\"type\":\"address\"}],\"name\":\"setYStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_zStorageFacade\",\"type\":\"address\"}],\"name\":\"setZStorageFacade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StorageFacadeManager", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000007d317031189949accd7fe6a72ae2138090d31a83000000000000000000000000d88092604d104df798764663040b0bceb90f78770000000000000000000000001648c920644c1f6662f8fb8939e65125f7cb05e6000000000000000000000000be6a6f90e10ba3449b320bb277defae21a93f90500000000000000000000000059875b9faa95caaf4e3fc61835bae3125b16beda00000000000000000000000091357471bd10f86b3d7ff5c7b710239099edb2390000000000000000000000003c8a1df4a9c30553e66b48a285536992a91c4d05000000000000000000000000c2853d511dc9bc792d53cb4b740446b7ff57b1a20000000000000000000000004723affff27d6b6ae01b74e5dc396a29a1adf263000000000000000000000000f5e8c8098c899a2407ceed24fcb782a4b5cd7c1a0000000000000000000000008283439ddbd6a9f603b2a5806c543392a73c20650000000000000000000000001e5ed92eb4ee192d9d43f6375638b158356b06c2000000000000000000000000c2e4be35f56da05f7622ad545b11deae8db32364000000000000000000000000a5b77fda81e352917c30a7f5dd2c97930d7180d8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}