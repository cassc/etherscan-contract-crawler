{"SourceCode": "// Sources flattened with hardhat v2.11.2 https://hardhat.org\r\n\r\n// File contracts/AttackStaking.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\ncontract AttackStaking {\r\n    IERC20 public rewardsToken;\r\n    IERC20 public stakingToken;\r\n\r\n    \r\n  \r\n    mapping(address => uint) public rewards;\r\n    \r\n\r\n    uint private _totalSupply;\r\n    mapping(address => uint) private _balances;\r\n    mapping(address => uint) private _lastUpdateTimes;\r\n    bool private _enableLock;\r\n    address private _ownerAddr;\r\n    uint private _maximumLimit;\r\n    uint private _apyRate;\r\n    uint private _stakingFee;\r\n    uint private _withdrawFee;\r\n\r\n    event RewardUpdated(address account, uint rewards, uint lastUpdateTime);\r\n    event Stake(address account, uint amount, uint amountSoFar);\r\n    event Withdraw(address account, uint amount, uint amountRemaining);\r\n    event ClaimReward(address account, uint amount);\r\n    \r\n   \r\n\r\n    constructor(address _stakingToken, address _rewardsToken) {\r\n        stakingToken = IERC20(_stakingToken);\r\n        rewardsToken = IERC20(_rewardsToken);\r\n        _ownerAddr = msg.sender;\r\n        _enableLock = false;\r\n    }\r\n\r\n   \r\n    function enableLock() public {\r\n        require(msg.sender == _ownerAddr, \"You can enable Lock features.\");\r\n        _enableLock = false;\r\n    }\r\n    \r\n    function enableUnLock() public {\r\n        require(msg.sender == _ownerAddr, \"You can enable Lock features.\");\r\n        _enableLock = true;\r\n        \r\n        \r\n    }\r\n\r\n    function earned(address account) public view returns (uint) {\r\n        \r\n        if (_totalSupply == 0) {\r\n            return 0;\r\n        }\r\n        if (_enableLock == false){\r\n            return 0;\r\n        }\r\n        else{ \r\n            uint256 reward = (_balances[account] *  (block.timestamp - _lastUpdateTimes[account]) * _apyRate) / (365 * 24 hours * 100); \r\n            return reward;\r\n        }\r\n    }\r\n    \r\n\r\n    modifier updateReward(address account) {\r\n        rewards[account] += earned(account);\r\n        _lastUpdateTimes[account] = block.timestamp;\r\n        emit RewardUpdated(account, rewards[account], _lastUpdateTimes[account]);\r\n        _;\r\n    }\r\n\r\n\tfunction setOwner(address account) public\r\n\t{\r\n\t\trequire(msg.sender == _ownerAddr, \"Only the owner can call this function\");\r\n\t\t_ownerAddr = account;\r\n\t}\r\n\t\r\n    function stake(uint _amount) external updateReward(msg.sender) {\r\n        require(_balances[msg.sender] + _amount <= _maximumLimit, \"Staking amount exceed Maximum Limit\");\r\n        _totalSupply += _amount * (100 - _stakingFee) / 100;\r\n        _balances[msg.sender] += _amount * (100 - _stakingFee) / 100;\r\n        \r\n        stakingToken.transferFrom(msg.sender, address(this), _amount);\r\n        \r\n        emit Stake(msg.sender, _amount, _balances[msg.sender]);\r\n    }\r\n\r\n    function restake() external updateReward(msg.sender) {\r\n        uint reward = rewards[msg.sender];\r\n        _totalSupply += reward;\r\n        _balances[msg.sender] += reward;\r\n        rewards[msg.sender] = 0;\r\n    }\r\n\r\n\tfunction withdraw(uint _amount) external updateReward(msg.sender) \r\n\t{\r\n\t_totalSupply -= _amount;\r\n\t_balances[msg.sender] -= _amount;\r\n\r\n\tbool sent = stakingToken.transfer(msg.sender, _amount * (100 - _withdrawFee) / 100);\r\n\trequire(sent, \"Stakingtoken transfer failed\");\r\n\r\n\temit Withdraw(msg.sender, _amount, _balances[msg.sender]);\r\n\r\n}\r\n\r\n    function claimReward() external updateReward(msg.sender) {\r\n        \r\n        uint reward = rewards[msg.sender];\r\n        rewards[msg.sender] = 0;\r\n        rewardsToken.transfer(msg.sender, reward);\r\n\r\n        emit ClaimReward(msg.sender, reward);\r\n    }\r\n    \r\n    function getStackingAmount(address account) public view returns(uint){\r\n        return _balances[account];   \r\n    }\r\n\r\n    function getDailyProfit(uint _amount) public view returns(uint){\r\n        return (_balances[msg.sender] + _amount) * _apyRate/ (365 * 100); \r\n    }\r\n\r\n    function getEarnedAmount(address account) public view returns(uint){\r\n        uint reward = (_balances[account] *  (block.timestamp - _lastUpdateTimes[account]) * _apyRate) / (365 * 24 hours * 100); \r\n        reward += rewards[account];  \r\n        return reward;\r\n    }\r\n\r\n    function setMaximumAmount(uint _amount) external {\r\n        require(msg.sender == _ownerAddr, \"You can set Maximum Limit\");\r\n        _maximumLimit = _amount;\r\n        \r\n    }\r\n\r\n    function getMaxmumAmount() public view returns(uint){\r\n        return _maximumLimit;\r\n    }\r\n\r\n    function setApyRate(uint _amount) external {\r\n        require(msg.sender == _ownerAddr, \"You can set Maximum Limit\");\r\n        _apyRate = _amount;\r\n        \r\n    }\r\n\r\n    function getApyRate() public view returns(uint){\r\n        return _apyRate;\r\n    }\r\n\r\n\r\n    function setStakingFee(uint _amount) external {\r\n        require(msg.sender == _ownerAddr, \"You can set Maximum Limit\");\r\n        _stakingFee = _amount;\r\n        \r\n    }\r\n\r\n    function getStakingFee() public view returns(uint){\r\n        return _stakingFee;\r\n    }\r\n\r\n\r\n    function setWithdrawFee(uint _amount) external {\r\n        require(msg.sender == _ownerAddr, \"You can set Maximum Limit\");\r\n        _withdrawFee = _amount;\r\n        \r\n    }\r\n\r\n    function getWithdrawFee() public view returns(uint){\r\n        return _withdrawFee;\r\n    }\r\n\r\n    function getTotalStaked() public view returns(uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastUpdateTime\",\"type\":\"uint256\"}],\"name\":\"RewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSoFar\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountRemaining\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableUnLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getApyRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getDailyProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getEarnedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxmumAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStackingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setApyRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMaximumAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setStakingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setWithdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AttackStaking", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f868939ee81f04f463010bc52eab91c0839ef08c000000000000000000000000f868939ee81f04f463010bc52eab91c0839ef08c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://322ce13f6a5cd3becc1c936024ac0e12146bdbb7d9fd47a6c2b3d0e80d98ae49"}