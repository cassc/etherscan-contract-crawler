{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Archimedes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"./PiAdmin.sol\\\";\\nimport \\\"../interfaces/IPiToken.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IReferral.sol\\\";\\nimport \\\"../interfaces/IStrategy.sol\\\";\\nimport \\\"../interfaces/IWNative.sol\\\";\\n\\ncontract Archimedes is PiAdmin, ReentrancyGuard {\\n    // using Address for address;\\n    using SafeERC20 for IERC20;\\n\\n    // Used for native token deposits/withdraws\\n    IWNative public immutable WNative;\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IERC20 want;             // Address of token contract.\\n        uint weighing;           // How much weighing assigned to this pool. PIes to distribute per block.\\n        uint lastRewardBlock;    // Last block number that PIes distribution occurs.\\n        uint accPiTokenPerShare; // Accumulated PIes per share, times SHARE_PRECISION. See below.\\n        address controller;      // Token controller\\n    }\\n\\n    // IPiToken already have safe transfer from SuperToken\\n    IPiToken public immutable piToken;\\n\\n    // Used to made multiplications and divitions over shares\\n    uint public constant SHARE_PRECISION = 1e18;\\n\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n    // Info of each user that stakes tokens.\\n    // Users can't transfer controller's minted tokens\\n    mapping(uint => mapping(address => uint)) public userPaidRewards;\\n    // Total weighing. Must be the sum of all pools weighing.\\n    uint public totalWeighing;\\n    // The block number when PI mining starts.\\n    uint public immutable startBlock;\\n\\n    // PiToken referral contract address.\\n    IReferral public referralMgr;\\n    // Referral commission rate in basis points.\\n    uint16 public referralCommissionRate = 10; // 1%\\n    // Max referral commission rate: 5%.\\n    uint16 public constant MAXIMUM_REFERRAL_COMMISSION_RATE = 50; // 5%\\n    uint16 public constant COMMISSION_RATE_PRECISION = 1000;\\n\\n    event Deposit(uint indexed pid, address indexed user, uint amount);\\n    event Withdraw(uint indexed pid, address indexed user, uint amount);\\n    event EmergencyWithdraw(uint indexed pid, address indexed user, uint amount);\\n    event NewPool(uint indexed pid, address want, uint weighing);\\n    event PoolWeighingUpdated(uint indexed pid, uint oldWeighing, uint newWeighing);\\n    event Harvested(uint indexed pid, address indexed user, uint amount);\\n\\n    constructor(IPiToken _piToken, uint _startBlock, IWNative _wNative) {\\n        require(address(_piToken) != address(0), \\\"Pi address !ZeroAddress\\\");\\n        require(_startBlock > _blockNumber(), \\\"StartBlock must be in the future\\\");\\n\\n        piToken = _piToken;\\n        startBlock = _startBlock;\\n        WNative = _wNative;\\n    }\\n\\n    // Deposit Native\\n    receive() external payable { }\\n\\n    modifier onlyController(uint _pid) {\\n        require(poolInfo[_pid].controller == msg.sender, \\\"!Controller\\\");\\n        _;\\n    }\\n\\n    // Add a new want token to the pool. Can only be called by the owner.\\n    function addNewPool(IERC20 _want, address _ctroller, uint _weighing, bool _massUpdate) external onlyAdmin {\\n        require(address(_want) != address(0), \\\"Address zero not allowed\\\");\\n        require(IController(_ctroller).archimedes() == address(this), \\\"Not an Archimedes controller\\\");\\n        require(IController(_ctroller).strategy() != address(0), \\\"Controller without strategy\\\");\\n\\n        // Update pools before a weighing change\\n        if (_massUpdate) { massUpdatePools(); }\\n\\n        uint lastRewardBlock = _blockNumber() > startBlock ? _blockNumber() : startBlock;\\n\\n        totalWeighing += _weighing;\\n\\n        poolInfo.push(PoolInfo({\\n            want: _want,\\n            weighing: _weighing,\\n            lastRewardBlock: lastRewardBlock,\\n            accPiTokenPerShare: 0,\\n            controller: _ctroller\\n        }));\\n\\n        uint _pid = poolInfo.length - 1;\\n        uint _setPid = IController(_ctroller).setPid(_pid);\\n        require(_pid == _setPid, \\\"Pid doesn't match\\\");\\n\\n        emit NewPool(_pid, address(_want), _weighing);\\n    }\\n\\n    // Update the given pool's rewards weighing .\\n    function changePoolWeighing(uint _pid, uint _weighing, bool _massUpdate) external onlyAdmin {\\n        emit PoolWeighingUpdated(_pid, poolInfo[_pid].weighing, _weighing);\\n\\n        // Update pools before a weighing change\\n        if (_massUpdate) {\\n            massUpdatePools();\\n        } else {\\n            updatePool(_pid);\\n        }\\n\\n        totalWeighing = (totalWeighing - poolInfo[_pid].weighing) + _weighing;\\n        poolInfo[_pid].weighing = _weighing;\\n    }\\n\\n    // Return reward multiplier over the given _from to _to block.\\n    function _getMultiplier(uint _from, uint _to) internal pure returns (uint) {\\n        return _to - _from;\\n    }\\n\\n    // View function to see pending PIes on frontend.\\n    function pendingPiToken(uint _pid, address _user) external view returns (uint) {\\n        PoolInfo storage pool = poolInfo[_pid];\\n\\n        uint accPiTokenPerShare = pool.accPiTokenPerShare;\\n        uint sharesTotal = _controller(_pid).totalSupply();\\n\\n        if (_blockNumber() > pool.lastRewardBlock && sharesTotal > 0 && piToken.communityLeftToMint() > 0) {\\n            uint multiplier = _getMultiplier(pool.lastRewardBlock, _blockNumber());\\n            uint piTokenReward = (multiplier * piTokenPerBlock() * pool.weighing) / totalWeighing;\\n            accPiTokenPerShare += (piTokenReward * SHARE_PRECISION) / sharesTotal;\\n        }\\n        return ((_userShares(_pid, _user) * accPiTokenPerShare) / SHARE_PRECISION) - paidRewards(_pid, _user);\\n    }\\n\\n    // Update reward variables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        for (uint pid = 0; pid < poolInfo.length; ++pid) {\\n            updatePool(pid);\\n            if (_outOfGasForLoop()) { break; }\\n        }\\n    }\\n\\n    // Mint community tokens for a given pool pid\\n    function updatePool(uint _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n\\n        // If same block as last update return\\n        if (_blockNumber() <= pool.lastRewardBlock) { return; }\\n\\n        // If community Mint is already finished\\n        uint communityLeftToMint = piToken.communityLeftToMint();\\n        if (communityLeftToMint <= 0) {\\n            pool.lastRewardBlock = _blockNumber();\\n            return;\\n        }\\n\\n        uint sharesTotal = _controller(_pid).totalSupply();\\n\\n        if (sharesTotal <= 0 || pool.weighing <= 0) {\\n            pool.lastRewardBlock = _blockNumber();\\n            return;\\n        }\\n\\n        uint multiplier = _getMultiplier(pool.lastRewardBlock, _blockNumber());\\n        uint piTokenReward = (multiplier * piTokenPerBlock() * pool.weighing) / totalWeighing;\\n\\n        // No rewards =( update lastRewardBlock\\n        if (piTokenReward <= 0) {\\n            pool.lastRewardBlock = _blockNumber();\\n            return;\\n        }\\n\\n        // If the reward is greater than the left to mint\\n        if (piTokenReward > communityLeftToMint) {\\n            piTokenReward = communityLeftToMint;\\n        }\\n\\n        piToken.communityMint(address(this), piTokenReward);\\n\\n        pool.accPiTokenPerShare += (piTokenReward * SHARE_PRECISION) / sharesTotal;\\n        pool.lastRewardBlock = _blockNumber();\\n    }\\n\\n    // Direct native deposit\\n    function depositNative(uint _pid, address _referrer) external payable nonReentrant {\\n        uint _amount = msg.value;\\n        require(_amount > 0, \\\"Insufficient deposit\\\");\\n        require(address(poolInfo[_pid].want) == address(WNative), \\\"Only Native token pool\\\");\\n\\n        // Update pool rewards\\n        updatePool(_pid);\\n\\n        // Record referral if it's needed\\n        _recordReferral(_pid, _referrer);\\n\\n        // Pay rewards\\n        _calcPendingAndPayRewards(_pid, msg.sender);\\n\\n        // With that Archimedes already has the wNative\\n        WNative.deposit{value: _amount}();\\n\\n        // Deposit in the controller\\n        _depositInStrategy(_pid, _amount);\\n    }\\n\\n    // Deposit want token to Archimedes for PI allocation.\\n    function deposit(uint _pid, uint _amount, address _referrer) public nonReentrant {\\n        require(_amount > 0, \\\"Insufficient deposit\\\");\\n\\n        // Update pool rewards\\n        updatePool(_pid);\\n\\n        // Record referral if it's needed\\n        _recordReferral(_pid, _referrer);\\n\\n        // Pay rewards\\n        _calcPendingAndPayRewards(_pid, msg.sender);\\n\\n        // Transfer from user => Archimedes\\n        poolInfo[_pid].want.safeTransferFrom(msg.sender, address(this), _amount);\\n\\n        // Deposit in the controller\\n        _depositInStrategy(_pid, _amount);\\n    }\\n\\n    function depositAll(uint _pid, address _referrer) external {\\n        require(address(poolInfo[_pid].want) != address(WNative), \\\"Can't deposit all Native\\\");\\n        uint _balance = poolInfo[_pid].want.balanceOf(msg.sender);\\n\\n        deposit(_pid, _balance, _referrer);\\n    }\\n\\n    // Withdraw want token from Archimedes.\\n    function withdraw(uint _pid, uint _shares) public nonReentrant {\\n        require(_shares > 0, \\\"0 shares\\\");\\n        require(_userShares(_pid) >= _shares, \\\"withdraw: not sufficient founds\\\");\\n\\n        updatePool(_pid);\\n\\n        // Pay rewards\\n        _calcPendingAndPayRewards(_pid, msg.sender);\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n\\n        uint _before = _wantBalance(pool.want);\\n        // this should burn shares and control the amount\\n        uint withdrawn = _controller(_pid).withdraw(msg.sender, _shares);\\n        require(withdrawn > 0, \\\"No funds withdrawn\\\");\\n\\n        uint _balance = _wantBalance(pool.want) - _before;\\n\\n        // In case we have WNative we unwrap to Native\\n        if (address(pool.want) == address(WNative)) {\\n            // Unwrap WNative => Native\\n            WNative.withdraw(_balance);\\n\\n            Address.sendValue(payable(msg.sender), _balance);\\n        } else {\\n            pool.want.safeTransfer(address(msg.sender), _balance);\\n        }\\n\\n        // This is to \\\"save\\\" like the new amount of shares was paid\\n        _updateUserPaidRewards(_pid, msg.sender);\\n\\n        emit Withdraw(_pid, msg.sender, _shares);\\n    }\\n\\n    function withdrawAll(uint _pid) external {\\n        withdraw(_pid, _userShares(_pid));\\n    }\\n\\n    // Claim rewards for a pool\\n    function harvest(uint _pid) public nonReentrant {\\n        _harvest(_pid, msg.sender);\\n    }\\n\\n    function _harvest(uint _pid, address _user) internal {\\n        if (_userShares(_pid, _user) <= 0) { return; }\\n\\n        updatePool(_pid);\\n\\n        _calcPendingAndPayRewards(_pid, _user);\\n\\n        _updateUserPaidRewards(_pid, _user);\\n    }\\n\\n    function harvestAll() external {\\n        uint length = poolInfo.length;\\n        for (uint pid = 0; pid < length; ++pid) {\\n            harvest(pid);\\n            if (_outOfGasForLoop()) { break; }\\n        }\\n    }\\n\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint _pid) external nonReentrant {\\n        IERC20 want = poolInfo[_pid].want;\\n\\n        userPaidRewards[_pid][msg.sender] = 0;\\n\\n        uint _shares = _userShares(_pid);\\n\\n        require(_shares > 0, \\\"No shares to withdraw\\\");\\n\\n        uint _before = _wantBalance(want);\\n        // this should burn shares and control the amount\\n        _controller(_pid).withdraw(msg.sender, _shares);\\n\\n        uint __wantBalance = _wantBalance(want) - _before;\\n        want.safeTransfer(address(msg.sender), __wantBalance);\\n\\n        emit EmergencyWithdraw(_pid, msg.sender, _shares);\\n    }\\n\\n    // Controller callback before transfer to harvest users rewards\\n    function beforeSharesTransfer(uint _pid, address _from, address _to, uint amount) external onlyController(_pid) {\\n        if (amount <= 0) { return; }\\n\\n        // harvest rewards for\\n        _harvest(_pid, _from);\\n\\n        // Harvest the shares receiver just in case\\n        _harvest(_pid, _to);\\n    }\\n\\n    // Controller callback after transfer to update users rewards\\n    function afterSharesTransfer(uint _pid, address _from, address _to, uint amount) external onlyController(_pid) {\\n        if (amount <= 0) { return; }\\n\\n        // Reset users \\\"paidRewards\\\"\\n        _updateUserPaidRewards(_pid, _from);\\n        _updateUserPaidRewards(_pid, _to);\\n    }\\n\\n    function _updateUserPaidRewards(uint _pid, address _user) internal {\\n        userPaidRewards[_pid][_user] = (_userShares(_pid, _user) * poolInfo[_pid].accPiTokenPerShare) / SHARE_PRECISION;\\n    }\\n\\n    function _wantBalance(IERC20 _want) internal view returns (uint) {\\n        return _want.balanceOf(address(this));\\n    }\\n\\n    // Record referral in referralMgr contract if needed\\n    function _recordReferral(uint _pid, address _referrer) internal {\\n        // only if it's the first deposit\\n        if (_userShares(_pid) <= 0 && _referrer != address(0) &&\\n            _referrer != msg.sender && address(referralMgr) != address(0)) {\\n\\n            referralMgr.recordReferral(msg.sender, _referrer);\\n        }\\n    }\\n\\n    function _depositInStrategy(uint _pid, uint _amount) internal {\\n        PoolInfo storage pool = poolInfo[_pid];\\n\\n        // Archimedes => controller transfer & deposit\\n        pool.want.safeIncreaseAllowance(pool.controller, _amount);\\n        _controller(_pid).deposit(msg.sender, _amount);\\n\\n        // This is to \\\"save\\\" like the new amount of shares was paid\\n        _updateUserPaidRewards(_pid, msg.sender);\\n\\n        emit Deposit(_pid, msg.sender, _amount);\\n    }\\n\\n    // Pay rewards\\n    function _calcPendingAndPayRewards(uint _pid, address _user) internal returns (uint pending) {\\n        uint _shares = _userShares(_pid, _user);\\n\\n        if (_shares > 0) {\\n            pending = ((_shares * poolInfo[_pid].accPiTokenPerShare) / SHARE_PRECISION) - paidRewards(_pid, _user);\\n\\n            if (pending > 0) {\\n                _safePiTokenTransfer(_user, pending);\\n                _payReferralCommission(_user, pending);\\n\\n                emit Harvested(_pid, _user, pending);\\n            }\\n        }\\n    }\\n\\n    // Safe piToken transfer function, just in case if rounding error causes pool to not have enough PI.\\n    function _safePiTokenTransfer(address _to, uint _amount) internal {\\n        uint piTokenBal = piToken.balanceOf(address(this));\\n\\n        if (_amount > piTokenBal) {\\n            _amount = piTokenBal;\\n        }\\n\\n        // piToken.transfer is safe\\n        piToken.transfer(_to, _amount);\\n    }\\n\\n    // Update the referral contract address by the owner\\n    function setReferralAddress(IReferral _newReferral) external onlyAdmin {\\n        require(_newReferral != referralMgr, \\\"Same Manager\\\");\\n        require(address(_newReferral) != address(0), \\\"!ZeroAddress\\\");\\n        referralMgr = _newReferral;\\n    }\\n\\n    // Update referral commission rate by the owner\\n    function setReferralCommissionRate(uint16 _referralCommissionRate) external onlyAdmin {\\n        require(_referralCommissionRate != referralCommissionRate, \\\"Same rate\\\");\\n        require(_referralCommissionRate <= MAXIMUM_REFERRAL_COMMISSION_RATE, \\\"rate greater than MaxCommission\\\");\\n        referralCommissionRate = _referralCommissionRate;\\n    }\\n\\n    // Pay referral commission to the referrer who referred this user.\\n    function _payReferralCommission(address _user, uint _pending) internal {\\n        if (address(referralMgr) != address(0) && referralCommissionRate > 0) {\\n            address referrer = referralMgr.getReferrer(_user);\\n\\n            uint commissionAmount = (_pending * referralCommissionRate) / COMMISSION_RATE_PRECISION;\\n            if (referrer != address(0) && commissionAmount > 0) {\\n                uint communityLeftToMint = piToken.communityLeftToMint();\\n\\n                if (communityLeftToMint < commissionAmount) {\\n                    commissionAmount = communityLeftToMint;\\n                }\\n\\n                if (commissionAmount > 0) {\\n                    piToken.communityMint(referrer, commissionAmount);\\n                    referralMgr.referralPaid(referrer, commissionAmount); // sum paid\\n                }\\n            }\\n        }\\n    }\\n\\n    // View functions\\n    function poolLength() external view returns (uint) {\\n        return poolInfo.length;\\n    }\\n\\n    function _userShares(uint _pid) public view returns (uint) {\\n        return _controller(_pid).balanceOf(msg.sender);\\n    }\\n    function _userShares(uint _pid, address _user) public view returns (uint) {\\n        return _controller(_pid).balanceOf(_user);\\n    }\\n\\n    function paidRewards(uint _pid) public view returns (uint) {\\n        return userPaidRewards[_pid][msg.sender];\\n    }\\n    function paidRewards(uint _pid, address _user) public view returns (uint) {\\n        return userPaidRewards[_pid][_user];\\n    }\\n    function _controller(uint _pid) internal view returns (IController) {\\n        return IController(poolInfo[_pid].controller);\\n    }\\n\\n    function getPricePerFullShare(uint _pid) external view returns (uint) {\\n        uint _totalSupply = _controller(_pid).totalSupply();\\n        uint precision = 10 ** decimals(_pid);\\n\\n        return _totalSupply <= 0 ? precision : ((_controller(_pid).balance() * precision) / _totalSupply);\\n    }\\n    function decimals(uint _pid) public view returns (uint) {\\n        return _controller(_pid).decimals();\\n    }\\n    function balance(uint _pid) external view returns (uint) {\\n        return _controller(_pid).balance();\\n    }\\n    function balanceOf(uint _pid, address _user) external view returns (uint) {\\n        return _controller(_pid).balanceOf(_user);\\n    }\\n\\n    function paused(uint _pid) external view returns (bool) {\\n        return IStrategy(_controller(_pid).strategy()).paused();\\n    }\\n\\n    function availableDeposit(uint _pid) external view returns (uint) {\\n        return _controller(_pid).availableDeposit();\\n    }\\n\\n    function availableUserDeposit(uint _pid, address _user) external view returns (uint) {\\n        return _controller(_pid).availableUserDeposit(_user);\\n    }\\n\\n    function piTokenPerBlock() public view returns (uint) {\\n        // Skip 0~5% of minting per block for Referrals\\n        uint reserve = COMMISSION_RATE_PRECISION - referralCommissionRate;\\n        return piToken.communityMintPerBlock() * reserve / COMMISSION_RATE_PRECISION;\\n    }\\n\\n    function poolStrategyInfo(uint _pid) external view returns (\\n        IStrategy strategy,\\n        string memory stratIdentifier\\n    ) {\\n        strategy = IStrategy(_controller(_pid).strategy());\\n        stratIdentifier = strategy.identifier();\\n    }\\n\\n    // Only to be mocked\\n    function _blockNumber() internal view virtual returns (uint) {\\n        return block.number;\\n    }\\n\\n    // In case of stucketd 2Pi tokens after 2.5 years\\n    // check if any holder has pending tokens then call this fn\\n    // E.g. in case of a few EmergencyWithdraw the rewards will be stucked\\n    function redeemStuckedPiTokens() external onlyAdmin {\\n        require(piToken.totalSupply() == piToken.MAX_SUPPLY(), \\\"PiToken still minting\\\");\\n        // 2.5 years (2.5 * 365 * 24 * 3600) / 2.4s per block == 32850000\\n        require(_blockNumber() > (startBlock + 32850000), \\\"Still waiting\\\");\\n\\n        uint _balance = piToken.balanceOf(address(this));\\n\\n        if (_balance > 0) { piToken.transfer(msg.sender, _balance); }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PiAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\nabstract contract PiAdmin is AccessControl {\\n    constructor() {\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not an admin\\\");\\n        _;\\n    }\\n\\n    // @dev Used to break loops if gasleft is less than 20k\\n    function _outOfGasForLoop() internal view returns (bool) {\\n        return gasleft() <= 20_000;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IPiToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"../vendor_contracts/NativeSuperTokenProxy.sol\\\";\\n\\n// Used in Archimedes\\ninterface IPiToken is ISuperToken {\\n    function apiMint(address _receiver, uint _supply) external;\\n    function communityMint(address _receiver, uint _supply) external;\\n    function communityMintPerBlock() external view returns(uint);\\n    function apiMintPerBlock() external view returns(uint);\\n    function communityLeftToMint() external view returns(uint);\\n    function apiLeftToMint() external view returns(uint);\\n    function MAX_SUPPLY() external view returns(uint);\\n}\\n\\n// Used for tests\\ninterface IPiTokenMocked is IPiToken {\\n    function initRewardsOn(uint _startBlock) external;\\n    function init() external;\\n    function addMinter(address newMinter) external;\\n    function addBurner(address newBurner) external;\\n    function cap() external view returns(uint);\\n    function INITIAL_SUPPLY() external view returns(uint);\\n    function setBlockNumber(uint n) external;\\n    function setCommunityMintPerBlock(uint n) external;\\n    function setApiMintPerBlock(uint n) external;\\n    function mintForMultiChain(uint n, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"interfaces/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IController {\\n    function strategy() external view returns (address);\\n    function totalSupply() external view returns (uint);\\n    function balance() external view returns (uint);\\n    function balanceOf(address _user) external view returns (uint);\\n    function decimals() external view returns (uint);\\n    function archimedes() external view returns (address);\\n    function deposit(address _depositor, uint _amount) external;\\n    function withdraw(address _depositor, uint _shares) external returns (uint);\\n    function setPid(uint pid) external returns (uint);\\n    function depositLimit() external view returns (uint);\\n    function userDepositLimit(address) external view returns (uint);\\n    function availableDeposit() external view returns (uint);\\n    function availableUserDeposit(address) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"interfaces/IReferral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IReferral {\\n    function recordReferral(address, address referrer) external;\\n    function referralPaid(address user, uint amount) external;\\n    function getReferrer(address user) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IStrategy {\\n    function balance() external view returns (uint);\\n    function balanceOf() external view returns (uint);\\n    function beforeMovement() external;\\n    function deposit() external;\\n    function paused() external view returns (bool);\\n    function retireStrat() external;\\n    function want() external view returns (address);\\n    function withdraw(uint) external returns (uint);\\n    function identifier() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"interfaces/IWNative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWNative is IERC20 {\\n    function deposit() external payable;\\n    function withdraw(uint amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"vendor_contracts/NativeSuperTokenProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\n\\ninterface ISuperfluidToken {\\n\\n    /**************************************************************************\\n     * Basic information\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /**************************************************************************\\n     * Real-time balance functions\\n     *************************************************************************/\\n\\n    /**\\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\\n    * @param account for the query\\n    * @param timestamp Time of balance\\n    * @return availableBalance Real-time balance\\n    * @return deposit Account deposit\\n    * @return owedDeposit Account owed Deposit\\n    */\\n    function realtimeBalanceOf(\\n       address account,\\n       uint256 timestamp\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /// @dev realtimeBalanceOf with timestamp equals to block timestamp\\n    function realtimeBalanceOfNow(\\n       address account\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit,\\n            uint256 timestamp);\\n\\n    /**\\n    * @dev Check if one account is critical\\n    * @param account Account check if is critical by a future time\\n    * @param timestamp Time of balance\\n    * @return isCritical\\n    */\\n    function isAccountCritical(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n    * @dev Check if one account is critical now\\n    * @param account Account check if is critical by a future time\\n    * @return isCritical\\n    */\\n    function isAccountCriticalNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n     * @dev Check if one account is solvent\\n     * @param account Account check if is solvent by a future time\\n     * @param timestamp Time of balance\\n     * @return isSolvent\\n     */\\n    function isAccountSolvent(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n     * @dev Check if one account is solvent now\\n     * @param account Account check if is solvent now\\n     * @return isSolvent\\n     */\\n    function isAccountSolventNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n    * @dev Get a list of agreements that is active for the account\\n    * @dev An active agreement is one that has state for the account\\n    * @param account Account to query\\n    * @return activeAgreements List of accounts that have non-zero states for the account\\n    */\\n    function getAccountActiveAgreements(address account)\\n       external view\\n       returns(ISuperAgreement[] memory activeAgreements);\\n\\n\\n   /**************************************************************************\\n    * Super Agreement hosting functions\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function createAgreement(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n\\n    /**\\n     * @dev Agreement creation event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementCreated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Get data of the agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @return data Data of the agreement\\n     */\\n    function getAgreementData(\\n        address agreementClass,\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external view\\n        returns(bytes32[] memory data);\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function updateAgreementData(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n\\n    /**\\n     * @dev Agreement creation event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementUpdated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Close the agreement\\n     * @param id Agreement ID\\n     */\\n    function terminateAgreement(\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external;\\n\\n    /**\\n     * @dev Agreement termination event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     */\\n    event AgreementTerminated(\\n        address indexed agreementClass,\\n        bytes32 id\\n    );\\n\\n    /**\\n     * @dev Update agreement state slot\\n     * @param account Account to be updated\\n     *\\n     * NOTE\\n     * - To clear the storage out, provide zero-ed array of intended length\\n     */\\n    function updateAgreementStateSlot(\\n        address account,\\n        uint256 slotId,\\n        bytes32[] calldata slotData\\n    )\\n        external;\\n\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account updated\\n     * @param slotId slot id of the agreement state\\n     */\\n    event AgreementStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        uint256 slotId\\n    );\\n\\n    /**\\n     * @dev Get data of the slot of the state of a agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account to query\\n     * @param slotId slot id of the state\\n     * @param dataLength length of the state data\\n     */\\n    function getAgreementStateSlot(\\n        address agreementClass,\\n        address account,\\n        uint256 slotId,\\n        uint dataLength\\n    )\\n        external view\\n        returns (bytes32[] memory slotData);\\n\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account of the agrement\\n     * @param state Agreement state of the account\\n     */\\n    event AgreementAccountStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        bytes state\\n    );\\n\\n    /**\\n     * @dev Settle balance from an account by the agreement.\\n     *      The agreement needs to make sure that the balance delta is balanced afterwards\\n     * @param account Account to query.\\n     * @param delta Amount of balance delta to be settled\\n     *\\n     * Modifiers:\\n     *  - onlyAgreement\\n     */\\n    function settleBalance(\\n        address account,\\n        int256 delta\\n    )\\n        external;\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAccount Account that collect the reward\\n     * @param rewardAmount Amount of liquidation reward\\n     */\\n    event AgreementLiquidated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed rewardAccount,\\n        uint256 rewardAmount\\n    );\\n\\n    /**\\n     * @dev System bailout occurred (DEPRECATIED BY AgreementLiquidatedBy)\\n     * @param bailoutAccount Account that bailout the penalty account\\n     * @param bailoutAmount Amount of account bailout\\n     */\\n    event Bailout(\\n        address indexed bailoutAccount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Agreement liquidation event (including agent account)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param bondAccount Account that collect the reward or bailout accounts\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of liquidation bailouot\\n     *\\n     * NOTE:\\n     * Reward account rule:\\n     * - if bailout is equal to 0, then\\n     *   - the bondAccount will get the rewardAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount.\\n     * - if bailout is larger than 0, then\\n     *   - the liquidatorAccount will get the rewardAmouont,\\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\\n     */\\n    event AgreementLiquidatedBy(\\n        address liquidatorAccount,\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed bondAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Make liquidation payouts\\n     * @param id Agreement ID\\n     * @param liquidator Address of the executer of liquidation\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of account bailout needed\\n     *\\n     * NOTE:\\n     * Liquidation rules:\\n     *  - If a bailout is required (bailoutAmount > 0)\\n     *     - the actual reward goes to the liquidator,\\n     *     - while the reward account becomes the bailout account\\n     *     - total bailout include: bailout amount + reward amount\\n     *\\n     * Modifiers:\\n     *  - onlyAgreement\\n     */\\n    function makeLiquidationPayouts\\n    (\\n        bytes32 id,\\n        address liquidator,\\n        address penaltyAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    )\\n        external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * NOTE: solidity-coverage not supporting it\\n     *************************************************************************/\\n\\n     /// @dev The msg.sender must be host contract\\n     //modifier onlyHost() virtual;\\n\\n    /// @dev The msg.sender must be a listed agreement.\\n    //modifier onlyAgreement() virtual;\\n\\n}\\n\\ninterface ISuperAgreement {\\n\\n    /**\\n     * @dev Initialize the agreement contract\\n     */\\n    function initialize() external;\\n\\n    /**\\n     * @dev Get the type of the agreement class.\\n     */\\n    function agreementType() external view returns (bytes32);\\n\\n    /**\\n     * @dev Calculate the real-time balance for the account of this agreement class.\\n     * @param account Account the state belongs to\\n     * @param time Future time used for the calculation.\\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement.\\n     * @return deposit Account deposit amount of this agreement.\\n     * @return owedDeposit Account owed deposit amount of this agreement.\\n     */\\n    function realtimeBalanceOf(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 time\\n    )\\n        external\\n        view\\n        returns (\\n            int256 dynamicBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n}\\n\\ninterface TokenInfo {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\\ninterface ISuperToken is ISuperfluidToken, TokenInfo, IERC20, IERC777 {\\n\\n    /// @dev Initialize the contract\\n    function initialize(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        string calldata n,\\n        string calldata s\\n    ) external;\\n\\n    /**************************************************************************\\n    * TokenInfo & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: SuperToken always uses 18 decimals.\\n     *\\n     * Note: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view override(TokenInfo) returns (uint8);\\n\\n    /**************************************************************************\\n    * ERC20 & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\\n\\n    /**************************************************************************\\n    * ERC20\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**************************************************************************\\n    * ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For super token contracts, this value is 1 always\\n     */\\n    function granularity() external view override(IERC777) returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**************************************************************************\\n     * SuperToken custom token functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Mint new tokens for the account\\n     *\\n     * Modifiers:\\n     *  - onlySelf\\n     */\\n    function selfMint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n   /**\\n    * @dev Burn existing tokens for the account\\n    *\\n    * Modifiers:\\n    *  - onlySelf\\n    */\\n   function selfBurn(\\n       address account,\\n       uint256 amount,\\n       bytes memory userData\\n   ) external;\\n\\n    /**************************************************************************\\n     * SuperToken extra functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\\n     */\\n    function transferAll(address recipient) external;\\n\\n    /**************************************************************************\\n     * ERC20 wrapping\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Return the underlying token contract\\n     * @return tokenAddr Underlying token address\\n     */\\n    function getUnderlyingToken() external view returns(address tokenAddr);\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken.\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     *\\n     * NOTE: It will use \u00b4transferFrom\u00b4 to get tokens. Before calling this\\n     * function you should \u00b4approve\u00b4 this contract\\n     */\\n    function upgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\\n     * @param to The account to received upgraded tokens\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     * @param data User data for the TokensRecipient callback\\n     *\\n     * NOTE: It will use \u00b4transferFrom\u00b4 to get tokens. Before calling this\\n     * function you should \u00b4approve\u00b4 this contract\\n     */\\n    function upgradeTo(address to, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Token upgrade event\\n     * @param account Account where tokens are upgraded to\\n     * @param amount Amount of tokens upgraded (in 18 decimals)\\n     */\\n    event TokenUpgraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20.\\n     * @dev It will call transfer to send tokens\\n     * @param amount Number of tokens to be downgraded\\n     */\\n    function downgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Token downgrade event\\n     * @param account Account whose tokens are upgraded\\n     * @param amount Amount of tokens downgraded\\n     */\\n    event TokenDowngraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**************************************************************************\\n    * Batch Operations\\n    *************************************************************************/\\n\\n    /**\\n    * @dev Perform ERC20 approve by host contract.\\n    * @param account The account owner to be approved.\\n    * @param spender The spender of account owner's funds.\\n    * @param amount Number of tokens to be approved.\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationApprove(\\n        address account,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC20 transfer from by host contract.\\n    * @param account The account to spend sender's funds.\\n    * @param spender  The account where the funds is sent from.\\n    * @param recipient The recipient of thefunds.\\n    * @param amount Number of tokens to be transferred.\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationTransferFrom(\\n        address account,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Upgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationUpgrade(address account, uint256 amount) external;\\n\\n    /**\\n    * @dev Downgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\\n    *\\n    * Modifiers:\\n    *  - onlyHost\\n    */\\n    function operationDowngrade(address account, uint256 amount) external;\\n\\n\\n    /**************************************************************************\\n    * Function modifiers for access control and parameter validations\\n    *\\n    * While they cannot be explicitly stated in function definitions, they are\\n    * listed in function definition comments instead for clarity.\\n    *\\n    * NOTE: solidity-coverage not supporting it\\n    *************************************************************************/\\n\\n    /// @dev The msg.sender must be the contract itself\\n    //modifier onlySelf() virtual\\n\\n}\\n\\ninterface ISuperfluidGovernance {\\n\\n    /**\\n     * @dev Replace the current governance with a new governance\\n     */\\n    function replaceGovernance(\\n        ISuperfluid host,\\n        address newGov) external;\\n\\n    /**\\n     * @dev Register a new agreement class\\n     */\\n    function registerAgreementClass(\\n        ISuperfluid host,\\n        address agreementClass) external;\\n\\n    /**\\n     * @dev Update logics of the contracts\\n     *\\n     * NOTE:\\n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\\n     */\\n    function updateContracts(\\n        ISuperfluid host,\\n        address hostNewLogic,\\n        address[] calldata agreementClassNewLogics,\\n        address superTokenFactoryNewLogic\\n    ) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\\n     */\\n    function updateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken token) external;\\n\\n    /// @dev Get configuration as address value\\n    function getConfigAsAddress(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (address value);\\n\\n    /// @dev Get configuration as uint256 value\\n    function getConfigAsUint256(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (uint256 value);\\n\\n}\\n\\nabstract contract ERC20WithTokenInfo is IERC20, TokenInfo {}\\n\\ninterface ISuperTokenFactory {\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /// @dev Initialize the contract\\n    function initialize() external;\\n\\n    /**\\n     * @dev Get the current super token logic used by the factory\\n     */\\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Upgradability modes\\n     */\\n    enum Upgradability {\\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\\n        NON_UPGRADABLE,\\n        /// Upgradable through `host.updateSuperTokenLogic` operation\\n        SEMI_UPGRADABLE,\\n        /// Always using the latest super token logic\\n        FULL_UPGRADABE\\n    }\\n\\n    /**\\n     * @dev Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param underlyingDecimals Underlying token decimals\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     */\\n    function createERC20Wrapper(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Create new super token wrapper for the underlying ERC20 token with extra token info\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     *\\n     * NOTE:\\n     * - It assumes token provide the .decimals() function\\n     */\\n    function createERC20Wrapper(\\n        ERC20WithTokenInfo underlyingToken,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    function initializeCustomSuperToken(\\n        address customSuperTokenProxy\\n    )\\n        external;\\n\\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\\n\\n    event SuperTokenCreated(ISuperToken indexed token);\\n\\n    event CustomSuperTokenCreated(ISuperToken indexed token);\\n\\n}\\n\\ninterface ISuperApp {\\n\\n    /**\\n     * @dev Callback before a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * NOTE:\\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n     * @dev Callback after a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param cbdata The data returned from the before-hook callback.\\n     * @param ctx The context data.\\n     * @return newCtx The current context of the transaction.\\n     *\\n     * NOTE:\\n     * - State changes is permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function afterAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Callback before a new agreement is updated.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * NOTE:\\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n\\n    /**\\n    * @dev Callback after a new agreement is updated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * NOTE:\\n    * - State changes is permitted.\\n    * - Only revert with a \\\"reason\\\" is permitted.\\n    */\\n    function afterAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n    * @dev Callback before a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param ctx The context data.\\n    * @return cbdata A free format in memory data the app can use to pass\\n    *          arbitary information to the after-hook callback.\\n    *\\n    * NOTE:\\n    * - It will be invoked with `staticcall`, no state changes are permitted.\\n    * - Revert is not permitted.\\n    */\\n    function beforeAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n    * @dev Callback after a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * NOTE:\\n    * - State changes is permitted.\\n    * - Revert is not permitted.\\n    */\\n    function afterAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n}\\n\\nlibrary SuperAppDefinitions {\\n\\n    /**************************************************************************\\n    / App manifest config word\\n    /**************************************************************************/\\n\\n    /*\\n     * App level is a way to allow the app to whitelist what other app it can\\n     * interact with (aka. composite app feature).\\n     *\\n     * For more details, refer to the technical paper of superfluid protocol.\\n     */\\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\\n\\n    // The app is at the final level, hence it doesn't want to interact with any other app\\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\\n\\n    // The app is at the second level, it may interact with other final level apps if whitelisted\\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\\n\\n    function getAppLevel(uint256 configWord) internal pure returns (uint8) {\\n        return uint8(configWord & APP_LEVEL_MASK);\\n    }\\n\\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\\n    }\\n\\n    /**************************************************************************\\n    / Callback implementation bit masks\\n    /**************************************************************************/\\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\\n\\n    /**************************************************************************\\n    / App Jail Reasons\\n    /**************************************************************************/\\n\\n    uint256 constant internal APP_RULE_REGISTRATION_ONLY_IN_CONSTRUCTOR = 1;\\n    uint256 constant internal APP_RULE_NO_REGISTRATION_FOR_EOA = 2;\\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\\n}\\n\\nlibrary ContextDefinitions {\\n\\n    /**************************************************************************\\n    / Call info\\n    /**************************************************************************/\\n\\n    // app level\\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\\n\\n    // call type\\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\\n\\n    function decodeCallInfo(uint256 callInfo)\\n        internal pure\\n        returns (uint8 appLevel, uint8 callType)\\n    {\\n        appLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n    function encodeCallInfo(uint8 appLevel, uint8 callType)\\n        internal pure\\n        returns (uint256 callInfo)\\n    {\\n        return uint256(appLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n}\\n\\nlibrary BatchOperation {\\n    /**\\n     * @dev ERC20.approve batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationApprove(\\n     *     abi.decode(data, (address spender, uint256 amount))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\\n    /**\\n     * @dev ERC20.transferFrom batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationTransferFrom(\\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\\n    /**\\n     * @dev SuperToken.upgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationUpgrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\\n    /**\\n     * @dev SuperToken.downgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDowngrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\\n    /**\\n     * @dev Superfluid.callAgreement batch operation type\\n     *\\n     * Call spec:\\n     * callAgreement(\\n     *     ISuperAgreement(target)),\\n     *     abi.decode(data, (bytes calldata, bytes userdata)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\\n    /**\\n     * @dev Superfluid.callAppAction batch operation type\\n     *\\n     * Call spec:\\n     * callAppAction(\\n     *     ISuperApp(target)),\\n     *     data\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\\n}\\n\\nlibrary SuperfluidGovernanceConfigs {\\n\\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.rewardAddress\\\");\\n\\n    bytes32 constant internal CFAv1_LIQUIDATION_PERIOD_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.liquidationPeriod\\\");\\n\\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.trustedForwarder\\\",\\n            forwarder));\\n    }\\n\\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\\\",\\n            deployer,\\n            registrationKey));\\n    }\\n\\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.factory\\\",\\n            factory));\\n    }\\n}\\n\\ninterface ISuperfluid {\\n\\n    /**************************************************************************\\n     * Governance\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get the current governace of the Superfluid host\\n     */\\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\\n\\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\\n    /**\\n     * @dev Replace the current governance with a new one\\n     */\\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\\n\\n    /**************************************************************************\\n     * Agreement Whitelisting\\n     *************************************************************************/\\n\\n    event AgreementClassRegistered(bytes32 agreementType, address code);\\n    /**\\n     * @dev Register a new agreement class to the system\\n     * @param agreementClassLogic INitial agreement class code\\n     *\\n     * Modifiers:\\n     *  - onlyGovernance\\n     */\\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\\n\\n    event AgreementClassUpdated(bytes32 agreementType, address code);\\n    /**\\n    * @dev Update code of an agreement class\\n    * @param agreementClassLogic New code for the agreement class\\n    *\\n    * Modifiers:\\n    *  - onlyGovernance\\n    */\\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\\n\\n    /**\\n    * @dev Get agreement class\\n    */\\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\\n\\n    /**\\n    * @dev Map list of the agreement classes using a bitmap\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function mapAgreementClasses(uint256 bitmap)\\n        external view\\n        returns (ISuperAgreement[] memory agreementClasses);\\n\\n    /**\\n    * @dev Create a new bitmask by adding a agreement class to it.\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**\\n    * @dev Create a new bitmask by removing a agreement class from it.\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**************************************************************************\\n    * Super Token Factory\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get the super token factory\\n     * @return factory The factory\\n     */\\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\\n\\n    /**\\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\\n     * @return logic The factory logic\\n     */\\n    function getSuperTokenFactoryLogic() external view returns (address logic);\\n\\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\\n    /**\\n     * @dev Update super token factory\\n     * @param newFactory New factory logic\\n     */\\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\\n\\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\\n    /**\\n     * @dev Update the super token logic to the latest\\n     *\\n     * NOTE:\\n     * - Refer toISuperTokenFactory.Upgradability for expected behaviours.\\n     */\\n    function updateSuperTokenLogic(ISuperToken token) external;\\n\\n    /**************************************************************************\\n     * App Registry\\n     *************************************************************************/\\n\\n    /**\\n     * @dev App registered event\\n     */\\n    event AppRegistered(ISuperApp indexed app);\\n\\n    /**\\n     * @dev Jail event for the app\\n     */\\n    event Jail(ISuperApp indexed app, uint256 reason);\\n\\n    /**\\n     * @dev Message sender declares it as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     *                   `SuperAppDefinitions`\\n     */\\n    function registerApp(uint256 configWord) external;\\n\\n    /**\\n     * @dev Message sender declares it as a super app, using a registration key\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     *                   `SuperAppDefinitions`\\n     * @param registrationKey The registration key issued by the governance\\n     */\\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\\n\\n    /**\\n     * @dev Message sender declares app as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     *                   `SuperAppDefinitions`\\n     * NOTE: only factory contracts authorized by governance can register super apps\\n     */\\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\\n\\n    /**\\n     * @dev Query if the app is registered\\n     * @param app Super app address\\n     */\\n    function isApp(ISuperApp app) external view returns(bool);\\n\\n    /**\\n     * @dev Query app level\\n     * @param app Super app address\\n     */\\n    function getAppLevel(ISuperApp app) external view returns(uint8 appLevel);\\n\\n    /**\\n     * @dev Get the manifest of the super app\\n     * @param app Super app address\\n     */\\n    function getAppManifest(\\n        ISuperApp app\\n    )\\n        external view\\n        returns (\\n            bool isSuperApp,\\n            bool isJailed,\\n            uint256 noopMask\\n        );\\n\\n    /**\\n     * @dev Query if the app has been jailed\\n     * @param app Super app address\\n     */\\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\\n\\n    /**\\n     * @dev White-list the target app for app composition for the source app (msg.sender)\\n     * @param targetApp The taget super app address\\n     */\\n    function allowCompositeApp(ISuperApp targetApp) external;\\n\\n    /**\\n     * @dev Query if source app  is allowed to call the target app as downstream app.\\n     * @param app Super app address\\n     * @param targetApp The taget super app address\\n     */\\n    function isCompositeAppAllowed(\\n        ISuperApp app,\\n        ISuperApp targetApp\\n    )\\n        external view\\n        returns (bool isAppAllowed);\\n\\n    /**************************************************************************\\n     * Agreement Framework\\n     *\\n     * Agreements use these function to trigger super app callbacks, updates\\n     * app allowance and charge gas fees.\\n     *\\n     * These functions can only be called by registered agreements.\\n     *************************************************************************/\\n\\n    function callAppBeforeCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // isAppActive(app)\\n        returns(bytes memory cbdata);\\n\\n    function callAppAfterCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // isAppActive(app)\\n        returns(bytes memory appCtx);\\n\\n    function appCallbackPush(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 appAllowanceGranted,\\n        int256 appAllowanceUsed,\\n        ISuperfluidToken appAllowanceToken\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory appCtx);\\n\\n    function appCallbackPop(\\n        bytes calldata ctx,\\n        int256 appAllowanceUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    function ctxUseAllowance(\\n        bytes calldata ctx,\\n        uint256 appAllowanceWantedMore,\\n        int256 appAllowanceUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    function jailApp(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 reason\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    /**************************************************************************\\n     * Contextless Call Proxies\\n     *\\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\\n     * with agreements or apps.\\n     *\\n     * NOTE: The contextual call data should be generated using\\n     * abi.encodeWithSelector. The context parameter should be set to \\\"0x\\\",\\n     * an empty bytes array as a placeholder to be replaced by the host\\n     * contract.\\n     *************************************************************************/\\n\\n     /**\\n      * @dev Call agreement function\\n      * @param callData The contextual call data with placeholder ctx\\n      * @param userData Extra user data being sent to the super app callbacks\\n      */\\n     function callAgreement(\\n         ISuperAgreement agreementClass,\\n         bytes calldata callData,\\n         bytes calldata userData\\n     )\\n        external\\n        //cleanCtx\\n        returns(bytes memory returnedData);\\n\\n    /**\\n     * @dev Call app action\\n     * @param callData The contextual call data.\\n     *\\n     * NOTE: See callAgreement about contextual call data.\\n     */\\n    function callAppAction(\\n        ISuperApp app,\\n        bytes calldata callData\\n    )\\n        external\\n        //cleanCtx\\n        //isAppActive(app)\\n        returns(bytes memory returnedData);\\n\\n    /**************************************************************************\\n     * Contextual Call Proxies and Context Utilities\\n     *\\n     * For apps, they must use context they receive to interact with\\n     * agreements or apps.\\n     *\\n     * The context changes must be saved and returned by the apps in their\\n     * callbacks always, any modification to the context will be detected and\\n     * the violating app will be jailed.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev ABIv2 Encoded memory data of context\\n     *\\n     * NOTE on backward compatibility:\\n     * - Non-dynamic fields are padded to 32bytes and packed\\n     * - Dynamic fields are referenced through a 32bytes offset to their \\\"parents\\\" field (or root)\\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\\n     *    - non-dynamic fields will be parsed at the same memory location,\\n     *    - and dynamic fields will simply have a greater offset than it was.\\n     */\\n    struct Context {\\n        //\\n        // Call context\\n        //\\n        // callback level\\n        uint8 appLevel;\\n        // type of call\\n        uint8 callType;\\n        // the system timestsamp\\n        uint256 timestamp;\\n        // The intended message sender for the call\\n        address msgSender;\\n\\n        //\\n        // Callback context\\n        //\\n        // For callbacks it is used to know which agreement function selector is called\\n        bytes4 agreementSelector;\\n        // User provided data for app callbacks\\n        bytes userData;\\n\\n        //\\n        // App context\\n        //\\n        // app allowance granted\\n        uint256 appAllowanceGranted;\\n        // app allowance wanted by the app callback\\n        uint256 appAllowanceWanted;\\n        // app allowance used, allowing negative values over a callback session\\n        int256 appAllowanceUsed;\\n        // app address\\n        address appAddress;\\n        // app allowance in super token\\n        ISuperfluidToken appAllowanceToken;\\n    }\\n\\n    function callAgreementWithContext(\\n        ISuperAgreement agreementClass,\\n        bytes calldata callData,\\n        bytes calldata userData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // validCtx(ctx)\\n        // onlyAgreement(agreementClass)\\n        returns (bytes memory newCtx, bytes memory returnedData);\\n\\n    function callAppActionWithContext(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // validCtx(ctx)\\n        // isAppActive(app)\\n        returns (bytes memory newCtx);\\n\\n    function decodeCtx(bytes calldata ctx)\\n        external pure\\n        returns (Context memory context);\\n\\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\\n\\n    /**************************************************************************\\n    * Batch call\\n    **************************************************************************/\\n    /**\\n     * @dev Batch operation data\\n     */\\n    struct Operation {\\n        // Operation. Defined in BatchOperation (Definitions.sol)\\n        uint32 operationType;\\n        // Operation target\\n        address target;\\n        // Data specific to the operation\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Batch call function\\n     * @param operations Array of batch operations.\\n     */\\n    function batchCall(Operation[] memory operations) external;\\n\\n    /**\\n     * @dev Batch call function for trusted forwarders (EIP-2771)\\n     * @param operations Array of batch operations.\\n     */\\n    function forwardBatchCall(Operation[] memory operations) external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * TODO: turning these off because solidity-coverage don't like it\\n     *************************************************************************/\\n\\n     /* /// @dev The current superfluid context is clean.\\n     modifier cleanCtx() virtual;\\n\\n     /// @dev The superfluid context is valid.\\n     modifier validCtx(bytes memory ctx) virtual;\\n\\n     /// @dev The agreement is a listed agreement.\\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\\n\\n     // onlyGovernance\\n\\n     /// @dev The msg.sender must be a listed agreement.\\n     modifier onlyAgreement() virtual;\\n\\n     /// @dev The app is registered and not jailed.\\n     modifier isAppActive(ISuperApp app) virtual; */\\n}\\n\\nabstract contract CustomSuperTokenBase {\\n    // This is the hard-coded number of storage slots used by the super token\\n    uint256[32] internal _storagePaddings;\\n}\\n\\ninterface INativeSuperTokenCustom {\\n    function initialize(string calldata name, string calldata symbol, uint256 initialSupply) external;\\n}\\n\\nlibrary UUPSUtils {\\n\\n    /**\\n     * @dev Implementation slot constant.\\n     * Using https://eips.ethereum.org/EIPS/eip-1967 standard\\n     * Storage slot 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\\n     * (obtained as bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)).\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @dev Get implementation address.\\n    function implementation() internal view returns (address impl) {\\n        assembly { // solium-disable-line\\n            impl := sload(_IMPLEMENTATION_SLOT)\\n        }\\n    }\\n\\n    /// @dev Set new implementation address.\\n    function setImplementation(address codeAddress) internal {\\n        assembly {\\n            // solium-disable-line\\n            sstore(\\n                _IMPLEMENTATION_SLOT,\\n                codeAddress\\n            )\\n        }\\n    }\\n\\n}\\n\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\\n\\ncontract UUPSProxy is Proxy {\\n\\n    /**\\n     * @dev Proxy initialization function.\\n     *      This should only be called once and it is permission-less.\\n     * @param initialAddress Initial logic contract code address to be used.\\n     */\\n    function initializeProxy(address initialAddress) external {\\n        require(initialAddress != address(0), \\\"UUPSProxy: zero address\\\");\\n        require(UUPSUtils.implementation() == address(0), \\\"UUPSProxy: already initialized\\\");\\n        UUPSUtils.setImplementation(initialAddress);\\n    }\\n\\n    /// @dev Proxy._implementation implementation\\n    function _implementation() internal virtual override view returns (address)\\n    {\\n        return UUPSUtils.implementation();\\n    }\\n\\n}\\n\\n// SPDX-License-Identifier: AGPLv3\\n/**\\n * @dev Native SuperToken custom super token implementation\\n *\\n * NOTE: this is a merged one-file from 1.0.0-rc7 contracts/tokens/NativeSuperToken.sol\\n *\\n */\\ncontract NativeSuperTokenProxy is INativeSuperTokenCustom, CustomSuperTokenBase, UUPSProxy {\\n    function initialize(string calldata /*name*/, string calldata /*symbol*/, uint256 /*initialSupply*/) external pure override {\\n        revert(\\\"Can't call initialize directly\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC777/IERC777.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/ArchimedesMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport { Archimedes, IPiToken, IWNative } from \\\"../Archimedes.sol\\\";\\n\\ncontract ArchimedesMock is Archimedes {\\n    uint private mockedBlockNumber;\\n\\n    constructor(\\n        IPiToken _piToken,\\n        uint _startBlock,\\n        IWNative _wNative\\n    ) Archimedes(_piToken, _startBlock, _wNative) { }\\n\\n    function setBlockNumber(uint _n) public {\\n        mockedBlockNumber = _n;\\n    }\\n\\n    function _blockNumber() internal view override returns (uint) {\\n        return mockedBlockNumber == 0 ? block.number : mockedBlockNumber;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UniZap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\n/*\\n    Zap contracts based on PancakeBunny ZapSushi\\n    Many thanks for the team =)\\n    https://github.com/PancakeBunny-finance/PolygonBUNNY/blob/main/contracts/zap/ZapSushi.sol\\n */\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"./PiAdmin.sol\\\";\\n\\nimport \\\"../interfaces/IUniswapPair.sol\\\";\\nimport \\\"../interfaces/IUniswapRouter.sol\\\";\\nimport \\\"../interfaces/IWNative.sol\\\";\\n\\ncontract UniZap is PiAdmin, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    address public constant WNative = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\\n    address public constant WETH = address(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\\n\\n    IUniswapRouter public exchange = IUniswapRouter(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506);\\n\\n    mapping(address => address) public routePairAddresses;\\n\\n    receive() external payable {}\\n\\n    event NewExchange(address oldExchange, address newExchange);\\n\\n    function zapInToken(address _from, uint amount, address _to) external nonReentrant {\\n        IERC20(_from).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        _zapInToken(_from, amount, _to);\\n    }\\n\\n    function zapIn(address _to) external payable nonReentrant {\\n        IWNative(WNative).deposit{value: msg.value}();\\n\\n        _zapInToken(WNative, msg.value, _to);\\n    }\\n\\n    // zapOut only should work to split LPs\\n    function zapOut(address _from, uint amount) external nonReentrant {\\n        if (_isLP(_from)) {\\n            IERC20(_from).safeTransferFrom(msg.sender, address(this), amount);\\n\\n            IUniswapPair pair = IUniswapPair(_from);\\n            address token0 = pair.token0();\\n            address token1 = pair.token1();\\n\\n            _approveToken(_from, amount);\\n\\n            if (token0 == WNative || token1 == WNative) {\\n                exchange.removeLiquidityETH(\\n                    token0 != WNative ? token0 : token1,\\n                    amount,\\n                    0,\\n                    0,\\n                    msg.sender,\\n                    block.timestamp + 60\\n                );\\n            } else {\\n                exchange.removeLiquidity(token0, token1, amount, 0, 0, msg.sender, block.timestamp + 60);\\n            }\\n\\n            _removeAllowance(_from);\\n        }\\n    }\\n\\n    function estimateReceiveTokens(address _from, address _to, uint _amount) public view returns (uint) {\\n        address[] memory route = _getRoute(_from, _to);\\n\\n        uint[] memory amounts = exchange.getAmountsOut(_amount, route);\\n\\n        return amounts[amounts.length - 1];\\n    }\\n\\n    /* ========== Private Functions ========== */\\n    function _approveToken(address _token, uint _amount) internal {\\n        IERC20(_token).safeApprove(address(exchange), _amount);\\n    }\\n\\n    function _removeAllowance(address _token) internal {\\n        if (IERC20(_token).allowance(address(this), address(exchange)) > 0) {\\n            IERC20(_token).safeApprove(address(exchange), 0);\\n        }\\n    }\\n\\n    function _isLP(address _addr) internal view returns (bool) {\\n        try IUniswapPair(_addr).token1() returns (address) {\\n            return true;\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    function _zapInToken(address _from, uint amount, address _to) internal {\\n        if (_isLP(_to)) {\\n            IUniswapPair pair = IUniswapPair(_to);\\n            address token0 = pair.token0();\\n            address token1 = pair.token1();\\n            uint sellAmount = amount / 2;\\n\\n            uint amount0 = amount - sellAmount;\\n            uint amount1;\\n\\n            // If _from is one of the LP tokens we need to swap just 1\\n            if (_from == token0) {\\n                amount1 = _swap(_from, sellAmount, token1, address(this));\\n            } else if (_from == token1) {\\n                amount1 = amount0; // amount - sellAmount\\n                amount0 = _swap(_from, sellAmount, token0, address(this));\\n            } else {\\n                // If _from isn't one of LP tokens we swap half for each one\\n                amount1 = _swap(_from, amount0, token1, address(this));\\n                amount0 = _swap(_from, sellAmount, token0, address(this));\\n            }\\n            // Double check that lp has reserves\\n            pair.skim(address(this));\\n\\n            // Approve only needed amounts\\n            _approveToken(token0, amount0);\\n            _approveToken(token1, amount1);\\n            // Add liquidity to the LP\\n            exchange.addLiquidity(\\n                token0,\\n                token1,\\n                amount0,\\n                amount1,\\n                0,\\n                0,\\n                msg.sender,\\n                block.timestamp + 60\\n            );\\n\\n            _removeAllowance(token0);\\n            _removeAllowance(token1);\\n        } else {\\n            _swap(_from, amount, _to, msg.sender);\\n        }\\n    }\\n\\n    function _swap(address _from, uint amount, address _to, address receiver) private returns (uint) {\\n        address[] memory route = _getRoute(_from, _to);\\n\\n        _approveToken(_from, amount);\\n        uint[] memory amounts = exchange.swapExactTokensForTokens(amount, 0, route, receiver, block.timestamp);\\n        _removeAllowance(_from);\\n\\n        return amounts[amounts.length - 1];\\n    }\\n\\n    function _getRoute(address _from, address _to) internal view returns (address[] memory route) {\\n        if (\\n            routePairAddresses[_from] != address(0) &&\\n            routePairAddresses[_to] != address(0) &&\\n            routePairAddresses[_from] != routePairAddresses[_to]\\n        ) {\\n            if (routePairAddresses[_from] == WETH || routePairAddresses[_to] == WETH) {\\n                route = new address[](4);\\n                route[0] = _from;\\n                route[1] = routePairAddresses[_from];\\n                route[2] = routePairAddresses[_to];\\n                route[3] = _to;\\n            } else {\\n                route = new address[](5);\\n                route[0] = _from;\\n                route[1] = routePairAddresses[_from];\\n                route[2] = WETH;\\n                route[3] = routePairAddresses[_to];\\n                route[4] = _to;\\n            }\\n        } else if (routePairAddresses[_from] != address(0) && routePairAddresses[_from] != WETH) {\\n            route = new address[](4);\\n            route[0] = _from;\\n            route[1] = routePairAddresses[_from];\\n            route[2] = WETH;\\n            route[3] = _to;\\n        } else if (routePairAddresses[_to] != address(0) && routePairAddresses[_to] != WETH) {\\n            route = new address[](4);\\n            route[0] = _from;\\n            route[2] = WETH;\\n            route[1] = routePairAddresses[_to];\\n            route[3] = _to;\\n        } else if (_from == WETH || _to == WETH) {\\n            route = new address[](2);\\n            route[0] = _from;\\n            route[1] = _to;\\n        } else {\\n            route = new address[](3);\\n            route[0] = _from;\\n            route[1] = WETH;\\n            route[2] = _to;\\n        }\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n    function setExchange(address _newExchange) external onlyAdmin {\\n        require(_newExchange != address(0), \\\"!ZeroAddress\\\");\\n        emit NewExchange(address(exchange), _newExchange);\\n        exchange = IUniswapRouter(_newExchange);\\n\\n    }\\n\\n    function setRoutePairAddress(address asset, address route) external onlyAdmin {\\n        routePairAddresses[asset] = route;\\n    }\\n\\n    // Sweep airdroips / remains\\n    function sweep(address _token) external onlyAdmin {\\n        if (_token == address(0)) {\\n            Address.sendValue(payable(msg.sender), address(this).balance);\\n        } else {\\n            uint amount = IERC20(_token).balanceOf(address(this));\\n            IERC20(_token).safeTransfer(msg.sender, amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IUniswapPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IUniswapPair {\\n    function approve(address, uint) external returns (bool);\\n    function balanceOf(address) external view returns (uint);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function skim(address to) external;\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function totalSupply() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"interfaces/IUniswapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IUniswapRouter {\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB);\\n  function removeLiquidityETH(\\n      address token,\\n      uint liquidity,\\n      uint amountTokenMin,\\n      uint amountETHMin,\\n      address to,\\n      uint deadline\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/SwapperWithCompensation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"./Swappable.sol\\\";\\nimport \\\"../interfaces/IUniswapPair.sol\\\";\\nimport \\\"../interfaces/IUniswapRouter.sol\\\";\\n\\ncontract SwapperWithCompensation is Swappable, ReentrancyGuard {\\n    using SafeERC20 for IERC20Metadata;\\n\\n    address public immutable strategy;\\n    address public exchange = address(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);\\n\\n    IUniswapPair public immutable lp;\\n    IERC20Metadata public immutable token0;\\n    IERC20Metadata public immutable token1;\\n    IERC20Metadata public immutable want;\\n\\n    mapping(address => mapping(address => address[])) public routes;\\n\\n    uint public reserveSwapRatio = 50; // 0.5% (0.3% of swap fee + a little more to get the more LP as possible\\n    uint public offsetRatio = 80; // 0.8% (0.3% of swap fee + 0.5% of staking deposit fee\\n\\n    constructor(IERC20Metadata _want, IUniswapPair _lp, address _strategy) {\\n        // Check that want is at least an ERC20\\n        _want.symbol();\\n        require(_want.balanceOf(address(this)) == 0, \\\"Invalid ERC20\\\");\\n        require(_want.allowance(msg.sender, address(this)) == 0, \\\"Invalid ERC20\\\");\\n\\n        want = _want;\\n        lp = _lp;\\n        token0 = IERC20Metadata(lp.token0());\\n        token1 = IERC20Metadata(lp.token1());\\n\\n        strategy = _strategy;\\n    }\\n\\n    modifier onlyStrat() {\\n        require(msg.sender == strategy, \\\"!Strategy\\\");\\n        _;\\n    }\\n\\n    function setRoute(address _from, address[] calldata _route) external onlyAdmin {\\n        require(_from != address(0), \\\"!ZeroAddress\\\");\\n        require(_route[0] == _from, \\\"First route isn't from\\\");\\n        require(_route[_route.length - 1] != _from, \\\"Last route is same as from\\\");\\n        require(_route.length > 1, \\\"Route length < 2\\\");\\n\\n        routes[_from][_route[_route.length - 1]] = _route;\\n    }\\n\\n    function setReserveSwapRatio(uint newRatio) external onlyAdmin {\\n        require(newRatio != reserveSwapRatio, \\\"same ratio\\\");\\n        require(newRatio <= RATIO_PRECISION, \\\"greater than 100%\\\");\\n\\n        reserveSwapRatio = newRatio;\\n    }\\n\\n    function setOffsetRatio(uint newRatio) external onlyAdmin {\\n        require(newRatio != offsetRatio, \\\"same ratio\\\");\\n        require(newRatio <= RATIO_PRECISION, \\\"greater than 100%\\\");\\n\\n        offsetRatio = newRatio;\\n    }\\n\\n    function swapLpTokensForWant(uint _amount0, uint _amount1) external onlyStrat returns (uint _amount) {\\n        uint prevBal = wantBalance();\\n        if (token0 != want) {\\n            token0.safeTransferFrom(strategy, address(this), _amount0);\\n            _swap(address(token0), _amount0, address(want));\\n        }\\n        if (token1 != want) {\\n            token1.safeTransferFrom(strategy, address(this), _amount1);\\n            _swap(address(token1), _amount1, address(want));\\n        }\\n\\n        // This is because the wantBalance could be more to compensate swaps\\n        _amount = wantBalance() - prevBal;\\n        want.safeTransfer(strategy, _amount);\\n    }\\n\\n    function swapWantForLpTokens(uint _balance) external onlyStrat returns (uint _amount0, uint _amount1) {\\n        // Ensure the strategy has the _balance\\n        want.safeTransferFrom(msg.sender, address(this), _balance);\\n\\n        // Compensate swap\\n        uint _amount = _balance * (RATIO_PRECISION + offsetRatio) / RATIO_PRECISION;\\n\\n        if (_amount > wantBalance()) { _amount = wantBalance(); }\\n\\n        uint _sellAmount;\\n        (_amount0, _sellAmount) = _wantAmountToLpTokensAmount(_amount);\\n\\n        // If want is one of the LP tokens we need to swap just 1\\n        if (want == token0) {\\n            _amount1 = _swap(address(want), _sellAmount, address(token1));\\n        } else if (want == token1) {\\n            _amount1 = _amount0; // _amount - _sellAmount\\n            _amount0 = _swap(address(want), _sellAmount, address(token0));\\n        } else {\\n            // If want isn't one of LP tokens we swap half for each one\\n            _amount1 = _swap(address(want), _amount0, address(token1));\\n            _amount0 = _swap(address(want), _sellAmount, address(token0));\\n        }\\n\\n        token0.safeTransfer(msg.sender, _amount0);\\n        token1.safeTransfer(msg.sender, _amount1);\\n    }\\n\\n    function _swap(address _from, uint _amount, address _to) internal returns (uint) {\\n        address[] memory _route = _getRoute(_from, _to);\\n\\n        if (_amount > 0) {\\n            uint _expected = _expectedForSwap(_amount, _from, _to);\\n\\n            if (_expected > 1) {\\n                _approveToken(_from, _amount);\\n\\n                uint[] memory _amounts = IUniswapRouter(exchange).swapExactTokensForTokens(\\n                    _amount,\\n                    _expected,\\n                    _route,\\n                    address(this),\\n                    block.timestamp\\n                );\\n\\n                _removeAllowance(_from);\\n\\n                return _amounts[_amounts.length - 1];\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    function lpInWant(uint _lpAmount) public view returns (uint) {\\n        (uint112 _reserve0, uint112 _reserve1,) = lp.getReserves();\\n\\n        uint _lpTotalSupply = lp.totalSupply();\\n        uint _amount0 = _reserve0 * _lpAmount / _lpTotalSupply;\\n        uint _amount1 = _reserve1 * _lpAmount / _lpTotalSupply;\\n        uint _received0 = _getAmountsOut(token0, want, _amount0);\\n        uint _received1 = _getAmountsOut(token1, want, _amount1);\\n\\n        return _received0 + _received1;\\n    }\\n\\n    function lpToMinAmounts(uint _liquidity) public view returns (uint _amount0Min, uint _amount1Min) {\\n        uint _lpTotalSupply = lp.totalSupply();\\n        (uint112 _reserve0, uint112 _reserve1,) = lp.getReserves();\\n\\n        _amount0Min = _liquidity * _reserve0 / _lpTotalSupply;\\n        _amount1Min = _liquidity * _reserve1 / _lpTotalSupply;\\n    }\\n\\n    function _getAmountsOut(IERC20Metadata _from, IERC20Metadata _to, uint _amount) internal view returns (uint) {\\n        if (_from == _to) {\\n            return _amount;\\n        } else {\\n            address[] memory _route = _getRoute(address(_from), address(_to));\\n            uint[] memory amounts = IUniswapRouter(exchange).getAmountsOut(_amount, _route);\\n\\n            return amounts[amounts.length - 1];\\n        }\\n    }\\n\\n    function _getRoute(address _from, address _to) internal view returns (address[] memory) {\\n        address[] memory _route = routes[_from][_to];\\n\\n        require(_route.length > 1, \\\"Invalid route!\\\");\\n\\n        return _route;\\n    }\\n\\n    function _approveToken(address _token, uint _amount) internal {\\n        IERC20Metadata(_token).safeApprove(exchange, _amount);\\n    }\\n\\n    function _removeAllowance(address _token) internal {\\n        if (IERC20Metadata(_token).allowance(address(this), exchange) > 0) {\\n            IERC20Metadata(_token).safeApprove(exchange, 0);\\n        }\\n    }\\n\\n    function _max(uint _x, uint _y) internal pure returns (uint) {\\n        return _x > _y ? _x : _y;\\n    }\\n\\n    function wantBalance() public view returns (uint) {\\n        return want.balanceOf(address(this));\\n    }\\n\\n    function _reservePrecision() internal view returns (uint) {\\n        if (token0.decimals() >= token1.decimals()) {\\n            return (10 ** token0.decimals()) / (10 ** token1.decimals());\\n        } else {\\n            return (10 ** token1.decimals()) / (10 ** token0.decimals());\\n        }\\n    }\\n\\n    function wantToLP(uint _amount) public view returns (uint) {\\n        (uint112 _reserve0, uint112 _reserve1,) = lp.getReserves();\\n\\n        // convert amount from want => token0\\n        if (want != token0 && want != token1) {\\n            _amount = _getAmountsOut(want, token0, _amount);\\n        }\\n\\n        (uint _amount0, uint _amount1) = _wantAmountToLpTokensAmount(_amount);\\n\\n        uint _lpTotalSupply = lp.totalSupply();\\n\\n        // They should be equal, but just in case we strive for maximum liquidity =)\\n        return _max(_amount0 * _lpTotalSupply / _reserve0, _amount1 * _lpTotalSupply / _reserve1);\\n    }\\n\\n    function _wantAmountToLpTokensAmount(uint _amount) internal view returns (uint _amount0, uint _amount1) {\\n        (uint112 _reserve0, uint112 _reserve1,) = lp.getReserves();\\n\\n        // Reserves in token0 precision\\n        uint totalReserves = _reserve0;\\n        totalReserves += _reserve1 / _reservePrecision();\\n\\n        // Get the reserve ratio plus the 0.5% of the swap\\n        _amount0 = _amount * _reserve0 *\\n            (RATIO_PRECISION + reserveSwapRatio) /\\n            totalReserves / RATIO_PRECISION;\\n\\n        _amount1 = _amount - _amount0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Swappable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"./PiAdmin.sol\\\";\\nimport \\\"../interfaces/IChainLink.sol\\\";\\nimport \\\"../interfaces/IUniswapRouter.sol\\\";\\n\\nabstract contract Swappable is PiAdmin {\\n    uint constant public SWAP_PRECISION = 1e18;\\n    uint constant public RATIO_PRECISION = 10000; // 100%\\n    uint public swapSlippageRatio = 100; // 1%\\n\\n    mapping(address => IChainLink) public oracles;\\n\\n    uint public maxPriceOffset = 600; // 10 minutes\\n\\n    function setSwapSlippageRatio(uint _ratio) external onlyAdmin {\\n        require(_ratio != swapSlippageRatio, \\\"Same ratio\\\");\\n        require(_ratio <= RATIO_PRECISION, \\\"Can't be more than 100%\\\");\\n        swapSlippageRatio = _ratio;\\n    }\\n\\n    function setMaxPriceOffset(uint _offset) external onlyAdmin {\\n        require(_offset != maxPriceOffset, \\\"Same offset\\\");\\n        require(_offset <= 86400, \\\"Can't be more than 1 day\\\");\\n        maxPriceOffset = _offset;\\n    }\\n\\n    function setPriceFeed(address _token, IChainLink _feed) external onlyAdmin {\\n        require(_token != address(0), \\\"!ZeroAddress\\\");\\n        (uint80 round, int price,,,) = _feed.latestRoundData();\\n        require(round > 0 && price > 0, \\\"Invalid feed\\\");\\n\\n        oracles[_token] = _feed;\\n    }\\n\\n    function _expectedForSwap(uint _amount, address _fromToken, address _toToken) internal view returns (uint) {\\n        // ratio is a 18 decimals ratio number calculated to get the minimum\\n        // amount of want-tokens. So the balance is multiplied by the ratio\\n        // and then divided by 9 decimals to get the same \\\"precision\\\".\\n        // Then the result should be divided for the decimal diff between tokens.\\n        // Oracle Price Feed has always 8 decimals.\\n        // E.g want is USDT with only 6 decimals:\\n        // tokenDiffPrecision = 1e21 ((1e18 MATIC decimals / 1e6 USDT decimals) * 1e9 ratio precision)\\n        // ratio = 1_507_423_500 ((152265000 * 1e9) / 100000000) * 99 / 100 [with 1.52 USDT/MATIC]\\n        // _balance = 1e18 (1.0 MATIC)\\n        // expected = 1507423 (1e18 * 1_507_423_500 / 1e21) [1.507 in USDT decimals]\\n        // we should keep in mind the order of the token decimals\\n\\n        uint ratio = (\\n            (_getPriceFor(_fromToken) * SWAP_PRECISION) / _getPriceFor(_toToken)\\n        ) * (RATIO_PRECISION - swapSlippageRatio) / RATIO_PRECISION;\\n\\n        if (IERC20Metadata(_fromToken).decimals() >= IERC20Metadata(_toToken).decimals()) {\\n            uint tokenDiffPrecision = (10 ** IERC20Metadata(_fromToken).decimals()) / (10 ** IERC20Metadata(_toToken).decimals());\\n\\n            tokenDiffPrecision *= SWAP_PRECISION;\\n\\n            return (_amount * ratio / tokenDiffPrecision);\\n        } else {\\n            uint tokenDiffPrecision = (10 ** IERC20Metadata(_toToken).decimals()) / (10 ** IERC20Metadata(_fromToken).decimals());\\n\\n            return (_amount * ratio * tokenDiffPrecision / SWAP_PRECISION);\\n        }\\n    }\\n\\n    function _getPriceFor(address _token) internal view returns (uint) {\\n        // This could be implemented with FeedRegistry but it's not available in polygon\\n        (, int price,,uint timestamp,) = oracles[_token].latestRoundData();\\n\\n        require(timestamp >= (block.timestamp - maxPriceOffset), \\\"Old price\\\");\\n\\n        return uint(price);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"interfaces/IChainLink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IChainLink {\\n  function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n  function decimals() external view returns (uint8);\\n  function aggregator() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/ControllerQuickSwapMaiLPStrat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"./ControllerStratAbs.sol\\\";\\n\\nimport \\\"../interfaces/IMasterChef.sol\\\";\\nimport \\\"../interfaces/IUniswapPair.sol\\\";\\n\\ninterface Swapper {\\n   function lp() external view returns (address);\\n   function strategy() external view returns (address);\\n   function swapWantForLpTokens(uint) external returns (uint, uint);\\n   function swapLpTokensForWant(uint, uint) external returns (uint);\\n   function lpInWant(uint) external view returns (uint);\\n   function lpToMinAmounts(uint) external view returns (uint, uint);\\n   function wantToLP(uint) external view returns (uint);\\n}\\n\\ncontract ControllerQuickSwapMaiLPStrat is ControllerStratAbs {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IERC20Metadata;\\n\\n    address constant public MAI_FARM = address(0x574Fe4E8120C4Da1741b5Fd45584de7A5b521F0F); // MAI-USDC farm\\n    address constant public QUICKSWAP_LP = address(0x160532D2536175d65C03B97b0630A9802c274daD); // USDC-MAI\\n    address constant public TOKEN_0 = address(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174); // USDC\\n    address constant public TOKEN_1 = address(0xa3Fa99A148fA48D14Ed51d610c367C61876997F1); // MAI\\n\\n    uint public constant POOL_ID = 1;\\n    uint public minWantToRedeposit;\\n    uint public liquidityToleration = 200; // 2%\\n\\n    Swapper public swapper;\\n\\n    bool private depositMutex = false;\\n\\n    constructor(\\n        IERC20Metadata _want,\\n        address _controller,\\n        address _exchange,\\n        address _treasury,\\n        uint _minWantToRedeposit\\n    ) ControllerStratAbs(_want, _controller, _exchange, _treasury) {\\n        minWantToRedeposit = _minWantToRedeposit;\\n    }\\n\\n    function identifier() external view returns (string memory) {\\n        return string(abi.encodePacked(want.symbol(), \\\"@QuickSwapMaiLP#1.0.0\\\"));\\n    }\\n\\n    function setSwapper(Swapper _swapper) external onlyAdmin {\\n        require(address(_swapper) != address(0), \\\"!ZeroAddress\\\");\\n        require(_swapper != swapper, \\\"Same swapper\\\");\\n        require(_swapper.strategy() == address(this), \\\"Unknown strategy\\\");\\n        require(_swapper.lp() == QUICKSWAP_LP, \\\"Unknown LP\\\");\\n\\n        swapper = _swapper;\\n    }\\n\\n\\n    function harvest() public nonReentrant override {\\n        uint _before = wantBalance();\\n\\n        _claimRewards();\\n        _swapRewards();\\n\\n        uint _harvested = wantBalance() - _before;\\n\\n        // Charge performance fee for earned want + rewards\\n        _beforeMovement();\\n\\n        // re-deposit\\n        if (!paused() && wantBalance() > minWantToRedeposit) {\\n            _deposit();\\n        }\\n\\n        // Update lastBalance for the next movement\\n        _afterMovement();\\n\\n        emit Harvested(address(want), _harvested);\\n    }\\n\\n    function setMinWantToRedeposit(uint _minWantToRedeposit) external onlyAdmin {\\n        require(_minWantToRedeposit != minWantToRedeposit, \\\"Same minimum value\\\");\\n\\n        minWantToRedeposit = _minWantToRedeposit;\\n    }\\n\\n    function setLiquidityToleration(uint _liquidityToleration) external onlyAdmin {\\n        require(_liquidityToleration != liquidityToleration, \\\"Same toleration\\\");\\n        require(_liquidityToleration <= RATIO_PRECISION, \\\"Toleration too big!\\\");\\n\\n        liquidityToleration = _liquidityToleration;\\n    }\\n\\n    function balanceOfPool() public view override returns (uint) {\\n        (uint _amount,) = IMasterChef(MAI_FARM).userInfo(POOL_ID, address(this));\\n\\n        return _amount;\\n    }\\n\\n    function balanceOfPoolInWant() public view override returns (uint) {\\n        return _liquidityInWant(balanceOfPool());\\n    }\\n\\n    function _deposit() internal override {\\n        uint _balance = wantBalance();\\n\\n        if (_balance > 0) {\\n            want.safeApprove(address(swapper), _balance);\\n\\n            (uint _amount0, uint _amount1) = swapper.swapWantForLpTokens(_balance);\\n            // just in case\\n            _removeAllowance(address(want), address(swapper));\\n\\n            _addLiquidity(_amount0, _amount1);\\n        }\\n\\n        if (depositMutex) { depositMutex = false; }\\n    }\\n\\n    // amount is the want expected to be withdrawn\\n    function _withdraw(uint _amount) internal override returns (uint) {\\n        uint _balance = wantBalance();\\n\\n        if (_balance < _amount) {\\n            uint _liquidity = swapper.wantToLP(_amount);\\n\\n            _withdrawFromPool(_liquidity);\\n            _swapLPTokensForWant();\\n        }\\n\\n        uint _withdrawn = wantBalance() - _balance;\\n\\n        return (_withdrawn > _amount) ? _amount : _withdrawn;\\n    }\\n\\n    function _withdrawAll() internal override returns (uint) {\\n        uint _balance = wantBalance();\\n        uint _liquidity = balanceOfPool();\\n\\n        if (_liquidity > 0) {\\n            _withdrawFromPool(_liquidity);\\n            _swapLPTokensForWant();\\n        }\\n\\n        return wantBalance() - _balance;\\n    }\\n\\n    function _claimRewards() internal override {\\n        // Weird behavior, but this mean \\\"harvest\\\" or \\\"claim\\\".\\n        IMasterChef(MAI_FARM).deposit(POOL_ID, 0);\\n    }\\n\\n    function _addLiquidity(uint _amount0, uint _amount1) internal {\\n        // Approve only needed amounts\\n        _approveToken(TOKEN_0, exchange, _amount0);\\n        _approveToken(TOKEN_1, exchange, _amount1);\\n\\n        // Add liquidity to the LP\\n        (, , uint _liquidity) = IUniswapRouter(exchange).addLiquidity(\\n            TOKEN_0,\\n            TOKEN_1,\\n            _amount0,\\n            _amount1,\\n            _amount0 * (RATIO_PRECISION - liquidityToleration) / RATIO_PRECISION,\\n            _amount1 * (RATIO_PRECISION - liquidityToleration) / RATIO_PRECISION,\\n            address(this),\\n            block.timestamp + 60\\n        );\\n\\n        if (_liquidity > 0) {\\n            uint _lpLiquidity = IERC20(QUICKSWAP_LP).balanceOf(address(this));\\n\\n            _approveToken(QUICKSWAP_LP, MAI_FARM, _lpLiquidity);\\n\\n            // This has a 0.5% of deposit fee\\n            IMasterChef(MAI_FARM).deposit(POOL_ID, _lpLiquidity);\\n        }\\n\\n        _removeAllowance(TOKEN_0, exchange);\\n        _removeAllowance(TOKEN_1, exchange);\\n\\n        // Some recursion is needed when swaps required for LP are \\\"not well balanced\\\".\\n        if (wantBalance() > minWantToRedeposit && !depositMutex) {\\n            depositMutex = true;\\n\\n            _deposit();\\n        }\\n    }\\n\\n    function _swapLPTokensForWant() internal {\\n        uint _liquidity = IERC20(QUICKSWAP_LP).balanceOf(address(this));\\n        (uint _amount0Min, uint _amount1Min) = swapper.lpToMinAmounts(_liquidity);\\n\\n        _amount0Min = _amount0Min * (RATIO_PRECISION - liquidityToleration) / RATIO_PRECISION;\\n        _amount1Min = _amount1Min * (RATIO_PRECISION - liquidityToleration) / RATIO_PRECISION;\\n\\n        _approveToken(QUICKSWAP_LP, exchange, _liquidity);\\n\\n        (uint _amount0, uint _amount1) = IUniswapRouter(exchange).removeLiquidity(\\n            TOKEN_0,\\n            TOKEN_1,\\n            _liquidity,\\n            _amount0Min,\\n            _amount1Min,\\n            address(this),\\n            block.timestamp + 60\\n        );\\n\\n        _approveToken(TOKEN_0, address(swapper), _amount0);\\n        _approveToken(TOKEN_1, address(swapper), _amount1);\\n\\n        swapper.swapLpTokensForWant(_amount0, _amount1);\\n\\n        _removeAllowance(TOKEN_0, address(swapper));\\n        _removeAllowance(TOKEN_1, address(swapper));\\n    }\\n\\n    function _withdrawFromPool(uint _liquidity) internal {\\n        IMasterChef(MAI_FARM).withdraw(POOL_ID, _liquidity);\\n    }\\n\\n    function _liquidityInWant(uint _liquidity) internal view returns (uint) {\\n        if (_liquidity <= 0) { return 0; }\\n\\n        return swapper.lpInWant(_liquidity);\\n    }\\n\\n    function _approveToken(address _token, address _dst, uint _amount) internal {\\n        IERC20(_token).safeApprove(_dst, _amount);\\n    }\\n\\n    function _removeAllowance(address _token, address _dst) internal {\\n        if (IERC20(_token).allowance(address(this), _dst) > 0) {\\n            IERC20(_token).safeApprove(_dst, 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ControllerStratAbs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./Swappable.sol\\\";\\n\\nabstract contract ControllerStratAbs is Swappable, Pausable, ReentrancyGuard {\\n    using SafeERC20 for IERC20Metadata;\\n\\n    bytes32 public constant BOOSTER_ROLE = keccak256(\\\"BOOSTER_ROLE\\\");\\n\\n    // Want\\n    IERC20Metadata immutable public want;\\n    // want \\\"missing\\\" decimals precision\\n    uint internal immutable WANT_MISSING_PRECISION;\\n\\n    // Pool settings\\n    uint public ratioForFullWithdraw = 9000; // 90% [Min % to full withdraw\\n    uint public poolSlippageRatio = 20; // 0.2% [Slippage % to add/remove liquidity to/from the pool]\\n    // Min % to add/remove to an amount to conver BTC<=>BTCCRV\\n    // The virtualPrice will ALWAYS be greater than 1.0 (otherwise we're loosing BTC\\n    // so we only consider the decimal part)\\n    uint public poolMinVirtualPrice = 30; // 0.3%\\n    // Pool reward[s] route for Swap\\n    mapping(address => address[]) public rewardToWantRoute;\\n    // PoolRewards\\n    address[] public rewardTokens;\\n\\n    // Fees\\n    uint constant public MAX_PERFORMANCE_FEE = 5000; // 50% max\\n    uint public performanceFee = 500; // 5.0%\\n    uint internal lastBalance;\\n\\n    address public treasury;\\n    address public exchange;\\n    address public immutable controller; // immutable to prevent anyone to change it and withdraw\\n\\n    // Deposit compensation\\n    address public equalizer;\\n    uint public offsetRatio = 0; // 0.00%\\n\\n    // manual boosts\\n    uint public lastExternalBoost;\\n\\n    // Migrate to a library or something\\n    function _checkIERC20(IERC20Metadata token, string memory errorMsg) internal view {\\n        require(address(token) != address(0), errorMsg);\\n        token.symbol(); // Check that want is at least an ERC20\\n        require(token.balanceOf(address(this)) == 0, \\\"Invalid ERC20\\\"); // Check that want is at least an ERC20\\n        require(token.allowance(msg.sender, address(this)) == 0, \\\"Invalid ERC20\\\"); // Check that want is at least an ERC20\\n    }\\n\\n    constructor(IERC20Metadata _want, address _controller, address _exchange, address _treasury) {\\n        _checkIERC20(_want, \\\"Want !ZeroAddress\\\");\\n        require(_controller != address(0), \\\"Controller !ZeroAddress\\\");\\n        require(_exchange != address(0), \\\"Exchange !ZeroAddress\\\");\\n        require(_treasury != address(0), \\\"Treasury !ZeroAddress\\\");\\n\\n        want = _want;\\n        controller = _controller;\\n        exchange = _exchange;\\n        treasury = _treasury;\\n\\n        WANT_MISSING_PRECISION = (10 ** (18 - _want.decimals()));\\n\\n        equalizer = msg.sender;\\n    }\\n\\n    event NewTreasury(address oldTreasury, address newTreasury);\\n    event NewExchange(address oldExchange, address newExchange);\\n    event NewPerformanceFee(uint oldFee, uint newFee);\\n    event Harvested(address _want, uint _amount);\\n    event PerformanceFee(uint _amount);\\n    event Boosted(address indexed booster, uint amount);\\n\\n    modifier onlyController() {\\n        require(msg.sender == controller, \\\"Not from controller\\\");\\n        _;\\n    }\\n\\n    function setTreasury(address _treasury) external onlyAdmin nonReentrant {\\n        require(_treasury != treasury, \\\"Same address\\\");\\n        require(_treasury != address(0), \\\"!ZeroAddress\\\");\\n        emit NewTreasury(treasury, _treasury);\\n\\n        treasury = _treasury;\\n    }\\n\\n    function setExchange(address _exchange) external onlyAdmin nonReentrant {\\n        require(_exchange != exchange, \\\"Same address\\\");\\n        require(_exchange != address(0), \\\"!ZeroAddress\\\");\\n        emit NewExchange(exchange, _exchange);\\n\\n        exchange = _exchange;\\n    }\\n\\n    function setPerformanceFee(uint _fee) external onlyAdmin nonReentrant {\\n        require(_fee != performanceFee, \\\"Same fee\\\");\\n        require(_fee <= MAX_PERFORMANCE_FEE, \\\"Can't be greater than max\\\");\\n        emit NewPerformanceFee(performanceFee, _fee);\\n\\n        performanceFee = _fee;\\n    }\\n\\n    function setPoolMinVirtualPrice(uint _ratio) public onlyAdmin {\\n        require(_ratio != poolMinVirtualPrice, \\\"Same ratio\\\");\\n        require(_ratio <= RATIO_PRECISION, \\\"Can't be more than 100%\\\");\\n\\n        poolMinVirtualPrice = _ratio;\\n    }\\n\\n    function setPoolSlippageRatio(uint _ratio) public onlyAdmin {\\n        require(_ratio != poolSlippageRatio, \\\"Same ratio\\\");\\n        require(_ratio <= RATIO_PRECISION, \\\"Can't be more than 100%\\\");\\n\\n        poolSlippageRatio = _ratio;\\n    }\\n    function setRatioForFullWithdraw(uint _ratio) public onlyAdmin {\\n        require(_ratio != ratioForFullWithdraw, \\\"Same ratio\\\");\\n        require(_ratio <= RATIO_PRECISION, \\\"Can't be more than 100%\\\");\\n\\n        ratioForFullWithdraw = _ratio;\\n    }\\n\\n    function setRewardToWantRoute(address _reward, address[] calldata _route) external onlyAdmin {\\n        require(_reward != address(0), \\\"!ZeroAddress\\\");\\n        require(_route[0] == _reward, \\\"First route isn't reward\\\");\\n        require(_route[_route.length - 1] == address(want), \\\"Last route isn't want token\\\");\\n\\n        bool newReward = true;\\n        for (uint i = 0; i < rewardTokens.length; i++) {\\n            if (rewardTokens[i] == _reward) {\\n                newReward = false;\\n                break;\\n            }\\n        }\\n\\n        if (newReward) { rewardTokens.push(_reward); }\\n        rewardToWantRoute[_reward] = _route;\\n    }\\n\\n    // Compensation\\n    function setOffsetRatio(uint newRatio) external onlyAdmin {\\n        require(newRatio != offsetRatio, \\\"same ratio\\\");\\n        require(newRatio <= RATIO_PRECISION, \\\"greater than 100%\\\");\\n        require(newRatio >= 0, \\\"less than 0%?\\\");\\n\\n        offsetRatio = newRatio;\\n    }\\n\\n    function setEqualizer(address _equalizer) external onlyAdmin {\\n        require(_equalizer != address(0), \\\"!ZeroAddress\\\");\\n        require(_equalizer != equalizer, \\\"same address\\\");\\n\\n        equalizer = _equalizer;\\n    }\\n\\n    function beforeMovement() external onlyController nonReentrant {\\n        _beforeMovement();\\n    }\\n\\n    // Update new `lastBalance` for the next charge\\n    function _afterMovement() internal virtual {\\n        lastBalance = balance();\\n    }\\n\\n    function deposit() external whenNotPaused onlyController nonReentrant {\\n        _deposit();\\n        _afterMovement();\\n    }\\n\\n    function withdraw(uint _amount) external onlyController nonReentrant returns (uint) {\\n        uint _balance = wantBalance();\\n\\n        if (_balance < _amount) {\\n            uint poolBalance = balanceOfPoolInWant();\\n\\n            // If the requested amount is greater than xx% of the founds just withdraw everything\\n            if (_amount > (poolBalance * ratioForFullWithdraw / RATIO_PRECISION)) {\\n                _withdrawAll();\\n            } else {\\n                _withdraw(_amount);\\n            }\\n\\n            _balance = wantBalance();\\n\\n            if (_balance < _amount) { _amount = _balance; } // solhint-disable-unreachable-code\\n        }\\n\\n        want.safeTransfer(controller, _amount);\\n\\n        // Redeposit\\n        if (!paused()) { _deposit(); }\\n\\n        _afterMovement();\\n\\n        return _amount;\\n    }\\n\\n    function harvest() public nonReentrant virtual {\\n        uint _before = wantBalance();\\n\\n        _claimRewards();\\n        _swapRewards();\\n\\n        uint harvested = wantBalance() - _before;\\n\\n        // Charge performance fee for earned want + rewards\\n        _beforeMovement();\\n\\n        // re-deposit\\n        if (!paused()) { _deposit(); }\\n\\n        // Update lastBalance for the next movement\\n        _afterMovement();\\n\\n        emit Harvested(address(want), harvested);\\n    }\\n\\n    // This function is called to \\\"boost\\\" the strategy.\\n    function boost(uint _amount) external {\\n        require(hasRole(BOOSTER_ROLE, msg.sender), \\\"Not a booster\\\");\\n\\n        // Charge performance fee for earned want\\n        _beforeMovement();\\n\\n        // transfer reward from caller\\n        if (_amount > 0) { want.safeTransferFrom(msg.sender, address(this), _amount); }\\n\\n        // Keep track of how much is added to calc boost APY\\n        lastExternalBoost = _amount;\\n\\n        // Deposit transfered amount\\n        _deposit();\\n\\n        // update last_balance to exclude the manual reward from perfFee\\n        _afterMovement();\\n\\n        emit Boosted(msg.sender, _amount);\\n    }\\n\\n    function _beforeMovement() internal virtual{\\n        uint currentBalance = balance();\\n\\n        if (currentBalance > lastBalance) {\\n            uint perfFee = ((currentBalance - lastBalance) * performanceFee) / RATIO_PRECISION;\\n\\n            if (perfFee > 0) {\\n                uint _balance = wantBalance();\\n\\n                if (_balance < perfFee) {\\n                    uint _diff = perfFee - _balance;\\n\\n                    _withdraw(_diff);\\n                }\\n\\n                // Just in case\\n                _balance = wantBalance();\\n                if (_balance < perfFee) { perfFee = _balance; }\\n\\n                if (perfFee > 0) {\\n                    want.safeTransfer(treasury, perfFee);\\n                    emit PerformanceFee(perfFee);\\n                }\\n            }\\n        }\\n    }\\n\\n    function _deposit() internal virtual {\\n        // should be implemented\\n    }\\n\\n    function _withdraw(uint) internal virtual returns (uint) {\\n        // should be implemented\\n    }\\n\\n    function _withdrawAll() internal virtual returns (uint) {\\n        // should be implemented\\n    }\\n\\n    function _claimRewards() internal virtual {\\n        // should be implemented\\n    }\\n\\n    function _swapRewards() internal virtual {\\n        // should be implemented\\n        for (uint i = 0; i < rewardTokens.length; i++) {\\n            address rewardToken = rewardTokens[i];\\n            uint _balance = IERC20Metadata(rewardToken).balanceOf(address(this));\\n\\n            if (_balance > 0) {\\n                uint expected = _expectedForSwap(_balance, rewardToken, address(want));\\n\\n                // Want price sometimes is too high so it requires a lot of rewards to swap\\n                if (expected > 1) {\\n                    IERC20Metadata(rewardToken).safeApprove(exchange, _balance);\\n\\n                    IUniswapRouter(exchange).swapExactTokensForTokens(\\n                        _balance, expected, rewardToWantRoute[rewardToken], address(this), block.timestamp + 60\\n                    );\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes out performance fee.\\n     */\\n    function _chargeFees(uint _harvested) internal {\\n        uint fee = (_harvested * performanceFee) / RATIO_PRECISION;\\n\\n        // Pay to treasury a percentage of the total reward claimed\\n        if (fee > 0) { want.safeTransfer(treasury, fee); }\\n    }\\n\\n    function _compensateDeposit(uint _amount) internal returns (uint) {\\n        if (offsetRatio <= 0) { return _amount; }\\n\\n        uint _comp = _amount * offsetRatio / RATIO_PRECISION;\\n\\n        // Compensate only if we can...\\n        if (\\n            want.allowance(equalizer, address(this)) >= _comp &&\\n            want.balanceOf(equalizer) >= _comp\\n        ) {\\n            want.safeTransferFrom(equalizer, address(this), _comp);\\n            _amount += _comp;\\n        }\\n\\n        return _amount;\\n    }\\n\\n    function wantBalance() public view returns (uint) {\\n        return want.balanceOf(address(this));\\n    }\\n\\n    function balance() public view returns (uint) {\\n        return wantBalance() + balanceOfPoolInWant();\\n    }\\n\\n    function balanceOfPool() public view virtual returns (uint) {\\n        // should be implemented\\n    }\\n\\n    function balanceOfPoolInWant() public view virtual returns (uint) {\\n        // should be implemented\\n    }\\n\\n    // called as part of strat migration. Sends all the available funds back to the vault.\\n    function retireStrat() external onlyController {\\n        if (!paused()) { _pause(); }\\n\\n        // max withdraw can fail if not staked (in case of panic)\\n        if (balanceOfPool() > 0) { _withdrawAll(); }\\n\\n        // Can be called without rewards\\n        harvest();\\n\\n        require(balanceOfPool() <= 0, \\\"Strategy still has deposits\\\");\\n        want.safeTransfer(controller, wantBalance());\\n    }\\n\\n    // pauses deposits and withdraws all funds from third party systems.\\n    function panic() external onlyAdmin nonReentrant {\\n        _withdrawAll(); // max withdraw\\n        pause();\\n    }\\n\\n    function pause() public onlyAdmin {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyAdmin nonReentrant {\\n        _unpause();\\n\\n        _deposit();\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IMasterChef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IMasterChef {\\n    function deposit(uint256 _pid, uint256 _amount) external;\\n    function withdraw(uint256 _pid, uint256 _amount) external;\\n    function enterStaking(uint256 _amount) external;\\n    function leaveStaking(uint256 _amount) external;\\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\\n    function emergencyWithdraw(uint256 _pid) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ControllerMStableStrat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"./ControllerStratAbs.sol\\\";\\nimport \\\"../interfaces/IMStable.sol\\\";\\n\\ncontract ControllerMStableStrat is ControllerStratAbs {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IERC20Metadata;\\n\\n    address constant public MTOKEN = address(0xE840B73E5287865EEc17d250bFb1536704B43B21); // mUSD\\n    address constant public IMTOKEN = address(0x5290Ad3d83476CA6A2b178Cd9727eE1EF72432af); // imUSD\\n    address constant public VAULT = address(0x32aBa856Dc5fFd5A56Bcd182b13380e5C855aa29); // imUSD Vault\\n\\n    constructor(\\n        IERC20Metadata _want,\\n        address _controller,\\n        address _exchange,\\n        address _treasury\\n    ) ControllerStratAbs(_want, _controller, _exchange, _treasury) {}\\n\\n    function identifier() external view returns (string memory) {\\n        return string(abi.encodePacked(want.symbol(), \\\"@mStable#1.0.0\\\"));\\n    }\\n\\n    function harvest() public nonReentrant override {\\n        uint _before = wantBalance();\\n\\n        _claimRewards();\\n        _swapRewards();\\n\\n        uint harvested = wantBalance() - _before;\\n\\n        // Charge fees for the swapped rewards\\n        _chargeFees(harvested);\\n\\n        // Charge performance fee for the deposits yield\\n        _beforeMovement();\\n\\n        // re-deposit\\n        if (!paused()) { _deposit(); }\\n\\n        // Update lastBalance for the next movement\\n        _afterMovement();\\n\\n        emit Harvested(address(want), harvested);\\n    }\\n\\n    function _deposit() internal override {\\n        uint wantBal = _compensateDeposit(wantBalance());\\n\\n        if (wantBal > 0) {\\n            uint expected = _wantToMusdDoubleCheck(wantBal);\\n\\n            want.safeApprove(MTOKEN, wantBal);\\n            IMToken(MTOKEN).mint(address(want), wantBal, expected, address(this));\\n        }\\n\\n        uint mBalance = IERC20(MTOKEN).balanceOf(address(this));\\n\\n        if (mBalance > 0) {\\n            uint expected = _musdAmountToImusd(mBalance) * (RATIO_PRECISION - poolSlippageRatio) / RATIO_PRECISION;\\n            IERC20(MTOKEN).safeApprove(IMTOKEN, mBalance);\\n            uint credits = IIMToken(IMTOKEN).depositSavings(mBalance);\\n\\n            require(credits >= expected, \\\"less credits than expected\\\");\\n\\n            IERC20(IMTOKEN).safeApprove(VAULT, credits);\\n            IMVault(VAULT).stake(credits);\\n        }\\n    }\\n\\n    function _claimRewards() internal override {\\n        IMVault(VAULT).claimReward();\\n    }\\n\\n    // amount is the `want` expected to be withdrawn\\n    function _withdraw(uint _amount) internal override returns (uint) {\\n        uint wantBal = wantBalance();\\n\\n        _withdrawFromPool(\\n            _wantToPoolToken(_amount)\\n        );\\n\\n        return wantBalance() - wantBal;\\n    }\\n\\n    function _withdrawAll() internal override returns (uint) {\\n        uint wantBal = wantBalance();\\n\\n        _withdrawFromPool(balanceOfPool());\\n\\n        return wantBalance() - wantBal;\\n    }\\n\\n    function _withdrawFromPool(uint poolTokenAmount) internal {\\n        // Remove staked from vault\\n        IMVault(VAULT).withdraw(poolTokenAmount);\\n\\n        uint _balance = IIMToken(IMTOKEN).balanceOf(address(this));\\n\\n        require(_balance > 0, \\\"redeem balance = 0\\\");\\n\\n        uint _amount = _imusdAmountToMusd(_balance);\\n        uint expected = _amount / WANT_MISSING_PRECISION * (RATIO_PRECISION - poolSlippageRatio) / RATIO_PRECISION;\\n\\n        IIMToken(IMTOKEN).redeemUnderlying(_amount);\\n        IMToken(MTOKEN).redeem(address(want), _amount, expected, address(this));\\n    }\\n\\n    function _wantToMusdDoubleCheck(uint _amount) internal view returns (uint minOut) {\\n        if (_amount <= 0) { return 0; }\\n\\n        minOut = IMToken(MTOKEN).getMintOutput(address(want), _amount);\\n\\n        // want <=> mUSD is almost 1:1\\n        uint expected = _amount * WANT_MISSING_PRECISION * (RATIO_PRECISION - poolSlippageRatio) / RATIO_PRECISION;\\n\\n        if (expected > minOut) { minOut = expected; }\\n    }\\n\\n    function balanceOfPool() public view override returns (uint) {\\n        return IMVault(VAULT).balanceOf(address(this));\\n    }\\n\\n    function balanceOfPoolInWant() public view override returns (uint) {\\n        return _musdAmountToWant(\\n            _imusdAmountToMusd(\\n                balanceOfPool()\\n            )\\n        );\\n    }\\n\\n    function _musdAmountToWant(uint _amount) internal view returns (uint) {\\n        if (_amount <= 0) { return 0; }\\n\\n        return IMToken(MTOKEN).getRedeemOutput(address(want), _amount);\\n    }\\n\\n    function _musdAmountToImusd(uint _amount) internal view returns (uint) {\\n        return _amount * (10 ** IIMToken(IMTOKEN).decimals()) / IIMToken(IMTOKEN).exchangeRate();\\n    }\\n\\n    function _imusdAmountToMusd(uint _amount) internal view returns (uint) {\\n        return _amount * IIMToken(IMTOKEN).exchangeRate() / (10 ** IIMToken(IMTOKEN).decimals());\\n    }\\n\\n    function _wantToPoolToken(uint _amount) internal view returns (uint) {\\n        return _musdAmountToImusd(\\n            _wantToMusdDoubleCheck(_amount)\\n        );\\n    }\\n\\n    // We use balanceOfPoolInMUsd instead of balance to prevent\\n    // `lastBalance` be less than the last harvest with the same deposits.\\n    function _beforeMovement() internal override {\\n        uint _currentMUsdBalance = _balanceOfPoolInMUsd();\\n        uint _currentBalance = wantBalance();\\n\\n        if (_currentMUsdBalance > lastBalance) {\\n            uint perfFee = ((_currentMUsdBalance - lastBalance) * performanceFee) / RATIO_PRECISION;\\n\\n            if (perfFee > 0) {\\n                _withdrawFromPool(_musdAmountToImusd(perfFee));\\n\\n                uint feeInWant = wantBalance() - _currentBalance;\\n\\n                if (feeInWant > 0) {\\n                    want.safeTransfer(treasury, feeInWant);\\n                    emit PerformanceFee(feeInWant);\\n                }\\n            }\\n        }\\n    }\\n\\n    // Update new `lastBalance` for the next charge\\n    function _afterMovement() internal override {\\n        lastBalance = _balanceOfPoolInMUsd();\\n    }\\n\\n    function _balanceOfPoolInMUsd() internal view returns (uint){\\n        return _imusdAmountToMusd(balanceOfPool());\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IMStable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface IMToken is IERC20Metadata {\\n    function mint(address _input, uint256 _inputQuantity, uint256 _minOutputQuantity, address _recipient) external returns (uint256 mintOutput);\\n    function getMintOutput(address _input, uint256 _inputQuantity) external view  returns (uint256 mintOutput);\\n    function redeem(address _output, uint256 _mAssetQuantity, uint256 _minOutputQuantity, address _recipient) external returns (uint256 outputQuantity);\\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity) external view returns (uint256 bAssetOutput);\\n}\\n\\ninterface IIMToken is IERC20Metadata {\\n    function exchangeRate() external view returns (uint256);\\n    function depositSavings(uint256 _underlying) external returns (uint256 creditsIssued);\\n    function redeemUnderlying(uint256 _underlying) external returns (uint256 creditsBurned);\\n}\\n\\ninterface IMVault {\\n    function balanceOf(address) external view returns (uint256);\\n    function stake(uint256 _amount) external;\\n    function withdraw(uint256 _amount) external;\\n    function claimReward() external;\\n}\\n\"\r\n    },\r\n    \"contracts/FeeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n\\nimport \\\"./Swappable.sol\\\";\\nimport \\\"../interfaces/IPiVault.sol\\\";\\n\\n// Swappable contract has the AccessControl module\\ncontract FeeManager is Swappable, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    // Tokens used\\n    address public constant wNative = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270); // test\\n    address public constant piToken = address(0x44eB948756d6c7AA83Fb6aE5cFD548dCF5082109); // Test\\n\\n    address public immutable piVault;\\n    address public treasury;\\n    address public exchange;\\n\\n    // Fee constants\\n    uint public treasuryRatio = 150;\\n    uint public constant MAX_TREASURY_RATIO = 5000; // 50% for treasury & 50% for Stakers\\n\\n    mapping(address => address[]) public routes;\\n\\n    constructor(address _treasury, address _piVault, address _exchange) {\\n        require(_treasury != address(0), \\\"!ZeroAddress treasury\\\");\\n        require(_exchange != address(0), \\\"!ZeroAddress exchange\\\");\\n        require(IPiVault(_piVault).piToken() == piToken, \\\"Not PiToken vault\\\");\\n        treasury = _treasury;\\n        piVault = _piVault;\\n        exchange = _exchange;\\n    }\\n\\n    event NewTreasuryRatio(uint oldRatio, uint newRatio);\\n    event NewTreasury(address oldTreasury, address newTreasury);\\n    event NewExchange(address oldExchange, address newExchange);\\n    event Harvest(address _token, uint _tokenAmount, uint piTokenAmount);\\n\\n    function harvest(address _token) external nonReentrant {\\n        uint _balance = IERC20(_token).balanceOf(address(this));\\n\\n        if (_balance <= 0) { return; }\\n\\n        bool native = _token == wNative;\\n        address[] memory route;\\n\\n        if (routes[_token].length > 0) {\\n            route = routes[_token];\\n        } else {\\n            route = new address[](native ? 2 : 3);\\n            route[0] = _token;\\n\\n            if (native) {\\n                route[1] = piToken;\\n            } else {\\n                route[1] = wNative;\\n                route[2] = piToken;\\n            }\\n        }\\n\\n        uint expected = _expectedForSwap(_balance, _token, piToken);\\n        IERC20(_token).safeApprove(exchange, _balance);\\n        IUniswapRouter(exchange).swapExactTokensForTokens(\\n            _balance, expected, route, address(this), block.timestamp + 60\\n        );\\n\\n        uint piBalance = IERC20(piToken).balanceOf(address(this));\\n        uint treasuryPart = piBalance * treasuryRatio / RATIO_PRECISION;\\n\\n        IERC20(piToken).safeTransfer(treasury, treasuryPart);\\n        IERC20(piToken).safeTransfer(piVault, piBalance - treasuryPart);\\n\\n        emit Harvest(_token, _balance, piBalance);\\n    }\\n\\n    function setTreasuryRatio(uint _ratio) external onlyAdmin nonReentrant {\\n        require(_ratio != treasuryRatio, \\\"Same ratio\\\");\\n        require(_ratio <= MAX_TREASURY_RATIO, \\\"Can't be greater than 50%\\\");\\n        emit NewTreasuryRatio(treasuryRatio, _ratio);\\n        treasuryRatio = _ratio;\\n    }\\n\\n    function setTreasury(address _treasury) external onlyAdmin nonReentrant {\\n        require(_treasury != treasury, \\\"Same Address\\\");\\n        require(_treasury != address(0), \\\"!ZeroAddress\\\");\\n        emit NewTreasury(treasury, _treasury);\\n        treasury = _treasury;\\n    }\\n\\n    function setExchange(address _exchange) external onlyAdmin nonReentrant {\\n        require(_exchange != exchange, \\\"Same Address\\\");\\n        require(_exchange != address(0), \\\"!ZeroAddress\\\");\\n        emit NewExchange(exchange, _exchange);\\n\\n        exchange = _exchange;\\n    }\\n\\n    function setRoute(address _token, address[] calldata _route) external onlyAdmin {\\n        require(_token != address(0), \\\"!ZeroAddress\\\");\\n        require(_route.length > 2, \\\"Invalid route\\\");\\n\\n        for (uint i = 0; i < _route.length; i++) {\\n            require(_route[i] != address(0), \\\"Route with ZeroAddress\\\");\\n        }\\n\\n        routes[_token] = _route;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IPiVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IPiVault {\\n    function piToken() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/ControllerAaveStrat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\nimport \\\"./Swappable.sol\\\";\\nimport \\\"../interfaces/IAave.sol\\\";\\nimport \\\"../interfaces/IDataProvider.sol\\\";\\n\\n// Swappable contract has the AccessControl module\\ncontract ControllerAaveStrat is Pausable, ReentrancyGuard, Swappable {\\n    using SafeERC20 for IERC20;\\n\\n    address public constant wNative = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270); // test\\n\\n    address public immutable want;\\n    address public immutable aToken;\\n    address public immutable debtToken;\\n\\n    // Aave contracts (test addr)\\n    address public constant DATA_PROVIDER = address(0x7551b5D2763519d4e37e8B81929D336De671d46d);\\n    address public constant INCENTIVES = address(0x357D51124f59836DeD84c8a1730D72B749d8BC23);\\n    address public constant POOL = address(0x8dFf5E27EA6b7AC08EbFdf9eB090F32ee9a30fcf);\\n\\n    // Routes\\n    address[] public wNativeToWantRoute;\\n\\n    address public treasury;\\n\\n    // Profitability vars\\n    uint public borrowRate;\\n    uint public borrowRateMax;\\n    uint public borrowDepth;\\n    uint public minLeverage;\\n    uint constant public BORROW_DEPTH_MAX = 10;\\n    uint constant public INTEREST_RATE_MODE = 2; // variable\\n    uint constant public MIN_HEALTH_FACTOR = 1.05e18;  // Always at least 1.05 to not enter default like Arg\\n\\n    // In the case of leverage we should withdraw when the\\n    // amount to withdraw is 50%\\n    uint public ratioForFullWithdraw = 5000; // 50%\\n\\n    // The healthFactor value has the same representation than supply so\\n    // to do the math we should remove 12 places from healthFactor to get a HF\\n    // with only 6 \\\"decimals\\\" and add 6 \\\"decimals\\\" to supply to divide like we do IRL.\\n    uint public constant HF_DECIMAL_FACTOR = 1e6;\\n    uint public constant HF_WITHDRAW_TOLERANCE = 0.05e6;\\n\\n    // Fees\\n    uint constant public MAX_PERFORMANCE_FEE = 2000; // 20% max\\n    uint public performanceFee = 450; // 4.5%\\n    uint internal lastBalance;\\n\\n    address public exchange;\\n    address public immutable controller;\\n\\n    constructor(\\n        address _want,\\n        uint _borrowRate,\\n        uint _borrowRateMax,\\n        uint _borrowDepth,\\n        uint _minLeverage,\\n        address _controller,\\n        address _exchange,\\n        address _treasury\\n    ) {\\n        require(_want != address(0), \\\"want !ZeroAddress\\\");\\n        require(_controller != address(0), \\\"Controller !ZeroAddress\\\");\\n        require(_treasury != address(0), \\\"Treasury !ZeroAddress\\\");\\n        require(_borrowRate <= _borrowRateMax, \\\"!Borrow <= MaxBorrow\\\");\\n        require(_borrowRateMax <= RATIO_PRECISION, \\\"!MaxBorrow <= 100%\\\");\\n\\n        want = _want;\\n        borrowRate = _borrowRate;\\n        borrowRateMax = _borrowRateMax;\\n        borrowDepth = _borrowDepth;\\n        minLeverage = _minLeverage;\\n        controller = _controller;\\n        exchange = _exchange;\\n        treasury = _treasury;\\n\\n        (aToken,,debtToken) = IDataProvider(DATA_PROVIDER).getReserveTokensAddresses(_want);\\n\\n        wNativeToWantRoute = [wNative, _want];\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    }\\n\\n    event NewTreasury(address oldTreasury, address newTreasury);\\n    event NewExchange(address oldExchange, address newExchange);\\n    event NewPerformanceFee(uint oldFee, uint newFee);\\n    event Harvested(address _want, uint _amount);\\n    event PerformanceFee(uint _amount);\\n\\n    modifier onlyController() {\\n        require(msg.sender == controller, \\\"Not from controller\\\");\\n        _;\\n    }\\n\\n    function identifier() external view returns (string memory) {\\n        return string(abi.encodePacked(\\n            IERC20Metadata(want).symbol(), \\\"@AaveV2#1.0.0\\\"\\n        ));\\n    }\\n\\n    function setTreasury(address _treasury) external onlyAdmin nonReentrant {\\n        require(_treasury != treasury, \\\"Same address\\\");\\n        require(_treasury != address(0), \\\"!ZeroAddress\\\");\\n        emit NewTreasury(treasury, _treasury);\\n\\n        treasury = _treasury;\\n    }\\n\\n    function setExchange(address _exchange) external onlyAdmin nonReentrant {\\n        require(_exchange != exchange, \\\"Same address\\\");\\n        require(_exchange != address(0), \\\"!ZeroAddress\\\");\\n        emit NewExchange(exchange, _exchange);\\n\\n        exchange = _exchange;\\n    }\\n\\n    function setSwapRoute(address[] calldata _route) external onlyAdmin nonReentrant {\\n        require(_route[0] == wNative, \\\"route[0] isn't wNative\\\");\\n        require(_route[_route.length - 1] == want, \\\"Last route isn't want\\\");\\n        wNativeToWantRoute = _route;\\n    }\\n\\n    function setRatioForFullWithdraw(uint _ratio) public onlyAdmin {\\n        require(_ratio != ratioForFullWithdraw, \\\"Same ratio\\\");\\n        require(_ratio <= RATIO_PRECISION, \\\"Can't be more than 100%\\\");\\n        ratioForFullWithdraw = _ratio;\\n    }\\n\\n    function setPerformanceFee(uint _fee) external onlyAdmin nonReentrant {\\n        require(_fee != performanceFee, \\\"Same fee\\\");\\n        require(_fee <= MAX_PERFORMANCE_FEE, \\\"Can't be greater than max\\\");\\n        emit NewPerformanceFee(performanceFee, _fee);\\n\\n        performanceFee = _fee;\\n    }\\n\\n    // Charge want auto-generation with performanceFee\\n    // Basically we assign `lastBalance` each time that we charge or make a movement\\n    function beforeMovement() external onlyController nonReentrant {\\n        _beforeMovement();\\n    }\\n\\n    function _beforeMovement() internal {\\n        uint currentBalance = balance();\\n\\n        if (currentBalance > lastBalance) {\\n            uint perfFee = ((currentBalance - lastBalance) * performanceFee) / RATIO_PRECISION;\\n\\n            if (perfFee > 0) {\\n                uint _balance = wantBalance();\\n\\n                if (_balance < perfFee) {\\n                    uint _diff = perfFee - _balance;\\n\\n                    // Call partial because this fee should never be a big amount\\n                    _partialDeleverage(_diff);\\n                }\\n\\n                // Just in case\\n                _balance = wantBalance();\\n                if (_balance < perfFee) { perfFee = _balance; }\\n\\n                if (perfFee > 0) {\\n                    IERC20(want).safeTransfer(treasury, perfFee);\\n                    emit PerformanceFee(perfFee);\\n                }\\n            }\\n        }\\n    }\\n\\n    // Update new `lastBalance` for the next charge\\n    function _afterMovement() internal {\\n        lastBalance = balance();\\n    }\\n\\n    function deposit() external whenNotPaused onlyController nonReentrant {\\n        _leverage();\\n        _afterMovement();\\n    }\\n\\n    function withdraw(uint _amount) external onlyController nonReentrant returns (uint) {\\n        uint _balance = wantBalance();\\n\\n        if (_balance < _amount) {\\n            uint _diff = _amount - _balance;\\n\\n            // If the amount is at least the half of the real deposit\\n            // we have to do a full deleverage, in other case the withdraw+repay\\n            // will looping for ever.\\n            if ((balanceOfPool() * ratioForFullWithdraw / RATIO_PRECISION) <= _diff) {\\n                _fullDeleverage();\\n            } else {\\n                _partialDeleverage(_diff);\\n            }\\n\\n           _balance =  wantBalance();\\n           if (_balance < _amount) { _amount = _balance; }\\n        }\\n\\n        IERC20(want).safeTransfer(controller, _amount);\\n\\n        if (!paused() && wantBalance() > 0) { _leverage(); }\\n\\n        _afterMovement();\\n\\n        return _amount;\\n    }\\n\\n    function _leverage() internal {\\n        uint _amount = wantBalance();\\n\\n        IERC20(want).safeApprove(POOL, _amount);\\n        IAaveLendingPool(POOL).deposit(want, _amount, address(this), 0);\\n\\n        if (_amount < minLeverage) { return; }\\n\\n        // Borrow & deposit strategy\\n        for (uint i = 0; i < borrowDepth; i++) {\\n            _amount = (_amount * borrowRate) / RATIO_PRECISION;\\n\\n            IAaveLendingPool(POOL).borrow(want, _amount, INTEREST_RATE_MODE, 0, address(this));\\n            IERC20(want).safeApprove(POOL, _amount);\\n            IAaveLendingPool(POOL).deposit(want, _amount, address(this), 0);\\n\\n            if (_amount < minLeverage || _outOfGasForLoop()) { break; }\\n        }\\n    }\\n\\n    function _fullDeleverage() internal {\\n        (uint supplyBal, uint borrowBal) = supplyAndBorrow();\\n        uint toWithdraw;\\n        uint toRepay;\\n\\n        while (borrowBal > 0) {\\n            toWithdraw = _maxWithdrawFromSupply(supplyBal);\\n\\n            IAaveLendingPool(POOL).withdraw(want, toWithdraw, address(this));\\n\\n            // This is made mainly for the approve != 0\\n            toRepay = toWithdraw;\\n            if (toWithdraw > borrowBal) { toRepay = borrowBal; }\\n\\n            IERC20(want).safeApprove(POOL, toRepay);\\n            // Repay only will use the needed\\n            IAaveLendingPool(POOL).repay(want, toRepay, INTEREST_RATE_MODE, address(this));\\n\\n            (supplyBal, borrowBal) = supplyAndBorrow();\\n        }\\n\\n        if (supplyBal > 0) {\\n            IAaveLendingPool(POOL).withdraw(want, type(uint).max, address(this));\\n        }\\n    }\\n\\n    function _partialDeleverage(uint _needed) internal {\\n        // Instead of a require() to raise an exception, the fullDeleverage should\\n        // fix the health factor\\n        if (currentHealthFactor() <= MIN_HEALTH_FACTOR) {\\n            _fullDeleverage();\\n\\n            return;\\n        }\\n\\n        // This is because we check the wantBalance in each iteration\\n        // but for partialDeleverage we need to withdraw the entire\\n        // _needed amount\\n        uint toWithdraw = wantBalance() + _needed;\\n\\n        while (toWithdraw > wantBalance()) { _withdrawAndRepay(toWithdraw); }\\n    }\\n\\n    function _withdrawAndRepay(uint _needed) internal {\\n        (uint supplyBal, uint borrowBal) = supplyAndBorrow();\\n        // This amount with borrowDepth = 0 will return the entire deposit\\n        uint toWithdraw = _maxWithdrawFromSupply(supplyBal);\\n\\n        if (toWithdraw > _needed) { toWithdraw = _needed; }\\n\\n        IAaveLendingPool(POOL).withdraw(want, toWithdraw, address(this));\\n\\n        // for depth > 0\\n        if (borrowBal > 0) {\\n            // Only repay the just amount\\n            uint toRepay = (toWithdraw * borrowRate) / RATIO_PRECISION;\\n            if (toRepay > borrowBal) { toRepay = borrowBal; }\\n\\n            // In case the toWithdraw is really low it fails to repay 0\\n            if (toRepay > 0) {\\n                IERC20(want).safeApprove(POOL, toRepay);\\n                IAaveLendingPool(POOL).repay(want, toRepay, INTEREST_RATE_MODE, address(this));\\n            }\\n        }\\n    }\\n\\n    // This function is useful to increase Aave HF (to prevent liquidation) and\\n    // in case of \\\"stucked while loop for withdraws\\\" the strategy can be paused, and then\\n    // use this function the N needed times to get all the resources out of the Aave pool\\n    function increaseHealthFactor(uint byRatio) external onlyAdmin nonReentrant {\\n        require(byRatio <= RATIO_PRECISION, \\\"Can't be more than 100%\\\");\\n        (uint supplyBal, uint borrowBal) = supplyAndBorrow();\\n\\n        uint toWithdraw = (_maxWithdrawFromSupply(supplyBal) * byRatio) / RATIO_PRECISION;\\n\\n        IAaveLendingPool(POOL).withdraw(want, toWithdraw, address(this));\\n\\n        //  just in case\\n        if (borrowBal > 0) {\\n            uint toRepay = toWithdraw;\\n            if (toWithdraw > borrowBal) { toRepay = borrowBal; }\\n\\n            IERC20(want).safeApprove(POOL, toRepay);\\n            IAaveLendingPool(POOL).repay(want, toRepay, INTEREST_RATE_MODE, address(this));\\n        }\\n    }\\n\\n    function rebalance(uint _borrowRate, uint _borrowDepth) external onlyAdmin nonReentrant {\\n        require(_borrowRate <= borrowRateMax, \\\"Exceeds max borrow rate\\\");\\n        require(_borrowDepth <= BORROW_DEPTH_MAX, \\\"Exceeds max borrow depth\\\");\\n\\n        _fullDeleverage();\\n\\n        borrowRate = _borrowRate;\\n        borrowDepth = _borrowDepth;\\n\\n        if (!paused() && wantBalance() > 0) { _leverage(); }\\n    }\\n\\n    // Divide the supply with HF less 0.5 to finish at least with HF~=1.05\\n    function _maxWithdrawFromSupply(uint _supply) internal view returns (uint) {\\n        // The healthFactor value has the same representation than supply so\\n        // to do the math we should remove 12 places from healthFactor to get a HF\\n        // with only 6 \\\"decimals\\\" and add 6 \\\"decimals\\\" to supply to divide like we do IRL.\\n        uint hfDecimals = 1e18 / HF_DECIMAL_FACTOR;\\n\\n        return _supply - (\\n            (_supply * HF_DECIMAL_FACTOR) / ((currentHealthFactor() / hfDecimals) - HF_WITHDRAW_TOLERANCE)\\n        );\\n    }\\n\\n    function wantBalance() public view returns (uint) {\\n        return IERC20(want).balanceOf(address(this));\\n    }\\n\\n    function balance() public view returns (uint) {\\n        return wantBalance() + balanceOfPool();\\n    }\\n\\n    // it calculates how much 'want' the strategy has working in the controller.\\n    function balanceOfPool() public view returns (uint) {\\n        (uint supplyBal, uint borrowBal) = supplyAndBorrow();\\n        return supplyBal - borrowBal;\\n    }\\n\\n    function _claimRewards() internal {\\n        // Incentive controller only receive aToken addresses\\n        address[] memory assets = new address[](2);\\n        assets[0] = aToken;\\n        assets[1] = debtToken;\\n\\n        IAaveIncentivesController(INCENTIVES).claimRewards(\\n            assets, type(uint).max, address(this)\\n        );\\n    }\\n\\n    function harvest() public nonReentrant {\\n        uint _balance = balance();\\n        _claimRewards();\\n\\n        // only need swap when is different =)\\n        if (want != wNative) { _swapRewards(); }\\n\\n        uint harvested = balance() - _balance;\\n\\n        // Charge performance fee for earned want + rewards\\n        _beforeMovement();\\n\\n        // re-deposit\\n        if (!paused() && wantBalance() > 0) { _leverage(); }\\n\\n        // Update lastBalance for the next movement\\n        _afterMovement();\\n\\n        emit Harvested(want, harvested);\\n    }\\n\\n    function _swapRewards() internal {\\n        uint _balance = IERC20(wNative).balanceOf(address(this));\\n\\n        if (_balance > 0) {\\n            // _expectedForSwap checks with oracles to obtain the minExpected amount\\n            uint expected = _expectedForSwap(_balance, wNative, want);\\n\\n            IERC20(wNative).safeApprove(exchange, _balance);\\n            IUniswapRouter(exchange).swapExactTokensForTokens(\\n                _balance, expected, wNativeToWantRoute, address(this), block.timestamp + 60\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Takes out performance fee.\\n     */\\n    function _chargeFees(uint _harvested) internal {\\n        uint fee = (_harvested * performanceFee) / RATIO_PRECISION;\\n\\n        // Pay to treasury a percentage of the total reward claimed\\n        if (fee > 0) { IERC20(want).safeTransfer(treasury, fee); }\\n    }\\n\\n    function userReserves() public view returns (\\n        uint256 currentATokenBalance,\\n        uint256 currentStableDebt,\\n        uint256 currentVariableDebt,\\n        uint256 principalStableDebt,\\n        uint256 scaledVariableDebt,\\n        uint256 stableBorrowRate,\\n        uint256 liquidityRate,\\n        uint40 stableRateLastUpdated,\\n        bool usageAsCollateralEnabled\\n    ) {\\n        return IDataProvider(DATA_PROVIDER).getUserReserveData(want, address(this));\\n    }\\n\\n    function supplyAndBorrow() public view returns (uint, uint) {\\n        (uint supplyBal,,uint borrowBal,,,,,,) = userReserves();\\n        return (supplyBal, borrowBal);\\n    }\\n\\n    // returns the user account data across all the reserves\\n    function userAccountData() public view returns (\\n        uint totalCollateralETH,\\n        uint totalDebtETH,\\n        uint availableBorrowsETH,\\n        uint currentLiquidationThreshold,\\n        uint ltv,\\n        uint healthFactor\\n    ) {\\n        return IAaveLendingPool(POOL).getUserAccountData(address(this));\\n    }\\n\\n    function currentHealthFactor() public view returns (uint) {\\n        (,,,,, uint healthFactor) = userAccountData();\\n\\n        return healthFactor;\\n    }\\n\\n    // called as part of strat migration. Sends all the available funds back to the vault.\\n    function retireStrat() external onlyController {\\n        if (!paused()) { _pause(); }\\n\\n        if (balanceOfPool() > 0) { _fullDeleverage(); }\\n\\n        // Can be called without rewards\\n        harvest();\\n\\n        require(balanceOfPool() <= 0, \\\"Strategy still has deposits\\\");\\n        IERC20(want).safeTransfer(controller, wantBalance());\\n    }\\n\\n    // pauses deposits and withdraws all funds from third party systems.\\n    function panic() external onlyAdmin nonReentrant {\\n        _fullDeleverage();\\n        pause();\\n    }\\n\\n    function pause() public onlyAdmin {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyAdmin nonReentrant {\\n        _unpause();\\n\\n        if (wantBalance() > 0) { _leverage(); }\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IAaveIncentivesController {\\n  function claimRewards(\\n    address[] calldata assets,\\n    uint amount,\\n    address to\\n  ) external returns (uint);\\n}\\n\\ninterface IAaveLendingPool {\\n    event Deposit(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint amount,\\n        uint16 indexed referral\\n    );\\n\\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint amount);\\n\\n    function deposit(address asset, uint amount, address onBehalfOf, uint16 referralCode) external;\\n    function withdraw(address asset, uint amount, address to) external returns (uint);\\n    function borrow(address asset, uint amount, uint interestRateMode, uint16 referralCode, address onBehalfOf) external;\\n    function repay(address asset, uint amount, uint rateMode, address onBehalfOf) external returns (uint);\\n\\n    function getUserAccountData(address user) external view returns (\\n        uint totalCollateralETH,\\n        uint totalDebtETH,\\n        uint availableBorrowsETH,\\n        uint currentLiquidationThreshold,\\n        uint ltv,\\n        uint healthFactor\\n    );\\n}\\n\"\r\n    },\r\n    \"interfaces/IDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IDataProvider {\\n    function getReserveTokensAddresses(address asset) external view returns (\\n        address aTokenAddress,\\n        address stableDebtTokenAddress,\\n        address variableDebtTokenAddress\\n    );\\n\\n    function getUserReserveData(address asset, address user) external view returns (\\n        uint256 currentATokenBalance,\\n        uint256 currentStableDebt,\\n        uint256 currentVariableDebt,\\n        uint256 principalStableDebt,\\n        uint256 scaledVariableDebt,\\n        uint256 stableBorrowRate,\\n        uint256 liquidityRate,\\n        uint40 stableRateLastUpdated,\\n        bool usageAsCollateralEnabled\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/PiVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"./PiAdmin.sol\\\";\\n\\ncontract PiVault is ERC20, PiAdmin, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 public immutable piToken;\\n\\n    // Investor & Founders funds will be deposited but not released\\n    uint public immutable investorsLockTime;\\n    uint public immutable foundersLockTime;\\n\\n    // Wallets\\n    mapping(address => bool) public investors;\\n    mapping(address => bool) public founders;\\n\\n    // Individual max amount to release after the first year.\\n    uint public constant FOUNDERS_MAX_WITHDRAWS_AFTER_FIRST_YEAR = 1.57e24;\\n    mapping(address => uint) public foundersLeftToWithdraw;\\n\\n    /**\\n     * @dev Sets the address of 2pi token, the one that the vault will hold\\n     * as underlying value.\\n     * @param _token the 2pi token.\\n     */\\n    constructor(address _token, uint _investorsLock, uint _foundersLock) ERC20('stk2Pi', 'stk2Pi') {\\n        piToken = IERC20(_token);\\n\\n        investorsLockTime = _investorsLock;\\n        foundersLockTime = _foundersLock;\\n    }\\n\\n    event Deposit(address indexed user, uint amount);\\n    event Withdraw(address indexed user, uint amount);\\n\\n    /**\\n     * @dev Adds address to investors list\\n     */\\n    function addInvestor(address _wallet) external onlyAdmin {\\n        investors[_wallet] = true;\\n    }\\n\\n    /**\\n     * @dev Adds address to founders list\\n     */\\n    function addFounder(address _wallet) external onlyAdmin {\\n        founders[_wallet] = true;\\n        foundersLeftToWithdraw[_wallet] = FOUNDERS_MAX_WITHDRAWS_AFTER_FIRST_YEAR;\\n    }\\n\\n    /**\\n     * @dev It calculates the total underlying value of {piToken} held by the system.\\n     */\\n    function balance() public view returns (uint) {\\n        return piToken.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev A helper function to call deposit() with all the sender's funds.\\n     */\\n    function depositAll() external returns (uint) {\\n        return deposit(piToken.balanceOf(msg.sender));\\n    }\\n\\n    /**\\n     * @dev The entrypoint of funds into the system. People deposit with this function\\n     * into the vault.\\n     */\\n    function deposit(uint _amount) public nonReentrant returns (uint) {\\n        uint shares = 0;\\n        uint _pool = balance();\\n\\n        piToken.safeTransferFrom(msg.sender, address(this), _amount);\\n\\n        uint _after = balance();\\n        _amount = _after - _pool; // Additional check for deflationary piToken\\n\\n        if (totalSupply() <= 0) {\\n            shares = _amount;\\n        } else {\\n            shares = _amount * totalSupply() / _pool;\\n        }\\n\\n        _mint(msg.sender, shares);\\n        emit Deposit(msg.sender, _amount);\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev A helper function to call withdraw() with all the sender's funds.\\n     */\\n    function withdrawAll() external {\\n        withdraw(balanceOf(msg.sender));\\n    }\\n\\n    /**\\n     * @dev Function to exit the system. The vault will pay up the piToken holder.\\n     */\\n    function withdraw(uint _shares) public nonReentrant {\\n        require(_shares <= balanceOf(msg.sender), \\\"Amount not available\\\");\\n\\n        uint r = balance() * _shares / totalSupply();\\n\\n        _checkWithdraw(r);\\n\\n        _burn(msg.sender, _shares);\\n        piToken.safeTransfer(msg.sender, r);\\n\\n        emit Withdraw(msg.sender, _shares);\\n    }\\n\\n    function getPricePerFullShare() external view returns (uint) {\\n        uint _totalSupply = totalSupply();\\n\\n        return _totalSupply <= 0 ? 1e18 : ((balance() * 1e18) / _totalSupply);\\n    }\\n\\n    /**\\n     * @dev Check if msg.sender is an investor or a founder to release the funds.\\n     */\\n    function _checkWithdraw(uint _amount) internal {\\n        if (investors[msg.sender]) {\\n            require(block.timestamp >= investorsLockTime, \\\"Still locked\\\");\\n        } else if (founders[msg.sender]) {\\n            // Half of founders vesting will be release  at investorsLockTime\\n            require(block.timestamp >= investorsLockTime, \\\"Still locked\\\");\\n\\n            // This branch is for the 2\u00ba year (between investors release and founders release)\\n            if (block.timestamp <= foundersLockTime) {\\n                require(_amount <= foundersLeftToWithdraw[msg.sender], \\\"Max withdraw reached\\\");\\n                // Accumulate withdrawn for founder\\n                // (will revert if the amount is greater than the left to withdraw)\\n                foundersLeftToWithdraw[msg.sender] -= _amount;\\n            }\\n        }\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint /*amount*/) internal virtual override {\\n        // Ignore mint/burn\\n        if (from != address(0) && to != address(0)) {\\n            // Founders & Investors can't transfer shares before timelock\\n            if (investors[from]) {\\n                require(block.timestamp >= investorsLockTime, \\\"Still locked\\\");\\n            } else if (founders[from]) {\\n                require(block.timestamp >= foundersLockTime, \\\"Still locked\\\");\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/TestPiToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"./PiAdmin.sol\\\";\\n\\ncontract TestPiToken is PiAdmin, ERC20 {\\n    using SafeERC20 for IERC20;\\n\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n    // Rates to mint per block\\n    uint public communityMintPerBlock;\\n    uint public apiMintPerBlock;\\n\\n    // Keep track in which block started the current tranche\\n    uint internal tranchesBlock;\\n\\n    // Keep track of minted per type for current tranch\\n    uint internal apiMintedForCurrentTranch;\\n    uint internal communityMintedForCurrentTranch;\\n    // Keep track of un-minted per type for old tranches\\n    uint internal apiReserveFromOldTranches;\\n    uint internal communityReserveFromOldTranches;\\n\\n    uint internal API_TYPE = 0;\\n    uint internal COMMUNITY_TYPE = 1;\\n\\n\\n    constructor() ERC20('Test-P-2Pi', 'Test-P-2Pi') {\\n        // Shared max supply\\n        _mint(msg.sender, 3.14e25);\\n        _mint(address(this), 3.14e25);\\n    }\\n\\n    function initRewardsOn(uint _blockNumber) external onlyAdmin {\\n        require(tranchesBlock <= 0, \\\"Already set\\\");\\n        tranchesBlock = _blockNumber;\\n    }\\n\\n    // Before change api or community RatePerBlock or before mintForMultiChain is called\\n    // Calculate and accumulate the un-minted amounts.\\n    function _beforeChangeMintRate() internal {\\n        if (tranchesBlock > 0 && blockNumber() > tranchesBlock && (apiMintPerBlock > 0 || communityMintPerBlock > 0)) {\\n            // Accumulate both proportions to keep track of \\\"un-minted\\\" amounts\\n            apiReserveFromOldTranches += _leftToMintForCurrentBlock(API_TYPE);\\n            communityReserveFromOldTranches += _leftToMintForCurrentBlock(COMMUNITY_TYPE);\\n        }\\n    }\\n\\n    function setCommunityMintPerBlock(uint _rate) external onlyAdmin {\\n        _beforeChangeMintRate();\\n        communityMintPerBlock = _rate;\\n        _updateCurrentTranch();\\n    }\\n\\n    function setApiMintPerBlock(uint _rate) external onlyAdmin {\\n        _beforeChangeMintRate();\\n        apiMintPerBlock = _rate;\\n        _updateCurrentTranch();\\n    }\\n\\n    function _updateCurrentTranch() internal {\\n        // Update variables to making calculations from this moment\\n        if (tranchesBlock > 0 && blockNumber() > tranchesBlock) {\\n            tranchesBlock = blockNumber();\\n        }\\n\\n        // mintedForCurrentTranch = self().totalSupply();\\n        apiMintedForCurrentTranch = 0;\\n        communityMintedForCurrentTranch = 0;\\n    }\\n\\n\\n    function addMinter(address newMinter) external onlyAdmin {\\n        _setupRole(MINTER_ROLE, newMinter);\\n    }\\n\\n    function available() public view returns (uint) {\\n        return IERC20(address(this)).balanceOf(address(this));\\n    }\\n\\n    // This function checks for \\\"most of revert scenarios\\\" to prevent more minting than expected.\\n    // And keep track of minted / un-minted amounts\\n    function _checkMintFor(address _receiver, uint _supply, uint _type) internal {\\n        require(hasRole(MINTER_ROLE, msg.sender), \\\"Only minters\\\");\\n        require(_receiver != address(0), \\\"Can't mint to zero address\\\");\\n        require(_supply > 0, \\\"Insufficient supply\\\");\\n        require(tranchesBlock > 0, \\\"Rewards not initialized\\\");\\n        require(tranchesBlock < blockNumber(), \\\"Still waiting for rewards block\\\");\\n        require(available() >= _supply, \\\"Can't mint more than available\\\");\\n\\n        uint _ratePerBlock = communityMintPerBlock;\\n        if (_type == API_TYPE) { _ratePerBlock = apiMintPerBlock; }\\n\\n        require(_ratePerBlock > 0, \\\"Mint ratio is 0\\\");\\n\\n        // Get the max mintable supply for the current tranche\\n        uint _maxMintableSupply = _leftToMintForCurrentBlock(_type);\\n\\n        // Create other variable to add to the MintedForCurrentTranch\\n        uint _toMint = _supply;\\n\\n        // if the _supply (mint amount) is less than the expected \\\"everything is fine\\\" but\\n        // if its greater we have to check the \\\"ReserveFromOldTranches\\\"\\n        if (_toMint > _maxMintableSupply) {\\n            // fromReserve is the amount that will be \\\"minted\\\" from the old tranches reserve\\n            uint fromReserve = _toMint - _maxMintableSupply;\\n\\n            // Drop the \\\"reserve\\\" amount to track only the \\\"real\\\" tranch minted amount\\n            _toMint -= fromReserve;\\n\\n            // Check reserve for type\\n            if (_type == API_TYPE) {\\n                require(fromReserve <= apiReserveFromOldTranches, \\\"Can't mint more than expected\\\");\\n\\n                // drop the minted \\\"extra\\\" amount from old tranches reserve\\n                apiReserveFromOldTranches -= fromReserve;\\n            } else {\\n                require(fromReserve <= communityReserveFromOldTranches, \\\"Can't mint more than expected\\\");\\n\\n                // drop the minted \\\"extra\\\" amount from history reserve\\n                communityReserveFromOldTranches -= fromReserve;\\n            }\\n        }\\n\\n        if (_type == API_TYPE) {\\n            apiMintedForCurrentTranch += _toMint;\\n        } else {\\n            communityMintedForCurrentTranch += _toMint;\\n        }\\n    }\\n\\n    // This function is called mint for contract compatibility but it doesn't mint,\\n    // it only transfers piTokens\\n    function communityMint(address _receiver, uint _supply) external {\\n        _checkMintFor(_receiver, _supply, COMMUNITY_TYPE);\\n\\n        IERC20(address(this)).safeTransfer(_receiver, _supply);\\n    }\\n\\n    function apiMint(address _receiver, uint _supply) external {\\n        _checkMintFor(_receiver, _supply, API_TYPE);\\n\\n        IERC20(address(this)).safeTransfer(_receiver, _supply);\\n    }\\n\\n    function _leftToMintForCurrentBlock(uint _type) internal view returns (uint) {\\n        if (tranchesBlock <= 0 || tranchesBlock > blockNumber()) { return 0; }\\n\\n       uint left = blockNumber() - tranchesBlock;\\n\\n       if (_type == API_TYPE) {\\n           left *= apiMintPerBlock;\\n           left -= apiMintedForCurrentTranch;\\n       } else {\\n           left *= communityMintPerBlock;\\n           left -= communityMintedForCurrentTranch;\\n       }\\n\\n       return left;\\n    }\\n\\n    function _leftToMint(uint _type) internal view returns (uint) {\\n        uint totalLeft = available();\\n        if (totalLeft <= 0) { return 0; }\\n\\n        // Get the max mintable supply for the current tranche\\n        uint _maxMintableSupply = _leftToMintForCurrentBlock(_type);\\n\\n        // Add the _type accumulated un-minted supply\\n        _maxMintableSupply += (_type == API_TYPE ? apiReserveFromOldTranches : communityReserveFromOldTranches);\\n\\n        return (totalLeft <= _maxMintableSupply ? totalLeft : _maxMintableSupply);\\n    }\\n\\n    function communityLeftToMint() public view returns (uint) {\\n        return _leftToMint(COMMUNITY_TYPE);\\n    }\\n\\n    function apiLeftToMint() public view returns (uint) {\\n        return _leftToMint(API_TYPE);\\n    }\\n\\n\\n    // Implemented to be mocked in tests\\n    function blockNumber() internal view virtual returns (uint) {\\n        return block.number;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/PoolMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ninterface IDataProvider {\\n    function setATokenBalance(address _user, uint _ATokenBalance) external;\\n    function setDebtTokenBalance(address _user, uint _debtTokenBalance) external;\\n    function getUserReserveData(address _asset, address _user) external view returns (\\n        uint currentATokenBalance,\\n        uint currentStableDebt,\\n        uint currentVariableDebt,\\n        uint principalStableDebt,\\n        uint scaledVariableDebt,\\n        uint stableBorrowRate,\\n        uint liquidityRate,\\n        uint40 stableRateLastUpdated,\\n        bool usageAsCollateralEnabled\\n    );\\n}\\n\\ncontract PoolMock {\\n    address public constant dataProvider = address(0x7551b5D2763519d4e37e8B81929D336De671d46d);\\n\\n    uint public fakeHF;\\n\\n    function reset() public {\\n        fakeHF = 0;\\n    }\\n\\n    function setHealthFactor(uint _hf) public {\\n        fakeHF = _hf;\\n    }\\n\\n    function supplyAndBorrow() public view returns (uint, uint) {\\n        (uint _aTokens, ,uint _debt,,,,,,) = IDataProvider(dataProvider).getUserReserveData(msg.sender, msg.sender);\\n\\n        return (_aTokens, _debt);\\n    }\\n\\n    function deposit(address _asset, uint _amount, address /*_onBehalfOf*/, uint16 /*_referralCode*/) public {\\n        (uint aTokens,) = supplyAndBorrow();\\n\\n        IDataProvider(dataProvider).setATokenBalance(msg.sender, aTokens + _amount);\\n\\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    function withdraw(address _asset, uint _amount, address to) public returns (uint) {\\n        (uint aTokens,) = supplyAndBorrow();\\n        if (_amount > aTokens) {\\n            _amount = aTokens;\\n        }\\n\\n        if (_amount > 0) {\\n            IERC20(_asset).transferFrom(address(this), to, _amount);\\n        }\\n\\n        IDataProvider(dataProvider).setATokenBalance(msg.sender, aTokens - _amount);\\n\\n        return _amount;\\n    }\\n\\n    function borrow(\\n        address _asset,\\n        uint _amount,\\n        uint /*_interestRateMode*/,\\n        uint16 /*_referralCode*/,\\n        address /*_onBehalfOf*/\\n    ) public {\\n        (, uint _debt) = supplyAndBorrow();\\n\\n        IDataProvider(dataProvider).setDebtTokenBalance(msg.sender, _debt + _amount);\\n\\n        IERC20(_asset).transfer(msg.sender, _amount);\\n    }\\n\\n    function repay(address _asset, uint _amount, uint /*rateMode*/, address /*onBehalfOf*/) public returns (uint) {\\n        (, uint _debt) = supplyAndBorrow();\\n\\n        if (_debt <= _amount) {\\n            _amount = _debt; // to transfer only needed\\n            _debt = 0;\\n        } else {\\n            _debt -= _amount;\\n        }\\n\\n        IDataProvider(dataProvider).setDebtTokenBalance(msg.sender, _debt);\\n\\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\\n\\n        return _amount;\\n    }\\n\\n    function getUserAccountData(address /*user*/) public view returns (\\n        uint totalCollateralETH,\\n        uint totalDebtETH,\\n        uint availableBorrowsETH,\\n        uint currentLiquidationThreshold,\\n        uint ltv,\\n        uint healthFactor\\n    ) {\\n        (uint _aTokens, uint _debt) = supplyAndBorrow();\\n\\n        if (fakeHF > 0 ) {\\n            healthFactor = fakeHF;\\n        } else if (_debt > 0 && _aTokens > 0) {\\n            // aTokens * 80% / _debt == 2 digits factor\\n            healthFactor = ((_aTokens * 80) / (_debt)) * 1e16;\\n        } else {\\n            healthFactor = 200e18;\\n        }\\n\\n        return (0, 0, 0, 0, 0, healthFactor);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/UniswapRouterMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract UniswapRouterMock {\\n    // We always handle 1% of slippage so to get 1 expected token\\n    // 2 * 99 / 100 => 1\\n    uint private expected = 2;\\n\\n    function reset() public {\\n        expected = 2;\\n    }\\n\\n    function setExpected(uint _amount) public {\\n        expected = _amount;\\n    }\\n\\n    function getAmountsOut(uint amountIn, address[] memory /*path*/) external view returns (uint[] memory amounts) {\\n        amounts = new uint[](2);\\n        amounts[0] = amountIn; // First always the same\\n        amounts[1] = expected;\\n    }\\n\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint /*deadline*/\\n    ) external returns (uint[] memory amounts) {\\n        uint idx = path.length - 1;\\n\\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\\n        IERC20(path[idx]).transfer(to, amountOutMin);\\n\\n        uint[] memory a = new uint[](1);\\n        a[0] = amountOutMin;\\n\\n        return a;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/FarmMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface Strategy {\\n    function deposit(address _senderUser, uint _amount) external returns (uint);\\n}\\n\\ncontract FarmMock {\\n    address token;\\n    address strategy;\\n\\n    constructor (address _token) {\\n        token = _token;\\n    }\\n\\n    function setStrategy(address _strategy) public {\\n        strategy = _strategy;\\n    }\\n\\n    function piToken() external view returns (address) {\\n        return token;\\n    }\\n\\n    function deposit(address _senderUser, uint _amount) public returns (uint) {\\n        IERC20(token).approve(strategy, _amount);\\n\\n        return Strategy(strategy).deposit(_senderUser, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/CurveRewardsGaugeMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ncontract CurveRewardsGaugeMock {\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 crvToken;\\n    IERC20 WMATIC = IERC20(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\\n    IERC20 CRV = IERC20(0x40bde52e6B80Ae11F34C58c14E1E7fE1f9c834C4);\\n\\n    mapping(address => mapping(address => uint)) private claimable;\\n    mapping(address => uint) private counter;\\n    address[] private holders;\\n    address[] private claimers;\\n\\n    constructor(address _crvToken) {\\n        crvToken = IERC20(_crvToken);\\n    }\\n\\n    function setClaimable(address _token, address _wallet, uint _amount) external {\\n        claimable[_token][_wallet] += _amount;\\n        claimers.push(_wallet);\\n    }\\n\\n    function reset() public {\\n        WMATIC.transfer(address(1), WMATIC.balanceOf(address(this)));\\n        CRV.transfer(address(1), CRV.balanceOf(address(this)));\\n\\n        for (uint i; i < holders.length; i++) {\\n            counter[holders[i]] = 0;\\n        }\\n\\n        for (uint i; i < claimers.length; i++) {\\n            claimable[address(CRV)][claimers[i]] = 0;\\n            claimable[address(WMATIC)][claimers[i]] = 0;\\n        }\\n    }\\n\\n    function balanceOf(address account) public view returns (uint) {\\n        return counter[account];\\n    }\\n\\n    function claimable_tokens(address wallet) public view returns (uint) {\\n        return claimable[address(CRV)][wallet];\\n    }\\n\\n    function claimable_reward(address _wallet) external view returns (uint) {\\n        return claimable[address(CRV)][_wallet] + claimable[address(WMATIC)][_wallet];\\n    }\\n\\n    function claimable_reward(address _wallet, address _token) external view returns (uint) {\\n        return claimable[_token][_wallet];\\n    }\\n\\n    function reward_count() public pure returns (uint) {\\n        return 1;\\n    }\\n\\n    function reward_tokens(uint) public view returns (address) {\\n        return address(WMATIC);\\n    }\\n\\n    function claim_rewards() external {\\n        uint _claimable = claimable[address(WMATIC)][msg.sender];\\n\\n        if (WMATIC.balanceOf(address(this)) > 0 && _claimable > 0) {\\n            WMATIC.safeTransfer(msg.sender, _claimable);\\n            claimable[address(WMATIC)][msg.sender] = 0;\\n        }\\n    }\\n\\n    function claimed(address _wallet) external {\\n        claimable[address(CRV)][_wallet] = 0;\\n    }\\n\\n    function deposit(uint _value) external {\\n        crvToken.safeTransferFrom(msg.sender, address(this), _value);\\n        counter[msg.sender] += _value;\\n        holders.push(msg.sender);\\n    }\\n\\n    function withdraw(uint _value) external {\\n        crvToken.safeTransfer(msg.sender, _value);\\n\\n        counter[msg.sender] -= _value;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/CurvePoolMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ncontract CurvePoolMock is ERC20 {\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 public token;\\n    address private gauge;\\n    address[] private tokens;\\n\\n    constructor(\\n        address _token,\\n        address _gauge,\\n        address[] memory _coins,\\n        string memory _name\\n    ) ERC20(_name, _name) {\\n        token  = IERC20(_token);\\n        gauge  = _gauge;\\n        tokens = _coins;\\n    }\\n\\n    function underlying_coins(int128 i) external view returns (address) {\\n        return tokens[uint(int256(i))];\\n    }\\n\\n    function setGauge(address _gauge) public {\\n        gauge = _gauge;\\n    }\\n\\n    function reset() public {\\n        _burn(gauge, balanceOf(gauge));\\n        token.transfer(address(1), token.balanceOf(address(this)));\\n    }\\n\\n    function mint(uint _amount) public {\\n        _mint(msg.sender, _amount);\\n    }\\n\\n    function add_liquidity(uint[2] calldata amounts, uint min_mint_amount, bool /* _use_underlying */) external {\\n        token.safeTransferFrom(msg.sender, address(this), amounts[0]);\\n        _mint(msg.sender, min_mint_amount);\\n    }\\n\\n    function add_liquidity(uint[4] calldata amounts, uint min_mint_amount) external {\\n        token.safeTransferFrom(msg.sender, address(this), amounts[0]);\\n        _mint(msg.sender, min_mint_amount);\\n    }\\n\\n    function remove_liquidity_one_coin(uint _token_amount, int128 /* i */, uint _min_amount, bool /* _use_underlying */) external returns (uint) {\\n        _burn(msg.sender, _token_amount);\\n\\n        token.transfer(msg.sender, _min_amount);\\n        return _min_amount;\\n    }\\n\\n    function calc_withdraw_one_coin(uint _token_amount, int128 /* i */) external view returns (uint) {\\n        return _token_amount / 10 ** (18 - IERC20Metadata(address(token)).decimals());\\n    }\\n\\n    function calc_token_amount(uint[2] calldata _amounts, bool /* is_deposit */) external view returns (uint) {\\n        return _amounts[0] * 10 ** (18 - IERC20Metadata(address(token)).decimals());\\n    }\\n\\n    function calc_token_amount(uint[4] calldata _amounts, bool /* is_deposit */) external pure returns (uint) {\\n        return _amounts[0];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/TokenMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract TokenMock is ERC20 {\\n    uint8 private _decimals = 18;\\n\\n    constructor (string memory _name, string memory _symbol) ERC20(_name, _symbol) {\\n        _mint(msg.sender, 100 * 10 ** uint(decimals()));\\n    }\\n\\n    function setDecimals(uint8 newDecimals) external {\\n        _decimals = newDecimals;\\n    }\\n\\n    function decimals() override public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function mint(address to, uint amount) public {\\n        _mint(to, amount);\\n    }\\n\\n    function burn(uint amount) public {\\n        _burn(msg.sender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IDMMRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ninterface IDMMRouter {\\n    function addLiquidity(\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        address pool,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        uint256[2] memory vReserveRatioBounds,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    function addLiquidityETH(\\n        IERC20 token,\\n        address pool,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        uint256[2] memory vReserveRatioBounds,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function removeLiquidity(\\n        IERC20 tokenA,\\n        IERC20 tokenB,\\n        address pool,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        IERC20 token,\\n        address pool,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory poolsPath,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory poolsPath,\\n        IERC20[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function getAmountsOut(\\n        uint256 amountIn,\\n        address[] calldata poolsPath,\\n        IERC20[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/ControllerJarvisStrat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"./ControllerStratAbs.sol\\\";\\nimport \\\"../interfaces/ICurve.sol\\\";\\nimport \\\"../interfaces/IJarvisPool.sol\\\";\\nimport \\\"../interfaces/IUniswapRouter.sol\\\";\\nimport \\\"../interfaces/IDMMRouter.sol\\\";\\n\\ncontract ControllerJarvisStrat is ControllerStratAbs {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IERC20Metadata;\\n\\n\\n    address constant public AG_DENARIUS = address(0xbAbC2dE9cE26a5674F8da84381e2f06e1Ee017A1);\\n    address constant public AGEURCRV = address(0x81212149b983602474fcD0943E202f38b38d7484); // same than CurvePool\\n    address constant public CURVE_POOL = address(0x81212149b983602474fcD0943E202f38b38d7484); // agEUR+4eur-f\\n    address constant public REWARDS_STORAGE = address(0x7c22801057be8392a25D5Ad9490959BCF51F18f2); // AerariumSanctius contract\\n    address constant public JARVIS_POOL = address(0x1Dc366c5aC2f3Ac16af20212B46cDC0c92235A20); // ElysianFields contract\\n\\n    uint constant public JARVIS_POOL_ID = 0; // agDenarius agEUR+4eur-f pool\\n\\n    constructor(address _controller, address _exchange, address _kyberExchange, address _treasury)\\n        ControllerStratAbs(\\n            IERC20Metadata(0xE0B52e49357Fd4DAf2c15e02058DCE6BC0057db4), // agEUR\\n            _controller,\\n            _exchange,\\n            _treasury\\n        ) {\\n            require(_kyberExchange != address(0), \\\"Kyber exchange !ZeroAddress\\\");\\n\\n            kyberExchange = _kyberExchange;\\n        }\\n\\n    function identifier() external pure returns (string memory) {\\n        return string(\\\"agEUR@Jarvis#1.0.0\\\");\\n    }\\n\\n    function _deposit() internal override {\\n        // if pool is ended we shouldn't deposit\\n        if (IJarvisPool(JARVIS_POOL).endBlock() <= block.number) { return; }\\n\\n        uint wantBal = wantBalance();\\n\\n        if (wantBal > 0) {\\n            uint[2] memory amounts = [wantBal, 0];\\n            uint agEurCrvAmount = _agEurToAgEurCrvDoubleCheck(wantBal, true);\\n\\n            want.safeApprove(CURVE_POOL, wantBal);\\n            ICurvePool(CURVE_POOL).add_liquidity(amounts, agEurCrvAmount);\\n        }\\n\\n        uint _agEurCRVBalance = agEurCRVBalance();\\n\\n        if (_agEurCRVBalance > 0) {\\n            IERC20(AGEURCRV).safeApprove(JARVIS_POOL, _agEurCRVBalance);\\n            IJarvisPool(JARVIS_POOL).deposit(JARVIS_POOL_ID, _agEurCRVBalance);\\n        }\\n    }\\n\\n    function _withdraw(uint _amount) internal override returns (uint) {\\n        uint _balance = wantBalance();\\n\\n        if (_balance < _amount) {\\n            _withdrawFromPool(\\n                _agEurToAgEurCrvDoubleCheck(_amount - _balance, false)\\n            );\\n        }\\n\\n        uint withdrawn = wantBalance() - _balance;\\n\\n        return (withdrawn > _amount) ? _amount : withdrawn;\\n    }\\n\\n    function _withdrawAll() internal override returns (uint) {\\n        uint _balance = wantBalance();\\n\\n        _withdrawFromPool(balanceOfPool());\\n\\n        return wantBalance() - _balance;\\n    }\\n\\n    function _withdrawFromPool(uint agEurCrvAmount) internal {\\n        // Remove staked from pool\\n        IJarvisPool(JARVIS_POOL).withdraw(JARVIS_POOL_ID, agEurCrvAmount);\\n\\n        // remove_liquidity\\n        uint _balance = agEurCRVBalance();\\n        uint expected = _agEurCrvToAgEurDoubleCheck(_balance);\\n\\n        require(expected > 0, \\\"remove_liquidity expected = 0\\\");\\n\\n        ICurvePool(CURVE_POOL).remove_liquidity_one_coin(_balance, 0,  expected);\\n    }\\n\\n    function harvest() public nonReentrant override {\\n        uint _before = wantBalance();\\n\\n        _claimRewards();\\n        _swapRewardsOnKyber(); // should be called before common swap\\n        _swapRewards();\\n\\n        uint harvested = wantBalance() - _before;\\n\\n        // Charge performance fee for earned want + rewards\\n        _beforeMovement();\\n\\n        // re-deposit\\n        if (!paused() && wantBalance() > 0) { _deposit(); }\\n\\n        // Update lastBalance for the next movement\\n        _afterMovement();\\n\\n        emit Harvested(address(want), harvested);\\n    }\\n\\n    function _claimRewards() internal override {\\n        uint pending = IJarvisPool(JARVIS_POOL).pendingRwd(JARVIS_POOL_ID, address(this));\\n\\n        if (pending > 0) {\\n            IJarvisPool(JARVIS_POOL).deposit(JARVIS_POOL_ID, 0);\\n        }\\n\\n        // If the endBlock is reached we burn all the AG_DENARIUS tokens to get rewards\\n        if (IJarvisPool(JARVIS_POOL).endBlock() <= block.number) {\\n            uint bal = IERC20(AG_DENARIUS).balanceOf(address(this));\\n\\n            if (bal > 0) {\\n                IERC20(AG_DENARIUS).safeApprove(REWARDS_STORAGE, bal);\\n                IJarvisRewards(REWARDS_STORAGE).claim(bal);\\n            }\\n        }\\n    }\\n\\n    // Kyber doesn't solve all the tokens so we only use it when needed\\n    // like agDEN => USDC and then the USDC => want is swapped on\\n    // a regular exchange\\n    function _swapRewardsOnKyber() internal {\\n        for (uint i = 0; i < kyberRewards.length; i++) {\\n            address _rewardToken = kyberRewards[i];\\n\\n            // just in case\\n            if (kyberRewardRoute[_rewardToken][0] != address(0) && kyberRewardPathRoute[_rewardToken][0] != address(0)) {\\n                uint _balance = IERC20(_rewardToken).balanceOf(address(this));\\n\\n                if (_balance > 0) {\\n                    address _pseudoWant =                         kyberRewardRoute[_rewardToken][kyberRewardRoute[_rewardToken].length - 1];\\n                    uint expected = _expectedForSwap(\\n                        _balance, _rewardToken, _pseudoWant\\n                    );\\n\\n                    if (expected > 1) {\\n                        IERC20(_rewardToken).safeApprove(kyberExchange, _balance);\\n\\n                        IDMMRouter(kyberExchange).swapExactTokensForTokens(\\n                            _balance,\\n                            expected,\\n                            kyberRewardPathRoute[_rewardToken],\\n                            kyberRewardRoute[_rewardToken],\\n                            address(this),\\n                            block.timestamp + 60\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _swapRewards() internal override {\\n        for (uint i = 0; i < rewardTokens.length; i++) {\\n            address rewardToken = rewardTokens[i];\\n            uint _balance = IERC20(rewardToken).balanceOf(address(this));\\n\\n            if (_balance > 0) {\\n                address _pseudoWant = rewardToWantRoute[rewardToken][rewardToWantRoute[rewardToken].length - 1];\\n                uint expected = _expectedForSwap(_balance, rewardToken, _pseudoWant);\\n                // Want price sometimes is too high so it requires a lot of rewards to swap\\n                if (expected > 1) {\\n                    address _rewardExchange = exchange;\\n\\n                    if (rewardExchange[rewardToken] != address(0)) {\\n                        _rewardExchange = rewardExchange[rewardToken];\\n                    }\\n\\n                    IERC20(rewardToken).safeApprove(_rewardExchange, _balance);\\n                    IUniswapRouter(_rewardExchange).swapExactTokensForTokens(\\n                        _balance, expected, rewardToWantRoute[rewardToken], address(this), block.timestamp + 60\\n                    );\\n                }\\n            }\\n        }\\n    }\\n\\n    function _minAgEurToAgEurCrv(uint _amount) internal view returns (uint) {\\n        // Based on virtual_price (poolMinVirtualPrice) and poolSlippageRatio\\n        // the expected amount is represented with 18 decimals as crvAgEur token\\n        // so we have to add 10 decimals to the agEur balance.\\n        // E.g. 1e8 (1AGEUR) * 1e10 * 99.4 / 100.0 => 0.994e18 AGEURCRV tokens\\n        return _amount * WANT_MISSING_PRECISION * (RATIO_PRECISION - poolSlippageRatio - poolMinVirtualPrice) / RATIO_PRECISION;\\n    }\\n\\n    function _agEurToAgEurCrvDoubleCheck(uint _amount, bool _isDeposit) internal view returns (uint agEurCrvAmount) {\\n        uint[2] memory amounts = [_amount, 0];\\n        // calc_token_amount doesn't consider fee\\n        agEurCrvAmount = ICurvePool(CURVE_POOL).calc_token_amount(amounts, _isDeposit);\\n        // Remove max fee\\n        agEurCrvAmount = agEurCrvAmount * (RATIO_PRECISION - poolSlippageRatio) / RATIO_PRECISION;\\n\\n        // In case the pool is unbalanced (attack), make a double check for\\n        // the expected amount with minExpected set ratios.\\n        uint agEurToAgEurCrv = _minAgEurToAgEurCrv(_amount);\\n\\n        if (agEurToAgEurCrv > agEurCrvAmount) { agEurCrvAmount = agEurToAgEurCrv; }\\n    }\\n\\n    // Calculate at least xx% of the expected. The function doesn't\\n    // consider the fee.\\n    function _agEurCrvToAgEurDoubleCheck(uint _balance) internal view returns (uint expected) {\\n        expected = (\\n            _calc_withdraw_one_coin(_balance) * (RATIO_PRECISION - poolSlippageRatio)\\n        ) / RATIO_PRECISION;\\n\\n        // Double check for expected value\\n        // In this case we sum the poolMinVirtualPrice and divide by 1e10 because we want to swap AGEURCRV => agEUR\\n        uint minExpected = _balance *\\n            (RATIO_PRECISION + poolMinVirtualPrice - poolSlippageRatio) /\\n            RATIO_PRECISION /\\n            WANT_MISSING_PRECISION;\\n\\n        if (minExpected > expected) { expected = minExpected; }\\n    }\\n\\n    function _calc_withdraw_one_coin(uint _amount) internal view returns (uint) {\\n        if (_amount > 0) {\\n            return ICurvePool(CURVE_POOL).calc_withdraw_one_coin(_amount, 0);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function agEurCRVBalance() public view returns (uint) {\\n        return IERC20(AGEURCRV).balanceOf(address(this));\\n    }\\n\\n    function balanceOfPool() public view override returns (uint) {\\n        (uint256 _amount,) = IJarvisPool(JARVIS_POOL).userInfo(JARVIS_POOL_ID, address(this));\\n\\n        return _amount;\\n    }\\n\\n    function balanceOfPoolInWant() public view override returns (uint) {\\n        return _calc_withdraw_one_coin(balanceOfPool());\\n    }\\n\\n    // Kyber to be extract\\n    mapping(address => address[]) public kyberRewardPathRoute;\\n    mapping(address => address[]) public kyberRewardRoute;\\n    address public kyberExchange;\\n    address[] public kyberRewards;\\n\\n    mapping(address => address) public rewardExchange;\\n\\n\\n    // This one is a little \\\"hack\\\" to bypass the want validation\\n    // from `setRewardToWantRoute`\\n    function setRewardToTokenRoute(address _reward, address[] calldata _route) external onlyAdmin nonReentrant {\\n        require(_reward != address(0), \\\"!ZeroAddress\\\");\\n        require(_route[0] == _reward, \\\"First route isn't reward\\\");\\n\\n        bool newReward = true;\\n        for (uint i = 0; i < rewardTokens.length; i++) {\\n            if (rewardTokens[i] == _reward) {\\n                newReward = false;\\n                break;\\n            }\\n        }\\n\\n        if (newReward) { rewardTokens.push(_reward); }\\n        rewardToWantRoute[_reward] = _route;\\n    }\\n\\n    function setRewardExchange(address _reward, address _exchange) external onlyAdmin nonReentrant {\\n        require(_exchange != address(0), \\\"!ZeroAddress\\\");\\n        require(_reward != address(0), \\\"!ZeroAddress\\\");\\n        require(rewardExchange[_reward] != _exchange, \\\"!ZeroAddress\\\");\\n\\n        rewardExchange[_reward] = _exchange;\\n    }\\n\\n    function setKyberExchange(address _kyberExchange) external onlyAdmin nonReentrant {\\n        require(_kyberExchange != kyberExchange, \\\"Same address\\\");\\n        require(_kyberExchange != address(0), \\\"!ZeroAddress\\\");\\n\\n        kyberExchange = _kyberExchange;\\n    }\\n\\n    function setKyberRewardPathRoute(address _reward, address[] calldata _path) external onlyAdmin {\\n        require(_reward != address(0), \\\"!ZeroAddress\\\");\\n        require(_path[0] != address(0), \\\"!ZeroAddress path\\\");\\n\\n        bool newReward = true;\\n        for (uint i = 0; i < kyberRewards.length; i++) {\\n            if (kyberRewards[i] == _reward) {\\n                newReward = false;\\n                break;\\n            }\\n        }\\n\\n        if (newReward) { kyberRewards.push(_reward); }\\n        kyberRewardPathRoute[_reward] = _path;\\n    }\\n\\n    function setKyberRewardRoute(address _reward, address[] calldata _route) external onlyAdmin {\\n        require(_reward != address(0), \\\"!ZeroAddress\\\");\\n        require(_route[0] == _reward, \\\"First route isn't reward\\\");\\n        require(_route.length > 1, \\\"Can't have less than 2 tokens\\\");\\n\\n        bool newReward = true;\\n        for (uint i = 0; i < kyberRewards.length; i++) {\\n            if (kyberRewards[i] == _reward) {\\n                newReward = false;\\n                break;\\n            }\\n        }\\n\\n        if (newReward) { kyberRewards.push(_reward); }\\n        kyberRewardRoute[_reward] = _route;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/ICurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface ICurvePool {\\n    // _use_underlying If True, withdraw underlying assets instead of aTokens\\n    function add_liquidity(uint[2] calldata amounts, uint min_mint_amount, bool _use_underlying) external;\\n    function add_liquidity(uint[2] calldata amounts, uint min_mint_amount) external;\\n    function add_liquidity(uint[4] calldata amounts, uint min_mint_amount, bool _use_underlying) external;\\n    function add_liquidity(uint[4] calldata amounts, uint min_mint_amount) external;\\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint _min_amount) external returns (uint);\\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint _min_amount, bool _use_underlying) external;\\n    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);\\n    function calc_token_amount(uint[2] calldata _amounts, bool is_deposit) external view returns (uint);\\n    function calc_token_amount(uint[4] calldata _amounts, bool is_deposit) external view returns (uint);\\n    function underlying_coins(int128 i) external view returns (address);\\n    function underlying_coins(uint256 i) external view returns (address);\\n}\\n\\ninterface ICurveGauge {\\n    // This function should be view but it's not defined as view...\\n    function claimable_tokens(address) external returns (uint);\\n    function claimable_reward(address _user) external view returns (uint);\\n    function claimable_reward(address _user, address _reward) external view returns (uint);\\n    function reward_count() external view returns (uint);\\n    function reward_tokens(uint) external view returns (address);\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function claim_rewards() external;\\n    function deposit(uint _value) external;\\n    function withdraw(uint _value) external;\\n}\\n\\ninterface ICurveGaugeFactory {\\n    function mint(address _gauge) external;\\n    function minted(address _arg0, address _arg1) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"interfaces/IJarvisPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IJarvisPool {\\n    function deposit(uint256 _pid, uint256 _amount) external;\\n    function withdraw(uint256 _pid, uint256 _amount) external;\\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\\n    function emergencyWithdraw(uint256 _pid) external;\\n    function pendingRwd(uint256 _pid, address _user) external view returns (uint256);\\n    function endBlock() external view returns (uint256);\\n}\\n\\ninterface IJarvisRewards {\\n    function claim(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/CurveGaugeFactoryMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"../../interfaces/ICurve.sol\\\";\\n\\ninterface ICurveMock is ICurveGauge {\\n    function claimed(address) external;\\n}\\n\\ncontract CurveGaugeFactoryMock {\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 CRV = IERC20(0x40bde52e6B80Ae11F34C58c14E1E7fE1f9c834C4);\\n\\n    function mint(address _gauge) public {\\n        uint _Cbalance = CRV.balanceOf(address(this));\\n        uint _claimable = ICurveGauge(_gauge).claimable_tokens(msg.sender);\\n\\n        if (_Cbalance > 0 && _claimable > 0) {\\n            CRV.safeTransfer(msg.sender, _claimable);\\n            ICurveMock(_gauge).claimed(msg.sender);\\n        }\\n    }\\n\\n    function minted(address, address) public pure returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ControllerCurveStrat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"./ControllerStratAbs.sol\\\";\\nimport \\\"../interfaces/ICurve.sol\\\";\\n\\ncontract ControllerCurveStrat is ControllerStratAbs {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IERC20Metadata;\\n\\n    IERC20Metadata public immutable crvToken;\\n    address public immutable pool;\\n    address public immutable swapPool;\\n    ICurveGauge public immutable gauge;\\n    ICurveGaugeFactory public immutable gaugeFactory;\\n\\n    int128 private immutable poolSize;\\n    int128 private immutable tokenIndex; // want token index on the pool\\n\\n    uint8 private immutable gaugeType;\\n    uint8 private constant GAUGE_TYPE_STAKING = 0;\\n    uint8 private constant GAUGE_TYPE_CHILD_STAKING = 1;\\n\\n    constructor(\\n        IERC20Metadata _want,\\n        address _controller,\\n        address _exchange,\\n        address _treasury,\\n        IERC20Metadata _crvToken,\\n        address _pool,\\n        address _swapPool,\\n        ICurveGauge _gauge,\\n        ICurveGaugeFactory _gaugeFactory,\\n        uint8 _gaugeType\\n    ) ControllerStratAbs(_want, _controller, _exchange, _treasury) {\\n        require(_pool != address(0), \\\"pool !ZeroAddress\\\");\\n        require(_swapPool != address(0), \\\"swapPool !ZeroAddress\\\");\\n        require(address(_gauge) != address(0), \\\"gauge !ZeroAddress\\\");\\n        require(address(_gaugeFactory) != address(0), \\\"gaugeFactory !ZeroAddress\\\");\\n        require(_gaugeType < 2, \\\"gaugeType unknown\\\");\\n\\n        _checkIERC20(_crvToken, \\\"Invalid crvToken\\\");\\n        // Check gauge _behaves_ as a gauge\\n        _gauge.claimable_tokens(address(this));\\n        // Check gauge factory _behaves_ as a gauge factory\\n        _gaugeFactory.minted(address(this), address(this));\\n\\n        crvToken = _crvToken;\\n        pool = _pool;\\n        swapPool = _swapPool;\\n        gauge = _gauge;\\n        gaugeFactory = _gaugeFactory;\\n        gaugeType = _gaugeType;\\n\\n        (int128 _poolSize, bool _int128) = _guessPoolSize();\\n\\n        require(_poolSize > 0, \\\"poolSize is zero\\\");\\n\\n        int128 _index = _guessTokenIndex(_poolSize, _int128);\\n\\n        require(_index < _poolSize, \\\"Index out of bounds\\\");\\n\\n        poolSize = _poolSize;\\n        tokenIndex = _index;\\n    }\\n\\n    function identifier() external view returns (string memory) {\\n        return string(abi.encodePacked(want.symbol(), \\\"@Curve#1.0.0\\\"));\\n    }\\n\\n    function wantCRVBalance() public view returns (uint) {\\n        return crvToken.balanceOf(address(this));\\n    }\\n\\n    function balanceOfPool() public view override returns (uint) {\\n        return gauge.balanceOf(address(this));\\n    }\\n\\n    function balanceOfPoolInWant() public view override returns (uint) {\\n        return _calcWithdrawOneCoin(balanceOfPool());\\n    }\\n\\n    function _deposit() internal override {\\n        uint _wantBal = wantBalance();\\n\\n        if (_wantBal > 0) {\\n            _addLiquidity(_wantBal);\\n        }\\n\\n        uint _wantCRVBalance = wantCRVBalance();\\n\\n        if (_wantCRVBalance > 0) {\\n            crvToken.safeApprove(address(gauge), _wantCRVBalance);\\n            gauge.deposit(_wantCRVBalance);\\n        }\\n    }\\n\\n    function _addLiquidity(uint _wantBal) internal {\\n        uint _expected = _wantToWantCrvDoubleCheck(_wantBal, true);\\n\\n        if (poolSize == 2) {\\n            uint[2] memory _amounts;\\n\\n            _amounts[uint(uint128(tokenIndex))] = _wantBal;\\n\\n            want.safeApprove(pool, _wantBal);\\n            ICurvePool(pool).add_liquidity(_amounts, _expected, true);\\n        } else if (poolSize == 4) {\\n            uint[4] memory _amounts;\\n\\n            _amounts[uint(uint128(tokenIndex))] = _wantBal;\\n\\n            want.safeApprove(pool, _wantBal);\\n            ICurvePool(pool).add_liquidity(_amounts, _expected);\\n        }\\n    }\\n\\n    function _withdraw(uint _amount) internal override returns (uint) {\\n        uint _balance = wantBalance();\\n\\n        _withdrawFromPool(\\n            _wantToWantCrvDoubleCheck(_amount - _balance, false)\\n        );\\n\\n        uint _withdrawn = wantBalance() - _balance;\\n\\n        return (_withdrawn > _amount) ? _amount : _withdrawn;\\n    }\\n\\n    function _withdrawAll() internal override returns (uint) {\\n        uint _balance = wantBalance();\\n\\n        _withdrawFromPool(balanceOfPool());\\n\\n        return wantBalance() - _balance;\\n    }\\n\\n    function _withdrawFromPool(uint _wantCrvAmount) internal {\\n        // Remove staked from gauge\\n        gauge.withdraw(_wantCrvAmount);\\n\\n        // remove_liquidity\\n        uint _balance = wantCRVBalance();\\n        uint _expected = _wantCrvToWantDoubleCheck(_balance);\\n\\n        require(_expected > 0, \\\"remove_liquidity expected = 0\\\");\\n\\n        if (address(pool) != address(swapPool)) {\\n            crvToken.safeApprove(pool, _balance);\\n        }\\n\\n        ICurvePool(pool).remove_liquidity_one_coin(_balance, tokenIndex, _expected, true);\\n    }\\n\\n    function _claimRewards() internal override {\\n        // CRV rewards\\n        if (gauge.claimable_tokens(address(this)) > 0) {\\n            gaugeFactory.mint(address(gauge));\\n        }\\n\\n        // no-CRV rewards\\n        bool _claim = false;\\n\\n        if (gaugeType == GAUGE_TYPE_STAKING) {\\n            if (gauge.claimable_reward(address(this)) > 0) {\\n                _claim = true;\\n            }\\n        } else if (gaugeType == GAUGE_TYPE_CHILD_STAKING) {\\n            for (uint i = 0; i < gauge.reward_count(); i++) {\\n                address _reward = gauge.reward_tokens(i);\\n\\n                if (gauge.claimable_reward(address(this), _reward) > 0) {\\n                    _claim = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (_claim) { gauge.claim_rewards(); }\\n    }\\n\\n    function _minWantToWantCrv(uint _amount) internal view returns (uint) {\\n        // Based on virtual_price (poolMinVirtualPrice) and poolSlippageRatio\\n        // the expected amount is represented with 18 decimals as crvWant token\\n        // so we have to add 12 decimals (on USDC and USDT for example) to the want balance.\\n        // E.g. 1e6 (1WANT) * 1e12 * 99.4 / 100.0 => 0.994e18 crvToken tokens\\n        return _amount * WANT_MISSING_PRECISION * (RATIO_PRECISION - poolSlippageRatio - poolMinVirtualPrice) / RATIO_PRECISION;\\n    }\\n\\n    function _wantToWantCrvDoubleCheck(uint _amount, bool _isDeposit) internal view returns (uint _wantCrvAmount) {\\n        if (poolSize == 2) {\\n            uint[2] memory _amounts;\\n\\n            _amounts[uint(uint128(tokenIndex))] = _amount;\\n            // calc_token_amount doesn't consider fee\\n            _wantCrvAmount = ICurvePool(swapPool).calc_token_amount(_amounts, _isDeposit);\\n        } else if (poolSize == 4) {\\n            uint[4] memory _amounts;\\n\\n            _amounts[uint(uint128(tokenIndex))] = _amount;\\n            // calc_token_amount doesn't consider fee\\n            _wantCrvAmount = ICurvePool(swapPool).calc_token_amount(_amounts, _isDeposit);\\n        }\\n\\n        // Remove max fee\\n        _wantCrvAmount = _wantCrvAmount * (RATIO_PRECISION - poolSlippageRatio) / RATIO_PRECISION;\\n\\n        // In case the pool is unbalanced (attack), make a double check for\\n        // the expected amount with minExpected set ratios.\\n        uint _wantToWantCrv = _minWantToWantCrv(_amount);\\n\\n        if (_wantToWantCrv > _wantCrvAmount) { _wantCrvAmount = _wantToWantCrv; }\\n    }\\n\\n    // Calculate at least xx% of the expected. The function doesn't\\n    // consider the fee.\\n    function _wantCrvToWantDoubleCheck(uint _balance) internal view returns (uint _expected) {\\n        _expected = (\\n            _calcWithdrawOneCoin(_balance) * (RATIO_PRECISION - poolSlippageRatio)\\n        ) / RATIO_PRECISION;\\n\\n        // Double check for expected value\\n        // In this case we sum the poolMinVirtualPrice and divide by\\n        // (for example) 1e12 because we want to swap crvToken => WANT\\n        uint _minExpected = _balance *\\n            (RATIO_PRECISION + poolMinVirtualPrice - poolSlippageRatio) /\\n            RATIO_PRECISION /\\n            WANT_MISSING_PRECISION;\\n\\n        if (_minExpected > _expected) { _expected = _minExpected; }\\n    }\\n\\n    function _calcWithdrawOneCoin(uint _amount) internal view returns (uint) {\\n        if (_amount > 0) {\\n            return ICurvePool(pool).calc_withdraw_one_coin(_amount, tokenIndex);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    // Constructor helper\\n\\n    function _guessPoolSize() internal view returns (int128 _poolSize, bool _int128) {\\n        ICurvePool _pool = ICurvePool(pool);\\n        bool _loop = true;\\n\\n        _int128 = true;\\n\\n        while (_loop) {\\n            try _pool.underlying_coins(_poolSize) returns (address) {\\n                _poolSize += 1;\\n            } catch {\\n                try _pool.underlying_coins(uint256(int256(_poolSize))) returns (address) {\\n                    _int128 = false;\\n                    _poolSize += 1;\\n                } catch {\\n                    _loop = false;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _guessTokenIndex(int128 _poolSize, bool _int128) internal view returns (int128 _index) {\\n        address _want = address(want);\\n        ICurvePool _pool = ICurvePool(pool);\\n\\n        for (_index; _index < _poolSize; _index++) {\\n            if (_int128) {\\n                if (_want == _pool.underlying_coins(_index)) { break; }\\n            } else {\\n                if (_want == _pool.underlying_coins(uint256(int256(_index)))) { break; }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ControllerLPWithoutStrat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"./PiAdmin.sol\\\";\\n\\n// \\\"Strategy\\\" that only keeps the LP\\ncontract ControllerLPWithoutStrat is PiAdmin, Pausable, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    address public immutable controller; // immutable to prevent anyone to change it and withdraw\\n    address public immutable want; // LP\\n\\n    constructor(address _controller, address _lp) {\\n        require(_controller != address(0), \\\"Controller !ZeroAddress\\\");\\n        require(_lp != address(0), \\\"want !ZeroAddress\\\");\\n\\n        controller = _controller;\\n        want = _lp;\\n    }\\n\\n    modifier onlyController() {\\n        require(msg.sender == controller, \\\"Not from controller\\\");\\n        _;\\n    }\\n\\n    function identifier() external pure returns (string memory) {\\n        return string(\\\"any@LP#1.0.0\\\");\\n    }\\n\\n    // @dev Just receive LPs from Controller\\n    function deposit() external whenNotPaused onlyController nonReentrant {\\n        // This function is ALWAYS called from the Controller and is used just\\n        // to receive the LPs.\\n        // As Controller implementation:\\n        //       want.safeTransfer(strategy, _amount);\\n        //       IStrategy(strategy).deposit();\\n        //\\n        // At the moment we're not investing LPs in any pool. But to keep all the\\n        // strategies working in the same way we keep deposit/withdraw functions without\\n        // anything else more than receive and return LPs.\\n    }\\n\\n    // @dev Just return LPs to Controller\\n    function withdraw(uint _amount) external onlyController nonReentrant returns (uint) {\\n        IERC20(want).safeTransfer(controller, _amount);\\n\\n        return _amount;\\n    }\\n\\n    // @dev Just to be called from Controller for compatibility\\n    function beforeMovement() external nonReentrant { }\\n\\n    function wantBalance() public view returns (uint) {\\n        return IERC20(want).balanceOf(address(this));\\n    }\\n    function balance() public view returns (uint) {\\n        return wantBalance();\\n    }\\n    // called as part of strat migration. Sends all the available funds back to the vault.\\n    function retireStrat() external onlyController {\\n        _pause();\\n\\n        IERC20(want).safeTransfer(controller, wantBalance());\\n    }\\n\\n    function pause() public onlyAdmin {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyAdmin nonReentrant {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Controller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"../interfaces/IArchimedes.sol\\\";\\nimport \\\"../interfaces/IStrategy.sol\\\";\\n\\ncontract Controller is ERC20, Ownable, ReentrancyGuard {\\n    using SafeERC20 for IERC20Metadata;\\n\\n    // Address of Archimedes\\n    address public immutable archimedes;\\n    IERC20Metadata public immutable want;\\n\\n    // Archimedes controller index\\n    uint public pid = type(uint16).max; // 65535 means unassigned\\n\\n    address public strategy;\\n    address public treasury;\\n\\n    // Fees\\n    uint constant public RATIO_PRECISION = 10000;\\n    uint constant public MAX_WITHDRAW_FEE = 100; // 1%\\n    uint public withdrawFee = 10; // 0.1%\\n\\n    // Deposit limit a contract can hold\\n    // This value should be in the same decimal representation as want\\n    // 0 value means unlimit\\n    uint public depositLimit;\\n    uint public userDepositLimit;\\n\\n    event NewStrategy(address oldStrategy, address newStrategy);\\n    event NewTreasury(address oldTreasury, address newTreasury);\\n    event NewDepositLimit(uint oldLimit, uint newLimit);\\n    event NewUserDepositLimit(uint oldLimit, uint newLimit);\\n    event WithdrawalFee(uint amount);\\n\\n    constructor(\\n        IERC20Metadata _want,\\n        address _archimedes,\\n        address _treasury,\\n        string memory _shareSymbol\\n    ) ERC20(_shareSymbol, _shareSymbol) {\\n        _want.symbol(); // Check that want is at least an ERC20\\n        require(_want.balanceOf(address(this)) == 0, \\\"Invalid ERC20\\\"); // Check that want is at least an ERC20\\n        require(_want.allowance(msg.sender, address(this)) == 0, \\\"Invalid ERC20\\\"); // Check that want is at least an ERC20\\n        require(IArchimedes(_archimedes).piToken() != address(0), \\\"Invalid PiToken on Archimedes\\\");\\n        require(_treasury != address(0), \\\"Treasury !ZeroAddress\\\");\\n\\n        want = _want;\\n        archimedes = _archimedes;\\n        treasury = _treasury;\\n    }\\n\\n    function decimals() override public view returns (uint8) {\\n        return want.decimals();\\n    }\\n\\n    // BeforeTransfer callback to harvest the archimedes rewards for both users\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        // ignore mint/burn\\n        if (from != address(0) && to != address(0) && amount > 0) {\\n            IArchimedes(archimedes).beforeSharesTransfer(uint(pid), from, to, amount);\\n        }\\n    }\\n\\n    // AferTransfer callback to update the archimedes rewards for both users\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        if (from != address(0) && to != address(0) && amount > 0) {\\n            IArchimedes(archimedes).afterSharesTransfer(uint(pid), from, to, amount);\\n        }\\n    }\\n\\n    modifier onlyArchimedes() {\\n        require(msg.sender == archimedes, \\\"Not from Archimedes\\\");\\n        _;\\n    }\\n\\n    function setPid(uint _pid) external onlyArchimedes returns (uint) {\\n        require(pid >= type(uint16).max, \\\"pid already assigned\\\");\\n\\n        pid = _pid;\\n\\n        return pid;\\n    }\\n\\n    function setTreasury(address _treasury) external onlyOwner nonReentrant {\\n        require(_treasury != treasury, \\\"Same address\\\");\\n        require(_treasury != address(0), \\\"!ZeroAddress\\\");\\n        emit NewTreasury(treasury, _treasury);\\n\\n        treasury = _treasury;\\n    }\\n\\n    function setStrategy(address newStrategy) external onlyOwner nonReentrant {\\n        require(newStrategy != strategy, \\\"Same strategy\\\");\\n        require(newStrategy != address(0), \\\"!ZeroAddress\\\");\\n        require(IStrategy(newStrategy).want() == address(want), \\\"Not same want\\\");\\n        emit NewStrategy(strategy, newStrategy);\\n\\n        if (strategy != address(0)) {\\n            IStrategy(strategy).retireStrat();\\n            require(\\n                IStrategy(strategy).balance() <= 0,\\n                \\\"Strategy still has deposits\\\"\\n            );\\n        }\\n\\n        strategy = newStrategy;\\n\\n        _strategyDeposit();\\n    }\\n\\n    function setWithdrawFee(uint _fee) external onlyOwner nonReentrant {\\n        require(_fee != withdrawFee, \\\"Same fee\\\");\\n        require(_fee <= MAX_WITHDRAW_FEE, \\\"!cap\\\");\\n\\n        withdrawFee = _fee;\\n    }\\n\\n    function setDepositLimit(uint _amount) external onlyOwner nonReentrant {\\n        require(_amount != depositLimit, \\\"Same limit\\\");\\n        require(_amount >= 0, \\\"Can't be negative\\\");\\n\\n        emit NewDepositLimit(depositLimit, _amount);\\n\\n        depositLimit = _amount;\\n    }\\n\\n    function setUserDepositLimit(uint _amount) external onlyOwner nonReentrant {\\n        require(_amount != userDepositLimit, \\\"Same limit\\\");\\n        require(_amount >= 0, \\\"Can't be negative\\\");\\n\\n        emit NewUserDepositLimit(userDepositLimit, _amount);\\n\\n        userDepositLimit = _amount;\\n    }\\n\\n    function deposit(address _senderUser, uint _amount) external onlyArchimedes nonReentrant {\\n        require(!_strategyPaused(), \\\"Strategy paused\\\");\\n        require(_amount > 0, \\\"Insufficient amount\\\");\\n        _checkDepositLimit(_senderUser, _amount);\\n\\n        IStrategy(strategy).beforeMovement();\\n\\n        uint _before = balance();\\n\\n        want.safeTransferFrom(\\n            archimedes, // Archimedes\\n            address(this),\\n            _amount\\n        );\\n\\n        uint _diff = balance() - _before;\\n\\n        uint shares;\\n        if (totalSupply() <= 0) {\\n            shares = _diff;\\n        } else {\\n            shares = (_diff * totalSupply()) / _before;\\n        }\\n\\n        _mint(_senderUser, shares);\\n\\n        _strategyDeposit();\\n    }\\n\\n    // Withdraw partial funds, normally used with a vault withdrawal\\n    function withdraw(address _senderUser, uint _shares) external onlyArchimedes nonReentrant returns (uint) {\\n        require(_shares > 0, \\\"Insufficient shares\\\");\\n        IStrategy(strategy).beforeMovement();\\n\\n        // This line has to be calc before burn\\n        uint _withdraw = (balance() * _shares) / totalSupply();\\n\\n        _burn(_senderUser, _shares);\\n\\n        uint _balance = wantBalance();\\n        uint withdrawn;\\n\\n        if (_balance < _withdraw) {\\n            uint _diff = _withdraw - _balance;\\n\\n            // withdraw will revert if anyything weird happend with the\\n            // transfer back but just in case we ensure that the withdraw is\\n            // positive\\n            withdrawn = IStrategy(strategy).withdraw(_diff);\\n            require(withdrawn > 0, \\\"Can't withdraw from strategy...\\\");\\n\\n            _balance = wantBalance();\\n            if (_balance < _withdraw) { _withdraw = _balance; }\\n        }\\n\\n        uint withdrawalFee = _withdraw * withdrawFee / RATIO_PRECISION;\\n        withdrawn = _withdraw - withdrawalFee;\\n\\n        want.safeTransfer(archimedes, withdrawn);\\n        if (withdrawalFee > 0) {\\n            want.safeTransfer(treasury, withdrawalFee);\\n            emit WithdrawalFee(withdrawFee);\\n        }\\n\\n        if (!_strategyPaused()) { _strategyDeposit(); }\\n\\n        return withdrawn;\\n    }\\n\\n    function _strategyPaused() internal view returns (bool){\\n        return IStrategy(strategy).paused();\\n    }\\n\\n    function strategyBalance() public view returns (uint){\\n        return IStrategy(strategy).balance();\\n    }\\n\\n    function wantBalance() public view returns (uint) {\\n        return want.balanceOf(address(this));\\n    }\\n\\n    function balance() public view returns (uint) {\\n        return wantBalance() + strategyBalance();\\n    }\\n\\n    // Check whats the max available amount to deposit\\n    function availableDeposit() external view returns (uint _available) {\\n        if (depositLimit <= 0) { // without limit\\n            _available = type(uint).max;\\n        } else if (balance() < depositLimit) {\\n            _available = depositLimit - balance();\\n        }\\n    }\\n\\n    function availableUserDeposit(address _user) public view returns (uint _available) {\\n        if (userDepositLimit <= 0) { // without limit\\n            _available = type(uint).max;\\n        } else {\\n            _available = userDepositLimit;\\n            // if there's no deposit yet, the totalSupply division raise\\n            if (totalSupply() > 0) {\\n                // Check the real amount in want for the user\\n                uint _precision = 10 ** decimals();\\n                uint _pricePerShare = (balance() * _precision) / totalSupply();\\n                uint _current = balanceOf(_user) * _pricePerShare / _precision;\\n\\n                if (_current >= _available) {\\n                    _available = 0;\\n                }  else {\\n                    _available -= _current;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _strategyDeposit() internal {\\n        uint _amount = wantBalance();\\n\\n        if (_amount > 0) {\\n            want.safeTransfer(strategy, _amount);\\n\\n            IStrategy(strategy).deposit();\\n        }\\n    }\\n\\n    function _checkDepositLimit(address _user, uint _amount) internal view {\\n        // 0 depositLimit means no-limit\\n        if (depositLimit > 0) {\\n            require(balance() + _amount <= depositLimit, \\\"Max depositLimit reached\\\");\\n        }\\n\\n        if (userDepositLimit > 0) {\\n            require(_amount <= availableUserDeposit(_user), \\\"Max userDepositLimit reached\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IArchimedes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IArchimedes {\\n    function piToken() external view returns (address);\\n    function beforeSharesTransfer(uint _pid, address _from, address _to, uint _amount) external;\\n    function afterSharesTransfer(uint _pid, address _from, address _to, uint _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Distributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\nimport \\\"./PiAdmin.sol\\\";\\nimport { IPiToken } from \\\"../interfaces/IPiToken.sol\\\";\\n\\ninterface IPiVault is IERC20 {\\n    function deposit(uint amount) external returns (uint);\\n}\\n\\ncontract Distributor is PiAdmin, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IPiVault;\\n\\n    IPiToken public immutable piToken;\\n    IPiVault public immutable piVault;\\n\\n    uint private lastBlock;\\n\\n    // tokens per investor \\\"ticket\\\"\\n    uint public constant INVESTOR_PER_BLOCK = 0.04779e18;\\n    // tokens per founder\\n    uint public constant FOUNDER_PER_BLOCK = 0.11948e18;\\n    // tokens for treasury\\n    uint public constant TREASURY_PER_BLOCK = 0.11948e18;\\n\\n    address public treasury;\\n\\n    // investor wallet => investor tickets per block\\n    mapping(address => uint) public investorTickets;\\n    uint public constant INVESTORS_TICKETS = 15;\\n    uint public constant INVESTORS_COUNT = 10;\\n    address[] public investors = new address[](INVESTORS_COUNT);\\n\\n    // 3 founders has the same proportion\\n    uint public constant FOUNDERS_COUNT = 3;\\n    address[] public founders = new address[](FOUNDERS_COUNT);\\n\\n    uint public leftTokensForInvestors = 9.42e24; // 9.42M\\n    uint public leftTokensForFounders  = 9.42e24; // 9.42M\\n    uint public leftTokensForTreasury  = 1.57e24; // 1.57M\\n\\n    constructor(address _piToken, address _piVault, address _treasury) {\\n        piToken = IPiToken(_piToken);\\n        piVault = IPiVault(_piVault);\\n        treasury = _treasury;\\n        lastBlock = _blockNumber();\\n\\n        // Will be changed for the right wallets before deploy\\n        founders[0] = address(0x1cC86b9b67C93B8Fa411554DB761f68979E7995A);\\n        founders[1] = address(0xBF67C362d035e6B6e95C4F254fe359Eea8B8C7ea);\\n        founders[2] = address(0xc2d2fE7c1aD582723Df08e3e176762f70d7aC7eC);\\n\\n        investors[0] = address(0x3181893d37BC1F89635B4dDAc5A7424d804FA9c9);\\n        investors[1] = address(0x610DA3A2b17a0611552E7519b804D2E554CbCE35);\\n        investors[2] = address(0x713C9aE2D300FE95f9778dC63DdA6B6a64E16474);\\n        investors[3] = address(0xD5399bE4abD48fBe728E5e20E352633a206Da795);\\n        investors[4] = address(0x774A1a1546Ff63135414b7394FD50779dfD0296d);\\n        investors[5] = address(0xc5A094F8AC2c9a51144930565Af590C51F1C1F66);\\n        investors[6] = address(0xe4eDB9B7b97884f37660b00aDfbB814bD4Bf1d61);\\n        investors[7] = address(0x75037D275A63f6449bbcAC7e971695696D6C2ce5);\\n        investors[8] = address(0x21E1A8CE937c0A0382ECebe687e9968c2f51731b);\\n        investors[9] = address(0x7341Fb8d04BE5FaEFe9152EC8Ca90908deBA1CB6);\\n\\n        investorTickets[investors[0]] = 4;\\n        investorTickets[investors[1]] = 2;\\n        investorTickets[investors[2]] = 2;\\n        investorTickets[investors[3]] = 1;\\n        investorTickets[investors[4]] = 1;\\n        investorTickets[investors[5]] = 1;\\n        investorTickets[investors[6]] = 1;\\n        investorTickets[investors[7]] = 1;\\n        investorTickets[investors[8]] = 1;\\n        investorTickets[investors[9]] = 1;\\n    }\\n\\n    event NewTreasury(address oldTreasury, address newTreasury);\\n    event InvestorsDistributed(uint amount);\\n    event FoundersDistributed(uint amount);\\n    event TreasoryDistributed(uint amount);\\n\\n    function setTreasury(address _treasury) external onlyAdmin nonReentrant {\\n        require(_treasury != treasury, \\\"Same address\\\");\\n        require(_treasury != address(0), \\\"!ZeroAddress\\\");\\n        emit NewTreasury(treasury, _treasury);\\n\\n        treasury = _treasury;\\n    }\\n\\n    function distribute() external nonReentrant {\\n        require(_blockNumber() > lastBlock, \\\"Have to wait\\\");\\n        require(\\n            leftTokensForInvestors > 0 ||\\n            leftTokensForFounders > 0 ||\\n            leftTokensForTreasury > 0,\\n            \\\"Nothing more to do\\\"\\n        );\\n\\n        uint multiplier = _blockNumber() - lastBlock;\\n\\n        _depositToInvestors(multiplier);\\n        _depositToFounders(multiplier);\\n        _transferToTreasury(multiplier);\\n\\n        lastBlock = _blockNumber();\\n    }\\n\\n    function _depositToInvestors(uint multiplier) internal {\\n        if (leftTokensForInvestors <= 0) { return; }\\n\\n        uint amount = multiplier * INVESTOR_PER_BLOCK * INVESTORS_TICKETS;\\n\\n        // Check for limit to mint\\n        if (amount > leftTokensForInvestors) {\\n            amount = leftTokensForInvestors;\\n        }\\n\\n        leftTokensForInvestors -= amount;\\n\\n        IERC20(piToken).safeApprove(address(piVault), amount);\\n        uint shares = piVault.deposit(amount);\\n\\n        // Calc how many shares correspond to each \\\"ticket\\\"\\n        uint sharesPerTicket = shares / INVESTORS_TICKETS;\\n\\n        for (uint i = 0; i < INVESTORS_COUNT; i++) {\\n            address wallet = investors[i];\\n            uint _sharesAmount = sharesPerTicket * investorTickets[wallet];\\n\\n            // send deposited stk2Pi to each investor\\n            piVault.safeTransfer(wallet, _sharesAmount);\\n        }\\n\\n        emit InvestorsDistributed(amount);\\n    }\\n\\n    function _depositToFounders(uint multiplier) internal {\\n        if (leftTokensForFounders <= 0) { return; }\\n\\n        uint amount = multiplier * FOUNDER_PER_BLOCK * FOUNDERS_COUNT;\\n\\n        // Check for limit to mint\\n        if (amount > leftTokensForFounders) {\\n            amount = leftTokensForFounders;\\n        }\\n\\n        leftTokensForFounders -= amount;\\n\\n        // Calc deposited shares\\n        IERC20(piToken).safeApprove(address(piVault), amount);\\n        uint shares = piVault.deposit(amount);\\n\\n        // Calc how many shares correspond to each founder\\n        uint sharesPerFounder = shares / FOUNDERS_COUNT;\\n\\n        for (uint i = 0; i < FOUNDERS_COUNT; i++) {\\n            // send deposited stk2Pi to each investor\\n            piVault.safeTransfer(founders[i], sharesPerFounder);\\n        }\\n\\n        emit FoundersDistributed(amount);\\n    }\\n\\n    function _transferToTreasury(uint multiplier) internal {\\n        // Just in case of division \\\"rest\\\"\\n        uint shares = piVault.balanceOf(address(this));\\n        if (shares > 0) { piVault.safeTransfer(treasury, shares); }\\n\\n        if (leftTokensForTreasury <= 0) { return; }\\n\\n        uint amount = multiplier * TREASURY_PER_BLOCK;\\n\\n        // Check for limit to mint\\n        if (amount > leftTokensForTreasury) {\\n            amount = leftTokensForTreasury;\\n        }\\n\\n        leftTokensForTreasury -= amount;\\n\\n        // SuperToken transfer is safe\\n        piToken.transfer(treasury, amount);\\n\\n        emit TreasoryDistributed(amount);\\n    }\\n\\n    // Only to be mocked\\n    function _blockNumber() internal view virtual returns (uint) {\\n        return block.number;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/DistributorMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"../Distributor.sol\\\";\\n\\ncontract DistributorMock is Distributor {\\n    uint private mockedBlockNumber;\\n\\n    constructor(address _piToken, address _piVault, address _treasury) Distributor(_piToken, _piVault, _treasury) {}\\n\\n    function setBlockNumber(uint _n) public {\\n        mockedBlockNumber = _n;\\n    }\\n\\n    function _blockNumber() internal view override returns (uint) {\\n        return mockedBlockNumber == 0 ? block.number : mockedBlockNumber;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ArchimedesAPI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"./Swappable.sol\\\";\\nimport \\\"../interfaces/IPiToken.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IReferral.sol\\\";\\n\\n// Swappable contract has the AccessControl module\\ncontract ArchimedesAPI is Swappable, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IPiToken;\\n\\n    address public handler; // 0x640bb21185093058549dFB000D566358dc40C584\\n    address public exchange;\\n    mapping(uint => address[]) public piTokenToWantRoute;\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IERC20 want;             // Address of token contract.\\n        uint weighing;           // How much weighing assigned to this pool. PIes to distribute per block.\\n        uint lastRewardBlock;    // Last block number that PIes distribution occurs.\\n        uint accPiTokenPerShare; // Accumulated PIes per share, times SHARE_PRECISION. See below.\\n        address controller;      // Token controller\\n    }\\n\\n    // IPiToken already have safe transfer from SuperToken\\n    IPiToken public immutable piToken;\\n    bytes private constant txData = new bytes(0); // just to support SuperToken mint\\n\\n    // Used to made multiplications and divitions over shares\\n    uint public constant SHARE_PRECISION = 1e18;\\n\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n    // Info of each user that stakes tokens.\\n    // Users can't transfer controller's minted tokens\\n    mapping(uint => mapping(address => uint)) public userPaidRewards;\\n    // Total weighing. Must be the sum of all pools weighing.\\n    uint public totalWeighing;\\n    // The block number when PI mining starts.\\n    uint public immutable startBlock;\\n\\n    // PiToken referral contract address.\\n    IReferral public referralMgr;\\n    // Referral commission rate in basis points.\\n    uint16 public referralCommissionRate = 10; // 1%\\n    // Max referral commission rate: 5%.\\n    uint16 public constant MAXIMUM_REFERRAL_COMMISSION_RATE = 50; // 5%\\n    uint16 public constant COMMISSION_RATE_PRECISION = 1000;\\n\\n    event Deposit(uint indexed pid, address indexed user, uint amount);\\n    event Withdraw(uint indexed pid, address indexed user, uint amount);\\n    event EmergencyWithdraw(uint indexed pid, address indexed user, uint amount);\\n    event NewPool(uint indexed pid, address want, uint weighing);\\n    event PoolWeighingUpdated(uint indexed pid, uint oldWeighing, uint newWeighing);\\n    event Harvested(uint indexed pid, address indexed user, uint amount);\\n    event NewExchange(address oldExchange, address newExchange);\\n    event NewHandler(address oldHandler, address newHandler);\\n\\n    constructor(IPiToken _piToken, uint _startBlock, address _handler) {\\n        require(address(_piToken) != address(0), \\\"Pi address !ZeroAddress\\\");\\n        require(_startBlock > _blockNumber(), \\\"StartBlock must be in the future\\\");\\n        require(_handler != address(0), \\\"Handler !ZeroAddress\\\");\\n\\n        piToken = _piToken;\\n        startBlock = _startBlock;\\n        handler = _handler;\\n    }\\n\\n    modifier onlyHandler() {\\n        require(msg.sender == handler, \\\"Only handler\\\");\\n        _;\\n    }\\n\\n    function setExchange(address _newExchange) external onlyAdmin {\\n        require(_newExchange != exchange, \\\"Same address\\\");\\n        require(_newExchange != address(0), \\\"!ZeroAddress\\\");\\n        emit NewExchange(exchange, _newExchange);\\n        exchange = _newExchange;\\n    }\\n\\n    function setRoute(uint _pid, address[] memory _route) external onlyAdmin {\\n        // Last address in path should be the same than pool.want\\n        require(_route[0] == address(piToken), \\\"First token is not PiToken\\\");\\n        require(_route[_route.length - 1] == address(poolInfo[_pid].want), \\\"Last token is not want\\\");\\n        require(poolInfo[_pid].controller != address(0), \\\"Unknown pool\\\");\\n\\n        piTokenToWantRoute[_pid] = _route;\\n    }\\n\\n    function setHandler(address _newHandler) external onlyAdmin {\\n        require(_newHandler != handler, \\\"Same address\\\");\\n        require(_newHandler != address(0), \\\"!ZeroAddress\\\");\\n        emit NewHandler(handler, _newHandler);\\n        handler = _newHandler;\\n    }\\n\\n    // Add a new want token to the pool. Can only be called by the admin.\\n    function addNewPool(IERC20 _want, address _ctroller, uint _weighing, bool _massUpdate) external onlyAdmin {\\n        require(address(_want) != address(0), \\\"Address zero not allowed\\\");\\n        require(IController(_ctroller).archimedes() == address(this), \\\"Not an Archimedes controller\\\");\\n        require(IController(_ctroller).strategy() != address(0), \\\"Controller without strategy\\\");\\n\\n        // Update pools before a weighing change\\n        if (_massUpdate) { massUpdatePools(); }\\n\\n        uint lastRewardBlock = _blockNumber() > startBlock ? _blockNumber() : startBlock;\\n\\n        totalWeighing += _weighing;\\n\\n        poolInfo.push(PoolInfo({\\n            want: _want,\\n            weighing: _weighing,\\n            lastRewardBlock: lastRewardBlock,\\n            accPiTokenPerShare: 0,\\n            controller: _ctroller\\n        }));\\n\\n        uint _pid = poolInfo.length - 1;\\n        uint _setPid = IController(_ctroller).setPid(_pid);\\n        require(_pid == _setPid, \\\"Pid doesn't match\\\");\\n\\n        emit NewPool(_pid, address(_want),  _weighing);\\n    }\\n\\n    // Update the given pool's PI rewards weighing\\n    function changePoolWeighing(uint _pid, uint _weighing, bool _massUpdate) external onlyAdmin {\\n        emit PoolWeighingUpdated(_pid, poolInfo[_pid].weighing, _weighing);\\n        // Update pools before a weighing change\\n        if (_massUpdate) {\\n            massUpdatePools();\\n        } else {\\n            updatePool(_pid);\\n        }\\n\\n        totalWeighing = (totalWeighing - poolInfo[_pid].weighing) + _weighing;\\n        poolInfo[_pid].weighing = _weighing;\\n    }\\n\\n    // Return reward multiplier over the given _from to _to block.\\n    function _getMultiplier(uint _from, uint _to) internal pure returns (uint) {\\n        return _to - _from;\\n    }\\n\\n    // Update reward variables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        for (uint pid = 0; pid < poolInfo.length; ++pid) {\\n            updatePool(pid);\\n            if (_outOfGasForLoop()) { break; }\\n        }\\n    }\\n\\n    // Mint api tokens for a given pool pid\\n    function updatePool(uint _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n\\n        // If same block as last update return\\n        if (_blockNumber() <= pool.lastRewardBlock) { return; }\\n        // If community Mint is already finished\\n        uint apiLeftToMint = piToken.apiLeftToMint();\\n        if (apiLeftToMint <= 0) {\\n            pool.lastRewardBlock = _blockNumber();\\n            return;\\n        }\\n\\n        uint sharesTotal = _controller(_pid).totalSupply();\\n\\n        if (sharesTotal <= 0 || pool.weighing <= 0) {\\n            pool.lastRewardBlock = _blockNumber();\\n            return;\\n        }\\n\\n        uint multiplier = _getMultiplier(pool.lastRewardBlock, _blockNumber());\\n        uint piTokenReward = (multiplier * piTokenPerBlock() * pool.weighing) / totalWeighing;\\n\\n        // No rewards =( update lastRewardBlock\\n        if (piTokenReward <= 0) {\\n            pool.lastRewardBlock = _blockNumber();\\n            return;\\n        }\\n\\n        // If the reward is greater than the left to mint\\n        if (piTokenReward > apiLeftToMint) {\\n            piTokenReward = apiLeftToMint;\\n        }\\n\\n        piToken.apiMint(address(this), piTokenReward);\\n\\n        pool.accPiTokenPerShare += (piTokenReward * SHARE_PRECISION) / sharesTotal;\\n        pool.lastRewardBlock = _blockNumber();\\n    }\\n\\n    // Deposit want token to Archimedes for PI allocation.\\n    function deposit(uint _pid, address _user, uint _amount, address _referrer) external nonReentrant onlyHandler {\\n        require(_amount > 0, \\\"Insufficient deposit\\\");\\n\\n        // Update pool rewards\\n        updatePool(_pid);\\n\\n        // Record referral if it's needed\\n        _recordReferral(_pid, _user, _referrer);\\n\\n        uint _before = _wantBalance(poolInfo[_pid].want);\\n\\n        // Pay rewards\\n        _calcPendingAndSwapRewards(_pid, _user);\\n\\n        // Transfer from user => Archimedes\\n        // This is the only line that should transfer from msg.sender to Archimedes\\n        // And in case of swap rewards will be included in the deposit\\n        poolInfo[_pid].want.safeTransferFrom(msg.sender, address(this), _amount);\\n        uint _balance = _wantBalance(poolInfo[_pid].want) - _before;\\n\\n        // Deposit in the controller\\n        _depositInController(_pid, _user, _balance);\\n    }\\n\\n    // Withdraw want token from Archimedes.\\n    function withdraw(uint _pid, address _user, uint _shares) external nonReentrant onlyHandler {\\n        require(_shares > 0, \\\"0 shares\\\");\\n        require(_userShares(_pid, _user) >= _shares, \\\"withdraw: not sufficient founds\\\");\\n\\n        updatePool(_pid);\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n\\n        uint _before = _wantBalance(pool.want);\\n\\n        // Pay rewards\\n        _calcPendingAndSwapRewards(_pid, _user);\\n\\n        // this should burn shares and control the amount\\n        uint withdrawn = _controller(_pid).withdraw(_user, _shares);\\n        require(withdrawn > 0, \\\"Can't withdraw from controller\\\");\\n\\n        uint __wantBalance = _wantBalance(pool.want) - _before;\\n\\n        pool.want.safeTransfer(_user, __wantBalance);\\n\\n        // This is to \\\"save\\\" like the new amount of shares was paid\\n        _updateUserPaidRewards(_pid, _user);\\n\\n        emit Withdraw(_pid, _user, _shares);\\n    }\\n\\n    // Claim rewards for a pool\\n    function harvest(uint _pid, address _user) public nonReentrant {\\n        if (_userShares(_pid, _user) <= 0) { return; }\\n\\n        updatePool(_pid);\\n\\n        uint _before = _wantBalance(poolInfo[_pid].want);\\n\\n        uint harvested = _calcPendingAndSwapRewards(_pid, _user);\\n\\n        uint _balance = _wantBalance(poolInfo[_pid].want) - _before;\\n\\n        if (_balance > 0) {\\n            _depositInController(_pid, _user, _balance);\\n        }\\n\\n        if (harvested > 0) { emit Harvested(_pid, _user, harvested); }\\n    }\\n\\n    function harvestAll(address _user) external {\\n        uint length = poolInfo.length;\\n        for (uint pid = 0; pid < length; ++pid) {\\n            harvest(pid, _user);\\n            if (_outOfGasForLoop()) { break; }\\n        }\\n    }\\n\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint _pid, address _user) external nonReentrant {\\n        require(msg.sender == _user || hasRole(DEFAULT_ADMIN_ROLE, msg.sender) || msg.sender == handler, \\\"Not authorized\\\");\\n        IERC20 want = poolInfo[_pid].want;\\n\\n        userPaidRewards[_pid][_user] = 0;\\n\\n        uint _shares = _userShares(_pid, _user);\\n\\n        uint _before = _wantBalance(want);\\n        // this should burn shares and control the amount\\n        _controller(_pid).withdraw(_user, _shares);\\n\\n        uint __wantBalance = _wantBalance(want) - _before;\\n        want.safeTransfer(_user, __wantBalance);\\n\\n        emit EmergencyWithdraw(_pid, _user, _shares);\\n    }\\n\\n    // Controller callback before transfer to harvest users rewards\\n    function beforeSharesTransfer(uint /*_pid*/, address /*_from*/, address /*_to*/, uint /*amount*/) external pure {\\n        revert(\\\"API shares are handled by handler at the moment\\\");\\n    }\\n\\n    // Controller callback after transfer to update users rewards\\n    function afterSharesTransfer(uint /*_pid*/, address /*_from*/, address /*_to*/, uint /*amount*/) external pure {\\n        revert(\\\"API shares are handled by handler at the moment\\\");\\n    }\\n\\n    function _updateUserPaidRewards(uint _pid, address _user) internal {\\n        userPaidRewards[_pid][_user] = (_userShares(_pid, _user) * poolInfo[_pid].accPiTokenPerShare) / SHARE_PRECISION;\\n    }\\n\\n    function _wantBalance(IERC20 _want) internal view returns (uint) {\\n        return _want.balanceOf(address(this));\\n    }\\n\\n    // Record referral in referralMgr contract if needed\\n    function _recordReferral(uint _pid, address _user, address _referrer) internal {\\n        // only if it's the first deposit\\n        if (_userShares(_pid, _user) <= 0 && _referrer != address(0) &&\\n            _referrer != _user && address(referralMgr) != address(0)) {\\n\\n            referralMgr.recordReferral(_user, _referrer);\\n        }\\n    }\\n\\n    function _depositInController(uint _pid, address _user, uint _amount) internal {\\n        // Archimedes => controller transfer & deposit\\n        poolInfo[_pid].want.safeIncreaseAllowance(poolInfo[_pid].controller, _amount);\\n        _controller(_pid).deposit(_user, _amount);\\n        // This is to \\\"save\\\" like the new amount of shares was paid\\n        _updateUserPaidRewards(_pid, _user);\\n\\n        emit Deposit(_pid, _user, _amount);\\n    }\\n\\n    // Pay rewards\\n    function _calcPendingAndSwapRewards(uint _pid, address _user) internal returns (uint pending) {\\n        uint _shares = _userShares(_pid, _user);\\n\\n        if (_shares > 0) {\\n            pending = ((_shares * poolInfo[_pid].accPiTokenPerShare) / SHARE_PRECISION) - paidRewards(_pid, _user);\\n\\n            if (pending > 0) {\\n                _swapForWant(_pid, pending);\\n                _payReferralCommission(_pid, _user, pending);\\n            }\\n        }\\n    }\\n\\n    function _swapForWant(uint _pid, uint _amount) internal returns (uint swapped) {\\n        uint piTokenBal = piToken.balanceOf(address(this));\\n\\n        if (_amount > piTokenBal) { _amount = piTokenBal; }\\n\\n        if (_amount > 0) {\\n            uint expected = _expectedForSwap(_amount, address(piToken), address(poolInfo[_pid].want));\\n\\n            require(expected > 0, \\\"Can't swap for 0 tokens\\\");\\n\\n            piToken.safeApprove(exchange, _amount);\\n            uint[] memory outAmounts = IUniswapRouter(exchange).swapExactTokensForTokens(\\n                _amount, expected, piTokenToWantRoute[_pid], address(this), block.timestamp + 60\\n            );\\n\\n            // Only last amount is needed\\n            swapped = outAmounts[outAmounts.length - 1];\\n        }\\n    }\\n\\n    // Update the referral contract address by the admin\\n    function setReferralAddress(IReferral _newReferral) external onlyAdmin {\\n        require(_newReferral != referralMgr, \\\"Same Manager\\\");\\n        require(address(_newReferral) != address(0), \\\"!ZeroAddress\\\");\\n        referralMgr = _newReferral;\\n    }\\n\\n    // Update referral commission rate by the admin\\n    function setReferralCommissionRate(uint16 _referralCommissionRate) external onlyAdmin {\\n        require(_referralCommissionRate != referralCommissionRate, \\\"Same rate\\\");\\n        require(_referralCommissionRate <= MAXIMUM_REFERRAL_COMMISSION_RATE, \\\"rate greater than MaxCommission\\\");\\n        referralCommissionRate = _referralCommissionRate;\\n    }\\n\\n    // Pay referral commission to the referrer who referred this user.\\n    function _payReferralCommission(uint _pid, address _user, uint _pending) internal {\\n        if (address(referralMgr) != address(0) && referralCommissionRate > 0) {\\n            address referrer = referralMgr.getReferrer(_user);\\n\\n            uint commissionAmount = (_pending * referralCommissionRate) / COMMISSION_RATE_PRECISION;\\n\\n            if (referrer != address(0) && commissionAmount > 0) {\\n                // Instead of mint to the user, we call mint, swap and transfer\\n                uint apiLeftToMint = piToken.apiLeftToMint();\\n                if (apiLeftToMint < commissionAmount) {\\n                    commissionAmount = apiLeftToMint;\\n                }\\n\\n                if (commissionAmount > 0) {\\n                    piToken.apiMint(address(this), commissionAmount);\\n\\n                    uint _reward = _swapForWant(_pid, commissionAmount);\\n\\n                    poolInfo[_pid].want.safeTransfer(referrer, _reward);\\n\\n                    referralMgr.referralPaid(referrer, commissionAmount); // sum paid\\n                }\\n            }\\n        }\\n    }\\n\\n    // View functions\\n    function poolLength() external view returns (uint) {\\n        return poolInfo.length;\\n    }\\n\\n    function _userShares(uint _pid, address _user) internal view returns (uint) {\\n        return _controller(_pid).balanceOf(_user);\\n    }\\n\\n    function paidRewards(uint _pid, address _user) public view returns (uint) {\\n        return userPaidRewards[_pid][_user];\\n    }\\n    function _controller(uint _pid) internal view returns (IController) {\\n        return IController(poolInfo[_pid].controller);\\n    }\\n\\n    // old vault functions\\n    function getPricePerFullShare(uint _pid) external view returns (uint) {\\n        uint _totalSupply = _controller(_pid).totalSupply();\\n        uint precision = 10 ** decimals(_pid);\\n\\n        return _totalSupply <= 0 ? precision : ((_controller(_pid).balance() * precision) / _totalSupply);\\n    }\\n    function decimals(uint _pid) public view returns (uint) {\\n        return _controller(_pid).decimals();\\n    }\\n    function balance(uint _pid) external view returns (uint) {\\n        return _controller(_pid).balance();\\n    }\\n    function balanceOf(uint _pid, address _user) external view returns (uint) {\\n        return _controller(_pid).balanceOf(_user);\\n    }\\n\\n    function piTokenPerBlock() public view returns (uint) {\\n        // Skip x% of minting per block for Referrals\\n        uint reserve = COMMISSION_RATE_PRECISION - referralCommissionRate;\\n        return piToken.apiMintPerBlock() * reserve / COMMISSION_RATE_PRECISION;\\n    }\\n\\n    // Only to be mocked\\n    function _blockNumber() internal view virtual returns (uint) {\\n        return block.number;\\n    }\\n\\n    // In case of stucketd 2Pi tokens after 2 years\\n    // check if any holder has pending tokens then call this fn\\n    // E.g. in case of a few EmergencyWithdraw the rewards will be stucked\\n    function redeemStuckedPiTokens() external onlyAdmin {\\n        require(piToken.totalSupply() == piToken.MAX_SUPPLY(), \\\"PiToken still minting\\\");\\n        // 2.5 years (2.5 * 365 * 24 * 3600) / 2.4s per block == 32850000\\n        require(_blockNumber() > (startBlock + 32850000), \\\"Still waiting\\\");\\n\\n        uint _balance = piToken.balanceOf(address(this));\\n\\n        if (_balance > 0) { piToken.safeTransfer(msg.sender, _balance); }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/ArchimedesAPIMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport { ArchimedesAPI, IPiToken } from \\\"../ArchimedesAPI.sol\\\";\\n\\ncontract ArchimedesAPIMock is ArchimedesAPI {\\n    uint private mockedBlockNumber;\\n\\n    constructor(\\n        IPiToken _piToken,\\n        uint _startBlock,\\n        address _handler\\n    ) ArchimedesAPI(_piToken, _startBlock, _handler) { }\\n\\n    function setBlockNumber(uint _n) public {\\n        mockedBlockNumber = _n;\\n    }\\n\\n    function _blockNumber() internal view override returns (uint) {\\n        return mockedBlockNumber == 0 ? block.number : mockedBlockNumber;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PiToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport { IERC1820Registry } from \\\"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"./PiAdmin.sol\\\";\\nimport \\\"../vendor_contracts/NativeSuperTokenProxy.sol\\\";\\n\\ncontract PiToken is NativeSuperTokenProxy, PiAdmin {\\n    // mint/burn roles\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant BURNER_ROLE = keccak256(\\\"BURNER_ROLE\\\");\\n\\n    // ERC777 registration in ERC1820\\n    bytes32 internal constant ERC777Recipient = keccak256(\\\"ERC777TokensRecipient\\\");\\n    IERC1820Registry constant internal _ERC1820_REGISTRY =\\n        IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\\n\\n    uint public constant MAX_SUPPLY = 6.28e25; // (2 * pi) 62.8M tokens\\n    uint public constant INITIAL_SUPPLY = (\\n        2512000 +  // Airdrop + incentives 2.512M\\n         942000 +  // Exchange 942K\\n        7536000 +  // Future rounds (investors) 7.536M\\n        9420000 +  // Timelock Founders 9.42M\\n        9420000 +  // Timelock Investors 9.42M\\n        1570000    // Timelock Treasury 1.57M\\n    ) * (10 ** 18);\\n\\n    // Rates to mint per block\\n    uint public communityMintPerBlock;\\n    uint public apiMintPerBlock;\\n\\n    // Keep track in which block started the current tranche\\n    uint internal tranchesBlock;\\n\\n    // Keep track of minted per type for current tranch\\n    uint internal apiMintedForCurrentTranch;\\n    uint internal communityMintedForCurrentTranch;\\n    // Keep track of un-minted per type for old tranches\\n    uint internal apiReserveFromOldTranches;\\n    uint internal communityReserveFromOldTranches;\\n\\n    uint internal API_TYPE = 0;\\n    uint internal COMMUNITY_TYPE = 1;\\n\\n    // Events from SuperToken\\n    // Minted, Burned, Transfer, Sent\\n\\n    // Should be called from a wallet\\n    function init() external onlyAdmin {\\n        require(_self().totalSupply() <= 0, \\\"Already initialized\\\");\\n\\n        _self().initialize(IERC20(address(0x0)), 18, '2Pi', '2Pi');\\n\\n        _ERC1820_REGISTRY.setInterfaceImplementer(\\n            address(this),\\n            ERC777Recipient,\\n            address(this)\\n        );\\n\\n        _self().selfMint(msg.sender, INITIAL_SUPPLY, abi.encodePacked(keccak256(\\\"Tokens for INITIAL SUPPLY\\\")));\\n    }\\n\\n    function addMinter(address newMinter) external onlyAdmin {\\n        _setupRole(MINTER_ROLE, newMinter);\\n    }\\n\\n    function initRewardsOn(uint __blockNumber) external onlyAdmin {\\n        require(tranchesBlock <= 0, \\\"Already set\\\");\\n        tranchesBlock = __blockNumber;\\n    }\\n\\n    // Before change api or community RatePerBlock or before mintForMultiChain is called\\n    // Calculate and accumulate the un-minted amounts.\\n    function _beforeChangeMintRate() internal {\\n        if (tranchesBlock > 0 && _blockNumber() > tranchesBlock && (apiMintPerBlock > 0 || communityMintPerBlock > 0)) {\\n            // Accumulate both proportions to keep track of \\\"un-minted\\\" amounts\\n            apiReserveFromOldTranches += _leftToMintForCurrentBlock(API_TYPE);\\n            communityReserveFromOldTranches += _leftToMintForCurrentBlock(COMMUNITY_TYPE);\\n        }\\n    }\\n\\n    function setCommunityMintPerBlock(uint _rate) external onlyAdmin {\\n        require(_rate != communityMintPerBlock, \\\"Same rate\\\");\\n\\n        _beforeChangeMintRate();\\n        communityMintPerBlock = _rate;\\n        _updateCurrentTranch();\\n    }\\n\\n    function setApiMintPerBlock(uint _rate) external onlyAdmin {\\n        require(_rate != apiMintPerBlock, \\\"Same rate\\\");\\n\\n        _beforeChangeMintRate();\\n        apiMintPerBlock = _rate;\\n        _updateCurrentTranch();\\n    }\\n\\n    function _updateCurrentTranch() internal {\\n        // Update variables to making calculations from this moment\\n        if (tranchesBlock > 0 && _blockNumber() > tranchesBlock) {\\n            tranchesBlock = _blockNumber();\\n        }\\n\\n        apiMintedForCurrentTranch = 0;\\n        communityMintedForCurrentTranch = 0;\\n    }\\n\\n    // This function is made to mint an arbitrary amount for other chains\\n    function mintForMultiChain(uint _amount, bytes calldata data) external onlyAdmin {\\n        require(_amount > 0, \\\"Insufficient supply\\\");\\n        require(_self().totalSupply() + _amount <= MAX_SUPPLY, \\\"Cant' mint more than cap\\\");\\n\\n        _beforeChangeMintRate();\\n\\n        // Mint + transfer to skip the 777-receiver callback\\n        _self().selfMint(address(this), _amount, data);\\n        // SuperToken transfer is safe\\n        _self().transfer(msg.sender, _amount);\\n\\n        _updateCurrentTranch();\\n    }\\n\\n    // This function checks for \\\"most of revert scenarios\\\" to prevent more minting than expected.\\n    // And keep track of minted / un-minted amounts\\n    function _checkMintFor(address _receiver, uint _supply, uint _type) internal {\\n        require(hasRole(MINTER_ROLE, msg.sender), \\\"Only minters\\\");\\n        require(_receiver != address(0), \\\"Can't mint to zero address\\\");\\n        require(_supply > 0, \\\"Insufficient supply\\\");\\n        require(tranchesBlock > 0, \\\"Rewards not initialized\\\");\\n        require(tranchesBlock < _blockNumber(), \\\"Still waiting for rewards block\\\");\\n        require(_self().totalSupply() + _supply <= MAX_SUPPLY, \\\"Mint capped to 62.8M\\\");\\n\\n        uint _ratePerBlock = communityMintPerBlock;\\n        if (_type == API_TYPE) { _ratePerBlock = apiMintPerBlock; }\\n\\n        require(_ratePerBlock > 0, \\\"Mint ratio is 0\\\");\\n\\n        // Get the max mintable supply for the current tranche\\n        uint _maxMintableSupply = _leftToMintForCurrentBlock(_type);\\n\\n        // Create other variable to add to the MintedForCurrentTranch\\n        uint _toMint = _supply;\\n\\n        // if the _supply (mint amount) is less than the expected \\\"everything is fine\\\" but\\n        // if its greater we have to check the \\\"ReserveFromOldTranches\\\"\\n        if (_toMint > _maxMintableSupply) {\\n            // fromReserve is the amount that will be \\\"minted\\\" from the old tranches reserve\\n            uint fromReserve = _toMint - _maxMintableSupply;\\n\\n            // Drop the \\\"reserve\\\" amount to track only the \\\"real\\\" tranch minted amount\\n            _toMint -= fromReserve;\\n\\n            // Check reserve for type\\n            if (_type == API_TYPE) {\\n                require(fromReserve <= apiReserveFromOldTranches, \\\"Can't mint more than expected\\\");\\n\\n                // drop the minted \\\"extra\\\" amount from old tranches reserve\\n                apiReserveFromOldTranches -= fromReserve;\\n            } else {\\n                require(fromReserve <= communityReserveFromOldTranches, \\\"Can't mint more than expected\\\");\\n\\n                // drop the minted \\\"extra\\\" amount from history reserve\\n                communityReserveFromOldTranches -= fromReserve;\\n            }\\n        }\\n\\n        if (_type == API_TYPE) {\\n            apiMintedForCurrentTranch += _toMint;\\n        } else {\\n            communityMintedForCurrentTranch += _toMint;\\n        }\\n    }\\n\\n    function communityMint(address _receiver, uint _supply) external {\\n        _checkMintFor(_receiver, _supply, COMMUNITY_TYPE);\\n\\n        // Mint + transfer to skip the 777-receiver callback\\n        _self().selfMint(address(this), _supply, abi.encodePacked(keccak256(\\\"Tokens for Community\\\")));\\n        // SuperToken transfer is safe\\n        _self().transfer(_receiver, _supply);\\n    }\\n\\n    function apiMint(address _receiver, uint _supply) external {\\n        _checkMintFor(_receiver, _supply, API_TYPE);\\n\\n        // Mint + transfer to skip the 777-receiver callback\\n        _self().selfMint(address(this), _supply, abi.encodePacked(keccak256(\\\"Tokens for API\\\")));\\n        // SuperToken transfer is safe\\n        _self().transfer(_receiver, _supply);\\n    }\\n\\n    function communityLeftToMint() public view returns (uint) {\\n        return _leftToMint(COMMUNITY_TYPE);\\n    }\\n\\n    function apiLeftToMint() public view returns (uint) {\\n        return _leftToMint(API_TYPE);\\n    }\\n\\n    function _leftToMintForCurrentBlock(uint _type) internal view returns (uint) {\\n        if (tranchesBlock <= 0 || tranchesBlock > _blockNumber()) { return 0; }\\n\\n       uint left = _blockNumber() - tranchesBlock;\\n\\n       if (_type == API_TYPE) {\\n           left *= apiMintPerBlock;\\n           left -= apiMintedForCurrentTranch;\\n       } else {\\n           left *= communityMintPerBlock;\\n           left -= communityMintedForCurrentTranch;\\n       }\\n\\n       return left;\\n    }\\n\\n    function _leftToMint(uint _type) internal view returns (uint) {\\n        uint totalLeft = MAX_SUPPLY - _self().totalSupply();\\n        if (totalLeft <= 0) { return 0; }\\n\\n        // Get the max mintable supply for the current tranche\\n        uint _maxMintableSupply = _leftToMintForCurrentBlock(_type);\\n\\n        // Add the _type accumulated un-minted supply\\n        _maxMintableSupply += (_type == API_TYPE ? apiReserveFromOldTranches : communityReserveFromOldTranches);\\n\\n        return (totalLeft <= _maxMintableSupply ? totalLeft : _maxMintableSupply);\\n    }\\n\\n    function tokensReceived(\\n        address /*operator*/,\\n        address /*from*/,\\n        address /*to*/,\\n        uint256 /*amount*/,\\n        bytes calldata /*userData*/,\\n        bytes calldata /*operatorData*/\\n    ) external view {\\n        require(msg.sender == address(this), \\\"Invalid token\\\");\\n    }\\n\\n\\n    // For future use, just in case\\n    function addBurner(address newBurner) external onlyAdmin {\\n        _setupRole(BURNER_ROLE, newBurner);\\n    }\\n\\n    // prevent anyone can burn\\n    function burn(uint _amount, bytes calldata data) external {\\n        require(hasRole(BURNER_ROLE, msg.sender), \\\"Only burners\\\");\\n\\n        _self().selfBurn(msg.sender, _amount, data);\\n    }\\n\\n    function _self() internal view returns (ISuperToken) {\\n        return ISuperToken(address(this));\\n    }\\n\\n    function cap() external pure returns (uint) {\\n        return MAX_SUPPLY;\\n    }\\n\\n    // Implemented to be mocked in tests\\n    function _blockNumber() internal view virtual returns (uint) {\\n        return block.number;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the global ERC1820 Registry, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\\n * implementers for interfaces in this registry, as well as query support.\\n *\\n * Implementers may be shared by multiple accounts, and can also implement more\\n * than a single interface for each account. Contracts can implement interfaces\\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\\n * contract.\\n *\\n * {IERC165} interfaces can also be queried via the registry.\\n *\\n * For an in-depth explanation and source code analysis, see the EIP text.\\n */\\ninterface IERC1820Registry {\\n    /**\\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\\n     * account is able to set interface implementers for it.\\n     *\\n     * By default, each account is its own manager. Passing a value of `0x0` in\\n     * `newManager` will reset the manager to this initial state.\\n     *\\n     * Emits a {ManagerChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     */\\n    function setManager(address account, address newManager) external;\\n\\n    /**\\n     * @dev Returns the manager for `account`.\\n     *\\n     * See {setManager}.\\n     */\\n    function getManager(address account) external view returns (address);\\n\\n    /**\\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\\n     * `interfaceHash`.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     * The zero address can also be used in `implementer` to remove an old one.\\n     *\\n     * See {interfaceHash} to learn how these are created.\\n     *\\n     * Emits an {InterfaceImplementerSet} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\\n     * end in 28 zeroes).\\n     * - `implementer` must implement {IERC1820Implementer} and return true when\\n     * queried for support, unless `implementer` is the caller. See\\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\\n     */\\n    function setInterfaceImplementer(\\n        address account,\\n        bytes32 _interfaceHash,\\n        address implementer\\n    ) external;\\n\\n    /**\\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\\n     * implementer is registered, returns the zero address.\\n     *\\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\\n     * zeroes), `account` will be queried for support of it.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     */\\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\\n\\n    /**\\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\\n     * corresponding\\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\\n     */\\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\\n\\n    /**\\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\\n     * @param account Address of the contract for which to update the cache.\\n     * @param interfaceId ERC165 interface for which to update the cache.\\n     */\\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\\n\\n    /**\\n     * @notice Checks whether a contract implements an ERC165 interface or not.\\n     * If the result is not cached a direct lookup on the contract address is performed.\\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\\n     * {updateERC165Cache} with the contract address.\\n     * @param account Address of the contract to check.\\n     * @param interfaceId ERC165 interface to check.\\n     * @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    /**\\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\\n     * @param account Address of the contract to check.\\n     * @param interfaceId ERC165 interface to check.\\n     * @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\\n\\n    event ManagerChanged(address indexed account, address indexed newManager);\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/PiTokenMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"../PiToken.sol\\\";\\n\\ncontract PiTokenMock is PiToken {\\n    uint private mockedBlockNumber;\\n\\n    function setBlockNumber(uint _n) public {\\n        mockedBlockNumber = _n;\\n    }\\n\\n    function _blockNumber() internal view override returns (uint) {\\n        return mockedBlockNumber == 0 ? block.number : mockedBlockNumber;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BridgedPiToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"./PiAdmin.sol\\\";\\n\\ncontract BridgedPiToken is PiAdmin {\\n    using SafeERC20 for IERC20;\\n\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n    IERC20 public immutable piToken;\\n\\n    // Rates to mint per block\\n    uint public communityMintPerBlock;\\n    uint public apiMintPerBlock;\\n\\n    // Keep track in which block started the current tranche\\n    uint internal tranchesBlock;\\n\\n    // Keep track of minted per type for current tranch\\n    uint internal apiMintedForCurrentTranch;\\n    uint internal communityMintedForCurrentTranch;\\n    // Keep track of un-minted per type for old tranches\\n    uint internal apiReserveFromOldTranches;\\n    uint internal communityReserveFromOldTranches;\\n\\n    uint internal API_TYPE = 0;\\n    uint internal COMMUNITY_TYPE = 1;\\n\\n\\n    constructor(IERC20 _piToken) {\\n        piToken = _piToken;\\n    }\\n\\n    function initRewardsOn(uint __blockNumber) external onlyAdmin {\\n        require(tranchesBlock <= 0, \\\"Already set\\\");\\n        tranchesBlock = __blockNumber;\\n    }\\n\\n    // Before change api or community RatePerBlock or before mintForMultiChain is called\\n    // Calculate and accumulate the un-minted amounts.\\n    function _beforeChangeMintRate() internal {\\n        if (tranchesBlock > 0 && _blockNumber() > tranchesBlock && (apiMintPerBlock > 0 || communityMintPerBlock > 0)) {\\n            // Accumulate both proportions to keep track of \\\"un-minted\\\" amounts\\n            apiReserveFromOldTranches += _leftToMintForCurrentBlock(API_TYPE);\\n            communityReserveFromOldTranches += _leftToMintForCurrentBlock(COMMUNITY_TYPE);\\n        }\\n    }\\n\\n    function setCommunityMintPerBlock(uint _rate) external onlyAdmin {\\n        require(_rate != communityMintPerBlock, \\\"Same rate\\\");\\n\\n        _beforeChangeMintRate();\\n        communityMintPerBlock = _rate;\\n        _updateCurrentTranch();\\n    }\\n\\n    function setApiMintPerBlock(uint _rate) external onlyAdmin {\\n        require(_rate != apiMintPerBlock, \\\"Same rate\\\");\\n\\n        _beforeChangeMintRate();\\n        apiMintPerBlock = _rate;\\n        _updateCurrentTranch();\\n    }\\n\\n    function _updateCurrentTranch() internal {\\n        // Update variables to making calculations from this moment\\n        if (tranchesBlock > 0 && _blockNumber() > tranchesBlock) {\\n            tranchesBlock = _blockNumber();\\n        }\\n\\n        // mintedForCurrentTranch = self().totalSupply();\\n        apiMintedForCurrentTranch = 0;\\n        communityMintedForCurrentTranch = 0;\\n    }\\n\\n\\n    function addMinter(address newMinter) external onlyAdmin {\\n        _setupRole(MINTER_ROLE, newMinter);\\n    }\\n\\n    function available() public view returns (uint) {\\n        return piToken.balanceOf(address(this));\\n    }\\n\\n    // This function checks for \\\"most of revert scenarios\\\" to prevent more minting than expected.\\n    // And keep track of minted / un-minted amounts\\n    function _checkMintFor(address _receiver, uint _supply, uint _type) internal {\\n        require(hasRole(MINTER_ROLE, msg.sender), \\\"Only minters\\\");\\n        require(_receiver != address(0), \\\"Can't mint to zero address\\\");\\n        require(_supply > 0, \\\"Insufficient supply\\\");\\n        require(tranchesBlock > 0, \\\"Rewards not initialized\\\");\\n        require(tranchesBlock < _blockNumber(), \\\"Still waiting for rewards block\\\");\\n        require(available() >= _supply, \\\"Can't mint more than available\\\");\\n\\n        uint _ratePerBlock = communityMintPerBlock;\\n        if (_type == API_TYPE) { _ratePerBlock = apiMintPerBlock; }\\n\\n        require(_ratePerBlock > 0, \\\"Mint ratio is 0\\\");\\n\\n        // Get the max mintable supply for the current tranche\\n        uint _maxMintableSupply = _leftToMintForCurrentBlock(_type);\\n\\n        // Create other variable to add to the MintedForCurrentTranch\\n        uint _toMint = _supply;\\n\\n        // if the _supply (mint amount) is less than the expected \\\"everything is fine\\\" but\\n        // if its greater we have to check the \\\"ReserveFromOldTranches\\\"\\n        if (_toMint > _maxMintableSupply) {\\n            // fromReserve is the amount that will be \\\"minted\\\" from the old tranches reserve\\n            uint fromReserve = _toMint - _maxMintableSupply;\\n\\n            // Drop the \\\"reserve\\\" amount to track only the \\\"real\\\" tranch minted amount\\n            _toMint -= fromReserve;\\n\\n            // Check reserve for type\\n            if (_type == API_TYPE) {\\n                require(fromReserve <= apiReserveFromOldTranches, \\\"Can't mint more than expected\\\");\\n\\n                // drop the minted \\\"extra\\\" amount from old tranches reserve\\n                apiReserveFromOldTranches -= fromReserve;\\n            } else {\\n                require(fromReserve <= communityReserveFromOldTranches, \\\"Can't mint more than expected\\\");\\n\\n                // drop the minted \\\"extra\\\" amount from history reserve\\n                communityReserveFromOldTranches -= fromReserve;\\n            }\\n        }\\n\\n        if (_type == API_TYPE) {\\n            apiMintedForCurrentTranch += _toMint;\\n        } else {\\n            communityMintedForCurrentTranch += _toMint;\\n        }\\n    }\\n\\n    // This function is called mint for contract compatibility but it doesn't mint,\\n    // it only transfers piTokens\\n    function communityMint(address _receiver, uint _supply) external {\\n        _checkMintFor(_receiver, _supply, COMMUNITY_TYPE);\\n\\n        piToken.safeTransfer(_receiver, _supply);\\n    }\\n\\n    function apiMint(address _receiver, uint _supply) external {\\n        _checkMintFor(_receiver, _supply, API_TYPE);\\n\\n        piToken.safeTransfer(_receiver, _supply);\\n    }\\n\\n    function _leftToMintForCurrentBlock(uint _type) internal view returns (uint) {\\n        if (tranchesBlock <= 0 || tranchesBlock > _blockNumber()) { return 0; }\\n\\n       uint left = _blockNumber() - tranchesBlock;\\n\\n       if (_type == API_TYPE) {\\n           left *= apiMintPerBlock;\\n           left -= apiMintedForCurrentTranch;\\n       } else {\\n           left *= communityMintPerBlock;\\n           left -= communityMintedForCurrentTranch;\\n       }\\n\\n       return left;\\n    }\\n\\n    function _leftToMint(uint _type) internal view returns (uint) {\\n        uint totalLeft = available();\\n        if (totalLeft <= 0) { return 0; }\\n\\n        // Get the max mintable supply for the current tranche\\n        uint _maxMintableSupply = _leftToMintForCurrentBlock(_type);\\n\\n        // Add the _type accumulated un-minted supply\\n        _maxMintableSupply += (_type == API_TYPE ? apiReserveFromOldTranches : communityReserveFromOldTranches);\\n\\n        return (totalLeft <= _maxMintableSupply ? totalLeft : _maxMintableSupply);\\n    }\\n\\n    function communityLeftToMint() public view returns (uint) {\\n        return _leftToMint(COMMUNITY_TYPE);\\n    }\\n\\n    function apiLeftToMint() public view returns (uint) {\\n        return _leftToMint(API_TYPE);\\n    }\\n\\n\\n    function balanceOf(address account) public view returns (uint) {\\n        return piToken.balanceOf(account);\\n    }\\n\\n    // Implemented to be mocked in tests\\n    function _blockNumber() internal view virtual returns (uint) {\\n        return block.number;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/BridgedPiTokenMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"../BridgedPiToken.sol\\\";\\n\\ncontract BridgedPiTokenMock is BridgedPiToken {\\n    uint private mockedBlockNumber;\\n\\n    constructor(IERC20 _token) BridgedPiToken(_token) {}\\n\\n    function setBlockNumber(uint _n) public {\\n        mockedBlockNumber = _n;\\n    }\\n\\n    function _blockNumber() internal view override returns (uint) {\\n        return mockedBlockNumber == 0 ? block.number : mockedBlockNumber;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mocks/WETHMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\n// MODIFIED FROM: superfluid/ethereum-contracts/contracts/mocks/WETH9Mock.sol\\n\\n// Copyright (C) 2015, 2016, 2017 Dapphub\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.15;\\n\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\ncontract WETHMock {\\n    string public name     = \\\"Wrapped Ether\\\";\\n    string public symbol   = \\\"WETH\\\";\\n    uint8  public decimals = 18;\\n\\n    event  Approval(address indexed src, address indexed guy, uint wad);\\n    event  Transfer(address indexed src, address indexed dst, uint wad);\\n    event  Deposit(address indexed dst, uint wad);\\n    event  Withdrawal(address indexed src, uint wad);\\n\\n    mapping (address => uint)                       public  balanceOf;\\n    mapping (address => mapping (address => uint))  public  allowance;\\n\\n    receive() external payable {\\n        deposit();\\n    }\\n    function deposit() public payable {\\n        balanceOf[msg.sender] += msg.value;\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n    function withdraw(uint wad) public {\\n        require(balanceOf[msg.sender] >= wad);\\n        balanceOf[msg.sender] -= wad;\\n        Address.sendValue(payable(msg.sender), address(this).balance);\\n        emit Withdrawal(msg.sender, wad);\\n    }\\n\\n    function totalSupply() public view returns (uint) {\\n        return address(this).balance;\\n    }\\n\\n    function approve(address guy, uint wad) public returns (bool) {\\n        allowance[msg.sender][guy] = wad;\\n        emit Approval(msg.sender, guy, wad);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint wad) public returns (bool) {\\n        return transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function transferFrom(address src, address dst, uint wad)\\n        public\\n        returns (bool)\\n    {\\n        require(balanceOf[src] >= wad);\\n\\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint).max) {\\n            require(allowance[src][msg.sender] >= wad);\\n            allowance[src][msg.sender] -= wad;\\n        }\\n\\n        balanceOf[src] -= wad;\\n        balanceOf[dst] += wad;\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IBalancer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\\n * types.\\n *\\n * This concept is unrelated to a Pool's Asset Managers.\\n */\\ninterface IAsset {\\n    // solhint-disable-previous-line no-empty-blocks\\n}\\n\\ninterface IBalancerV2Vault {\\n    function joinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        JoinPoolRequest memory request\\n    ) external payable;\\n\\n    struct JoinPoolRequest {\\n        IAsset[] assets;\\n        uint256[] maxAmountsIn;\\n        bytes userData;\\n        bool fromInternalBalance;\\n    }\\n\\n    function exitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address payable recipient,\\n        ExitPoolRequest memory request\\n    ) external;\\n\\n    struct ExitPoolRequest {\\n        IAsset[] assets;\\n        uint256[] minAmountsOut;\\n        bytes userData;\\n        bool toInternalBalance;\\n    }\\n\\n    function getPoolTokens(bytes32 poolId)\\n    external\\n    view\\n    returns (\\n        IERC20[] memory tokens,\\n        uint256[] memory balances,\\n        uint256 lastChangeBlock\\n    );\\n\\n    function getPool(bytes32 poolId) external view returns (address, uint8);\\n}\\n\\ninterface IBalancerPool {\\n    function getRate() external view returns (uint);\\n}\\n\\nstruct BalancerV2Claim {\\n    uint distributionId;\\n    uint balance;\\n    address distributor;\\n    uint tokenIndex;\\n    bytes32[] merkleProof;\\n}\\n\\ninterface IBalancerDistributor {\\n    function claimDistributions(address claimer, BalancerV2Claim[] memory claims, IERC20[] memory tokens) external;\\n}\\n\\ninterface IBalancerGauge {\\n    function deposit(uint amount) external;\\n    function withdraw(uint amount) external;\\n    function claim_rewards() external;\\n    function claimable_reward(address, address) view external returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/ControllerBalancerV2Strat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"./ControllerStratAbs.sol\\\";\\nimport \\\"../interfaces/IBalancer.sol\\\";\\nimport \\\"../libraries/Bytes32Utils.sol\\\";\\n\\ncontract ControllerBalancerV2Strat is ControllerStratAbs {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IERC20Metadata;\\n    using Bytes32Utils for bytes32;\\n\\n    bytes32 public constant HARVESTER_ROLE = keccak256(\\\"HARVESTER_ROLE\\\");\\n\\n    bytes32 public immutable poolId;\\n    IBalancerV2Vault public immutable vault;\\n\\n    // Pool settings\\n    // JoinKind { INIT = 0, EXACT_TOKENS_IN_FOR_BPT_OUT = 1, TOKEN_IN_FOR_EXACT_BPT_OUT = 2}\\n    uint public constant JOIN_KIND = 1;\\n    // ExitKind {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT = 0, EXACT_BPT_IN_FOR_TOKENS_OUT = 1, BPT_IN_FOR_EXACT_TOKENS_OUT = 2}\\n    uint public constant EXACT_BPT_IN_FOR_ONE_TOKEN_OUT = 0;\\n    uint public constant BPT_IN_FOR_EXACT_TOKENS_OUT = 2;\\n    uint public constant SHARES_PRECISION = 1e18; // same as BPT token\\n    IBalancerDistributor public immutable distributor = IBalancerDistributor(0x0F3e0c4218b7b0108a3643cFe9D3ec0d4F57c54e);\\n\\n    address public constant GAUGE = address(0x72843281394E68dE5d55BCF7072BB9B2eBc24150);\\n\\n    constructor(\\n        IBalancerV2Vault _vault,\\n        bytes32 _poolId,\\n        IERC20Metadata _want,\\n        address _controller,\\n        address _exchange,\\n        address _treasury\\n    ) ControllerStratAbs(_want, _controller, _exchange, _treasury){\\n        require(_poolId != \\\"\\\", \\\"Empty poolId\\\");\\n\\n        vault = _vault;\\n        poolId = _poolId;\\n\\n        require(_assets().length > 0, \\\"Vault without tokens\\\");\\n        _setupRole(HARVESTER_ROLE, msg.sender);\\n    }\\n\\n\\n    function identifier() external view returns (string memory) {\\n        return string(abi.encodePacked(\\n            want.symbol(),\\n            \\\"-0x\\\",\\n            poolId.toString(),\\n            \\\"@BalancerV2#1.0.0\\\"\\n        ));\\n    }\\n\\n    function _claimRewards() internal override {\\n        bool _claim = false;\\n\\n        for (uint i = 0; i < rewardTokens.length; i++) {\\n            address reward = rewardTokens[i];\\n\\n            if (IBalancerGauge(GAUGE).claimable_reward(address(this), reward) > 0) {\\n                _claim = true;\\n                break;\\n            }\\n        }\\n\\n        if (_claim) { IBalancerGauge(GAUGE).claim_rewards(); }\\n    }\\n\\n    function _deposit() internal override {\\n        uint _balance = wantBalance();\\n\\n        if (_balance > 0) {\\n            IAsset[] memory tokens = _assets();\\n            uint[] memory amounts = new uint[](tokens.length);\\n\\n\\n            amounts[_tokenIndex(tokens)] = _balance;\\n\\n            uint expected = (\\n                _balance * WANT_MISSING_PRECISION * SHARES_PRECISION *\\n                (RATIO_PRECISION - poolSlippageRatio) / RATIO_PRECISION /\\n                _pricePerShare()\\n            );\\n\\n            require(expected > 0, \\\"Insufficient expected amount\\\");\\n\\n            bytes memory userData = abi.encode(JOIN_KIND, amounts, expected);\\n\\n            IERC20(want).safeApprove(address(vault), _balance);\\n\\n            vault.joinPool(\\n                poolId,\\n                address(this),\\n                address(this),\\n                IBalancerV2Vault.JoinPoolRequest({\\n                    assets: tokens,\\n                    maxAmountsIn: amounts,\\n                    userData: userData,\\n                    fromInternalBalance: false\\n                })\\n            );\\n        }\\n\\n        // Stake\\n        uint _amount =  balanceOfVaultPool();\\n        if (_amount > 0) {\\n            IERC20(pool()).safeApprove(GAUGE, _amount);\\n            IBalancerGauge(GAUGE).deposit(_amount);\\n        }\\n    }\\n\\n    // amount is the want expected to be withdrawn\\n    function _withdraw(uint _amount) internal override returns (uint) {\\n        IAsset[] memory tokens = _assets();\\n        uint[] memory amounts = new uint[](tokens.length);\\n\\n        uint _balance = wantBalance();\\n        if (_balance < _amount) {\\n            uint diff = _amount - _balance;\\n            amounts[_tokenIndex(tokens)] = diff;\\n\\n            // We put a little more than the expected amount because of the fees & the pool swaps\\n            uint expected = (\\n                diff * WANT_MISSING_PRECISION * SHARES_PRECISION *\\n                (RATIO_PRECISION + poolSlippageRatio) / RATIO_PRECISION /\\n                _pricePerShare()\\n            );\\n\\n            require(expected > 0, \\\"Insufficient expected amount\\\");\\n\\n            // In case that the calc gives a little more than the balance\\n            uint _balanceOfPool = balanceOfPool();\\n            if (expected > _balanceOfPool) { expected = _balanceOfPool; }\\n\\n            //Unstake\\n            IBalancerGauge(GAUGE).withdraw(expected);\\n            require(balanceOfVaultPool() >= expected, \\\"Gauge gave less than expected\\\");\\n\\n            bytes memory userData = abi.encode(BPT_IN_FOR_EXACT_TOKENS_OUT, amounts, expected);\\n\\n            vault.exitPool(\\n                poolId,\\n                address(this),\\n                payable(address(this)),\\n                IBalancerV2Vault.ExitPoolRequest({\\n                    assets: tokens,\\n                    minAmountsOut: amounts,\\n                    userData: userData,\\n                    toInternalBalance: false\\n                })\\n            );\\n        }\\n\\n        uint withdrawn = wantBalance() - _balance;\\n\\n        return (withdrawn > _amount) ? _amount : withdrawn;\\n    }\\n\\n    function _withdrawAll() internal override returns (uint) {\\n        IAsset[] memory tokens = _assets();\\n        uint[] memory amounts = new uint[](tokens.length);\\n\\n        uint _balance = wantBalance();\\n\\n        //Unstake\\n        uint stakedBalance = balanceOfPool();\\n        IBalancerGauge(GAUGE).withdraw(stakedBalance);\\n        require(balanceOfVaultPool() >= stakedBalance, \\\"Gauge gave less than expected\\\");\\n\\n        uint index = 0;\\n        uint bptBalance = balanceOfVaultPool();\\n\\n        uint expected = (\\n            bptBalance * _pricePerShare() *\\n            (RATIO_PRECISION - poolSlippageRatio) / RATIO_PRECISION /\\n            WANT_MISSING_PRECISION / SHARES_PRECISION\\n        );\\n\\n        require(expected > 0, \\\"Insufficient expected amount\\\");\\n\\n        index = _tokenIndex(tokens);\\n        amounts[index] = expected;\\n\\n        // Withdraw all the BPT directly\\n        bytes memory userData = abi.encode(EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, bptBalance, index);\\n\\n        vault.exitPool(\\n            poolId,\\n            address(this),\\n            payable(address(this)),\\n            IBalancerV2Vault.ExitPoolRequest({\\n                assets: tokens,\\n                minAmountsOut: amounts,\\n                userData: userData,\\n                toInternalBalance: false\\n            })\\n        );\\n\\n        // Not sure if the minAmountsOut are respected in this case so re-check\\n        uint withdrawn = wantBalance() - _balance;\\n\\n        require(withdrawn >= expected, \\\"Less tokens than expected\\\");\\n\\n        return withdrawn;\\n    }\\n\\n    function pool() public view returns (address _pool) {\\n        (_pool,) = vault.getPool(poolId);\\n    }\\n\\n    function balanceOfVaultPool() public view returns (uint) {\\n        return IERC20(pool()).balanceOf(address(this));\\n    }\\n\\n    function balanceOfPool() public view override returns (uint) {\\n        return IERC20(GAUGE).balanceOf(address(this));\\n    }\\n\\n    function balanceOfPoolInWant() public view override returns (uint) {\\n        return balanceOfPool() * _pricePerShare() / WANT_MISSING_PRECISION / SHARES_PRECISION;\\n    }\\n\\n    function _pricePerShare() internal view returns (uint) {\\n        uint rate = IBalancerPool(pool()).getRate();\\n\\n        require(rate > 1e18, \\\"Under 1\\\");\\n\\n        return rate;\\n    }\\n\\n    function _assets() internal view returns (IAsset[] memory assets) {\\n        (IERC20[] memory poolTokens,,) = vault.getPoolTokens(poolId);\\n        assets = new IAsset[](poolTokens.length);\\n\\n        for (uint i = 0; i < poolTokens.length; i++) {\\n            assets[i] = IAsset(address(poolTokens[i]));\\n        }\\n    }\\n\\n    function _tokenIndex(IAsset[] memory tokens) internal view returns (uint i) {\\n        for (i; i < tokens.length; i++) {\\n            // assign index of want\\n            if (address(tokens[i]) == address(want)) { break; }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"libraries/Bytes32Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nlibrary Bytes32Utils {\\n    function toString(bytes32 _bytes32) internal pure returns (string memory) {\\n        bytes memory bytesArray = new bytes(64);\\n\\n        for (uint8 i = 0; i < bytesArray.length; i++) {\\n            uint8 _f = uint8(_bytes32[i/2] >> 4);\\n            uint8 _l = uint8(_bytes32[i/2] & 0x0f);\\n\\n            bytesArray[i] = toByte(_f);\\n            bytesArray[++i] = toByte(_l);\\n        }\\n\\n        return string(bytesArray);\\n    }\\n\\n    function toByte(uint8 _uint8) internal pure returns (bytes1) {\\n        if(_uint8 < 10) {\\n            return bytes1(_uint8 + 48);\\n        } else {\\n            return bytes1(_uint8 + 87);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ControllerEllipsisStrat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"./ControllerStratAbs.sol\\\";\\nimport \\\"../interfaces/IEps.sol\\\";\\n\\ncontract ControllerEllipsisStrat is ControllerStratAbs {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IERC20Metadata;\\n\\n    IEpsPool constant public POOL = IEpsPool(0x160CAed03795365F3A589f10C379FfA7d75d4E76);\\n    IERC20 constant public POOL_TOKEN = IERC20(0xaF4dE8E872131AE328Ce21D909C74705d3Aaf452);\\n    IEpsStaker constant public STAKE = IEpsStaker(0xcce949De564fE60e7f96C85e55177F8B9E4CF61b);\\n    IEpsMultiFeeDistribution constant public FEE_DISTRIBUTION = IEpsMultiFeeDistribution(0x4076CC26EFeE47825917D0feC3A79d0bB9a6bB5c);\\n\\n    int128 private immutable TOKEN_INDEX; // want token index in the pool\\n    uint private constant TOKENS_COUNT = 3; // 3Eps pool\\n    uint private constant STAKE_POOL_ID = 1; // 3Eps pool\\n\\n    constructor(\\n        IERC20Metadata _want,\\n        address _controller,\\n        address _exchange,\\n        address _treasury\\n    ) ControllerStratAbs(_want, _controller, _exchange, _treasury) {\\n        uint i = 0;\\n\\n        for (i; i < TOKENS_COUNT; i++) {\\n            if (address(want) == POOL.coins(i)) { break; }\\n        }\\n\\n        TOKEN_INDEX = int128(uint128(i));\\n    }\\n\\n    function identifier() external pure returns (string memory) {\\n        return string(\\\"3eps@Ellipsis#1.0.0\\\");\\n    }\\n\\n    function harvest() public nonReentrant override {\\n        uint _before = wantBalance();\\n\\n        _claimRewards();\\n        _swapRewards();\\n\\n        uint harvested = wantBalance() - _before;\\n\\n        // Charge performance fee for earned want + rewards\\n        _beforeMovement();\\n\\n        // re-deposit\\n        if (!paused()) { _deposit(); }\\n\\n        // Update lastBalance for the next movement\\n        _afterMovement();\\n\\n        emit Harvested(address(want), harvested);\\n    }\\n\\n    function _deposit() internal override {\\n        uint wantBal = wantBalance();\\n\\n        if (wantBal > 0) {\\n            uint[TOKENS_COUNT] memory amounts = _amountToAmountsList(wantBal);\\n\\n            uint expected = _wantToPoolTokenDoubleCheck(wantBal, true);\\n\\n            want.safeApprove(address(POOL), wantBal);\\n            POOL.add_liquidity(amounts, expected);\\n        }\\n\\n        uint poolTokenBal = POOL_TOKEN.balanceOf(address(this));\\n\\n        if (poolTokenBal > 0) {\\n            POOL_TOKEN.safeApprove(address(STAKE), poolTokenBal);\\n            STAKE.deposit(STAKE_POOL_ID, poolTokenBal);\\n        }\\n    }\\n\\n    function _claimRewards() internal override {\\n        uint[] memory pids = new uint[](1);\\n        pids[0] = STAKE_POOL_ID;\\n\\n        STAKE.claim(pids);\\n        FEE_DISTRIBUTION.exit();\\n    }\\n\\n    // amount is the `want` expected to be withdrawn\\n    function _withdraw(uint _amount) internal override returns (uint) {\\n        // To know how much we have to un-stake we use the same method to\\n        // calculate the expected poolToken at deposit\\n        uint poolTokenAmount = _wantToPoolTokenDoubleCheck(_amount, false);\\n        uint wantBal = wantBalance();\\n\\n        _withdrawFromPool(poolTokenAmount);\\n\\n        return wantBalance() - wantBal;\\n    }\\n\\n    function _withdrawAll() internal override returns (uint) {\\n        uint wantBal = wantBalance();\\n\\n        _withdrawFromPool(balanceOfPool());\\n\\n        return wantBalance() - wantBal;\\n    }\\n\\n    function _withdrawFromPool(uint poolTokenAmount) internal {\\n        // Remove staked from gauge\\n        STAKE.withdraw(STAKE_POOL_ID, poolTokenAmount);\\n\\n        // remove_liquidity\\n        uint _balance = POOL_TOKEN.balanceOf(address(this));\\n        uint expected = _poolTokenToWantDoubleCheck(_balance);\\n\\n        require(expected > 0, \\\"remove_liquidity expected = 0\\\");\\n\\n        POOL.remove_liquidity_one_coin(_balance, TOKEN_INDEX,  expected);\\n    }\\n\\n    function _minWantToPoolToken(uint _amount) internal view returns (uint) {\\n        // Based on virtual_price (poolMinVirtualPrice) and poolSlippageRatio\\n        // the expected amount is represented with 18 decimals as POOL_TOKEN\\n        // so we have to add X decimals to the want balance.\\n        // E.g. 1e8 (1BTC) * 1e10 * 99.4 / 100.0 => 0.994e18 poolToken tokens\\n        return _amount * WANT_MISSING_PRECISION * (RATIO_PRECISION - poolSlippageRatio - poolMinVirtualPrice) / RATIO_PRECISION;\\n    }\\n\\n    function _minPoolTokenToWant(uint _amount) internal view returns (uint) {\\n        // Double check for expected value\\n        // In this case we sum the poolMinVirtualPrice and divide by 1e10 because we want to swap poolToken => want\\n        return _amount * (RATIO_PRECISION + poolMinVirtualPrice - poolSlippageRatio) / (RATIO_PRECISION * WANT_MISSING_PRECISION);\\n    }\\n\\n    function _poolTokenToWantDoubleCheck(uint _amount) internal view returns (uint wantAmount) {\\n        // Calculate at least xx% of the expected. The function doesn't\\n        // consider the fee.\\n        wantAmount = (calcWithdrawOneCoin(_amount) * (RATIO_PRECISION - poolSlippageRatio)) / RATIO_PRECISION;\\n\\n        uint minWant = _minPoolTokenToWant(_amount);\\n\\n        if (minWant > wantAmount) { wantAmount = minWant; }\\n    }\\n\\n    function _wantToPoolTokenDoubleCheck(uint _amount, bool _isDeposit) internal view returns (uint poolTokenAmount) {\\n        uint[TOKENS_COUNT] memory amounts = _amountToAmountsList(_amount);\\n        // calc_token_amount doesn't consider fee\\n        poolTokenAmount = POOL.calc_token_amount(amounts, _isDeposit);\\n        // Remove max fee\\n        poolTokenAmount = poolTokenAmount * (RATIO_PRECISION - poolSlippageRatio) / RATIO_PRECISION;\\n\\n        // In case the pool is unbalanced (attack), make a double check for\\n        // the expected amount with minExpected set ratios.\\n        uint wantToPoolToken = _minWantToPoolToken(_amount);\\n\\n        if (wantToPoolToken > poolTokenAmount) { poolTokenAmount = wantToPoolToken; }\\n    }\\n\\n    function calcWithdrawOneCoin(uint _amount) public view returns (uint) {\\n        if (_amount > 0) {\\n            return POOL.calc_withdraw_one_coin(_amount, TOKEN_INDEX);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function balanceOfPool() public view override returns (uint) {\\n        (uint _amount, ) = STAKE.userInfo(STAKE_POOL_ID, address(this));\\n\\n        return _amount;\\n    }\\n\\n    function balanceOfPoolInWant() public view override returns (uint) {\\n        return calcWithdrawOneCoin(balanceOfPool());\\n    }\\n\\n    function _amountToAmountsList(uint _amount) internal view returns (uint[TOKENS_COUNT] memory) {\\n        uint[TOKENS_COUNT] memory amounts; // #  = new uint[](TOKENS_COUNT);\\n        amounts[uint(uint128(TOKEN_INDEX))] = _amount;\\n\\n        return amounts;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IEps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IEpsPool {\\n    function add_liquidity(uint[3] memory amounts, uint min_mint_amount) external;\\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint _min_amount) external;\\n    function coins(uint) external view returns (address);\\n    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);\\n    function calc_token_amount(uint[3] calldata _amounts, bool is_deposit) external view returns (uint);\\n}\\n\\ninterface IEpsLPPool {\\n    function add_liquidity(uint[2] memory amounts, uint min_mint_amount) external payable;\\n    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint _min_amount) external;\\n    function coins(uint) external view returns (address);\\n    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);\\n    function calc_token_amount(uint[2] calldata _amounts, bool is_deposit) external view returns (uint);\\n}\\n\\ninterface IEpsStaker {\\n    function poolInfo(uint256 _pid) external view returns (address, uint256, uint256, uint256, uint256);\\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\\n    function claimableReward(uint256 _pid, address _user) external view returns (uint256);\\n    function deposit(uint256 _pid, uint256 _amount) external;\\n    function withdraw(uint256 _pid, uint256 _amount) external;\\n    function emergencyWithdraw(uint256 _pid) external;\\n    function claim(uint256[] calldata _pids) external;\\n}\\n\\ninterface IEpsMultiFeeDistribution {\\n    function exit() external;\\n}\\n\"\r\n    },\r\n    \"contracts/ControllerEllipsisLPStrat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"./ControllerStratAbs.sol\\\";\\nimport \\\"../interfaces/IEps.sol\\\";\\nimport \\\"../interfaces/IWNative.sol\\\";\\n\\ncontract ControllerEllipsisLPStrat is ControllerStratAbs {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IERC20Metadata;\\n\\n    address public constant WNATIVE = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\\n    address immutable public POOL_TOKEN; // 0x5781041F9Cf18484533F433Cb2Ea9ad42e117B3a BNB\\n    IEpsLPPool immutable public POOL; // 0xc377e2648E5adD3F1CB51a8B77dBEb63Bd52c874 BNB\\n    IEpsStaker constant public STAKE = IEpsStaker(0xcce949De564fE60e7f96C85e55177F8B9E4CF61b);\\n    IEpsMultiFeeDistribution constant public FEE_DISTRIBUTION = IEpsMultiFeeDistribution(0x4076CC26EFeE47825917D0feC3A79d0bB9a6bB5c);\\n\\n    int128 private immutable TOKEN_INDEX; // want token index in the pool\\n    int128 private constant TOKENS_COUNT = 2; // LP pool\\n    uint private immutable STAKE_POOL_ID; // 11 BNB/BNBL (bnbEPS)\\n\\n    constructor(\\n        IERC20Metadata _want,\\n        uint _stakePoolId,\\n        int128 _tokenIndex,\\n        address _poolToken,\\n        address _pool,\\n        address _controller,\\n        address _exchange,\\n        address _treasury\\n    ) ControllerStratAbs(_want, _controller, _exchange, _treasury) {\\n        require(_poolToken != address(0), \\\"poolToken !ZeroAddress\\\");\\n        require(_pool != address(0), \\\"pool !ZeroAddress\\\");\\n        require(_tokenIndex >= 0 && _tokenIndex < TOKENS_COUNT, \\\"tokenIndex out of range\\\");\\n\\n        POOL = IEpsLPPool(_pool);\\n        POOL_TOKEN = _poolToken;\\n        STAKE_POOL_ID = _stakePoolId;\\n        TOKEN_INDEX = _tokenIndex;\\n    }\\n\\n    // Remove liquidity for native token\\n    receive() external payable { }\\n\\n    function identifier() external view returns (string memory) {\\n        return string(abi.encodePacked(\\n            IERC20Metadata(POOL_TOKEN).symbol(), \\\"@Ellipsis#1.0.0\\\"\\n        ));\\n    }\\n\\n    function harvest() public nonReentrant override {\\n        uint _before = wantBalance();\\n\\n        _claimRewards();\\n        _swapRewards();\\n\\n        uint harvested = wantBalance() - _before;\\n\\n        // Charge performance fee for earned want + rewards\\n        _beforeMovement();\\n\\n        // re-deposit\\n        if (!paused()) { _deposit(); }\\n\\n        // Update lastBalance for the next movement\\n        _afterMovement();\\n\\n        emit Harvested(address(want), harvested);\\n    }\\n\\n    function _deposit() internal override {\\n        uint wantBal = wantBalance();\\n\\n        if (wantBal > 0) {\\n            uint[TOKENS_COUNT] memory amounts = _amountToAmountsList(wantBal);\\n\\n            uint expected = _wantToPoolTokenDoubleCheck(wantBal, true);\\n\\n            if (address(want) == WNATIVE) {\\n                IWNative(address(want)).withdraw(wantBal);\\n                POOL.add_liquidity{value: wantBal}(amounts, expected);\\n            } else {\\n                // want.safeApprove(address(POOL), wantBal);\\n                // POOL.add_liquidity(amounts, expected);\\n            }\\n        }\\n\\n        uint poolTokenBal = IERC20(POOL_TOKEN).balanceOf(address(this));\\n\\n        if (poolTokenBal > 0) {\\n            IERC20(POOL_TOKEN).safeApprove(address(STAKE), poolTokenBal);\\n            STAKE.deposit(STAKE_POOL_ID, poolTokenBal);\\n        }\\n    }\\n\\n    function _claimRewards() internal override {\\n        uint[] memory pids = new uint[](1);\\n        pids[0] = STAKE_POOL_ID;\\n\\n        STAKE.claim(pids);\\n        FEE_DISTRIBUTION.exit();\\n    }\\n\\n    // amount is the `want` expected to be withdrawn\\n    function _withdraw(uint _amount) internal override returns (uint) {\\n        // To know how much we have to un-stake we use the same method to\\n        // calculate the expected poolToken at deposit\\n        uint poolTokenAmount = _wantToPoolTokenDoubleCheck(_amount, false);\\n        uint wantBal = wantBalance();\\n\\n        _withdrawFromPool(poolTokenAmount);\\n\\n        return wantBalance() - wantBal;\\n    }\\n\\n    function _withdrawAll() internal override returns (uint) {\\n        uint wantBal = wantBalance();\\n\\n        _withdrawFromPool(balanceOfPool());\\n\\n        return wantBalance() - wantBal;\\n    }\\n\\n    function _withdrawFromPool(uint poolTokenAmount) internal {\\n         // Remove staked from gauge\\n        STAKE.withdraw(STAKE_POOL_ID, poolTokenAmount);\\n\\n        // remove_liquidity\\n        uint _balance = IERC20(POOL_TOKEN).balanceOf(address(this));\\n        uint expected = _poolTokenToWantDoubleCheck(_balance);\\n\\n        require(expected > 0, \\\"remove_liquidity expected = 0\\\");\\n\\n        POOL.remove_liquidity_one_coin(_balance, TOKEN_INDEX,  expected);\\n\\n        if (address(want) == WNATIVE) {\\n            IWNative(address(want)).deposit{value: address(this).balance}();\\n        }\\n     }\\n\\n    function _minWantToPoolToken(uint _amount) internal view returns (uint) {\\n        // Based on virtual_price (poolMinVirtualPrice) and poolSlippageRatio\\n        // the expected amount is represented with 18 decimals as POOL_TOKEN\\n        // so we have to add X decimals to the want balance.\\n        // E.g. 1e8 (1BTC) * 1e10 * 99.4 / 100.0 => 0.994e18 poolToken tokens\\n        return _amount * WANT_MISSING_PRECISION * (RATIO_PRECISION - poolSlippageRatio - poolMinVirtualPrice) / RATIO_PRECISION;\\n    }\\n\\n    function _minPoolTokenToWant(uint _amount) internal view returns (uint) {\\n        // Double check for expected value\\n        // In this case we sum the poolMinVirtualPrice and divide by 1e10 because we want to swap poolToken => want\\n        return _amount * (RATIO_PRECISION + poolMinVirtualPrice - poolSlippageRatio) / (RATIO_PRECISION * WANT_MISSING_PRECISION);\\n    }\\n\\n    function _poolTokenToWantDoubleCheck(uint _amount) internal view returns (uint wantAmount) {\\n        // Calculate at least xx% of the expected. The function doesn't\\n        // consider the fee.\\n        wantAmount = (calcWithdrawOneCoin(_amount) * (RATIO_PRECISION - poolSlippageRatio)) / RATIO_PRECISION;\\n\\n        uint minWant = _minPoolTokenToWant(_amount);\\n\\n        if (minWant > wantAmount) { wantAmount = minWant; }\\n    }\\n\\n    function _wantToPoolTokenDoubleCheck(uint _amount, bool _isDeposit) internal view returns (uint poolTokenAmount) {\\n        uint[TOKENS_COUNT] memory amounts = _amountToAmountsList(_amount);\\n        // calc_token_amount doesn't consider fee\\n        poolTokenAmount = POOL.calc_token_amount(amounts, _isDeposit);\\n        // Remove max fee\\n        poolTokenAmount = poolTokenAmount * (RATIO_PRECISION - poolSlippageRatio) / RATIO_PRECISION;\\n\\n        // In case the pool is unbalanced (attack), make a double check for\\n        // the expected amount with minExpected set ratios.\\n        uint wantToPoolToken = _minWantToPoolToken(_amount);\\n\\n        if (wantToPoolToken > poolTokenAmount) { poolTokenAmount = wantToPoolToken; }\\n    }\\n\\n    function calcWithdrawOneCoin(uint _amount) public view returns (uint) {\\n        if (_amount > 0) {\\n            return POOL.calc_withdraw_one_coin(_amount, TOKEN_INDEX);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function balanceOfPool() public view override returns (uint) {\\n        (uint _amount, ) = STAKE.userInfo(STAKE_POOL_ID, address(this));\\n        return _amount;\\n    }\\n\\n    function balanceOfPoolInWant() public view override returns (uint) {\\n        return calcWithdrawOneCoin(balanceOfPool());\\n    }\\n\\n    function _amountToAmountsList(uint _amount) internal view returns (uint[TOKENS_COUNT] memory) {\\n        uint[TOKENS_COUNT] memory amounts; // #  = new uint[](TOKENS_COUNT);\\n        amounts[uint(uint128(TOKEN_INDEX))] = _amount;\\n\\n        return amounts;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ControllerDummyStrat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"./ControllerStratAbs.sol\\\";\\n\\ncontract ControllerDummyStrat is ControllerStratAbs {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IERC20Metadata;\\n\\n    constructor(\\n        IERC20Metadata _want,\\n        address _controller,\\n        address _exchange,\\n        address _treasury\\n    ) ControllerStratAbs(_want, _controller, _exchange, _treasury) {}\\n\\n    function identifier() external view returns (string memory) {\\n        return string(abi.encodePacked(want.symbol(), \\\"@2pi-dummy#1.0.0\\\"));\\n    }\\n\\n    function harvest() public nonReentrant override {\\n        emit Harvested(address(want), 0);\\n    }\\n\\n    function _deposit() internal override {\\n    }\\n\\n    // amount is the `want` expected to be withdrawn\\n    function _withdraw(uint) internal pure override returns (uint) {\\n        return 0;\\n    }\\n\\n    function _withdrawAll() internal pure override returns (uint) {\\n        return 0;\\n    }\\n\\n    function balanceOfPool() public pure override returns (uint) {\\n        return 0;\\n    }\\n\\n    function balanceOfPoolInWant() public pure override returns (uint) {\\n        return 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IPiToken\",\"name\":\"_piToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"contract IWNative\",\"name\":\"_wNative\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weighing\",\"type\":\"uint256\"}],\"name\":\"NewPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldWeighing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newWeighing\",\"type\":\"uint256\"}],\"name\":\"PoolWeighingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COMMISSION_RATE_PRECISION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_REFERRAL_COMMISSION_RATE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHARE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WNative\",\"outputs\":[{\"internalType\":\"contract IWNative\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"_userShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"_userShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_want\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ctroller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_weighing\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_massUpdate\",\"type\":\"bool\"}],\"name\":\"addNewPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"afterSharesTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"availableDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"availableUserDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"beforeSharesTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_weighing\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_massUpdate\",\"type\":\"bool\"}],\"name\":\"changePoolWeighing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"depositAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"depositNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getPricePerFullShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"paidRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"paidRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingPiToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piToken\",\"outputs\":[{\"internalType\":\"contract IPiToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piTokenPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"want\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weighing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accPiTokenPerShare\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"poolStrategyInfo\",\"outputs\":[{\"internalType\":\"contract IStrategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"stratIdentifier\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemStuckedPiTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralCommissionRate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralMgr\",\"outputs\":[{\"internalType\":\"contract IReferral\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IReferral\",\"name\":\"_newReferral\",\"type\":\"address\"}],\"name\":\"setReferralAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_referralCommissionRate\",\"type\":\"uint16\"}],\"name\":\"setReferralCommissionRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWeighing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userPaidRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Archimedes", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000044eb948756d6c7aa83fb6ae5cfd548dcf50821090000000000000000000000000000000000000000000000000000000001e85f8c0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}