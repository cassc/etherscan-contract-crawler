{"SourceCode": "// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.4.2\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Morra.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract Morra is ReentrancyGuard {\r\n    // 4 Game Phases: Join, Commit, Reveal, Result\r\n    enum GameState {\r\n        JoinPhase,\r\n        CommitPhase,\r\n        RevealPhase,\r\n        ResultPhase\r\n    }\r\n\r\n    struct GamePlayerStruct {\r\n        bool initialized;\r\n        bool commited;\r\n        bool revealed;\r\n        uint8 round;\r\n        uint8 playersCount;\r\n        uint8 commitsCount;\r\n        uint8 revealsCount;\r\n        address creator;\r\n        address gameHash;\r\n        uint256 points;\r\n        uint256 revealDeadline;\r\n        uint256 commitDeadline;\r\n        GameState gameState;\r\n    }\r\n\r\n    struct RoundStruct {\r\n        uint8 commitsCount;\r\n        uint8 revealsCount;\r\n        uint8 total;\r\n        mapping(address => bytes32) commits;\r\n        mapping(address => bool) reveals;\r\n        mapping(address => uint8) totals;\r\n    }\r\n\r\n    // Holds the game data for a single match\r\n    struct GameStruct {\r\n        bool initialized;\r\n        uint8 playersCount;\r\n        uint8 round;\r\n        uint256 revealDeadline;\r\n        uint256 commitDeadline;\r\n        address[] playersArray;\r\n        address creator;\r\n        mapping(address => bool) players;\r\n        mapping(address => bool) withdraw;\r\n        mapping(address => uint256) points;\r\n        mapping(uint8 => RoundStruct) rounds;\r\n        GameState gameState;\r\n    }\r\n\r\n    // Maps Game address => Game data\r\n    mapping(address => GameStruct) public games;\r\n    // Maps Player address to their current 'active' game\r\n    mapping(address => address) public activeGame;\r\n\r\n    uint8 public constant maxPlayers = 20;\r\n    uint256 public constant entryFee = 1 ether;\r\n\r\n    event GameCreate(address indexed gameHash, address indexed creator);\r\n    event GameJoin(address indexed gameHash, address indexed player);\r\n    event GameStart(address indexed gameHash);\r\n    event RoundStart(address indexed gameHash, uint8 indexed round);\r\n    event PlayerCommit(address indexed gameHash, address indexed player, uint8 indexed round, bytes32 commitHash);\r\n    event PlayerReveal(address indexed gameHash, address indexed player, uint8 indexed round, uint8 number, uint8 total, string salt);\r\n    event RoundEnd(address indexed gameHash, uint8 indexed round, uint8 total);\r\n    event CommitEnd(address indexed gameHash, uint8 indexed round);\r\n    event GameEnd(address indexed gameHash);\r\n    event ClaimPrize(address indexed gameHash, address indexed player, uint256 prize);\r\n\r\n    /**\r\n     * @notice Modifier that checks game is initialized, the sender is among players\r\n     * and that the game state to be in the expected phase\r\n     * @param gameHash - the game code\r\n     * @param gameState - the three possible game phases\r\n     */\r\n    modifier validGameState(address gameHash, GameState gameState) {\r\n        // Check that the game exists\r\n        require(\r\n            games[gameHash].initialized == true,\r\n            \"Game code does not exist\"\r\n        );\r\n        // Check player is among players\r\n        require(\r\n            games[gameHash].players[msg.sender],\r\n            \"Player not in this game\"\r\n        );\r\n        // Check that game is in expected state\r\n        require(\r\n            games[gameHash].gameState == gameState,\r\n            \"Game not in correct phase\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new game, generating a game hash and setting the sender as player\r\n     */\r\n    function createGame() public payable returns (address) {\r\n        // check entry fee\r\n        require(msg.value >= entryFee, \"Not enough!\");\r\n\r\n        address gameHash = generateGameHash();\r\n        require(\r\n            !games[gameHash].initialized,\r\n            \"Game code already exists, please try again\"\r\n        );\r\n\r\n        games[gameHash].initialized = true;\r\n        games[gameHash].players[msg.sender] = true;\r\n        games[gameHash].playersArray.push(msg.sender);\r\n        games[gameHash].playersCount = 1;\r\n        games[gameHash].creator = msg.sender;\r\n\r\n        // Set game phase to initial join phase\r\n        games[gameHash].gameState = GameState.JoinPhase;\r\n\r\n        // Set P1 active game to game hash\r\n        activeGame[msg.sender] = gameHash;\r\n\r\n        emit GameCreate(gameHash, msg.sender);\r\n\r\n        // Return the game hash so it can be shared\r\n        return gameHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Function for other players to join a game with the game address\r\n     * @param gameHash - game address shared by game creator\r\n     */\r\n    function joinGame(address gameHash) public payable {\r\n        // check entry fee\r\n        require(msg.value >= entryFee, \"Not enough!\");\r\n        // Check that the game exists\r\n        require(\r\n            games[gameHash].initialized == true,\r\n            \"Game code does not exist\"\r\n        );\r\n        // Check player is not among players\r\n        require(\r\n            !games[gameHash].players[msg.sender],\r\n            \"Player already in this game\"\r\n        );\r\n        // Check that game is in expected state\r\n        require(\r\n            games[gameHash].gameState == GameState.JoinPhase,\r\n            \"Game not in correct phase\"\r\n        );\r\n        // Check max players\r\n        require(\r\n            games[gameHash].playersCount <= maxPlayers,\r\n            \"Game full\"\r\n        );\r\n\r\n        games[gameHash].players[msg.sender] = true;\r\n        games[gameHash].playersArray.push(msg.sender);\r\n        games[gameHash].playersCount++;\r\n\r\n        // Set player active game to game hash\r\n        activeGame[msg.sender] = gameHash;\r\n\r\n        emit GameJoin(gameHash, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to start a game by the creator\r\n     * @param gameHash - game address\r\n     */\r\n    function startGame(address gameHash)\r\n        public\r\n        validGameState(gameHash, GameState.JoinPhase)\r\n    {\r\n        require(games[gameHash].creator == msg.sender, \"Only the creator can start the game\");\r\n\r\n        // Set game phase to commit phase\r\n        games[gameHash].gameState = GameState.CommitPhase;\r\n\r\n        games[gameHash].round = 1;\r\n\r\n        emit GameStart(gameHash);\r\n        emit RoundStart(gameHash, games[gameHash].round);\r\n    }\r\n\r\n    /**\r\n     * @notice Function for players to commit their choice\r\n     * @dev players can commit multiple times to change their choice until the other player commits\r\n     * @param commitHash Commit hash (choice + salt)\r\n     */\r\n    function commit(bytes32 commitHash)\r\n        public\r\n        validGameState(activeGame[msg.sender], GameState.CommitPhase)\r\n    {\r\n        // Get the game hash from active game mapping\r\n        address gameHash = activeGame[msg.sender];\r\n\r\n        uint8 currentRound = games[gameHash].round;\r\n\r\n        if (games[gameHash].rounds[currentRound].commits[msg.sender] == bytes32(0)) {\r\n            games[gameHash].rounds[currentRound].commitsCount++;\r\n        }\r\n\r\n        games[gameHash].rounds[currentRound].commits[msg.sender] = commitHash;\r\n\r\n        emit PlayerCommit(gameHash, msg.sender, currentRound, commitHash);\r\n\r\n        // If all players have committed, set game state to reveal phase\r\n        if (games[gameHash].rounds[currentRound].commitsCount == games[gameHash].playersCount) {\r\n            games[gameHash].gameState = GameState.RevealPhase;\r\n            emit CommitEnd(gameHash, currentRound);\r\n        }\r\n\r\n        if (games[gameHash].rounds[currentRound].commitsCount == 1) {\r\n            // Set deadline for other players to commit\r\n            games[gameHash].commitDeadline = block.timestamp + 3 minutes;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Finish the commit phase after commit timeout\r\n     * @param gameHash gameHash to finish commit phase\r\n     */\r\n    function finishCommitPhaseAfterCommitTimeout(address gameHash)\r\n        public\r\n    {\r\n        // Check that the game exists\r\n        require(\r\n            games[gameHash].initialized == true,\r\n            \"Game code does not exist\"\r\n        );\r\n        // Check that game is in expected state\r\n        require(\r\n            games[gameHash].gameState == GameState.CommitPhase,\r\n            \"Game not in commit phase\"\r\n        );\r\n        // Check that we are after the commit deadline\r\n        require(\r\n            block.timestamp > games[gameHash].commitDeadline,\r\n            \"Commit deadline not reached\"\r\n        );\r\n\r\n        games[gameHash].gameState = GameState.RevealPhase;\r\n        emit CommitEnd(gameHash, games[gameHash].round);\r\n    }\r\n\r\n    /**\r\n     * @notice Function for players to reveal their choice. The first player to reveal sets a deadline for the second player\r\n     * this is prevent players for abandoning the game once they know they have lost based on the revealed hash.\r\n     * At the end of the deadline, anyone can trigger a \"win-by-default\".\r\n     * If all players reveal in time, the last player's reveal will call determineWinner() and advance the game to the result phase\r\n     * @notice Unlike commit, players can only reveal once\r\n     * @param number - the selected number (0 to 5)\r\n     * @param total - the selected total number (0 to number of players * 5)\r\n     * @param salt - a player chosen secret string from the \"commit\" phase used to prove their choice via a hash match\r\n     */\r\n    function reveal(uint8 number, uint8 total, string memory salt)\r\n        public\r\n        validGameState(activeGame[msg.sender], GameState.RevealPhase)\r\n    {\r\n        require(number <= 5, \"Invalid number. Number must be between 0 and 5.\");\r\n\r\n        // Get the game hash from active game mapping\r\n        address gameHash = activeGame[msg.sender];\r\n\r\n        require(total <= 5 * games[gameHash].playersCount, \"Wrong total\");\r\n\r\n        require(!games[gameHash].rounds[games[gameHash].round].reveals[msg.sender], \"Already revealed\");\r\n\r\n        // Verify that one of the choices + salt hashes matches commit hash\r\n        // Compare all three possible choices so they don't have to enter their choice again\r\n        bytes32 verificationHash = keccak256(\r\n            abi.encodePacked(number, total, salt)\r\n        );\r\n\r\n        uint8 currentRound = games[gameHash].round;\r\n\r\n        require(\r\n            verificationHash == games[gameHash].rounds[currentRound].commits[msg.sender],\r\n            \"Verification hash doesn't match commit hash. Salt and/or choice not the same as commit.\"\r\n        );\r\n\r\n        // Save the revealed total\r\n        games[gameHash].rounds[currentRound].totals[msg.sender] = total;\r\n\r\n        games[gameHash].rounds[currentRound].total += number;\r\n\r\n        games[gameHash].rounds[currentRound].reveals[msg.sender] = true;\r\n        games[gameHash].rounds[currentRound].revealsCount++;\r\n\r\n        emit PlayerReveal(gameHash, msg.sender, currentRound, number, total, salt);\r\n\r\n        // if all players revealed, determine winner\r\n        if (games[gameHash].rounds[currentRound].revealsCount == games[gameHash].playersCount) {\r\n            _determineWinners(gameHash);\r\n        }\r\n\r\n        if (games[gameHash].rounds[currentRound].revealsCount == 1) {\r\n            // Set deadline for other players to reveal\r\n            games[gameHash].revealDeadline = block.timestamp + 3 minutes;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Players can this to leave the game at anytime. Usually at the end to reset the UI\r\n     */\r\n    function leaveGame() public {\r\n        activeGame[msg.sender] = address(0);\r\n    }\r\n\r\n    /// @notice Util Functions for generating hashes, computing winners and fetching data\r\n\r\n    function generateGameHash() public view returns (address) {\r\n        bytes32 prevHash = blockhash(block.number - 1);\r\n        // Game hash is a pseudo-randomly generated address from last blockhash + p1\r\n        return\r\n            address(bytes20(keccak256(abi.encodePacked(prevHash, msg.sender))));\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the winners\r\n     * @param gameHash - gameHash to determine winners\r\n     */\r\n    function _determineWinners(address gameHash)\r\n        internal\r\n    {\r\n        RoundStruct storage currentRound = games[gameHash].rounds[games[gameHash].round];\r\n\r\n        emit RoundEnd(gameHash, games[gameHash].round, currentRound.total);\r\n\r\n        bool finish = false;\r\n\r\n        uint8 maxTotal = games[gameHash].playersCount * 5;\r\n\r\n        for (uint i = 0; i < games[gameHash].playersArray.length; i++) {\r\n            address player = games[gameHash].playersArray[i];\r\n            if (currentRound.reveals[player]) {\r\n                int8 diff = int8(currentRound.total) - int8(currentRound.totals[player]);\r\n                if (diff < 0) {\r\n                    diff = -diff;\r\n                }\r\n                uint8 playerPoints = maxTotal - uint8(diff);\r\n                games[gameHash].points[player] += playerPoints;\r\n\r\n                if (games[gameHash].points[player] >= maxTotal * 3) {\r\n                    finish = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (games[gameHash].round == 5) {\r\n            finish = true;\r\n        }\r\n\r\n        if (finish) {\r\n            games[gameHash].gameState = GameState.ResultPhase;\r\n\r\n            emit GameEnd(gameHash);\r\n        } else {\r\n            games[gameHash].round++;\r\n\r\n            emit RoundStart(gameHash, games[gameHash].round);\r\n\r\n            games[gameHash].gameState = GameState.CommitPhase;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the winners after reveal timeout\r\n     * @param gameHash - gameHash to determine winners\r\n     */\r\n    function determineWinnersAfterRevealTimeout(address gameHash)\r\n        public\r\n    {\r\n        // Check that the game exists\r\n        require(\r\n            games[gameHash].initialized == true,\r\n            \"Game code does not exist\"\r\n        );\r\n        // Check that game is in expected state\r\n        require(\r\n            games[gameHash].gameState == GameState.RevealPhase,\r\n            \"Game not in reveal phase\"\r\n        );\r\n        // Check that we are after the reveal deadline\r\n        require(\r\n            block.timestamp > games[gameHash].revealDeadline,\r\n            \"Reveal deadline not reached\"\r\n        );\r\n\r\n        _determineWinners(gameHash);\r\n    }\r\n\r\n    function getPlayersOnGame(address gameHash)\r\n        public\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n                // Check that the game exists\r\n        require(\r\n            games[gameHash].initialized == true,\r\n            \"Game code does not exist\"\r\n        );\r\n\r\n        return games[gameHash].playersArray;\r\n    }\r\n\r\n    /**\r\n     * @notice Fetches the game data of the player's active game\r\n     * @param player - address of player\r\n     */\r\n    function getActiveGameData(address player)\r\n        public\r\n        view\r\n        returns (GamePlayerStruct memory)\r\n    {\r\n        // Get the game hash from active game mapping\r\n        address gameHash = activeGame[player];\r\n\r\n        GamePlayerStruct memory gameData;\r\n\r\n        uint8 currentRoundNumber = games[gameHash].round;\r\n\r\n        gameData.initialized = games[gameHash].initialized;\r\n        gameData.round = currentRoundNumber;\r\n        gameData.gameState = games[gameHash].gameState;\r\n        gameData.playersCount = games[gameHash].playersCount;\r\n        gameData.creator = games[gameHash].creator;\r\n        gameData.commited = games[gameHash].rounds[currentRoundNumber].commits[player] != bytes32(0);\r\n        gameData.revealed = games[gameHash].rounds[currentRoundNumber].reveals[player];\r\n        gameData.commitsCount = games[gameHash].rounds[currentRoundNumber].commitsCount;\r\n        gameData.revealsCount = games[gameHash].rounds[currentRoundNumber].revealsCount;\r\n        gameData.points = games[gameHash].points[player];\r\n        gameData.gameHash = gameHash;\r\n        gameData.revealDeadline = games[gameHash].revealDeadline;\r\n        gameData.commitDeadline = games[gameHash].commitDeadline;\r\n\r\n        return gameData;\r\n    }\r\n\r\n    function claimPrize(address gameHash) external nonReentrant {\r\n        // Check that the game exists\r\n        require(\r\n            games[gameHash].initialized == true,\r\n            \"Game code does not exist\"\r\n        );\r\n        // Check that game is in expected state\r\n        require(\r\n            games[gameHash].gameState == GameState.ResultPhase,\r\n            \"Game not in result phase\"\r\n        );\r\n\r\n        uint256 maxScore = 0;\r\n\r\n        for (uint i = 0; i < games[gameHash].playersArray.length; i++) {\r\n            address player = games[gameHash].playersArray[i];\r\n            if (games[gameHash].points[player] > maxScore) {\r\n                maxScore = games[gameHash].points[player];\r\n            }\r\n        }\r\n\r\n        uint8 playersWithMaxScoreCount = 0;\r\n        bool senderHasMaxScore = false;\r\n\r\n        for (uint i = 0; i < games[gameHash].playersArray.length; i++) {\r\n            address player = games[gameHash].playersArray[i];\r\n            if (games[gameHash].points[player] == maxScore) {\r\n                playersWithMaxScoreCount++;\r\n                if (player == msg.sender) {\r\n                    senderHasMaxScore = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        require(senderHasMaxScore, \"No winner!\");\r\n\r\n        require(!games[gameHash].withdraw[msg.sender], \"Already claimed!\");\r\n\r\n        games[gameHash].withdraw[msg.sender] = true;\r\n\r\n        uint256 prize = entryFee * games[gameHash].playersCount / playersWithMaxScoreCount;\r\n\r\n        (bool success, ) = address(msg.sender).call{ value: prize }(\"\");\r\n        require(success, \"Failed to send prize\");\r\n\r\n        emit ClaimPrize(gameHash, msg.sender, prize);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"ClaimPrize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"CommitEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"GameCreate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"}],\"name\":\"GameEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"GameJoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"}],\"name\":\"GameStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"}],\"name\":\"PlayerCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"number\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"total\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"}],\"name\":\"PlayerReveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"total\",\"type\":\"uint8\"}],\"name\":\"RoundEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"RoundStart\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"activeGame\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"}],\"name\":\"claimPrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commitHash\",\"type\":\"bytes32\"}],\"name\":\"commit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createGame\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"}],\"name\":\"determineWinnersAfterRevealTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"}],\"name\":\"finishCommitPhaseAfterCommitTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"games\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"playersCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"revealDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitDeadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"enum Morra.GameState\",\"name\":\"gameState\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generateGameHash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getActiveGameData\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"commited\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"revealed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"playersCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"commitsCount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"revealsCount\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitDeadline\",\"type\":\"uint256\"},{\"internalType\":\"enum Morra.GameState\",\"name\":\"gameState\",\"type\":\"uint8\"}],\"internalType\":\"struct Morra.GamePlayerStruct\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"}],\"name\":\"getPlayersOnGame\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"}],\"name\":\"joinGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaveGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPlayers\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"number\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"total\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameHash\",\"type\":\"address\"}],\"name\":\"startGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Morra", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://781948d0dc2412be481b9f5b905336f87a74e2a3149a25bb2cb7c2714280ff49"}