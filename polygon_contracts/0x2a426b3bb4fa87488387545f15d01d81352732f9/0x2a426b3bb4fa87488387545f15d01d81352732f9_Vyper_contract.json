{"SourceCode": "# @version 0.3.3\r\n\"\"\"\r\n@title Curve Registry Exchange Contract\r\n@license MIT\r\n@author Curve.Fi\r\n@notice Find pools, query exchange rates and perform swaps\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface AddressProvider:\r\n    def admin() -> address: view\r\n    def get_registry() -> address: view\r\n    def get_address(idx: uint256) -> address: view\r\n\r\ninterface Registry:\r\n    def address_provider() -> address: view\r\n    def get_A(_pool: address) -> uint256: view\r\n    def get_fees(_pool: address) -> uint256[2]: view\r\n    def get_coin_indices(_pool: address, _from: address, _to: address) -> (int128, int128, bool): view\r\n    def get_n_coins(_pool: address) -> uint256[2]: view\r\n    def get_balances(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_underlying_balances(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_rates(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_decimals(_pool: address) -> uint256[MAX_COINS]: view\r\n    def get_underlying_decimals(_pool: address) -> uint256[MAX_COINS]: view\r\n    def find_pool_for_coins(_from: address, _to: address, i: uint256) -> address: view\r\n    def get_lp_token(_pool: address) -> address: view\r\n    def is_meta(_pool: address) -> bool: view\r\n\r\ninterface CryptoRegistry:\r\n    def get_coin_indices(_pool: address, _from: address, _to: address) -> (uint256, uint256): view\r\n\r\ninterface CurvePool:\r\n    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\r\n    def exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\r\n    def get_dy(i: int128, j: int128, amount: uint256) -> uint256: view\r\n    def get_dy_underlying(i: int128, j: int128, amount: uint256) -> uint256: view\r\n    def coins(i: uint256) -> address: view\r\n\r\ninterface CryptoPool:\r\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256): payable\r\n    def exchange_underlying(i: uint256, j: uint256, dx: uint256, min_dy: uint256): payable\r\n    def get_dy(i: uint256, j: uint256, amount: uint256) -> uint256: view\r\n    def get_dy_underlying(i: uint256, j: uint256, amount: uint256) -> uint256: view\r\n\r\ninterface CryptoPoolETH:\r\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool): payable\r\n\r\ninterface LendingBasePoolMetaZap:\r\n    def exchange_underlying(pool: address, i: int128, j: int128, dx: uint256, min_dy: uint256): nonpayable\r\n\r\ninterface CryptoMetaZap:\r\n    def get_dy(pool: address, i: uint256, j: uint256, dx: uint256) -> uint256: view\r\n    def exchange(pool: address, i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool): payable\r\n\r\ninterface BasePool2Coins:\r\n    def add_liquidity(amounts: uint256[2], min_mint_amount: uint256): nonpayable\r\n    def calc_token_amount(amounts: uint256[2], is_deposit: bool) -> uint256: view\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: int128) -> uint256: view\r\n\r\ninterface BasePool3Coins:\r\n    def add_liquidity(amounts: uint256[3], min_mint_amount: uint256): nonpayable\r\n    def calc_token_amount(amounts: uint256[3], is_deposit: bool) -> uint256: view\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: int128) -> uint256: view\r\n\r\ninterface LendingBasePool3Coins:\r\n    def add_liquidity(amounts: uint256[3], min_mint_amount: uint256, use_underlying: bool): nonpayable\r\n    def calc_token_amount(amounts: uint256[3], is_deposit: bool) -> uint256: view\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: int128, min_amount: uint256, use_underlying: bool) -> uint256: nonpayable\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: int128) -> uint256: view\r\n\r\ninterface CryptoBasePool3Coins:\r\n    def add_liquidity(amounts: uint256[3], min_mint_amount: uint256, use_underlying: bool): nonpayable\r\n    def calc_token_amount(amounts: uint256[3], is_deposit: bool) -> uint256: view\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256): nonpayable\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: uint256) -> uint256: view\r\n\r\ninterface BasePool4Coins:\r\n    def add_liquidity(amounts: uint256[4], min_mint_amount: uint256): nonpayable\r\n    def calc_token_amount(amounts: uint256[4], is_deposit: bool) -> uint256: view\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: int128) -> uint256: view\r\n\r\ninterface BasePool5Coins:\r\n    def add_liquidity(amounts: uint256[5], min_mint_amount: uint256): nonpayable\r\n    def calc_token_amount(amounts: uint256[5], is_deposit: bool) -> uint256: view\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: int128) -> uint256: view\r\n\r\ninterface wETH:\r\n    def deposit(): payable\r\n    def withdraw(_amount: uint256): nonpayable\r\n\r\ninterface Calculator:\r\n    def get_dx(n_coins: uint256, balances: uint256[MAX_COINS], amp: uint256, fee: uint256,\r\n               rates: uint256[MAX_COINS], precisions: uint256[MAX_COINS],\r\n               i: int128, j: int128, dx: uint256) -> uint256: view\r\n    def get_dy(n_coins: uint256, balances: uint256[MAX_COINS], amp: uint256, fee: uint256,\r\n               rates: uint256[MAX_COINS], precisions: uint256[MAX_COINS],\r\n               i: int128, j: int128, dx: uint256[CALC_INPUT_SIZE]) -> uint256[CALC_INPUT_SIZE]: view\r\n\r\n\r\nevent TokenExchange:\r\n    buyer: indexed(address)\r\n    receiver: indexed(address)\r\n    pool: indexed(address)\r\n    token_sold: address\r\n    token_bought: address\r\n    amount_sold: uint256\r\n    amount_bought: uint256\r\n\r\nevent ExchangeMultiple:\r\n    buyer: indexed(address)\r\n    receiver: indexed(address)\r\n    route: address[9]\r\n    swap_params: uint256[3][4]\r\n    pools: address[4]\r\n    amount_sold: uint256\r\n    amount_bought: uint256\r\n\r\nETH_ADDRESS: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nWETH_ADDRESS: immutable(address)\r\nMAX_COINS: constant(uint256) = 8\r\nCALC_INPUT_SIZE: constant(uint256) = 100\r\nEMPTY_POOL_LIST: constant(address[8]) = [\r\n    ZERO_ADDRESS,\r\n    ZERO_ADDRESS,\r\n    ZERO_ADDRESS,\r\n    ZERO_ADDRESS,\r\n    ZERO_ADDRESS,\r\n    ZERO_ADDRESS,\r\n    ZERO_ADDRESS,\r\n    ZERO_ADDRESS,\r\n]\r\n\r\n\r\naddress_provider: AddressProvider\r\nregistry: public(address)\r\nfactory_registry: public(address)\r\ncrypto_registry: public(address)\r\n\r\ndefault_calculator: public(address)\r\nis_killed: public(bool)\r\npool_calculator: HashMap[address, address]\r\n\r\nis_approved: HashMap[address, HashMap[address, bool]]\r\nbase_coins: HashMap[address, address[2]]\r\n\r\n\r\n@external\r\ndef __init__(_address_provider: address, _calculator: address, _weth: address):\r\n    \"\"\"\r\n    @notice Constructor function\r\n    \"\"\"\r\n    self.address_provider = AddressProvider(_address_provider)\r\n    self.registry = AddressProvider(_address_provider).get_registry()\r\n    self.factory_registry = AddressProvider(_address_provider).get_address(3)\r\n    self.crypto_registry = AddressProvider(_address_provider).get_address(5)\r\n    self.default_calculator = _calculator\r\n\r\n    WETH_ADDRESS = _weth\r\n\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    pass\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_exchange_amount(\r\n    _registry: address,\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins received in an exchange\r\n    @param _registry Registry address\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_from` to be sent\r\n    @return Quantity of `_to` to be received\r\n    \"\"\"\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    i, j, is_underlying = Registry(_registry).get_coin_indices(_pool, _from, _to) # dev: no market\r\n\r\n    if is_underlying and (_registry == self.registry or Registry(_registry).is_meta(_pool)):\r\n        return CurvePool(_pool).get_dy_underlying(i, j, _amount)\r\n\r\n    return CurvePool(_pool).get_dy(i, j, _amount)\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_crypto_exchange_amount(\r\n    _registry: address,\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins received in an exchange\r\n    @param _registry Registry address\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_from` to be sent\r\n    @return Quantity of `_to` to be received\r\n    \"\"\"\r\n    i: uint256 = 0\r\n    j: uint256 = 0\r\n    i, j = CryptoRegistry(_registry).get_coin_indices(_pool, _from, _to) # dev: no market\r\n\r\n    return CryptoPool(_pool).get_dy(i, j, _amount)\r\n\r\n\r\n@internal\r\ndef _exchange(\r\n    _registry: address,\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _sender: address,\r\n    _receiver: address,\r\n) -> uint256:\r\n\r\n    assert not self.is_killed\r\n\r\n    eth_amount: uint256 = 0\r\n    received_amount: uint256 = 0\r\n\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    i, j, is_underlying = Registry(_registry).get_coin_indices(_pool, _from, _to)  # dev: no market\r\n    if is_underlying and _registry == self.factory_registry:\r\n        if Registry(_registry).is_meta(_pool):\r\n            base_coins: address[2] = self.base_coins[_pool]\r\n            if base_coins[0] == empty(address) and base_coins[1] == empty(address):\r\n                base_coins = [CurvePool(_pool).coins(0), CurvePool(_pool).coins(1)]\r\n                self.base_coins[_pool] = base_coins\r\n\r\n            # we only need to use exchange underlying if the input or output is not in the base coins\r\n            is_underlying = _from not in base_coins or _to not in base_coins\r\n        else:\r\n            # not a metapool so no underlying exchange method\r\n            is_underlying = False\r\n\r\n    # perform / verify input transfer\r\n    if _from == ETH_ADDRESS:\r\n        eth_amount = _amount\r\n    else:\r\n        response: Bytes[32] = raw_call(\r\n            _from,\r\n            _abi_encode(\r\n                _sender,\r\n                self,\r\n                _amount,\r\n                method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    # approve input token\r\n    if _from != ETH_ADDRESS and not self.is_approved[_from][_pool]:\r\n        response: Bytes[32] = raw_call(\r\n            _from,\r\n            _abi_encode(\r\n                _pool,\r\n                MAX_UINT256,\r\n                method_id=method_id(\"approve(address,uint256)\"),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n        self.is_approved[_from][_pool] = True\r\n\r\n    # perform coin exchange\r\n    if is_underlying:\r\n        CurvePool(_pool).exchange_underlying(i, j, _amount, _expected, value=eth_amount)\r\n    else:\r\n        CurvePool(_pool).exchange(i, j, _amount, _expected, value=eth_amount)\r\n\r\n    # perform output transfer\r\n    if _to == ETH_ADDRESS:\r\n        received_amount = self.balance\r\n        raw_call(_receiver, b\"\", value=self.balance)\r\n    else:\r\n        received_amount = ERC20(_to).balanceOf(self)\r\n        response: Bytes[32] = raw_call(\r\n            _to,\r\n            _abi_encode(\r\n                _receiver,\r\n                received_amount,\r\n                method_id=method_id(\"transfer(address,uint256)\"),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    log TokenExchange(_sender, _receiver, _pool, _from, _to, _amount, received_amount)\r\n\r\n    return received_amount\r\n\r\n\r\n@internal\r\ndef _crypto_exchange(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _sender: address,\r\n    _receiver: address,\r\n) -> uint256:\r\n\r\n    assert not self.is_killed\r\n\r\n    initial: address = _from\r\n    target: address = _to\r\n\r\n    if _from == ETH_ADDRESS:\r\n        initial = WETH_ADDRESS\r\n    if _to == ETH_ADDRESS:\r\n        target = WETH_ADDRESS\r\n\r\n    eth_amount: uint256 = 0\r\n    received_amount: uint256 = 0\r\n\r\n    i: uint256 = 0\r\n    j: uint256 = 0\r\n    i, j = CryptoRegistry(self.crypto_registry).get_coin_indices(_pool, initial, target)  # dev: no market\r\n\r\n    # perform / verify input transfer\r\n    if _from == ETH_ADDRESS:\r\n        eth_amount = _amount\r\n    else:\r\n        response: Bytes[32] = raw_call(\r\n            _from,\r\n            _abi_encode(\r\n                _sender,\r\n                self,\r\n                _amount,\r\n                method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    # approve input token\r\n    if not self.is_approved[_from][_pool]:\r\n        response: Bytes[32] = raw_call(\r\n            _from,\r\n            _abi_encode(\r\n                _pool,\r\n                MAX_UINT256,\r\n                method_id=method_id(\"approve(address,uint256)\"),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n        self.is_approved[_from][_pool] = True\r\n\r\n    # perform coin exchange\r\n    if ETH_ADDRESS in [_from, _to]:\r\n        CryptoPoolETH(_pool).exchange(i, j, _amount, _expected, True, value=eth_amount)\r\n    else:\r\n        CryptoPool(_pool).exchange(i, j, _amount, _expected)\r\n\r\n    # perform output transfer\r\n    if _to == ETH_ADDRESS:\r\n        received_amount = self.balance\r\n        raw_call(_receiver, b\"\", value=self.balance)\r\n    else:\r\n        received_amount = ERC20(_to).balanceOf(self)\r\n        response: Bytes[32] = raw_call(\r\n            _to,\r\n            _abi_encode(\r\n                _receiver,\r\n                received_amount,\r\n                method_id=method_id(\"transfer(address,uint256)\"),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    log TokenExchange(_sender, _receiver, _pool, _from, _to, _amount, received_amount)\r\n\r\n    return received_amount\r\n\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef exchange_with_best_rate(\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange using the pool that offers the best rate\r\n    @dev Prior to calling this function, the caller must approve\r\n         this contract to transfer `_amount` coins from `_from`\r\n         Does NOT check rates in factory-deployed pools\r\n    @param _from Address of coin being sent\r\n    @param _to Address of coin being received\r\n    @param _amount Quantity of `_from` being sent\r\n    @param _expected Minimum quantity of `_from` received\r\n           in order for the transaction to succeed\r\n    @param _receiver Address to transfer the received tokens to\r\n    @return uint256 Amount received\r\n    \"\"\"\r\n    if _from == ETH_ADDRESS:\r\n        assert _amount == msg.value, \"Incorrect ETH amount\"\r\n    else:\r\n        assert msg.value == 0, \"Incorrect ETH amount\"\r\n\r\n    registry: address = self.registry\r\n    best_pool: address = ZERO_ADDRESS\r\n    max_dy: uint256 = 0\r\n    for i in range(65536):\r\n        pool: address = Registry(registry).find_pool_for_coins(_from, _to, i)\r\n        if pool == ZERO_ADDRESS:\r\n            break\r\n        dy: uint256 = self._get_exchange_amount(registry, pool, _from, _to, _amount)\r\n        if dy > max_dy:\r\n            best_pool = pool\r\n            max_dy = dy\r\n\r\n    return self._exchange(registry, best_pool, _from, _to, _amount, _expected, msg.sender, _receiver)\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef exchange(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange using a specific pool\r\n    @dev Prior to calling this function, the caller must approve\r\n         this contract to transfer `_amount` coins from `_from`\r\n         Works for both regular and factory-deployed pools\r\n    @param _pool Address of the pool to use for the swap\r\n    @param _from Address of coin being sent\r\n    @param _to Address of coin being received\r\n    @param _amount Quantity of `_from` being sent\r\n    @param _expected Minimum quantity of `_from` received\r\n           in order for the transaction to succeed\r\n    @param _receiver Address to transfer the received tokens to\r\n    @return uint256 Amount received\r\n    \"\"\"\r\n    if _from == ETH_ADDRESS:\r\n        assert _amount == msg.value, \"Incorrect ETH amount\"\r\n    else:\r\n        assert msg.value == 0, \"Incorrect ETH amount\"\r\n\r\n    if Registry(self.crypto_registry).get_lp_token(_pool) != ZERO_ADDRESS:\r\n        return self._crypto_exchange(_pool, _from, _to, _amount, _expected, msg.sender, _receiver)\r\n\r\n    registry: address = self.registry\r\n    if Registry(registry).get_lp_token(_pool) == ZERO_ADDRESS:\r\n        registry = self.factory_registry\r\n    return self._exchange(registry, _pool, _from, _to, _amount, _expected, msg.sender, _receiver)\r\n\r\n\r\n@external\r\n@payable\r\ndef exchange_multiple(\r\n    _route: address[9],\r\n    _swap_params: uint256[3][4],\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _pools: address[4]=[ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS],\r\n    _receiver: address=msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Perform up to four swaps in a single transaction\r\n    @dev Routing and swap params must be determined off-chain. This\r\n         functionality is designed for gas efficiency over ease-of-use.\r\n    @param _route Array of [initial token, pool, token, pool, token, ...]\r\n                  The array is iterated until a pool address of 0x00, then the last\r\n                  given token is transferred to `_receiver`\r\n    @param _swap_params Multidimensional array of [i, j, swap type] where i and j are the correct\r\n                        values for the n'th pool in `_route`. The swap type should be\r\n                        1 for a stableswap `exchange`,\r\n                        2 for stableswap `exchange_underlying`,\r\n                        3 for a cryptoswap `exchange`,\r\n                        4 for a cryptoswap `exchange_underlying`,\r\n                        5 for factory metapools with lending base pool `exchange_underlying`,\r\n                        6 for factory crypto-meta pools underlying exchange (`exchange` method in zap),\r\n                        7-11 for wrapped coin (underlying for lending or fake pool) -> LP token \"exchange\" (actually `add_liquidity`),\r\n                        12-14 for LP token -> wrapped coin (underlying for lending pool) \"exchange\" (actually `remove_liquidity_one_coin`)\r\n                        15 for WETH -> ETH \"exchange\" (actually deposit/withdraw)\r\n    @param _amount The amount of `_route[0]` token being sent.\r\n    @param _expected The minimum amount received after the final swap.\r\n    @param _pools Array of pools for swaps via zap contracts. This parameter is only needed for\r\n                  Polygon meta-factories underlying swaps.\r\n    @param _receiver Address to transfer the final output token to.\r\n    @return Received amount of the final output token\r\n    \"\"\"\r\n    input_token: address = _route[0]\r\n    amount: uint256 = _amount\r\n    output_token: address = ZERO_ADDRESS\r\n\r\n    # validate / transfer initial token\r\n    if input_token == ETH_ADDRESS:\r\n        assert msg.value == amount\r\n    else:\r\n        assert msg.value == 0\r\n        response: Bytes[32] = raw_call(\r\n            input_token,\r\n            _abi_encode(\r\n                msg.sender,\r\n                self,\r\n                amount,\r\n                method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    for i in range(1,5):\r\n        # 4 rounds of iteration to perform up to 4 swaps\r\n        swap: address = _route[i*2-1]\r\n        pool: address = _pools[i-1] # Only for Polygon meta-factories underlying swap (swap_type == 4)\r\n        output_token = _route[i*2]\r\n        params: uint256[3] = _swap_params[i-1]  # i, j, swap type\r\n\r\n        if not self.is_approved[input_token][swap]:\r\n            # approve the pool to transfer the input token\r\n            response: Bytes[32] = raw_call(\r\n                input_token,\r\n                _abi_encode(\r\n                    swap,\r\n                    MAX_UINT256,\r\n                    method_id=method_id(\"approve(address,uint256)\"),\r\n                ),\r\n                max_outsize=32,\r\n            )\r\n            if len(response) != 0:\r\n                assert convert(response, bool)\r\n            self.is_approved[input_token][swap] = True\r\n\r\n        eth_amount: uint256 = 0\r\n        if input_token == ETH_ADDRESS:\r\n            eth_amount = amount\r\n        # perform the swap according to the swap type\r\n        if params[2] == 1:\r\n            CurvePool(swap).exchange(convert(params[0], int128), convert(params[1], int128), amount, 0, value=eth_amount)\r\n        elif params[2] == 2:\r\n            CurvePool(swap).exchange_underlying(convert(params[0], int128), convert(params[1], int128), amount, 0, value=eth_amount)\r\n        elif params[2] == 3:\r\n            if input_token == ETH_ADDRESS or output_token == ETH_ADDRESS:\r\n                CryptoPoolETH(swap).exchange(params[0], params[1], amount, 0, True, value=eth_amount)\r\n            else:\r\n                CryptoPool(swap).exchange(params[0], params[1], amount, 0)\r\n        elif params[2] == 4:\r\n            CryptoPool(swap).exchange_underlying(params[0], params[1], amount, 0, value=eth_amount)\r\n        elif params[2] == 5:\r\n            LendingBasePoolMetaZap(swap).exchange_underlying(pool, convert(params[0], int128), convert(params[1], int128), amount, 0)\r\n        elif params[2] == 6:\r\n            use_eth: bool = input_token == ETH_ADDRESS or output_token == ETH_ADDRESS\r\n            CryptoMetaZap(swap).exchange(pool, params[0], params[1], amount, 0, use_eth)\r\n        elif params[2] == 7:\r\n            _amounts: uint256[2] = [0, 0]\r\n            _amounts[params[0]] = amount\r\n            BasePool2Coins(swap).add_liquidity(_amounts, 0)\r\n        elif params[2] == 8:\r\n            _amounts: uint256[3] = [0, 0, 0]\r\n            _amounts[params[0]] = amount\r\n            BasePool3Coins(swap).add_liquidity(_amounts, 0)\r\n        elif params[2] == 9:\r\n            _amounts: uint256[3] = [0, 0, 0]\r\n            _amounts[params[0]] = amount\r\n            LendingBasePool3Coins(swap).add_liquidity(_amounts, 0, True) # example: aave on Polygon\r\n        elif params[2] == 10:\r\n            _amounts: uint256[4] = [0, 0, 0, 0]\r\n            _amounts[params[0]] = amount\r\n            BasePool4Coins(swap).add_liquidity(_amounts, 0)\r\n        elif params[2] == 11:\r\n            _amounts: uint256[5] = [0, 0, 0, 0, 0]\r\n            _amounts[params[0]] = amount\r\n            BasePool5Coins(swap).add_liquidity(_amounts, 0)\r\n        elif params[2] == 12:\r\n            # The number of coins doesn't matter here\r\n            BasePool3Coins(swap).remove_liquidity_one_coin(amount, convert(params[1], int128), 0)\r\n        elif params[2] == 13:\r\n            # The number of coins doesn't matter here\r\n            LendingBasePool3Coins(swap).remove_liquidity_one_coin(amount, convert(params[1], int128), 0, True) # example: aave on Polygon\r\n        elif params[2] == 14:\r\n            # The number of coins doesn't matter here\r\n            CryptoBasePool3Coins(swap).remove_liquidity_one_coin(amount, params[1], 0) # example: atricrypto3 on Polygon\r\n        elif params[2] == 15:\r\n            if input_token == ETH_ADDRESS:\r\n                wETH(swap).deposit(value=amount)\r\n            elif output_token == ETH_ADDRESS:\r\n                wETH(swap).withdraw(amount)\r\n            else:\r\n                raise \"One of the coins must be ETH for swap type 15\"\r\n        else:\r\n            raise \"Bad swap type\"\r\n\r\n        # update the amount received\r\n        if output_token == ETH_ADDRESS:\r\n            amount = self.balance\r\n        else:\r\n            amount = ERC20(output_token).balanceOf(self)\r\n\r\n        # sanity check, if the routing data is incorrect we will have a 0 balance and that is bad\r\n        assert amount != 0, \"Received nothing\"\r\n\r\n        # check if this was the last swap\r\n        if i == 4 or _route[i*2+1] == ZERO_ADDRESS:\r\n            break\r\n        # if there is another swap, the output token becomes the input for the next round\r\n        input_token = output_token\r\n\r\n    # validate the final amount received\r\n    assert amount >= _expected\r\n\r\n    # transfer the final token to the receiver\r\n    if output_token == ETH_ADDRESS:\r\n        raw_call(_receiver, b\"\", value=amount)\r\n    else:\r\n        response: Bytes[32] = raw_call(\r\n            output_token,\r\n            _abi_encode(\r\n                _receiver,\r\n                amount,\r\n                method_id=method_id(\"transfer(address,uint256)\"),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    log ExchangeMultiple(msg.sender, _receiver, _route, _swap_params, _pools, _amount, amount)\r\n\r\n    return amount\r\n\r\n\r\n@view\r\n@external\r\ndef get_best_rate(\r\n    _from: address, _to: address, _amount: uint256, _exclude_pools: address[8] = EMPTY_POOL_LIST\r\n) -> (address, uint256):\r\n    \"\"\"\r\n    @notice Find the pool offering the best rate for a given swap.\r\n    @dev Checks rates for regular and factory pools\r\n    @param _from Address of coin being sent\r\n    @param _to Address of coin being received\r\n    @param _amount Quantity of `_from` being sent\r\n    @param _exclude_pools A list of up to 8 addresses which shouldn't be returned\r\n    @return Pool address, amount received\r\n    \"\"\"\r\n    best_pool: address = ZERO_ADDRESS\r\n    max_dy: uint256 = 0\r\n\r\n    initial: address = _from\r\n    target: address = _to\r\n    if _from == ETH_ADDRESS:\r\n        initial = WETH_ADDRESS\r\n    if _to == ETH_ADDRESS:\r\n        target = WETH_ADDRESS\r\n\r\n    registry: address = self.crypto_registry\r\n    for i in range(65536):\r\n        pool: address = Registry(registry).find_pool_for_coins(initial, target, i)\r\n        if pool == ZERO_ADDRESS:\r\n            if i == 0:\r\n                # we only check for stableswap pools if we did not find any crypto pools\r\n                break\r\n            return best_pool, max_dy\r\n        elif pool in _exclude_pools:\r\n            continue\r\n        dy: uint256 = self._get_crypto_exchange_amount(registry, pool, initial, target, _amount)\r\n        if dy > max_dy:\r\n            best_pool = pool\r\n            max_dy = dy\r\n\r\n    registry = self.registry\r\n    for i in range(65536):\r\n        pool: address = Registry(registry).find_pool_for_coins(_from, _to, i)\r\n        if pool == ZERO_ADDRESS:\r\n            break\r\n        elif pool in _exclude_pools:\r\n            continue\r\n        dy: uint256 = self._get_exchange_amount(registry, pool, _from, _to, _amount)\r\n        if dy > max_dy:\r\n            best_pool = pool\r\n            max_dy = dy\r\n\r\n    registry = self.factory_registry\r\n    for i in range(65536):\r\n        pool: address = Registry(registry).find_pool_for_coins(_from, _to, i)\r\n        if pool == ZERO_ADDRESS:\r\n            break\r\n        elif pool in _exclude_pools:\r\n            continue\r\n        if ERC20(pool).totalSupply() == 0:\r\n            # ignore pools without TVL as the call to `get_dy` will revert\r\n            continue\r\n        dy: uint256 = self._get_exchange_amount(registry, pool, _from, _to, _amount)\r\n        if dy > max_dy:\r\n            best_pool = pool\r\n            max_dy = dy\r\n\r\n    return best_pool, max_dy\r\n\r\n\r\n@view\r\n@external\r\ndef get_exchange_amount(_pool: address, _from: address, _to: address, _amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins received in an exchange\r\n    @dev Works for both regular and factory-deployed pools\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_from` to be sent\r\n    @return Quantity of `_to` to be received\r\n    \"\"\"\r\n\r\n    registry: address = self.crypto_registry\r\n    if Registry(registry).get_lp_token(_pool) != ZERO_ADDRESS:\r\n        initial: address = _from\r\n        target: address = _to\r\n        if _from == ETH_ADDRESS:\r\n            initial = WETH_ADDRESS\r\n        if _to == ETH_ADDRESS:\r\n            target = WETH_ADDRESS\r\n        return self._get_crypto_exchange_amount(registry, _pool, initial, target, _amount)\r\n\r\n    registry = self.registry\r\n    if Registry(registry).get_lp_token(_pool) == ZERO_ADDRESS:\r\n        registry = self.factory_registry\r\n    return self._get_exchange_amount(registry, _pool, _from, _to, _amount)\r\n\r\n\r\n@view\r\n@external\r\ndef get_input_amount(_pool: address, _from: address, _to: address, _amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number of coins required to receive the given amount in an exchange\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amount Quantity of `_to` to be received\r\n    @return Quantity of `_from` to be sent\r\n    \"\"\"\r\n    registry: address = self.registry\r\n\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    i, j, is_underlying = Registry(registry).get_coin_indices(_pool, _from, _to)\r\n    amp: uint256 = Registry(registry).get_A(_pool)\r\n    fee: uint256 = Registry(registry).get_fees(_pool)[0]\r\n\r\n    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    rates: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    n_coins: uint256 = Registry(registry).get_n_coins(_pool)[convert(is_underlying, uint256)]\r\n    if is_underlying:\r\n        balances = Registry(registry).get_underlying_balances(_pool)\r\n        decimals = Registry(registry).get_underlying_decimals(_pool)\r\n        for x in range(MAX_COINS):\r\n            if x == n_coins:\r\n                break\r\n            rates[x] = 10**18\r\n    else:\r\n        balances = Registry(registry).get_balances(_pool)\r\n        decimals = Registry(registry).get_decimals(_pool)\r\n        rates = Registry(registry).get_rates(_pool)\r\n\r\n    for x in range(MAX_COINS):\r\n        if x == n_coins:\r\n            break\r\n        decimals[x] = 10 ** (18 - decimals[x])\r\n\r\n    calculator: address = self.pool_calculator[_pool]\r\n    if calculator == ZERO_ADDRESS:\r\n        calculator = self.default_calculator\r\n    return Calculator(calculator).get_dx(n_coins, balances, amp, fee, rates, decimals, i, j, _amount)\r\n\r\n\r\n@view\r\n@external\r\ndef get_exchange_amounts(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address,\r\n    _amounts: uint256[CALC_INPUT_SIZE]\r\n) -> uint256[CALC_INPUT_SIZE]:\r\n    \"\"\"\r\n    @notice Get the current number of coins required to receive the given amount in an exchange\r\n    @param _pool Pool address\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param _amounts Quantity of `_to` to be received\r\n    @return Quantity of `_from` to be sent\r\n    \"\"\"\r\n    registry: address = self.registry\r\n\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    is_underlying: bool = False\r\n    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    rates: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n\r\n    amp: uint256 = Registry(registry).get_A(_pool)\r\n    fee: uint256 = Registry(registry).get_fees(_pool)[0]\r\n    i, j, is_underlying = Registry(registry).get_coin_indices(_pool, _from, _to)\r\n    n_coins: uint256 = Registry(registry).get_n_coins(_pool)[convert(is_underlying, uint256)]\r\n\r\n    if is_underlying:\r\n        balances = Registry(registry).get_underlying_balances(_pool)\r\n        decimals = Registry(registry).get_underlying_decimals(_pool)\r\n        for x in range(MAX_COINS):\r\n            if x == n_coins:\r\n                break\r\n            rates[x] = 10**18\r\n    else:\r\n        balances = Registry(registry).get_balances(_pool)\r\n        decimals = Registry(registry).get_decimals(_pool)\r\n        rates = Registry(registry).get_rates(_pool)\r\n\r\n    for x in range(MAX_COINS):\r\n        if x == n_coins:\r\n            break\r\n        decimals[x] = 10 ** (18 - decimals[x])\r\n\r\n    calculator: address = self.pool_calculator[_pool]\r\n    if calculator == ZERO_ADDRESS:\r\n        calculator = self.default_calculator\r\n    return Calculator(calculator).get_dy(n_coins, balances, amp, fee, rates, decimals, i, j, _amounts)\r\n\r\n\r\n@view\r\n@external\r\ndef get_exchange_multiple_amount(\r\n    _route: address[9],\r\n    _swap_params: uint256[3][4],\r\n    _amount: uint256,\r\n    _pools: address[4]=[ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS]\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current number the final output tokens received in an exchange\r\n    @dev Routing and swap params must be determined off-chain. This\r\n         functionality is designed for gas efficiency over ease-of-use.\r\n    @param _route Array of [initial token, pool, token, pool, token, ...]\r\n                  The array is iterated until a pool address of 0x00, then the last\r\n                  given token is transferred to `_receiver`\r\n    @param _swap_params Multidimensional array of [i, j, swap type] where i and j are the correct\r\n                        values for the n'th pool in `_route`. The swap type should be\r\n                        1 for a stableswap `exchange`,\r\n                        2 for stableswap `exchange_underlying`,\r\n                        3 for a cryptoswap `exchange`,\r\n                        4 for a cryptoswap `exchange_underlying`,\r\n                        5 for factory metapools with lending base pool `exchange_underlying`,\r\n                        6 for factory crypto-meta pools underlying exchange (`exchange` method in zap),\r\n                        7-11 for wrapped coin (underlying for lending pool) -> LP token \"exchange\" (actually `add_liquidity`),\r\n                        12-14 for LP token -> wrapped coin (underlying for lending or fake pool) \"exchange\" (actually `remove_liquidity_one_coin`)\r\n                        15 for WETH -> ETH \"exchange\" (actually deposit/withdraw)\r\n    @param _amount The amount of `_route[0]` token to be sent.\r\n    @param _pools Array of pools for swaps via zap contracts. This parameter is only needed for\r\n                  Polygon meta-factories underlying swaps.\r\n    @return Expected amount of the final output token\r\n    \"\"\"\r\n    amount: uint256 = _amount\r\n\r\n    for i in range(1,5):\r\n        # 4 rounds of iteration to perform up to 4 swaps\r\n        swap: address = _route[i*2-1]\r\n        pool: address = _pools[i-1] # Only for Polygon meta-factories underlying swap (swap_type == 4)\r\n        params: uint256[3] = _swap_params[i-1]  # i, j, swap type\r\n\r\n        # Calc output amount according to the swap type\r\n        if params[2] == 1:\r\n            amount = CurvePool(swap).get_dy(convert(params[0], int128), convert(params[1], int128), amount)\r\n        elif params[2] == 2:\r\n            amount = CurvePool(swap).get_dy_underlying(convert(params[0], int128), convert(params[1], int128), amount)\r\n        elif params[2] == 3:\r\n            amount = CryptoPool(swap).get_dy(params[0], params[1], amount)\r\n        elif params[2] == 4:\r\n            amount = CryptoPool(swap).get_dy_underlying(params[0], params[1], amount)\r\n        elif params[2] == 5:\r\n            amount = CurvePool(pool).get_dy_underlying(convert(params[0], int128), convert(params[1], int128), amount)\r\n        elif params[2] == 6:\r\n            amount = CryptoMetaZap(swap).get_dy(pool, params[0], params[1], amount)\r\n        elif params[2] == 7:\r\n            _amounts: uint256[2] = [0, 0]\r\n            _amounts[params[0]] = amount\r\n            amount = BasePool2Coins(swap).calc_token_amount(_amounts, True)\r\n        elif params[2] in [8, 9]:\r\n            _amounts: uint256[3] = [0, 0, 0]\r\n            _amounts[params[0]] = amount\r\n            amount = BasePool3Coins(swap).calc_token_amount(_amounts, True)\r\n        elif params[2] == 10:\r\n            _amounts: uint256[4] = [0, 0, 0, 0]\r\n            _amounts[params[0]] = amount\r\n            amount = BasePool4Coins(swap).calc_token_amount(_amounts, True)\r\n        elif params[2] == 11:\r\n            _amounts: uint256[5] = [0, 0, 0, 0, 0]\r\n            _amounts[params[0]] = amount\r\n            amount = BasePool5Coins(swap).calc_token_amount(_amounts, True)\r\n        elif params[2] in [12, 13]:\r\n            # The number of coins doesn't matter here\r\n            amount = BasePool3Coins(swap).calc_withdraw_one_coin(amount, convert(params[1], int128))\r\n        elif params[2] == 14:\r\n            # The number of coins doesn't matter here\r\n            amount = CryptoBasePool3Coins(swap).calc_withdraw_one_coin(amount, params[1])\r\n        elif params[2] == 15:\r\n            # ETH <--> WETH rate is 1:1\r\n            pass\r\n        else:\r\n            raise \"Bad swap type\"\r\n\r\n        # check if this was the last swap\r\n        if i == 4 or _route[i*2+1] == ZERO_ADDRESS:\r\n            break\r\n\r\n    return amount\r\n\r\n\r\n@view\r\n@external\r\ndef get_calculator(_pool: address) -> address:\r\n    \"\"\"\r\n    @notice Set calculator contract\r\n    @dev Used to calculate `get_dy` for a pool\r\n    @param _pool Pool address\r\n    @return `CurveCalc` address\r\n    \"\"\"\r\n    calculator: address = self.pool_calculator[_pool]\r\n    if calculator == ZERO_ADDRESS:\r\n        return self.default_calculator\r\n    else:\r\n        return calculator\r\n\r\n\r\n@external\r\ndef update_registry_address() -> bool:\r\n    \"\"\"\r\n    @notice Update registry address\r\n    @dev The registry address is kept in storage to reduce gas costs.\r\n         If a new registry is deployed this function should be called\r\n         to update the local address from the address provider.\r\n    @return bool success\r\n    \"\"\"\r\n    address_provider: address = self.address_provider.address\r\n    self.registry = AddressProvider(address_provider).get_registry()\r\n    self.factory_registry = AddressProvider(address_provider).get_address(3)\r\n    self.crypto_registry = AddressProvider(address_provider).get_address(5)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_calculator(_pool: address, _calculator: address) -> bool:\r\n    \"\"\"\r\n    @notice Set calculator contract\r\n    @dev Used to calculate `get_dy` for a pool\r\n    @param _pool Pool address\r\n    @param _calculator `CurveCalc` address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    self.pool_calculator[_pool] = _calculator\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_default_calculator(_calculator: address) -> bool:\r\n    \"\"\"\r\n    @notice Set default calculator contract\r\n    @dev Used to calculate `get_dy` for a pool\r\n    @param _calculator `CurveCalc` address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    self.default_calculator = _calculator\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef claim_balance(_token: address) -> bool:\r\n    \"\"\"\r\n    @notice Transfer an ERC20 or ETH balance held by this contract\r\n    @dev The entire balance is transferred to the owner\r\n    @param _token Token address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n\r\n    if _token == ETH_ADDRESS:\r\n        raw_call(msg.sender, b\"\", value=self.balance)\r\n    else:\r\n        amount: uint256 = ERC20(_token).balanceOf(self)\r\n        response: Bytes[32] = raw_call(\r\n            _token,\r\n            concat(\r\n                method_id(\"transfer(address,uint256)\"),\r\n                convert(msg.sender, bytes32),\r\n                convert(amount, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef set_killed(_is_killed: bool) -> bool:\r\n    \"\"\"\r\n    @notice Kill or unkill the contract\r\n    @param _is_killed Killed status of the contract\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\r\n    self.is_killed = _is_killed\r\n\r\n    return True", "ABI": "[{\"name\":\"TokenExchange\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"pool\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_sold\",\"type\":\"address\",\"indexed\":false},{\"name\":\"token_bought\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ExchangeMultiple\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"route\",\"type\":\"address[9]\",\"indexed\":false},{\"name\":\"swap_params\",\"type\":\"uint256[3][4]\",\"indexed\":false},{\"name\":\"pools\",\"type\":\"address[4]\",\"indexed\":false},{\"name\":\"amount_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_address_provider\",\"type\":\"address\"},{\"name\":\"_calculator\",\"type\":\"address\"},{\"name\":\"_weth\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_with_best_rate\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_with_best_rate\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_multiple\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[9]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[3][4]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_multiple\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[9]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[3][4]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"},{\"name\":\"_pools\",\"type\":\"address[4]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_multiple\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[9]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[3][4]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"},{\"name\":\"_pools\",\"type\":\"address[4]\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_best_rate\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_best_rate\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_exclude_pools\",\"type\":\"address[8]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_exchange_amount\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_input_amount\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_exchange_amounts\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[100]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[100]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_exchange_multiple_amount\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[9]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[3][4]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_exchange_multiple_amount\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[9]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[3][4]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_pools\",\"type\":\"address[4]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_calculator\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_registry_address\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_calculator\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_calculator\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_default_calculator\",\"inputs\":[{\"name\":\"_calculator\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_balance\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_killed\",\"inputs\":[{\"name\":\"_is_killed\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"registry\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"factory_registry\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"crypto_registry\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"default_calculator\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.3", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000000000000022d53366457f9d5e68ec105046fc438300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}