{"SourceCode": "/**\r\n *  SourceUnit: contracts/Vesting.sol\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IStake {\r\n    // Info of each user in pool\r\n    struct UserInfo {\r\n        uint256 endTime; // timestamp when tokens can be released\r\n        uint256 totalAmount; // total reward to be withdrawn\r\n    }\r\n\r\n    // Info about staking pool\r\n    struct PoolInfo {\r\n        uint256 minStake; // minimum stake per user\r\n        uint256 maxStake; // maximum stake per user\r\n        uint256 startTime; // start of stake start window\r\n        uint256 endTime; // end of stake start windows\r\n        uint256 rewardPermill; // permill of reward (1permill of 1000 = 1, 20 will be 2%)\r\n        uint256 lockPeriod; // required stake length\r\n        uint256 maxTotalStaked; // maximum total tokens stoked on this\r\n        uint256 totalStaked; // total tokens already staked\r\n        bytes32 poolHash; // unique pool id needed to keep track of user deposits\r\n    }\r\n\r\n    function getPools() external view returns (PoolInfo[] memory);\r\n\r\n    function getPoolCount() external view returns (uint256);\r\n\r\n    function poolInfo(uint256 poolId) external view returns (PoolInfo memory);\r\n\r\n    function addStakePool(\r\n        uint256 minStake,\r\n        uint256 maxStake,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        uint256 rewardPermill,\r\n        uint256 lockPeriod,\r\n        uint256 maxTotalStaked\r\n    ) external;\r\n\r\n    /// Claim all possible tokens\r\n    function claim() external;\r\n\r\n    /// Claim tokens only from given user stake\r\n    function claimStake(uint256 index) external;\r\n\r\n    /// Address of Vesting contract for claim2stake\r\n    function vestingAddress() external view returns (address);\r\n\r\n    /// Address of ERC20 token used for staking\r\n    function tokenAddress() external view returns (address);\r\n\r\n    /**\r\n        Total user staked tokens and rewards\r\n     */\r\n    function totalStakedTokens() external view returns (uint256);\r\n\r\n    /**\r\n        Free reward tokens available for staking\r\n     */\r\n    function rewardsAvailable() external view returns (uint256);\r\n\r\n    /**\r\n        Stake tokens directly from Vesting contract.\r\n        Can be call only from Vesting contract.\r\n        Can fail, if stake requirements are not met.\r\n        @param user address of user that is calling claim2stake in Vesting\r\n        @param poolIndex chosen pool index to stake\r\n        @param amount of tokens claimed to stake\r\n     */\r\n    function claim2stake(\r\n        address user,\r\n        uint256 poolIndex,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n        Deposit tokens to given pool.\r\n        @param poolId index of staking pool to deposit\r\n        @param amount of tokens to be staked\r\n     */\r\n    function deposit(uint256 poolId, uint256 amount) external;\r\n\r\n    /// Event emited on successful deposit.\r\n    event Deposit(\r\n        address indexed user,\r\n        uint256 indexed pid,\r\n        uint256 amount,\r\n        uint256 timeout\r\n    );\r\n\r\n    /// Event emited on successful claim\r\n    event Withdraw(address indexed user, uint256 amount);\r\n}\r\n\r\n/**\r\n *  SourceUnit: contracts/Vesting.sol\r\n */\r\n\r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IVesting {\r\n    struct Vest {\r\n        uint256 startDate;\r\n        uint256 endDate;\r\n        uint256 startTokens;\r\n        uint256 totalTokens;\r\n        uint256 claimed;\r\n    }\r\n\r\n    /**\r\n        Get all coins that can be claimed from contract\r\n        @param user address of user to check\r\n        @return sum number of tokens to be claimed\r\n     */\r\n    function claimable(address user) external view returns (uint256 sum);\r\n\r\n    /// Event emited on claim\r\n    event Claimed(address indexed user, uint256 amount);\r\n\r\n    /**\r\n        Claim tokens by msg.sender\r\n        Emits Claimed event\r\n     */\r\n    function claim() external;\r\n\r\n    /// Event emited on creating new vest\r\n    event VestAdded(\r\n        address indexed user,\r\n        uint256 startDate,\r\n        uint256 endDate,\r\n        uint256 startTokens,\r\n        uint256 totalTokens\r\n    );\r\n\r\n    /**\r\n        Create vesting for user\r\n        Function restricted\r\n        Emits VestAdded event\r\n        @param user address of user\r\n        @param startDate strat timestamp of vesting (can not be in past)\r\n        @param endDate end timestamp of vesting (must be higher than startDate)\r\n        @param startTokens number of tokens to be released on start date (can be zero)\r\n        @param totalTokens total number of tokens to be released on end date (must be greater than startTokens)\r\n     */\r\n    function createVest(\r\n        address user,\r\n        uint256 startDate,\r\n        uint256 endDate,\r\n        uint256 startTokens,\r\n        uint256 totalTokens\r\n    ) external;\r\n\r\n    /// Mass create vestings\r\n    function massCreateVest(\r\n        address[] calldata user,\r\n        uint256[] calldata startDate,\r\n        uint256[] calldata endDate,\r\n        uint256[] calldata startTokens,\r\n        uint256[] calldata totalTokens\r\n    ) external;\r\n\r\n    /**\r\n        Get all vestings for given user.\r\n        Will return empty array if no vests configured.\r\n        @param user address to list\r\n        @return array of vests\r\n     */\r\n    function getVestings(address user) external view returns (Vest[] memory);\r\n\r\n    /**\r\n        Get one vesting for given user\r\n        Will throw if user have no vestings configured\r\n        @param user address to check\r\n        @param index number of vesting to show\r\n        @return single vest struct\r\n     */\r\n    function getVesting(address user, uint256 index)\r\n        external\r\n        view\r\n        returns (Vest memory);\r\n}\r\n\r\n/**\r\n *  SourceUnit: contracts/Vesting.sol\r\n */\r\n\r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n    Modified ERC173 Ownership contract\r\n */\r\nabstract contract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    address internal constant ZERO_ADDRESS = address(0x0);\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(ZERO_ADDRESS, msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only for Owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(newOwner != ZERO_ADDRESS, \"newOwner not set\");\r\n        require(msg.sender == newOwner, \"Only newOwner\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        newOwner = ZERO_ADDRESS;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function renounceOwnership() external onlyOwner {\r\n        emit OwnershipTransferred(owner, ZERO_ADDRESS);\r\n        owner = ZERO_ADDRESS;\r\n    }\r\n}\r\n\r\n/**\r\n *  SourceUnit: contracts/Vesting.sol\r\n */\r\n\r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * ////IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/**\r\n *  SourceUnit: contracts/Vesting.sol\r\n */\r\n\r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\n\r\npragma solidity ^0.8.10;\r\n\r\n////import \"./IERC20.sol\";\r\n////import \"./Ownable.sol\";\r\n////import \"./IVesting.sol\";\r\n////import \"./IStake.sol\";\r\n\r\ncontract Vesting is Ownable, IVesting {\r\n    mapping(address => Vest[]) private _vestings;\r\n\r\n    /// Amount of tokens inside vesting contract\r\n    uint256 public vested;\r\n    /// Address of ERC20 token contract\r\n    address public immutable tokenAddress;\r\n\r\n    /**\r\n        Contract constructor\r\n        @param token address of ERC20 token to be vested\r\n     */\r\n    constructor(address token) {\r\n        tokenAddress = token;\r\n        name = concat(\"vested \", IERC20(token).name());\r\n        symbol = concat(\"v\", IERC20(token).symbol());\r\n    }\r\n\r\n    /**\r\n        Concat two strings\r\n        @param a first string\r\n        @param b second string\r\n        @return concatenated strings\r\n     */\r\n    function concat(string memory a, string memory b)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return string(abi.encodePacked(a, b));\r\n    }\r\n\r\n    // Internal add vesting function\r\n    function _addVesting(\r\n        address user,\r\n        uint256 startDate,\r\n        uint256 endDate,\r\n        uint256 startTokens,\r\n        uint256 totalTokens\r\n    ) internal {\r\n        require(user != ZERO_ADDRESS, \"Address 0x0 is prohibited\");\r\n        require(user.code.length == 0, \"Contracts are prohibited\");\r\n        require(startDate > block.timestamp, \"Start date in past\");\r\n        require(endDate >= startDate, \"Date setup mismatch\");\r\n        require(totalTokens > startTokens, \"Token number mismatch\");\r\n        _vestings[user].push(\r\n            Vest(startDate, endDate, startTokens, totalTokens, 0)\r\n        );\r\n        emit VestAdded(user, startDate, endDate, startTokens, totalTokens);\r\n        vested += totalTokens;\r\n    }\r\n\r\n    /**\r\n        Create single Vesting in contract\r\n        @param user address of the user\r\n        @param startDate timestamp on which user can start claiming\r\n        @param endDate timestamp on which all tokens are freed\r\n        @param startTokens amount of tokens on cliff startDate\r\n        @param totalTokens total amount of tokens in this vesting\r\n     */\r\n    function createVest(\r\n        address user,\r\n        uint256 startDate,\r\n        uint256 endDate,\r\n        uint256 startTokens,\r\n        uint256 totalTokens\r\n    ) external onlyOwner {\r\n        _addVesting(user, startDate, endDate, startTokens, totalTokens);\r\n        require(\r\n            IERC20(tokenAddress).transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                totalTokens\r\n            ),\r\n            \"\" // this will revert in token if no allowance or balance\r\n        );\r\n    }\r\n\r\n    /**\r\n        Create many vestings in one call\r\n        @param user array of user addresses\r\n        @param startDate array of start timestamps\r\n        @param endDate array of end timestamps\r\n        @param startTokens array of tokens on cliff\r\n        @param totalTokens array of total tokens vested\r\n     */\r\n    function massCreateVest(\r\n        address[] calldata user,\r\n        uint256[] calldata startDate,\r\n        uint256[] calldata endDate,\r\n        uint256[] calldata startTokens,\r\n        uint256[] calldata totalTokens\r\n    ) external onlyOwner {\r\n        uint256 len = user.length;\r\n        require(\r\n            len == startTokens.length &&\r\n                len == endDate.length &&\r\n                len == startTokens.length &&\r\n                len == totalTokens.length,\r\n            \"Data size mismatch\"\r\n        );\r\n        uint256 total;\r\n        uint256 i;\r\n        for (i; i < len; i++) {\r\n            uint256 tokens = totalTokens[i];\r\n            total += tokens;\r\n            _addVesting(\r\n                user[i],\r\n                startDate[i],\r\n                endDate[i],\r\n                startTokens[i],\r\n                tokens\r\n            );\r\n        }\r\n        require(\r\n            IERC20(tokenAddress).transferFrom(msg.sender, address(this), total),\r\n            \"\" // this will revert in token if no allowance or balance\r\n        );\r\n    }\r\n\r\n    /**\r\n        Get all vestings for given user\r\n        @param user address to check\r\n        @return array of Vest struct\r\n     */\r\n    function getVestings(address user) external view returns (Vest[] memory) {\r\n        return _vestings[user];\r\n    }\r\n\r\n    /**\r\n        Read number of vests created for given user\r\n        @param user address to check\r\n        @return number of vestings\r\n     */\r\n    function getVestingCount(address user) external view returns (uint256) {\r\n        return _vestings[user].length;\r\n    }\r\n\r\n    /**\r\n        Get singe vesting parameters for given user\r\n        @param user address to check\r\n        @param index index of vesting to read\r\n        @return single Vest struct\r\n     */\r\n    function getVesting(address user, uint256 index)\r\n        external\r\n        view\r\n        returns (Vest memory)\r\n    {\r\n        require(index < _vestings[user].length, \"Index out out bounds\");\r\n        return _vestings[user][index];\r\n    }\r\n\r\n    /**\r\n        How much tokens can be claimed now by given user\r\n        @param user address to check\r\n        @return sum of tokens available to claim\r\n     */\r\n    function claimable(address user) external view returns (uint256 sum) {\r\n        uint256 len = _vestings[user].length;\r\n        uint256 time = block.timestamp;\r\n        if (len > 0) {\r\n            uint256 i;\r\n            for (i; i < len; i++) {\r\n                sum += _claimable(_vestings[user][i], time);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        Count number of tokens claimable from vesting at given time\r\n        @param c Vesting struct data\r\n        @param time timestamp to calculate\r\n        @return amt number of tokens possible to claim\r\n     */\r\n    function _claimable(Vest memory c, uint256 time)\r\n        internal\r\n        pure\r\n        returns (uint256 amt)\r\n    {\r\n        if (time > c.startDate) {\r\n            if (time > c.endDate) {\r\n                // all coins can be released\r\n                amt = c.totalTokens;\r\n            } else {\r\n                // we need calculate how much can be released\r\n                uint256 pct = ((time - c.startDate) * 1 gwei) /\r\n                    (c.endDate - c.startDate);\r\n                amt =\r\n                    c.startTokens +\r\n                    ((c.totalTokens - c.startTokens) * pct) /\r\n                    1 gwei;\r\n            }\r\n            amt -= c.claimed; // some may be already claimed\r\n        }\r\n    }\r\n\r\n    /**\r\n        Claim all possible vested tokens by caller\r\n     */\r\n    function claim() external {\r\n        uint256 sum = _claim(msg.sender, block.timestamp);\r\n        require(\r\n            IERC20(tokenAddress).transfer(msg.sender, sum),\r\n            \"\" // will fail in token on transfer error\r\n        );\r\n    }\r\n\r\n    /**\r\n        Claim tokens for someone (pay network fees)\r\n        @param user address of vested user to claim\r\n     */\r\n    function claimFor(address user) external {\r\n        uint256 sum = _claim(user, block.timestamp);\r\n        require(\r\n            IERC20(tokenAddress).transfer(user, sum),\r\n            \"\" // will fail in token on transfer error\r\n        );\r\n    }\r\n\r\n    /**\r\n        Claim one of vestings for given user.\r\n        Can be handy if many vestings per account.\r\n        @param user address to claim\r\n        @param index index of vesting to be claimed\r\n     */\r\n    function claimOneFor(address user, uint256 index) external {\r\n        require(index < _vestings[user].length, \"Index out of bounds\");\r\n        Vest storage c = _vestings[user][index];\r\n        uint256 amt = _claimable(c, block.timestamp);\r\n        require(amt > 0, \"Nothing to claim\");\r\n        c.claimed += amt;\r\n        vested -= amt;\r\n        require(\r\n            IERC20(tokenAddress).transfer(user, amt),\r\n            \"\" // will fail in token on transfer error\r\n        );\r\n        emit Claimed(user, amt);\r\n    }\r\n\r\n    /**\r\n        Internal claim function\r\n        @param user address to calculate\r\n        @return sum number of tokens claimed\r\n     */\r\n    function _claim(address user, uint256 time) internal returns (uint256 sum) {\r\n        uint256 len = _vestings[user].length;\r\n        require(len > 0, \"No locks for user\");\r\n\r\n        uint256 i;\r\n        for (i; i < len; i++) {\r\n            Vest storage c = _vestings[user][i];\r\n            uint256 amt = _claimable(c, time);\r\n            c.claimed += amt;\r\n            sum += amt;\r\n        }\r\n\r\n        require(sum > 0, \"Nothing to claim\");\r\n        vested -= sum;\r\n        emit Claimed(user, sum);\r\n    }\r\n\r\n    //\r\n    // Stake/Claim2stake\r\n    //\r\n    /// Address of stake contract\r\n    address public stakeAddress;\r\n\r\n    /**\r\n        Set address of stake contract (once, only owner)\r\n        @param stake contract address\r\n     */\r\n    function setStakeAddress(address stake) external onlyOwner {\r\n        require(stakeAddress == ZERO_ADDRESS, \"Contract already set\");\r\n        stakeAddress = stake;\r\n        require(\r\n            IStake(stake).vestingAddress() == address(this),\r\n            \"Wrong contract address\"\r\n        );\r\n        require(\r\n            IERC20(tokenAddress).approve(stake, type(uint256).max),\r\n            \"Token approval failed\"\r\n        );\r\n    }\r\n\r\n    /**\r\n        Claim possible tokens and stake directly to stake pool\r\n     */\r\n    function claim2stake(uint256 index) external {\r\n        require(stakeAddress != ZERO_ADDRESS, \"Stake contract not set\");\r\n        uint256 sum = _claim(msg.sender, block.timestamp);\r\n        require(\r\n            IStake(stakeAddress).claim2stake(msg.sender, index, sum),\r\n            \"Claim2stake call failed\"\r\n        );\r\n    }\r\n\r\n    //\r\n    // ETH/ERC20 recovery\r\n    //\r\n    string internal constant ERR_NTR = \"Nothing to recover\";\r\n\r\n    /**\r\n        Recover accidentally send ETH or ERC20 tokens\r\n        @param token address of ERC20 token contract, 0x0 if ETH recovery\r\n        @param amount amount of coins/tokens to recover, 0=all\r\n     */\r\n    function recover(address token, uint256 amount) external onlyOwner {\r\n        if (token == ZERO_ADDRESS) {\r\n            uint256 balance = address(this).balance;\r\n            require(balance > 0, ERR_NTR);\r\n            if (amount > 0 && amount < balance) balance = amount;\r\n            payable(owner).transfer(balance);\r\n        } else {\r\n            uint256 balance = IERC20(token).balanceOf(address(this));\r\n            require(balance > 0, ERR_NTR);\r\n            if (token == tokenAddress) {\r\n                balance -= vested; // vested tokens can not be removed\r\n            }\r\n            if (amount > 0 && amount < balance) balance = amount;\r\n\r\n            require(IERC20(token).transfer(owner, balance), \"\");\r\n        }\r\n    }\r\n\r\n    //\r\n    // Imitate ERC20 token, show unclaimed tokens\r\n    //\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;\r\n\r\n    /**\r\n        Read total unclaimed balance for given user\r\n        @param user address to check\r\n        @return amount of unclaimed tokens locked in contract\r\n     */\r\n    function balanceOf(address user) external view returns (uint256 amount) {\r\n        uint256 len = _vestings[user].length;\r\n        if (len > 0) {\r\n            uint256 i;\r\n            for (i; i < len; i++) {\r\n                Vest memory v = _vestings[user][i];\r\n                amount += (v.totalTokens - v.claimed);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        Imitation of ERC20 transfer() function to claim from wallet.\r\n        Ignoring parameters, returns true if claim succeed.\r\n     */\r\n    function transfer(address, uint256) external returns (bool) {\r\n        uint256 sum = _claim(msg.sender, block.timestamp);\r\n        require(\r\n            IERC20(tokenAddress).transfer(msg.sender, sum),\r\n            \"\" // will throw in token contract on transfer fail\r\n        );\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"}],\"name\":\"VestAdded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"claim2stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"claimOneFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"}],\"name\":\"createVest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getVesting\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"internalType\":\"struct IVesting.Vest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getVestingCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getVestings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"internalType\":\"struct IVesting.Vest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"startDate\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"endDate\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"startTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"totalTokens\",\"type\":\"uint256[]\"}],\"name\":\"massCreateVest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stake\",\"type\":\"address\"}],\"name\":\"setStakeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Vesting", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000cebdc775e9f18156ec2e04fb4150f1bc54de690f", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://daa3fcd97be568757d9334ab1330c40b852cde2e573c865da9ce4007163d712f"}