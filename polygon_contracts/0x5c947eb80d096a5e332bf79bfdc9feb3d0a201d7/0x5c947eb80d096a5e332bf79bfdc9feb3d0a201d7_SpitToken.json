{"SourceCode": "{\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address =\\u003e uint256) public balanceOf;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address =\\u003e uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline \\u003e= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner\\u0027s nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user\\u0027s balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"},\"FXBaseChildTunnel.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// IFxMessageProcessor represents interface to process message\\ninterface IFxMessageProcessor {\\n    function processMessageFromRoot(\\n        uint256 stateId,\\n        address rootMessageSender,\\n        bytes calldata data\\n    ) external;\\n}\\n\\n/**\\n * @notice Mock child tunnel contract to receive and send message from L2\\n */\\nabstract contract FxBaseChildTunnel is IFxMessageProcessor {\\n    // MessageTunnel on L1 will get data from this event\\n    event MessageSent(bytes message);\\n\\n    // fx child\\n    address public fxChild;\\n\\n    // fx root tunnel\\n    address public fxRootTunnel;\\n\\n    constructor(address _fxChild) {\\n        fxChild = _fxChild;\\n    }\\n\\n    // Sender must be fxRootTunnel in case of ERC20 tunnel\\n    modifier validateSender(address sender) {\\n        require(sender == fxRootTunnel, \\\"FxBaseChildTunnel: INVALID_SENDER_FROM_ROOT\\\");\\n        _;\\n    }\\n\\n    // set fxRootTunnel if not set already\\n    function setFxRootTunnel(address _fxRootTunnel) external {\\n        require(fxRootTunnel == address(0x0), \\\"FxBaseChildTunnel: ROOT_TUNNEL_ALREADY_SET\\\");\\n        fxRootTunnel = _fxRootTunnel;\\n    }\\n\\n    function processMessageFromRoot(\\n        uint256 stateId,\\n        address rootMessageSender,\\n        bytes calldata data\\n    ) external override {\\n        require(msg.sender == fxChild, \\\"FxBaseChildTunnel: INVALID_SENDER\\\");\\n        _processMessageFromRoot(stateId, rootMessageSender, data);\\n    }\\n\\n    /**\\n     * @notice Emit message that can be received on Root Tunnel\\n     * @dev Call the internal function when need to emit message\\n     * @param message bytes message that will be sent to Root Tunnel\\n     * some message examples -\\n     *   abi.encode(tokenId);\\n     *   abi.encode(tokenId, tokenMetadata);\\n     *   abi.encode(messageType, messageData);\\n     */\\n    function _sendMessageToRoot(bytes memory message) internal {\\n        emit MessageSent(message);\\n    }\\n\\n    /**\\n     * @notice Process message received from Root Tunnel\\n     * @dev function needs to be implemented to handle message as per requirement\\n     * This is called by onStateReceive function.\\n     * Since it is called via a system call, any event will not be emitted during its execution.\\n     * @param stateId unique state id\\n     * @param sender root message sender\\n     * @param message bytes message that was sent from Root Tunnel\\n     */\\n    function _processMessageFromRoot(\\n        uint256 stateId,\\n        address sender,\\n        bytes memory message\\n    ) internal virtual;\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nerror NotOwner();\\n\\n// https://github.com/m1guelpf/erc721-drop/blob/main/src/LilOwnable.sol\\nabstract contract Ownable {\\n    address internal _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender);\\n        _;\\n    }\\n\\n    constructor() {\\n        _owner = msg.sender;\\n    }\\n\\n    function owner() external view returns (address) {\\n        return _owner;\\n    }\\n\\n    function transferOwnership(address _newOwner) external {\\n        if (msg.sender != _owner) revert NotOwner();\\n\\n        _owner = _newOwner;\\n    }\\n\\n    function renounceOwnership() public {\\n        if (msg.sender != _owner) revert NotOwner();\\n\\n        _owner = address(0);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        virtual\\n        returns (bool)\\n    {\\n        return interfaceId == 0x7f5828d0; // ERC165 Interface ID for ERC173\\n    }\\n}\\n\"},\"SpitToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./FXBaseChildTunnel.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n   __ _                                               \\n  / /| | __ _ _ __ ___   __ _/\\\\   /\\\\___ _ __ ___  ___ \\n / / | |/ _` | \\u0027_ ` _ \\\\ / _` \\\\ \\\\ / / _ \\\\ \\u0027__/ __|/ _ \\\\\\n/ /__| | (_| | | | | | | (_| |\\\\ V /  __/ |  \\\\__ \\\\  __/\\n\\\\____/_|\\\\__,_|_| |_| |_|\\\\__,_| \\\\_/ \\\\___|_|  |___/\\\\___|\\n\\n**/\\n\\n/// @title $SPIT Token\\n/// @author delta devs (https://twitter.com/deltadevelopers)\\n\\nenum TokenType {\\n    StaticLlama,\\n    AnimatedLlama,\\n    SilverBoost,\\n    GoldBoost,\\n    PixletCanvas,\\n    LlamaDraws\\n}\\n\\ncontract SpitToken is ERC20, FxBaseChildTunnel, Ownable {\\n    /*///////////////////////////////////////////////////////////////\\n                            STORAGE\\n    /////////////////////////////////////////////////////////////*/\\n\\n    struct Rewards {\\n        uint256 staticLlama;\\n        uint256 animatedLlama;\\n        uint256 silverEnergy;\\n        uint256 goldEnergy;\\n        uint256 pixletCanvas;\\n        uint256 llamaDraws;\\n    }\\n\\n    /// @notice The current reward rates per token type.\\n    Rewards public rewards;\\n\\n    /// @notice Keeps track of the staking balances (how much is being staked) of each token type for all holders.\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public balances;\\n\\n    /// @notice Keeps track of the timestamp of when a holder last withdrew their rewards.\\n    mapping(address =\\u003e uint256) public lastUpdated;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _fxChild)\\n        FxBaseChildTunnel(_fxChild)\\n        ERC20(\\\"Spit Token\\\", \\\"SPIT\\\", 18)\\n    {\\n        rewards.staticLlama = (uint256(10) * 1e18) / 1 days;\\n        rewards.animatedLlama = (uint256(30) * 1e18) / 1 days;\\n        rewards.silverEnergy = (uint256(4) * 1e18) / 1 days;\\n        rewards.goldEnergy = (uint256(12) * 1e18) / 1 days;\\n        rewards.llamaDraws = (uint256(1) * 1e18) / 1 days;\\n        rewards.pixletCanvas = (uint256(1) * 1e18) / 1 days;\\n\\n        _mint(address(this), 100_000_000 * 1e18);\\n        uint256 allocation = (30_000_000 + 5_000_000 + 5_000_000 + 2_500_000) *\\n            1e18;\\n        balanceOf[address(this)] -= allocation;\\n\\n        unchecked {\\n            balanceOf[\\n                0xcc5cDaB325689Bcd654aB8611c528e60CC8CBe6A\\n            ] += (30_000_000 * 1e18);\\n            balanceOf[\\n                0x58B96f5C8ef1CdD7e12a9b71Bbbe575E7B26b142\\n            ] += (5_000_000 * 1e18);\\n            balanceOf[\\n                0x58caDf06fcC222f573F81B08B6Cc156e420D35d7\\n            ] += (5_000_000 * 1e18);\\n            balanceOf[\\n                0x5D31E4A33470e1a15e54aAdD1d913b613fd0E9ED\\n            ] += (2_500_000 * 1e18);\\n        }\\n\\n        emit Transfer(\\n            address(this),\\n            0xcc5cDaB325689Bcd654aB8611c528e60CC8CBe6A,\\n            30_000_000 * 1e18\\n        );\\n        emit Transfer(\\n            address(this),\\n            0x58B96f5C8ef1CdD7e12a9b71Bbbe575E7B26b142,\\n            5_000_000 * 1e18\\n        );\\n        emit Transfer(\\n            address(this),\\n            0x58caDf06fcC222f573F81B08B6Cc156e420D35d7,\\n            5_000_000 * 1e18\\n        );\\n        emit Transfer(\\n            address(this),\\n            0x5D31E4A33470e1a15e54aAdD1d913b613fd0E9ED,\\n            2_500_000 * 1e18\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            STAKING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Called when withdrawing rewards. $SPIT is transferred to the address, and the lastUpdated field is updated.\\n    /// @param account The address to mint to.\\n    modifier updateReward(address account) {\\n        uint256 amount = earned(account);\\n        balanceOf[address(this)] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[account] += amount;\\n        }\\n\\n        lastUpdated[account] = block.timestamp;\\n        emit Transfer(address(this), account, amount);\\n        _;\\n    }\\n\\n    /// @notice Internal call to stake an amount of a specific token type.\\n    /// @param account The address which will be staking.\\n    /// @param tokenType The token type to stake.\\n    /// @param amount The amount to stake.\\n    function processStake(\\n        address account,\\n        TokenType tokenType,\\n        uint256 amount\\n    ) internal updateReward(account) {\\n        balances[account][uint256(tokenType)] += amount;\\n    }\\n\\n    /// @notice Internal call to unstake an amount of a specific token type.\\n    /// @param account The address which will be unstaking.\\n    /// @param tokenType The token type to unstake.\\n    /// @param amount The amount to unstake.\\n    function processUnstake(\\n        address account,\\n        TokenType tokenType,\\n        uint256 amount\\n    ) internal updateReward(account) {\\n        balances[account][uint256(tokenType)] -= amount;\\n    }\\n\\n    /**\\n     * @notice Process message received from FxChild\\n     * @param stateId unique state id\\n     * @param sender root message sender\\n     * @param message bytes message that was sent from Root Tunnel\\n     */\\n    function _processMessageFromRoot(\\n        uint256 stateId,\\n        address sender,\\n        bytes memory message\\n    ) internal override validateSender(sender) {\\n        (address from, uint256 token, uint256 count, bool action) = abi.decode(\\n            message,\\n            (address, uint256, uint256, bool)\\n        );\\n        action\\n            ? processStake(from, TokenType(token), count)\\n            : processUnstake(from, TokenType(token), count);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            USER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Forwards a user\\u0027s purchase in SPIT to this contract using EIP-2612\\n    /// @dev This function exists so that the permit and transfer can be done in a single transaction.\\n    function purchaseUtility(\\n        address owner,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public updateReward(owner) {\\n        permit(owner, msg.sender, value, deadline, v, r, s);\\n        transferFrom(owner, address(this), value);\\n    }\\n\\n    /// @notice Calculates the total amount of rewards accumulated for a staker, for staking all owned token types.\\n    /// @dev Calculates based on when the staker last withdrew rewards, and compares it with the current block\\u0027s timestamp.\\n    /// @param account The account to calculate the accumulated rewards for.\\n    function earned(address account) public view returns (uint256) {\\n        return\\n            spitPerSecond(account) * (block.timestamp - lastUpdated[account]);\\n    }\\n\\n    /// @notice Calculates the current balance of the user including the unclaimed rewards.\\n    /// @dev Unclaimed rewards are withdrawn automatically when a utility purchase is made or an unstake/stake occurs.\\n    function totalBalance(address account) public view returns (uint256) {\\n        return balanceOf[account] + earned(account);\\n    }\\n\\n    /// @notice Calculates the amount of SPIT earned per second by the given user\\n    /// @param account The account to calculate the accumulated rewards for.\\n    function spitPerSecond(address account) public view returns (uint256) {\\n        return ((balances[account][0] * rewards.staticLlama) +\\n            (balances[account][1] * rewards.animatedLlama) +\\n            (min(balances[account][2], balances[account][0]) *\\n                rewards.silverEnergy) +\\n            (min(balances[account][3], balances[account][1]) *\\n                rewards.goldEnergy) +\\n            (balances[account][4] * rewards.pixletCanvas) +\\n            (balances[account][5] * rewards.llamaDraws));\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ADMIN UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Allows the contract owner to burn SPIT owned by the contract.\\n    function burn(uint256 amount) public onlyOwner {\\n        _burn(address(this), amount);\\n    }\\n\\n    /// @notice Allows the contract owner to airdrop SPIT owned by the contract.\\n    function airdrop(address[] calldata accounts, uint256[] calldata amounts) public onlyOwner {\\n        require(accounts.length == amounts.length);\\n        for(uint i = 0; i \\u003c accounts.length; i++) {\\n            uint amount = amounts[i];\\n            balanceOf[address(this)] -= amount;\\n\\n            // Cannot overflow because the sum of all user\\n            // balances can\\u0027t exceed the max uint256 value.\\n            unchecked {\\n                balanceOf[accounts[i]] += amount;\\n            }\\n\\n            emit Transfer(address(this), accounts[i], amount);\\n        }\\n    }\\n\\n    /// @notice Allows the contract owner to mint SPIT to the contract.\\n    function mint(uint256 amount) public onlyOwner {\\n        _mint(address(this), amount);\\n    }\\n\\n    /// @notice Withdraw  $SPIT being held on this contract to the requested address.\\n    /// @param recipient The address to withdraw the funds to.\\n    /// @param amount The amount of SPIT to withdraw\\n    function withdrawSpit(address recipient, uint256 amount) public onlyOwner {\\n        balanceOf[address(this)] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[recipient] += amount;\\n        }\\n\\n        emit Transfer(address(this), recipient, amount);\\n    }\\n\\n    /// @notice Allows the contract deployer to sets the reward rates for each token type.\\n    /// @param staticLlama The reward rate for staking a static llama.\\n    /// @param animatedLlama The reward rate for staking an animated llama.\\n    /// @param silverEnergy The reward rate for staking a silver llama boost.\\n    /// @param goldEnergy The reward rate for staking a gold llama boost.\\n    /// @param pixletCanvas The reward rate for staking a pixlet canvas.\\n    function setRewardRates(\\n        uint256 staticLlama,\\n        uint256 animatedLlama,\\n        uint256 silverEnergy,\\n        uint256 goldEnergy,\\n        uint256 pixletCanvas,\\n        uint256 llamaDraws\\n    ) public onlyOwner {\\n        rewards.staticLlama = staticLlama;\\n        rewards.animatedLlama = animatedLlama;\\n        rewards.silverEnergy = silverEnergy;\\n        rewards.goldEnergy = goldEnergy;\\n        rewards.pixletCanvas = pixletCanvas;\\n        rewards.llamaDraws = llamaDraws;\\n    }\\n\\n    function updateFxRootRunnel(address _fxRootTunnel) external onlyOwner {\\n        fxRootTunnel = _fxRootTunnel;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                HELPERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x \\u003c y ? x : y;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxChild\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxChild\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxRootTunnel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastUpdated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stateId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rootMessageSender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"processMessageFromRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"purchaseUtility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"staticLlama\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"animatedLlama\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"silverEnergy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"goldEnergy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pixletCanvas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"llamaDraws\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxRootTunnel\",\"type\":\"address\"}],\"name\":\"setFxRootTunnel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"staticLlama\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"animatedLlama\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"silverEnergy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"goldEnergy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pixletCanvas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"llamaDraws\",\"type\":\"uint256\"}],\"name\":\"setRewardRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"spitPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxRootTunnel\",\"type\":\"address\"}],\"name\":\"updateFxRootRunnel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSpit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SpitToken", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "0000000000000000000000008397259c983751daf40400790063935a11afa28a", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6cbcb4f6de275324e9c40d3cabeac022d09c0a62b4bb98773fadc03162644ffa"}