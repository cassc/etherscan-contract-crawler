{"SourceCode": "# @version 0.3.3\r\n\"\"\"\r\n@title Child Liquidity Gauge\r\n@license MIT\r\n@author Curve Finance\r\n\"\"\"\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\n\r\ninterface ERC20Extended:\r\n    def symbol() -> String[26]: view\r\n\r\ninterface Minter:\r\n    def minted(_user: address, _gauge: address) -> uint256: view\r\n    def getBalancerToken() -> address: view\r\n\r\ninterface ERC1271:\r\n    def isValidSignature(_hash: bytes32, _signature: Bytes[65]) -> bytes32: view\r\n\r\ninterface AuthorizerAdaptor:\r\n    def getVault() -> address: view\r\n\r\ninterface VotingEscrowDelegationProxy:\r\n    def totalSupply() -> uint256: view\r\n    def adjustedBalanceOf(_account: address) -> uint256: view\r\n\r\n\r\nevent Approval:\r\n    _owner: indexed(address)\r\n    _spender: indexed(address)\r\n    _value: uint256\r\n\r\nevent Transfer:\r\n    _from: indexed(address)\r\n    _to: indexed(address)\r\n    _value: uint256\r\n\r\nevent Deposit:\r\n    _user: indexed(address)\r\n    _value: uint256\r\n\r\nevent Withdraw:\r\n    _user: indexed(address)\r\n    _value: uint256\r\n\r\nevent UpdateLiquidityLimit:\r\n    _user: indexed(address)\r\n    _original_balance: uint256\r\n    _original_supply: uint256\r\n    _working_balance: uint256\r\n    _working_supply: uint256\r\n\r\n\r\nstruct Reward:\r\n    distributor: address\r\n    period_finish: uint256\r\n    rate: uint256\r\n    last_update: uint256\r\n    integral: uint256\r\n\r\n\r\nDOMAIN_TYPE_HASH: constant(bytes32) = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\r\nPERMIT_TYPE_HASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\r\nERC1271_MAGIC_VAL: constant(bytes32) = 0x1626ba7e00000000000000000000000000000000000000000000000000000000\r\n\r\nMAX_REWARDS: constant(uint256) = 8\r\nTOKENLESS_PRODUCTION: constant(uint256) = 40\r\nWEEK: constant(uint256) = 86400 * 7\r\n\r\n\r\nBAL: immutable(address)\r\nBAL_PSEUDO_MINTER: immutable(address)\r\nVE_DELEGATION_PROXY: immutable(address)\r\nBAL_VAULT: immutable(address)\r\nAUTHORIZER_ADAPTOR: immutable(address)\r\n\r\nDOMAIN_SEPARATOR: public(bytes32)\r\nnonces: public(HashMap[address, uint256])\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\n\r\n_allowance: HashMap[address, HashMap[address, uint256]]\r\nbalanceOf: public(HashMap[address, uint256])\r\ntotalSupply: public(uint256)\r\n\r\nlp_token: public(address)\r\nversion: public(String[128])\r\nfactory: public(address)\r\n\r\nworking_balances: public(HashMap[address, uint256])\r\nworking_supply: public(uint256)\r\n\r\nperiod: public(uint256)\r\nperiod_timestamp: public(HashMap[uint256, uint256])\r\n\r\nintegrate_checkpoint_of: public(HashMap[address, uint256])\r\nintegrate_fraction: public(HashMap[address, uint256])\r\nintegrate_inv_supply: public(HashMap[uint256, uint256])\r\nintegrate_inv_supply_of: public(HashMap[address, uint256])\r\n\r\n# For tracking external rewards\r\nreward_count: public(uint256)\r\nreward_tokens: public(address[MAX_REWARDS])\r\nreward_data: public(HashMap[address, Reward])\r\n# claimant -> default reward receiver\r\nrewards_receiver: public(HashMap[address, address])\r\n# reward token -> claiming address -> integral\r\nreward_integral_for: public(HashMap[address, HashMap[address, uint256]])\r\n# user -> token -> [uint128 claimable amount][uint128 claimed amount]\r\nclaim_data: HashMap[address, HashMap[address, uint256]]\r\n\r\nis_killed: public(bool)\r\ninflation_rate: public(HashMap[uint256, uint256])\r\n\r\n\r\n@external\r\ndef __init__(\r\n    _voting_escrow_delegation_proxy: address,\r\n    _bal_pseudo_minter: address,\r\n    _authorizer_adaptor: address,\r\n    _version: String[128]\r\n):\r\n    self.lp_token = 0x000000000000000000000000000000000000dEaD\r\n    self.version = _version\r\n    self.factory = 0x000000000000000000000000000000000000dEaD\r\n\r\n    VE_DELEGATION_PROXY = _voting_escrow_delegation_proxy\r\n    BAL_PSEUDO_MINTER = _bal_pseudo_minter\r\n    BAL = Minter(_bal_pseudo_minter).getBalancerToken()\r\n    AUTHORIZER_ADAPTOR = _authorizer_adaptor\r\n    BAL_VAULT = AuthorizerAdaptor(_authorizer_adaptor).getVault()\r\n\r\n\r\n@internal\r\ndef _checkpoint(_user: address):\r\n    \"\"\"\r\n    @notice Checkpoint a user calculating their BAL entitlement\r\n    @param _user User address\r\n    \"\"\"\r\n    period: uint256 = self.period\r\n    period_time: uint256 = self.period_timestamp[period]\r\n    integrate_inv_supply: uint256 = self.integrate_inv_supply[period]\r\n\r\n    # If killed, we skip accumulating inflation in `integrate_inv_supply`\r\n    if block.timestamp > period_time and not self.is_killed:\r\n\r\n        working_supply: uint256 = self.working_supply\r\n        prev_week_time: uint256 = period_time\r\n        week_time: uint256 = min((period_time + WEEK) / WEEK * WEEK, block.timestamp)\r\n\r\n        for i in range(256):\r\n            dt: uint256 = week_time - prev_week_time\r\n\r\n            if working_supply != 0:\r\n                # we don't have to worry about crossing inflation epochs\r\n                # and if we miss any weeks, those weeks inflation rates will be 0 for sure\r\n                # but that means no one interacted with the gauge for that long\r\n                integrate_inv_supply += self.inflation_rate[prev_week_time / WEEK] * 10 ** 18 * dt / working_supply\r\n\r\n            if week_time == block.timestamp:\r\n                break\r\n            prev_week_time = week_time\r\n            week_time = min(week_time + WEEK, block.timestamp)\r\n\r\n    # check BAL balance and increase weekly inflation rate by delta for the rest of the week\r\n    bal_balance: uint256 = ERC20(BAL).balanceOf(self)\r\n    if bal_balance != 0:\r\n        current_week: uint256 = block.timestamp / WEEK\r\n        self.inflation_rate[current_week] += bal_balance / ((current_week + 1) * WEEK - block.timestamp)\r\n        ERC20(BAL).transfer(BAL_PSEUDO_MINTER, bal_balance)\r\n\r\n    period += 1\r\n    self.period = period\r\n    self.period_timestamp[period] = block.timestamp\r\n    self.integrate_inv_supply[period] = integrate_inv_supply\r\n\r\n    working_balance: uint256 = self.working_balances[_user]\r\n    self.integrate_fraction[_user] += working_balance * (integrate_inv_supply - self.integrate_inv_supply_of[_user]) / 10 ** 18\r\n    self.integrate_inv_supply_of[_user] = integrate_inv_supply\r\n    self.integrate_checkpoint_of[_user] = block.timestamp\r\n\r\n\r\n@internal\r\ndef _update_liquidity_limit(_user: address, _user_balance: uint256, _total_supply: uint256):\r\n    \"\"\"\r\n    @notice Calculate working balances to apply amplification of BAL production.\r\n    @param _user The user address\r\n    @param _user_balance User's amount of liquidity (LP tokens)\r\n    @param _total_supply Total amount of liquidity (LP tokens)\r\n    \"\"\"\r\n    working_balance: uint256 = _user_balance * TOKENLESS_PRODUCTION / 100\r\n\r\n    ve: address = VE_DELEGATION_PROXY\r\n    if ve != ZERO_ADDRESS:\r\n        ve_ts: uint256 = VotingEscrowDelegationProxy(ve).totalSupply()\r\n        if ve_ts != 0:\r\n            ve_user_balance: uint256 = VotingEscrowDelegationProxy(ve).adjustedBalanceOf(_user)\r\n            working_balance += _total_supply * ve_user_balance / ve_ts * (100 - TOKENLESS_PRODUCTION) / 100\r\n            working_balance = min(_user_balance, working_balance)\r\n\r\n    old_working_balance: uint256 = self.working_balances[_user]\r\n    self.working_balances[_user] = working_balance\r\n\r\n    working_supply: uint256 = self.working_supply + working_balance - old_working_balance\r\n    self.working_supply = working_supply\r\n\r\n    log UpdateLiquidityLimit(_user, _user_balance, _total_supply, working_balance, working_supply)\r\n\r\n\r\n@view\r\n@internal\r\ndef _all_indexes() -> DynArray[uint256, MAX_REWARDS]:\r\n    indexes: DynArray[uint256, MAX_REWARDS] = []\r\n    for i in range(MAX_REWARDS):\r\n        if i >= self.reward_count:\r\n            break\r\n        indexes.append(i)\r\n\r\n    return indexes\r\n\r\n\r\n@internal\r\ndef _checkpoint_rewards(\r\n    _user: address,\r\n    _total_supply: uint256,\r\n    _claim: bool,\r\n    _receiver: address,\r\n    _input_reward_indexes: DynArray[uint256, MAX_REWARDS]\r\n):\r\n    \"\"\"\r\n    @notice Claim pending rewards and checkpoint rewards for a user\r\n    \"\"\"\r\n    user_balance: uint256 = 0\r\n    receiver: address = _receiver\r\n    if _user != ZERO_ADDRESS:\r\n        user_balance = self.balanceOf[_user]\r\n        if _claim and _receiver == ZERO_ADDRESS:\r\n            # if receiver is not explicitly declared, check if a default receiver is set\r\n            receiver = self.rewards_receiver[_user]\r\n            if receiver == ZERO_ADDRESS:\r\n                # if no default receiver is set, direct claims to the user\r\n                receiver = _user\r\n\r\n    reward_count: uint256 = self.reward_count\r\n    reward_indexes: DynArray[uint256, MAX_REWARDS] = []\r\n    if len(_input_reward_indexes) == 0:\r\n        reward_indexes = self._all_indexes()\r\n    else:\r\n        reward_indexes = _input_reward_indexes\r\n\r\n    for i in reward_indexes:\r\n        assert i < reward_count, \"INVALID_REWARD_INDEX\"\r\n\r\n        token: address = self.reward_tokens[i]\r\n\r\n        integral: uint256 = self.reward_data[token].integral\r\n        last_update: uint256 = min(block.timestamp, self.reward_data[token].period_finish)\r\n        duration: uint256 = last_update - self.reward_data[token].last_update\r\n        if duration != 0:\r\n            self.reward_data[token].last_update = last_update\r\n            if _total_supply != 0:\r\n                integral += duration * self.reward_data[token].rate * 10**18 / _total_supply\r\n                self.reward_data[token].integral = integral\r\n\r\n        if _user != ZERO_ADDRESS:\r\n            integral_for: uint256 = self.reward_integral_for[token][_user]\r\n            new_claimable: uint256 = 0\r\n\r\n            if integral_for < integral:\r\n                self.reward_integral_for[token][_user] = integral\r\n                new_claimable = user_balance * (integral - integral_for) / 10**18\r\n\r\n            claim_data: uint256 = self.claim_data[_user][token]\r\n            total_claimable: uint256 = shift(claim_data, -128) + new_claimable\r\n            if total_claimable > 0:\r\n                total_claimed: uint256 = claim_data % 2**128\r\n                if _claim:\r\n                    response: Bytes[32] = raw_call(\r\n                        token,\r\n                        _abi_encode(\r\n                            receiver,\r\n                            total_claimable,\r\n                            method_id=method_id(\"transfer(address,uint256)\")\r\n                        ),\r\n                        max_outsize=32,\r\n                    )\r\n                    if len(response) != 0:\r\n                        assert convert(response, bool), \"TRANSFER_FAILURE\"\r\n                    self.claim_data[_user][token] = total_claimed + total_claimable\r\n                elif new_claimable > 0:\r\n                    self.claim_data[_user][token] = total_claimed + shift(total_claimable, 128)\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256):\r\n    if _value == 0:\r\n        return\r\n    total_supply: uint256 = self.totalSupply\r\n\r\n    has_rewards: bool = self.reward_count != 0\r\n    for addr in [_from, _to]:\r\n        self._checkpoint(addr)\r\n        # We need to checkpoint all of the rewards before affecting the gauge token balance for a user,\r\n        # but to do it safely we need to skip making external calls. Therefore, we set _claim to False.\r\n        self._checkpoint_rewards(addr, total_supply, False, ZERO_ADDRESS, [])\r\n\r\n    new_balance: uint256 = self.balanceOf[_from] - _value\r\n    self.balanceOf[_from] = new_balance\r\n    self._update_liquidity_limit(_from, new_balance, total_supply)\r\n\r\n    new_balance = self.balanceOf[_to] + _value\r\n    self.balanceOf[_to] = new_balance\r\n    self._update_liquidity_limit(_to, new_balance, total_supply)\r\n\r\n    log Transfer(_from, _to, _value)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef deposit(_value: uint256, _user: address = msg.sender):\r\n    \"\"\"\r\n    @notice Deposit `_value` LP tokens\r\n    @param _value Number of tokens to deposit\r\n    @param _user The account to send gauge tokens to\r\n    \"\"\"\r\n    self._checkpoint(_user)\r\n    if _value == 0:\r\n        return\r\n\r\n    total_supply: uint256 = self.totalSupply\r\n    new_balance: uint256 = self.balanceOf[_user] + _value\r\n\r\n    if self.reward_count != 0:\r\n        # We need to checkpoint all of the rewards before affecting the gauge token balance for a user,\r\n        # but to do it safely we need to skip making external calls. Therefore, we set _claim to False.\r\n        self._checkpoint_rewards(_user, total_supply, False, ZERO_ADDRESS, [])\r\n\r\n    total_supply += _value\r\n\r\n    self.balanceOf[_user] = new_balance\r\n    self.totalSupply = total_supply\r\n\r\n    self._update_liquidity_limit(_user, new_balance, total_supply)\r\n\r\n    ERC20(self.lp_token).transferFrom(msg.sender, self, _value)\r\n\r\n    log Deposit(_user, _value)\r\n    log Transfer(ZERO_ADDRESS, _user, _value)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef withdraw(_value: uint256, _user: address = msg.sender):\r\n    \"\"\"\r\n    @notice Withdraw `_value` LP tokens\r\n    @param _value Number of tokens to withdraw\r\n    @param _user The account to send LP tokens to\r\n    \"\"\"\r\n    self._checkpoint(_user)\r\n    if _value == 0:\r\n        return\r\n\r\n    total_supply: uint256 = self.totalSupply\r\n    new_balance: uint256 = self.balanceOf[msg.sender] - _value\r\n\r\n    if self.reward_count != 0:\r\n        # We need to checkpoint all of the rewards before affecting the gauge token balance for a user,\r\n        # but to do it safely we need to skip making external calls. Therefore, we set _claim to False.\r\n        self._checkpoint_rewards(_user, total_supply, False, ZERO_ADDRESS, [])\r\n\r\n    total_supply -= _value\r\n\r\n    self.balanceOf[msg.sender] = new_balance\r\n    self.totalSupply = total_supply\r\n\r\n    self._update_liquidity_limit(msg.sender, new_balance, total_supply)\r\n\r\n    ERC20(self.lp_token).transfer(_user, _value)\r\n\r\n    log Withdraw(_user, _value)\r\n    log Transfer(msg.sender, ZERO_ADDRESS, _value)\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_allowance(owner: address, spender: address) -> uint256:\r\n    \"\"\"\r\n     @dev Override to grant the Vault infinite allowance, causing for Gauge Tokens to not require approval.\r\n     This is sound as the Vault already provides authorization mechanisms when initiating token transfers, which this\r\n     contract inherits.\r\n    \"\"\"\r\n    if (spender == BAL_VAULT):\r\n        return MAX_UINT256\r\n    return self._allowance[owner][spender]\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef transferFrom(_from: address, _to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer tokens from one address to another\r\n    @param _from The address which you want to send tokens from\r\n    @param _to The address which you want to transfer to\r\n    @param _value the amount of tokens to be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    allowance: uint256 = self._get_allowance(_from, msg.sender)\r\n    if allowance != MAX_UINT256:\r\n        self._allowance[_from][msg.sender] = allowance - _value\r\n\r\n    self._transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Approve the passed address to transfer the specified amount of\r\n            tokens on behalf of msg.sender\r\n    @dev Beware that changing an allowance via this method brings the risk\r\n         that someone may use both the old and new allowance by unfortunate\r\n         transaction ordering. This may be mitigated with the use of\r\n         {increaseAllowance} and {decreaseAllowance}.\r\n         https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will transfer the funds\r\n    @param _value The amount of tokens that may be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    self._allowance[msg.sender][_spender] = _value\r\n\r\n    log Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef permit(\r\n    _owner: address,\r\n    _spender: address,\r\n    _value: uint256,\r\n    _deadline: uint256,\r\n    _v: uint8,\r\n    _r: bytes32,\r\n    _s: bytes32\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Approves spender by owner's signature to expend owner's tokens.\r\n        See https://eips.ethereum.org/EIPS/eip-2612.\r\n    @dev Inspired by https://github.com/yearn/yearn-vaults/blob/main/contracts/Vault.vy#L753-L793\r\n    @dev Supports smart contract wallets which implement ERC1271\r\n        https://eips.ethereum.org/EIPS/eip-1271\r\n    @param _owner The address which is a source of funds and has signed the Permit.\r\n    @param _spender The address which is allowed to spend the funds.\r\n    @param _value The amount of tokens to be spent.\r\n    @param _deadline The timestamp after which the Permit is no longer valid.\r\n    @param _v The bytes[64] of the valid secp256k1 signature of permit by owner\r\n    @param _r The bytes[0:32] of the valid secp256k1 signature of permit by owner\r\n    @param _s The bytes[32:64] of the valid secp256k1 signature of permit by owner\r\n    @return True, if transaction completes successfully\r\n    \"\"\"\r\n    assert _owner != ZERO_ADDRESS, \"INVALID_OWNER\"\r\n    assert block.timestamp <= _deadline, \"DEADLINE_EXPIRED\"\r\n\r\n    nonce: uint256 = self.nonces[_owner]\r\n    digest: bytes32 = keccak256(\r\n        concat(\r\n            b\"\\x19\\x01\",\r\n            self.DOMAIN_SEPARATOR,\r\n            keccak256(_abi_encode(PERMIT_TYPE_HASH, _owner, _spender, _value, nonce, _deadline))\r\n        )\r\n    )\r\n\r\n    if _owner.is_contract:\r\n        sig: Bytes[65] = concat(_abi_encode(_r, _s), slice(convert(_v, bytes32), 31, 1))\r\n        assert ERC1271(_owner).isValidSignature(digest, sig) == ERC1271_MAGIC_VAL, \"INVALID_SIG\"\r\n    else:\r\n        recovered_address: address = ecrecover(digest, convert(_v, uint256), convert(_r, uint256), convert(_s, uint256))\r\n        assert recovered_address == _owner,\"INVALID_SIG\"\r\n\r\n    self._allowance[_owner][_spender] = _value\r\n    self.nonces[_owner] = nonce + 1\r\n\r\n    log Approval(_owner, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef transfer(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer token to a specified address\r\n    @param _to The address to transfer to\r\n    @param _value The amount to be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    self._transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef increaseAllowance(_spender: address, _added_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Increase the allowance granted to `_spender` by the caller\r\n    @dev This is alternative to {approve} that can be used as a mitigation for\r\n         the potential race condition\r\n    @param _spender The address which will transfer the funds\r\n    @param _added_value The amount of to increase the allowance\r\n    @return bool success\r\n    \"\"\"\r\n    allowance: uint256 = self._get_allowance(msg.sender, _spender) + _added_value\r\n    self._allowance[msg.sender][_spender] = allowance\r\n\r\n    log Approval(msg.sender, _spender, allowance)\r\n    return True\r\n\r\n\r\n@external\r\ndef decreaseAllowance(_spender: address, _subtracted_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Decrease the allowance granted to `_spender` by the caller\r\n    @dev This is alternative to {approve} that can be used as a mitigation for\r\n         the potential race condition\r\n    @param _spender The address which will transfer the funds\r\n    @param _subtracted_value The amount of to decrease the allowance\r\n    @return bool success\r\n    \"\"\"\r\n    allowance: uint256 = self._get_allowance(msg.sender, _spender) - _subtracted_value\r\n    self._allowance[msg.sender][_spender] = allowance\r\n\r\n    log Approval(msg.sender, _spender, allowance)\r\n    return True\r\n\r\n\r\n@external\r\ndef user_checkpoint(addr: address) -> bool:\r\n    \"\"\"\r\n    @notice Record a checkpoint for `addr`\r\n    @param addr User address\r\n    @return bool success\r\n    \"\"\"\r\n    self._checkpoint(addr)\r\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\r\n    return True\r\n\r\n\r\n@external\r\ndef claimable_tokens(addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of claimable tokens per user\r\n    @dev This function should be manually changed to \"view\" in the ABI\r\n    @return uint256 number of claimable tokens per user\r\n    \"\"\"\r\n    self._checkpoint(addr)\r\n    return self.integrate_fraction[addr] - Minter(BAL_PSEUDO_MINTER).minted(addr, self)\r\n\r\n\r\n@view\r\n@external\r\ndef claimed_reward(_addr: address, _token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of already-claimed reward tokens for a user\r\n    @param _addr Account to get reward amount for\r\n    @param _token Token to get reward amount for\r\n    @return uint256 Total amount of `_token` already claimed by `_addr`\r\n    \"\"\"\r\n    return self.claim_data[_addr][_token] % 2**128\r\n\r\n\r\n@view\r\n@external\r\ndef claimable_reward(_user: address, _reward_token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of claimable reward tokens for a user\r\n    @param _user Account to get reward amount for\r\n    @param _reward_token Token to get reward amount for\r\n    @return uint256 Claimable reward token amount\r\n    \"\"\"\r\n    integral: uint256 = self.reward_data[_reward_token].integral\r\n    total_supply: uint256 = self.totalSupply\r\n    if total_supply != 0:\r\n        last_update: uint256 = min(block.timestamp, self.reward_data[_reward_token].period_finish)\r\n        duration: uint256 = last_update - self.reward_data[_reward_token].last_update\r\n        integral += (duration * self.reward_data[_reward_token].rate * 10**18 / total_supply)\r\n\r\n    integral_for: uint256 = self.reward_integral_for[_reward_token][_user]\r\n    new_claimable: uint256 = self.balanceOf[_user] * (integral - integral_for) / 10**18\r\n\r\n    return shift(self.claim_data[_user][_reward_token], -128) + new_claimable\r\n\r\n\r\n@external\r\ndef set_rewards_receiver(_receiver: address):\r\n    \"\"\"\r\n    @notice Set the default reward receiver for the caller.\r\n    @dev When set to ZERO_ADDRESS, rewards are sent to the caller\r\n    @param _receiver Receiver address for any rewards claimed via `claim_rewards`\r\n    \"\"\"\r\n    self.rewards_receiver[msg.sender] = _receiver\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef claim_rewards(\r\n    _addr: address = msg.sender,\r\n    _receiver: address = ZERO_ADDRESS,\r\n    _reward_indexes: DynArray[uint256, MAX_REWARDS] = []\r\n):\r\n    \"\"\"\r\n    @notice Claim available reward tokens for `_addr`\r\n    @param _addr Address to claim for\r\n    @param _receiver Address to transfer rewards to - if set to\r\n                     ZERO_ADDRESS, uses the default reward receiver\r\n                     for the caller\r\n    @param _reward_indexes Array with indexes of the rewards to be checkpointed (all of them by default)\r\n    \"\"\"\r\n    if _receiver != ZERO_ADDRESS:\r\n        assert _addr == msg.sender, \"CANNOT_REDIRECT_CLAIM\"  # dev: cannot redirect when claiming for another user\r\n    self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver, _reward_indexes)\r\n\r\n\r\n@external\r\ndef add_reward(_reward_token: address, _distributor: address):\r\n    \"\"\"\r\n    @notice Set the active reward contract.\r\n    @dev The reward token cannot be BAL, since it is transferred automatically to the pseudo minter during checkpoints.\r\n    \"\"\"\r\n    assert msg.sender == AUTHORIZER_ADAPTOR, \"SENDER_NOT_ALLOWED\"  # dev: only owner\r\n    assert _reward_token != BAL, \"CANNOT_ADD_BAL_REWARD\"\r\n\r\n    reward_count: uint256 = self.reward_count\r\n    assert reward_count < MAX_REWARDS, \"MAX_REWARDS_REACHED\"\r\n    assert self.reward_data[_reward_token].distributor == ZERO_ADDRESS, \"REWARD_ALREADY_EXISTS\"\r\n\r\n    self.reward_data[_reward_token].distributor = _distributor\r\n    self.reward_tokens[reward_count] = _reward_token\r\n    self.reward_count = reward_count + 1\r\n\r\n\r\n@external\r\ndef set_reward_distributor(_reward_token: address, _distributor: address):\r\n    current_distributor: address = self.reward_data[_reward_token].distributor\r\n\r\n    assert msg.sender in [current_distributor, AUTHORIZER_ADAPTOR], \"SENDER_NOT_ALLOWED\"\r\n    assert current_distributor != ZERO_ADDRESS, \"REWARD_NOT_ADDED\"\r\n    assert _distributor != ZERO_ADDRESS, \"INVALID_DISTRIBUTOR\"\r\n\r\n    self.reward_data[_reward_token].distributor = _distributor\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef deposit_reward_token(_reward_token: address, _amount: uint256):\r\n    assert msg.sender == self.reward_data[_reward_token].distributor, \"SENDER_NOT_ALLOWED\"\r\n\r\n    # It is safe to checkpoint all the existing rewards as long as `_claim` is set to false (i.e. no external calls).\r\n    self._checkpoint_rewards(ZERO_ADDRESS, self.totalSupply, False, ZERO_ADDRESS, [])\r\n\r\n    response: Bytes[32] = raw_call(\r\n        _reward_token,\r\n        _abi_encode(\r\n            msg.sender,\r\n            self,\r\n            _amount,\r\n            method_id=method_id(\"transferFrom(address,address,uint256)\")\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool), \"TRANSFER_FROM_FAILURE\"\r\n\r\n    period_finish: uint256 = self.reward_data[_reward_token].period_finish\r\n    if block.timestamp >= period_finish:\r\n        self.reward_data[_reward_token].rate = _amount / WEEK\r\n    else:\r\n        remaining: uint256 = period_finish - block.timestamp\r\n        leftover: uint256 = remaining * self.reward_data[_reward_token].rate\r\n        self.reward_data[_reward_token].rate = (_amount + leftover) / WEEK\r\n\r\n    self.reward_data[_reward_token].last_update = block.timestamp\r\n    self.reward_data[_reward_token].period_finish = block.timestamp + WEEK\r\n\r\n\r\n@external\r\ndef killGauge():\r\n    \"\"\"\r\n    @notice Kills the gauge so it always yields a rate of 0 and so cannot mint BAL\r\n    \"\"\"\r\n    assert msg.sender == AUTHORIZER_ADAPTOR, \"SENDER_NOT_ALLOWED\"  # dev: only owner\r\n\r\n    self.is_killed = True\r\n\r\n\r\n@external\r\ndef unkillGauge():\r\n    \"\"\"\r\n    @notice Unkills the gauge so it can mint BAL again\r\n    \"\"\"\r\n    assert msg.sender == AUTHORIZER_ADAPTOR, \"SENDER_NOT_ALLOWED\"  # dev: only owner\r\n\r\n    self.is_killed = False\r\n\r\n\r\n@view\r\n@external\r\ndef decimals() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the number of decimals the token uses\r\n    \"\"\"\r\n    return 18\r\n\r\n\r\n@view\r\n@external\r\ndef allowance(owner: address, spender: address) -> uint256:\r\n    \"\"\"\r\n     @notice Get `spender`'s current allowance from `owner` \r\n    \"\"\"\r\n    return self._get_allowance(owner, spender)\r\n\r\n\r\n@view\r\n@external\r\ndef integrate_checkpoint() -> uint256:\r\n    return self.period_timestamp[self.period]\r\n\r\n\r\n@view\r\n@external\r\ndef bal_token() -> address:\r\n    return BAL\r\n\r\n\r\n@view\r\n@external\r\ndef bal_pseudo_minter() -> address:\r\n    return BAL_PSEUDO_MINTER\r\n\r\n\r\n@view\r\n@external\r\ndef voting_escrow_delegation_proxy() -> address:\r\n    return VE_DELEGATION_PROXY\r\n\r\n\r\n@view\r\n@external\r\ndef authorizer_adaptor() -> address:\r\n    \"\"\"\r\n    @notice Return the authorizer adaptor address.\r\n    \"\"\"\r\n    return AUTHORIZER_ADAPTOR\r\n\r\n\r\n@external\r\ndef initialize(_lp_token: address, _version: String[128]):\r\n    assert self.lp_token == ZERO_ADDRESS, \"ALREADY_INITIALIZED\"  # dev: already initialzed\r\n\r\n    self.lp_token = _lp_token\r\n    self.version = _version\r\n    self.factory = msg.sender\r\n\r\n    symbol: String[26] = ERC20Extended(_lp_token).symbol()\r\n    name: String[64] = concat(\"Balancer \", symbol, \" Gauge Deposit\")\r\n\r\n    self.name = name\r\n    self.symbol = concat(symbol, \"-gauge\")\r\n\r\n    self.period_timestamp[0] = block.timestamp\r\n    self.DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(\r\n            DOMAIN_TYPE_HASH,\r\n            keccak256(name),\r\n            keccak256(self.version),\r\n            chain.id,\r\n            self\r\n        )\r\n    )", "ABI": "[{\"name\":\"Approval\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateLiquidityLimit\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_original_balance\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_original_supply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_working_balance\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_working_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_voting_escrow_delegation_proxy\",\"type\":\"address\"},{\"name\":\"_bal_pseudo_minter\",\"type\":\"address\"},{\"name\":\"_authorizer_adaptor\",\"type\":\"address\"},{\"name\":\"_version\",\"type\":\"string\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_added_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtracted_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"user_checkpoint\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claimable_tokens\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claimed_reward\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claimable_reward\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_reward_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_rewards_receiver\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_rewards\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_rewards\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_rewards\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_rewards\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_reward_indexes\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_reward\",\"inputs\":[{\"name\":\"_reward_token\",\"type\":\"address\"},{\"name\":\"_distributor\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_reward_distributor\",\"inputs\":[{\"name\":\"_reward_token\",\"type\":\"address\"},{\"name\":\"_distributor\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit_reward_token\",\"inputs\":[{\"name\":\"_reward_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"killGauge\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"unkillGauge\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_checkpoint\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bal_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bal_pseudo_minter\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"voting_escrow_delegation_proxy\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"authorizer_adaptor\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_version\",\"type\":\"string\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lp_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"working_balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"working_supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"period_timestamp\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_checkpoint_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_fraction\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_inv_supply\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_inv_supply_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_tokens\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_data\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"distributor\",\"type\":\"address\"},{\"name\":\"period_finish\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"last_update\",\"type\":\"uint256\"},{\"name\":\"integral\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewards_receiver\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_integral_for\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"inflation_rate\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.3", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000000f08eef2c785aa5e7539684af04755dec1347b7c00000000000000000000000047b489bf5836f83abd928c316f8e39bc0587b020000000000000000000000000c128468b7ce63ea702c1f104d55a2566b13d3abd0000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000005b7b226e616d65223a224368696c64436861696e4761756765222c2276657273696f6e223a322c226465706c6f796d656e74223a2232303233303331362d6368696c642d636861696e2d67617567652d666163746f72792d7632227d0000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}