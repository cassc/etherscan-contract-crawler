{"SourceCode": "// File: @onchain-id/solidity/contracts/interface/IERC734.sol\r\n\r\npragma solidity ^0.8.0;\r\n// SPDX-License-Identifier: GPL-3.0\r\n\r\n\r\n/**\r\n * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.\r\n */\r\ninterface IERC734 {\r\n\r\n    /**\r\n     * @dev Emitted when an execution request was approved.\r\n     *\r\n     * Specification: MUST be triggered when approve was successfully called.\r\n     */\r\n    event Approved(uint256 indexed executionId, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when an execute operation was approved and successfully performed.\r\n     *\r\n     * Specification: MUST be triggered when approve was called and the execution was successfully approved.\r\n     */\r\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\r\n\r\n    /**\r\n     * @dev Emitted when an execution request was performed via `execute`.\r\n     *\r\n     * Specification: MUST be triggered when execute was successfully called.\r\n     */\r\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\r\n\r\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\r\n\r\n    /**\r\n     * @dev Emitted when a key was added to the Identity.\r\n     *\r\n     * Specification: MUST be triggered when addKey was successfully called.\r\n     */\r\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\r\n\r\n    /**\r\n     * @dev Emitted when a key was removed from the Identity.\r\n     *\r\n     * Specification: MUST be triggered when removeKey was successfully called.\r\n     */\r\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\r\n\r\n    /**\r\n     * @dev Emitted when the list of required keys to perform an action was updated.\r\n     *\r\n     * Specification: MUST be triggered when changeKeysRequired was successfully called.\r\n     */\r\n    event KeysRequiredChanged(uint256 purpose, uint256 number);\r\n\r\n\r\n    /**\r\n     * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.\r\n     *\r\n     * Triggers Event: `KeyAdded`\r\n     *\r\n     * Specification: MUST only be done by keys of purpose 1, or the identity itself. If it's the identity itself, the approval process will determine its approval.\r\n     */\r\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);\r\n\r\n    /**\r\n    * @dev Approves an execution or claim addition.\r\n    *\r\n    * Triggers Event: `Approved`, `Executed`\r\n    *\r\n    * Specification:\r\n    * This SHOULD require n of m approvals of keys purpose 1, if the _to of the execution is the identity contract itself, to successfully approve an execution.\r\n    * And COULD require n of m approvals of keys purpose 2, if the _to of the execution is another contract, to successfully approve an execution.\r\n    */\r\n    function approve(uint256 _id, bool _approve) external returns (bool success);\r\n\r\n    /**\r\n     * @dev Passes an execution instruction to an ERC725 identity.\r\n     *\r\n     * Triggers Event: `ExecutionRequested`, `Executed`\r\n     *\r\n     * Specification:\r\n     * SHOULD require approve to be called with one or more keys of purpose 1 or 2 to approve this execution.\r\n     * Execute COULD be used as the only accessor for `addKey` and `removeKey`.\r\n     */\r\n    function execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);\r\n\r\n    /**\r\n     * @dev Returns the full key data, if present in the identity.\r\n     */\r\n    function getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\r\n\r\n    /**\r\n     * @dev Returns the list of purposes associated with a key.\r\n     */\r\n    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory _purposes);\r\n\r\n    /**\r\n     * @dev Returns an array of public key bytes32 held by this identity.\r\n     */\r\n    function getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);\r\n\r\n    /**\r\n     * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.\r\n     */\r\n    function keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);\r\n\r\n    /**\r\n     * @dev Removes _purpose for _key from the identity.\r\n     *\r\n     * Triggers Event: `KeyRemoved`\r\n     *\r\n     * Specification: MUST only be done by keys of purpose 1, or the identity itself. If it's the identity itself, the approval process will determine its approval.\r\n     */\r\n    function removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);\r\n}\r\n\r\n// File: @onchain-id/solidity/contracts/interface/IERC735.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev interface of the ERC735 (Claim Holder) standard as defined in the EIP.\r\n */\r\ninterface IERC735 {\r\n\r\n    /**\r\n     * @dev Emitted when a claim request was performed.\r\n     *\r\n     * Specification: Is not clear\r\n     */\r\n    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n\r\n    /**\r\n     * @dev Emitted when a claim was added.\r\n     *\r\n     * Specification: MUST be triggered when a claim was successfully added.\r\n     */\r\n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n\r\n    /**\r\n     * @dev Emitted when a claim was removed.\r\n     *\r\n     * Specification: MUST be triggered when removeClaim was successfully called.\r\n     */\r\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n\r\n    /**\r\n     * @dev Emitted when a claim was changed.\r\n     *\r\n     * Specification: MUST be triggered when changeClaim was successfully called.\r\n     */\r\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\r\n\r\n    /**\r\n     * @dev Get a claim by its ID.\r\n     *\r\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\r\n     */\r\n    function getClaim(bytes32 _claimId) external view returns(uint256 topic, uint256 scheme, address issuer, bytes memory signature, bytes memory data, string memory uri);\r\n\r\n    /**\r\n     * @dev Returns an array of claim IDs by topic.\r\n     */\r\n    function getClaimIdsByTopic(uint256 _topic) external view returns(bytes32[] memory claimIds);\r\n\r\n    /**\r\n     * @dev Add or update a claim.\r\n     *\r\n     * Triggers Event: `ClaimRequested`, `ClaimAdded`, `ClaimChanged`\r\n     *\r\n     * Specification: Requests the ADDITION or the CHANGE of a claim from an issuer.\r\n     * Claims can requested to be added by anybody, including the claim holder itself (self issued).\r\n     *\r\n     * _signature is a signed message of the following structure: `keccak256(abi.encode(address identityHolder_address, uint256 topic, bytes data))`.\r\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address + uint256 topic))`.\r\n     *\r\n     * This COULD implement an approval process for pending claims, or add them right away.\r\n     * MUST return a claimRequestId (use claim ID) that COULD be sent to the approve function.\r\n     */\r\n    function addClaim(uint256 _topic, uint256 _scheme, address issuer, bytes calldata _signature, bytes calldata _data, string calldata _uri) external returns (bytes32 claimRequestId);\r\n\r\n    /**\r\n     * @dev Removes a claim.\r\n     *\r\n     * Triggers Event: `ClaimRemoved`\r\n     *\r\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\r\n     */\r\n    function removeClaim(bytes32 _claimId) external returns (bool success);\r\n}\r\n\r\n// File: @onchain-id/solidity/contracts/interface/IIdentity.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IIdentity is IERC734, IERC735 {}\r\n\r\n// File: @onchain-id/solidity/contracts/interface/IClaimIssuer.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface IClaimIssuer is IIdentity {\r\n    function revokeClaim(bytes32 _claimId, address _identity) external returns(bool);\r\n    function getRecoveredAddress(bytes calldata sig, bytes32 dataHash) external pure returns (address);\r\n    function isClaimRevoked(bytes calldata _sig) external view returns (bool);\r\n    function isClaimValid(IIdentity _identity, uint256 claimTopic, bytes calldata sig, bytes calldata data) external view returns (bool);\r\n}\r\n\r\n// File: contracts/registry/IClaimTopicsRegistry.sol\r\n\r\n\r\n/**\r\n *     NOTICE\r\n *\r\n *     The T-REX software is licensed under a proprietary license or the GPL v.3.\r\n *     If you choose to receive it under the GPL v.3 license, the following applies:\r\n *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain\r\n *\r\n *     Copyright (C) 2019, Tokeny s\u00e0rl.\r\n *\r\n *     This program is free software: you can redistribute it and/or modify\r\n *     it under the terms of the GNU General Public License as published by\r\n *     the Free Software Foundation, either version 3 of the License, or\r\n *     (at your option) any later version.\r\n *\r\n *     This program is distributed in the hope that it will be useful,\r\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *     GNU General Public License for more details.\r\n *\r\n *     You should have received a copy of the GNU General Public License\r\n *     along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\n\r\n\r\ninterface IClaimTopicsRegistry {\r\n    /**\r\n     *  this event is emitted when a claim topic has been added to the ClaimTopicsRegistry\r\n     *  the event is emitted by the 'addClaimTopic' function\r\n     *  `claimTopic` is the required claim added to the Claim Topics Registry\r\n     */\r\n    event ClaimTopicAdded(uint256 indexed claimTopic);\r\n\r\n    /**\r\n     *  this event is emitted when a claim topic has been removed from the ClaimTopicsRegistry\r\n     *  the event is emitted by the 'removeClaimTopic' function\r\n     *  `claimTopic` is the required claim removed from the Claim Topics Registry\r\n     */\r\n    event ClaimTopicRemoved(uint256 indexed claimTopic);\r\n\r\n    /**\r\n     * @dev Add a trusted claim topic (For example: KYC=1, AML=2).\r\n     * Only owner can call.\r\n     * emits `ClaimTopicAdded` event\r\n     * @param _claimTopic The claim topic index\r\n     */\r\n    function addClaimTopic(uint256 _claimTopic) external;\r\n\r\n    /**\r\n     *  @dev Remove a trusted claim topic (For example: KYC=1, AML=2).\r\n     *  Only owner can call.\r\n     *  emits `ClaimTopicRemoved` event\r\n     *  @param _claimTopic The claim topic index\r\n     */\r\n    function removeClaimTopic(uint256 _claimTopic) external;\r\n\r\n    /**\r\n     *  @dev Get the trusted claim topics for the security token\r\n     *  @return Array of trusted claim topics\r\n     */\r\n    function getClaimTopics() external view returns (uint256[] memory);\r\n\r\n    /**\r\n     *  @dev Transfers the Ownership of ClaimTopics to a new Owner.\r\n     *  Only owner can call.\r\n     *  @param _newOwner The new owner of this contract.\r\n     */\r\n    function transferOwnershipOnClaimTopicsRegistryContract(address _newOwner) external;\r\n}\r\n\r\n// File: contracts/registry/ITrustedIssuersRegistry.sol\r\n\r\n\r\n/**\r\n *     NOTICE\r\n *\r\n *     The T-REX software is licensed under a proprietary license or the GPL v.3.\r\n *     If you choose to receive it under the GPL v.3 license, the following applies:\r\n *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain\r\n *\r\n *     Copyright (C) 2019, Tokeny s\u00e0rl.\r\n *\r\n *     This program is free software: you can redistribute it and/or modify\r\n *     it under the terms of the GNU General Public License as published by\r\n *     the Free Software Foundation, either version 3 of the License, or\r\n *     (at your option) any later version.\r\n *\r\n *     This program is distributed in the hope that it will be useful,\r\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *     GNU General Public License for more details.\r\n *\r\n *     You should have received a copy of the GNU General Public License\r\n *     along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\n\r\n\r\n\r\ninterface ITrustedIssuersRegistry {\r\n    /**\r\n     *  this event is emitted when a trusted issuer is added in the registry.\r\n     *  the event is emitted by the addTrustedIssuer function\r\n     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\r\n     *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit\r\n     */\r\n    event TrustedIssuerAdded(IClaimIssuer indexed trustedIssuer, uint256[] claimTopics);\r\n\r\n    /**\r\n     *  this event is emitted when a trusted issuer is removed from the registry.\r\n     *  the event is emitted by the removeTrustedIssuer function\r\n     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\r\n     */\r\n    event TrustedIssuerRemoved(IClaimIssuer indexed trustedIssuer);\r\n\r\n    /**\r\n     *  this event is emitted when the set of claim topics is changed for a given trusted issuer.\r\n     *  the event is emitted by the updateIssuerClaimTopics function\r\n     *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\r\n     *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit\r\n     */\r\n    event ClaimTopicsUpdated(IClaimIssuer indexed trustedIssuer, uint256[] claimTopics);\r\n\r\n    /**\r\n     *  @dev registers a ClaimIssuer contract as trusted claim issuer.\r\n     *  Requires that a ClaimIssuer contract doesn't already exist\r\n     *  Requires that the claimTopics set is not empty\r\n     *  @param _trustedIssuer The ClaimIssuer contract address of the trusted claim issuer.\r\n     *  @param _claimTopics the set of claim topics that the trusted issuer is allowed to emit\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits a `TrustedIssuerAdded` event\r\n     */\r\n    function addTrustedIssuer(IClaimIssuer _trustedIssuer, uint256[] calldata _claimTopics) external;\r\n\r\n    /**\r\n     *  @dev Removes the ClaimIssuer contract of a trusted claim issuer.\r\n     *  Requires that the claim issuer contract to be registered first\r\n     *  @param _trustedIssuer the claim issuer to remove.\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits a `TrustedIssuerRemoved` event\r\n     */\r\n    function removeTrustedIssuer(IClaimIssuer _trustedIssuer) external;\r\n\r\n    /**\r\n     *  @dev Updates the set of claim topics that a trusted issuer is allowed to emit.\r\n     *  Requires that this ClaimIssuer contract already exists in the registry\r\n     *  Requires that the provided claimTopics set is not empty\r\n     *  @param _trustedIssuer the claim issuer to update.\r\n     *  @param _claimTopics the set of claim topics that the trusted issuer is allowed to emit\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits a `ClaimTopicsUpdated` event\r\n     */\r\n    function updateIssuerClaimTopics(IClaimIssuer _trustedIssuer, uint256[] calldata _claimTopics) external;\r\n\r\n    /**\r\n     *  @dev Function for getting all the trusted claim issuers stored.\r\n     *  @return array of all claim issuers registered.\r\n     */\r\n    function getTrustedIssuers() external view returns (IClaimIssuer[] memory);\r\n\r\n    /**\r\n     *  @dev Checks if the ClaimIssuer contract is trusted\r\n     *  @param _issuer the address of the ClaimIssuer contract\r\n     *  @return true if the issuer is trusted, false otherwise.\r\n     */\r\n    function isTrustedIssuer(address _issuer) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Function for getting all the claim topic of trusted claim issuer\r\n     *  Requires the provided ClaimIssuer contract to be registered in the trusted issuers registry.\r\n     *  @param _trustedIssuer the trusted issuer concerned.\r\n     *  @return The set of claim topics that the trusted issuer is allowed to emit\r\n     */\r\n    function getTrustedIssuerClaimTopics(IClaimIssuer _trustedIssuer) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     *  @dev Function for checking if the trusted claim issuer is allowed\r\n     *  to emit a certain claim topic\r\n     *  @param _issuer the address of the trusted issuer's ClaimIssuer contract\r\n     *  @param _claimTopic the Claim Topic that has to be checked to know if the `issuer` is allowed to emit it\r\n     *  @return true if the issuer is trusted for this claim topic.\r\n     */\r\n    function hasClaimTopic(address _issuer, uint256 _claimTopic) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Transfers the Ownership of TrustedIssuersRegistry to a new Owner.\r\n     *  @param _newOwner The new owner of this contract.\r\n     *  This function can only be called by the owner of the Trusted Issuers Registry contract\r\n     *  emits an `OwnershipTransferred` event\r\n     */\r\n    function transferOwnershipOnIssuersRegistryContract(address _newOwner) external;\r\n}\r\n\r\n// File: contracts/registry/IIdentityRegistryStorage.sol\r\n\r\n\r\n/**\r\n *     NOTICE\r\n *\r\n *     The T-REX software is licensed under a proprietary license or the GPL v.3.\r\n *     If you choose to receive it under the GPL v.3 license, the following applies:\r\n *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain\r\n *\r\n *     Copyright (C) 2019, Tokeny s\u00e0rl.\r\n *\r\n *     This program is free software: you can redistribute it and/or modify\r\n *     it under the terms of the GNU General Public License as published by\r\n *     the Free Software Foundation, either version 3 of the License, or\r\n *     (at your option) any later version.\r\n *\r\n *     This program is distributed in the hope that it will be useful,\r\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *     GNU General Public License for more details.\r\n *\r\n *     You should have received a copy of the GNU General Public License\r\n *     along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\n\r\n\r\n\r\ninterface IIdentityRegistryStorage {\r\n    /**\r\n     *  this event is emitted when an Identity is registered into the storage contract.\r\n     *  the event is emitted by the 'registerIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityStored(address indexed investorAddress, IIdentity indexed identity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is removed from the storage contract.\r\n     *  the event is emitted by the 'deleteIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityUnstored(address indexed investorAddress, IIdentity indexed identity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity has been updated\r\n     *  the event is emitted by the 'updateIdentity' function\r\n     *  `oldIdentity` is the old Identity contract's address to update\r\n     *  `newIdentity` is the new Identity contract's\r\n     */\r\n    event IdentityModified(IIdentity indexed oldIdentity, IIdentity indexed newIdentity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity's country has been updated\r\n     *  the event is emitted by the 'updateCountry' function\r\n     *  `investorAddress` is the address on which the country has been updated\r\n     *  `country` is the numeric code (ISO 3166-1) of the new country\r\n     */\r\n    event CountryModified(address indexed investorAddress, uint16 indexed country);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity Registry is bound to the storage contract\r\n     *  the event is emitted by the 'addIdentityRegistry' function\r\n     *  `identityRegistry` is the address of the identity registry added\r\n     */\r\n    event IdentityRegistryBound(address indexed identityRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity Registry is unbound from the storage contract\r\n     *  the event is emitted by the 'removeIdentityRegistry' function\r\n     *  `identityRegistry` is the address of the identity registry removed\r\n     */\r\n    event IdentityRegistryUnbound(address indexed identityRegistry);\r\n\r\n    /**\r\n     *  @dev Returns the identity registries linked to the storage contract\r\n     */\r\n    function linkedIdentityRegistries() external view returns (address[] memory);\r\n\r\n    /**\r\n     *  @dev Returns the onchainID of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function storedIdentity(address _userAddress) external view returns (IIdentity);\r\n\r\n    /**\r\n     *  @dev Returns the country code of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function storedInvestorCountry(address _userAddress) external view returns (uint16);\r\n\r\n    /**\r\n     *  @dev adds an identity contract corresponding to a user address in the storage.\r\n     *  Requires that the user doesn't have an identity contract already registered.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's identity contract\r\n     *  @param _country The country of the investor\r\n     *  emits `IdentityStored` event\r\n     */\r\n    function addIdentityToStorage(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Removes an user from the storage.\r\n     *  Requires that the user have an identity contract already deployed that will be deleted.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user to be removed\r\n     *  emits `IdentityUnstored` event\r\n     */\r\n    function removeIdentityFromStorage(address _userAddress) external;\r\n\r\n    /**\r\n     *  @dev Updates the country corresponding to a user address.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _country The new country of the user\r\n     *  emits `CountryModified` event\r\n     */\r\n    function modifyStoredInvestorCountry(address _userAddress, uint16 _country) external;\r\n\r\n    /**\r\n     *  @dev Updates an identity contract corresponding to a user address.\r\n     *  Requires that the user address should be the owner of the identity contract.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by an address set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's new identity contract\r\n     *  emits `IdentityModified` event\r\n     */\r\n    function modifyStoredIdentity(address _userAddress, IIdentity _identity) external;\r\n\r\n    /**\r\n     *  @notice Transfers the Ownership of the Identity Registry Storage to a new Owner.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _newOwner The new owner of this contract.\r\n     */\r\n    function transferOwnershipOnIdentityRegistryStorage(address _newOwner) external;\r\n\r\n    /**\r\n     *  @notice Adds an identity registry as agent of the Identity Registry Storage Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  This function adds the identity registry to the list of identityRegistries linked to the storage contract\r\n     *  @param _identityRegistry The identity registry address to add.\r\n     */\r\n    function bindIdentityRegistry(address _identityRegistry) external;\r\n\r\n    /**\r\n     *  @notice Removes an identity registry from being agent of the Identity Registry Storage Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  This function removes the identity registry from the list of identityRegistries linked to the storage contract\r\n     *  @param _identityRegistry The identity registry address to remove.\r\n     */\r\n    function unbindIdentityRegistry(address _identityRegistry) external;\r\n}\r\n\r\n// File: contracts/registry/IIdentityRegistry.sol\r\n\r\n\r\n/**\r\n *     NOTICE\r\n *\r\n *     The T-REX software is licensed under a proprietary license or the GPL v.3.\r\n *     If you choose to receive it under the GPL v.3 license, the following applies:\r\n *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain\r\n *\r\n *     Copyright (C) 2019, Tokeny s\u00e0rl.\r\n *\r\n *     This program is free software: you can redistribute it and/or modify\r\n *     it under the terms of the GNU General Public License as published by\r\n *     the Free Software Foundation, either version 3 of the License, or\r\n *     (at your option) any later version.\r\n *\r\n *     This program is distributed in the hope that it will be useful,\r\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *     GNU General Public License for more details.\r\n *\r\n *     You should have received a copy of the GNU General Public License\r\n *     along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IIdentityRegistry {\r\n    /**\r\n     *  this event is emitted when the ClaimTopicsRegistry has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `claimTopicsRegistry` is the address of the Claim Topics Registry contract\r\n     */\r\n    event ClaimTopicsRegistrySet(address indexed claimTopicsRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when the IdentityRegistryStorage has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `identityStorage` is the address of the Identity Registry Storage contract\r\n     */\r\n    event IdentityStorageSet(address indexed identityStorage);\r\n\r\n    /**\r\n     *  this event is emitted when the ClaimTopicsRegistry has been set for the IdentityRegistry\r\n     *  the event is emitted by the IdentityRegistry constructor\r\n     *  `trustedIssuersRegistry` is the address of the Trusted Issuers Registry contract\r\n     */\r\n    event TrustedIssuersRegistrySet(address indexed trustedIssuersRegistry);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is registered into the Identity Registry.\r\n     *  the event is emitted by the 'registerIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityRegistered(address indexed investorAddress, IIdentity indexed identity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity is removed from the Identity Registry.\r\n     *  the event is emitted by the 'deleteIdentity' function\r\n     *  `investorAddress` is the address of the investor's wallet\r\n     *  `identity` is the address of the Identity smart contract (onchainID)\r\n     */\r\n    event IdentityRemoved(address indexed investorAddress, IIdentity indexed identity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity has been updated\r\n     *  the event is emitted by the 'updateIdentity' function\r\n     *  `oldIdentity` is the old Identity contract's address to update\r\n     *  `newIdentity` is the new Identity contract's\r\n     */\r\n    event IdentityUpdated(IIdentity indexed oldIdentity, IIdentity indexed newIdentity);\r\n\r\n    /**\r\n     *  this event is emitted when an Identity's country has been updated\r\n     *  the event is emitted by the 'updateCountry' function\r\n     *  `investorAddress` is the address on which the country has been updated\r\n     *  `country` is the numeric code (ISO 3166-1) of the new country\r\n     */\r\n    event CountryUpdated(address indexed investorAddress, uint16 indexed country);\r\n\r\n    /**\r\n     *  @dev Register an identity contract corresponding to a user address.\r\n     *  Requires that the user doesn't have an identity contract already registered.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's identity contract\r\n     *  @param _country The country of the investor\r\n     *  emits `IdentityRegistered` event\r\n     */\r\n    function registerIdentity(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev Removes an user from the identity registry.\r\n     *  Requires that the user have an identity contract already deployed that will be deleted.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user to be removed\r\n     *  emits `IdentityRemoved` event\r\n     */\r\n    function deleteIdentity(address _userAddress) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual identityRegistryStorage contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _identityRegistryStorage The address of the new Identity Registry Storage\r\n     *  emits `IdentityStorageSet` event\r\n     */\r\n    function setIdentityRegistryStorage(address _identityRegistryStorage) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual claimTopicsRegistry contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _claimTopicsRegistry The address of the new claim Topics Registry\r\n     *  emits `ClaimTopicsRegistrySet` event\r\n     */\r\n    function setClaimTopicsRegistry(address _claimTopicsRegistry) external;\r\n\r\n    /**\r\n     *  @dev Replace the actual trustedIssuersRegistry contract with a new one.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _trustedIssuersRegistry The address of the new Trusted Issuers Registry\r\n     *  emits `TrustedIssuersRegistrySet` event\r\n     */\r\n    function setTrustedIssuersRegistry(address _trustedIssuersRegistry) external;\r\n\r\n    /**\r\n     *  @dev Updates the country corresponding to a user address.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _country The new country of the user\r\n     *  emits `CountryUpdated` event\r\n     */\r\n    function updateCountry(address _userAddress, uint16 _country) external;\r\n\r\n    /**\r\n     *  @dev Updates an identity contract corresponding to a user address.\r\n     *  Requires that the user address should be the owner of the identity contract.\r\n     *  Requires that the user should have an identity contract already deployed that will be replaced.\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  @param _userAddress The address of the user\r\n     *  @param _identity The address of the user's new identity contract\r\n     *  emits `IdentityUpdated` event\r\n     */\r\n    function updateIdentity(address _userAddress, IIdentity _identity) external;\r\n\r\n    /**\r\n     *  @dev function allowing to register identities in batch\r\n     *  This function can only be called by a wallet set as agent of the smart contract\r\n     *  Requires that none of the users has an identity contract already registered.\r\n     *  IMPORTANT : THIS TRANSACTION COULD EXCEED GAS LIMIT IF `_userAddresses.length` IS TOO HIGH,\r\n     *  USE WITH CARE OR YOU COULD LOSE TX FEES WITH AN \"OUT OF GAS\" TRANSACTION\r\n     *  @param _userAddresses The addresses of the users\r\n     *  @param _identities The addresses of the corresponding identity contracts\r\n     *  @param _countries The countries of the corresponding investors\r\n     *  emits _userAddresses.length `IdentityRegistered` events\r\n     */\r\n    function batchRegisterIdentity(\r\n        address[] calldata _userAddresses,\r\n        IIdentity[] calldata _identities,\r\n        uint16[] calldata _countries\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev This functions checks whether a wallet has its Identity registered or not\r\n     *  in the Identity Registry.\r\n     *  @param _userAddress The address of the user to be checked.\r\n     *  @return 'True' if the address is contained in the Identity Registry, 'false' if not.\r\n     */\r\n    function contains(address _userAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev This functions checks whether an identity contract\r\n     *  corresponding to the provided user address has the required claims or not based\r\n     *  on the data fetched from trusted issuers registry and from the claim topics registry\r\n     *  @param _userAddress The address of the user to be verified.\r\n     *  @return 'True' if the address is verified, 'false' if not.\r\n     */\r\n    function isVerified(address _userAddress) external view returns (bool);\r\n\r\n    /**\r\n     *  @dev Returns the onchainID of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function identity(address _userAddress) external view returns (IIdentity);\r\n\r\n    /**\r\n     *  @dev Returns the country code of an investor.\r\n     *  @param _userAddress The wallet of the investor\r\n     */\r\n    function investorCountry(address _userAddress) external view returns (uint16);\r\n\r\n    /**\r\n     *  @dev Returns the IdentityRegistryStorage linked to the current IdentityRegistry.\r\n     */\r\n    function identityStorage() external view returns (IIdentityRegistryStorage);\r\n\r\n    /**\r\n     *  @dev Returns the TrustedIssuersRegistry linked to the current IdentityRegistry.\r\n     */\r\n    function issuersRegistry() external view returns (ITrustedIssuersRegistry);\r\n\r\n    /**\r\n     *  @dev Returns the ClaimTopicsRegistry linked to the current IdentityRegistry.\r\n     */\r\n    function topicsRegistry() external view returns (IClaimTopicsRegistry);\r\n\r\n    /**\r\n     *  @notice Transfers the Ownership of the Identity Registry to a new Owner.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _newOwner The new owner of this contract.\r\n     */\r\n    function transferOwnershipOnIdentityRegistryContract(address _newOwner) external;\r\n\r\n    /**\r\n     *  @notice Adds an address as _agent of the Identity Registry Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _agent The _agent's address to add.\r\n     */\r\n    function addAgentOnIdentityRegistryContract(address _agent) external;\r\n\r\n    /**\r\n     *  @notice Removes an address from being _agent of the Identity Registry Contract.\r\n     *  This function can only be called by the wallet set as owner of the smart contract\r\n     *  @param _agent The _agent's address to remove.\r\n     */\r\n    function removeAgentOnIdentityRegistryContract(address _agent) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/roles/Roles.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping(address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), 'Roles: account already has role');\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), 'Roles: account does not have role');\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), 'Roles: account is the zero address');\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts/roles/AgentRole.sol\r\n\r\n\r\n/**\r\n *     NOTICE\r\n *\r\n *     The T-REX software is licensed under a proprietary license or the GPL v.3.\r\n *     If you choose to receive it under the GPL v.3 license, the following applies:\r\n *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain\r\n *\r\n *     Copyright (C) 2019, Tokeny s\u00e0rl.\r\n *\r\n *     This program is free software: you can redistribute it and/or modify\r\n *     it under the terms of the GNU General Public License as published by\r\n *     the Free Software Foundation, either version 3 of the License, or\r\n *     (at your option) any later version.\r\n *\r\n *     This program is distributed in the hope that it will be useful,\r\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *     GNU General Public License for more details.\r\n *\r\n *     You should have received a copy of the GNU General Public License\r\n *     along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\n\r\n\r\n\r\n\r\ncontract AgentRole is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event AgentAdded(address indexed _agent);\r\n    event AgentRemoved(address indexed _agent);\r\n\r\n    Roles.Role private _agents;\r\n\r\n    modifier onlyAgent() {\r\n        require(isAgent(msg.sender), 'AgentRole: caller does not have the Agent role');\r\n        _;\r\n    }\r\n\r\n    function isAgent(address _agent) public view returns (bool) {\r\n        return _agents.has(_agent);\r\n    }\r\n\r\n    function addAgent(address _agent) public onlyOwner {\r\n        _agents.add(_agent);\r\n        emit AgentAdded(_agent);\r\n    }\r\n\r\n    function removeAgent(address _agent) public onlyOwner {\r\n        _agents.remove(_agent);\r\n        emit AgentRemoved(_agent);\r\n    }\r\n}\r\n\r\n// File: contracts/registry/IdentityRegistry.sol\r\n\r\n\r\n/**\r\n *     NOTICE\r\n *\r\n *     The T-REX software is licensed under a proprietary license or the GPL v.3.\r\n *     If you choose to receive it under the GPL v.3 license, the following applies:\r\n *     T-REX is a suite of smart contracts developed by Tokeny to manage and transfer financial assets on the ethereum blockchain\r\n *\r\n *     Copyright (C) 2019, Tokeny s\u00e0rl.\r\n *\r\n *     This program is free software: you can redistribute it and/or modify\r\n *     it under the terms of the GNU General Public License as published by\r\n *     the Free Software Foundation, either version 3 of the License, or\r\n *     (at your option) any later version.\r\n *\r\n *     This program is distributed in the hope that it will be useful,\r\n *     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *     GNU General Public License for more details.\r\n *\r\n *     You should have received a copy of the GNU General Public License\r\n *     along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IdentityRegistry is IIdentityRegistry, AgentRole {\r\n    /// @dev Address of the ClaimTopicsRegistry Contract\r\n    IClaimTopicsRegistry private tokenTopicsRegistry;\r\n\r\n    /// @dev Address of the TrustedIssuersRegistry Contract\r\n    ITrustedIssuersRegistry private tokenIssuersRegistry;\r\n\r\n    /// @dev Address of the IdentityRegistryStorage Contract\r\n    IIdentityRegistryStorage private tokenIdentityStorage;\r\n\r\n    /**\r\n     *  @dev the constructor initiates the Identity Registry smart contract\r\n     *  @param _trustedIssuersRegistry the trusted issuers registry linked to the Identity Registry\r\n     *  @param _claimTopicsRegistry the claim topics registry linked to the Identity Registry\r\n     *  @param _identityStorage the identity registry storage linked to the Identity Registry\r\n     *  emits a `ClaimTopicsRegistrySet` event\r\n     *  emits a `TrustedIssuersRegistrySet` event\r\n     *  emits an `IdentityStorageSet` event\r\n     */\r\n    constructor(\r\n        address _trustedIssuersRegistry,\r\n        address _claimTopicsRegistry,\r\n        address _identityStorage\r\n    ) {\r\n        tokenTopicsRegistry = IClaimTopicsRegistry(_claimTopicsRegistry);\r\n        tokenIssuersRegistry = ITrustedIssuersRegistry(_trustedIssuersRegistry);\r\n        tokenIdentityStorage = IIdentityRegistryStorage(_identityStorage);\r\n        emit ClaimTopicsRegistrySet(_claimTopicsRegistry);\r\n        emit TrustedIssuersRegistrySet(_trustedIssuersRegistry);\r\n        emit IdentityStorageSet(_identityStorage);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-identity}.\r\n     */\r\n    function identity(address _userAddress) public view override returns (IIdentity) {\r\n        return tokenIdentityStorage.storedIdentity(_userAddress);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-investorCountry}.\r\n     */\r\n    function investorCountry(address _userAddress) external view override returns (uint16) {\r\n        return tokenIdentityStorage.storedInvestorCountry(_userAddress);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-issuersRegistry}.\r\n     */\r\n    function issuersRegistry() external view override returns (ITrustedIssuersRegistry) {\r\n        return tokenIssuersRegistry;\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-topicsRegistry}.\r\n     */\r\n    function topicsRegistry() external view override returns (IClaimTopicsRegistry) {\r\n        return tokenTopicsRegistry;\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-identityStorage}.\r\n     */\r\n    function identityStorage() external view override returns (IIdentityRegistryStorage) {\r\n        return tokenIdentityStorage;\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-registerIdentity}.\r\n     */\r\n    function registerIdentity(\r\n        address _userAddress,\r\n        IIdentity _identity,\r\n        uint16 _country\r\n    ) public override onlyAgent {\r\n        tokenIdentityStorage.addIdentityToStorage(_userAddress, _identity, _country);\r\n        emit IdentityRegistered(_userAddress, _identity);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-batchRegisterIdentity}.\r\n     */\r\n    function batchRegisterIdentity(\r\n        address[] calldata _userAddresses,\r\n        IIdentity[] calldata _identities,\r\n        uint16[] calldata _countries\r\n    ) external override {\r\n        for (uint256 i = 0; i < _userAddresses.length; i++) {\r\n            registerIdentity(_userAddresses[i], _identities[i], _countries[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-updateIdentity}.\r\n     */\r\n    function updateIdentity(address _userAddress, IIdentity _identity) external override onlyAgent {\r\n        IIdentity oldIdentity = identity(_userAddress);\r\n        tokenIdentityStorage.modifyStoredIdentity(_userAddress, _identity);\r\n        emit IdentityUpdated(oldIdentity, _identity);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-updateCountry}.\r\n     */\r\n    function updateCountry(address _userAddress, uint16 _country) external override onlyAgent {\r\n        tokenIdentityStorage.modifyStoredInvestorCountry(_userAddress, _country);\r\n        emit CountryUpdated(_userAddress, _country);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-deleteIdentity}.\r\n     */\r\n    function deleteIdentity(address _userAddress) external override onlyAgent {\r\n        tokenIdentityStorage.removeIdentityFromStorage(_userAddress);\r\n        emit IdentityRemoved(_userAddress, identity(_userAddress));\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-isVerified}.\r\n     */\r\n    function isVerified(address _userAddress) external view override returns (bool) {\r\n        if (address(identity(_userAddress)) == address(0)) {\r\n            return false;\r\n        }\r\n        uint256[] memory requiredClaimTopics = tokenTopicsRegistry.getClaimTopics();\r\n        if (requiredClaimTopics.length == 0) {\r\n            return true;\r\n        }\r\n        uint256 foundClaimTopic;\r\n        uint256 scheme;\r\n        address issuer;\r\n        bytes memory sig;\r\n        bytes memory data;\r\n        uint256 claimTopic;\r\n        for (claimTopic = 0; claimTopic < requiredClaimTopics.length; claimTopic++) {\r\n            bytes32[] memory claimIds = identity(_userAddress).getClaimIdsByTopic(requiredClaimTopics[claimTopic]);\r\n            if (claimIds.length == 0) {\r\n                return false;\r\n            }\r\n            for (uint256 j = 0; j < claimIds.length; j++) {\r\n                (foundClaimTopic, scheme, issuer, sig, data, ) = identity(_userAddress).getClaim(claimIds[j]);\r\n\r\n                if (\r\n                    IClaimIssuer(issuer).isClaimValid(identity(_userAddress), requiredClaimTopics[claimTopic], sig, data)\r\n                    && tokenIssuersRegistry.hasClaimTopic(issuer, requiredClaimTopics[claimTopic])\r\n                    && tokenIssuersRegistry.isTrustedIssuer(issuer)\r\n                ) {\r\n                    j = claimIds.length;\r\n                }\r\n\r\n                if (!tokenIssuersRegistry.isTrustedIssuer(issuer) && j == (claimIds.length - 1)) {\r\n                    return false;\r\n                }\r\n                if (!tokenIssuersRegistry.hasClaimTopic(issuer, requiredClaimTopics[claimTopic]) && j == (claimIds.length - 1)) {\r\n                    return false;\r\n                }\r\n                if (\r\n                    !IClaimIssuer(issuer).isClaimValid(identity(_userAddress), requiredClaimTopics[claimTopic], sig, data) &&\r\n                    j == (claimIds.length - 1)\r\n                ) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-setIdentityRegistryStorage}.\r\n     */\r\n    function setIdentityRegistryStorage(address _identityRegistryStorage) external override onlyOwner {\r\n        tokenIdentityStorage = IIdentityRegistryStorage(_identityRegistryStorage);\r\n        emit IdentityStorageSet(_identityRegistryStorage);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-setClaimTopicsRegistry}.\r\n     */\r\n    function setClaimTopicsRegistry(address _claimTopicsRegistry) external override onlyOwner {\r\n        tokenTopicsRegistry = IClaimTopicsRegistry(_claimTopicsRegistry);\r\n        emit ClaimTopicsRegistrySet(_claimTopicsRegistry);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-setTrustedIssuersRegistry}.\r\n     */\r\n    function setTrustedIssuersRegistry(address _trustedIssuersRegistry) external override onlyOwner {\r\n        tokenIssuersRegistry = ITrustedIssuersRegistry(_trustedIssuersRegistry);\r\n        emit TrustedIssuersRegistrySet(_trustedIssuersRegistry);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-contains}.\r\n     */\r\n    function contains(address _userAddress) external view override returns (bool) {\r\n        if (address(identity(_userAddress)) == address(0)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-transferOwnershipOnIdentityRegistryContract}.\r\n     */\r\n    function transferOwnershipOnIdentityRegistryContract(address _newOwner) external override onlyOwner {\r\n        transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-addAgentOnIdentityRegistryContract}.\r\n     */\r\n    function addAgentOnIdentityRegistryContract(address _agent) external override {\r\n        addAgent(_agent);\r\n    }\r\n\r\n    /**\r\n     *  @dev See {IIdentityRegistry-removeAgentOnIdentityRegistryContract}.\r\n     */\r\n    function removeAgentOnIdentityRegistryContract(address _agent) external override {\r\n        removeAgent(_agent);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedIssuersRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_claimTopicsRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_identityStorage\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"AgentAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"AgentRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimTopicsRegistry\",\"type\":\"address\"}],\"name\":\"ClaimTopicsRegistrySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"country\",\"type\":\"uint16\"}],\"name\":\"CountryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IIdentity\",\"name\":\"identity\",\"type\":\"address\"}],\"name\":\"IdentityRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IIdentity\",\"name\":\"identity\",\"type\":\"address\"}],\"name\":\"IdentityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"identityStorage\",\"type\":\"address\"}],\"name\":\"IdentityStorageSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IIdentity\",\"name\":\"oldIdentity\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IIdentity\",\"name\":\"newIdentity\",\"type\":\"address\"}],\"name\":\"IdentityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trustedIssuersRegistry\",\"type\":\"address\"}],\"name\":\"TrustedIssuersRegistrySet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"addAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"addAgentOnIdentityRegistryContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userAddresses\",\"type\":\"address[]\"},{\"internalType\":\"contract IIdentity[]\",\"name\":\"_identities\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_countries\",\"type\":\"uint16[]\"}],\"name\":\"batchRegisterIdentity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"contains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"deleteIdentity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"identity\",\"outputs\":[{\"internalType\":\"contract IIdentity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identityStorage\",\"outputs\":[{\"internalType\":\"contract IIdentityRegistryStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"investorCountry\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"isAgent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"isVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issuersRegistry\",\"outputs\":[{\"internalType\":\"contract ITrustedIssuersRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"contract IIdentity\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_country\",\"type\":\"uint16\"}],\"name\":\"registerIdentity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"removeAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"removeAgentOnIdentityRegistryContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_claimTopicsRegistry\",\"type\":\"address\"}],\"name\":\"setClaimTopicsRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identityRegistryStorage\",\"type\":\"address\"}],\"name\":\"setIdentityRegistryStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedIssuersRegistry\",\"type\":\"address\"}],\"name\":\"setTrustedIssuersRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topicsRegistry\",\"outputs\":[{\"internalType\":\"contract IClaimTopicsRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnershipOnIdentityRegistryContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_country\",\"type\":\"uint16\"}],\"name\":\"updateCountry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"contract IIdentity\",\"name\":\"_identity\",\"type\":\"address\"}],\"name\":\"updateIdentity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IdentityRegistry", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000aa958ce7684588198d01669d9e05f3de1ed1bc21000000000000000000000000586491b0e8b9c15a4da7a3805cbe385248c0abab000000000000000000000000d1c3437fceb2fe17f6655f4d66b27093908a70fd", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bdb81e9e60b906348f24ac6c12205f6e56435d35010db01e35b3bcff0b1b9ccc"}