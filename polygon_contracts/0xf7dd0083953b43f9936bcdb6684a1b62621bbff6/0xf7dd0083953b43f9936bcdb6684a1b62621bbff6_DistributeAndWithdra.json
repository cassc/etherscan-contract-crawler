{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/DistributeAndWithdraw.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.17;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {ISplitMain} from \\\"./interfaces/ISplitMain.sol\\\";\\n\\n/// @title DistributeAndWithdraw\\n/// @author 0xSplits\\n/// @notice A helper contract for more efficiently performing a distribute and withdraw multicall transaction\\ncontract DistributeAndWithdraw {\\n    /// -----------------------------------------------------------------------\\n    /// storage\\n    /// -----------------------------------------------------------------------\\n\\n    ISplitMain public immutable splitMain;\\n\\n    /// -----------------------------------------------------------------------\\n    /// constructor\\n    /// -----------------------------------------------------------------------\\n\\n    constructor(address _splitMain) {\\n        splitMain = ISplitMain(_splitMain);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// functions\\n    /// -----------------------------------------------------------------------\\n\\n    /// -----------------------------------------------------------------------\\n    /// functions - public & external\\n    /// -----------------------------------------------------------------------\\n\\n    /// Distribute given tokens for the split, then withdraw tokens for all recipients\\n    /// @param split Address of split to distribute\\n    /// @param accounts Ordered, unique list of addresses with ownership in the split\\n    /// @param percentAllocations Percent allocations associated with each address\\n    /// @param distributorFee Keeper fee paid by split to cover gas costs of distribution\\n    /// @param distributorAddress Address to pay `distributorFee` to\\n    /// @param shouldDistributeETH Distribute and withdraw eth if non-zero\\n    /// @param erc20Tokens List of erc20 tokens to distribute and withdraw\\n    function distributeAndWithdrawForAll(\\n        address split,\\n        address[] calldata accounts,\\n        uint32[] calldata percentAllocations,\\n        uint32 distributorFee,\\n        address distributorAddress,\\n        uint256 shouldDistributeETH,\\n        ERC20[] calldata erc20Tokens\\n    ) external {\\n        uint256 erc20TokensLength = erc20Tokens.length;\\n\\n        if (shouldDistributeETH != 0) {\\n            splitMain.distributeETH({\\n                split: split,\\n                accounts: accounts,\\n                percentAllocations: percentAllocations,\\n                distributorFee: distributorFee,\\n                distributorAddress: distributorAddress\\n            });\\n        }\\n        uint256 i = 0;\\n        for (; i < erc20TokensLength;) {\\n            splitMain.distributeERC20({\\n                split: split,\\n                token: erc20Tokens[i],\\n                accounts: accounts,\\n                percentAllocations: percentAllocations,\\n                distributorFee: distributorFee,\\n                distributorAddress: distributorAddress\\n            });\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        i = 0;\\n        uint256 accountsLength = accounts.length;\\n        for (; i < accountsLength;) {\\n            splitMain.withdraw({account: accounts[i], withdrawETH: shouldDistributeETH, tokens: erc20Tokens});\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISplitMain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.17;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\ninterface ISplitMain {\\n    error InvalidSplit__TooFewAccounts(uint256 accountsLength);\\n\\n    function createSplit(\\n        address[] calldata accounts,\\n        uint32[] calldata percentAllocations,\\n        uint32 distributorFee,\\n        address controller\\n    ) external returns (address);\\n\\n    function distributeETH(\\n        address split,\\n        address[] calldata accounts,\\n        uint32[] calldata percentAllocations,\\n        uint32 distributorFee,\\n        address distributorAddress\\n    ) external;\\n\\n    function distributeERC20(\\n        address split,\\n        ERC20 token,\\n        address[] calldata accounts,\\n        uint32[] calldata percentAllocations,\\n        uint32 distributorFee,\\n        address distributorAddress\\n    ) external;\\n\\n    function updateAndDistributeETH(\\n        address split,\\n        address[] calldata accounts,\\n        uint32[] calldata percentAllocations,\\n        uint32 distributorFee,\\n        address distributorAddress\\n    ) external;\\n\\n    function updateAndDistributeERC20(\\n        address split,\\n        ERC20 token,\\n        address[] calldata accounts,\\n        uint32[] calldata percentAllocations,\\n        uint32 distributorFee,\\n        address distributorAddress\\n    ) external;\\n\\n    function getETHBalance(address account) external view returns (uint256);\\n\\n    function getERC20Balance(address account, ERC20 token) external view returns (uint256);\\n\\n    function withdraw(address account, uint256 withdrawETH, ERC20[] calldata tokens) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_splitMain\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"percentAllocations\",\"type\":\"uint32[]\"},{\"internalType\":\"uint32\",\"name\":\"distributorFee\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shouldDistributeETH\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20[]\",\"name\":\"erc20Tokens\",\"type\":\"address[]\"}],\"name\":\"distributeAndWithdrawForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"splitMain\",\"outputs\":[{\"internalType\":\"contract ISplitMain\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DistributeAndWithdraw", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002ed6c4b5da6378c7897ac67ba9e43102feb694ee", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}