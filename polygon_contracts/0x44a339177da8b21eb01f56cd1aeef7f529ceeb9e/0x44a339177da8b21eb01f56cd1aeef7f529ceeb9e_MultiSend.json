{"SourceCode": "{\"IERC20.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\ncontract IERC20 {\\n  function totalSupply() public constant returns (uint);\\n  function balanceOf(address tokenOwner) public constant returns (uint balance);\\n  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\\n  function transfer(address to, uint tokens) public returns (bool success);\\n  function approve(address spender, uint tokens) public returns (bool success);\\n  function transferFrom(address from, address to, uint tokens) public returns (bool success);\\n\\n  event Transfer(address indexed from, address indexed to, uint tokens);\\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n}\"},\"MultiSend.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\ncontract MultiSend {\\n\\tusing SafeERC20 for IERC20;\\n\\n  mapping(address =\\u003e bool) public admins;\\n\\t\\n\\tevent AdminSet(address indexed newAdmin);\\n\\tevent AdminRemoved(address indexed oldAdmin);\\n\\tevent Transfer(address indexed from, address indexed to, address indexed tokenAddress, uint tokens);\\n\\n\\tconstructor() public {\\n\\t\\tadmins[msg.sender] = true;\\n\\t\\temit AdminSet(msg.sender);\\n\\t}\\n\\n\\tmodifier onlyAdmin() {\\n\\t\\trequire(admins[msg.sender], \\\"Must be an admin\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tfunction setAdmin(address admin) external onlyAdmin returns(bool success){\\n\\t\\tadmins[admin] = true;\\n\\t\\temit AdminSet(admin);\\n\\t\\treturn admins[admin];\\n\\t}\\n\\n\\tfunction removeAdmin(address admin) external onlyAdmin returns(bool success){\\n\\t\\tadmins[admin] = false;\\n\\t\\temit AdminRemoved(admin);\\n\\t\\treturn !admins[admin];\\n\\t}\\n\\n\\t// withdraw tokens stuck in the contract\\n\\tfunction withdraw(address returnee, address tokenAddress, uint256 amount)external onlyAdmin returns(bool success){\\n\\t\\tIERC20 token = IERC20(tokenAddress);\\n\\t\\tuint256 balance = token.balanceOf(address(this));\\n\\t\\trequire(balance \\u003e 0, \\\"There are no tokens to withdraw\\\");\\n\\t\\trequire(balance \\u003e= amount, \\\"Attempting to withdraw more tokens than available\\\");\\n\\t\\trequire(token.safeTransfer(returnee, amount) == true, \\\"Failed to transfer tokens\\\");\\n\\t\\temit Transfer(address(this), returnee, tokenAddress, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction sendEth(address[] memory recipients, uint256[] memory amounts) public payable returns (bool) {\\n\\t\\t// input validation\\n\\t\\trequire(recipients.length == amounts.length, \\\"Recipients array must have same length as amounts\\\");\\n\\n\\t\\t// count values for refunding sender\\n\\t\\tuint256 sentTotal = 0;\\n\\n\\t\\t// loop through recipients and send amount\\n\\t\\tfor (uint i = 0; i \\u003c recipients.length; i++) {\\n\\t\\t\\tsentTotal = sentTotal + amounts[i];\\n\\t\\t\\trequire(sentTotal \\u003c= msg.value, \\\"Ran out of funds. \\u0027value\\u0027 should be at least sum of amounts\\\");\\n\\t\\t\\trequire(recipients[i].send(amounts[i]), \\\"Failed to send\\\");\\n\\t\\t\\temit Transfer(msg.sender, recipients[i], address(0), amounts[i]);\\n\\t\\t}\\n\\t\\t// send back remaining value to sender\\n\\t\\tuint256 remainingValue = msg.value - sentTotal;\\n\\t\\tif (remainingValue \\u003e 0) {\\n\\t\\t\\trequire(msg.sender.send(remainingValue), \\\"Failed to send remaining back to self\\\");\\n\\t\\t\\temit Transfer(address(this), msg.sender, address(0), remainingValue);\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction sendErc20(address tokenAddress, address[] memory recipients, uint256[] memory amounts) public returns (bool) {\\n\\t\\t// input validation\\n\\t\\trequire(recipients.length == amounts.length, \\\"Recipients array must have same length as amounts\\\");\\n\\n\\t\\t// use the erc20 abi\\n\\t\\tIERC20 token = IERC20(tokenAddress);\\n\\n\\t\\t// check if contract is allowed to send total amount\\n\\t\\tuint256 total = 0;\\n\\t\\tfor (uint i = 0; i \\u003c recipients.length; i++) {\\n\\t\\t\\ttotal += amounts[i];\\n\\t\\t}\\n\\t\\trequire(token.allowance(msg.sender, address(this)) \\u003e= total, \\\"Insufficient token allowance\\\");\\n\\n\\t\\t// loop through recipients and send amount\\n\\t\\tfor (i = 0; i \\u003c recipients.length; i++) {\\n\\t\\t\\trequire(token.safeTransferFrom(msg.sender, recipients[i], amounts[i]) == true, \\\"Failed to transfer\\\");\\n\\t\\t\\temit Transfer(msg.sender, recipients[i], tokenAddress, amounts[i]);\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\nimport \\\"./IERC20.sol\\\";\\n/**\\n* @dev Library to perform safe calls to standard method for ERC20 tokens.\\n*\\n* Why Transfers: transfer methods could have a return value (bool), throw or revert for insufficient funds or\\n* unathorized value.\\n*\\n* Why Approve: approve method could has a return value (bool) or does not accept 0 as a valid value (BNB token).\\n* The common strategy used to clean approvals.\\n*\\n* We use the Solidity call instead of interface methods because in the case of transfer, it will fail\\n* for tokens with an implementation without returning a value.\\n* Since versions of Solidity 0.4.22 the EVM has a new opcode, called RETURNDATASIZE.\\n* This opcode stores the size of the returned data of an external call. The code checks the size of the return value\\n* after an external call and reverts the transaction in case the return data is shorter than expected\\n*/\\nlibrary SafeERC20 {\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param _token erc20 The address of the ERC20 contract\\n    * @param _to address The address which you want to transfer to\\n    * @param _value uint256 the _value of tokens to be transferred\\n    * @return bool whether the transfer was successful or not\\n    */\\n    function safeTransfer(IERC20 _token, address _to, uint256 _value) internal returns (bool) {\\n        uint256 prevBalance = _token.balanceOf(address(this));\\n\\n        if (prevBalance \\u003c _value) {\\n            // Insufficient funds\\n            return false;\\n        }\\n\\n        address(_token).call(\\n            abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", _to, _value)\\n        );\\n\\n        // Fail if the new balance its not equal than previous balance sub _value\\n        return prevBalance - _value == _token.balanceOf(address(this));\\n    }\\n\\n    /**\\n    * @dev Transfer tokens from one address to another\\n    * @param _token erc20 The address of the ERC20 contract\\n    * @param _from address The address which you want to send tokens from\\n    * @param _to address The address which you want to transfer to\\n    * @param _value uint256 the _value of tokens to be transferred\\n    * @return bool whether the transfer was successful or not\\n    */\\n    function safeTransferFrom(\\n        IERC20 _token,\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) internal returns (bool)\\n    {\\n        uint256 prevBalance = _token.balanceOf(_from);\\n\\n        if (\\n          prevBalance \\u003c _value || // Insufficient funds\\n          _token.allowance(_from, address(this)) \\u003c _value // Insufficient allowance\\n        ) {\\n            return false;\\n        }\\n\\n        address(_token).call(\\n            abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", _from, _to, _value)\\n        );\\n\\n        // Fail if the new balance its not equal than previous balance sub _value\\n        return prevBalance - _value == _token.balanceOf(_from);\\n    }\\n\\n   /**\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n   *\\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n   * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * @param _token erc20 The address of the ERC20 contract\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   * @return bool whether the approve was successful or not\\n   */\\n    function safeApprove(IERC20 _token, address _spender, uint256 _value) internal returns (bool) {\\n        address(_token).call(\\n            abi.encodeWithSignature(\\\"approve(address,uint256)\\\",_spender, _value)\\n        );\\n\\n        // Fail if the new allowance its not equal than _value\\n        return _token.allowance(address(this), _spender) == _value;\\n    }\\n\\n   /**\\n   * @dev Clear approval\\n   * Note that if 0 is not a valid value it will be set to 1.\\n   * @param _token erc20 The address of the ERC20 contract\\n   * @param _spender The address which will spend the funds.\\n   */\\n    function clearApprove(IERC20 _token, address _spender) internal returns (bool) {\\n        bool success = safeApprove(_token, _spender, 0);\\n\\n        if (!success) {\\n            success = safeApprove(_token, _spender, 1);\\n        }\\n\\n        return success;\\n    }\\n}\"}}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipients\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"sendEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"recipients\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"sendErc20\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"returnee\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "MultiSend", "CompilerVersion": "v0.4.23+commit.124ca40d", "OptimizationUsed": "1", "Runs": "200000", "ConstructorArguments": "", "EVMVersion": "byzantium", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://3919f74d6a87a6f9f9d7af416d1fe8af733d7f2f3dad4910edcd8157ea0fd5b5"}