{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakingRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint);\\r\\n\\r\\n    function transfer(address recipient, uint amount) external returns (bool);\\r\\n\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n}\\r\\n\\r\\n/// @title ERC20 Staking Contract.\\r\\n/// @author VAIOT team.\\r\\n/// @notice This contract allows for stake ERC20 tokens and receive ERC20 tokens as rewards\\r\\n/// @dev This contract allows for updating the duration of  reward period at any given moment\\r\\n\\r\\ncontract StakingRewards is ReentrancyGuard {\\r\\n    // ============= VARIABLES ============\\r\\n\\r\\n    // Contract address of the staked token\\r\\n    IERC20 public immutable stakingToken;\\r\\n    // Contract address of the rewards token\\r\\n    IERC20 public immutable rewardsToken;\\r\\n    // Address of the owner of the contract\\r\\n    address public owner;\\r\\n    // Duration of rewards to be paid out (in seconds)\\r\\n    uint public duration;\\r\\n    // Timestamp of when the rewards finish\\r\\n    uint public finishAt;\\r\\n    // Minimum of last updated time and reward finish time\\r\\n    uint public updatedAt;\\r\\n    // Reward to be paid out per second\\r\\n    uint public rewardRate;\\r\\n    // Sum of (reward rate * dt * 1e18 / total supply)\\r\\n    uint public rewardPerTokenStored;\\r\\n    // Total staked\\r\\n    uint public totalSupply;\\r\\n    // Max amount that people can stake\\r\\n    uint public MAX_AMOUNT_STAKE;\\r\\n    // The maximum amount of tokens in the staking pool\\r\\n    uint public MAX_NUM_OF_TOKENS_IN_POOL;\\r\\n    // Grace period duration for handling withdrawals\\r\\n    uint public GRACE_PERIOD;\\r\\n    // Fee collecting address from the \\\"withdraw immediately\\\" button\\r\\n    address public FEE_COLLECTING_WALLET;\\r\\n    // Fee amount as a intenger number (ex. 10% = 10)\\r\\n    uint public FEE_PERCENTAGE;\\r\\n\\r\\n    // ============= MAPPINGS ============\\r\\n    // User address => rewardPerTokenStored\\r\\n    mapping(address => uint) public userRewardPerTokenPaid;\\r\\n    // User address => rewards to be claimed\\r\\n    mapping(address => uint) public rewards;\\r\\n    // User address => staked amount\\r\\n    mapping(address => uint) public balanceOf;\\r\\n    // User address => timestamp when the withdrawal has been initiated\\r\\n    mapping(address => uint) public withdrawalInitiated;\\r\\n\\r\\n    /// @param _stakingToken - address of the staking token\\r\\n    /// @param _rewardToken - address of the reward token\\r\\n\\r\\n    constructor(\\r\\n        address _stakingToken,\\r\\n        address _rewardToken,\\r\\n        address _feeAddress\\r\\n    ) {\\r\\n        owner = msg.sender;\\r\\n        stakingToken = IERC20(_stakingToken);\\r\\n        rewardsToken = IERC20(_rewardToken);\\r\\n        MAX_AMOUNT_STAKE = 100000000000000000000000; // 100 000 tokens\\r\\n        MAX_NUM_OF_TOKENS_IN_POOL = 20000000000000000000000000; // 20 milion tokens\\r\\n        GRACE_PERIOD = 604800; // 604 800 seconds = 1 week\\r\\n        FEE_COLLECTING_WALLET = _feeAddress;\\r\\n        FEE_PERCENTAGE = 10;\\r\\n    }\\r\\n\\r\\n    // ============= MODIFIERS ============\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"not authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @notice Modifier that updates rewardPerTokenStored and userRewardPerTokenPaid\\r\\n    /// @param _account - address of the account that we wish to update rewards for\\r\\n\\r\\n    modifier updateReward(address _account) {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        updatedAt = lastTimeRewardApplicable();\\r\\n\\r\\n        if (_account != address(0)) {\\r\\n            rewards[_account] = earned(_account);\\r\\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\\r\\n        }\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // ============= MAIN FUNCTIONS ============\\r\\n\\r\\n    /// @notice Function that allows the user to initialize the withdrawal\\r\\n\\r\\n    function initializeWithdrawal()\\r\\n        external\\r\\n        nonReentrant\\r\\n        updateReward(msg.sender)\\r\\n    {\\r\\n        require(balanceOf[msg.sender] > 0, \\\"Nothing to withdraw\\\");\\r\\n        require(\\r\\n            withdrawalInitiated[msg.sender] == 0,\\r\\n            \\\"Withdrawal already initiated\\\"\\r\\n        );\\r\\n        withdrawalInitiated[msg.sender] = block.timestamp;\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows users to claim their tokens after the grace period has ended\\r\\n    /// @param _amount - amount of tokens to withdraw\\r\\n\\r\\n    function claimWithdrawal(\\r\\n        uint _amount\\r\\n    ) external nonReentrant updateReward(msg.sender) {\\r\\n        require(\\r\\n            withdrawalInitiated[msg.sender] > 0,\\r\\n            \\\"Withdrawal not initiated\\\"\\r\\n        );\\r\\n        require(\\r\\n            block.timestamp >= withdrawalInitiated[msg.sender] + GRACE_PERIOD,\\r\\n            \\\"Grace period not yet passed\\\"\\r\\n        );\\r\\n        require(balanceOf[msg.sender] > 0, \\\"Nothing to withdraw\\\");\\r\\n        require(_amount > 0, \\\"Withdrawal amount has to be greater than zero\\\");\\r\\n        require(balanceOf[msg.sender] >= _amount, \\\"Withdrawal is too high!\\\");\\r\\n\\r\\n        balanceOf[msg.sender] -= _amount;\\r\\n        totalSupply -= _amount;\\r\\n        withdrawalInitiated[msg.sender] = 0;\\r\\n        stakingToken.transfer(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows the user to withdraw immediately with a 10% fee\\r\\n    /// @param _amount - amount the tokens to withdraw\\r\\n\\r\\n    function withdrawImmediately(\\r\\n        uint _amount\\r\\n    ) external nonReentrant updateReward(msg.sender) {\\r\\n        require(balanceOf[msg.sender] > 0, \\\"Nothing to withdraw\\\");\\r\\n        require(_amount > 0, \\\"Withdrawal amount has to be greater than zero\\\");\\r\\n        require(balanceOf[msg.sender] >= _amount, \\\"Withdrawal is too high!\\\");\\r\\n        require(\\r\\n            withdrawalInitiated[msg.sender] == 0,\\r\\n            \\\"Withdrawal already initiated\\\"\\r\\n        );\\r\\n\\r\\n        balanceOf[msg.sender] -= _amount;\\r\\n        totalSupply -= _amount;\\r\\n        withdrawalInitiated[msg.sender] = 0;\\r\\n        stakingToken.transfer(\\r\\n            FEE_COLLECTING_WALLET,\\r\\n            (_amount * FEE_PERCENTAGE) / 100\\r\\n        );\\r\\n        stakingToken.transfer(\\r\\n            msg.sender,\\r\\n            (_amount * (100 - FEE_PERCENTAGE)) / 100\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows to calculate rewardPerTokenStored\\r\\n\\r\\n    function rewardPerToken() public view returns (uint) {\\r\\n        if (totalSupply == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n\\r\\n        return\\r\\n            rewardPerTokenStored +\\r\\n            (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18) /\\r\\n            totalSupply;\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows users to stake their tokens\\r\\n    /// @param _amount - amount of tokens to stake in WEI\\r\\n    /// @dev remember to approve the token first from the frontend\\r\\n    /// @dev when users stake tokens updateReward modifier is fired for them\\r\\n\\r\\n    function stake(\\r\\n        uint _amount\\r\\n    ) external nonReentrant updateReward(msg.sender) {\\r\\n        require(_amount > 0, \\\"amount = 0\\\");\\r\\n        require(\\r\\n            balanceOf[msg.sender] + _amount <= MAX_AMOUNT_STAKE,\\r\\n            \\\"Too much staked!\\\"\\r\\n        );\\r\\n        require(\\r\\n            totalSupply + _amount <= MAX_NUM_OF_TOKENS_IN_POOL,\\r\\n            \\\"Maximum number of tokens staked has been reached!\\\"\\r\\n        );\\r\\n        stakingToken.transferFrom(msg.sender, address(this), _amount);\\r\\n        balanceOf[msg.sender] += _amount;\\r\\n        totalSupply += _amount;\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows users to withdraw their winnings\\r\\n    /// @dev when users withdraw rewards updateReward modifier is fired for them\\r\\n\\r\\n    function withdrawReward() external nonReentrant updateReward(msg.sender) {\\r\\n        uint reward = rewards[msg.sender];\\r\\n        if (reward > 0) {\\r\\n            rewards[msg.sender] = 0;\\r\\n            rewardsToken.transfer(msg.sender, reward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows the owner to specify the rewards and duration for the next reward period\\r\\n    /// @param _amount - amount of tokens that will be given out as rewards during the given period\\r\\n    /// @param _duration - duration of the next reward period in seconds\\r\\n    /// @dev this function is a modified version of the Synthetix ERC20 Staking implementation - it allows\\r\\n    /// @dev the owner to change the duration before the last one ends - keep in mind in the next period it will give out\\r\\n    /// @dev the _amount + remaining rewards from the last period that were not given out\\r\\n\\r\\n    function notifyRewardAmount(\\r\\n        uint _amount,\\r\\n        uint _duration\\r\\n    ) external onlyOwner updateReward(address(0)) {\\r\\n        require(_amount > 0, \\\"amount must be greater than 0\\\");\\r\\n        bool success = rewardsToken.transferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            _amount\\r\\n        );\\r\\n        require(success, \\\"transfer was not successfull\\\");\\r\\n        if (duration == 0) {\\r\\n            duration = _duration;\\r\\n        }\\r\\n        if (block.timestamp >= finishAt) {\\r\\n            rewardRate = _amount / _duration;\\r\\n        } else {\\r\\n            uint remainingRewards = (finishAt - block.timestamp) * rewardRate;\\r\\n            rewardRate = (_amount + remainingRewards) / _duration;\\r\\n        }\\r\\n\\r\\n        require(rewardRate > 0, \\\"reward rate = 0\\\");\\r\\n        require(\\r\\n            rewardRate * _duration <= rewardsToken.balanceOf(address(this)),\\r\\n            \\\"reward amount > balance\\\"\\r\\n        );\\r\\n\\r\\n        duration = _duration;\\r\\n        finishAt = block.timestamp + duration;\\r\\n        updatedAt = block.timestamp;\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows the owner to change the user staking limit\\r\\n    /// @param _amount - the maximum amount a person can stake at once in WEI\\r\\n\\r\\n    function changeStakeLimit(uint _amount) public onlyOwner {\\r\\n        MAX_AMOUNT_STAKE = _amount;\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows the owner to change the pool staking limit\\r\\n    /// @param _amount - the maximum amount of tokens that the whole staking pool can stake in WEI\\r\\n\\r\\n    function changePoolLimit(uint _amount) public onlyOwner {\\r\\n        MAX_NUM_OF_TOKENS_IN_POOL = _amount;\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows the owner to change the grace period\\r\\n    /// @param _newGracePeriod - the new grace period in seconds\\r\\n\\r\\n    function changeGracePeriod(uint _newGracePeriod) public onlyOwner {\\r\\n        GRACE_PERIOD = _newGracePeriod;\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows the owner to change the fee collecting wallet\\r\\n    /// @param _newWallet - new wallet that will collect fees\\r\\n\\r\\n    function changeFeeCollectingWallet(address _newWallet) public onlyOwner {\\r\\n        FEE_COLLECTING_WALLET = _newWallet;\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows the owner to change the amount of fees collected\\r\\n    /// @param _amount - new amount of fees to collect\\r\\n\\r\\n    function changeFeeAmount(uint _amount) public onlyOwner {\\r\\n        FEE_PERCENTAGE = _amount;\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows the owner to return ERC20 tokens that were sent to the contract by accident\\r\\n    /// @param _tokenAddress - ERC20 address of the token\\r\\n    /// @param _tokenAmount - amount of tokens\\r\\n\\r\\n    function recoverERC20(\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenAmount\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            _tokenAddress != address(stakingToken),\\r\\n            \\\"Cannot withdraw the staking token\\\"\\r\\n        );\\r\\n        IERC20(_tokenAddress).transfer(owner, _tokenAmount);\\r\\n    }\\r\\n\\r\\n    /// @notice Function that allows you to change the ownership of the contract\\r\\n    /// @param _newOwner - address of the new owner of the contract\\r\\n\\r\\n    function transferOwnership(address _newOwner) external onlyOwner {\\r\\n        require(\\r\\n            _newOwner != address(0),\\r\\n            \\\"New owner cannot be the zero address!\\\"\\r\\n        );\\r\\n        owner = _newOwner;\\r\\n    }\\r\\n\\r\\n    // ============= UTILITY FUNCTIONS ============\\r\\n\\r\\n    function _min(uint x, uint y) private pure returns (uint) {\\r\\n        return x <= y ? x : y;\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() public view returns (uint) {\\r\\n        return _min(finishAt, block.timestamp);\\r\\n    }\\r\\n\\r\\n    // ============= GETTER FUNCTIONS ============\\r\\n\\r\\n    function getRewardRate() public view returns (uint) {\\r\\n        return rewardRate;\\r\\n    }\\r\\n\\r\\n    function getTotalSupply() public view returns (uint) {\\r\\n        return totalSupply;\\r\\n    }\\r\\n\\r\\n    function secondsLeftTillPoolEnds() public view returns (uint) {\\r\\n        return finishAt < block.timestamp ? 0 : finishAt - block.timestamp;\\r\\n    }\\r\\n\\r\\n    function earned(address _account) public view returns (uint) {\\r\\n        return\\r\\n            ((balanceOf[_account] *\\r\\n                (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e18) +\\r\\n            rewards[_account];\\r\\n    }\\r\\n\\r\\n    /// @notice This function does not take unclaimed rewards under consideration\\r\\n\\r\\n    function getTokensDepositedForRewards() public view returns (uint) {\\r\\n        uint balance = stakingToken.balanceOf(address(this));\\r\\n        return balance - totalSupply;\\r\\n    }\\r\\n\\r\\n    function getStakeLimit() public view returns (uint) {\\r\\n        return MAX_AMOUNT_STAKE;\\r\\n    }\\r\\n\\r\\n    function getPoolLimit() public view returns (uint) {\\r\\n        return MAX_NUM_OF_TOKENS_IN_POOL;\\r\\n    }\\r\\n\\r\\n    function getDuration() public view returns (uint) {\\r\\n        return duration;\\r\\n    }\\r\\n\\r\\n    function getFinishAt() public view returns (uint) {\\r\\n        return finishAt;\\r\\n    }\\r\\n\\r\\n    function getUpdatedAt() public view returns (uint) {\\r\\n        return updatedAt;\\r\\n    }\\r\\n\\r\\n    function getTimeLeftToWithdraw(address _addr) public view returns (uint) {\\r\\n        uint endingTimestamp = withdrawalInitiated[_addr];\\r\\n        if (endingTimestamp + GRACE_PERIOD > block.timestamp) {\\r\\n            return endingTimestamp + GRACE_PERIOD - block.timestamp;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FEE_COLLECTING_WALLET\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_AMOUNT_STAKE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_NUM_OF_TOKENS_IN_POOL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"changeFeeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"changeFeeCollectingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newGracePeriod\",\"type\":\"uint256\"}],\"name\":\"changeGracePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"changePoolLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"changeStakeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"claimWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFinishAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getTimeLeftToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensDepositedForRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUpdatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondsLeftTillPoolEnds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawImmediately\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawalInitiated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StakingRewards", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d13cfd3133239a3c73a9e535a5c4dadee36b395c000000000000000000000000d13cfd3133239a3c73a9e535a5c4dadee36b395c0000000000000000000000004fcd8ba9ad619db0e8116f363c2c71f1f146432a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}