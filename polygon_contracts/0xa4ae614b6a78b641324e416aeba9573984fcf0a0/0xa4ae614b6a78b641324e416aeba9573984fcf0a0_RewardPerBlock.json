{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/reward-per-block.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\nimport './access-control.sol';\\n\\n/**\\n * @dev Partial interface of the ERC20 standard according to the needs of the e2p contract.\\n */\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(\\n        address recipient, uint256 amount\\n    ) external returns (bool);\\n    function transferFrom(\\n        address sender, address recipient, uint256 amount\\n    ) external returns (bool);\\n    function allowance(\\n        address owner, address spender\\n    ) external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @dev Partial interface of the ERC20 standard according to the needs of the e2p contract.\\n */\\ninterface IBorrowingLending {\\n    function getBorrowingProfilesNumber () external view returns (uint256);\\n    function getTotalLent (\\n        uint256 borrowingProfileIndex\\n    ) external view returns (uint256);\\n    function getUserProfileLent (\\n        address userAddress, uint256 borrowingProfileIndex\\n    ) external view returns (uint256);\\n    function getUsdRate (\\n        address contractAddress\\n    ) external view returns (uint256);\\n}\\n\\n/**\\n * @dev Interface of the Proxy contract.\\n */\\ninterface IProxy {\\n    function getUsdRate (\\n        address contractAddress\\n    ) external view returns (uint256);\\n}\\n\\n\\n/**\\n * @dev Bonus reward based on the lent amount.\\n */\\ncontract RewardPerBlock is AccessControl {\\n    modifier onlyBorrowingLendingContract () {\\n        require(\\n            msg.sender == address(_borrowingLendingContract),\\n                'Caller is not the Borrowing Lending contract'\\n        );\\n        _;\\n    }\\n    struct Profile {\\n        uint256 rewardPerToken;\\n        uint256 lastTimestamp;\\n        uint256 rewardPercentage; // % * 100\\n        uint256 lastTotalLentAmount;\\n    }\\n    struct User {\\n        uint256 accumulatedReward;\\n        uint256 withdrawnReward;\\n        uint256 rewardPerTokenOffset;\\n        uint256 lastLentAmount;\\n        uint256 updatedAt;\\n    }\\n    mapping (uint256 => Profile) internal _profiles;\\n    // profileId => Profile data\\n    mapping (uint256 => uint256) internal _rewardPaid;\\n    // profileId => paid reward\\n    mapping (address => mapping (uint256 => uint256)) internal _userRewardPaid;\\n    // userAddress => profileId => paid reward\\n    mapping (address => mapping (uint256 => User)) internal _userProfiles;\\n    // userAddress => profileId => User data\\n    IERC20 internal _rewardToken;\\n    IBorrowingLending internal _borrowingLendingContract;\\n    IProxy _proxyContract;\\n    uint256 internal _duration;\\n    uint256 internal _endTime;\\n    uint256 internal _rewardPool;\\n    uint256 internal _blockTime; // in milliseconds\\n    uint256 internal constant SHIFT = 1 ether;\\n    uint256 internal constant YEAR = 365 * 24 * 3600;\\n    // used for exponent shifting for yieldPerToken calculation\\n    uint256 internal constant DECIMALS = 10000;\\n    // used for exponent shifting when calculation with decimals\\n\\n    constructor (\\n        address newOwner,\\n        address rewardTokenAddress,\\n        address blContractAddress,\\n        address proxyContractAddress,\\n        uint256 duration,\\n        uint256 rewardPool,\\n        uint256 blockTime\\n    ) {\\n        require(newOwner != address(0), 'Owner address can not be zero');\\n        require(\\n            rewardTokenAddress != address(0),\\n            'Reward token address can not be zero'\\n        );\\n        require(\\n            blContractAddress != address(0),\\n            'Borrowing Lending contract address can not be zero'\\n        );\\n        require(\\n            proxyContractAddress != address(0),\\n            'Proxy contract address can not be zero'\\n        );\\n        require(rewardPool > 0, 'Reward pool should be greater than zero');\\n        require(duration > 0, 'Duration should be greater than zero');\\n        require(blockTime > 0, 'Block time should be greater than zero');\\n        addToManagers(newOwner);\\n        transferOwnership(newOwner);\\n        _rewardToken = IERC20(rewardTokenAddress);\\n        _borrowingLendingContract = IBorrowingLending(blContractAddress);\\n        _proxyContract = IProxy(proxyContractAddress);\\n        _blockTime = blockTime;\\n        _rewardPool = rewardPool;\\n        _duration = duration;\\n        _endTime = block.timestamp + duration;\\n        uint256 profilesNumber = _borrowingLendingContract\\n        .getBorrowingProfilesNumber();\\n        uint256 totalPercentage;\\n        for (uint256 i = 1; i <= profilesNumber; i ++) {\\n            _profiles[i].lastTimestamp = block.timestamp;\\n            if (i == profilesNumber) {\\n                _profiles[i].rewardPercentage = DECIMALS - totalPercentage;\\n                break;\\n            }\\n            _profiles[i].rewardPercentage = DECIMALS / profilesNumber;\\n            totalPercentage += _profiles[i].rewardPercentage;\\n        }\\n    }\\n\\n    function withdrawReward () external returns (bool) {\\n        uint256 profilesNumber = _borrowingLendingContract\\n            .getBorrowingProfilesNumber();\\n        uint256 reward;\\n        for (uint256 i = 1; i <= profilesNumber; i ++) {\\n            uint256 lent = _borrowingLendingContract\\n                .getUserProfileLent(msg.sender, i);\\n            uint256 totalLent = _borrowingLendingContract\\n                .getTotalLent(i);\\n            _updateProfileReward (\\n                i\\n            );\\n            _updateUserProfileReward (\\n                msg.sender,\\n                i\\n            );\\n            _profiles[i].lastTotalLentAmount = totalLent;\\n            _userProfiles[msg.sender][i].lastLentAmount = lent;\\n            uint256 profileReward = _userProfiles[msg.sender][i].accumulatedReward\\n                - _userProfiles[msg.sender][i].withdrawnReward;\\n            _userProfiles[msg.sender][i].withdrawnReward\\n                += profileReward;\\n            _rewardPaid[i] += profileReward;\\n            _userRewardPaid[msg.sender][i] += profileReward;\\n            reward += profileReward;\\n        }\\n        _rewardToken.transfer(msg.sender, reward);\\n        return true;\\n    }\\n\\n    // manager function\\n    function setBlockTime (\\n        uint256 blockTime\\n    ) external onlyManager returns (bool) {\\n        require(blockTime > 0, 'Block time should be greater than zero');\\n        _blockTime = blockTime;\\n        return true;\\n    }\\n\\n    function setBorrowingContract (\\n        address blContractAddress\\n    ) external onlyManager returns (bool) {\\n        require(\\n            blContractAddress != address(0),\\n                'Borrowing Lending contract address can not be zero'\\n        );\\n        _borrowingLendingContract = IBorrowingLending(blContractAddress);\\n        return true;\\n    }\\n\\n    function setRewardPercentage (\\n        uint256[] memory percentage\\n    ) external onlyManager returns (bool) {\\n        _updateTotalReward();\\n        uint256 totalPercentage;\\n        for (uint256 i; i < percentage.length; i ++) {\\n            _profiles[i + 1].rewardPercentage = percentage[i];\\n            totalPercentage += percentage[i];\\n        }\\n        require(\\n            totalPercentage == 10000,\\n            'Total percentage should be equal 10000 (100%)'\\n        );\\n        return true;\\n    }\\n\\n    function setRewardData (\\n        uint256 duration,\\n        uint256 endTime,\\n        uint256 rewardPool\\n    ) external onlyManager returns (bool) {\\n        _duration = duration;\\n        _endTime = endTime;\\n        _rewardPool = rewardPool;\\n        return true;\\n    }\\n\\n    function setProxyContract (\\n        address proxyContractAddress\\n    ) external onlyManager returns (bool) {\\n        _proxyContract = IProxy(proxyContractAddress);\\n        return true;\\n    }\\n\\n    function setProfilesTotalLent () external onlyManager returns (bool) {\\n        uint256 profilesNumber = _borrowingLendingContract\\n            .getBorrowingProfilesNumber();\\n        for (uint256 i = 1; i <= profilesNumber; i ++) {\\n            uint256 totalLent = _borrowingLendingContract\\n                .getTotalLent(i);\\n            _profiles[i].lastTotalLentAmount = totalLent;\\n            _profiles[i].lastTimestamp = block.timestamp;\\n        }\\n        return true;\\n    }\\n\\n    function setUserProfilesLent (\\n        address[] calldata userAddresses\\n    ) external onlyManager returns (bool) {\\n        uint256 profilesNumber = _borrowingLendingContract\\n            .getBorrowingProfilesNumber();\\n        for (uint256 i = 0; i < userAddresses.length; i ++) {\\n            for (uint256 j = 1; j <= profilesNumber; j ++) {\\n                uint256 lent = _borrowingLendingContract\\n                    .getUserProfileLent(userAddresses[i], j);\\n                _userProfiles[userAddresses[i]][j].lastLentAmount = lent;\\n                _userProfiles[userAddresses[i]][j].updatedAt = block.timestamp;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    // admin functions\\n    function adminWithdrawToken (\\n        uint256 amount, address tokenAddress\\n    ) external onlyOwner returns (bool) {\\n        require(tokenAddress != address(0), 'Token address can not be zero');\\n        IERC20 tokenContract = IERC20(tokenAddress);\\n        uint256 balance = tokenContract.balanceOf(address(this));\\n        require(amount <= balance, 'Not enough contract balance');\\n        tokenContract.transfer(msg.sender, amount);\\n        return true;\\n    }\\n\\n    function _updateTotalReward () internal returns (bool) {\\n        uint256 profilesNumber = _borrowingLendingContract\\n            .getBorrowingProfilesNumber();\\n        for (uint256 i = 1; i <= profilesNumber; i ++) {\\n            uint256 totalLent = _borrowingLendingContract\\n                .getTotalLent(i);\\n            _updateProfileReward(\\n                i\\n            );\\n            _profiles[i].lastTotalLentAmount = totalLent;\\n        }\\n        return true;\\n    }\\n\\n    function _updateProfileReward (\\n        uint256 profileId\\n    ) internal returns (bool) {\\n        uint256 currentTimestamp = block.timestamp;\\n        if (currentTimestamp > _endTime) {\\n            currentTimestamp = _endTime;\\n        }\\n        if (_profiles[profileId].lastTimestamp == 0) {\\n            _profiles[profileId].lastTimestamp = currentTimestamp;\\n            return true;\\n        }\\n        if (_profiles[profileId].lastTotalLentAmount == 0) {\\n            _profiles[profileId].lastTimestamp = currentTimestamp;\\n            return true;\\n        }\\n        if (_profiles[profileId].rewardPercentage == 0) {\\n            _profiles[profileId].lastTimestamp = currentTimestamp;\\n            return true;\\n        }\\n        uint256 endTime = currentTimestamp;\\n        uint256 period = endTime\\n            - _profiles[profileId].lastTimestamp;\\n        if (period == 0) return true;\\n\\n        uint256 profileRewardPerToken = SHIFT\\n            * _rewardPool\\n            * period\\n            * _profiles[profileId].rewardPercentage\\n            / _duration\\n            / DECIMALS\\n            / _profiles[profileId].lastTotalLentAmount;\\n        _profiles[profileId].rewardPerToken += profileRewardPerToken;\\n        _profiles[profileId].lastTimestamp = currentTimestamp;\\n        return true;\\n    }\\n\\n    function _updateUserProfileReward (\\n        address userAddress,\\n        uint256 profileId\\n    ) internal returns (bool) {\\n        if (_profiles[profileId].lastTotalLentAmount == 0) {\\n            _userProfiles[userAddress][profileId].updatedAt =\\n                _profiles[profileId].lastTimestamp;\\n            return true;\\n        }\\n        uint256 accumulatedReward = (\\n            _profiles[profileId].rewardPerToken\\n                - _userProfiles[userAddress][profileId].rewardPerTokenOffset\\n        ) * _userProfiles[userAddress][profileId].lastLentAmount / SHIFT;\\n        _userProfiles[userAddress][profileId].accumulatedReward\\n            += accumulatedReward;\\n        _userProfiles[userAddress][profileId].rewardPerTokenOffset\\n            = _profiles[profileId].rewardPerToken;\\n        _userProfiles[userAddress][profileId].updatedAt =\\n            _profiles[profileId].lastTimestamp;\\n        return true;\\n    }\\n\\n    function updateRewardData (\\n        address userAddress,\\n        uint256 profileId,\\n        uint256 lent,\\n        uint256 totalLent\\n    ) external onlyBorrowingLendingContract returns (bool) {\\n        _updateProfileReward (\\n            profileId\\n        );\\n        _updateUserProfileReward(\\n            userAddress,\\n            profileId\\n        );\\n        _profiles[profileId].lastTotalLentAmount = totalLent;\\n        _userProfiles[userAddress][profileId].lastLentAmount = lent;\\n        return true;\\n    }\\n\\n    // view functions\\n    function getTokenBalance (\\n        address tokenAddress\\n    ) external view returns (uint256) {\\n        IERC20 tokenContract = IERC20(tokenAddress);\\n        return tokenContract.balanceOf(address(this));\\n    }\\n\\n    function getRewardToken () external view returns (address) {\\n        return address(_rewardToken);\\n    }\\n\\n    function getProfile (\\n        uint256 profileId\\n    ) external view returns (\\n        uint256 rewardPerToken,\\n        uint256 lastTimestamp,\\n        uint256 rewardPercentage,\\n        uint256 lastTotalLentAmount\\n    ) {\\n        return (\\n            _profiles[profileId].rewardPerToken,\\n            _profiles[profileId].lastTimestamp,\\n            _profiles[profileId].rewardPercentage,\\n            _profiles[profileId].lastTotalLentAmount\\n        );\\n    }\\n\\n    function getUserProfile (\\n        address userAddress,\\n        uint256 profileId\\n    ) external view returns (\\n        uint256 accumulatedReward,\\n        uint256 withdrawnReward,\\n        uint256 rewardPerTokenOffset,\\n        uint256 lastLentAmount,\\n        uint256 updatedAt\\n    ) {\\n        return (\\n            _userProfiles[userAddress][profileId].accumulatedReward,\\n            _userProfiles[userAddress][profileId].withdrawnReward,\\n            _userProfiles[userAddress][profileId].rewardPerTokenOffset,\\n            _userProfiles[userAddress][profileId].lastLentAmount,\\n            _userProfiles[userAddress][profileId].updatedAt\\n        );\\n    }\\n\\n    function getRewardPercentage (\\n        uint256 profileId\\n    ) external view returns (uint256) {\\n        return _profiles[profileId].rewardPercentage;\\n    }\\n\\n    function getRewardData () external view returns (\\n        uint256 duration,\\n        uint256 endTime,\\n        uint256 rewardPool\\n    ) {\\n        return (_duration, _endTime, _rewardPool);\\n    }\\n\\n    function getProxyContractAddress () external view returns (address) {\\n        return address(_proxyContract);\\n    }\\n\\n    function getRewardPaid(\\n        uint256 profileId\\n    ) external view returns (uint256) {\\n        return _rewardPaid[profileId];\\n    }\\n\\n    function getUserRewardPaid(\\n        address userAddress,\\n        uint256 profileId\\n    ) external view returns (uint256) {\\n        return _userRewardPaid[userAddress][profileId];\\n    }\\n\\n    function calculateProfileReward (\\n        address userAddress,\\n        uint256 profileId,\\n        bool accumulated\\n    ) public view returns (uint256) {\\n        uint256 lent = _borrowingLendingContract\\n            .getUserProfileLent(userAddress, profileId);\\n        uint256 totalLent = _borrowingLendingContract\\n            .getTotalLent(profileId);\\n        uint256 reward = _calculateProfileReward(\\n            userAddress, profileId, lent, totalLent\\n        );\\n        if (accumulated) {\\n            reward += (\\n                _userProfiles[userAddress][profileId].accumulatedReward\\n                    - _userProfiles[userAddress][profileId].withdrawnReward\\n            );\\n        }\\n        return reward;\\n    }\\n\\n    function calculateReward (\\n        address userAddress, bool accumulated\\n    ) external view returns (uint256) {\\n        uint256 profilesNumber = _borrowingLendingContract\\n            .getBorrowingProfilesNumber();\\n        uint256 reward;\\n        for (uint256 i = 1; i <= profilesNumber; i ++) {\\n            reward += calculateProfileReward(\\n                userAddress,\\n                i,\\n                accumulated\\n            );\\n        }\\n        return reward;\\n    }\\n\\n    function _calculateProfileReward (\\n        address userAddress,\\n        uint256 profileId,\\n        uint256 lent,\\n        uint256 totalLent\\n    ) internal view returns (uint256) {\\n        if (_profiles[profileId].rewardPercentage == 0) return 0;\\n        if (lent == 0) return 0;\\n        uint256 extraPeriodStartTime\\n            = _profiles[profileId].lastTimestamp;\\n        if (\\n            extraPeriodStartTime <\\n                _userProfiles[userAddress][profileId].updatedAt\\n        ) {\\n            extraPeriodStartTime = _userProfiles[userAddress][profileId].updatedAt;\\n        }\\n        uint256 endTime = block.timestamp;\\n        if (endTime > _endTime) {\\n            endTime = _endTime;\\n        }\\n        uint256 extraPeriod;\\n        if (endTime > extraPeriodStartTime) {\\n            extraPeriod = endTime - extraPeriodStartTime;\\n        }\\n        uint256 rewardPerToken = _profiles[profileId].rewardPerToken;\\n        if (extraPeriod > 0) {\\n            rewardPerToken += SHIFT\\n                * _rewardPool\\n                * extraPeriod\\n                * _profiles[profileId].rewardPercentage\\n                / _duration\\n                / totalLent\\n                / DECIMALS;\\n        }\\n        uint256 reward = (\\n            rewardPerToken - _userProfiles[userAddress][profileId]\\n                .rewardPerTokenOffset\\n        ) * lent / SHIFT;\\n        return reward;\\n    }\\n\\n    function getBlockTime() external view returns (uint256) {\\n        return _blockTime;\\n    }\\n\\n    function getBorrowingContract() external view returns (address) {\\n        return address(_borrowingLendingContract);\\n    }\\n\\n    function getTimestamp() external view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n     * Calculate current APR (depends on totalLent)\\n     * uint256 apr = DECIMALS // shift decimals point\\n     *    * (_rewardPool * rewardTokenUsdRate / SHIFT) // reward amount in USD\\n     *    * (_profiles[profileId].rewardPercentage / DECIMALS) // exact profile part\\n     *    / (_duration / YEAR) // duration in years\\n     *    / totalLent;\\n     */\\n    function getProfileApr(\\n        uint256 profileId\\n    ) external view returns (uint256) {\\n        uint256 rewardTokenUsdRate = _proxyContract\\n            .getUsdRate(address(_rewardToken));\\n        uint256 totalLent = _borrowingLendingContract\\n            .getTotalLent(profileId);\\n        if (totalLent == 0) return 0;\\n        uint256 apr = _rewardPool\\n            * rewardTokenUsdRate\\n            * _profiles[profileId].rewardPercentage\\n            * YEAR\\n            / SHIFT\\n            / _duration\\n            / totalLent;\\n        return apr;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access-control.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\n/**\\n * @dev Access control contract,\\n * functions names are self explanatory\\n */\\nabstract contract AccessControl {\\n    modifier onlyOwner() {\\n        require(msg.sender == _owner, 'Caller is not the owner');\\n        _;\\n    }\\n    modifier onlyManager() {\\n        require(_managers[msg.sender], 'Caller is not the manager');\\n        _;\\n    }\\n\\n    mapping (address => bool) private _managers;\\n    address private _owner;\\n\\n    constructor () {\\n        _owner = msg.sender;\\n        _managers[_owner] = true;\\n    }\\n\\n    // admin functions\\n    function transferOwnership(address newOwner) public onlyOwner returns (bool) {\\n        require(newOwner != address(0), 'newOwner should not be zero address');\\n        _owner = newOwner;\\n        return true;\\n    }\\n\\n    function addToManagers (\\n        address userAddress\\n    ) public onlyOwner returns (bool) {\\n        _managers[userAddress] = true;\\n        return true;\\n    }\\n\\n    function removeFromManagers (\\n        address userAddress\\n    ) public onlyOwner returns (bool) {\\n        _managers[userAddress] = false;\\n        return true;\\n    }\\n\\n    /**\\n     * @dev If true - user has manager role\\n     */\\n    function isManager (\\n        address userAddress\\n    ) external view returns (bool) {\\n        return _managers[userAddress];\\n    }\\n\\n    /**\\n     * @dev Owner address getter\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"blContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proxyContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"addToManagers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"adminWithdrawToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"accumulated\",\"type\":\"bool\"}],\"name\":\"calculateProfileReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"accumulated\",\"type\":\"bool\"}],\"name\":\"calculateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBorrowingContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"}],\"name\":\"getProfile\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardPerToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTotalLentAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"}],\"name\":\"getProfileApr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProxyContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"}],\"name\":\"getRewardPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"}],\"name\":\"getRewardPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"}],\"name\":\"getUserProfile\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"accumulatedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerTokenOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastLentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"}],\"name\":\"getUserRewardPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"removeFromManagers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"setBlockTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blContractAddress\",\"type\":\"address\"}],\"name\":\"setBorrowingContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setProfilesTotalLent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxyContractAddress\",\"type\":\"address\"}],\"name\":\"setProxyContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPool\",\"type\":\"uint256\"}],\"name\":\"setRewardData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"percentage\",\"type\":\"uint256[]\"}],\"name\":\"setRewardPercentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"userAddresses\",\"type\":\"address[]\"}],\"name\":\"setUserProfilesLent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLent\",\"type\":\"uint256\"}],\"name\":\"updateRewardData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RewardPerBlock", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005011f31d9969fb0b31766435829df66afa04d6fa000000000000000000000000015c425f6dfabc31e1464cc4339954339f096061000000000000000000000000d7bac58d0555215c5f05f166d39cbf706c9883430000000000000000000000006da88dce0ad9f850d4f1b5c147815c492e7a6ded0000000000000000000000000000000000000000000000000000000001e133800000000000000000000000000000000000000000000422ca8b0a00a4250000000000000000000000000000000000000000000000000000000000000000000bb8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}