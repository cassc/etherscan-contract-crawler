{"SourceCode": "// File: xvmc-contracts/libs/poolLibraries.sol\r\n\r\n\r\n\r\npragma solidity 0.6.12;\r\n//openZeppelin contracts(also used by Pancakeswap).\r\n//modified IERC20 and SafeERC20(using transferXVMC instead of standard transferFrom)\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    \r\n\t//transfers XVMC without allowance\r\n    function transferXVMC(address _sender, address _recipient, uint256 _amount) external returns (bool);\r\n\t\r\n\t//returns owner address\r\n\tfunction owner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferXVMC.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance =\r\n            token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: xvmc-contracts/pools/1year.sol\r\n\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface IMasterChef {\r\n    function deposit(uint256 _pid, uint256 _amount) external;\r\n    function withdraw(uint256 _pid, uint256 _amount) external;\r\n    function pendingEgg(uint256 _pid, address _user) external view returns (uint256);\r\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\r\n    function emergencyWithdraw(uint256 _pid) external;\r\n    function feeAddress() external view returns (address);\r\n    function owner() external view returns (address);\r\n}\r\n\r\ninterface IacPool {\r\n    function hopDeposit(uint256 _amount, address _recipientAddress, uint256 previousLastDepositedTime, uint256 _mandatoryTime) external;\r\n    function getUserShares(address wallet) external view returns (uint256);\r\n    function getNrOfStakes(address _user) external view returns (uint256);\r\n\tfunction giftDeposit(uint256 _amount, address _toAddress, uint256 _minToServeInSecs) external;\r\n}\r\n\r\ninterface IGovernance {\r\n    function costToVote() external view returns (uint256);\r\n    function rebalancePools() external;\r\n    function getRollBonus(address _bonusForPool) external view returns (uint256);\r\n    function stakeRolloverBonus(address _toAddress, address _depositToPool, uint256 _bonusToPay, uint256 _stakeID) external;\r\n\tfunction treasuryWallet() external view returns (address);\r\n}\r\ninterface IVoting {\r\n    function addCredit(uint256 amount, address _beneficiary) external;\r\n}\r\n\r\n\r\n/**\r\n * XVMC time-locked deposit\r\n * Auto-compounding pool\r\n * !!! Warning: !!! Licensed under Business Source License 1.1 (BSL 1.1)\r\n */\r\ncontract XVMCtimeDeposit is ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    struct UserInfo {\r\n        uint256 shares; // number of shares for a user\r\n        uint256 lastDepositedTime; // keeps track of deposited time for potential penalty\r\n        uint256 xvmcAtLastUserAction; // keeps track of XVMC deposited at the last user action\r\n        uint256 lastUserActionTime; // keeps track of the last user action time\r\n        uint256 mandatoryTimeToServe; // optional: disables early withdraw\r\n    }\r\n\t//allows stakes to be transferred, similar to token transfers\r\n\tstruct StakeTransfer {\r\n\t\tuint256 shares; // ALLOWANCE of shares\r\n        uint256 lastDepositedTime;\r\n        uint256 mandatoryTimeToServe; \r\n\t}\r\n\r\n    IERC20 public immutable token; // XVMC token\r\n\t\r\n\tIERC20 public immutable oldToken = IERC20(0x6d0c966c8A09e354Df9C48b446A474CE3343D912);\r\n    \r\n    IERC20 public immutable dummyToken; \r\n\r\n    IMasterChef public masterchef;  \r\n    \r\n    uint256 public immutable withdrawFeePeriod = 365 days;\r\n    uint256 public immutable gracePeriod = 14 days;\r\n\r\n    mapping(address => UserInfo[]) public userInfo;\r\n    mapping(address => uint256) public userVote; //the ID the user is voting for\r\n    mapping(uint256 => uint256) public totalVotesForID; //total votes for a given ID\r\n\tmapping(address => address) public userDelegate; //user can delegate their voting to another wallet\r\n\t\r\n\tmapping(address => bool) public trustedSender; //Pools with shorter lockup duration(trustedSender(contracts) can transfer into this pool)\r\n\tmapping(address => bool) public trustedPool; //Pools with longer lockup duration(can transfer from this pool into trustedPool(contracts))\r\n\t\r\n\tmapping(address => mapping(address => StakeTransfer[])) private _stakeAllowances; \r\n\t//similar to token allowances, difference being it's not for amount of tokens, but for a specific stake defined by shares, latdeposittime and mandatorytime\r\n\r\n\tuint256 public poolID; \r\n    uint256 public totalShares;\r\n    address public admin; //admin = governing contract!\r\n    address public treasury; //penalties go to this address\r\n    address public migrationPool; //if pools are to change\r\n\t\r\n\taddress public votingCreditAddress;\r\n\t\r\n\tuint256 public minimumGift = 1000000 * 1e18;\r\n\tbool public updateMinGiftGovernor = true; //allows automatic update by anybody to costToVote from governing contract\r\n    \r\n    uint256 public callFee = 5; // call fee paid for rebalancing pools\r\n\t\r\n\tbool public allowStakeTransfer = true; //enable/disable transferring of stakes to another wallet\r\n\tbool public allowStakeTransferFrom = false; //allow third party transfers(disabled initially)\r\n\t\r\n\tbool public partialWithdrawals = true; //partial withdrawals from stakes\r\n\tbool public partialTransfers = true; //allows transferring a portion of  a stake\r\n\t\r\n\tbool public allowOrigin = true; //(dis)allows tx.origin for voting\r\n\t//safe to use tx.origin IMO. Can be disabled and use msg.sender instead\r\n\t//it allows the voting and delegating in a single transaction for all pools through a proxy contract\r\n\t\r\n\t// Easier to verify (opposed to checking event logs)\r\n\tuint256 public trustedSenderCount;\r\n\tuint256 public trustedPoolCount;\r\n\r\n    event Deposit(address indexed sender, uint256 amount, uint256 shares, uint256 lastDepositedTime);\r\n    event GiftDeposit(address indexed sender, address indexed recipient, uint256 amount, uint256 shares, uint256 lastDepositedTime);\r\n    event AddAndExtendStake(address indexed sender, address indexed recipient, uint256 amount, uint256 stakeID, uint256 shares, uint256 lastDepositedTime);\r\n    event Withdraw(address indexed sender, uint256 amount, uint256 penalty, uint256 shares);\r\n    \r\n\tevent TransferStake(address indexed sender, address indexed recipient, uint256 shares, uint256 stakeID);\r\n    event HopPool(address indexed sender, uint256 XVMCamount, uint256 shares, address indexed newPool);\r\n    event MigrateStake(address indexed goodSamaritan, uint256 XVMCamount, uint256 shares, address indexed recipient);\r\n   \r\n    event HopDeposit(address indexed recipient, uint256 amount, uint256 shares, uint256 previousLastDepositedTime, uint256 mandatoryTime);\r\n\t\r\n    event RemoveVotes(address indexed voter, uint256 proposalID, uint256 change);\r\n    event AddVotes(address indexed voter, uint256 proposalID, uint256 change);\r\n\t\r\n\tevent TrustedSender(address contractAddress, bool setting);\r\n\tevent TrustedPool(address contractAddress, bool setting);\r\n\t\r\n\tevent StakeApproval(address owner, address spender, uint256 allowanceID, uint256 shareAllowance, uint256 lastDeposit, uint256 mandatoryTime);\r\n\tevent StakeAllowanceRevoke(address owner, address spender, uint256 allowanceID);\r\n\tevent TransferStakeFrom(address _from, address _to, uint256 _stakeID, uint256 _allowanceID);\r\n\t\r\n\tevent SetDelegate(address userDelegating, address delegatee);\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _token: XVMC token contract\r\n     * @param _dummyToken: Dummy token contract\r\n     * @param _masterchef: MasterChef contract\r\n     * @param _admin: address of the admin\r\n     * @param _treasury: address of the treasury (collects fees)\r\n     */\r\n    constructor(\r\n        IERC20 _token,\r\n        IERC20 _dummyToken,\r\n        IMasterChef _masterchef,\r\n        address _admin,\r\n        address _treasury,\r\n        uint256 _poolID\r\n    ) public {\r\n        token = _token;\r\n        dummyToken = _dummyToken;\r\n        masterchef = _masterchef;\r\n        admin = _admin;\r\n        treasury = _treasury;\r\n        poolID = _poolID;\r\n\r\n        IERC20(_dummyToken).safeApprove(address(_masterchef), uint256(-1));\r\n    }\r\n    \r\n    /**\r\n     * @notice Checks if the msg.sender is the admin\r\n     */\r\n    modifier adminOnly() {\r\n        require(msg.sender == admin, \"admin: wut?\");\r\n        _;\r\n    }\r\n\t\r\n    /**\r\n     * @notice Deposits funds into the XVMC time-locked vault\r\n     * @param _amount: number of tokens to deposit (in XVMC)\r\n     * \r\n     * Creates a NEW stake\r\n     */\r\n    function deposit(uint256 _amount) external nonReentrant {\r\n    \trequire(_amount > 0, \"Nothing to deposit\");\r\n\t\r\n        uint256 pool = balanceOf();\r\n        token.safeTransferFrom(msg.sender, address(this), _amount);\r\n        uint256 currentShares = 0;\r\n        if (totalShares != 0) {\r\n            currentShares = (_amount.mul(totalShares)).div(pool);\r\n        } else {\r\n            currentShares = _amount;\r\n        }\r\n        \r\n        totalShares = totalShares.add(currentShares);\r\n        \r\n        userInfo[msg.sender].push(\r\n                UserInfo(currentShares, block.timestamp, _amount, block.timestamp, 0)\r\n            );\r\n        \r\n\t\tuint256 votingFor = userVote[msg.sender];\r\n        if(votingFor != 0) {\r\n            _updateVotingAddDiff(msg.sender, votingFor, currentShares);\r\n        }\r\n\r\n        emit Deposit(msg.sender, _amount, currentShares, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * Equivalent to Deposit\r\n     * Instead of crediting the msg.sender, it credits custom recipient\r\n     * A mechanism to gift a time-locked stake to another wallet\r\n     * Users can withdraw at any time(but will pay a penalty)\r\n     * Optionally stake can be irreversibly locked for a minimum period of time(minToServe)\r\n     */\r\n    function giftDeposit(uint256 _amount, address _toAddress, uint256 _minToServeInSecs) external nonReentrant {\r\n        require(_amount >= minimumGift, \"Below Minimum Gift\");\r\n\r\n        uint256 pool = balanceOf();\r\n        token.safeTransferFrom(msg.sender, address(this), _amount);\r\n        uint256 currentShares = 0;\r\n        if (totalShares != 0) {\r\n            currentShares = (_amount.mul(totalShares)).div(pool);\r\n        } else {\r\n            currentShares = _amount;\r\n        }\r\n        \r\n        totalShares = totalShares.add(currentShares);\r\n        \r\n        userInfo[_toAddress].push(\r\n                UserInfo(currentShares, block.timestamp, _amount, block.timestamp, _minToServeInSecs)\r\n            );\r\n\t\t\t\r\n        uint256 votingFor = userVote[_toAddress];\r\n        if(votingFor != 0) {\r\n            _updateVotingAddDiff(_toAddress, votingFor, currentShares);\r\n        }\r\n\r\n        emit GiftDeposit(msg.sender, _toAddress, _amount, currentShares, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @notice Deposits funds into the XVMC time-locked vault\r\n     * @param _amount: number of tokens to deposit (in XVMC)\r\n     * \r\n     * Deposits into existing stake, effectively extending the stake\r\n     * It's used for rolling over stakes by the governor(admin) as well\r\n     * Mandatory Lock Up period can only be Increased\r\n\t * It can be Decreased if stake is being extended(after it matures)\r\n     */\r\n    function addAndExtendStake(address _recipientAddr, uint256 _amount, uint256 _stakeID, uint256 _lockUpTokensInSeconds) external nonReentrant {\r\n        require(_amount > 0, \"Nothing to deposit\");\r\n        require(userInfo[_recipientAddr].length > _stakeID, \"wrong Stake ID\");\r\n        \r\n        if(msg.sender != admin) { require(_recipientAddr == msg.sender, \"can only extend your own stake\"); }\r\n\r\n        uint256 pool = balanceOf();\r\n        token.safeTransferFrom(msg.sender, address(this), _amount);\r\n        uint256 currentShares = 0;\r\n        if (totalShares != 0) {\r\n            currentShares = (_amount.mul(totalShares)).div(pool);\r\n        } else {\r\n            currentShares = _amount;\r\n        }\r\n        UserInfo storage user = userInfo[_recipientAddr][_stakeID];\r\n\r\n        user.shares = user.shares.add(currentShares);\r\n        totalShares = totalShares.add(currentShares);\r\n        \r\n        if(_lockUpTokensInSeconds > user.mandatoryTimeToServe || \r\n\t\t\t\tblock.timestamp > user.lastDepositedTime.add(withdrawFeePeriod)) { \r\n\t\t\tuser.mandatoryTimeToServe = _lockUpTokensInSeconds; \r\n\t\t}\r\n\t\t\r\n        user.xvmcAtLastUserAction = user.shares.mul(balanceOf()).div(totalShares);\r\n        user.lastUserActionTime = block.timestamp;\r\n\t\tuser.lastDepositedTime = block.timestamp;\r\n        \r\n\t\tuint256 votingFor = userVote[_recipientAddr];\r\n        if(votingFor != 0) {\r\n            _updateVotingAddDiff(_recipientAddr, votingFor, currentShares);\r\n        }\r\n\r\n        emit AddAndExtendStake(msg.sender, _recipientAddr, _amount, _stakeID, currentShares, block.timestamp);\r\n    }\r\n \r\n\r\n    function withdrawAll(uint256 _stakeID) external {\r\n        withdraw(userInfo[msg.sender][_stakeID].shares, _stakeID);\r\n    }\r\n\r\n\t\r\n    /**\r\n     * Harvest pending rewards from masterchef\r\n\t * Governor pays the rewards for harvesting and rebalancing\r\n     */\r\n    function harvest() external {\r\n        IMasterChef(masterchef).withdraw(poolID, 0);\r\n    }\r\n\r\n    \r\n    /**\r\n     * @notice Sets admin address and treasury\r\n     * If new governor is set, anyone can pay the gas to update the addresses\r\n\t * Masterchef owns the token, the governor owns the Masterchef\r\n\t * Treasury is feeAddress from masterchef(which collects fees from deposits into masterchef)\r\n\t * Currently all penalties are going to fee address(currently governing contract)\r\n\t * Alternatively, fee address can be set as a separate contract, which would re-distribute\r\n\t * The tokens back into pool(so honest stakers would directly receive penalties from prematurely ended stakes)\r\n\t * Alternatively could also split: a portion to honest stakers, a portion into governing contract. \r\n\t * With initial setting, all penalties are going towards governing contract\r\n     */\r\n    function setAdmin() external {\r\n        admin = IMasterChef(masterchef).owner();\r\n        treasury = IMasterChef(masterchef).feeAddress();\r\n    }\r\n\t\r\n\t//updates minimum gift to costToVote from Governing contract\r\n\tfunction updateMinimumGift() external {\r\n\t\trequire(updateMinGiftGovernor, \"automatic update disabled\");\r\n\t\tminimumGift = IGovernance(admin).costToVote();\r\n\t}\r\n\r\n    /**\r\n     * @notice Withdraws from funds from the XVMC time-locked vault\r\n     * @param _shares: Number of shares to withdraw\r\n     */\r\n    function withdraw(uint256 _shares, uint256 _stakeID) public {\r\n        require(_stakeID < userInfo[msg.sender].length, \"invalid stake ID\");\r\n        UserInfo storage user = userInfo[msg.sender][_stakeID];\r\n        require(_shares > 0, \"Nothing to withdraw\");\r\n        require(_shares <= user.shares, \"Withdraw amount exceeds balance\");\r\n        require(block.timestamp > user.lastDepositedTime.add(user.mandatoryTimeToServe), \"must serve mandatory time\");\r\n        if(!partialWithdrawals) { require(_shares == user.shares, \"must transfer full stake\"); }\r\n\r\n        uint256 currentAmount = (balanceOf().mul(_shares)).div(totalShares);\r\n        user.shares = user.shares.sub(_shares);\r\n        totalShares = totalShares.sub(_shares);\r\n\r\n        uint256 currentWithdrawFee = 0;\r\n        \r\n        if (block.timestamp < user.lastDepositedTime.add(withdrawFeePeriod)) {\r\n           uint256 withdrawFee = uint256(5000).sub(((block.timestamp - user.lastDepositedTime).div(86400)).mul(1337).div(100));\r\n            currentWithdrawFee = currentAmount.mul(withdrawFee).div(10000);\r\n            token.safeTransfer(treasury, currentWithdrawFee); \r\n            currentAmount = currentAmount.sub(currentWithdrawFee);\r\n        } else if(block.timestamp > user.lastDepositedTime.add(withdrawFeePeriod).add(gracePeriod)) {\r\n            uint256 withdrawFee = block.timestamp.sub(user.lastDepositedTime.add(withdrawFeePeriod)).div(86400).mul(1337).div(100);\r\n            if(withdrawFee > 5000) { withdrawFee = 5000; }\r\n            currentWithdrawFee = currentAmount.mul(withdrawFee).div(10000);\r\n            token.safeTransfer(treasury, currentWithdrawFee); \r\n            currentAmount = currentAmount.sub(currentWithdrawFee);\r\n        }\r\n\r\n        if (user.shares > 0) {\r\n            user.xvmcAtLastUserAction = user.shares.mul(balanceOf().sub(currentAmount)).div(totalShares);\r\n            user.lastUserActionTime = block.timestamp;\r\n        } else {\r\n            _removeStake(msg.sender, _stakeID); //delete the stake\r\n        }\r\n        \r\n\t\tuint256 votingFor = userVote[msg.sender];\r\n        if(votingFor != 0) {\r\n            _updateVotingSubDiff(msg.sender, votingFor, _shares);\r\n        }\r\n\r\n\t\temit Withdraw(msg.sender, currentAmount, currentWithdrawFee, _shares);\r\n\t\t\r\n        token.safeTransfer(msg.sender, currentAmount);\r\n    } \r\n    \r\n    /**\r\n     * Users can transfer their stake to another pool\r\n     * Can only transfer to pool with longer lock-up period(trusted pools)\r\n     * Equivalent to withdrawing, but it deposits the stake into another pool as hopDeposit\r\n     * Users can transfer stake without penalty\r\n     * Time served gets transferred \r\n     * The pool is \"registered\" as a \"trustedSender\" to another pool\r\n     */\r\n    function hopStakeToAnotherPool(uint256 _shares, uint256 _stakeID, address _poolAddress) public {\r\n        require(_shares > 0, \"Nothing to withdraw\");\r\n\t\trequire(_stakeID < userInfo[msg.sender].length, \"wrong stake ID\");\r\n\t\t\r\n        UserInfo storage user = userInfo[msg.sender][_stakeID];\r\n\t\trequire(_shares <= user.shares, \"Withdraw amount exceeds balance\");\r\n        if(!partialWithdrawals) { require(_shares == user.shares, \"must transfer full stake\"); } \r\n        \r\n\t\tuint256 _lastDepositedTime = user.lastDepositedTime;\r\n        if(trustedPool[_poolAddress]) { \r\n\t\t\tif(block.timestamp > _lastDepositedTime.add(withdrawFeePeriod).add(gracePeriod)) {\r\n\t\t\t\t_lastDepositedTime = block.timestamp; //if after grace period, resets timer\r\n\t\t\t}\r\n        } else { \r\n\t\t\t//can only hop into trusted Pools or into trusted sender(lower pool) after time has been served within grace period\r\n\t\t\t//only meant for stakeRollover. After hop, stake is extended and timer reset\r\n            require(trustedSender[_poolAddress] && block.timestamp > _lastDepositedTime.add(withdrawFeePeriod) &&\r\n                                block.timestamp < _lastDepositedTime.add(withdrawFeePeriod).add(gracePeriod),\r\n                                        \"can only hop into pre-set Pools\");\r\n\t\t}\r\n\r\n        uint256 currentAmount = (balanceOf().mul(_shares)).div(totalShares);\r\n        user.shares = user.shares.sub(_shares);\r\n        totalShares = totalShares.sub(_shares);\r\n\t\t\r\n\t\tuint256 votingFor = userVote[msg.sender];\r\n        if(votingFor != 0) {\r\n            _updateVotingSubDiff(msg.sender, votingFor, _shares);\r\n        }\r\n\t\t\r\n\t\tIacPool(_poolAddress).hopDeposit(currentAmount, msg.sender, _lastDepositedTime, user.mandatoryTimeToServe);\r\n\t\t//_poolAddress can only be trusted pool(contract)\r\n\r\n        if (user.shares > 0) {\r\n            user.xvmcAtLastUserAction = user.shares.mul(balanceOf()).div(totalShares);\r\n            user.lastUserActionTime = block.timestamp;\r\n        } else {\r\n            _removeStake(msg.sender, _stakeID); //delete the stake\r\n        }\r\n        \r\n        emit HopPool(msg.sender, currentAmount, _shares, _poolAddress);\r\n    }\r\n\r\n    \r\n    /**\r\n     * hopDeposit is equivalent to gift deposit, exception being that the time served can be passed\r\n     * The msg.sender can only be a trusted contract\r\n     * The checks are already made in the hopStakeToAnotherPool function\r\n     * msg sender can only be trusted senders\r\n     */\r\n     \r\n    function hopDeposit(uint256 _amount, address _recipientAddress, uint256 previousLastDepositedTime, uint256 _mandatoryTime) external {\r\n        require(trustedSender[msg.sender] || trustedPool[msg.sender], \"only trusted senders(other pools)\");\r\n\t\t//only trustedSenders allowed. TrustedPools are under condition that the stake has matured(hopStake checks condition)\r\n        \r\n        uint256 pool = balanceOf();\r\n        token.safeTransferFrom(msg.sender, address(this), _amount);\r\n        uint256 currentShares = 0;\r\n        if (totalShares != 0) {\r\n            currentShares = (_amount.mul(totalShares)).div(pool);\r\n        } else {\r\n            currentShares = _amount;\r\n        }\r\n        \r\n        totalShares = totalShares.add(currentShares);\r\n        \r\n        userInfo[_recipientAddress].push(\r\n                UserInfo(currentShares, previousLastDepositedTime, _amount,\r\n                    block.timestamp, _mandatoryTime)\r\n            );\r\n\r\n\t\tuint256 votingFor = userVote[_recipientAddress];\r\n        if(votingFor != 0) {\r\n            _updateVotingAddDiff(_recipientAddress, votingFor, currentShares);\r\n        }\r\n\r\n        emit HopDeposit(_recipientAddress, _amount, currentShares, previousLastDepositedTime, _mandatoryTime);\r\n    }\r\n\t\r\n    /**\r\n     * Users are encouraged to keep staking\r\n     * Governor pays bonuses to re-commit and roll over your stake\r\n     * Higher bonuses available for hopping into pools with longer lockup period\r\n     */\r\n    function stakeRollover(address _poolInto, uint256 _stakeID) external {\r\n        require(userInfo[msg.sender].length > _stakeID, \"invalid stake ID\");\r\n        \r\n        UserInfo storage user = userInfo[msg.sender][_stakeID];\r\n        \r\n        require(block.timestamp > user.lastDepositedTime.add(withdrawFeePeriod), \"stake not yet mature\");\r\n        \r\n        uint256 currentAmount = (balanceOf().mul(user.shares)).div(totalShares); \r\n        uint256 toPay = currentAmount.mul(IGovernance(admin).getRollBonus(_poolInto)).div(10000);\r\n\r\n        require(IERC20(token).balanceOf(admin) >= toPay, \"governor reserves are currently insufficient\");\r\n        \r\n        if(_poolInto == address(this)) {\r\n            IGovernance(admin).stakeRolloverBonus(msg.sender, _poolInto, toPay, _stakeID); //gov sends tokens to extend the stake\r\n        } else {\r\n\t\t\thopStakeToAnotherPool(user.shares, _stakeID, _poolInto); //will revert if pool is wrong\r\n\t\t\tIGovernance(admin).stakeRolloverBonus(msg.sender, _poolInto, toPay, IacPool(_poolInto).getNrOfStakes(msg.sender) - 1); //extends latest stake\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Transfer stake to another account(another wallet address)\r\n     */\r\n    function transferStakeToAnotherWallet(uint256 _shares, uint256 _stakeID, address _recipientAddress) external {\r\n        require(allowStakeTransfer, \"transfers disabled\");\r\n\t\trequire(_recipientAddress != msg.sender, \"can't transfer to self\");\r\n        require(_stakeID < userInfo[msg.sender].length, \"wrong stake ID\");\r\n        UserInfo storage user = userInfo[msg.sender][_stakeID];\r\n\t\tuint256 _tokensTransferred = _shares.mul(balanceOf()).div(totalShares);\r\n        require(_tokensTransferred >= minimumGift, \"Below minimum threshold\");\r\n        require(_shares <= user.shares, \"Withdraw amount exceeds balance\");\r\n        if(!partialTransfers) { require(_shares == user.shares, \"must transfer full stake\"); }\r\n        \r\n        user.shares = user.shares.sub(_shares);\r\n\r\n\t\tuint256 votingFor = userVote[msg.sender];\r\n        if(votingFor != 0) {\r\n            _updateVotingSubDiff(msg.sender, votingFor, _shares);\r\n        }\r\n\t\tvotingFor = userVote[_recipientAddress];\r\n        if(votingFor != 0) {\r\n            _updateVotingAddDiff(_recipientAddress, votingFor, _shares);\r\n        }\r\n        \r\n        userInfo[_recipientAddress].push(\r\n                UserInfo(_shares, user.lastDepositedTime, _tokensTransferred, block.timestamp, user.mandatoryTimeToServe)\r\n            );\r\n\r\n        if (user.shares > 0) {\r\n            user.xvmcAtLastUserAction = user.shares.mul(balanceOf()).div(totalShares);\r\n            user.lastUserActionTime = block.timestamp;\r\n        } else {\r\n            _removeStake(msg.sender, _stakeID); //delete the stake\r\n        }\r\n\r\n        emit TransferStake(msg.sender, _recipientAddress, _shares, _stakeID);\r\n    }\r\n\r\n    /**\r\n     * user delegates their shares to cast a vote on a proposal\r\n     * casting to proposal ID = 0 is basically neutral position (not voting)\r\n\t * Is origin is allowed, proxy contract can be used to vote in all pools in a single tx\r\n     */\r\n    function voteForProposal(uint256 proposalID) external {\r\n        address _wallet;\r\n\t\tallowOrigin ? _wallet = tx.origin : _wallet = msg.sender;\r\n        uint256 votingFor = userVote[_wallet]; //the ID the user is voting for(before change)\r\n\t\t\r\n        if(proposalID != votingFor) { // do nothing if false(already voting for that ID)\r\n\t\r\n\t\t\tuint256 userTotalShares = getUserTotalShares(_wallet);\r\n\t\t\tif(userTotalShares > 0) { //if false, no shares, thus just assign proposal ID to userVote\r\n\t\t\t\tif(proposalID != 0) { // Allocates vote to an ID\r\n\t\t\t\t\tif(votingFor == 0) { //starts voting, adds votes\r\n\t\t\t\t\t\t_updateVotingAddDiff(_wallet, proposalID, userTotalShares);\r\n\t\t\t\t\t} else { //removes from previous vote, adds to new\r\n\t\t\t\t\t\t_updateVotingSubDiff(_wallet, votingFor, userTotalShares);\r\n\t\t\t\t\t\t_updateVotingAddDiff(_wallet, proposalID, userTotalShares);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { //stops voting (previously voted, now going into neutral (=0)\r\n\t\t\t\t\t_updateVotingSubDiff(_wallet, votingFor, userTotalShares);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tuserVote[_wallet] = proposalID;\r\n\t\t}\r\n    }\r\n\t\r\n\t/*\r\n\t* delegatee can vote with shares of another user\r\n\t*/\r\n    function delegateeVote(address[] calldata votingAddress, uint256 proposalID) external {\r\n        for(uint256 i = 0; i < votingAddress.length; i++) { \r\n\t\t\tif(userDelegate[votingAddress[i]] == msg.sender) {\r\n\t\t\t\tuint256 votingFor = userVote[votingAddress[i]]; //the ID the user is voting for(before change)\r\n\t\t\t\t\r\n\t\t\t\tif(proposalID != votingFor){\r\n\t\t\t\t\r\n\t\t\t\t\tuint256 userTotalShares = getUserTotalShares(votingAddress[i]);\r\n\t\t\t\t\tif(userTotalShares > 0) {\r\n\t\t\t\t\t\tif(proposalID != 0) { \r\n\t\t\t\t\t\t\tif(votingFor == 0) {\r\n\t\t\t\t\t\t\t\t_updateVotingAddDiff(votingAddress[i], proposalID, userTotalShares);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t_updateVotingSubDiff(votingAddress[i], votingFor, userTotalShares);\r\n\t\t\t\t\t\t\t\t_updateVotingAddDiff(votingAddress[i], proposalID, userTotalShares);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t_updateVotingSubDiff(votingAddress[i], votingFor, userTotalShares);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tuserVote[votingAddress[i]] = proposalID;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n\t\r\n     /**\r\n     * Users can delegate their shares\r\n     */\r\n    function setDelegate(address _delegate) external {\r\n        address _wallet;\r\n\t\tallowOrigin ? _wallet=tx.origin : _wallet=msg.sender;\r\n        userDelegate[_wallet] = _delegate;\r\n        \r\n\t\temit SetDelegate(_wallet, _delegate);\r\n    }\r\n\t\r\n\t//allows third party stake transfer(stake IDs can be changed, so instead of being identified through ID, it's identified by shares, lastdeposit and mandatory time\r\n    function giveStakeAllowance(address spender, uint256 _stakeID) external {\r\n\t\tUserInfo storage user = userInfo[msg.sender][_stakeID];\r\n\t\trequire(user.shares.mul(balanceOf()).div(totalShares) >= minimumGift, \"below minimum threshold\");\r\n\t\t\r\n\t\tuint256 _allowanceID = _stakeAllowances[msg.sender][spender].length;\r\n\r\n\t\t_stakeAllowances[msg.sender][spender].push(\r\n\t\t\tStakeTransfer(user.shares, user.lastDepositedTime, user.mandatoryTimeToServe)\r\n\t\t);\r\n\t\t\r\n\t\temit StakeApproval(msg.sender, spender, _allowanceID, user.shares, user.lastDepositedTime, user.mandatoryTimeToServe);\r\n    }\r\n\t\r\n    //Note: allowanceID (and not ID of the stake!)\r\n\tfunction revokeStakeAllowance(address spender, uint256 allowanceID) external {\r\n\t\tStakeTransfer[] storage allowances = _stakeAllowances[msg.sender][spender];\r\n        uint256 lastAllowanceID = allowances.length.sub(1);\r\n        \r\n        if(allowanceID != lastAllowanceID) {\r\n            allowances[allowanceID] = allowances[lastAllowanceID];\r\n        }\r\n        \r\n        allowances.pop();\r\n\t\t\r\n\t\temit StakeAllowanceRevoke(msg.sender, spender, allowanceID);\r\n\t}\r\n\t\r\n    function nrOfstakeAllowances(address owner, address spender) public view returns (uint256) {\r\n        return _stakeAllowances[owner][spender].length;\r\n    }\r\n\t\r\n    function stakeAllowances(address owner, address spender, uint256 allowanceID) public view returns (uint256, uint256, uint256) {\r\n        StakeTransfer storage stakeStore = _stakeAllowances[owner][spender][allowanceID];\r\n        return (stakeStore.shares, stakeStore.lastDepositedTime, stakeStore.mandatoryTimeToServe);\r\n    }\r\n\t\r\n    /**\r\n     * A third party can transfer the stake(allowance required)\r\n\t * Allows smart contract inter-operability similar to how regular tokens work\r\n\t * Can only transfer full stake (You can split the stake through other methods)\r\n\t * Bad: makes illiquid stakes liquid\r\n\t * I think best is to have the option, but leave it unavailable unless desired\r\n     */\r\n    function transferStakeFrom(address _from, uint256 _stakeID, uint256 allowanceID, address _to) external returns (bool) {\r\n        require(allowStakeTransferFrom, \"third party stake transfers disabled\");\r\n\t\t\r\n\t\trequire(_from != _to, \"can't transfer to self\");\r\n        require(_stakeID < userInfo[_from].length, \"wrong stake ID\");\r\n        UserInfo storage user = userInfo[_from][_stakeID];\r\n\t\t\r\n\t\t(uint256 _shares, uint256 _lastDeposit, uint256 _mandatoryTime) = stakeAllowances(_from, msg.sender, allowanceID);\r\n\r\n\t\t//since stake ID can change, the stake to transfer is identified through number of shares, last deposit and mandatory time\r\n\t\t//checks if stake allowance(for allowanceID) matches the actual stake of a user\r\n\t\trequire(_shares == user.shares, \"incorrect stake or allowance\");\r\n\t\trequire(_lastDeposit == user.lastDepositedTime, \"incorrect stake or allowance\");\r\n\t\trequire(_mandatoryTime == user.mandatoryTimeToServe, \"incorrect stake or allowance\");\r\n     \r\n\t\tuint256 votingFor = userVote[_from];\r\n        if(votingFor != 0) {\r\n            _updateVotingSubDiff(_from, votingFor, _shares);\r\n        }\r\n\t\tvotingFor = userVote[_to];\r\n        if(votingFor != 0) {\r\n            _updateVotingAddDiff(_to, votingFor, _shares);\r\n        }\r\n\r\n        _removeStake(_from, _stakeID); //transfer from must transfer full stake\r\n\t\t_revokeStakeAllowance(_from, allowanceID);\r\n\t\t\r\n        userInfo[_to].push(\r\n                UserInfo(_shares, _lastDeposit, _shares.mul(balanceOf()).div(totalShares),\r\n                    block.timestamp, _mandatoryTime)\r\n            );\r\n\r\n        emit TransferStakeFrom(_from, _to, _stakeID, allowanceID);\r\n\t\t\r\n\t\treturn true;\r\n    }\r\n\r\n\t/**\r\n     * Ability to withdraw tokens from the stake, and add voting credit\r\n     * At the time of launch there is no option(voting with credit), but can be added later on\r\n    */\r\n\tfunction votingCredit(uint256 _shares, uint256 _stakeID) public {\r\n        require(votingCreditAddress != address(0), \"disabled\");\r\n        require(_stakeID < userInfo[msg.sender].length, \"invalid stake ID\");\r\n        UserInfo storage user = userInfo[msg.sender][_stakeID];\r\n        require(_shares > 0, \"Nothing to withdraw\");\r\n        require(_shares <= user.shares, \"Withdraw amount exceeds balance\");\r\n\r\n        uint256 currentAmount = (balanceOf().mul(_shares)).div(totalShares);\r\n        user.shares = user.shares.sub(_shares);\r\n        totalShares = totalShares.sub(_shares);\r\n\r\n        if (user.shares > 0) {\r\n            user.xvmcAtLastUserAction = user.shares.mul(balanceOf().sub(currentAmount)).div(totalShares);\r\n            user.lastUserActionTime = block.timestamp;\r\n        } else {\r\n            _removeStake(msg.sender, _stakeID); //delete the stake\r\n        }\r\n\r\n\t\tuint256 votingFor = userVote[msg.sender];\r\n        if(votingFor != 0) {\r\n            _updateVotingSubDiff(msg.sender, votingFor, _shares);\r\n        }\r\n\r\n\t\temit Withdraw(votingCreditAddress, currentAmount, 0, _shares);\r\n\r\n        token.safeTransfer(votingCreditAddress, currentAmount);\r\n\t\tIVoting(votingCreditAddress).addCredit(currentAmount, msg.sender); //in the votingCreditAddress regulate how much is credited, depending on where it's coming from (msg.sender)\r\n    } \r\n\t\r\n    /**\r\n\t * Allows the pools to be changed to new contracts\r\n     * if migration Pool is set\r\n     * anyone can be a \"good Samaritan\"\r\n     * and transfer the stake of another user to the new pool\r\n     */\r\n    function migrateStake(address _staker, uint256 _stakeID) public {\r\n        require(migrationPool != address(0), \"migration not activated\");\r\n        require(_stakeID < userInfo[_staker].length, \"invalid stake ID\");\r\n        UserInfo storage user = userInfo[_staker][_stakeID];\r\n\t\trequire(user.shares > 0, \"no balance\");\r\n        \r\n        uint256 currentAmount = (balanceOf().mul(user.shares)).div(totalShares);\r\n        totalShares = totalShares.sub(user.shares);\r\n\t\t\r\n        user.shares = 0; // equivalent to deleting the stake. Pools are no longer to be used,\r\n\t\t\t\t\t\t//setting user shares to 0 is sufficient\r\n\t\t\r\n\t\tIacPool(migrationPool).hopDeposit(currentAmount, _staker, user.lastDepositedTime, user.mandatoryTimeToServe);\r\n\r\n        emit MigrateStake(msg.sender, currentAmount, user.shares, _staker);\r\n    }\r\n\r\n    /**\r\n     * loop and migrate all user stakes\r\n     * could run out of gas if too many stakes\r\n     */\r\n    function migrateAllStakes(address _staker) external {\r\n        UserInfo[] storage user = userInfo[_staker];\r\n        uint256 userStakes = user.length;\r\n        \r\n        for(uint256 i=0; i < userStakes; i++) {\r\n            migrateStake(_staker, i);\r\n        }\r\n    }\r\n\t\r\n    \r\n    /**\r\n     * Returns number of stakes for a user\r\n     */\r\n    function getNrOfStakes(address _user) external view returns (uint256) {\r\n        return userInfo[_user].length;\r\n    }\r\n    \r\n    /**\r\n     * Returns all shares for a user\r\n     */\r\n    function getUserTotalShares(address _user) public view returns (uint256) {\r\n        UserInfo[] storage _stake = userInfo[_user];\r\n        uint256 nrOfUserStakes = _stake.length;\r\n\r\n\t\tuint256 countShares = 0;\r\n\t\t\r\n\t\tfor(uint256 i=0; i < nrOfUserStakes; i++) {\r\n\t\t\tcountShares += _stake[i].shares;\r\n\t\t}\r\n\t\t\r\n\t\treturn countShares;\r\n    }\r\n\t\r\n    /**\r\n     * @notice Calculates the expected harvest reward from third party\r\n     * @return Expected reward to collect in XVMC\r\n     */\r\n    function calculateHarvestXVMCRewards() external view returns (uint256) {\r\n        uint256 amount = IMasterChef(masterchef).pendingEgg(poolID, address(this));\r\n        uint256 currentCallFee = amount.mul(callFee).div(10000);\r\n\r\n        return currentCallFee;\r\n    }\r\n\r\n    /**\r\n     * @return Returns total pending xvmc rewards\r\n     */\r\n    function calculateTotalPendingXVMCRewards() external view returns (uint256) {\r\n        uint256 amount = IMasterChef(masterchef).pendingEgg(poolID, address(this));\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the price per share\r\n     */\r\n    function getPricePerFullShare() external view returns (uint256) {\r\n        return totalShares == 0 ? 1e18 : balanceOf().mul(1e18).div(totalShares);\r\n    }\r\n    \r\n    /**\r\n     * @notice returns number of shares for a certain stake of an user\r\n     */\r\n    function getUserShares(address _wallet, uint256 _stakeID) public view returns (uint256) {\r\n        return userInfo[_wallet][_stakeID].shares;\r\n    }\r\n\t\r\n    /**\r\n     * @notice Calculates the total underlying tokens\r\n     * @dev It includes tokens held by the contract and held in MasterChef\r\n     */\r\n    function balanceOf() public view returns (uint256) {\r\n        uint256 amount = IMasterChef(masterchef).pendingEgg(poolID, address(this)); \r\n        return token.balanceOf(address(this)).add(amount); \r\n    }\r\n\t\r\n    \r\n\t//enables or disables ability to draw stake from another wallet(allowance required)\r\n\tfunction enableDisableStakeTransferFrom(bool _setting) external adminOnly {\r\n\t\tallowStakeTransferFrom = _setting;\r\n\t}\r\n\r\n    /**\r\n     * @notice Sets call fee \r\n     * @dev Only callable by the contract admin.\r\n     */\r\n    function setCallFee(uint256 _callFee) external adminOnly {\r\n        callFee = _callFee;\r\n    }\r\n\r\n     /*\r\n     * set trusted senders, other pools that we can receive from (that can hopDeposit)\r\n     * guaranteed to be trusted (they rely lastDepositTime)\r\n     */\r\n    function setTrustedSender(address _sender, bool _setting) external adminOnly {\r\n        if(trustedSender[_sender] != _setting) {\r\n\t\t\ttrustedSender[_sender] = _setting;\r\n\t\t\t\r\n\t\t\t_setting ? trustedSenderCount++ : trustedSenderCount--;\r\n\r\n\t\t\temit TrustedSender(_sender, _setting);\r\n\t\t}\r\n    }\r\n    \r\n     /**\r\n     * set trusted pools, the smart contracts that we can send the tokens to without penalty\r\n\t * NOTICE: new pool must be set as trusted contract(to be able to draw balance without allowance)\r\n     */\r\n    function setTrustedPool(address _pool, bool _setting) external adminOnly {\r\n        if(trustedPool[_pool] != _setting) {\r\n\t\t\ttrustedPool[_pool] = _setting;\r\n\t\t\t\r\n\t\t\t_setting ? trustedPoolCount++ : trustedPoolCount--;\r\n\r\n\t\t\temit TrustedPool(_pool, _setting);\r\n\t\t}\r\n    }\r\n\r\n\r\n     /**\r\n     * set address of new pool that we can migrate into\r\n\t * !!! NOTICE !!!\r\n     *  new pool must be set as trusted contract in the token contract by the governor(to be able to draw balance without allowance)\r\n     */\r\n    function setMigrationPool(address _newPool) external adminOnly {\r\n\t\tmigrationPool = _newPool;\r\n    }\r\n    \r\n     /**\r\n     * Enable or disable partial withdrawals from stakes\r\n     */\r\n    function modifyPartialWithdrawals(bool _decision) external adminOnly {\r\n        partialWithdrawals = _decision;\r\n    }\r\n\tfunction modifyPartialTransfers(bool _decision) external adminOnly {\r\n        partialTransfers = _decision;\r\n    }\r\n\t\r\n\tfunction enableDisableStakeTransfer(bool _setting) external adminOnly {\r\n\t\tallowStakeTransfer = _setting;\r\n\t}\r\n\r\n    /**\r\n     * @notice Withdraws from MasterChef to Vault without caring about rewards.\r\n     * @dev EMERGENCY ONLY. Only callable by the contract admin.\r\n     */\r\n    function emergencyWithdraw() external adminOnly {\r\n        IMasterChef(masterchef).emergencyWithdraw(poolID);\r\n        token.safeTransfer(admin, token.balanceOf(address(this)));\r\n    }\r\n\t\r\n\t/*\r\n\t * Unlikely, but Masterchef can be changed if needed to be used without changing pools\r\n\t * masterchef = IMasterChef(token.owner());\r\n\t * Must stop earning first(withdraw tokens from old chef)\r\n\t*/\r\n\tfunction setMasterChefAddress(IMasterChef _masterchef, uint256 _newPoolID) external adminOnly {\r\n\t\tmasterchef = _masterchef;\r\n\t\tpoolID = _newPoolID; //in case pool ID changes\r\n\t\t\r\n\t\tuint256 _dummyAllowance = IERC20(dummyToken).allowance(address(this), address(masterchef));\r\n\t\tif(_dummyAllowance == 0) {\r\n\t\t\tIERC20(dummyToken).safeApprove(address(_masterchef), type(uint256).max);\r\n\t\t}\r\n\t}\r\n\t\r\n    /**\r\n     * When contract is launched, dummyToken shall be deposited to start earning rewards\r\n     */\r\n    function startEarning() external adminOnly {\r\n\t\tIMasterChef(masterchef).deposit(poolID, dummyToken.balanceOf(address(this)));\r\n    }\r\n\t\r\n    /**\r\n     * Dummy token can be withdrawn if ever needed(allows for flexibility)\r\n     */\r\n\tfunction stopEarning(uint256 _withdrawAmount) external adminOnly {\r\n\t\tif(_withdrawAmount == 0) { \r\n\t\t\tIMasterChef(masterchef).withdraw(poolID, dummyToken.balanceOf(address(masterchef)));\r\n\t\t} else {\r\n\t\t\tIMasterChef(masterchef).withdraw(poolID, _withdrawAmount);\r\n\t\t}\r\n\t}\r\n\t\r\n    /**\r\n     * Withdraws dummyToken to owner(who can burn it if needed)\r\n     */\r\n    function withdrawDummy(uint256 _amount) external adminOnly {\t\r\n        if(_amount == 0) { \r\n\t\t\tdummyToken.safeTransfer(admin, dummyToken.balanceOf(address(this)));\r\n\t\t} else {\r\n\t\t\tdummyToken.safeTransfer(admin, _amount);\r\n\t\t}\r\n    }\r\n\t\r\n\tfunction allowTxOrigin(bool _setting) external adminOnly {\r\n\t\tallowOrigin = _setting;\r\n\t}\r\n\t\r\n\t//sets minimum amount(for sending gift, transferring to another wallet,...)\r\n\t//if setting is enabled, minimumGift can be auto-updated to costToVote from governor by anybody\r\n\tfunction setMinimumGiftDeposit(uint256 _amount, bool _setting) external adminOnly {\r\n\t\tminimumGift = _amount;\r\n\t\tupdateMinGiftGovernor = _setting;\r\n\t}\r\n\t\r\n    function regulateVotingCredit(address _newAddress) external adminOnly {\r\n        votingCreditAddress = _newAddress;\r\n    }\r\n\t\r\n\t/**\r\n\t * option to withdraw wrongfully sent tokens(but requires change of the governing contract to do so)\r\n\t * If you send wrong tokens to the contract address, consider them lost. Though there is possibility of recovery\r\n\t */\r\n\tfunction withdrawStuckTokens(address _tokenAddress) external adminOnly {\r\n\t\trequire(_tokenAddress != address(token), \"wrong token\");\r\n\t\trequire(_tokenAddress != address(dummyToken), \"wrong token\");\r\n\t\t\r\n\t\tIERC20(_tokenAddress).safeTransfer(IGovernance(admin).treasuryWallet(), IERC20(_tokenAddress).balanceOf(address(this)));\r\n\t}\r\n\t\r\n\t\r\n    //Note: allowanceID (and not ID of the stake!)\r\n\tfunction _revokeStakeAllowance(address owner, uint256 allowanceID) private {\r\n\t\tStakeTransfer[] storage allowances = _stakeAllowances[owner][msg.sender];\r\n        uint256 lastAllowanceID = allowances.length.sub(1);\r\n        \r\n        if(allowanceID != lastAllowanceID) {\r\n            allowances[allowanceID] = allowances[lastAllowanceID];\r\n        }\r\n        \r\n        allowances.pop();\r\n\t\t\r\n\t\temit StakeAllowanceRevoke(owner, msg.sender, allowanceID);\r\n\t}\r\n\t\r\n    /**\r\n     * updates votes(whenever there is transfer of funds)\r\n     */\r\n    function _updateVotingAddDiff(address voter, uint256 proposalID, uint256 diff) private {\r\n        totalVotesForID[proposalID] = totalVotesForID[proposalID].add(diff);\r\n        \r\n        emit AddVotes(voter, proposalID, diff);\r\n    }\r\n    function _updateVotingSubDiff(address voter, uint256 proposalID, uint256 diff) private {\r\n        totalVotesForID[proposalID] = totalVotesForID[proposalID].sub(diff);\r\n        \r\n        emit RemoveVotes(voter, proposalID, diff);\r\n    }\r\n    \r\n    /**\r\n     * removes the stake\r\n     */\r\n    function _removeStake(address _staker, uint256 _stakeID) private {\r\n        UserInfo[] storage stakes = userInfo[_staker];\r\n        uint256 lastStakeID = stakes.length - 1;\r\n        \r\n        if(_stakeID != lastStakeID) {\r\n            stakes[_stakeID] = stakes[lastStakeID];\r\n        }\r\n        \r\n        stakes.pop();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_dummyToken\",\"type\":\"address\"},{\"internalType\":\"contract IMasterChef\",\"name\":\"_masterchef\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolID\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastDepositedTime\",\"type\":\"uint256\"}],\"name\":\"AddAndExtendStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"change\",\"type\":\"uint256\"}],\"name\":\"AddVotes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastDepositedTime\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastDepositedTime\",\"type\":\"uint256\"}],\"name\":\"GiftDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousLastDepositedTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mandatoryTime\",\"type\":\"uint256\"}],\"name\":\"HopDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"XVMCamount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPool\",\"type\":\"address\"}],\"name\":\"HopPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"goodSamaritan\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"XVMCamount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"MigrateStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"change\",\"type\":\"uint256\"}],\"name\":\"RemoveVotes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userDelegating\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"SetDelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allowanceID\",\"type\":\"uint256\"}],\"name\":\"StakeAllowanceRevoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allowanceID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareAllowance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mandatoryTime\",\"type\":\"uint256\"}],\"name\":\"StakeApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"}],\"name\":\"TransferStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_allowanceID\",\"type\":\"uint256\"}],\"name\":\"TransferStakeFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"setting\",\"type\":\"bool\"}],\"name\":\"TrustedPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"setting\",\"type\":\"bool\"}],\"name\":\"TrustedSender\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipientAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockUpTokensInSeconds\",\"type\":\"uint256\"}],\"name\":\"addAndExtendStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowOrigin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowStakeTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowStakeTransferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_setting\",\"type\":\"bool\"}],\"name\":\"allowTxOrigin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateHarvestXVMCRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateTotalPendingXVMCRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"callFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"votingAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"delegateeVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dummyToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_setting\",\"type\":\"bool\"}],\"name\":\"enableDisableStakeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_setting\",\"type\":\"bool\"}],\"name\":\"enableDisableStakeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNrOfStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPricePerFullShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"}],\"name\":\"getUserShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserTotalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minToServeInSecs\",\"type\":\"uint256\"}],\"name\":\"giftDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"}],\"name\":\"giveStakeAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gracePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipientAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"previousLastDepositedTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mandatoryTime\",\"type\":\"uint256\"}],\"name\":\"hopDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"}],\"name\":\"hopStakeToAnotherPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterchef\",\"outputs\":[{\"internalType\":\"contract IMasterChef\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"migrateAllStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"}],\"name\":\"migrateStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumGift\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_decision\",\"type\":\"bool\"}],\"name\":\"modifyPartialTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_decision\",\"type\":\"bool\"}],\"name\":\"modifyPartialWithdrawals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"nrOfstakeAllowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partialTransfers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partialWithdrawals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"regulateVotingCredit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowanceID\",\"type\":\"uint256\"}],\"name\":\"revokeStakeAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_callFee\",\"type\":\"uint256\"}],\"name\":\"setCallFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"setDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMasterChef\",\"name\":\"_masterchef\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newPoolID\",\"type\":\"uint256\"}],\"name\":\"setMasterChefAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPool\",\"type\":\"address\"}],\"name\":\"setMigrationPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_setting\",\"type\":\"bool\"}],\"name\":\"setMinimumGiftDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_setting\",\"type\":\"bool\"}],\"name\":\"setTrustedPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_setting\",\"type\":\"bool\"}],\"name\":\"setTrustedSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowanceID\",\"type\":\"uint256\"}],\"name\":\"stakeAllowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolInto\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"}],\"name\":\"stakeRollover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startEarning\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"stopEarning\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalVotesForID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowanceID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferStakeFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipientAddress\",\"type\":\"address\"}],\"name\":\"transferStakeToAnotherWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"trustedPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedPoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"trustedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedSenderCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateMinGiftGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateMinimumGift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDelegate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDepositedTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xvmcAtLastUserAction\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUserActionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mandatoryTimeToServe\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"voteForProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"}],\"name\":\"votingCredit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingCreditAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDummy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFeePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "XVMCtimeDeposit", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000970ccee657dd831e9c37511aa3eb5302c1eb5eee0000000000000000000000000fcaf4045f05e32f321a339dcca0a90643bc7bf90000000000000000000000006ff40a8a1fe16075bd6008a48befb768be08b4b0000000000000000000000000d5b7b040859e87bfbb7807599698786fc2367e2d000000000000000000000000d5b7b040859e87bfbb7807599698786fc2367e2d0000000000000000000000000000000000000000000000000000000000000005", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fb4948bfc61fb0dcbb4bd4bf79175bc78c48a82d48b21a2ad2bd86a3937e4d1f"}