{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/registry/ICRS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-2-Clause\\npragma solidity ^0.8.0;\\n\\ninterface ICRS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\\n    function setResolver(bytes32 node, address resolver) external;\\n    function setOwner(bytes32 node, address owner) external;\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n    function setApprovalForAll(address operator, bool approved) external;\\n    function owner(bytes32 node) external view returns (address);\\n    function resolver(bytes32 node) external view returns (address);\\n    function ttl(bytes32 node) external view returns (uint64);\\n    function recordExists(bytes32 node) external view returns (bool);\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/BaseResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SupportsInterface.sol\\\";\\n\\n/**\\n * @dev All resolver profiles inherit from BaseResolver to make auth checks.\\n */\\nabstract contract BaseResolver is SupportsInterface {\\n    /**\\n     * @dev Checks if caller is either an owner of a node or approved by the owner.\\n     * @param node 3rd party controller of metadata.\\n     * @return true if access is authorized.\\n     */\\n    function isAuthorised(bytes32 node) internal virtual view returns(bool);\\n\\n    /**\\n     * @dev Allow 3rd parties to store isolated records for the node.\\n     * @param controller 3rd party controller of metadata.\\n     * @return true if access is authorized.\\n     */\\n    function isDelegated(bytes32 node, address controller) internal virtual view returns(bool);\\n\\n    modifier authorised(bytes32 node) {\\n        require(isAuthorised(node), \\\"access denied\\\");\\n        _;\\n    }\\n\\n    modifier delegated(bytes32 node, address controller) {\\n        require(isDelegated(node, controller), \\\"not a delegate\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/IMulticallable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IMulticallable {\\n    /**\\n     * @dev Execute several resolver calls in a batch.\\n     * @param data Array of ABI-encoded calls to resolver.\\n     * @return results array of call results in the same order as input.\\n     */\\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/IResolver.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./profile/IAddressResolver.sol\\\";\\nimport \\\"./profile/INameResolver.sol\\\";\\nimport \\\"./profile/ITextResolver.sol\\\";\\nimport \\\"./profile/IContentHashResolver.sol\\\";\\nimport \\\"./profile/IABIResolver.sol\\\";\\nimport \\\"./profile/IInterfaceResolver.sol\\\";\\nimport \\\"./profile/IPubkeyResolver.sol\\\";\\nimport \\\"./profile/IRoyaltiesResolver.sol\\\";\\nimport \\\"./profile/IProxyConfigResolver.sol\\\";\\nimport \\\"./profile/IManagedResolver.sol\\\";\\nimport \\\"./profile/IKeyHashResolver.sol\\\";\\nimport \\\"./ISupportsInterface.sol\\\";\\n\\n/**\\n * @dev A generic resolver interface which includes all the functions including the ones deprecated.\\n */\\ninterface IResolver is\\n    ISupportsInterface,\\n    IAddressResolver,\\n    INameResolver,\\n    ITextResolver,\\n    IContentHashResolver,\\n    IABIResolver,\\n    IInterfaceResolver,\\n    IPubkeyResolver,\\n    IRoyaltiesResolver,\\n    IProxyConfigResolver,\\n    IManagedResolver,\\n    IKeyHashResolver\\n{\\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\\n    function setAddr(bytes32 node, address a) external;\\n    function setAddr(bytes32 node, uint coinType, bytes calldata a) external;\\n    function setName(bytes32 node, string calldata _name) external;\\n    function setContenthash(bytes32 node, bytes calldata hash) external;\\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\\n    function setText(bytes32 node, string calldata key, string calldata value) external;\\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\\n    function setRoyalties(bytes32 node, address beneficiary, uint256 amount) external;\\n    function setProxyConfig(bytes32 node, address controller, bytes4 selector, address proxy) external;\\n    function setRole(bytes32 node, bytes4 roleSig, address manager, bool active) external;\\n    function setKeyHash(bytes32 node, bytes4 key, bytes32 keyhash) external;\\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/ISupportsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ISupportsInterface {\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) external pure returns(bool);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/Multicallable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IMulticallable.sol\\\";\\nimport \\\"./SupportsInterface.sol\\\";\\n\\n/**\\n * @dev Make it possible to batch several resolver calls into a one transaction.\\n */\\nabstract contract Multicallable is IMulticallable, SupportsInterface {\\n    /**\\n     * @dev Execute several resolver calls in a batch.\\n     * @param data Array of ABI-encoded calls to resolver.\\n     * @return results array of call results in the same order as input.\\n     */\\n    function multicall(bytes[] calldata data) external override returns(bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for(uint i = 0; i < data.length; i++) {\\n            // solhint-disable avoid-low-level-calls\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n            require(success, \\\"batched call failed\\\");\\n            results[i] = result;\\n        }\\n        return results;\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) public override virtual pure returns(bool) {\\n        return interfaceID == type(IMulticallable).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/SupportsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ISupportsInterface.sol\\\";\\n\\n/**\\n * @dev EIP-165 implementation.\\n */\\nabstract contract SupportsInterface is ISupportsInterface {\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(ISupportsInterface).interfaceId;\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/ABIResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseResolver.sol\\\";\\nimport \\\"./IABIResolver.sol\\\";\\n\\n/**\\n * @dev See {https://eips.ethereum.org/EIPS/eip-205}.\\n */\\nabstract contract ABIResolver is IABIResolver, BaseResolver {\\n    mapping(bytes32=>mapping(uint256=>bytes)) internal abis;\\n\\n    /**\\n     * @dev Sets the ABI associated with a CRS node.\\n     *      Nodes may have one ABI of each content type. To remove an ABI, set it to\\n     *      the empty string.\\n     * @param node The node to update.\\n     * @param contentType The content type of the ABI\\n     * @param data The ABI data.\\n     */\\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) virtual external authorised(node) {\\n        // Content types must be powers of 2\\n        require(((contentType - 1) & contentType) == 0, \\\"invalid bitmask\\\");\\n\\n        abis[node][contentType] = data;\\n        emit ABIChanged(node, contentType);\\n    }\\n\\n    /**\\n     * @dev Returns the ABI associated with a CRS node.\\n     *      Defined in EIP205.\\n     * @param node The CRS node to query\\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\n     * @return contentType The content type of the return value\\n     * @return data The ABI data\\n     */\\n    function ABI(bytes32 node, uint256 contentTypes) virtual override external view returns (uint256, bytes memory) {\\n        mapping(uint256=>bytes) storage abiset = abis[node];\\n\\n        for (uint256 contentType = 1; contentType <= contentTypes; contentType <<= 1) {\\n            if ((contentType & contentTypes) != 0 && abiset[contentType].length > 0) {\\n                return (contentType, abiset[contentType]);\\n            }\\n        }\\n\\n        return (0, bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IABIResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/AddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseResolver.sol\\\";\\nimport \\\"./IAddressResolver.sol\\\";\\n\\n/**\\n * @dev Human-reable name for wallets on different networks.\\n */\\nabstract contract AddressResolver is IAddressResolver, BaseResolver {\\n    uint constant private COIN_TYPE_MATIC = 137;\\n\\n    mapping(bytes32=>mapping(uint=>bytes)) internal _addresses;\\n\\n    /**\\n     * @dev Returns the address associated with a CRS node.\\n     * @param node The CRS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) virtual public view returns (address payable) {\\n        bytes memory a = addr(node, COIN_TYPE_MATIC);\\n        if(a.length == 0) {\\n            return payable(0);\\n        }\\n        return _bytesToAddress(a);\\n    }\\n    function addr(bytes32 node, uint coinType) virtual override public view returns(bytes memory) {\\n        return _addresses[node][coinType];\\n    }\\n\\n    /**\\n     * @dev Sets the address associated with a CRS node.\\n     *      May only be called by the owner of that node in the CRS registry.\\n     * @param node The node to update.\\n     * @param a The address to set.\\n     */\\n    function setAddr(bytes32 node, address a) external authorised(node) {\\n        setAddr(node, COIN_TYPE_MATIC, _addressToBytes(a));\\n    }\\n\\n    /**\\n     * @dev Sets the address associated with a CRS node.\\n     *      May only be called by the owner of that node in the CRS registry.\\n     * @param node The node to update.\\n     * @param coinType Chain id to set address.\\n     * @param a The address to set.\\n     */\\n    function setAddr(bytes32 node, uint coinType, bytes memory a) virtual public authorised(node) {\\n        emit AddressChanged(node, coinType, a);\\n        _addresses[node][coinType] = a;\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IAddressResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n\\n    /**\\n     * @dev Convert from bytes to address type.\\n     * @param b Address encoded as bytes.\\n     * @return a decoded address.\\n     */\\n    function _bytesToAddress(bytes memory b) internal pure returns(address payable a) {\\n        require(b.length == 20, \\\"not an address\\\");\\n        // solhint-disable no-inline-assembly\\n        assembly {\\n            a := div(mload(add(b, 32)), exp(256, 12))\\n        }\\n    }\\n\\n    /**\\n     * @dev Convert from address to bytes type.\\n     * @param a Address to encode\\n     * @return b encoded address.\\n     */\\n    function _addressToBytes(address a) internal pure returns(bytes memory b) {\\n        b = new bytes(20);\\n        // solhint-disable no-inline-assembly\\n        assembly {\\n            mstore(add(b, 32), mul(a, exp(256, 12)))\\n        }\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/ContentHashResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseResolver.sol\\\";\\nimport \\\"./IContentHashResolver.sol\\\";\\n\\n/**\\n * @dev URL / content hash associated with a node, usually a website or IPFS link.\\n */\\nabstract contract ContentHashResolver is IContentHashResolver, BaseResolver {\\n    mapping(bytes32=>bytes) internal hashes;\\n\\n    /**\\n     * @dev Sets the contenthash associated with a CRS node.\\n     *      May only be called by the owner of that node in the CRS registry.\\n     * @param node The node to update.\\n     * @param hash The contenthash to set\\n     */\\n    function setContenthash(bytes32 node, bytes calldata hash) virtual external authorised(node) {\\n        hashes[node] = hash;\\n        emit ContenthashChanged(node, hash);\\n    }\\n\\n    /**\\n     * @dev Returns the contenthash associated with a CRS node.\\n     * @param node The CRS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function contenthash(bytes32 node) virtual external override view returns (bytes memory) {\\n        return hashes[node];\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IContentHashResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/IABIResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IABIResolver {\\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\\n    \\n    /**\\n     * @dev Returns the ABI associated with an ENS node.\\n     *      Defined in EIP205.\\n     * @param node The ENS node to query\\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\n     * @return contentType The content type of the return value\\n     * @return data The ABI data\\n     */\\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/IAddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * Interface for addr function.\\n */\\ninterface IAddressResolver {\\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\\n\\n    /**\\n     * @dev Returns the address associated with a CRS node.\\n     * @param node The CRS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node, uint coinType) external view returns(bytes memory);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/IContentHashResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IContentHashResolver {\\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\\n\\n    /**\\n     * @dev Returns the contenthash associated with a CRS node.\\n     * @param node The CRS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function contenthash(bytes32 node) external view returns (bytes memory);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/IInterfaceResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IInterfaceResolver {\\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\\n\\n    /**\\n     * @dev Returns the address of a contract that implements the specified interface for this name.\\n     *      If an implementer has not been set for this interfaceID and name, the resolver will query\\n     *      the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\\n     *      contract implements EIP165 and returns `true` for the specified interfaceID, its address\\n     *      will be returned.\\n     * @param node The CRS node to query.\\n     * @param interfaceID The EIP 165 interface ID to check for.\\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\\n     */\\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/IKeyHashResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IKeyHashResolver {\\n    event KeyHashChanged(bytes32 indexed node, bytes4 indexed key, bytes32 keyhash);\\n\\n    /**\\n     * @dev Returns the hash associated with a CRS node for a key.\\n     * @param node The CRS node to query.\\n     * @param key bytes4 signature of a key generated like bytes4(keccak256(\\\"KEY\\\")).\\n     * @return The associated hash.\\n     */\\n    function keyHash(bytes32 node, bytes4 key) external view returns (bytes32);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/IManagedResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IManagedResolver {\\n    event RoleChanged(\\n        bytes32 indexed node,\\n        bytes4 indexed roleSig,\\n        address indexed manager,\\n        bool active\\n    );\\n\\n    /**\\n     * @dev Check if manager address has some role.\\n     * @param _node the node to update.\\n     * @param _roleSig bytes4 signature of a role generated like bytes4(keccak256(\\\"ROLE_NAME\\\")).\\n     * @param _manager address which will get the role.\\n     * @return true if manager address has role.\\n     */\\n    function hasRole(bytes32 _node, bytes4 _roleSig, address _manager) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/INameResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface INameResolver {\\n    event NameChanged(bytes32 indexed node, string name);\\n\\n    /**\\n     * @dev Returns the name associated with a CRS node, for reverse records.\\n     *      Defined in EIP181.\\n     * @param node The CRS node to query.\\n     * @return The associated name.\\n     */\\n    function name(bytes32 node) external view returns (string memory);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/IProxyConfigResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IProxyConfigResolver {\\n    event ProxyConfigChanged(bytes32 indexed node, address indexed controller, bytes4 indexed selector, address proxy);\\n\\n    /**\\n     * @dev Returns proxy contract address which resolves into some content.\\n     * @param node The CRS node to query.\\n     * @param controller Address of proxy controller.\\n     * @param selector Function selector to be called on proxy contract.\\n     * @return Address which implements proxy interface.\\n     */\\n    function proxyConfig(bytes32 node, address controller, bytes4 selector) external view returns (address);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/IPubkeyResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IPubkeyResolver {\\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\\n\\n    /**\\n     * @dev Returns the SECP256k1 public key associated with a CRS node.\\n     *      Defined in EIP 619.\\n     * @param node The CRS node to query\\n     * @return x The X coordinate of the curve point for the public key.\\n     * @return y The Y coordinate of the curve point for the public key.\\n     */\\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/IRoyaltiesResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IRoyaltiesResolver {\\n    event RoyaltiesChanged(\\n        bytes32 indexed node,\\n        address indexed beneficiary,\\n        uint256 amount,\\n        address token,\\n        address indexed forAddress\\n    );\\n\\n    /**\\n     * @dev Returns the royalties associated with a CRS node.\\n     * @param node The CRS node to query\\n     * @param addr Specific address for which royalties apply, address(0) for any address.\\n     * @return beneficiary address for royalties.\\n     * @return amount of roylties.\\n     * @return token, address(0) for gas coin\\n     */\\n    function royalty(bytes32 node, address addr) external view returns (address, uint256, address);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/ITextResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITextResolver {\\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string value);\\n\\n    /**\\n     * Returns the text data associated with a CRS node and key.\\n     * @param node The CRS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(bytes32 node, string calldata key) external view returns (string memory);\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/InterfaceResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ISupportsInterface.sol\\\";\\nimport \\\"./AddressResolver.sol\\\";\\nimport \\\"./IInterfaceResolver.sol\\\";\\n\\n/**\\n * @dev Defines a proxy address which implements specific EIP 165 interface associated with a node.\\n */\\nabstract contract InterfaceResolver is IInterfaceResolver, AddressResolver {\\n    mapping(bytes32=>mapping(bytes4=>address)) internal interfaces;\\n\\n    /**\\n     * @dev Sets an interface associated with a name.\\n     *      Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\\n     * @param node The node to update.\\n     * @param interfaceID The EIP 165 interface ID.\\n     * @param implementer The address of a contract that implements this interface for this node.\\n     */\\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) virtual external authorised(node) {\\n        interfaces[node][interfaceID] = implementer;\\n        emit InterfaceChanged(node, interfaceID, implementer);\\n    }\\n\\n    /**\\n     * @dev Returns the address of a contract that implements the specified interface for this name.\\n     *      If an implementer has not been set for this interfaceID and name, the resolver will query\\n     *      the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\\n     *      contract implements EIP165 and returns `true` for the specified interfaceID, its address\\n     *      will be returned.\\n     * @param node The CRS node to query.\\n     * @param interfaceID The EIP 165 interface ID to check for.\\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\\n     */\\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) virtual override external view returns (address) {\\n        address implementer = interfaces[node][interfaceID];\\n        if(implementer != address(0)) {\\n            return implementer;\\n        }\\n\\n        address a = addr(node);\\n        if(a == address(0)) {\\n            return address(0);\\n        }\\n\\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", type(ISupportsInterface).interfaceId));\\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\\n            // EIP 165 not supported by target\\n            return address(0);\\n        }\\n\\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", interfaceID));\\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\\n            // Specified interface not supported by target\\n            return address(0);\\n        }\\n\\n        return a;\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IInterfaceResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/KeyHashResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseResolver.sol\\\";\\nimport \\\"./IKeyHashResolver.sol\\\";\\n\\n/**\\n * @dev Storage-optimised key-value storage for bytes32 hashes.\\n *      The main intended usage is storage of compressed IPFS hashes\\n *      associated with different records for a node.\\n *      Check `ContentHashResolver` if node needs only one record.\\n */\\nabstract contract KeyHashResolver is IKeyHashResolver, BaseResolver {\\n    mapping(bytes32=>mapping(bytes4=>bytes32)) internal keyHashes;\\n\\n    /**\\n     * @dev Sets the contenthash associated with a CRS node.\\n     *      May only be called by the owner of that node in the CRS registry.\\n     * @param _node The node to update.\\n     * @param _key bytes4 signature of a key generated like bytes4(keccak256(\\\"KEY\\\")).\\n     * @param _keyhash Hash to store, trimmed to bytes32 storage type.\\n     */\\n    function setKeyHash(bytes32 _node, bytes4 _key, bytes32 _keyhash) virtual external authorised(_node) {\\n        keyHashes[_node][_key] = _keyhash;\\n        emit KeyHashChanged(_node, _key, _keyhash);\\n    }\\n\\n    /**\\n     * @dev Returns the hash associated with a CRS node for a key.\\n     * @param _node The CRS node to query.\\n     * @param _key bytes4 signature of a key generated like bytes4(keccak256(\\\"KEY\\\")).\\n     * @return The associated hash.\\n     */\\n    function keyHash(bytes32 _node, bytes4 _key) virtual external override view returns (bytes32) {\\n        return keyHashes[_node][_key];\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IKeyHashResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/ManagedResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"../BaseResolver.sol\\\";\\nimport \\\"./IManagedResolver.sol\\\";\\n\\n/**\\n * @dev Define roles or permissions associated with a node.\\n */\\nabstract contract ManagedResolver is IManagedResolver, BaseResolver {\\n    mapping(bytes32 => mapping(bytes4 => mapping(address => bool))) internal managementRoles; \\n    \\n    /**\\n     * @dev Assign some role to an address.\\n     * @param _node the node to update.\\n     * @param _roleSig bytes4 signature of a role generated like bytes4(keccak256(\\\"ROLE_NAME\\\")).\\n     * @param _manager address which will get the role.\\n     * @param _active true to set role, false to revoke it.\\n     */\\n    function setRole(bytes32 _node, bytes4 _roleSig, address _manager, bool _active) virtual external authorised(_node) {\\n        managementRoles[_node][_roleSig][_manager] = _active;\\n        emit RoleChanged(_node, _roleSig, _manager, _active);\\n    }\\n\\n    /**\\n     * @dev Check if manager address has some role.\\n     * @param _node the node to update.\\n     * @param _roleSig bytes4 signature of a role generated like bytes4(keccak256(\\\"ROLE_NAME\\\")).\\n     * @param _manager address which will get the role.\\n     * @return true if manager address has role.\\n     */\\n    function hasRole(bytes32 _node, bytes4 _roleSig, address _manager) virtual override external view returns (bool) {\\n        return managementRoles[_node][_roleSig][_manager];\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IManagedResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/NameResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseResolver.sol\\\";\\nimport \\\"./INameResolver.sol\\\";\\n\\n/**\\n * @dev Full name associated with a node.\\n */\\nabstract contract NameResolver is INameResolver, BaseResolver {\\n    mapping(bytes32=>string) internal names;\\n\\n    /**\\n     * Sets the name associated with a CRS node, for reverse records.\\n     * May only be called by the owner of that node in the CRS registry.\\n     * @param node The node to update.\\n     */\\n    function setName(bytes32 node, string calldata newName) virtual external authorised(node) {\\n        names[node] = newName;\\n        emit NameChanged(node, newName);\\n    }\\n\\n    /**\\n     * Returns the name associated with a CRS node, for reverse records.\\n     * Defined in EIP181.\\n     * @param node The CRS node to query.\\n     * @return The associated name.\\n     */\\n    function name(bytes32 node) virtual override external view returns (string memory) {\\n        return names[node];\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(INameResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/ProxyConfigResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseResolver.sol\\\";\\nimport \\\"./IProxyConfigResolver.sol\\\";\\n\\n/**\\n * @dev Allows 3rd parties to associate their own records related to this node.\\n *      It can be used to set game profiles, reputation scores or other data, which\\n *      shouldn't be controlled by the owner of a node.\\n */\\nabstract contract ProxyConfigResolver is IProxyConfigResolver, BaseResolver {\\n    mapping(bytes32=>mapping(address=>mapping(bytes4=>address))) internal proxyConfigs;\\n\\n    /**\\n     * @dev Sets proxy contract controlled by a 3rd party with data related to this CRS.\\n     *      Use InterfaceResolver to define proxies for more complex interfaces.\\n     * @param node The node to update.\\n     * @param controller Address of proxy controller.\\n     * @param selector Function selector to be called on proxy contract.\\n     * @param proxy Address which implements proxy interface.\\n     */\\n    function setProxyConfig(\\n        bytes32 node,\\n        address controller,\\n        bytes4 selector,\\n        address proxy\\n    ) virtual external delegated(node, controller) {\\n        proxyConfigs[node][controller][selector] = proxy;\\n        emit ProxyConfigChanged(node, controller, selector, proxy);\\n    }\\n\\n    /**\\n     * @dev Returns proxy contract address which resolves into some content.\\n     * @param node The CRS node to query.\\n     * @param controller Address of proxy controller.\\n     * @param selector Function selector to be called on proxy contract.\\n     * @return Address which implements proxy interface.\\n     */\\n    function proxyConfig(bytes32 node, address controller, bytes4 selector) virtual override external view returns (address) {\\n        return proxyConfigs[node][controller][selector];\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IProxyConfigResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/PubkeyResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseResolver.sol\\\";\\nimport \\\"./IPubkeyResolver.sol\\\";\\n\\n/**\\n * @dev Publish public key associated with a node.\\n */\\nabstract contract PubkeyResolver is IPubkeyResolver, BaseResolver {\\n    struct PublicKey {\\n        bytes32 x;\\n        bytes32 y;\\n    }\\n\\n    mapping(bytes32=>PublicKey) internal pubkeys;\\n\\n    /**\\n     * @dev Sets the SECP256k1 public key associated with a CRS node.\\n     * @param node The CRS node to query\\n     * @param x the X coordinate of the curve point for the public key.\\n     * @param y the Y coordinate of the curve point for the public key.\\n     */\\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) virtual external authorised(node) {\\n        pubkeys[node] = PublicKey(x, y);\\n        emit PubkeyChanged(node, x, y);\\n    }\\n\\n    /**\\n     * @dev Returns the SECP256k1 public key associated with a CRS node.\\n     *      Defined in EIP 619.\\n     * @param node The CRS node to query\\n     * @return x The X coordinate of the curve point for the public key.\\n     * @return y The Y coordinate of the curve point for the public key.\\n     */\\n    function pubkey(bytes32 node) virtual override external view returns (bytes32 x, bytes32 y) {\\n        return (pubkeys[node].x, pubkeys[node].y);\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IPubkeyResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/RoyaltiesResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseResolver.sol\\\";\\nimport \\\"./IRoyaltiesResolver.sol\\\";\\n\\n/**\\n * @dev Defines royalties associated with a node. Supports default and\\n *      individual roylties for specific callers. Token or gas coin, amount and\\n *      beneficiary are configurable, but interpetation and implementation are\\n *      on a side of a caller.\\n */\\nabstract contract RoyaltiesResolver is IRoyaltiesResolver, BaseResolver {\\n    struct Royalties {\\n        address beneficiary;\\n        uint256 amount;\\n        address token;\\n    }\\n\\n    address public constant ZERO_ADDRESS = address(0);\\n\\n    mapping(bytes32=>Royalties) internal royalties;\\n    mapping(bytes32=>mapping(address=>Royalties)) internal addressRoyalties;\\n    \\n    /**\\n     * @dev Sets the royalties associated with a CRS node, for reverse records.\\n     *      May only be called by the owner of that node in the CRS registry.\\n     * @param node The node to update.\\n     * @param beneficiary The associated beneficiary to recieve royalties.\\n     * @param amount The associated royalty amount.\\n     * @param token ERC20 token to charge royalites, address(0) to use gas coin.\\n     * @param forAddress Address which individual settings are used, address(0) for default settings.\\n     */\\n    function setRoyalties(bytes32 node, address beneficiary, uint256 amount, address token, address forAddress) virtual external authorised(node) {\\n        if (forAddress == address(0)) {\\n            royalties[node] = Royalties(beneficiary, amount, token);\\n        } else {\\n            addressRoyalties[node][forAddress] = Royalties(beneficiary, amount, token);\\n        }\\n        emit RoyaltiesChanged(node, beneficiary, amount, token, forAddress);\\n    }\\n\\n    /**\\n     * @dev Returns the royalties associated with a CRS node.\\n     * @param node The CRS node to query.\\n     * @param addr Address for which royalty was set.\\n     * @return The associated beneficiary to recieve royalties.\\n     * @return The associated royalty amount.\\n     * @return The associated royalty token or address(0) for gas coin.\\n     */\\n    function royalty(bytes32 node, address addr) virtual override external view returns(address, uint256, address) {\\n        if (addr == ZERO_ADDRESS) {\\n            return _defaultRoyalty(node);\\n        } else {\\n            address _beneficiary = addressRoyalties[node][addr].beneficiary;\\n            if (_beneficiary == ZERO_ADDRESS) {\\n                return _defaultRoyalty(node);\\n            } else {\\n                return (_beneficiary, addressRoyalties[node][addr].amount, addressRoyalties[node][addr].token);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns default royalties\\n     * @param node The CRS node to query.\\n     * @return The associated beneficiary to recieve royalties.\\n     * @return The associated royalty amount.\\n     * @return The associated royalty token or address(0) for gas coin.\\n     */\\n    function _defaultRoyalty(bytes32 node) internal view returns(address, uint256, address) {\\n        return (royalties[node].beneficiary, royalties[node].amount, royalties[node].token);\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(IRoyaltiesResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\"\r\n    },\r\n    \"node_modules/@le7el/web3_crs/contracts/resolver/profile/TextResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseResolver.sol\\\";\\nimport \\\"./ITextResolver.sol\\\";\\n\\n/**\\n * @dev Flexible key-value storage for string or byte data.\\n */\\nabstract contract TextResolver is ITextResolver, BaseResolver {\\n    mapping(bytes32=>mapping(string=>string)) internal texts;\\n\\n    /**\\n     * @dev Sets the text data associated with a CRS node and key.\\n     *      May only be called by the owner of that node in the CRS registry.\\n     * @param node The node to update.\\n     * @param key The key to set.\\n     * @param value The text data value to set.\\n     */\\n    function setText(bytes32 node, string calldata key, string calldata value) virtual external authorised(node) {\\n        texts[node][key] = value;\\n        emit TextChanged(node, key, value);\\n    }\\n\\n    /**\\n     * @dev Returns the text data associated with a CRS node and key.\\n     * @param node The CRS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(bytes32 node, string calldata key) virtual override external view returns (string memory) {\\n        return texts[node][key];\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == type(ITextResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\"\r\n    },\r\n    \"src/interface/IERC1155Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity ^0.8.10;\\n\\ninterface IERC1155Burnable {\\n    function burn(address account, uint256 id, uint256 value) external; // 0xf5298aca\\n}\"\r\n    },\r\n    \"src/interface/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity ^0.8.10;\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint256);\\n}\"\r\n    },\r\n    \"src/interface/IERC20BurnableV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity ^0.8.10;\\n\\ninterface IERC20BurnableV1 {\\n    function burnFrom(address account, uint256 value) external; // 0x79cc6790\\n}\"\r\n    },\r\n    \"src/interface/IERC20BurnableV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity ^0.8.10;\\n\\ninterface IERC20BurnableV2 {\\n    function burn(address account, uint256 value) external; // 0x9dc29fac\\n}\"\r\n    },\r\n    \"src/resolver/LevelingResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity ^0.8.10;\\n\\nimport \\\"@le7el/web3_crs/contracts/registry/ICRS.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/IResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/profile/AddressResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/profile/ContentHashResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/profile/NameResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/profile/TextResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/profile/InterfaceResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/profile/ABIResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/profile/PubkeyResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/profile/RoyaltiesResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/profile/ProxyConfigResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/profile/ManagedResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/profile/KeyHashResolver.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/Multicallable.sol\\\";\\nimport \\\"./profile/LevelResolver.sol\\\";\\n\\n/** \\n * @dev All default features of CRS resolver, with leveling system, controllable by 3rd party,\\n *      see `profile/LevelResolver.sol` for details.\\n */\\ncontract LevelingResolver is \\n    Multicallable,\\n    AddressResolver,\\n    ContentHashResolver,\\n    NameResolver,\\n    TextResolver,\\n    InterfaceResolver,\\n    ABIResolver,\\n    PubkeyResolver,\\n    RoyaltiesResolver,\\n    ProxyConfigResolver,\\n    ManagedResolver,\\n    KeyHashResolver,\\n    LevelResolver\\n{\\n    ICRS crs;\\n\\n    /**\\n     * A mapping of operators. An address that is authorised for an address\\n     * may make any changes to the name that the owner could, but may not update\\n     * the set of authorisations.\\n     * (owner, operator) => approved\\n     */\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    constructor(ICRS _crs) {\\n        crs = _crs;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external {\\n        require(\\n            msg.sender != operator,\\n            \\\"ERC1155: can't self-approve\\\"\\n        );\\n\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Checks if caller is either an owner of a node or approved by the owner.\\n     * @param node 3rd party controller of metadata.\\n     * @return true if access is authorized.\\n     */\\n    function isAuthorised(bytes32 node) internal override view returns(bool) {\\n        address owner = crs.owner(node);\\n        return owner == msg.sender || isApprovedForAll(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allow 3rd parties to store isolated records for the node.\\n     * @param controller 3rd party controller of metadata.\\n     * @return true if access is authorized.\\n     */\\n    function isDelegated(bytes32, address controller) internal override view returns(bool) {\\n        return controller == msg.sender;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) public override(\\n        Multicallable,\\n        AddressResolver,\\n        ContentHashResolver,\\n        NameResolver,\\n        TextResolver,\\n        InterfaceResolver,\\n        ABIResolver,\\n        PubkeyResolver,\\n        RoyaltiesResolver,\\n        ProxyConfigResolver,\\n        ManagedResolver,\\n        KeyHashResolver,\\n        LevelResolver\\n    ) pure returns(bool) {\\n        return interfaceID == type(IMulticallable).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n}\"\r\n    },\r\n    \"src/resolver/profile/ILevelResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity ^0.8.10;\\n\\ninterface ILevelResolver {\\n    event AdvancedToNextLevel(\\n        bytes32 indexed project,\\n        bytes32 indexed node,\\n        uint256 newExperience,\\n        uint256 totalExperience\\n    );\\n\\n    event ProjectLevelingRulesChanged(\\n        bytes32 indexed project,\\n        bytes4 indexed burnInterface,\\n        address indexed experienceToken,\\n        uint256 experienceTokenId,\\n        address levelingFormulaProxy\\n    );\\n\\n    /**\\n     * @dev Level based on experience.\\n     * @param _project node for a project which issue experience.\\n     * @param _node the node to query.\\n     * @return level based on experience\\n     */\\n    function level(bytes32 _project, bytes32 _node) external view returns (uint256);\\n\\n    /**\\n     * @dev Experience in scope of project.\\n     * @param _project node for a project which issue experience.\\n     * @param _node the node to query.\\n     * @return project experience\\n     */\\n    function experience(bytes32 _project, bytes32 _node) external view returns (uint256);\\n}\"\r\n    },\r\n    \"src/resolver/profile/ILevelingFormula.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity ^0.8.10;\\n\\ninterface ILevelingFormula {\\n    /**\\n     * @dev Get level based on experience.\\n     * @param _experience experience points.\\n     * @return user level based on experience.\\n     */\\n    function expToLevel(uint256 _experience) external view returns (uint256);\\n}\"\r\n    },\r\n    \"src/resolver/profile/LevelResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@le7el/web3_crs/contracts/resolver/BaseResolver.sol\\\";\\nimport \\\"../../interface/IERC20.sol\\\";\\nimport \\\"../../interface/IERC1155Burnable.sol\\\";\\nimport \\\"../../interface/IERC20BurnableV1.sol\\\";\\nimport \\\"../../interface/IERC20BurnableV2.sol\\\";\\nimport \\\"./ILevelingFormula.sol\\\";\\nimport \\\"./ILevelResolver.sol\\\";\\n\\n/** \\n * @dev Any owner of a node can configure own leveling system for other NFT owners.\\n *      He configures his node as project for external usage, defining experience token and leveling formula.\\n *      NFT owner needs to burn experience tokens set for such a project to level up.\\n *      Leveling formula can be set as an oracle conract, or default formula\\n *      500*level^2-500*level=exp will be used.\\n */\\nabstract contract LevelResolver is ILevelResolver, BaseResolver {\\n    // parabolic equation coeficients for the default leveling formula.\\n    uint256 public constant DEF_LEVELING_COF1 = 500;\\n    uint256 public constant DEF_LEVELING_COF2 = 250000;\\n    uint256 public constant DEF_LEVELING_COF3 = 2000;\\n    uint256 public constant DEF_LEVELING_COF4 = 1000;\\n\\n    bytes4 public constant IERC1155_BURNABLE = 0xf5298aca;\\n    bytes4 public constant IERC20_BURNABLE_V1 = 0x79cc6790;\\n    bytes4 public constant IERC20_BURNABLE_V2 = 0x9dc29fac;\\n    \\n    struct Project{\\n        address formula;\\n        address experienceToken;\\n        uint256 experienceTokenId;\\n        bytes4 burnInterface;\\n    }\\n\\n    mapping(bytes32=>mapping(bytes32=>uint256)) internal levelingExperience;\\n    mapping(bytes32=>Project) public levelingProjects;\\n\\n    /**\\n     * @dev Burn experience tokens to advance in leveling.\\n     * @param _project node for a project which issue experience.\\n     * @param _node the node to update.\\n     * @param _burnExperienceTokenAmount amount of experience tokens to burn.\\n     * @return updated experience.\\n     */\\n    function advanceToNextLevel(\\n        bytes32 _project,\\n        bytes32 _node,\\n        uint256 _burnExperienceTokenAmount\\n    ) virtual external authorised(_node) returns (uint256) {\\n        require(_burnExperienceTokenAmount > 0, \\\"no advance in leveling\\\");\\n        Project memory _levelingProject = levelingProjects[_project];\\n        require(_levelingProject.experienceToken != address(0), \\\"unregistered project\\\");\\n\\n        if (_levelingProject.burnInterface == IERC1155_BURNABLE) {\\n            IERC1155Burnable(_levelingProject.experienceToken).burn(msg.sender, _levelingProject.experienceTokenId, _burnExperienceTokenAmount);\\n        } else if (_levelingProject.burnInterface == IERC20_BURNABLE_V2) {\\n            IERC20BurnableV2(_levelingProject.experienceToken).burn(msg.sender, _burnExperienceTokenAmount);\\n        } else {\\n            IERC20BurnableV1(_levelingProject.experienceToken).burnFrom(msg.sender, _burnExperienceTokenAmount);\\n        }\\n        uint256 _currentExp = levelingExperience[_node][_project];\\n        uint256 _newExp = _currentExp + _burnExperienceTokenAmount;\\n        levelingExperience[_node][_project] = _newExp;\\n        emit AdvancedToNextLevel(_project, _node, _burnExperienceTokenAmount, _newExp);\\n        return _newExp;\\n    }\\n\\n    /**\\n     * @dev Project controller can update leveling system and experience token.\\n     * @param _project node for a project which issue experience.\\n     * @param _levelingFormulaProxy address of proxy contract which implements ILevelingFormula, pass address(0) for default formula.\\n     * @param _experienceToken address of experience token. \\n     * @param _experienceTokenId experience token id in case of ERC1155, pass 0 for ERC20.\\n     * @param _burnInterface signature of burning function: 0xf5298aca, 0x9dc29fac or 0x79cc6790 (default).\\n     */\\n    function setProjectLevelingRules(\\n        bytes32 _project,\\n        address _levelingFormulaProxy,\\n        address _experienceToken,\\n        uint256 _experienceTokenId,\\n        bytes4 _burnInterface\\n    ) virtual external authorised(_project) {\\n        levelingProjects[_project] = Project(_levelingFormulaProxy, _experienceToken, _experienceTokenId, _burnInterface);\\n        emit ProjectLevelingRulesChanged(_project, _burnInterface, _experienceToken, _experienceTokenId, _levelingFormulaProxy);\\n    }\\n\\n    /**\\n     * @dev Level based on experience.\\n     * @param _project node for a project which issue experience.\\n     * @param _node the node to query.\\n     * @return level based on experience\\n     */\\n    function level(bytes32 _project, bytes32 _node) virtual override external view returns (uint256) {\\n        uint256 _exp = levelingExperience[_node][_project];\\n        if (_exp == 0) return 1;\\n        if (levelingProjects[_project].formula == address(0)) {\\n            if (levelingProjects[_project].burnInterface != IERC1155_BURNABLE) {\\n                return _defaultLevelingFormula(_exp, IERC20(levelingProjects[_project].experienceToken).decimals());\\n            }\\n            return _defaultLevelingFormula(_exp, 0);\\n        } else {\\n            return ILevelingFormula(levelingProjects[_project].formula).expToLevel(_exp);\\n        }\\n    }\\n\\n    /**\\n     * @dev Experience in scope of project.\\n     * @param _project node for a project which issue experience.\\n     * @param _node the node to query.\\n     * @return project experience\\n     */\\n    function experience(bytes32 _project, bytes32 _node) virtual override external view returns (uint256) {\\n        return levelingExperience[_node][_project];\\n    }\\n\\n    /**\\n     * @dev Check if specific interface is implemented.\\n     * @param interfaceID Keccak of matched interface.\\n     * @return true if implemented.\\n     */\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns (bool) {\\n        return interfaceID == type(ILevelResolver).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n\\n    /**\\n     * @dev Parabolic leveling formula similar to DnD 3.5 leveling system: 500*level^2-500*level=exp.\\n     * @param _exp total experience.\\n     * @param _decimals experience token decimals.\\n     * @return level based on experience\\n     */\\n    function _defaultLevelingFormula(uint256 _exp, uint256 _decimals) internal pure returns (uint256) {\\n        if (_decimals > 0) _exp = _exp / (10 ** _decimals); \\n        return (DEF_LEVELING_COF1 + _sqrt(DEF_LEVELING_COF2 + (DEF_LEVELING_COF3 * _exp))) / DEF_LEVELING_COF4;\\n    }\\n\\n    /**\\n     * @dev Square root, taken from Uniswap 2.0.\\n     * @param y argument for square root.\\n     * @return z a rounded square root result.\\n     */\\n    function _sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@le7el/=node_modules/@le7el/\",\r\n      \"@le7el/generative_art/=node_modules/@le7el/generative_art/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ICRS\",\"name\":\"_crs\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"contentType\",\"type\":\"uint256\"}],\"name\":\"ABIChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"newAddress\",\"type\":\"bytes\"}],\"name\":\"AddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"project\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newExperience\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalExperience\",\"type\":\"uint256\"}],\"name\":\"AdvancedToNextLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"ContenthashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementer\",\"type\":\"address\"}],\"name\":\"InterfaceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"key\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"keyhash\",\"type\":\"bytes32\"}],\"name\":\"KeyHashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"project\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"burnInterface\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"experienceToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"experienceTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"levelingFormulaProxy\",\"type\":\"address\"}],\"name\":\"ProjectLevelingRulesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyConfigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"name\":\"PubkeyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"roleSig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"RoleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"forAddress\",\"type\":\"address\"}],\"name\":\"RoyaltiesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"indexedKey\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"TextChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"contentTypes\",\"type\":\"uint256\"}],\"name\":\"ABI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEF_LEVELING_COF1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEF_LEVELING_COF2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEF_LEVELING_COF3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEF_LEVELING_COF4\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IERC1155_BURNABLE\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IERC20_BURNABLE_V1\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IERC20_BURNABLE_V2\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"addr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"}],\"name\":\"addr\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_project\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_burnExperienceTokenAmount\",\"type\":\"uint256\"}],\"name\":\"advanceToNextLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"contenthash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_project\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"}],\"name\":\"experience\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"_roleSig\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"interfaceImplementer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"_key\",\"type\":\"bytes4\"}],\"name\":\"keyHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_project\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"}],\"name\":\"level\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"levelingProjects\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"formula\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"experienceToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"experienceTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"burnInterface\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"proxyConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"pubkey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"royalty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"contentType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setABI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"a\",\"type\":\"bytes\"}],\"name\":\"setAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"setContenthash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"implementer\",\"type\":\"address\"}],\"name\":\"setInterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"_key\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"_keyhash\",\"type\":\"bytes32\"}],\"name\":\"setKeyHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_project\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_levelingFormulaProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_experienceToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_experienceTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"_burnInterface\",\"type\":\"bytes4\"}],\"name\":\"setProjectLevelingRules\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"setProxyConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"name\":\"setPubkey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"_roleSig\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"forAddress\",\"type\":\"address\"}],\"name\":\"setRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"text\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LevelingResolver", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000df4d2c1d3f9b960501defdbdb9f7d32361e4c72f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}