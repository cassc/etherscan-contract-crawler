{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/universal/ProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { Proxy } from \\\"./Proxy.sol\\\";\\nimport { AddressManager } from \\\"../legacy/AddressManager.sol\\\";\\nimport { L1ChugSplashProxy } from \\\"../legacy/L1ChugSplashProxy.sol\\\";\\n\\n/// @title IStaticERC1967Proxy\\n/// @notice IStaticERC1967Proxy is a static version of the ERC1967 proxy interface.\\ninterface IStaticERC1967Proxy {\\n    function implementation() external view returns (address);\\n\\n    function admin() external view returns (address);\\n}\\n\\n/// @title IStaticL1ChugSplashProxy\\n/// @notice IStaticL1ChugSplashProxy is a static version of the ChugSplash proxy interface.\\ninterface IStaticL1ChugSplashProxy {\\n    function getImplementation() external view returns (address);\\n\\n    function getOwner() external view returns (address);\\n}\\n\\n/// @title ProxyAdmin\\n/// @notice This is an auxiliary contract meant to be assigned as the admin of an ERC1967 Proxy,\\n///         based on the OpenZeppelin implementation. It has backwards compatibility logic to work\\n///         with the various types of proxies that have been deployed by Optimism in the past.\\ncontract ProxyAdmin is Ownable {\\n    /// @notice The proxy types that the ProxyAdmin can manage.\\n    /// @custom:value ERC1967    Represents an ERC1967 compliant transparent proxy interface.\\n    /// @custom:value CHUGSPLASH Represents the Chugsplash proxy interface (legacy).\\n    /// @custom:value RESOLVED   Represents the ResolvedDelegate proxy (legacy).\\n    enum ProxyType {\\n        ERC1967,\\n        CHUGSPLASH,\\n        RESOLVED\\n    }\\n\\n    /// @notice A mapping of proxy types, used for backwards compatibility.\\n    mapping(address => ProxyType) public proxyType;\\n\\n    /// @notice A reverse mapping of addresses to names held in the AddressManager. This must be\\n    ///         manually kept up to date with changes in the AddressManager for this contract\\n    ///         to be able to work as an admin for the ResolvedDelegateProxy type.\\n    mapping(address => string) public implementationName;\\n\\n    /// @notice The address of the address manager, this is required to manage the\\n    ///         ResolvedDelegateProxy type.\\n    AddressManager public addressManager;\\n\\n    /// @notice A legacy upgrading indicator used by the old Chugsplash Proxy.\\n    bool internal upgrading;\\n\\n    /// @param _owner Address of the initial owner of this contract.\\n    constructor(address _owner) Ownable() {\\n        _transferOwnership(_owner);\\n    }\\n\\n    /// @notice Sets the proxy type for a given address. Only required for non-standard (legacy)\\n    ///         proxy types.\\n    /// @param _address Address of the proxy.\\n    /// @param _type    Type of the proxy.\\n    function setProxyType(address _address, ProxyType _type) external onlyOwner {\\n        proxyType[_address] = _type;\\n    }\\n\\n    /// @notice Sets the implementation name for a given address. Only required for\\n    ///         ResolvedDelegateProxy type proxies that have an implementation name.\\n    /// @param _address Address of the ResolvedDelegateProxy.\\n    /// @param _name    Name of the implementation for the proxy.\\n    function setImplementationName(address _address, string memory _name) external onlyOwner {\\n        implementationName[_address] = _name;\\n    }\\n\\n    /// @notice Set the address of the AddressManager. This is required to manage legacy\\n    ///         ResolvedDelegateProxy type proxy contracts.\\n    /// @param _address Address of the AddressManager.\\n    function setAddressManager(AddressManager _address) external onlyOwner {\\n        addressManager = _address;\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Set an address in the address manager. Since only the owner of the AddressManager\\n    ///         can directly modify addresses and the ProxyAdmin will own the AddressManager, this\\n    ///         gives the owner of the ProxyAdmin the ability to modify addresses directly.\\n    /// @param _name    Name to set within the AddressManager.\\n    /// @param _address Address to attach to the given name.\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        addressManager.setAddress(_name, _address);\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Set the upgrading status for the Chugsplash proxy type.\\n    /// @param _upgrading Whether or not the system is upgrading.\\n    function setUpgrading(bool _upgrading) external onlyOwner {\\n        upgrading = _upgrading;\\n    }\\n\\n    /// @custom:legacy\\n    /// @notice Legacy function used to tell ChugSplashProxy contracts if an upgrade is happening.\\n    /// @return Whether or not there is an upgrade going on. May not actually tell you whether an\\n    ///         upgrade is going on, since we don't currently plan to use this variable for anything\\n    ///         other than a legacy indicator to fix a UX bug in the ChugSplash proxy.\\n    function isUpgrading() external view returns (bool) {\\n        return upgrading;\\n    }\\n\\n    /// @notice Returns the implementation of the given proxy address.\\n    /// @param _proxy Address of the proxy to get the implementation of.\\n    /// @return Address of the implementation of the proxy.\\n    function getProxyImplementation(address _proxy) external view returns (address) {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            return IStaticERC1967Proxy(_proxy).implementation();\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            return IStaticL1ChugSplashProxy(_proxy).getImplementation();\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            return addressManager.getAddress(implementationName[_proxy]);\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /// @notice Returns the admin of the given proxy address.\\n    /// @param _proxy Address of the proxy to get the admin of.\\n    /// @return Address of the admin of the proxy.\\n    function getProxyAdmin(address payable _proxy) external view returns (address) {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            return IStaticERC1967Proxy(_proxy).admin();\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            return IStaticL1ChugSplashProxy(_proxy).getOwner();\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            return addressManager.owner();\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /// @notice Updates the admin of the given proxy address.\\n    /// @param _proxy    Address of the proxy to update.\\n    /// @param _newAdmin Address of the new proxy admin.\\n    function changeProxyAdmin(address payable _proxy, address _newAdmin) external onlyOwner {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).changeAdmin(_newAdmin);\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            L1ChugSplashProxy(_proxy).setOwner(_newAdmin);\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            addressManager.transferOwnership(_newAdmin);\\n        } else {\\n            revert(\\\"ProxyAdmin: unknown proxy type\\\");\\n        }\\n    }\\n\\n    /// @notice Changes a proxy's implementation contract.\\n    /// @param _proxy          Address of the proxy to upgrade.\\n    /// @param _implementation Address of the new implementation address.\\n    function upgrade(address payable _proxy, address _implementation) public onlyOwner {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).upgradeTo(_implementation);\\n        } else if (ptype == ProxyType.CHUGSPLASH) {\\n            L1ChugSplashProxy(_proxy).setStorage(\\n                // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\\n                bytes32(uint256(uint160(_implementation)))\\n            );\\n        } else if (ptype == ProxyType.RESOLVED) {\\n            string memory name = implementationName[_proxy];\\n            addressManager.setAddress(name, _implementation);\\n        } else {\\n            // It should not be possible to retrieve a ProxyType value which is not matched by\\n            // one of the previous conditions.\\n            assert(false);\\n        }\\n    }\\n\\n    /// @notice Changes a proxy's implementation contract and delegatecalls the new implementation\\n    ///         with some given data. Useful for atomic upgrade-and-initialize calls.\\n    /// @param _proxy          Address of the proxy to upgrade.\\n    /// @param _implementation Address of the new implementation address.\\n    /// @param _data           Data to trigger the new implementation with.\\n    function upgradeAndCall(\\n        address payable _proxy,\\n        address _implementation,\\n        bytes memory _data\\n    ) external payable onlyOwner {\\n        ProxyType ptype = proxyType[_proxy];\\n        if (ptype == ProxyType.ERC1967) {\\n            Proxy(_proxy).upgradeToAndCall{ value: msg.value }(_implementation, _data);\\n        } else {\\n            // reverts if proxy type is unknown\\n            upgrade(_proxy, _implementation);\\n            (bool success, ) = _proxy.call{ value: msg.value }(_data);\\n            require(success, \\\"ProxyAdmin: call to proxy after upgrade failed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/universal/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/// @title Proxy\\n/// @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\\n///         if the caller is address(0), meaning that the call originated from an off-chain\\n///         simulation.\\ncontract Proxy {\\n    /// @notice The storage slot that holds the address of the implementation.\\n    ///         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 internal constant IMPLEMENTATION_KEY =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @notice The storage slot that holds the address of the owner.\\n    ///         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n    bytes32 internal constant OWNER_KEY =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice An event that is emitted each time the implementation is changed. This event is part\\n    ///         of the EIP-1967 specification.\\n    /// @param implementation The address of the implementation contract\\n    event Upgraded(address indexed implementation);\\n\\n    /// @notice An event that is emitted each time the owner is upgraded. This event is part of the\\n    ///         EIP-1967 specification.\\n    /// @param previousAdmin The previous owner of the contract\\n    /// @param newAdmin      The new owner of the contract\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /// @notice A modifier that reverts if not called by the owner or by address(0) to allow\\n    ///         eth_call to interact with this proxy without needing to use low-level storage\\n    ///         inspection. We assume that nobody is able to trigger calls from address(0) during\\n    ///         normal EVM execution.\\n    modifier proxyCallIfNotAdmin() {\\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /// @notice Sets the initial admin during contract deployment. Admin address is stored at the\\n    ///         EIP-1967 admin storage slot so that accidental storage collision with the\\n    ///         implementation is not possible.\\n    /// @param _admin Address of the initial contract admin. Admin as the ability to access the\\n    ///               transparent proxy interface.\\n    constructor(address _admin) {\\n        _changeAdmin(_admin);\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /// @notice Set the implementation contract address. The code at the given address will execute\\n    ///         when this contract is called.\\n    /// @param _implementation Address of the implementation contract.\\n    function upgradeTo(address _implementation) public virtual proxyCallIfNotAdmin {\\n        _setImplementation(_implementation);\\n    }\\n\\n    /// @notice Set the implementation and call a function in a single transaction. Useful to ensure\\n    ///         atomic execution of initialization-based upgrades.\\n    /// @param _implementation Address of the implementation contract.\\n    /// @param _data           Calldata to delegatecall the new implementation with.\\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\\n        public\\n        payable\\n        virtual\\n        proxyCallIfNotAdmin\\n        returns (bytes memory)\\n    {\\n        _setImplementation(_implementation);\\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\\n        require(success, \\\"Proxy: delegatecall to new implementation contract failed\\\");\\n        return returndata;\\n    }\\n\\n    /// @notice Changes the owner of the proxy contract. Only callable by the owner.\\n    /// @param _admin New owner of the proxy contract.\\n    function changeAdmin(address _admin) public virtual proxyCallIfNotAdmin {\\n        _changeAdmin(_admin);\\n    }\\n\\n    /// @notice Gets the owner of the proxy contract.\\n    /// @return Owner address.\\n    function admin() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    //// @notice Queries the implementation address.\\n    /// @return Implementation address.\\n    function implementation() public virtual proxyCallIfNotAdmin returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /// @notice Sets the implementation address.\\n    /// @param _implementation New implementation address.\\n    function _setImplementation(address _implementation) internal {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n        emit Upgraded(_implementation);\\n    }\\n\\n    /// @notice Changes the owner of the proxy contract.\\n    /// @param _admin New owner of the proxy contract.\\n    function _changeAdmin(address _admin) internal {\\n        address previous = _getAdmin();\\n        assembly {\\n            sstore(OWNER_KEY, _admin)\\n        }\\n        emit AdminChanged(previous, _admin);\\n    }\\n\\n    /// @notice Performs the proxy call via a delegatecall.\\n    function _doProxyCall() internal {\\n        address impl = _getImplementation();\\n        require(impl != address(0), \\\"Proxy: implementation not initialized\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n\\n    /// @notice Queries the implementation address.\\n    /// @return Implementation address.\\n    function _getImplementation() internal view returns (address) {\\n        address impl;\\n        assembly {\\n            impl := sload(IMPLEMENTATION_KEY)\\n        }\\n        return impl;\\n    }\\n\\n    /// @notice Queries the owner of the proxy contract.\\n    /// @return Owner address.\\n    function _getAdmin() internal view returns (address) {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/legacy/AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @custom:legacy\\n/// @title AddressManager\\n/// @notice AddressManager is a legacy contract that was used in the old version of the Optimism\\n///         system to manage a registry of string names to addresses. We now use a more standard\\n///         proxy system instead, but this contract is still necessary for backwards compatibility\\n///         with several older contracts.\\ncontract AddressManager is Ownable {\\n    /// @notice Mapping of the hashes of string names to addresses.\\n    mapping(bytes32 => address) private addresses;\\n\\n    /// @notice Emitted when an address is modified in the registry.\\n    /// @param name       String name being set in the registry.\\n    /// @param newAddress Address set for the given name.\\n    /// @param oldAddress Address that was previously set for the given name.\\n    event AddressSet(string indexed name, address newAddress, address oldAddress);\\n\\n    /// @notice Changes the address associated with a particular name.\\n    /// @param _name    String name to associate an address with.\\n    /// @param _address Address to associate with the name.\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /// @notice Retrieves the address associated with a given name.\\n    /// @param _name Name to retrieve an address for.\\n    /// @return Address associated with the given name.\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /// @notice Computes the hash of a name.\\n    /// @param _name Name to compute a hash for.\\n    /// @return Hash of the given name.\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/legacy/L1ChugSplashProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/// @title IL1ChugSplashDeployer\\ninterface IL1ChugSplashDeployer {\\n    function isUpgrading() external view returns (bool);\\n}\\n\\n/// @custom:legacy\\n/// @title L1ChugSplashProxy\\n/// @notice Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\\n///         functions `setCode` and `setStorage` for changing the code or storage of the contract.\\n///         Note for future developers: do NOT make anything in this contract 'public' unless you\\n///         know what you're doing. Anything public can potentially have a function signature that\\n///         conflicts with a signature attached to the implementation contract. Public functions\\n///         SHOULD always have the `proxyCallIfNotOwner` modifier unless there's some *really* good\\n///         reason not to have that modifier. And there almost certainly is not a good reason to not\\n///         have that modifier. Beware!\\ncontract L1ChugSplashProxy {\\n    /// @notice \\\"Magic\\\" prefix. When prepended to some arbitrary bytecode and used to create a\\n    ///         contract, the appended bytecode will be deployed as given.\\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\\n\\n    /// @notice bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 internal constant IMPLEMENTATION_KEY =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @notice bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\\n    bytes32 internal constant OWNER_KEY =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice Blocks a function from being called when the parent signals that the system should\\n    ///         be paused via an isUpgrading function.\\n    modifier onlyWhenNotPaused() {\\n        address owner = _getOwner();\\n\\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\\n        // it turns out that it isn't the right type of contract.\\n        (bool success, bytes memory returndata) = owner.staticcall(\\n            abi.encodeWithSelector(IL1ChugSplashDeployer.isUpgrading.selector)\\n        );\\n\\n        // If the call was unsuccessful then we assume that there's no \\\"isUpgrading\\\" method and we\\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\\n        // long. If this isn't the case then we can safely ignore the result.\\n        if (success && returndata.length == 32) {\\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\\n            // really care about the case where this value is 0 (= false).\\n            uint256 ret = abi.decode(returndata, (uint256));\\n            require(ret == 0, \\\"L1ChugSplashProxy: system is currently being upgraded\\\");\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice Makes a proxy call instead of triggering the given function when the caller is\\n    ///         either the owner or the zero address. Caller can only ever be the zero address if\\n    ///         this function is being called off-chain via eth_call, which is totally fine and can\\n    ///         be convenient for client-side tooling. Avoids situations where the proxy and\\n    ///         implementation share a sighash and the proxy function ends up being called instead\\n    ///         of the implementation one.\\n    ///         Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If\\n    ///         there's a way for someone to send a transaction with msg.sender == address(0) in any\\n    ///         real context then we have much bigger problems. Primary reason to include this\\n    ///         additional allowed sender is because the owner address can be changed dynamically\\n    ///         and we do not want clients to have to keep track of the current owner in order to\\n    ///         make an eth_call that doesn't trigger the proxied contract.\\n    // slither-disable-next-line incorrect-modifier\\n    modifier proxyCallIfNotOwner() {\\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\\n            _;\\n        } else {\\n            // This WILL halt the call frame on completion.\\n            _doProxyCall();\\n        }\\n    }\\n\\n    /// @param _owner Address of the initial contract owner.\\n    constructor(address _owner) {\\n        _setOwner(_owner);\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    receive() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    // slither-disable-next-line locked-ether\\n    fallback() external payable {\\n        // Proxy call by default.\\n        _doProxyCall();\\n    }\\n\\n    /// @notice Sets the code that should be running behind this proxy.\\n    ///         Note: This scheme is a bit different from the standard proxy scheme where one would\\n    ///         typically deploy the code separately and then set the implementation address. We're\\n    ///         doing it this way because it gives us a lot more freedom on the client side. Can\\n    ///         only be triggered by the contract owner.\\n    /// @param _code New contract code to run inside this contract.\\n    function setCode(bytes memory _code) external proxyCallIfNotOwner {\\n        // Get the code hash of the current implementation.\\n        address implementation = _getImplementation();\\n\\n        // If the code hash matches the new implementation then we return early.\\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\\n            return;\\n        }\\n\\n        // Create the deploycode by appending the magic prefix.\\n        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\\n\\n        // Deploy the code and set the new implementation address.\\n        address newImplementation;\\n        assembly {\\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\\n        }\\n\\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\\n        // actually fail this check. Should only happen if the contract creation from above runs\\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\\n        // should be doing this check anyway though.\\n        require(\\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\\n            \\\"L1ChugSplashProxy: code was not correctly deployed\\\"\\n        );\\n\\n        _setImplementation(newImplementation);\\n    }\\n\\n    /// @notice Modifies some storage slot within the proxy contract. Gives us a lot of power to\\n    ///         perform upgrades in a more transparent way. Only callable by the owner.\\n    /// @param _key   Storage key to modify.\\n    /// @param _value New value for the storage key.\\n    function setStorage(bytes32 _key, bytes32 _value) external proxyCallIfNotOwner {\\n        assembly {\\n            sstore(_key, _value)\\n        }\\n    }\\n\\n    /// @notice Changes the owner of the proxy contract. Only callable by the owner.\\n    /// @param _owner New owner of the proxy contract.\\n    function setOwner(address _owner) external proxyCallIfNotOwner {\\n        _setOwner(_owner);\\n    }\\n\\n    /// @notice Queries the owner of the proxy contract. Can only be called by the owner OR by\\n    ///         making an eth_call and setting the \\\"from\\\" address to address(0).\\n    /// @return Owner address.\\n    function getOwner() external proxyCallIfNotOwner returns (address) {\\n        return _getOwner();\\n    }\\n\\n    /// @notice Queries the implementation address. Can only be called by the owner OR by making an\\n    ///         eth_call and setting the \\\"from\\\" address to address(0).\\n    /// @return Implementation address.\\n    function getImplementation() external proxyCallIfNotOwner returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /// @notice Sets the implementation address.\\n    /// @param _implementation New implementation address.\\n    function _setImplementation(address _implementation) internal {\\n        assembly {\\n            sstore(IMPLEMENTATION_KEY, _implementation)\\n        }\\n    }\\n\\n    /// @notice Changes the owner of the proxy contract.\\n    /// @param _owner New owner of the proxy contract.\\n    function _setOwner(address _owner) internal {\\n        assembly {\\n            sstore(OWNER_KEY, _owner)\\n        }\\n    }\\n\\n    /// @notice Performs the proxy call via a delegatecall.\\n    function _doProxyCall() internal onlyWhenNotPaused {\\n        address implementation = _getImplementation();\\n\\n        require(implementation != address(0), \\\"L1ChugSplashProxy: implementation is not set yet\\\");\\n\\n        assembly {\\n            // Copy calldata into memory at 0x0....calldatasize.\\n            calldatacopy(0x0, 0x0, calldatasize())\\n\\n            // Perform the delegatecall, make sure to pass all available gas.\\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\\n\\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\\n            // overwrite the calldata that we just copied into memory but that doesn't really\\n            // matter because we'll be returning in a second anyway.\\n            returndatacopy(0x0, 0x0, returndatasize())\\n\\n            // Success == 0 means a revert. We'll revert too and pass the data up.\\n            if iszero(success) {\\n                revert(0x0, returndatasize())\\n            }\\n\\n            // Otherwise we'll just return and pass the data up.\\n            return(0x0, returndatasize())\\n        }\\n    }\\n\\n    /// @notice Queries the implementation address.\\n    /// @return Implementation address.\\n    function _getImplementation() internal view returns (address) {\\n        address implementation;\\n        assembly {\\n            implementation := sload(IMPLEMENTATION_KEY)\\n        }\\n        return implementation;\\n    }\\n\\n    /// @notice Queries the owner of the proxy contract.\\n    /// @return Owner address.\\n    function _getOwner() internal view returns (address) {\\n        address owner;\\n        assembly {\\n            owner := sload(OWNER_KEY)\\n        }\\n        return owner;\\n    }\\n\\n    /// @notice Gets the code hash for a given account.\\n    /// @param _account Address of the account to get a code hash for.\\n    /// @return Code hash for the account.\\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {\\n        bytes32 codeHash;\\n        assembly {\\n            codeHash := extcodehash(_account)\\n        }\\n        return codeHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/\",\r\n      \"@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/\",\r\n      \"@rari-capital/solmate/=node_modules/@rari-capital/solmate/\",\r\n      \"@cwia/=node_modules/clones-with-immutable-args/src/\",\r\n      \"forge-std/=node_modules/forge-std/src/\",\r\n      \"ds-test/=node_modules/ds-test/src/\",\r\n      \"clones-with-immutable-args/=node_modules/clones-with-immutable-args/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addressManager\",\"outputs\":[{\"internalType\":\"contract AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeProxyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"getProxyImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"implementationName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUpgrading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proxyType\",\"outputs\":[{\"internalType\":\"enum ProxyAdmin.ProxyType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AddressManager\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAddressManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setImplementationName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"enum ProxyAdmin.ProxyType\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"setProxyType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_upgrading\",\"type\":\"bool\"}],\"name\":\"setUpgrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"upgradeAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "ProxyAdmin", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000340b2d3543b72bdd8be1b85d0fc062942e7d495a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}