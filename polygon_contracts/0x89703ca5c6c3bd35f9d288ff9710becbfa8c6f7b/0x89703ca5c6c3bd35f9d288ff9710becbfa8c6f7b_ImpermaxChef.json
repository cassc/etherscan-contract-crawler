{"SourceCode": "// File: contracts\\Ownable.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\r\n\r\n// P1 - P3: OK\r\npragma solidity =0.6.6;\r\n\r\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\r\n// Edited by BoringCrypto\r\n\r\n// T1 - T4: OK\r\ncontract OwnableData {\r\n    // V1 - V5: OK\r\n    address public owner;\r\n    // V1 - V5: OK\r\n    address public pendingOwner;\r\n}\r\n\r\n// T1 - T4: OK\r\ncontract Ownable is OwnableData {\r\n    // E1: OK\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    // F1 - F9: OK\r\n    // C1 - C21: OK\r\n    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\r\n        if (direct) {\r\n            // Checks\r\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\r\n\r\n            // Effects\r\n            emit OwnershipTransferred(owner, newOwner);\r\n            owner = newOwner;\r\n        } else {\r\n            // Effects\r\n            pendingOwner = newOwner;\r\n        }\r\n    }\r\n\r\n    // F1 - F9: OK\r\n    // C1 - C21: OK\r\n    function claimOwnership() public {\r\n        address _pendingOwner = pendingOwner;\r\n\r\n        // Checks\r\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\r\n\r\n        // Effects\r\n        emit OwnershipTransferred(owner, _pendingOwner);\r\n        owner = _pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    // M1 - M5: OK\r\n    // C1 - C21: OK\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts\\libraries\\SafeMath.sol\r\n\r\npragma solidity =0.6.6;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts\\libraries\\SafeToken.sol\r\n\r\npragma solidity =0.6.6;\r\n\r\ninterface ERC20Interface {\r\n    function balanceOf(address user) external view returns (uint256);\r\n}\r\n\r\nlibrary SafeToken {\r\n    function myBalance(address token) internal view returns (uint256) {\r\n        return ERC20Interface(token).balanceOf(address(this));\r\n    }\r\n\r\n    function balanceOf(address token, address user) internal view returns (uint256) {\r\n        return ERC20Interface(token).balanceOf(user);\r\n    }\r\n\r\n    function safeApprove(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeApprove\");\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeTransfer\");\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeTransferFrom\");\r\n    }\r\n}\r\n\r\n// File: contracts\\libraries\\SignedSafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.6.6;\r\n\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two signed integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function toUInt256(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0, \"Integer < 0\");\r\n        return uint256(a);\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\IBorrowTracker.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IBorrowTracker {\r\n\tfunction trackBorrow(address borrower, uint borrowBalance, uint borrowIndex) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC20.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n// File: contracts\\interfaces\\IBorrowable.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IBorrowable {\r\n\r\n\t/*** Impermax ERC20 ***/\r\n\t\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\t\r\n\tfunction name() external pure returns (string memory);\r\n\tfunction symbol() external pure returns (string memory);\r\n\tfunction decimals() external pure returns (uint8);\r\n\tfunction totalSupply() external view returns (uint);\r\n\tfunction balanceOf(address owner) external view returns (uint);\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\tfunction approve(address spender, uint value) external returns (bool);\r\n\tfunction transfer(address to, uint value) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\t\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction nonces(address owner) external view returns (uint);\r\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\r\n\t/*** Pool Token ***/\r\n\t\r\n\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\r\n\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\r\n\tevent Sync(uint totalBalance);\r\n\t\r\n\tfunction underlying() external view returns (address);\r\n\tfunction factory() external view returns (address);\r\n\tfunction totalBalance() external view returns (uint);\r\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n\tfunction exchangeRate() external returns (uint);\r\n\tfunction mint(address minter) external returns (uint mintTokens);\r\n\tfunction redeem(address redeemer) external returns (uint redeemAmount);\r\n\tfunction skim(address to) external;\r\n\tfunction sync() external;\r\n\t\r\n\tfunction _setFactory() external;\r\n\t\r\n\t/*** Borrowable ***/\r\n\r\n\tevent BorrowApproval(address indexed owner, address indexed spender, uint value);\r\n\tevent Borrow(address indexed sender, address indexed borrower, address indexed receiver, uint borrowAmount, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\r\n\tevent Liquidate(address indexed sender, address indexed borrower, address indexed liquidator, uint seizeTokens, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\r\n\t\r\n\tfunction BORROW_FEE() external pure returns (uint);\r\n\tfunction collateral() external view returns (address);\r\n\tfunction reserveFactor() external view returns (uint);\r\n\tfunction exchangeRateLast() external view returns (uint);\r\n\tfunction borrowIndex() external view returns (uint);\r\n\tfunction totalBorrows() external view returns (uint);\r\n\tfunction borrowAllowance(address owner, address spender) external view returns (uint);\r\n\tfunction borrowBalance(address borrower) external view returns (uint);\t\r\n\tfunction borrowTracker() external view returns (address);\r\n\t\r\n\tfunction BORROW_PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\tfunction borrowApprove(address spender, uint256 value) external returns (bool);\r\n\tfunction borrowPermit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\tfunction borrow(address borrower, address receiver, uint borrowAmount, bytes calldata data) external;\r\n\tfunction liquidate(address borrower, address liquidator) external returns (uint seizeTokens);\r\n\tfunction trackBorrow(address borrower) external;\r\n\t\r\n\t/*** Borrowable Interest Rate Model ***/\r\n\r\n\tevent AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\r\n\tevent CalculateKink(uint kinkRate);\r\n\tevent CalculateBorrowRate(uint borrowRate);\r\n\t\r\n\tfunction KINK_BORROW_RATE_MAX() external pure returns (uint);\r\n\tfunction KINK_BORROW_RATE_MIN() external pure returns (uint);\r\n\tfunction KINK_MULTIPLIER() external pure returns (uint);\r\n\tfunction borrowRate() external view returns (uint);\r\n\tfunction kinkBorrowRate() external view returns (uint);\r\n\tfunction kinkUtilizationRate() external view returns (uint);\r\n\tfunction adjustSpeed() external view returns (uint);\r\n\tfunction rateUpdateTimestamp() external view returns (uint32);\r\n\tfunction accrualTimestamp() external view returns (uint32);\r\n\t\r\n\tfunction accrueInterest() external;\r\n\t\r\n\t/*** Borrowable Setter ***/\r\n\r\n\tevent NewReserveFactor(uint newReserveFactor);\r\n\tevent NewKinkUtilizationRate(uint newKinkUtilizationRate);\r\n\tevent NewAdjustSpeed(uint newAdjustSpeed);\r\n\tevent NewBorrowTracker(address newBorrowTracker);\r\n\r\n\tfunction RESERVE_FACTOR_MAX() external pure returns (uint);\r\n\tfunction KINK_UR_MIN() external pure returns (uint);\r\n\tfunction KINK_UR_MAX() external pure returns (uint);\r\n\tfunction ADJUST_SPEED_MIN() external pure returns (uint);\r\n\tfunction ADJUST_SPEED_MAX() external pure returns (uint);\r\n\t\r\n\tfunction _initialize (\r\n\t\tstring calldata _name, \r\n\t\tstring calldata _symbol,\r\n\t\taddress _underlying, \r\n\t\taddress _collateral\r\n\t) external;\r\n\tfunction _setReserveFactor(uint newReserveFactor) external;\r\n\tfunction _setKinkUtilizationRate(uint newKinkUtilizationRate) external;\r\n\tfunction _setAdjustSpeed(uint newAdjustSpeed) external;\r\n\tfunction _setBorrowTracker(address newBorrowTracker) external;\r\n}\r\n\r\n// File: contracts\\interfaces\\IRewarder.sol\r\n\r\npragma solidity =0.6.6;\r\n\r\n\r\n\r\ninterface IRewarder {\r\n    function onReward(address _borrowable, address user, address recipient, uint256 rewardAmount, uint256 newShares) external;\r\n    function pendingTokens(address _borrowable, address user, uint256 rewardAmount) external view returns (IERC20[] memory, uint256[] memory);\r\n}\r\n\r\n// File: contracts\\interfaces\\IFactory.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IFactory {\r\n\tevent LendingPoolInitialized(address indexed uniswapV2Pair, address indexed token0, address indexed token1,\r\n\t\taddress collateral, address borrowable0, address borrowable1, uint lendingPoolId);\r\n\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\tevent NewAdmin(address oldAdmin, address newAdmin);\r\n\tevent NewReservesPendingAdmin(address oldReservesPendingAdmin, address newReservesPendingAdmin);\r\n\tevent NewReservesAdmin(address oldReservesAdmin, address newReservesAdmin);\r\n\tevent NewReservesManager(address oldReservesManager, address newReservesManager);\r\n\t\r\n\tfunction admin() external view returns (address);\r\n\tfunction pendingAdmin() external view returns (address);\r\n\tfunction reservesAdmin() external view returns (address);\r\n\tfunction reservesPendingAdmin() external view returns (address);\r\n\tfunction reservesManager() external view returns (address);\r\n\r\n\tfunction getLendingPool(address uniswapV2Pair) external view returns (\r\n\t\tbool initialized, \r\n\t\tuint24 lendingPoolId, \r\n\t\taddress collateral, \r\n\t\taddress borrowable0, \r\n\t\taddress borrowable1\r\n\t);\r\n\tfunction allLendingPools(uint) external view returns (address uniswapV2Pair);\r\n\tfunction allLendingPoolsLength() external view returns (uint);\r\n\t\r\n\tfunction bDeployer() external view returns (address);\r\n\tfunction cDeployer() external view returns (address);\r\n\tfunction simpleUniswapOracle() external view returns (address);\r\n\r\n\tfunction createCollateral(address uniswapV2Pair) external returns (address collateral);\r\n\tfunction createBorrowable0(address uniswapV2Pair) external returns (address borrowable0);\r\n\tfunction createBorrowable1(address uniswapV2Pair) external returns (address borrowable1);\r\n\tfunction initializeLendingPool(address uniswapV2Pair) external;\r\n\r\n\tfunction _setPendingAdmin(address newPendingAdmin) external;\r\n\tfunction _acceptAdmin() external;\r\n\tfunction _setReservesPendingAdmin(address newPendingAdmin) external;\r\n\tfunction _acceptReservesAdmin() external;\r\n\tfunction _setReservesManager(address newReservesManager) external;\r\n}\r\n\r\n// File: contracts\\ImpermaxChef.sol\r\n\r\npragma solidity =0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ImpermaxChef is IBorrowTracker, Ownable {\r\n\tusing SafeMath for uint256;\r\n\tusing SignedSafeMath for int256;\r\n\tusing SafeToken for address;\r\n\r\n\tstruct UserInfo {\r\n\t\tuint256 shares;\r\n\t\tint256 rewardDebt;\r\n\t}\r\n\r\n\tstruct PoolInfo {\r\n\t\tuint256 totalShares;\r\n\t\tuint256 accRewardPerShare;\r\n\t\tuint256 lastRewardTime;\r\n\t\tuint256 allocPoint;\r\n\t\tIRewarder rewarder;\r\n\t}\r\n\r\n\taddress public immutable rewardToken;\r\n\tuint256 public rewardPerSec;\r\n\t\r\n\tmapping(address => PoolInfo) public poolInfo;\r\n\tmapping(address => mapping(address => UserInfo)) public userInfo; // [borrowable][user]\r\n\t\r\n\tuint256 public totalAllocPoint;\r\n\r\n\tuint256 private constant ACC_PRECISION = 2**160;\r\n\tuint256 private constant SHARES_PRECISION = 2**96;\r\n\tuint256 private constant MAX_REWARD_PER_SEC = 1.58e18; // limit reward to 50M IMX per year\r\n\r\n\tevent TrackBorrow(address indexed borrowable, address indexed borrower, uint256 borrowBalance, uint256 borrowIndex);\r\n\tevent Harvest(address indexed borrowable, address indexed user, uint256 amount);\r\n\tevent LogSetReward(uint256 rewardPerSec);\r\n\tevent LogSetPool(address indexed borrowable, uint256 allocPoint, IRewarder indexed rewarder, bool overwrite);\r\n\tevent LogUpdatePool(address indexed borrowable, uint256 lastRewardTime, uint256 totalShares, uint256 accRewardPerShare);\r\n\t\r\n\tconstructor(address _rewardToken, uint256 _rewardPerSec) public {\r\n\t\trequire(_rewardPerSec < MAX_REWARD_PER_SEC, \"ImperaxChef: MAX_REWARD_PER_SEC\");\r\n\t\trewardToken = _rewardToken;\r\n\t\trewardPerSec = _rewardPerSec;\r\n\t\temit LogSetReward(_rewardPerSec);\r\n\t}\r\n\t\t\r\n\t/* \r\n\t * Owner\r\n\t */\r\n\t \r\n\tfunction setReward(uint256 _rewardPerSec) public onlyOwner {\r\n\t\trequire(_rewardPerSec < MAX_REWARD_PER_SEC, \"ImperaxChef: MAX_REWARD_PER_SEC\");\r\n\t\trewardPerSec = _rewardPerSec;\r\n\t\temit LogSetReward(_rewardPerSec);\r\n\t}\r\n\t\r\n\tfunction set(address borrowable, uint256 allocPoint, IRewarder rewarder, bool overwrite) public onlyOwner {\r\n\t\tPoolInfo storage pool = poolInfo[borrowable];\r\n\t\ttotalAllocPoint = totalAllocPoint.sub(pool.allocPoint).add(allocPoint);\r\n\t\tpool.allocPoint = allocPoint;\r\n\t\tif (overwrite) pool.rewarder = rewarder;\r\n\t\temit LogSetPool(borrowable, allocPoint, overwrite ? rewarder : pool.rewarder, overwrite);\r\n\t}\r\n\t\r\n\tfunction setUniswapV2Pair(IFactory factory, address uniswapV2Pair, uint256 allocPoint, IRewarder rewarder, bool overwrite) external {\r\n\t\t(,,, address borrowable0, address borrowable1) = factory.getLendingPool(uniswapV2Pair);\r\n\t\tset(borrowable0, allocPoint, rewarder, overwrite);\r\n\t\tset(borrowable1, allocPoint, rewarder, overwrite);\r\n\t}\r\n\t\t\r\n\t/* \r\n\t * Interactions\r\n\t */\r\n\t\r\n\tfunction pendingReward(address borrowable, address _user) external view returns (uint256 pending) {\r\n\t\tPoolInfo memory pool = poolInfo[borrowable];\r\n\t\tUserInfo memory user = userInfo[borrowable][_user];\r\n\t\tuint256 accRewardPerShare = pool.accRewardPerShare;\r\n\t\tuint256 totalShares = pool.totalShares;\r\n\t\tif (getBlockTimestamp() > pool.lastRewardTime && totalShares != 0) {\r\n\t\t\tuint256 timeElapsed = getBlockTimestamp().sub(pool.lastRewardTime);\r\n\t\t\tuint256 reward = timeElapsed.mul(rewardPerSec).mul(pool.allocPoint) / totalAllocPoint;\r\n\t\t\taccRewardPerShare = accRewardPerShare.add(reward.mul(ACC_PRECISION) / totalShares);\r\n\t\t}\r\n\t\tpending = int256(user.shares.mul(accRewardPerShare) / ACC_PRECISION).sub(user.rewardDebt).toUInt256();\r\n\t}\r\n\r\n\tfunction updatePool(address borrowable) public returns (PoolInfo memory pool) {\r\n\t\tpool = poolInfo[borrowable];\r\n\t\tif (getBlockTimestamp() > pool.lastRewardTime) {\r\n\t\t\tuint256 totalShares = pool.totalShares;\r\n\t\t\tif (totalShares > 0) {\r\n\t\t\t\tuint256 timeElapsed = getBlockTimestamp().sub(pool.lastRewardTime);\r\n\t\t\t\tuint256 reward = timeElapsed.mul(rewardPerSec).mul(pool.allocPoint) / totalAllocPoint;\r\n\t\t\t\tpool.accRewardPerShare = pool.accRewardPerShare.add((reward.mul(ACC_PRECISION) / totalShares));\r\n\t\t\t}\r\n\t\t\tpool.lastRewardTime = getBlockTimestamp();\r\n\t\t\tpoolInfo[borrowable] = pool;\r\n\t\t\temit LogUpdatePool(borrowable, pool.lastRewardTime, totalShares, pool.accRewardPerShare);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction harvest(address borrowable, address to) public {\r\n\t\tPoolInfo memory pool = updatePool(borrowable);\r\n\t\tUserInfo storage user = userInfo[borrowable][msg.sender];\r\n\t\tint256 accumulatedReward = int256(user.shares.mul(pool.accRewardPerShare) / ACC_PRECISION);\r\n\t\tuint256 _pendingReward = accumulatedReward.sub(user.rewardDebt).toUInt256();\r\n\r\n\t\t// Effects\r\n\t\tuser.rewardDebt = accumulatedReward;\r\n\r\n\t\t// Interactions\r\n\t\tif (_pendingReward != 0) {\r\n\t\t\trewardToken.safeTransfer(to, _pendingReward);\r\n\t\t}\r\n\t\tif (address(pool.rewarder) != address(0)) {\r\n\t\t\tpool.rewarder.onReward(borrowable, msg.sender, to, _pendingReward, user.shares);\r\n\t\t}\r\n\r\n\t\temit Harvest(borrowable, msg.sender, _pendingReward);\r\n\t}\r\n\t\r\n\tfunction trackBorrow(address borrower, uint borrowBalance, uint borrowIndex) external override {\r\n\t\taddress borrowable = msg.sender;\r\n\t\tPoolInfo memory pool = updatePool(borrowable);\r\n\t\t\r\n\t\t// Effects\r\n\t\tUserInfo storage user = userInfo[borrowable][borrower];\r\n\t\tuint newShares = borrowBalance.mul(SHARES_PRECISION).div(borrowIndex);\r\n\t\tint256 diffShares = int256(newShares).sub(int256(user.shares));\r\n\t\tint256 diffRewardDebt = diffShares.mul(int256(pool.accRewardPerShare)) / int256(ACC_PRECISION);\r\n\t\tuser.shares = newShares;\r\n\t\tuser.rewardDebt = user.rewardDebt.add(diffRewardDebt);\r\n\t\tpoolInfo[borrowable].totalShares = int256(pool.totalShares).add(diffShares).toUInt256();\r\n\r\n        // Interactions\r\n\t\tif (address(pool.rewarder) != address(0)) {\r\n\t\t\tpool.rewarder.onReward(borrowable, borrower, borrower, 0, newShares);\r\n\t\t}\r\n\t\t\r\n\t\temit TrackBorrow(borrowable, borrower, borrowBalance, borrowIndex);\r\n\t}\r\n\t\r\n\t/*\r\n\t * Aggregators\r\n\t */\r\n\t \r\n\tfunction massUpdatePools(address[] calldata borrowables) external {\r\n\t\tuint256 len = borrowables.length;\r\n\t\tfor (uint256 i = 0; i < len; ++i) {\r\n\t\t\tupdatePool(borrowables[i]);\r\n\t\t}\r\n\t}\r\n\t \r\n\tfunction massHarvest(address[] calldata borrowables, address to) external {\r\n\t\tuint256 len = borrowables.length;\r\n\t\tfor (uint256 i = 0; i < len; ++i) {\r\n\t\t\tharvest(borrowables[i], to);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction getBlockTimestamp() public virtual view returns (uint256) {\r\n\t\treturn block.timestamp;\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerSec\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract IRewarder\",\"name\":\"rewarder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"overwrite\",\"type\":\"bool\"}],\"name\":\"LogSetPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerSec\",\"type\":\"uint256\"}],\"name\":\"LogSetReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"}],\"name\":\"LogUpdatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"}],\"name\":\"TrackBorrow\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"borrowables\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"massHarvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"borrowables\",\"type\":\"address[]\"}],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IRewarder\",\"name\":\"rewarder\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IRewarder\",\"name\":\"rewarder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"overwrite\",\"type\":\"bool\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerSec\",\"type\":\"uint256\"}],\"name\":\"setReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapV2Pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IRewarder\",\"name\":\"rewarder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"overwrite\",\"type\":\"bool\"}],\"name\":\"setUniswapV2Pair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"}],\"name\":\"trackBorrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"}],\"name\":\"updatePool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IRewarder\",\"name\":\"rewarder\",\"type\":\"address\"}],\"internalType\":\"struct ImpermaxChef.PoolInfo\",\"name\":\"pool\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rewardDebt\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ImpermaxChef", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "00000000000000000000000060bb3d364b765c497c8ce50ae0ae3f0882c5bd050000000000000000000000000000000000000000000000000000000000989680", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://160226d2f61da554f5c11f953fd988a25bd4c14647955f7abf3b9013881f5927"}