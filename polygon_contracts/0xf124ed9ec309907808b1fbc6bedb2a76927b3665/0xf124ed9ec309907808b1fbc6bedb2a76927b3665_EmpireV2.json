{"SourceCode": "// File @openzeppelin/contracts/utils/Context.sol@v4.4.1\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.4.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/dependencies/Controller.sol\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\ncontract Controller is Ownable {\r\n    mapping(address => bool) public operator;\r\n    event OperatorCreated(address _operator, bool _whiteList);\r\n\r\n    modifier onlyOperator() {\r\n        require(operator[msg.sender], \"Only-Operator\");\r\n        _;\r\n    }\r\n\r\n    function setOperator(address _operator, bool _whiteList) public onlyOwner {\r\n        operator[_operator] = _whiteList;\r\n        emit OperatorCreated(_operator, _whiteList);\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/EmpireV2.sol\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IERC20 {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function balanceOf(address owner) external view returns (uint256);\r\n}\r\n\r\ninterface IEmpireFactory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\ninterface IEmpireRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\n/// @title EmpireV2: A contract for the EMPIREv2 token\r\n/// @author Empire Capital (Splnty, Tranquil Flow) https://github.com/Empire-Capital\r\n/// @dev This contract defines the core logic of EMPIRE token\r\ncontract EmpireV2 is Controller {\r\n    string  private _name = \"Empire Network\";\r\n    string  private _symbol = \"EMPIRE\";\r\n    uint256 private _totalSupply;\r\n    uint8   private _decimals = 18;\r\n\r\n    address public pair;\r\n    uint256 public addLiquidityAmount;\r\n    uint256 public buyLiquidityFee;\r\n    uint256 public sellLiquidityFee;\r\n    uint256 public blockCooldownAmount;\r\n\r\n    bool private _inSwap;\r\n    bool public tradingActive;\r\n    bool public antiBotsActive;\r\n\r\n    IEmpireRouter private router;\r\n    \r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => bool) public _excludedFees;\r\n    mapping (address => bool) public _excludedAntiMev;\r\n    mapping (address => uint256) public antiMevBlock;\r\n    mapping (address => bool) public automatedMarketMakerPairs;\r\n   \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event LiquidityAdded(uint256 tokens, uint256 nativeCoin, uint256 lpAdded);\r\n    event NewLimit(uint256 newAddLiqAmount);\r\n    event NewFees(uint256 newBuyLiqFee, uint256 newSellLiqFee);\r\n    event SetExcludedFees(address addr, bool status);\r\n    event SetTradingActive(bool status);\r\n    \r\n    /// @param _router The address of the router that EMPIRE is interacting with for transfer fees\r\n    constructor (address _router) {\r\n\r\n        router = IEmpireRouter(_router);        \r\n\r\n        pair = IEmpireFactory(router.factory())\r\n            .createPair(address(this), router.WETH());\r\n\r\n        setAutomatedMarketMakerPair(pair, true);\r\n\r\n        addLiquidityAmount = 100 * 10 **_decimals;\r\n        buyLiquidityFee = 5000;         // 5%\r\n        sellLiquidityFee = 5000;        // 5%\r\n        blockCooldownAmount = 1;\r\n        antiBotsActive = true;\r\n        \r\n        setExcludedFees(address(this), true);\r\n        setExcludedFees(owner(), true);\r\n        setExcludedAntiMev(address(this), true);\r\n    }\r\n    \r\n    receive() payable external {}\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            USER FUNCTIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    \r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"Wallet address can not be the zero address!\");\r\n        require(spender != address(0), \"Spender can not be the zero address!\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n    \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"Decreased allowance below zero!\");\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    /// @notice High level function to move `amount` of tokens from `msg.sender` to `recipient` and applying fees\r\n    /// @dev Transfers amount of tokens from the msg.sender to recipient\r\n    /// @param recipient The address that is receiving tokens\r\n    /// @param amount The initial amount of tokens being sent, before fees on transfer\r\n    /// @return True if transfer is successful, else false\r\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n    /// @notice High level function to move `amount` of tokens from `sender` to `recipient` and applying fees\r\n    /// @dev Transfers amount of tokens from sender to recipient\r\n    /// @param sender The address that is sending tokens\r\n    /// @param recipient The address that is receiving tokens\r\n    /// @param amount The initial amount of tokens being sent, before fees on transfer\r\n    /// @return True if transfer is succesful, else false\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"Amount exceeds allowance!\");\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, currentAllowance - amount);    \r\n        return true;\r\n    }\r\n\r\n    /// @notice Low level function that sends `amount` from `sender` to `recipient`, checking limitations & apply fees\r\n    /// @dev Transfers amount of tokens from sender to recipient\r\n    /// @param sender The address that is sending tokens\r\n    /// @param recipient The address that is receiving tokens\r\n    /// @param amount The initial amount of tokens being sent, before fees on transfer\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n\r\n        //anti mev\r\n        if(antiBotsActive) {\r\n            if(!_excludedAntiMev[sender] && !_excludedAntiMev[recipient])\r\n            {\r\n                address actor = antiMevCheck(sender, recipient);\r\n                antiMevFreq(actor);\r\n                antiMevBlock[actor] = block.number;\r\n            }\r\n        }\r\n        \r\n        uint256 senderBalance = balanceOf(sender);\r\n        require(senderBalance >= amount, \"Amount exceeds senders balance!\");\r\n        _balances[sender] = senderBalance - amount;\r\n\r\n       if(!tradingActive){\r\n            require(_excludedFees[sender] || _excludedFees[recipient], \"Trading is not active.\");\r\n        }\r\n\r\n        bool takeFee = !_inSwap;\r\n\r\n        if(\r\n            _excludedFees[sender] || \r\n            _excludedFees[recipient] \r\n        ) {\r\n            takeFee = false;\r\n        }\r\n\r\n        if(takeFee) {\r\n            uint256 liquidityAmount = 0;\r\n        \r\n            //if buy\r\n            if(automatedMarketMakerPairs[sender]) {\r\n                liquidityAmount = amount * buyLiquidityFee / 100000;\r\n            }\r\n\r\n            //if sell\r\n            if(automatedMarketMakerPairs[recipient]) {\r\n                liquidityAmount = amount * sellLiquidityFee / 100000;\r\n                \r\n                swapAddLiquidity();\r\n            }\r\n\r\n            if(liquidityAmount > 0){ \r\n                amount -= liquidityAmount;\r\n                _balances[address(this)] += liquidityAmount;\r\n                emit Transfer(sender, address(this), liquidityAmount);\r\n            }\r\n        }\r\n        \r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /// @dev Adds liquidity on the EMPIRE/Native Coin pair\r\n    /// @param tokenAmount The amount of tokens for adding to liquidity\r\n    /// @param amount The amount of native coin for adding to liquidity\r\n    function addLiquidity(uint256 tokenAmount, uint256 amount) internal virtual {\r\n        _approve(address(this), address(router), tokenAmount);\r\n        (uint256 tokens, uint256 eth, uint256 lpCreated) = \r\n        router.addLiquidityETH{value: amount}(address(this), tokenAmount, 0, 0, address(this), block.timestamp);\r\n        emit LiquidityAdded(tokens, eth, lpCreated);\r\n    }\r\n\r\n    /// @dev Swaps `amount` EMPIRE for native coin\r\n    /// @param amount The amount of EMPIRE to swap\r\n    function swapTokensForEth(uint256 amount) internal virtual {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        _approve(address(this), address(router), amount);\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp);\r\n    }\r\n\r\n    /// @notice Sells EMPIRE for native coin and uses both to add liquidity\r\n    /// @dev Checks if the amount of EMPIRE on the contract is > addLiquidityAmount\r\n    function swapAddLiquidity() internal virtual {\r\n        uint256 tokenBalance = balanceOf(address(this));\r\n        if(!_inSwap && tokenBalance >= addLiquidityAmount) {\r\n            _inSwap = true;\r\n            \r\n            uint256 sellAmount = tokenBalance;\r\n            uint256 sellHalf = sellAmount / 2;\r\n\r\n            uint256 initialEth = address(this).balance;\r\n            swapTokensForEth(sellHalf);\r\n            uint256 receivedEth = address(this).balance - initialEth;\r\n\r\n            addLiquidity(sellAmount - sellHalf, (receivedEth));\r\n\r\n            _inSwap = false;\r\n        }\r\n    }\r\n\r\n    /// @notice Burns `amount` EMPIRE tokens\r\n    /// @dev Used to manually burn EMPIRE\r\n    /// @param amount The amount of EMPIRE to burn\r\n    function manualBurn(uint256 amount) external {\r\n        address account = msg.sender;\r\n        require(amount <= _balances[account], \"Burn amount exceeds balance\");\r\n        _balances[account] -= amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ANTI BOT FUNCTIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function antiMevCheck(address _from, address _to) internal virtual returns (address) {\r\n        require(!isContract(_to) || !isContract(_from), \"No bots allowed!\");\r\n        if (isContract(_to)) return _from;\r\n        else return _to;\r\n    }\r\n\r\n    function antiMevFreq(address addr) internal virtual {\r\n        bool isAllowed = antiMevBlock[addr] == 0 ||\r\n            ((antiMevBlock[addr] + blockCooldownAmount) < (block.number + 1));\r\n        require(isAllowed, \"Max tx frequency exceeded!\");\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ADMIN FUNCTIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Withdraws token address or native if 0x0 is input\r\n    /// @dev Withdraws native coin or tokens from contract if some gets stuck on the contract\r\n    /// @param token The address of the token being withdrawn\r\n    function recover(address token) external onlyOwner {\r\n        if (token == 0x0000000000000000000000000000000000000000) {\r\n           (bool success,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n           require(success, \"Transfer failed.\");\r\n        } else {\r\n            IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    /// @notice Changes antiBotsActive to `value`\r\n    /// @dev Determines if anti-MEV checks are conducted on transfers\r\n    /// @param value Determines the new value for antiBotsActive\r\n    function setAntiBotsActive(bool value) external onlyOwner {\r\n        antiBotsActive = value;\r\n    }\r\n\r\n    /// @notice Defines the new value for addLiquidityAmount (`_addLiquidityAmount`)\r\n    /// @dev addLiquidityAmount = how many tokens to hold on contract before selling for liquidity\r\n    /// @param _addLiquidityAmount Determines the new value for addLiquidityAmount\r\n    function setLimit(uint256 _addLiquidityAmount) external onlyOwner {\r\n        addLiquidityAmount = _addLiquidityAmount * 10**_decimals;\r\n        emit NewLimit(_addLiquidityAmount);\r\n    }\r\n\r\n    /// @dev Defines the fees on transfer for buys and sells separately\r\n    /// @param _buyLiquidityFee Determines the new value for buyLiquidityFee\r\n    /// @param _sellLiquidityFee Determines the new value for sellLiquidityFee\r\n    function setFees(\r\n        uint256 _buyLiquidityFee,\r\n        uint256 _sellLiquidityFee\r\n        ) external onlyOwner {\r\n        require(\r\n            _buyLiquidityFee <= 5000\r\n            && _sellLiquidityFee <= 5000\r\n            , \"Fees cannot be more than 5 percent\");\r\n        buyLiquidityFee = _buyLiquidityFee;\r\n        sellLiquidityFee = _sellLiquidityFee;\r\n        emit NewFees(_buyLiquidityFee, _sellLiquidityFee);\r\n    }\r\n\r\n    /// @notice Defines if an address (`addy`) is exempt from fees on transfer\r\n    /// @param addy Determines the address to be excluded from fees on transfer\r\n    /// @param status Determines if `addy` is excluded from fees on transfer\r\n    function setExcludedFees(address addy, bool status) public onlyOwner {\r\n        _excludedFees[addy] = status;\r\n        emit SetExcludedFees(addy, status);\r\n    }\r\n\r\n    /// @notice Defines if an address (`addy`) is exempt from anti-MEV checks\r\n    /// @param addy Determines the address to be excluded from anti-MEV checks\r\n    /// @param status Determines if `addy` is excluded from anti-MEV checks\r\n    function setExcludedAntiMev(address addy, bool status) public onlyOwner {\r\n        _excludedAntiMev[addy] = status;\r\n    }\r\n\r\n    /// @notice Defines if `addy` is a DEX trading pair for the EMPIRE token\r\n    /// @dev Specifies the pair address contract\r\n    /// @param addy Determines the address of the market maker pair\r\n    /// @param status Determines if `addy` is a market maker pair\r\n    function setAutomatedMarketMakerPair(address addy, bool status) public onlyOwner {\r\n        automatedMarketMakerPairs[addy] = status;\r\n    }\r\n\r\n\r\n    /// @notice Changes the tradingActive to `status`\r\n    /// @dev tradingActive determines if trading on a DEX is enabled \r\n    /// @param status Determines the new status for tradingActive\r\n    function setTradingActive(bool status) external onlyOwner {\r\n        tradingActive = status;\r\n        emit SetTradingActive(status);\r\n    }\r\n\r\n    /// @notice Changes the setBlockCooldown variable to `value`\r\n    /// @dev Used to determine anti-MEV logic, setting how many blocks can elapse between transfers\r\n    /// @param value Determines the new value for setBlockCooldown\r\n    function setBlockCooldown(uint value) external onlyOwner {\r\n        blockCooldownAmount = value;\r\n    }\r\n\r\n    /// @notice Changes the router variable to `_router`\r\n    /// @dev Used for changing which router is integrated into the auto-liquidity feature\r\n    /// @param _router Determines the address of the new router\r\n    function changeRouter(address _router) external onlyOwner {\r\n        router = IEmpireRouter(_router);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                          BRIDGING FUNCTIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    // BRIDGE OPERATOR ONLY REQUIRES 2BA - TWO BLOCKCHAIN AUTHENTICATION //\r\n\r\n    /// @dev Receives `amount` EMPIRE from a cross chain transfer\r\n    /// @param account The address that is receiving a cross chain transfer\r\n    /// @param amount The amount of EMPIRE tokens being received cross chain\r\n    function unlock(address account, uint256 amount) external onlyOperator {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /// @notice Called by bridge when user has calls function lock() on LockBurnBridge\r\n    /// @dev Initiates cross chain transfer of `amount` EMPIRE to another chain\r\n    /// @param account The address that is doing a cross chain transfer\r\n    /// @param amount The amount of EMPIRE tokens being transferred cross chain\r\n    function lock(address account, uint256 amount) external onlyOperator {\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nativeCoin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpAdded\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBuyLiqFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSellLiqFee\",\"type\":\"uint256\"}],\"name\":\"NewFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAddLiqAmount\",\"type\":\"uint256\"}],\"name\":\"NewLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_whiteList\",\"type\":\"bool\"}],\"name\":\"OperatorCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetExcludedFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetTradingActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_excludedAntiMev\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_excludedFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidityAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antiBotsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"antiMevBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockCooldownAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"changeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manualBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAntiBotsActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setBlockCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setExcludedAntiMev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setExcludedFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyLiquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellLiquidityFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_addLiquidityAmount\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whiteList\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setTradingActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EmpireV2", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b2855a6daeebdb72b0176a479a983066ae9775a6", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b90057c6da5e45422c6d7352e4a563fdbe7874f288a90b2c3826febaddbd2f75"}