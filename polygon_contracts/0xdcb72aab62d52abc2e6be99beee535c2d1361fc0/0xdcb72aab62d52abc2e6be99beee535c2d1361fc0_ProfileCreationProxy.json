{"SourceCode": "{{\r\n  \"sources\": {\r\n    \"contracts/FollowNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\nimport {ERC2981CollectionRoyalties} from 'contracts/base/ERC2981CollectionRoyalties.sol';\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\nimport {HubRestricted} from 'contracts/base/HubRestricted.sol';\\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport {IERC721Timestamped} from 'contracts/interfaces/IERC721Timestamped.sol';\\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\\nimport {LensBaseERC721} from 'contracts/base/LensBaseERC721.sol';\\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\\nimport {FollowTokenURILib} from 'contracts/libraries/token-uris/FollowTokenURILib.sol';\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\n\\n/**\\n * @custom:upgradeable Beacon proxy. The beacon, responsible for returning the implementation address, is the LensHub.\\n */\\ncontract FollowNFT is HubRestricted, LensBaseERC721, ERC2981CollectionRoyalties, IFollowNFT {\\n    using Strings for uint256;\\n\\n    string constant FOLLOW_NFT_NAME_SUFFIX = '-Follower';\\n    string constant FOLLOW_NFT_SYMBOL_SUFFIX = '-Fl';\\n\\n    uint256[5] ___DEPRECATED_SLOTS; // Deprecated slots, previously used for delegations.\\n    uint256 internal _followedProfileId;\\n\\n    // Old uint256 `_lastFollowTokenId` slot splitted into two uint128s to include `_followerCount`.\\n    uint128 internal _lastFollowTokenId;\\n    // `_followerCount` will not be decreased when a follower profile is burned, making the counter not fully accurate.\\n    // New variable added in V2 in the same slot, lower-ordered to not conflict with previous storage layout.\\n    uint128 internal _followerCount;\\n\\n    bool private _initialized;\\n\\n    // Introduced in v2\\n    mapping(uint256 => Types.FollowData) internal _followDataByFollowTokenId;\\n    mapping(uint256 => uint256) internal _followTokenIdByFollowerProfileId;\\n    mapping(uint256 => uint256) internal _followApprovalByFollowTokenId;\\n    uint256 internal _royaltiesInBasisPoints;\\n\\n    event FollowApproval(uint256 indexed followerProfileId, uint256 indexed followTokenId);\\n\\n    modifier whenNotPaused() {\\n        if (ILensHub(HUB).getState() == Types.ProtocolState.Paused) {\\n            revert Errors.Paused();\\n        }\\n        _;\\n    }\\n\\n    constructor(address hub) HubRestricted(hub) {\\n        _initialized = true;\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function initialize(uint256 profileId) external override {\\n        // This is called right after deployment by the LensHub, so we can skip the onlyHub check.\\n        if (_initialized) {\\n            revert Errors.Initialized();\\n        }\\n        _initialized = true;\\n        _followedProfileId = profileId;\\n        _setRoyalty(1000); // 10% of royalties\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function follow(\\n        uint256 followerProfileId,\\n        address transactionExecutor,\\n        uint256 followTokenId\\n    ) external override onlyHub returns (uint256) {\\n        if (_followTokenIdByFollowerProfileId[followerProfileId] != 0) {\\n            revert AlreadyFollowing();\\n        }\\n\\n        if (followTokenId == 0) {\\n            // Fresh follow.\\n            return _followMintingNewToken(followerProfileId);\\n        }\\n\\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\\n        if (followTokenOwner != address(0)) {\\n            // Provided follow token is wrapped.\\n            return\\n                _followWithWrappedToken({\\n                    followerProfileId: followerProfileId,\\n                    transactionExecutor: transactionExecutor,\\n                    followTokenId: followTokenId\\n                });\\n        }\\n\\n        uint256 currentFollowerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\\n        if (currentFollowerProfileId != 0) {\\n            // Provided follow token is unwrapped.\\n            // It has a follower profile set already, it can only be used to follow if that profile was burnt.\\n            return\\n                _followWithUnwrappedTokenFromBurnedProfile({\\n                    followerProfileId: followerProfileId,\\n                    followTokenId: followTokenId,\\n                    currentFollowerProfileId: currentFollowerProfileId,\\n                    transactionExecutor: transactionExecutor\\n                });\\n        }\\n\\n        // Provided follow token does not exist anymore, it can only be used if the profile attempting to follow is\\n        // allowed to recover it.\\n        return _followByRecoveringToken({followerProfileId: followerProfileId, followTokenId: followTokenId});\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function unfollow(uint256 unfollowerProfileId) external override onlyHub {\\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[unfollowerProfileId];\\n        if (followTokenId == 0) {\\n            revert NotFollowing();\\n        }\\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\\n        // LensHub already validated that this action can only be performed by the unfollower profile's owner or one of\\n        // his approved delegated executors.\\n        _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\\n        if (followTokenOwner == address(0)) {\\n            // Follow token was unwrapped, allowing recovery.\\n            _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover = unfollowerProfileId;\\n        }\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function removeFollower(uint256 followTokenId) external override whenNotPaused {\\n        if (_isApprovedOrOwner(msg.sender, followTokenId)) {\\n            _unfollowIfHasFollower(followTokenId, msg.sender);\\n        } else {\\n            revert DoesNotHavePermissions();\\n        }\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function approveFollow(uint256 followerProfileId, uint256 followTokenId) external override {\\n        if (!IERC721Timestamped(HUB).exists(followerProfileId)) {\\n            revert Errors.TokenDoesNotExist();\\n        }\\n        // `followTokenId` allowed to be zero as a way to clear the approval.\\n        if (followTokenId != 0 && _unsafeOwnerOf(followTokenId) == address(0)) {\\n            revert OnlyWrappedFollowTokens();\\n        }\\n        if (_isApprovedOrOwner(msg.sender, followTokenId)) {\\n            _approveFollow(followerProfileId, followTokenId);\\n        } else {\\n            revert DoesNotHavePermissions();\\n        }\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function wrap(uint256 followTokenId, address wrappedTokenReceiver) external override whenNotPaused {\\n        if (wrappedTokenReceiver == address(0)) {\\n            revert Errors.InvalidParameter();\\n        }\\n        _wrap(followTokenId, wrappedTokenReceiver);\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function wrap(uint256 followTokenId) external override whenNotPaused {\\n        _wrap(followTokenId, address(0));\\n    }\\n\\n    function _wrap(uint256 followTokenId, address wrappedTokenReceiver) internal {\\n        if (_isFollowTokenWrapped(followTokenId)) {\\n            revert AlreadyWrapped();\\n        }\\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\\n        if (followerProfileId == 0) {\\n            followerProfileId = _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\\n            if (followerProfileId == 0) {\\n                revert FollowTokenDoesNotExist();\\n            }\\n            delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\\n        }\\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\\n        if (msg.sender != followerProfileOwner) {\\n            revert DoesNotHavePermissions();\\n        }\\n        _mint(wrappedTokenReceiver == address(0) ? followerProfileOwner : wrappedTokenReceiver, followTokenId);\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function unwrap(uint256 followTokenId) external override whenNotPaused {\\n        if (_followDataByFollowTokenId[followTokenId].followerProfileId == 0) {\\n            revert NotFollowing();\\n        }\\n        super.burn(followTokenId);\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function processBlock(uint256 followerProfileId) external override onlyHub returns (bool) {\\n        bool hasUnfollowed;\\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[followerProfileId];\\n        if (followTokenId != 0) {\\n            if (!_isFollowTokenWrapped(followTokenId)) {\\n                // Wrap it first, so the user stops following but does not lose the token when being blocked.\\n                _mint(IERC721(HUB).ownerOf(followerProfileId), followTokenId);\\n            }\\n            _unfollow(followerProfileId, followTokenId);\\n            hasUnfollowed = true;\\n        }\\n        return hasUnfollowed;\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function getFollowerProfileId(uint256 followTokenId) external view override returns (uint256) {\\n        return _followDataByFollowTokenId[followTokenId].followerProfileId;\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function isFollowing(uint256 followerProfileId) external view override returns (bool) {\\n        return _followTokenIdByFollowerProfileId[followerProfileId] != 0;\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function getFollowTokenId(uint256 followerProfileId) external view override returns (uint256) {\\n        return _followTokenIdByFollowerProfileId[followerProfileId];\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function getOriginalFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\\n        return _followDataByFollowTokenId[followTokenId].originalFollowTimestamp;\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function getFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\\n        return _followDataByFollowTokenId[followTokenId].followTimestamp;\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function getProfileIdAllowedToRecover(uint256 followTokenId) external view override returns (uint256) {\\n        return _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function getFollowData(uint256 followTokenId) external view override returns (Types.FollowData memory) {\\n        return _followDataByFollowTokenId[followTokenId];\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function getFollowApproved(uint256 followTokenId) external view override returns (uint256) {\\n        return _followApprovalByFollowTokenId[followTokenId];\\n    }\\n\\n    /// @inheritdoc IFollowNFT\\n    function getFollowerCount() external view override returns (uint256) {\\n        return _followerCount;\\n    }\\n\\n    function burn(uint256 followTokenId) public override whenNotPaused {\\n        _unfollowIfHasFollower(followTokenId, msg.sender);\\n        super.burn(followTokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(LensBaseERC721, ERC2981CollectionRoyalties) returns (bool) {\\n        return\\n            LensBaseERC721.supportsInterface(interfaceId) || ERC2981CollectionRoyalties.supportsInterface(interfaceId);\\n    }\\n\\n    function name() public view override returns (string memory) {\\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_NAME_SUFFIX));\\n    }\\n\\n    function symbol() public view override returns (string memory) {\\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_SYMBOL_SUFFIX));\\n    }\\n\\n    /**\\n     * @dev This returns the follow NFT URI fetched from the hub.\\n     */\\n    function tokenURI(uint256 followTokenId) public view override returns (string memory) {\\n        if (!_exists(followTokenId)) {\\n            revert Errors.TokenDoesNotExist();\\n        }\\n        return\\n            FollowTokenURILib.getTokenURI(\\n                followTokenId,\\n                _followedProfileId,\\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp\\n            );\\n    }\\n\\n    function _followMintingNewToken(uint256 followerProfileId) internal returns (uint256) {\\n        uint256 followTokenIdAssigned;\\n        unchecked {\\n            followTokenIdAssigned = ++_lastFollowTokenId;\\n            _followerCount++;\\n        }\\n        _baseFollow({\\n            followerProfileId: followerProfileId,\\n            followTokenId: followTokenIdAssigned,\\n            isOriginalFollow: true\\n        });\\n        return followTokenIdAssigned;\\n    }\\n\\n    function _followWithWrappedToken(\\n        uint256 followerProfileId,\\n        address transactionExecutor,\\n        uint256 followTokenId\\n    ) internal returns (uint256) {\\n        bool isFollowApproved = _followApprovalByFollowTokenId[followTokenId] == followerProfileId;\\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\\n        if (\\n            !isFollowApproved &&\\n            !_isApprovedOrOwner(followerProfileOwner, followTokenId) &&\\n            !_isApprovedOrOwner(transactionExecutor, followTokenId)\\n        ) {\\n            revert DoesNotHavePermissions();\\n        }\\n        // The transactionExecutor is allowed to write the follower in that wrapped token.\\n        if (isFollowApproved) {\\n            // The `_followApprovalByFollowTokenId` was used, and now it needs to be cleared.\\n            _approveFollow(0, followTokenId);\\n        }\\n        _replaceFollower({\\n            currentFollowerProfileId: _followDataByFollowTokenId[followTokenId].followerProfileId,\\n            newFollowerProfileId: followerProfileId,\\n            followTokenId: followTokenId,\\n            transactionExecutor: transactionExecutor\\n        });\\n        return followTokenId;\\n    }\\n\\n    function _followWithUnwrappedTokenFromBurnedProfile(\\n        uint256 followerProfileId,\\n        uint256 followTokenId,\\n        uint256 currentFollowerProfileId,\\n        address transactionExecutor\\n    ) internal returns (uint256) {\\n        if (IERC721Timestamped(HUB).exists(currentFollowerProfileId)) {\\n            revert DoesNotHavePermissions();\\n        }\\n        _replaceFollower({\\n            currentFollowerProfileId: currentFollowerProfileId,\\n            newFollowerProfileId: followerProfileId,\\n            followTokenId: followTokenId,\\n            transactionExecutor: transactionExecutor\\n        });\\n        return followTokenId;\\n    }\\n\\n    function _followByRecoveringToken(uint256 followerProfileId, uint256 followTokenId) internal returns (uint256) {\\n        if (_followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover != followerProfileId) {\\n            revert FollowTokenDoesNotExist();\\n        }\\n        unchecked {\\n            _followerCount++;\\n        }\\n        _baseFollow({followerProfileId: followerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\\n        return followTokenId;\\n    }\\n\\n    function _replaceFollower(\\n        uint256 currentFollowerProfileId,\\n        uint256 newFollowerProfileId,\\n        uint256 followTokenId,\\n        address transactionExecutor\\n    ) internal {\\n        if (currentFollowerProfileId != 0) {\\n            // As it has a follower, unfollow first, removing the current follower.\\n            delete _followTokenIdByFollowerProfileId[currentFollowerProfileId];\\n            ILensHub(HUB).emitUnfollowedEvent(currentFollowerProfileId, _followedProfileId, transactionExecutor);\\n        } else {\\n            unchecked {\\n                _followerCount++;\\n            }\\n        }\\n        // Perform the follow, setting a new follower.\\n        _baseFollow({followerProfileId: newFollowerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\\n    }\\n\\n    function _baseFollow(uint256 followerProfileId, uint256 followTokenId, bool isOriginalFollow) internal {\\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\\n        _followDataByFollowTokenId[followTokenId].followTimestamp = uint48(block.timestamp);\\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\\n        if (isOriginalFollow) {\\n            _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = uint48(block.timestamp);\\n        } else {\\n            // Migration code.\\n            // If the follow token was minted before the originalFollowTimestamp was introduced, it will be 0.\\n            // In that case, we need to fetch the mint timestamp from the token data.\\n            if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp == 0) {\\n                uint48 mintTimestamp = uint48(StorageLib.getTokenData(followTokenId).mintTimestamp);\\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = mintTimestamp;\\n            }\\n        }\\n    }\\n\\n    function _unfollowIfHasFollower(uint256 followTokenId, address transactionExecutor) internal {\\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\\n        if (followerProfileId != 0) {\\n            _unfollow(followerProfileId, followTokenId);\\n            ILensHub(HUB).emitUnfollowedEvent(followerProfileId, _followedProfileId, transactionExecutor);\\n        }\\n    }\\n\\n    function _unfollow(uint256 unfollower, uint256 followTokenId) internal {\\n        unchecked {\\n            // This is safe, as this line can only be reached if the unfollowed profile is being followed by the\\n            // unfollower profile, so _followerCount is guaranteed to be greater than zero.\\n            _followerCount--;\\n        }\\n        delete _followTokenIdByFollowerProfileId[unfollower];\\n        delete _followDataByFollowTokenId[followTokenId].followerProfileId;\\n        delete _followDataByFollowTokenId[followTokenId].followTimestamp;\\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\\n    }\\n\\n    function _approveFollow(uint256 approvedProfileId, uint256 followTokenId) internal {\\n        _followApprovalByFollowTokenId[followTokenId] = approvedProfileId;\\n        emit FollowApproval(approvedProfileId, followTokenId);\\n    }\\n\\n    /**\\n     * @dev Upon transfers, we clear follow approvals and emit the transfer event in the hub.\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 followTokenId) internal override whenNotPaused {\\n        if (from != address(0)) {\\n            // It is cleared on unwrappings and transfers, and it can not be set on unwrapped tokens.\\n            // As a consequence, there is no need to clear it on wrappings.\\n            _approveFollow(0, followTokenId);\\n        }\\n        super._beforeTokenTransfer(from, to, followTokenId);\\n    }\\n\\n    function _getReceiver(uint256 /* followTokenId */) internal view override returns (address) {\\n        if (!ILensHub(HUB).exists(_followedProfileId)) {\\n            return address(0);\\n        }\\n        return IERC721(HUB).ownerOf(_followedProfileId);\\n    }\\n\\n    function _beforeRoyaltiesSet(uint256 /* royaltiesInBasisPoints */) internal view override {\\n        if (IERC721(HUB).ownerOf(_followedProfileId) != msg.sender) {\\n            revert Errors.NotProfileOwner();\\n        }\\n    }\\n\\n    function _isFollowTokenWrapped(uint256 followTokenId) internal view returns (bool) {\\n        return _exists(followTokenId);\\n    }\\n\\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256) {\\n        uint256 slot;\\n        assembly {\\n            slot := _royaltiesInBasisPoints.slot\\n        }\\n        return slot;\\n    }\\n\\n    //////////////////\\n    /// Migrations ///\\n    //////////////////\\n\\n    // This function shouldn't fail under no circumstances, except if wrong parameters are passed.\\n    function tryMigrate(\\n        uint256 followerProfileId,\\n        address followerProfileOwner,\\n        uint256 followTokenId\\n    ) external onlyHub returns (uint48) {\\n        // Migrated FollowNFTs should have `originalFollowTimestamp` set\\n        if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp != 0) {\\n            return 0; // Already migrated\\n        }\\n\\n        if (_followTokenIdByFollowerProfileId[followerProfileId] != 0) {\\n            return 0; // Already following\\n        }\\n\\n        Types.TokenData memory tokenData = StorageLib.getTokenData(followTokenId);\\n\\n        address followTokenOwner = tokenData.owner;\\n\\n        if (followTokenOwner == address(0)) {\\n            return 0; // Doesn't exist\\n        }\\n\\n        // ProfileNFT and FollowNFT should be in the same account\\n        if (followerProfileOwner != followTokenOwner) {\\n            return 0; // Not holding both Profile & Follow NFTs together\\n        }\\n\\n        unchecked {\\n            ++_followerCount;\\n        }\\n\\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\\n\\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\\n        _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = uint48(tokenData.mintTimestamp);\\n        _followDataByFollowTokenId[followTokenId].followTimestamp = uint48(tokenData.mintTimestamp);\\n\\n        super._burn(followTokenId);\\n        return uint48(tokenData.mintTimestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/ERC2981CollectionRoyalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\nimport {IERC2981} from '@openzeppelin/contracts/interfaces/IERC2981.sol';\\n\\nabstract contract ERC2981CollectionRoyalties is IERC2981 {\\n    uint16 internal constant BASIS_POINTS = 10000;\\n    // bytes4(keccak256('royaltyInfo(uint256,uint256)')) == 0x2a55205a\\n    bytes4 internal constant INTERFACE_ID_ERC2981 = 0x2a55205a;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == INTERFACE_ID_ERC2981 || interfaceId == type(IERC165).interfaceId;\\n    }\\n\\n    /**\\n     * @notice Changes the royalty percentage for secondary sales.\\n     *\\n     * @param royaltiesInBasisPoints The royalty percentage (measured in basis points).\\n     */\\n    function setRoyalty(uint256 royaltiesInBasisPoints) external {\\n        _beforeRoyaltiesSet(royaltiesInBasisPoints);\\n        _setRoyalty(royaltiesInBasisPoints);\\n    }\\n\\n    /**\\n     * @notice Called with the sale price to determine how much royalty is owed and to whom.\\n     *\\n     * @param tokenId The ID of the token queried for royalty information.\\n     * @param salePrice The sale price of the token specified.\\n     * @return A tuple with the address that should receive the royalties and the royalty\\n     * payment amount for the given sale price.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address, uint256) {\\n        return (_getReceiver(tokenId), _getRoyaltyAmount(tokenId, salePrice));\\n    }\\n\\n    function _setRoyalty(uint256 royaltiesInBasisPoints) internal virtual {\\n        if (royaltiesInBasisPoints > BASIS_POINTS) {\\n            revert Errors.InvalidParameter();\\n        }\\n        _storeRoyaltiesInBasisPoints(royaltiesInBasisPoints);\\n    }\\n\\n    function _getRoyaltyAmount(uint256 /* tokenId */, uint256 salePrice) internal view virtual returns (uint256) {\\n        return (salePrice * _loadRoyaltiesInBasisPoints()) / BASIS_POINTS;\\n    }\\n\\n    function _storeRoyaltiesInBasisPoints(uint256 royaltiesInBasisPoints) internal virtual {\\n        uint256 royaltiesInBasisPointsSlot = _getRoyaltiesInBasisPointsSlot();\\n        assembly {\\n            sstore(royaltiesInBasisPointsSlot, royaltiesInBasisPoints)\\n        }\\n    }\\n\\n    function _loadRoyaltiesInBasisPoints() internal view virtual returns (uint256) {\\n        uint256 royaltiesInBasisPointsSlot = _getRoyaltiesInBasisPointsSlot();\\n        uint256 royaltyAmount;\\n        assembly {\\n            royaltyAmount := sload(royaltiesInBasisPointsSlot)\\n        }\\n        return royaltyAmount;\\n    }\\n\\n    function _beforeRoyaltiesSet(uint256 royaltiesInBasisPoints) internal view virtual;\\n\\n    function _getRoyaltiesInBasisPointsSlot() internal view virtual returns (uint256);\\n\\n    function _getReceiver(uint256 tokenId) internal view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/base/HubRestricted.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\n\\n/**\\n * @title HubRestricted\\n * @author Lens Protocol\\n *\\n * @notice This abstract contract adds a public `HUB` immutable field, as well as an `onlyHub` modifier,\\n * to inherit from contracts that have functions restricted to be only called by the Lens hub.\\n */\\nabstract contract HubRestricted {\\n    address public immutable HUB;\\n\\n    modifier onlyHub() {\\n        if (msg.sender != HUB) {\\n            revert Errors.NotHub();\\n        }\\n        _;\\n    }\\n\\n    constructor(address hub) {\\n        HUB = hub;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/LensBaseERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\nimport {MetaTxLib} from 'contracts/libraries/MetaTxLib.sol';\\nimport {ILensERC721} from 'contracts/interfaces/ILensERC721.sol';\\nimport {IERC721Timestamped} from 'contracts/interfaces/IERC721Timestamped.sol';\\nimport {IERC721Burnable} from 'contracts/interfaces/IERC721Burnable.sol';\\nimport {IERC721MetaTx} from 'contracts/interfaces/IERC721MetaTx.sol';\\nimport {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\\nimport {ERC165} from '@openzeppelin/contracts/utils/introspection/ERC165.sol';\\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n *\\n * Modifications:\\n * 1. Refactored _operatorApprovals setter into an internal function to allow meta-transactions.\\n * 2. Constructor replaced with an initializer.\\n * 3. Mint timestamp is now stored in a TokenData struct alongside the owner address.\\n */\\nabstract contract LensBaseERC721 is ERC165, ILensERC721 {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to token Data (owner address and mint timestamp uint96), this\\n    // replaces the original mapping(uint256 => address) private _owners;\\n    mapping(uint256 => Types.TokenData) private _tokenData;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Deprecated in V2 after removing ERC712Enumerable logic.\\n    mapping(address => mapping(uint256 => uint256)) private __DEPRECATED__ownedTokens;\\n    mapping(uint256 => uint256) private __DEPRECATED__ownedTokensIndex;\\n\\n    // Dirty hack on a deprecated slot:\\n    uint256 private _totalSupply; // uint256[] private __DEPRECATED__allTokens;\\n\\n    // Deprecated in V2 after removing ERC712Enumerable logic.\\n    mapping(uint256 => uint256) private __DEPRECATED__allTokensIndex;\\n\\n    mapping(address => uint256) private _nonces;\\n\\n    /**\\n     * @dev Initializes the ERC721 name and symbol.\\n     *\\n     * @param name_ The name to set.\\n     * @param symbol_ The symbol to set.\\n     */\\n    function _initialize(string calldata name_, string calldata symbol_) internal {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view virtual returns (string memory);\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Timestamped).interfaceId ||\\n            interfaceId == type(IERC721Burnable).interfaceId ||\\n            interfaceId == type(IERC721MetaTx).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function nonces(address signer) public view override returns (uint256) {\\n        return _nonces[signer];\\n    }\\n\\n    /// @inheritdoc IERC721MetaTx\\n    function getDomainSeparator() external view virtual override returns (bytes32) {\\n        return MetaTxLib.calculateDomainSeparator();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) {\\n            revert Errors.InvalidParameter();\\n        }\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _tokenData[tokenId].owner;\\n        if (owner == address(0)) {\\n            revert Errors.TokenDoesNotExist();\\n        }\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Timestamped-mintTimestampOf}\\n     */\\n    function mintTimestampOf(uint256 tokenId) public view virtual override returns (uint256) {\\n        uint96 mintTimestamp = _tokenData[tokenId].mintTimestamp;\\n        if (mintTimestamp == 0) {\\n            revert Errors.TokenDoesNotExist();\\n        }\\n        return mintTimestamp;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Timestamped-tokenDataOf}\\n     */\\n    function tokenDataOf(uint256 tokenId) public view virtual override returns (Types.TokenData memory) {\\n        if (!_exists(tokenId)) {\\n            revert Errors.TokenDoesNotExist();\\n        }\\n        return _tokenData[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Timestamped-exists}\\n     */\\n    function exists(uint256 tokenId) public view virtual override returns (bool) {\\n        return _exists(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function totalSupply() external view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ownerOf(tokenId);\\n        if (to == owner) {\\n            revert Errors.InvalidParameter();\\n        }\\n\\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\\n            revert Errors.NotOwnerOrApproved();\\n        }\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) {\\n            revert Errors.TokenDoesNotExist();\\n        }\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        if (operator == msg.sender) {\\n            revert Errors.InvalidParameter();\\n        }\\n\\n        _setOperatorApproval(msg.sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\\n            revert Errors.NotOwnerOrApproved();\\n        }\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\\n            revert Errors.NotOwnerOrApproved();\\n        }\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Burns `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public virtual override {\\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\\n            revert Errors.NotOwnerOrApproved();\\n        }\\n        _burn(tokenId);\\n    }\\n\\n    /**\\n     * @notice Returns the owner of the `tokenId` token.\\n     *\\n     * @dev It is prefixed as `unsafe` as it does not revert when the token does not exist.\\n     *\\n     * @param tokenId The token whose owner is being queried.\\n     *\\n     * @return address The address owning the given token, zero address if the token does not exist.\\n     */\\n    function _unsafeOwnerOf(uint256 tokenId) internal view returns (address) {\\n        return _tokenData[tokenId].owner;\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform a token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, _data)) {\\n            revert Errors.NonERC721ReceiverImplementer();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _tokenData[tokenId].owner != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ownerOf(tokenId);\\n        // We don't check owner for != address(0) cause it's done inside ownerOf()\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        if (to == address(0) || _exists(tokenId)) {\\n            revert Errors.InvalidParameter();\\n        }\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        unchecked {\\n            ++_balances[to];\\n            ++_totalSupply;\\n        }\\n        _tokenData[tokenId].owner = to;\\n        _tokenData[tokenId].mintTimestamp = uint96(block.timestamp);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        unchecked {\\n            --_balances[owner];\\n            --_totalSupply;\\n        }\\n        delete _tokenData[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        if (ownerOf(tokenId) != from) {\\n            revert Errors.InvalidOwner();\\n        }\\n        if (to == address(0)) {\\n            revert Errors.InvalidParameter();\\n        }\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        unchecked {\\n            --_balances[from];\\n            ++_balances[to];\\n        }\\n        _tokenData[tokenId].owner = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Refactored from the original OZ ERC721 implementation: approve or revoke approval from\\n     * `operator` to operate on all tokens owned by `owner`.\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setOperatorApproval(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert Errors.NonERC721ReceiverImplementer();\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title IERC721Burnable\\n * @author Lens Protocol\\n *\\n * @notice Extension of ERC-721 including a function that allows the token to be burned.\\n */\\ninterface IERC721Burnable {\\n    /**\\n     * @notice Burns an NFT, removing it from circulation and essentially destroying it.\\n     * @custom:permission Owner of the NFT.\\n     *\\n     * @param tokenId The token ID of the token to burn.\\n     */\\n    function burn(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721MetaTx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title IERC721MetaTx\\n * @author Lens Protocol\\n *\\n * @notice Extension of ERC-721 including meta-tx signatures related functions.\\n */\\ninterface IERC721MetaTx {\\n    /**\\n     * @notice Returns the current signature nonce of the given signer.\\n     *\\n     * @param signer The address for which to query the nonce.\\n     *\\n     * @return uint256 The current nonce of the given signer.\\n     */\\n    function nonces(address signer) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the EIP-712 domain separator for this contract.\\n     *\\n     * @return bytes32 The domain separator.\\n     */\\n    function getDomainSeparator() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Timestamped.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\n\\n/**\\n * @title IERC721Timestamped\\n * @author Lens Protocol\\n *\\n * @notice Extension of ERC-721 including a struct for token data, which contains the owner and the mint timestamp, as\\n * well as their associated getters.\\n */\\ninterface IERC721Timestamped {\\n    /**\\n     * @notice Returns the mint timestamp associated with a given NFT.\\n     *\\n     * @param tokenId The token ID of the NFT to query the mint timestamp for.\\n     *\\n     * @return uint256 Mint timestamp, this is stored as a uint96 but returned as a uint256 to reduce unnecessary\\n     * padding.\\n     */\\n    function mintTimestampOf(uint256 tokenId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the token data associated with a given NFT. This allows fetching the token owner and\\n     * mint timestamp in a single call.\\n     *\\n     * @param tokenId The token ID of the NFT to query the token data for.\\n     *\\n     * @return TokenData A struct containing both the owner address and the mint timestamp.\\n     */\\n    function tokenDataOf(uint256 tokenId) external view returns (Types.TokenData memory);\\n\\n    /**\\n     * @notice Returns whether a token with the given token ID exists.\\n     *\\n     * @param tokenId The token ID of the NFT to check existence for.\\n     *\\n     * @return bool True if the token exists.\\n     */\\n    function exists(uint256 tokenId) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the amount of tokens in circulation.\\n     *\\n     * @return uint256 The current total supply of tokens.\\n     */\\n    function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFollowModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title IFollowModule\\n * @author Lens Protocol\\n *\\n * @notice This is the standard interface for all Lens-compatible Follow Modules.\\n * These are responsible for processing the follow actions and can be used to implement any kind of follow logic.\\n * For example:\\n *  - Token-gated follows (e.g. a user must hold a certain amount of a token to follow a profile).\\n *  - Paid follows (e.g. a user must pay a certain amount of a token to follow a profile).\\n *  - Rewarding users for following a profile.\\n *  - Etc.\\n */\\ninterface IFollowModule {\\n    /**\\n     * @notice Initializes a follow module for a given Lens profile.\\n     * @custom:permissions LensHub.\\n     *\\n     * @param profileId The Profile ID to initialize this follow module for.\\n     * @param transactionExecutor The address of the transaction executor (e.g. for any funds to transferFrom).\\n     * @param data Arbitrary data passed from the user to be decoded by the Follow Module during initialization.\\n     *\\n     * @return bytes The encoded data to be emitted from the hub.\\n     */\\n    function initializeFollowModule(\\n        uint256 profileId,\\n        address transactionExecutor,\\n        bytes calldata data\\n    ) external returns (bytes memory);\\n\\n    /**\\n     * @notice Processes a given follow.\\n     * @custom:permissions LensHub.\\n     *\\n     * @param followerProfileId The Profile ID of the follower's profile.\\n     * @param followTokenId The Follow Token ID that is being used to follow. Zero if we are processing a new fresh\\n     * follow, in this case, the follow ID assigned can be queried from the Follow NFT collection if needed.\\n     * @param transactionExecutor The address of the transaction executor (e.g. for any funds to transferFrom).\\n     * @param targetProfileId The token ID of the profile being followed.\\n     * @param data Arbitrary data passed by the follower.\\n     *\\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\\n     * indexers or UIs.\\n     */\\n    function processFollow(\\n        uint256 followerProfileId,\\n        uint256 followTokenId,\\n        address transactionExecutor,\\n        uint256 targetProfileId,\\n        bytes calldata data\\n    ) external returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFollowNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\n\\n/**\\n * @title IFollowNFT\\n * @author Lens Protocol\\n *\\n * @notice This is the interface for the FollowNFT contract, which is cloned upon the first follow for any profile.\\n * By default the Follow tokens are tied to the follower profile, which means that they will be automatically\\n * transferred with it.\\n * This is achieved by them not being ERC-721 initially. However, the Follow NFT collections support converting them to\\n * ERC-721 tokens (i.e. wrapping) natively, enabling composability with existing ERC-721-based protocols.\\n */\\ninterface IFollowNFT {\\n    error AlreadyFollowing();\\n    error NotFollowing();\\n    error FollowTokenDoesNotExist();\\n    error AlreadyWrapped();\\n    error OnlyWrappedFollowTokens();\\n    error DoesNotHavePermissions();\\n\\n    /**\\n     * @notice Initializes the follow NFT.\\n     * @custom:permissions LensHub.\\n     *\\n     * @dev Sets the targeted profile, and the token royalties.\\n     *\\n     * @param profileId The ID of the profile targeted by the follow tokens minted by this collection.\\n     */\\n    function initialize(uint256 profileId) external;\\n\\n    /**\\n     * @notice Makes the passed profile follow the profile targeted in this contract.\\n     * @custom:permissions LensHub.\\n     *\\n     * @param followerProfileId The ID of the profile acting as the follower.\\n     * @param transactionExecutor The address of the transaction executor (e.g. for any funds to transferFrom).\\n     * @param followTokenId The ID of the follow token to be used for this follow operation. Zero if a new follow token\\n     * should be minted.\\n     *\\n     * @return uint256 The ID of the token used to follow.\\n     */\\n    function follow(\\n        uint256 followerProfileId,\\n        address transactionExecutor,\\n        uint256 followTokenId\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Makes the passed profile unfollow the profile targeted in this contract.\\n     * @custom:permissions LensHub.\\n     *\\n     * @param unfollowerProfileId The ID of the profile that is performing the unfollow operation.\\n     */\\n    function unfollow(uint256 unfollowerProfileId) external;\\n\\n    /**\\n     * @notice Removes the follower from the given follow NFT.\\n     * @custom:permissions Follow token owner or approved-for-all.\\n\\n     * @dev Only on wrapped token.\\n     *\\n     * @param followTokenId The ID of the follow token to remove the follower from.\\n     */\\n    function removeFollower(uint256 followTokenId) external;\\n\\n    /**\\n     * @notice Approves the given profile to follow with the given wrapped token.\\n     * @custom:permissions Follow token owner or approved-for-all.\\n     *\\n     * @dev Only on wrapped tokens.\\n     * It approves setting a follower on the given wrapped follow token, which lets the follow token owner to allow\\n     * a profile to follow with his token without losing its ownership. This approval is cleared on transfers, as well\\n     * as when unwrapping.\\n     *\\n     * @param approvedProfileId The ID of the profile approved to follow with the given token.\\n     * @param followTokenId The ID of the follow token to be approved for the given profile.\\n     */\\n    function approveFollow(uint256 approvedProfileId, uint256 followTokenId) external;\\n\\n    /**\\n     * @notice Unties the follow token from the follower's profile one, and wraps it into the ERC-721 untied follow\\n     * tokens collection. Untied follow tokens will NOT be automatically transferred with their follower profile.\\n     * @custom:permissions Follower profile owner.\\n     *\\n     * @dev Only on unwrapped follow tokens.\\n     *\\n     * @param followTokenId The ID of the follow token to untie and wrap.\\n     */\\n    function wrap(uint256 followTokenId) external;\\n\\n    /**\\n     * @notice Unties the follow token from the follower's profile one, and wraps it into the ERC-721 untied follow\\n     * tokens collection. Untied follow tokens will NOT be automatically transferred with their follower profile.\\n     * @custom:permissions Follower profile owner.\\n     *\\n     * @dev Only on unwrapped follow tokens.\\n     *\\n     * @param followTokenId The ID of the follow token to untie and wrap.\\n     * @param wrappedTokenReceiver The address where the follow token is minted to when being wrapped as ERC-721.\\n     */\\n    function wrap(uint256 followTokenId, address wrappedTokenReceiver) external;\\n\\n    /**\\n     * @notice Unwraps the follow token from the ERC-721 untied follow tokens collection, and ties it to the follower's\\n     * profile token. Tokens that are tied to the follower profile will be automatically transferred with it.\\n     *\\n     * @param followTokenId The ID of the follow token to unwrap and tie to its follower.\\n     */\\n    function unwrap(uint256 followTokenId) external;\\n\\n    /**\\n     * @notice Processes logic when the given profile is being blocked. If it was following the targeted profile,\\n     * this will make it unfollow.\\n     * @custom:permissions LensHub.\\n     *\\n     * @param followerProfileId The ID of the follow token to unwrap and tie.\\n     *\\n     * @return bool True if the given profile was following and now has unfollowed, false otherwise.\\n     */\\n    function processBlock(uint256 followerProfileId) external returns (bool);\\n\\n    ///////////////////////////\\n    ///       GETTERS       ///\\n    ///////////////////////////\\n\\n    /**\\n     * @notice Gets the ID of the profile following with the given follow token.\\n     *\\n     * @param followTokenId The ID of the follow token whose follower should be queried.\\n     *\\n     * @return uint256 The ID of the profile following with the given token, zero if it is not being used to follow.\\n     */\\n    function getFollowerProfileId(uint256 followTokenId) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the original follow timestamp of the given follow token.\\n     *\\n     * @param followTokenId The ID of the follow token whose original follow timestamp should be queried.\\n     *\\n     * @return uint256 The timestamp of the first follow performed with the token, zero if was not used to follow yet.\\n     */\\n    function getOriginalFollowTimestamp(uint256 followTokenId) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the current follow timestamp of the given follow token.\\n     *\\n     * @param followTokenId The ID of the follow token whose follow timestamp should be queried.\\n     *\\n     * @return uint256 The timestamp of the current follow of the token, zero if it is not being used to follow.\\n     */\\n    function getFollowTimestamp(uint256 followTokenId) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the ID of the profile allowed to recover the given follow token.\\n     *\\n     * @param followTokenId The ID of the follow token whose allowed profile to recover should be queried.\\n     *\\n     * @return uint256 The ID of the profile allowed to recover the given follow token, zero if none of them is allowed.\\n     */\\n    function getProfileIdAllowedToRecover(uint256 followTokenId) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the follow data of the given follow token.\\n     *\\n     * @param followTokenId The ID of the follow token whose follow data should be queried.\\n     *\\n     * @return FollowData The token data associated with the given follow token.\\n     */\\n    function getFollowData(uint256 followTokenId) external view returns (Types.FollowData memory);\\n\\n    /**\\n     * @notice Tells if the given profile is following the profile targeted in this contract.\\n     *\\n     * @param followerProfileId The ID of the profile whose following state should be queried.\\n     *\\n     * @return uint256 The ID of the profile set as a follower in the given token, zero if it is not being used to follow.\\n     */\\n    function isFollowing(uint256 followerProfileId) external view returns (bool);\\n\\n    /**\\n     * @notice Gets the ID of the token being used to follow by the given follower.\\n     *\\n     * @param followerProfileId The ID of the profile whose follow ID should be queried.\\n     *\\n     * @return uint256 The ID of the token being used to follow by the given follower, zero if he is not following.\\n     */\\n    function getFollowTokenId(uint256 followerProfileId) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the ID of the profile approved to follow with the given token.\\n     *\\n     * @param followTokenId The ID of the token whose approved to follow should be queried.\\n     *\\n     * @return uint256 The ID of the profile approved to follow with the given token, zero if none of them is approved.\\n     */\\n    function getFollowApproved(uint256 followTokenId) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the count of the followers of the profile targeted in this contract.\\n     * @notice This number might be out of sync if one of the followers burns their profile.\\n     *\\n     * @return uint256 The count of the followers of the profile targeted in this contract.\\n     */\\n    function getFollowerCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILegacyReferenceModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title IReferenceModule\\n * @author Lens Protocol\\n * @custom:pending-deprecation\\n *\\n * @notice This is the deprecated interface for previously Lens-compatible ReferenceModules.\\n */\\ninterface ILegacyReferenceModule {\\n    /**\\n     * @notice Initializes data for a given publication being published. This can only be called by the hub.\\n     *\\n     * @param profileId The token ID of the profile publishing the publication.\\n     * @param pubId The associated publication's LensHub publication ID.\\n     * @param data Arbitrary data passed from the user to be decoded.\\n     *\\n     * @return bytes An ABI-encoded data encapsulating the execution's state changes. This will be emitted by the\\n     * hub alongside the collect module's address and should be consumed by front ends.\\n     */\\n    function initializeReferenceModule(\\n        uint256 profileId,\\n        uint256 pubId,\\n        bytes calldata data\\n    ) external returns (bytes memory);\\n\\n    /**\\n     * @notice Processes a comment action referencing a given publication. This can only be called by the hub.\\n     *\\n     * @param profileId The token ID of the profile associated with the publication being published.\\n     * @param pointedProfileId The profile ID of the profile associated with the publication being referenced.\\n     * @param pointedPubId The publication ID of the publication being referenced.\\n     * @param data Arbitrary data __passed from the commenter!__ to be decoded.\\n     */\\n    function processComment(\\n        uint256 profileId,\\n        uint256 pointedProfileId,\\n        uint256 pointedPubId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @notice Processes a mirror action referencing a given publication. This can only be called by the hub.\\n     *\\n     * @param profileId The token ID of the profile associated with the publication being published.\\n     * @param pointedProfileId The profile ID of the profile associated with the publication being referenced.\\n     * @param pointedPubId The publication ID of the publication being referenced.\\n     * @param data Arbitrary data __passed from the mirrorer!__ to be decoded.\\n     */\\n    function processMirror(\\n        uint256 profileId,\\n        uint256 pointedProfileId,\\n        uint256 pointedPubId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILensERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport {IERC721Timestamped} from 'contracts/interfaces/IERC721Timestamped.sol';\\nimport {IERC721Burnable} from 'contracts/interfaces/IERC721Burnable.sol';\\nimport {IERC721MetaTx} from 'contracts/interfaces/IERC721MetaTx.sol';\\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\\n\\ninterface ILensERC721 is IERC721, IERC721Timestamped, IERC721Burnable, IERC721MetaTx, IERC721Metadata {}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILensGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\n\\n/**\\n * @title ILensGovernable\\n * @author Lens Protocol\\n *\\n * @notice This is the interface for the Lens Protocol main governance functions.\\n */\\ninterface ILensGovernable {\\n    /**\\n     * @notice Sets the privileged governance role.\\n     * @custom:permissions Governance.\\n     *\\n     * @param newGovernance The new governance address to set.\\n     */\\n    function setGovernance(address newGovernance) external;\\n\\n    /**\\n     * @notice Sets the emergency admin, which is a permissioned role able to set the protocol state.\\n     * @custom:permissions Governance.\\n     *\\n     * @param newEmergencyAdmin The new emergency admin address to set.\\n     */\\n    function setEmergencyAdmin(address newEmergencyAdmin) external;\\n\\n    /**\\n     * @notice Sets the protocol state to either a global pause, a publishing pause or an unpaused state.\\n     * @custom:permissions Governance or Emergency Admin. Emergency Admin can only restrict more.\\n     *\\n     * @param newState The state to set. It can be one of the following:\\n     *  - Unpaused: The protocol is fully operational.\\n     *  - PublishingPaused: The protocol is paused for publishing, but it is still operational for others operations.\\n     *  - Paused: The protocol is paused for all operations.\\n     */\\n    function setState(Types.ProtocolState newState) external;\\n\\n    /**\\n     * @notice Adds or removes a profile creator from the whitelist.\\n     * @custom:permissions Governance.\\n     *\\n     * @param profileCreator The profile creator address to add or remove from the whitelist.\\n     * @param whitelist Whether or not the profile creator should be whitelisted.\\n     */\\n    function whitelistProfileCreator(address profileCreator, bool whitelist) external;\\n\\n    /**\\n     * @notice Sets the treasury address.\\n     * @custom:permissions Governance\\n     *\\n     * @param newTreasury The new treasury address to set.\\n     */\\n    function setTreasury(address newTreasury) external;\\n\\n    /**\\n     * @notice Sets the treasury fee.\\n     * @custom:permissions Governance\\n     *\\n     * @param newTreasuryFee The new treasury fee to set.\\n     */\\n    function setTreasuryFee(uint16 newTreasuryFee) external;\\n\\n    /**\\n     * @notice Returns the currently configured governance address.\\n     *\\n     * @return address The address of the currently configured governance.\\n     */\\n    function getGovernance() external view returns (address);\\n\\n    /**\\n     * @notice Gets the state currently set in the protocol. It could be a global pause, a publishing pause or an\\n     * unpaused state.\\n     * @custom:permissions Anyone.\\n     *\\n     * @return Types.ProtocolState The state currently set in the protocol.\\n     */\\n    function getState() external view returns (Types.ProtocolState);\\n\\n    /**\\n     * @notice Returns whether or not a profile creator is whitelisted.\\n     *\\n     * @param profileCreator The address of the profile creator to check.\\n     *\\n     * @return bool True if the profile creator is whitelisted, false otherwise.\\n     */\\n    function isProfileCreatorWhitelisted(address profileCreator) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the treasury address.\\n     *\\n     * @return address The treasury address.\\n     */\\n    function getTreasury() external view returns (address);\\n\\n    /**\\n     * @notice Returns the treasury fee.\\n     *\\n     * @return uint16 The treasury fee.\\n     */\\n    function getTreasuryFee() external view returns (uint16);\\n\\n    /**\\n     * @notice Returns the treasury address and treasury fee in a single call.\\n     *\\n     * @return tuple First, the treasury address, second, the treasury fee.\\n     */\\n    function getTreasuryData() external view returns (address, uint16);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILensHandles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\n\\n/**\\n * @title ILensHandles\\n * @author Lens Protocol\\n *\\n * @notice This is the interface for the LensHandles contract that is responsible for minting and burning handle NFTs.\\n * A handle is composed of a local name and a namespace, separated by a dot.\\n * Example: `satoshi.lens` is a handle composed of the local name `satoshi` and the namespace `lens`.\\n */\\ninterface ILensHandles is IERC721 {\\n    /**\\n     * @notice Mints a handle NFT in the given namespace.\\n     * @custom:permissions Only LensHandles contract's owner or LensHub.\\n     *\\n     * @param to The address to mint the handle to.\\n     * @param localName The local name of the handle (the part before \\\".lens\\\").\\n     *\\n     * @return uint256 The ID of the handle NFT minted.\\n     */\\n    function mintHandle(address to, string calldata localName) external returns (uint256);\\n\\n    /**\\n     * @notice Burns a handle NFT.\\n     * @custom:permissions Owner of Handle NFT.\\n     *\\n     * @param tokenId The ID of the handle NFT to burn.\\n     */\\n    function burn(uint256 tokenId) external;\\n\\n    /**\\n     * @notice Gets the namespace of the contract. It's 'lens' for the LensHandles contract.\\n     *\\n     * @return string The namespace of the contract.\\n     */\\n    function getNamespace() external pure returns (string memory);\\n\\n    /**\\n     * @notice Gets the hash of the namespace of the contract. It's keccak256('lens') for the LensHandles contract.\\n     *\\n     * @return bytes32 The hash of the namespace of the contract.\\n     */\\n    function getNamespaceHash() external pure returns (bytes32);\\n\\n    /**\\n     * @notice Returns whether `tokenId` exists.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     *\\n     * @return bool Whether the token exists.\\n     */\\n    function exists(uint256 tokenId) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the amount of tokens in circulation.\\n     *\\n     * @return uint256 The current total supply of tokens.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice DANGER: Triggers disabling the profile protection mechanism for the msg.sender, which will allow\\n     * transfers or approvals over profiles held by it.\\n     * Disabling the mechanism will have a timelock before it becomes effective, allowing the owner to re-enable\\n     * the protection back in case of being under attack.\\n     * The protection layer only applies to EOA wallets.\\n     */\\n    function DANGER__disableTokenGuardian() external;\\n\\n    /**\\n     * @notice Enables back the profile protection mechanism for the msg.sender, preventing profile transfers or\\n     * approvals (except when revoking them).\\n     * The protection layer only applies to EOA wallets.\\n     */\\n    function enableTokenGuardian() external;\\n\\n    /**\\n     * @notice Returns the timestamp at which the Token Guardian will become effectively disabled.\\n     *\\n     * @param wallet The address to check the timestamp for.\\n     *\\n     * @return uint256 The timestamp at which the Token Guardian will become effectively disabled.\\n     * Max 256-bit unsigned integer value if enabled.\\n     */\\n    function getTokenGuardianDisablingTimestamp(address wallet) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILensHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {ILensProtocol} from 'contracts/interfaces/ILensProtocol.sol';\\nimport {ILensGovernable} from 'contracts/interfaces/ILensGovernable.sol';\\nimport {ILensHubEventHooks} from 'contracts/interfaces/ILensHubEventHooks.sol';\\nimport {ILensImplGetters} from 'contracts/interfaces/ILensImplGetters.sol';\\nimport {ILensProfiles} from 'contracts/interfaces/ILensProfiles.sol';\\nimport {ILensVersion} from 'contracts/interfaces/ILensVersion.sol';\\n\\ninterface ILensHub is\\n    ILensProfiles,\\n    ILensProtocol,\\n    ILensGovernable,\\n    ILensHubEventHooks,\\n    ILensImplGetters,\\n    ILensVersion\\n{}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILensHubEventHooks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title ILensHubEventHooks\\n * @author Lens Protocol\\n *\\n * @notice This is the interface for the LensHub contract's event hooks. As we want most of the core events to be\\n * emitted by the LensHub contract, event hooks are needed for core events generated by pheripheral contracts.\\n */\\ninterface ILensHubEventHooks {\\n    /**\\n     * @dev Helper function to emit an `Unfollowed` event from the hub, to be consumed by indexers to track unfollows.\\n     * @custom:permissions FollowNFT of the Profile unfollowed.\\n     *\\n     * @param unfollowerProfileId The ID of the profile that executed the unfollow.\\n     * @param idOfProfileUnfollowed The ID of the profile that was unfollowed.\\n     * @param transactionExecutor The address of the account executing the unfollow operation.\\n     */\\n    function emitUnfollowedEvent(\\n        uint256 unfollowerProfileId,\\n        uint256 idOfProfileUnfollowed,\\n        address transactionExecutor\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILensImplGetters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title ILensImplGetters\\n * @author Lens Protocol\\n *\\n * @notice This is the interface for the LensHub contract's implementation getters. These implementations will be used\\n * for deploying each respective contract for each profile.\\n */\\ninterface ILensImplGetters {\\n    /**\\n     * @notice Returns the Follow NFT implementation address that is used for all deployed Follow NFTs.\\n     *\\n     * @return address The Follow NFT implementation address.\\n     */\\n    function getFollowNFTImpl() external view returns (address);\\n\\n    /**\\n     * @notice Returns the Collect NFT implementation address that is used for each new deployed Collect NFT.\\n     * @custom:pending-deprecation\\n     *\\n     * @return address The Collect NFT implementation address.\\n     */\\n    function getLegacyCollectNFTImpl() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the registry that stores all modules that are used by the Lens Protocol.\\n     *\\n     * @return address The address of the Module Registry contract.\\n     */\\n    function getModuleRegistry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILensProfiles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {ILensERC721} from 'contracts/interfaces/ILensERC721.sol';\\n\\ninterface ILensProfiles is ILensERC721 {\\n    /**\\n     * @notice DANGER: Triggers disabling the profile protection mechanism for the msg.sender, which will allow\\n     * transfers or approvals over profiles held by it.\\n     * Disabling the mechanism will have a timelock before it becomes effective, allowing the owner to re-enable\\n     * the protection back in case of being under attack.\\n     * The protection layer only applies to EOA wallets.\\n     */\\n    function DANGER__disableTokenGuardian() external;\\n\\n    /**\\n     * @notice Enables back the profile protection mechanism for the msg.sender, preventing profile transfers or\\n     * approvals (except when revoking them).\\n     * The protection layer only applies to EOA wallets.\\n     */\\n    function enableTokenGuardian() external;\\n\\n    /**\\n     * @notice Returns the timestamp at which the Token Guardian will become effectively disabled.\\n     *\\n     * @param wallet The address to check the timestamp for.\\n     *\\n     * @return uint256 The timestamp at which the Token Guardian will become effectively disabled. Zero if enabled.\\n     */\\n    function getTokenGuardianDisablingTimestamp(address wallet) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILensProtocol.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\n\\n/**\\n * @title ILensProtocol\\n * @author Lens Protocol\\n *\\n * @notice This is the interface for Lens Protocol's core functions. It contains all the entry points for performing\\n * social operations.\\n */\\ninterface ILensProtocol {\\n    /**\\n     * @notice Creates a profile with the specified parameters, minting a Profile NFT to the given recipient.\\n     * @custom:permissions Any whitelisted profile creator.\\n     *\\n     * @param createProfileParams A CreateProfileParams struct containing the needed params.\\n     */\\n    function createProfile(Types.CreateProfileParams calldata createProfileParams) external returns (uint256);\\n\\n    /**\\n     * @notice Sets the metadata URI for the given profile.\\n     * @custom:permissions Profile Owner or Delegated Executor.\\n     *\\n     * @param profileId The token ID of the profile to set the metadata URI for.\\n     * @param metadataURI The metadata URI to set for the given profile.\\n     */\\n    function setProfileMetadataURI(uint256 profileId, string calldata metadataURI) external;\\n\\n    /**\\n     * @custom:meta-tx setProfileMetadataURI.\\n     */\\n    function setProfileMetadataURIWithSig(\\n        uint256 profileId,\\n        string calldata metadataURI,\\n        Types.EIP712Signature calldata signature\\n    ) external;\\n\\n    /**\\n     * @notice Sets the follow module for the given profile.\\n     * @custom:permissions Profile Owner or Delegated Executor.\\n     *\\n     * @param profileId The token ID of the profile to set the follow module for.\\n     * @param followModule The follow module to set for the given profile, must be whitelisted.\\n     * @param followModuleInitData The data to be passed to the follow module for initialization.\\n     */\\n    function setFollowModule(uint256 profileId, address followModule, bytes calldata followModuleInitData) external;\\n\\n    /**\\n     * @custom:meta-tx setFollowModule.\\n     */\\n    function setFollowModuleWithSig(\\n        uint256 profileId,\\n        address followModule,\\n        bytes calldata followModuleInitData,\\n        Types.EIP712Signature calldata signature\\n    ) external;\\n\\n    /**\\n     * @notice Changes the delegated executors configuration for the given profile. It allows setting the approvals for\\n     * delegated executors in the specified configuration, as well as switching to it.\\n     * @custom:permissions Profile Owner.\\n     *\\n     * @param delegatorProfileId The ID of the profile to which the delegated executor is being changed for.\\n     * @param delegatedExecutors The array of delegated executors to set the approval for.\\n     * @param approvals The array of booleans indicating the corresponding executor's new approval status.\\n     * @param configNumber The number of the configuration where the executor approval state is being set.\\n     * @param switchToGivenConfig A boolean indicating if the configuration must be switched to the one with the given\\n     * number.\\n     */\\n    function changeDelegatedExecutorsConfig(\\n        uint256 delegatorProfileId,\\n        address[] calldata delegatedExecutors,\\n        bool[] calldata approvals,\\n        uint64 configNumber,\\n        bool switchToGivenConfig\\n    ) external;\\n\\n    /**\\n     * @notice Changes the delegated executors configuration for the given profile under the current configuration.\\n     * @custom:permissions Profile Owner.\\n     *\\n     * @param delegatorProfileId The ID of the profile to which the delegated executor is being changed for.\\n     * @param delegatedExecutors The array of delegated executors to set the approval for.\\n     * @param approvals The array of booleans indicating the corresponding executor's new approval status.\\n     */\\n    function changeDelegatedExecutorsConfig(\\n        uint256 delegatorProfileId,\\n        address[] calldata delegatedExecutors,\\n        bool[] calldata approvals\\n    ) external;\\n\\n    /**\\n     * @custom:meta-tx changeDelegatedExecutorsConfig.\\n     */\\n    function changeDelegatedExecutorsConfigWithSig(\\n        uint256 delegatorProfileId,\\n        address[] calldata delegatedExecutors,\\n        bool[] calldata approvals,\\n        uint64 configNumber,\\n        bool switchToGivenConfig,\\n        Types.EIP712Signature calldata signature\\n    ) external;\\n\\n    /**\\n     * @notice Publishes a post.\\n     * Post is the most basic publication type, and can be used to publish any kind of content.\\n     * Posts can have these types of modules initialized:\\n     *  - Action modules: any number of publication actions (e.g. collect, tip, etc.)\\n     *  - Reference module: a module handling the rules when referencing this post (e.g. token-gated comments)\\n     * @custom:permissions Profile Owner or Delegated Executor.\\n     *\\n     * @param postParams A PostParams struct containing the needed parameters.\\n     *\\n     * @return uint256 An integer representing the post's publication ID.\\n     */\\n    function post(Types.PostParams calldata postParams) external returns (uint256);\\n\\n    /**\\n     * @custom:meta-tx post.\\n     */\\n    function postWithSig(\\n        Types.PostParams calldata postParams,\\n        Types.EIP712Signature calldata signature\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Publishes a comment on the given publication.\\n     * Comment is a type of reference publication that points to another publication.\\n     * Comments can have these types of modules initialized:\\n     *  - Action modules: any number of publication actions (e.g. collect, tip, etc.)\\n     *  - Reference module: a module handling the rules when referencing this comment (e.g. token-gated mirrors)\\n     * Comments can have referrers (e.g. publications or profiles that helped to discover the pointed publication).\\n     * @custom:permissions Profile Owner or Delegated Executor.\\n     *\\n     * @param commentParams A CommentParams struct containing the needed parameters.\\n     *\\n     * @return uint256 An integer representing the comment's publication ID.\\n     */\\n    function comment(Types.CommentParams calldata commentParams) external returns (uint256);\\n\\n    /**\\n     * @custom:meta-tx comment.\\n     */\\n    function commentWithSig(\\n        Types.CommentParams calldata commentParams,\\n        Types.EIP712Signature calldata signature\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Publishes a mirror of the given publication.\\n     * Mirror is a type of reference publication that points to another publication but doesn't have content.\\n     * Mirrors don't have any modules initialized.\\n     * Mirrors can have referrers (e.g. publications or profiles that allowed to discover the pointed publication).\\n     * You cannot mirror a mirror, comment on a mirror, or quote a mirror.\\n     * @custom:permissions Profile Owner or Delegated Executor.\\n     *\\n     * @param mirrorParams A MirrorParams struct containing the necessary parameters.\\n     *\\n     * @return uint256 An integer representing the mirror's publication ID.\\n     */\\n    function mirror(Types.MirrorParams calldata mirrorParams) external returns (uint256);\\n\\n    /**\\n     * @custom:meta-tx mirror.\\n     */\\n    function mirrorWithSig(\\n        Types.MirrorParams calldata mirrorParams,\\n        Types.EIP712Signature calldata signature\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Publishes a quote of the given publication.\\n     * Quote is a type of reference publication similar to mirror, but it has content and modules.\\n     * Quotes can have these types of modules initialized:\\n     *  - Action modules: any number of publication actions (e.g. collect, tip, etc.)\\n     *  - Reference module: a module handling the rules when referencing this quote (e.g. token-gated comments on quote)\\n     * Quotes can have referrers (e.g. publications or profiles that allowed to discover the pointed publication).\\n     * Unlike mirrors, you can mirror a quote, comment on a quote, or quote a quote.\\n     * @custom:permissions Profile Owner or Delegated Executor.\\n     *\\n     * @param quoteParams A QuoteParams struct containing the needed parameters.\\n     *\\n     * @return uint256 An integer representing the quote's publication ID.\\n     */\\n    function quote(Types.QuoteParams calldata quoteParams) external returns (uint256);\\n\\n    /**\\n     * @custom:meta-tx quote.\\n     */\\n    function quoteWithSig(\\n        Types.QuoteParams calldata quoteParams,\\n        Types.EIP712Signature calldata signature\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Follows given profiles, executing each profile's follow module logic (if any).\\n     * @custom:permissions Profile Owner or Delegated Executor.\\n     *\\n     * @dev Both the `idsOfProfilesToFollow`, `followTokenIds`, and `datas` arrays must be of the same length,\\n     * regardless if the profiles do not have a follow module set.\\n     *\\n     * @param followerProfileId The ID of the profile the follows are being executed for.\\n     * @param idsOfProfilesToFollow The array of IDs of profiles to follow.\\n     * @param followTokenIds The array of follow token IDs to use for each follow (0 if you don't own a follow token).\\n     * @param datas The arbitrary data array to pass to the follow module for each profile if needed.\\n     *\\n     * @return uint256[] An array of follow token IDs representing the follow tokens created for each follow.\\n     */\\n    function follow(\\n        uint256 followerProfileId,\\n        uint256[] calldata idsOfProfilesToFollow,\\n        uint256[] calldata followTokenIds,\\n        bytes[] calldata datas\\n    ) external returns (uint256[] memory);\\n\\n    /**\\n     * @custom:meta-tx follow.\\n     */\\n    function followWithSig(\\n        uint256 followerProfileId,\\n        uint256[] calldata idsOfProfilesToFollow,\\n        uint256[] calldata followTokenIds,\\n        bytes[] calldata datas,\\n        Types.EIP712Signature calldata signature\\n    ) external returns (uint256[] memory);\\n\\n    /**\\n     * @notice Unfollows given profiles.\\n     * @custom:permissions Profile Owner or Delegated Executor.\\n     *\\n     * @param unfollowerProfileId The ID of the profile the unfollows are being executed for.\\n     * @param idsOfProfilesToUnfollow The array of IDs of profiles to unfollow.\\n     */\\n    function unfollow(uint256 unfollowerProfileId, uint256[] calldata idsOfProfilesToUnfollow) external;\\n\\n    /**\\n     * @custom:meta-tx unfollow.\\n     */\\n    function unfollowWithSig(\\n        uint256 unfollowerProfileId,\\n        uint256[] calldata idsOfProfilesToUnfollow,\\n        Types.EIP712Signature calldata signature\\n    ) external;\\n\\n    /**\\n     * @notice Sets the block status for the given profiles. Changing a profile's block status to `true` (i.e. blocked),\\n     * when will also force them to unfollow.\\n     * Blocked profiles cannot perform any actions with the profile that blocked them: they cannot comment or mirror\\n     * their publications, they cannot follow them, they cannot collect, tip them, etc.\\n     * @custom:permissions Profile Owner or Delegated Executor.\\n     *\\n     * @dev Both the `idsOfProfilesToSetBlockStatus` and `blockStatus` arrays must be of the same length.\\n     *\\n     * @param byProfileId The ID of the profile that is blocking/unblocking somebody.\\n     * @param idsOfProfilesToSetBlockStatus The array of IDs of profiles to set block status.\\n     * @param blockStatus The array of block statuses to use for each (true is blocked).\\n     */\\n    function setBlockStatus(\\n        uint256 byProfileId,\\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\\n        bool[] calldata blockStatus\\n    ) external;\\n\\n    /**\\n     * @custom:meta-tx setBlockStatus.\\n     */\\n    function setBlockStatusWithSig(\\n        uint256 byProfileId,\\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\\n        bool[] calldata blockStatus,\\n        Types.EIP712Signature calldata signature\\n    ) external;\\n\\n    /**\\n     * @notice Collects a given publication via signature with the specified parameters.\\n     * Collect can have referrers (e.g. publications or profiles that allowed to discover the pointed publication).\\n     * @custom:permissions Collector Profile Owner or its Delegated Executor.\\n     * @custom:pending-deprecation Collect modules were replaced by PublicationAction Collect modules in V2. This method\\n     * is left here for backwards compatibility with posts made in V1 that had Collect modules.\\n     *\\n     * @param collectParams A CollectParams struct containing the parameters.\\n     *\\n     * @return uint256 An integer representing the minted token ID.\\n     */\\n    function collectLegacy(Types.LegacyCollectParams calldata collectParams) external returns (uint256);\\n\\n    /**\\n     * @custom:meta-tx collect.\\n     * @custom:pending-deprecation\\n     */\\n    function collectLegacyWithSig(\\n        Types.LegacyCollectParams calldata collectParams,\\n        Types.EIP712Signature calldata signature\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Acts on a given publication with the specified parameters.\\n     * You can act on a publication except a mirror (if it has at least one action module initialized).\\n     * Actions can have referrers (e.g. publications or profiles that allowed to discover the pointed publication).\\n     * @custom:permissions Actor Profile Owner or its Delegated Executor.\\n     *\\n     * @param publicationActionParams A PublicationActionParams struct containing the parameters.\\n     *\\n     * @return bytes Arbitrary data the action module returns.\\n     */\\n    function act(Types.PublicationActionParams calldata publicationActionParams) external returns (bytes memory);\\n\\n    /**\\n     * @custom:meta-tx act.\\n     */\\n    function actWithSig(\\n        Types.PublicationActionParams calldata publicationActionParams,\\n        Types.EIP712Signature calldata signature\\n    ) external returns (bytes memory);\\n\\n    /**\\n     * @dev This function is used to invalidate signatures by incrementing the nonce of the signer.\\n     * @param increment The amount to increment the nonce by (max 255).\\n     */\\n    function incrementNonce(uint8 increment) external;\\n\\n    /////////////////////////////////\\n    ///       VIEW FUNCTIONS      ///\\n    /////////////////////////////////\\n\\n    /**\\n     * @notice Returns whether or not `followerProfileId` is following `followedProfileId`.\\n     *\\n     * @param followerProfileId The ID of the profile whose following state should be queried.\\n     * @param followedProfileId The ID of the profile whose followed state should be queried.\\n     *\\n     * @return bool True if `followerProfileId` is following `followedProfileId`, false otherwise.\\n     */\\n    function isFollowing(uint256 followerProfileId, uint256 followedProfileId) external view returns (bool);\\n\\n    /**\\n     * @notice Returns whether the given address is approved as delegated executor, in the configuration with the given\\n     * number, to act on behalf of the given profile.\\n     *\\n     * @param delegatorProfileId The ID of the profile to check the delegated executor approval for.\\n     * @param delegatedExecutor The address to query the delegated executor approval for.\\n     * @param configNumber The number of the configuration where the executor approval state is being queried.\\n     *\\n     * @return bool True if the address is approved as a delegated executor to act on behalf of the profile in the\\n     * given configuration, false otherwise.\\n     */\\n    function isDelegatedExecutorApproved(\\n        uint256 delegatorProfileId,\\n        address delegatedExecutor,\\n        uint64 configNumber\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Returns whether the given address is approved as delegated executor, in the current configuration, to act\\n     * on behalf of the given profile.\\n     *\\n     * @param delegatorProfileId The ID of the profile to check the delegated executor approval for.\\n     * @param delegatedExecutor The address to query the delegated executor approval for.\\n     *\\n     * @return bool True if the address is approved as a delegated executor to act on behalf of the profile in the\\n     * current configuration, false otherwise.\\n     */\\n    function isDelegatedExecutorApproved(\\n        uint256 delegatorProfileId,\\n        address delegatedExecutor\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the current delegated executor config number for the given profile.\\n     *\\n     * @param delegatorProfileId The ID of the profile from which the delegated executors config number is being queried\\n     *\\n     * @return uint256 The current delegated executor configuration number.\\n     */\\n    function getDelegatedExecutorsConfigNumber(uint256 delegatorProfileId) external view returns (uint64);\\n\\n    /**\\n     * @notice Returns the previous used delegated executor config number for the given profile.\\n     *\\n     * @param delegatorProfileId The ID of the profile from which the delegated executors' previous configuration number\\n     * set is being queried.\\n     *\\n     * @return uint256 The delegated executor configuration number previously set. It will coincide with the current\\n     * configuration set if it was never switched from the default one.\\n     */\\n    function getDelegatedExecutorsPrevConfigNumber(uint256 delegatorProfileId) external view returns (uint64);\\n\\n    /**\\n     * @notice Returns the maximum delegated executor config number for the given profile.\\n     * This is the maximum config number that was ever used by this profile.\\n     * When creating a new clean configuration, you can only use a number that is maxConfigNumber + 1.\\n     *\\n     * @param delegatorProfileId The ID of the profile from which the delegated executors' maximum configuration number\\n     * set is being queried.\\n     *\\n     * @return uint256 The delegated executor maximum configuration number set.\\n     */\\n    function getDelegatedExecutorsMaxConfigNumberSet(uint256 delegatorProfileId) external view returns (uint64);\\n\\n    /**\\n     * @notice Returns whether `profileId` is blocked by `byProfileId`.\\n     * See setBlockStatus() for more information on how blocking works on the platform.\\n     *\\n     * @param profileId The ID of the profile whose blocked status should be queried.\\n     * @param byProfileId The ID of the profile whose blocker status should be queried.\\n     *\\n     * @return bool True if `profileId` is blocked by `byProfileId`, false otherwise.\\n     */\\n    function isBlocked(uint256 profileId, uint256 byProfileId) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the URI associated with a given publication.\\n     * This is used to store the publication's metadata, e.g.: content, images, etc.\\n     *\\n     * @param profileId The token ID of the profile that published the publication to query.\\n     * @param pubId The publication ID of the publication to query.\\n     *\\n     * @return string The URI associated with a given publication.\\n     */\\n    function getContentURI(uint256 profileId, uint256 pubId) external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the full profile struct associated with a given profile token ID.\\n     *\\n     * @param profileId The token ID of the profile to query.\\n     *\\n     * @return Profile The profile struct of the given profile.\\n     */\\n    function getProfile(uint256 profileId) external view returns (Types.Profile memory);\\n\\n    /**\\n     * @notice Returns the full publication struct for a given publication.\\n     *\\n     * @param profileId The token ID of the profile that published the publication to query.\\n     * @param pubId The publication ID of the publication to query.\\n     *\\n     * @return Publication The publication struct associated with the queried publication.\\n     */\\n    function getPublication(uint256 profileId, uint256 pubId) external view returns (Types.PublicationMemory memory);\\n\\n    /**\\n     * @notice Returns the type of a given publication.\\n     * The type can be one of the following (see PublicationType enum):\\n     * - Nonexistent\\n     * - Post\\n     * - Comment\\n     * - Mirror\\n     * - Quote\\n     *\\n     * @param profileId The token ID of the profile that published the publication to query.\\n     * @param pubId The publication ID of the publication to query.\\n     *\\n     * @return PublicationType The publication type of the queried publication.\\n     */\\n    function getPublicationType(uint256 profileId, uint256 pubId) external view returns (Types.PublicationType);\\n\\n    /**\\n     * @notice Returns wether a given Action Module is enabled for a given publication.\\n     *\\n     * @param profileId The token ID of the profile that published the publication to query.\\n     * @param pubId The publication ID of the publication to query.\\n     * @param module The address of the Action Module to query.\\n     *\\n     * @return bool True if the Action Module is enabled for the queried publication, false if not.\\n     */\\n    function isActionModuleEnabledInPublication(\\n        uint256 profileId,\\n        uint256 pubId,\\n        address module\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILensVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title ILensVersion\\n * @author Lens Protocol\\n *\\n * @notice This is the interface for the LensHub Version getters and emitter.\\n * It allows to emit a LensHub version during an upgrade, and also to get the current version.\\n */\\ninterface ILensVersion {\\n    /**\\n     * @notice Returns the LensHub current Version.\\n     *\\n     * @return version The LensHub current Version.\\n     */\\n    function getVersion() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the LensHub current Git Commit.\\n     *\\n     * @return gitCommit The LensHub current Git Commit.\\n     */\\n    function getGitCommit() external view returns (bytes20);\\n\\n    /**\\n     * @notice Emits the LensHub current Version. Used in upgradeAndCall().\\n     */\\n    function emitVersion() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IModuleRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\ninterface IModuleRegistry {\\n    enum ModuleType {\\n        __, // Just to avoid 0 as valid ModuleType\\n        PUBLICATION_ACTION_MODULE,\\n        REFERENCE_MODULE,\\n        FOLLOW_MODULE\\n    }\\n\\n    // Modules functions\\n\\n    function verifyModule(address moduleAddress, uint256 moduleType) external returns (bool);\\n\\n    function registerModule(address moduleAddress, uint256 moduleType) external returns (bool);\\n\\n    function getModuleTypes(address moduleAddress) external view returns (uint256);\\n\\n    function isModuleRegistered(address moduleAddress) external view returns (bool);\\n\\n    function isModuleRegisteredAs(address moduleAddress, uint256 moduleType) external view returns (bool);\\n\\n    // Currencies functions\\n\\n    function verifyErc20Currency(address currencyAddress) external returns (bool);\\n\\n    function registerErc20Currency(address currencyAddress) external returns (bool);\\n\\n    function isErc20CurrencyRegistered(address currencyAddress) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPublicationActionModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\n\\n/**\\n * @title IPublicationAction\\n * @author Lens Protocol\\n *\\n * @notice This is the standard interface for all Lens-compatible Publication Actions.\\n * Publication action modules allow users to execute actions directly from a publication, like:\\n *  - Minting NFTs.\\n *  - Collecting a publication.\\n *  - Sending funds to the publication author (e.g. tipping).\\n *  - Etc.\\n * Referrers are supported, so any publication or profile that references the publication can receive a share from the\\n * publication's action if the action module supports it.\\n */\\ninterface IPublicationActionModule {\\n    /**\\n     * @notice Initializes the action module for the given publication being published with this Action module.\\n     * @custom:permissions LensHub.\\n     *\\n     * @param profileId The profile ID of the author publishing the content with this Publication Action.\\n     * @param pubId The publication ID being published.\\n     * @param transactionExecutor The address of the transaction executor (e.g. for any funds to transferFrom).\\n     * @param data Arbitrary data passed from the user to be decoded by the Action Module during initialization.\\n     *\\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\\n     * indexers or UIs.\\n     */\\n    function initializePublicationAction(\\n        uint256 profileId,\\n        uint256 pubId,\\n        address transactionExecutor,\\n        bytes calldata data\\n    ) external returns (bytes memory);\\n\\n    /**\\n     * @notice Processes the action for a given publication. This includes the action's logic and any monetary/token\\n     * operations.\\n     * @custom:permissions LensHub.\\n     *\\n     * @param processActionParams The parameters needed to execute the publication action.\\n     *\\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\\n     * indexers or UIs.\\n     */\\n    function processPublicationAction(Types.ProcessActionParams calldata processActionParams)\\n        external\\n        returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReferenceModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\n\\n/**\\n * @title IReferenceModule\\n * @author Lens Protocol\\n *\\n * @notice This is the standard interface for all Lens-compatible ReferenceModules.\\n * Reference modules allow executing some action when a publication is referenced, like:\\n *  - Rewards for mirroring/commenting/quoting a publication.\\n *  - Token-gated comments/mirrors/quotes of a publication.\\n *  - Etc.\\n */\\ninterface IReferenceModule {\\n    /**\\n     * @notice Initializes data for the given publication being published with this Reference module.\\n     * @custom:permissions LensHub.\\n     *\\n     * @param profileId The token ID of the profile publishing the publication.\\n     * @param pubId The associated publication's LensHub publication ID.\\n     * @param transactionExecutor The address of the transaction executor (e.g. for any funds to transferFrom).\\n     * @param data Arbitrary data passed from the user to be decoded by the Reference Module during initialization.\\n     *\\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\\n     * indexers or UIs.\\n     */\\n    function initializeReferenceModule(\\n        uint256 profileId,\\n        uint256 pubId,\\n        address transactionExecutor,\\n        bytes calldata data\\n    ) external returns (bytes memory);\\n\\n    /**\\n     * @notice Processes a comment being published. This includes any module logic like transferring tokens,\\n     * checking for conditions (e.g. token-gated), etc.\\n     * @custom:permissions LensHub.\\n     *\\n     * @param processCommentParams The parameters for processing a comment.\\n     *\\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\\n     * indexers or UIs.\\n     */\\n    function processComment(Types.ProcessCommentParams calldata processCommentParams) external returns (bytes memory);\\n\\n    /**\\n     * @notice Processes a quote being published. This includes any module logic like transferring tokens,\\n     * checking for conditions (e.g. token-gated), etc.\\n     * @custom:permissions LensHub\\n     *\\n     * @param processQuoteParams The parameters for processing a quote.\\n     *\\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\\n     * indexers or UIs.\\n     */\\n    function processQuote(Types.ProcessQuoteParams calldata processQuoteParams) external returns (bytes memory);\\n\\n    /**\\n     * @notice Processes a mirror being published. This includes any module logic like transferring tokens,\\n     * checking for conditions (e.g. token-gated), etc.\\n     * @custom:permissions LensHub\\n     *\\n     * @param processMirrorParams The parameters for processing a mirror.\\n     *\\n     * @return bytes Any custom ABI-encoded data. This will be a LensHub event params that can be used by\\n     * indexers or UIs.\\n     */\\n    function processMirror(Types.ProcessMirrorParams calldata processMirrorParams) external returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenHandleRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title ITokenHandleRegistry\\n * @author Lens Protocol\\n *\\n * @notice The interface for TokenHandleRegistry contract that is responsible for linking a handle NFT to a token NFT.\\n * Linking means a connection between the two NFTs is created, and the handle NFT can be used to resolve the token NFT\\n * or vice versa.\\n * The registry is responsible for keeping track of the links between the NFTs, and for resolving them.\\n * The first version of the registry is hard-coded to support only the .lens namespace and the Lens Protocol Profiles.\\n */\\ninterface ITokenHandleRegistry {\\n    /**\\n     * @notice Lens V1 -> V2 migration function. Links a handle NFT to a profile NFT without additional checks to save\\n     * gas.\\n     * Will be called by the migration function (in MigrationLib) in LensHub, only for new handles being migrated.\\n     *\\n     * @custom:permissions LensHub\\n     *\\n     * @param handleId ID of the .lens namespace handle NFT\\n     * @param profileId ID of the Lens Protocol Profile NFT\\n     */\\n    function migrationLink(uint256 handleId, uint256 profileId) external;\\n\\n    /**\\n     * @notice Links a handle NFT with a profile NFT.\\n     * Linking means a connection between the two NFTs is created, and the handle NFT can be used to resolve the profile\\n     * NFT or vice versa.\\n     * @custom:permissions Both NFTs must be owned by the same address, and caller must be the owner of profile or its\\n     * approved DelegatedExecutor.\\n     *\\n     * @dev In the first version of the registry, the NFT contracts are hard-coded:\\n     *  - Handle is hard-coded to be of the .lens namespace\\n     *  - Token is hard-coded to be of the Lens Protocol Profile\\n     * In future versions, the registry will be more flexible and allow for different namespaces and tokens, so this\\n     * function might be deprecated and replaced with a new one accepting addresses of the handle and token contracts.\\n     *\\n     * @param handleId ID of the .lens namespace handle NFT\\n     * @param profileId ID of the Lens Protocol Profile NFT\\n     */\\n    function link(uint256 handleId, uint256 profileId) external;\\n\\n    /**\\n     * @notice Unlinks a handle NFT from a profile NFT.\\n     * @custom:permissions Caller can be the owner of either of the NFTs.\\n     *\\n     * @dev In the first version of the registry, the contracts are hard-coded:\\n     *  - Handle is hard-coded to be of the .lens namespace\\n     *  - Token is hard-coded to be of the Lens Protocol Profile\\n     * In future versions, the registry will be more flexible and allow for different namespaces and tokens, so this\\n     * function might be deprecated and replaced with a new one accepting addresses of the handle and token contracts.\\n     *\\n     * @param handleId ID of the .lens namespace handle NFT\\n     * @param profileId ID of the Lens Protocol Profile NFT\\n     */\\n    function unlink(uint256 handleId, uint256 profileId) external;\\n\\n    /**\\n     * @notice Resolves a handle NFT to a profile NFT.\\n     *\\n     * @dev In the first version of the registry, the contracts are hard-coded:\\n     *  - Handle is hard-coded to be of the .lens namespace\\n     *  - Token is hard-coded to be of the Lens Protocol Profile\\n     * In future versions, the registry will be more flexible and allow for different namespaces and tokens, so this\\n     * function might be deprecated and replaced with a new one.\\n     *\\n     * @param handleId ID of the .lens namespace handle NFT\\n     *\\n     * @return tokenId ID of the Lens Protocol Profile NFT\\n     */\\n    function resolve(uint256 handleId) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets a default handle for a profile NFT (aka reverse resolution).\\n     *\\n     * @dev In the first version of the registry, the contracts are hard-coded:\\n     *  - Handle is hard-coded to be of the .lens namespace\\n     *  - Token is hard-coded to be of the Lens Protocol Profile\\n     * In future versions, the registry will be more flexible and allow for different namespaces and tokens, so this\\n     * function might be deprecated and replaced with a new one.\\n     *\\n     * @param tokenId ID of the Lens Protocol Profile NFT\\n     *\\n     * @return handleId ID of the .lens namespace handle NFT\\n     */\\n    function getDefaultHandle(uint256 tokenId) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MetaTxLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {IERC1271} from '@openzeppelin/contracts/interfaces/IERC1271.sol';\\nimport {ILensERC721} from 'contracts/interfaces/ILensERC721.sol';\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\nimport {Typehash} from 'contracts/libraries/constants/Typehash.sol';\\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\\nimport {Events} from 'contracts/libraries/constants/Events.sol';\\n\\n/**\\n * @title MetaTxLib\\n * @author Lens Protocol\\n *\\n * NOTE: the functions in this contract operate under the assumption that the passed signer is already validated\\n * to either be the originator or one of their delegated executors.\\n *\\n * @dev User nonces are incremented from this library as well.\\n */\\nlibrary MetaTxLib {\\n    string constant EIP712_DOMAIN_VERSION = '2';\\n    bytes32 constant EIP712_DOMAIN_VERSION_HASH = keccak256(bytes(EIP712_DOMAIN_VERSION));\\n    bytes4 constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\\n\\n    /**\\n     * @dev We store the domain separator and LensHub Proxy address as constants to save gas.\\n     *\\n     * keccak256(\\n     *     abi.encode(\\n     *         keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n     *         keccak256('Lens Protocol Profiles'), // Contract Name\\n     *         keccak256('2'), // Version Hash\\n     *         137, // Polygon Chain ID\\n     *         address(0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d) // Verifying Contract Address - LensHub Address\\n     *     )\\n     * );\\n     */\\n    bytes32 constant LENS_HUB_CACHED_POLYGON_DOMAIN_SEPARATOR =\\n        0xbf9544cf7d7a0338fc4f071be35409a61e51e9caef559305410ad74e16a05f2d;\\n\\n    address constant LENS_HUB_ADDRESS = 0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d;\\n\\n    uint256 constant POLYGON_CHAIN_ID = 137;\\n\\n    function validateSetProfileMetadataURISignature(\\n        Types.EIP712Signature calldata signature,\\n        uint256 profileId,\\n        string calldata metadataURI\\n    ) external {\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.SET_PROFILE_METADATA_URI,\\n                        profileId,\\n                        _encodeUsingEip712Rules(metadataURI),\\n                        _getNonceIncrementAndEmitEvent(signature.signer),\\n                        signature.deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    function validateSetFollowModuleSignature(\\n        Types.EIP712Signature calldata signature,\\n        uint256 profileId,\\n        address followModule,\\n        bytes calldata followModuleInitData\\n    ) external {\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.SET_FOLLOW_MODULE,\\n                        profileId,\\n                        followModule,\\n                        _encodeUsingEip712Rules(followModuleInitData),\\n                        _getNonceIncrementAndEmitEvent(signature.signer),\\n                        signature.deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    function validateChangeDelegatedExecutorsConfigSignature(\\n        Types.EIP712Signature calldata signature,\\n        uint256 delegatorProfileId,\\n        address[] calldata delegatedExecutors,\\n        bool[] calldata approvals,\\n        uint64 configNumber,\\n        bool switchToGivenConfig\\n    ) external {\\n        address signer = signature.signer;\\n        uint256 deadline = signature.deadline;\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.CHANGE_DELEGATED_EXECUTORS_CONFIG,\\n                        delegatorProfileId,\\n                        _encodeUsingEip712Rules(delegatedExecutors),\\n                        _encodeUsingEip712Rules(approvals),\\n                        configNumber,\\n                        switchToGivenConfig,\\n                        _getNonceIncrementAndEmitEvent(signer),\\n                        deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    function validatePostSignature(\\n        Types.EIP712Signature calldata signature,\\n        Types.PostParams calldata postParams\\n    ) external {\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.POST,\\n                        postParams.profileId,\\n                        _encodeUsingEip712Rules(postParams.contentURI),\\n                        _encodeUsingEip712Rules(postParams.actionModules),\\n                        _encodeUsingEip712Rules(postParams.actionModulesInitDatas),\\n                        postParams.referenceModule,\\n                        _encodeUsingEip712Rules(postParams.referenceModuleInitData),\\n                        _getNonceIncrementAndEmitEvent(signature.signer),\\n                        signature.deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    function validateCommentSignature(\\n        Types.EIP712Signature calldata signature,\\n        Types.CommentParams calldata commentParams\\n    ) external {\\n        bytes memory encodedAbi = abi.encode(\\n            Typehash.COMMENT,\\n            commentParams.profileId,\\n            _encodeUsingEip712Rules(commentParams.contentURI),\\n            commentParams.pointedProfileId,\\n            commentParams.pointedPubId,\\n            _encodeUsingEip712Rules(commentParams.referrerProfileIds),\\n            _encodeUsingEip712Rules(commentParams.referrerPubIds),\\n            _encodeUsingEip712Rules(commentParams.referenceModuleData),\\n            _encodeUsingEip712Rules(commentParams.actionModules),\\n            _encodeUsingEip712Rules(commentParams.actionModulesInitDatas),\\n            commentParams.referenceModule,\\n            _encodeUsingEip712Rules(commentParams.referenceModuleInitData),\\n            _getNonceIncrementAndEmitEvent(signature.signer),\\n            signature.deadline\\n        );\\n        _validateRecoveredAddress(_calculateDigest(keccak256(encodedAbi)), signature);\\n    }\\n\\n    function validateQuoteSignature(\\n        Types.EIP712Signature calldata signature,\\n        Types.QuoteParams calldata quoteParams\\n    ) external {\\n        bytes memory encodedAbi = abi.encode(\\n            Typehash.QUOTE,\\n            quoteParams.profileId,\\n            _encodeUsingEip712Rules(quoteParams.contentURI),\\n            quoteParams.pointedProfileId,\\n            quoteParams.pointedPubId,\\n            _encodeUsingEip712Rules(quoteParams.referrerProfileIds),\\n            _encodeUsingEip712Rules(quoteParams.referrerPubIds),\\n            _encodeUsingEip712Rules(quoteParams.referenceModuleData),\\n            _encodeUsingEip712Rules(quoteParams.actionModules),\\n            _encodeUsingEip712Rules(quoteParams.actionModulesInitDatas),\\n            quoteParams.referenceModule,\\n            _encodeUsingEip712Rules(quoteParams.referenceModuleInitData),\\n            _getNonceIncrementAndEmitEvent(signature.signer),\\n            signature.deadline\\n        );\\n        _validateRecoveredAddress(_calculateDigest(keccak256(encodedAbi)), signature);\\n    }\\n\\n    function validateMirrorSignature(\\n        Types.EIP712Signature calldata signature,\\n        Types.MirrorParams calldata mirrorParams\\n    ) external {\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.MIRROR,\\n                        mirrorParams.profileId,\\n                        _encodeUsingEip712Rules(mirrorParams.metadataURI),\\n                        mirrorParams.pointedProfileId,\\n                        mirrorParams.pointedPubId,\\n                        _encodeUsingEip712Rules(mirrorParams.referrerProfileIds),\\n                        _encodeUsingEip712Rules(mirrorParams.referrerPubIds),\\n                        _encodeUsingEip712Rules(mirrorParams.referenceModuleData),\\n                        _getNonceIncrementAndEmitEvent(signature.signer),\\n                        signature.deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    function validateFollowSignature(\\n        Types.EIP712Signature calldata signature,\\n        uint256 followerProfileId,\\n        uint256[] calldata idsOfProfilesToFollow,\\n        uint256[] calldata followTokenIds,\\n        bytes[] calldata datas\\n    ) external {\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.FOLLOW,\\n                        followerProfileId,\\n                        _encodeUsingEip712Rules(idsOfProfilesToFollow),\\n                        _encodeUsingEip712Rules(followTokenIds),\\n                        _encodeUsingEip712Rules(datas),\\n                        _getNonceIncrementAndEmitEvent(signature.signer),\\n                        signature.deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    function validateUnfollowSignature(\\n        Types.EIP712Signature calldata signature,\\n        uint256 unfollowerProfileId,\\n        uint256[] calldata idsOfProfilesToUnfollow\\n    ) external {\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.UNFOLLOW,\\n                        unfollowerProfileId,\\n                        _encodeUsingEip712Rules(idsOfProfilesToUnfollow),\\n                        _getNonceIncrementAndEmitEvent(signature.signer),\\n                        signature.deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    function validateSetBlockStatusSignature(\\n        Types.EIP712Signature calldata signature,\\n        uint256 byProfileId,\\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\\n        bool[] calldata blockStatus\\n    ) external {\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.SET_BLOCK_STATUS,\\n                        byProfileId,\\n                        _encodeUsingEip712Rules(idsOfProfilesToSetBlockStatus),\\n                        _encodeUsingEip712Rules(blockStatus),\\n                        _getNonceIncrementAndEmitEvent(signature.signer),\\n                        signature.deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    function validateLegacyCollectSignature(\\n        Types.EIP712Signature calldata signature,\\n        Types.LegacyCollectParams calldata collectParams\\n    ) external {\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.COLLECT_LEGACY,\\n                        collectParams.publicationCollectedProfileId,\\n                        collectParams.publicationCollectedId,\\n                        collectParams.collectorProfileId,\\n                        collectParams.referrerProfileId,\\n                        collectParams.referrerPubId,\\n                        _encodeUsingEip712Rules(collectParams.collectModuleData),\\n                        _getNonceIncrementAndEmitEvent(signature.signer),\\n                        signature.deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    function validateActSignature(\\n        Types.EIP712Signature calldata signature,\\n        Types.PublicationActionParams calldata publicationActionParams\\n    ) external {\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.ACT,\\n                        publicationActionParams.publicationActedProfileId,\\n                        publicationActionParams.publicationActedId,\\n                        publicationActionParams.actorProfileId,\\n                        _encodeUsingEip712Rules(publicationActionParams.referrerProfileIds),\\n                        _encodeUsingEip712Rules(publicationActionParams.referrerPubIds),\\n                        publicationActionParams.actionModuleAddress,\\n                        _encodeUsingEip712Rules(publicationActionParams.actionModuleData),\\n                        _getNonceIncrementAndEmitEvent(signature.signer),\\n                        signature.deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    /// @dev This function is used to invalidate signatures by incrementing the nonce\\n    function incrementNonce(uint8 increment) external {\\n        uint256 currentNonce = StorageLib.nonces()[msg.sender];\\n        StorageLib.nonces()[msg.sender] = currentNonce + increment;\\n        emit Events.NonceUpdated(msg.sender, currentNonce + increment, block.timestamp);\\n    }\\n\\n    function calculateDomainSeparator() internal view returns (bytes32) {\\n        if (address(this) == LENS_HUB_ADDRESS && block.chainid == POLYGON_CHAIN_ID) {\\n            return LENS_HUB_CACHED_POLYGON_DOMAIN_SEPARATOR;\\n        }\\n        return\\n            keccak256(\\n                abi.encode(\\n                    Typehash.EIP712_DOMAIN,\\n                    keccak256(bytes(ILensERC721(address(this)).name())),\\n                    EIP712_DOMAIN_VERSION_HASH,\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Wrapper for ecrecover to reduce code size, used in meta-tx specific functions.\\n     */\\n    function _validateRecoveredAddress(bytes32 digest, Types.EIP712Signature calldata signature) private view {\\n        if (block.timestamp > signature.deadline) revert Errors.SignatureExpired();\\n        // If the expected address is a contract, check the signature there.\\n        if (signature.signer.code.length != 0) {\\n            bytes memory concatenatedSig = abi.encodePacked(signature.r, signature.s, signature.v);\\n            if (IERC1271(signature.signer).isValidSignature(digest, concatenatedSig) != EIP1271_MAGIC_VALUE) {\\n                revert Errors.SignatureInvalid();\\n            }\\n        } else {\\n            address recoveredAddress = ecrecover(digest, signature.v, signature.r, signature.s);\\n            if (recoveredAddress == address(0) || recoveredAddress != signature.signer) {\\n                revert Errors.SignatureInvalid();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates EIP712 digest based on the current DOMAIN_SEPARATOR.\\n     *\\n     * @param hashedMessage The message hash from which the digest should be calculated.\\n     *\\n     * @return bytes32 A 32-byte output representing the EIP712 digest.\\n     */\\n    function _calculateDigest(bytes32 hashedMessage) private view returns (bytes32) {\\n        return keccak256(abi.encodePacked('\\\\x19\\\\x01', calculateDomainSeparator(), hashedMessage));\\n    }\\n\\n    /**\\n     * @dev This fetches a signer's current nonce and increments it so it's ready for the next meta-tx. Also emits\\n     * the `NonceUpdated` event.\\n     *\\n     * @param signer The address to get and increment the nonce for.\\n     *\\n     * @return uint256 The current nonce for the given signer prior to being incremented.\\n     */\\n    function _getNonceIncrementAndEmitEvent(address signer) private returns (uint256) {\\n        uint256 currentNonce;\\n        unchecked {\\n            currentNonce = StorageLib.nonces()[signer]++;\\n        }\\n        emit Events.NonceUpdated(signer, currentNonce + 1, block.timestamp);\\n        return currentNonce;\\n    }\\n\\n    function _encodeUsingEip712Rules(bytes[] memory bytesArray) private pure returns (bytes32) {\\n        bytes32[] memory bytesArrayEncodedElements = new bytes32[](bytesArray.length);\\n        uint256 i;\\n        while (i < bytesArray.length) {\\n            // A `bytes` type is encoded as its keccak256 hash.\\n            bytesArrayEncodedElements[i] = _encodeUsingEip712Rules(bytesArray[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        // An array is encoded as the keccak256 hash of the concatenation of their encoded elements.\\n        return _encodeUsingEip712Rules(bytesArrayEncodedElements);\\n    }\\n\\n    function _encodeUsingEip712Rules(bool[] memory boolArray) private pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(boolArray));\\n    }\\n\\n    function _encodeUsingEip712Rules(address[] memory addressArray) private pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(addressArray));\\n    }\\n\\n    function _encodeUsingEip712Rules(uint256[] memory uint256Array) private pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(uint256Array));\\n    }\\n\\n    function _encodeUsingEip712Rules(bytes32[] memory bytes32Array) private pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(bytes32Array));\\n    }\\n\\n    function _encodeUsingEip712Rules(string memory stringValue) private pure returns (bytes32) {\\n        return keccak256(bytes(stringValue));\\n    }\\n\\n    function _encodeUsingEip712Rules(bytes memory bytesValue) private pure returns (bytes32) {\\n        return keccak256(bytesValue);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MigrationLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport {Events} from 'contracts/libraries/constants/Events.sol';\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\\nimport {FollowNFT} from 'contracts/FollowNFT.sol';\\nimport {LensHandles} from 'contracts/namespaces/LensHandles.sol';\\nimport {TokenHandleRegistry} from 'contracts/namespaces/TokenHandleRegistry.sol';\\nimport {IFollowModule} from 'contracts/interfaces/IFollowModule.sol';\\n\\ninterface ILegacyFeeFollowModule {\\n    struct ProfileData {\\n        address currency;\\n        uint256 amount;\\n        address recipient;\\n    }\\n\\n    function getProfileData(uint256 profileId) external view returns (ProfileData memory);\\n}\\n\\nlibrary MigrationLib {\\n    uint256 internal constant LENS_PROTOCOL_PROFILE_ID = 1;\\n    uint256 internal constant DOT_LENS_SUFFIX_LENGTH = 5;\\n\\n    // Profiles Handles Migration:\\n\\n    event ProfileMigrated(uint256 indexed profileId);\\n\\n    /**\\n     * @notice Migrates an array of profiles from V1 to V2. This function can be callable by anyone.\\n     * We would still perform the migration in batches by ourselves, but good to allow users to migrate on their own if they want to.\\n     *\\n     * @param profileIds The array of profile IDs to migrate.\\n     */\\n    function batchMigrateProfiles(\\n        uint256[] calldata profileIds,\\n        LensHandles lensHandles,\\n        TokenHandleRegistry tokenHandleRegistry\\n    ) external {\\n        uint256 i;\\n        while (i < profileIds.length) {\\n            _migrateProfile(profileIds[i], lensHandles, tokenHandleRegistry);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Migrates a profile from V1 to V2.\\n     *\\n     * @dev We do not revert in any case, as we want to allow the migration to continue even if one profile fails\\n     *      (and it usually fails if already migrated or profileNFT moved).\\n     * @dev Estimated gas cost of one profile migration is around 178k gas.\\n     *\\n     * @param profileId The profile ID to migrate.\\n     */\\n    function _migrateProfile(\\n        uint256 profileId,\\n        LensHandles lensHandles,\\n        TokenHandleRegistry tokenHandleRegistry\\n    ) private {\\n        address profileOwner = StorageLib.getTokenData(profileId).owner;\\n        // We check if the profile exists by checking owner != address(0).\\n        if (profileOwner != address(0)) {\\n            // We check if the profile has already been migrated by checking __DEPRECATED__handle != \\\"\\\".\\n            string memory handle = StorageLib.getProfile(profileId).__DEPRECATED__handle;\\n            if (bytes(handle).length == 0) {\\n                return; // Already migrated\\n            }\\n            bytes32 handleHash = keccak256(bytes(handle));\\n            // We check if the profile is the \\\"lensprotocol\\\" profile by checking profileId != 1.\\n            // \\\"lensprotocol\\\" is the only edge case without the .lens suffix:\\n            if (profileId != LENS_PROTOCOL_PROFILE_ID) {\\n                assembly {\\n                    let handle_length := mload(handle)\\n                    mstore(handle, sub(handle_length, DOT_LENS_SUFFIX_LENGTH)) // Cut 5 chars (.lens) from the end\\n                }\\n            }\\n            // We mint a new handle on the LensHandles contract. The resulting handle NFT is sent to the profile owner.\\n            uint256 handleId = lensHandles.migrateHandle(profileOwner, handle);\\n            // We link it to the profile in the TokenHandleRegistry contract.\\n            tokenHandleRegistry.migrationLink(handleId, profileId);\\n            emit ProfileMigrated(profileId);\\n            delete StorageLib.getProfile(profileId).__DEPRECATED__handle;\\n            delete StorageLib.getProfile(profileId).__DEPRECATED__followNFTURI;\\n            delete StorageLib.profileIdByHandleHash()[handleHash];\\n\\n            if (StorageLib.getDelegatedExecutorsConfig(profileId).configNumber == 0) {\\n                // This event can be duplicated, and then redundant, if the profile has already configured the Delegated\\n                // Executors before being migrated. Given that this is an edge case, we exceptionally accept this\\n                // redundancy considering that the event is still consistent with the state.\\n                emit Events.DelegatedExecutorsConfigApplied(profileId, 0, block.timestamp);\\n            }\\n        }\\n    }\\n\\n    // FollowNFT Migration:\\n\\n    function batchMigrateFollows(\\n        uint256 followerProfileId,\\n        uint256[] calldata idsOfProfileFollowed,\\n        uint256[] calldata followTokenIds\\n    ) external {\\n        if (idsOfProfileFollowed.length != followTokenIds.length) {\\n            revert Errors.ArrayMismatch();\\n        }\\n        uint256 i;\\n        while (i < idsOfProfileFollowed.length) {\\n            _migrateFollow(\\n                StorageLib.getProfile(idsOfProfileFollowed[i]).followNFT,\\n                followerProfileId, // one follower for all the follows\\n                idsOfProfileFollowed[i],\\n                followTokenIds[i]\\n            );\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function batchMigrateFollowers(\\n        uint256[] calldata followerProfileIds,\\n        uint256 idOfProfileFollowed,\\n        uint256[] calldata followTokenIds\\n    ) external {\\n        if (followerProfileIds.length != followTokenIds.length) {\\n            revert Errors.ArrayMismatch();\\n        }\\n        address followNFT = StorageLib.getProfile(idOfProfileFollowed).followNFT;\\n        uint256 i;\\n        while (i < followTokenIds.length) {\\n            _migrateFollow(\\n                followNFT,\\n                followerProfileIds[i],\\n                idOfProfileFollowed, // one profile followed -> one FollowNFT\\n                followTokenIds[i]\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _migrateFollow(\\n        address followNFT,\\n        uint256 followerProfileId,\\n        uint256 idOfProfileFollowed,\\n        uint256 followTokenId\\n    ) private {\\n        if (StorageLib.blockedStatus(idOfProfileFollowed)[followerProfileId]) {\\n            return; // Cannot follow if blocked\\n        }\\n        if (followerProfileId == idOfProfileFollowed) {\\n            return; // Cannot self-follow\\n        }\\n\\n        uint48 mintTimestamp = FollowNFT(followNFT).tryMigrate({\\n            followerProfileId: followerProfileId,\\n            followerProfileOwner: StorageLib.getTokenData(followerProfileId).owner,\\n            followTokenId: followTokenId\\n        });\\n        // `mintTimestamp` will be 0 if:\\n        // - Follow NFT was already migrated\\n        // - Follow NFT does not exist or was burnt\\n        // - Follower profile Owner is different from Follow NFT Owner\\n        if (mintTimestamp != 0) {\\n            emit Events.Followed({\\n                followerProfileId: followerProfileId,\\n                idOfProfileFollowed: idOfProfileFollowed,\\n                followTokenIdAssigned: followTokenId,\\n                followModuleData: '',\\n                processFollowModuleReturnData: '',\\n                transactionExecutor: address(0), // For migrations, we use this special value as transaction executor.\\n                timestamp: mintTimestamp // The only case where this won't match block.timestamp is during the migration\\n            });\\n        }\\n    }\\n\\n    function batchMigrateFollowModules(\\n        uint256[] calldata profileIds,\\n        address legacyFeeFollowModule,\\n        address legacyProfileFollowModule,\\n        address newFeeFollowModule\\n    ) external {\\n        uint256 i;\\n        while (i < profileIds.length) {\\n            address currentFollowModule = StorageLib.getProfile(profileIds[i]).followModule;\\n            if (currentFollowModule == legacyFeeFollowModule) {\\n                // If the profile had the legacy 'feeFollowModule' set, we need to read its parameters\\n                // and initialize the new feeFollowModule with them.\\n                StorageLib.getProfile(profileIds[i]).followModule = newFeeFollowModule;\\n                ILegacyFeeFollowModule.ProfileData memory feeFollowModuleData = ILegacyFeeFollowModule(\\n                    legacyFeeFollowModule\\n                ).getProfileData(profileIds[i]);\\n                bytes memory followModuleInitData = abi.encode(\\n                    feeFollowModuleData.currency,\\n                    feeFollowModuleData.amount,\\n                    feeFollowModuleData.recipient\\n                );\\n                bytes memory followModuleReturnData = IFollowModule(newFeeFollowModule).initializeFollowModule({\\n                    profileId: profileIds[i],\\n                    transactionExecutor: address(0),\\n                    data: followModuleInitData\\n                });\\n                emit Events.FollowModuleSet(\\n                    profileIds[i],\\n                    newFeeFollowModule,\\n                    followModuleInitData,\\n                    followModuleReturnData,\\n                    address(0),\\n                    block.timestamp\\n                );\\n            } else if (currentFollowModule == legacyProfileFollowModule) {\\n                // If the profile had `ProfileFollowModule` set, we just remove the follow module, as in Lens V2\\n                // you can only follow with a Lens profile.\\n                delete StorageLib.getProfile(profileIds[i]).followModule;\\n                emit Events.FollowModuleSet(profileIds[i], address(0), '', '', address(0), block.timestamp);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ProfileLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\nimport {Events} from 'contracts/libraries/constants/Events.sol';\\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\\nimport {IFollowModule} from 'contracts/interfaces/IFollowModule.sol';\\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\\nimport {IModuleRegistry} from 'contracts/interfaces/IModuleRegistry.sol';\\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\\n\\nlibrary ProfileLib {\\n    function MODULE_REGISTRY() internal view returns (IModuleRegistry) {\\n        return IModuleRegistry(ILensHub(address(this)).getModuleRegistry());\\n    }\\n\\n    function ownerOf(uint256 profileId) internal view returns (address) {\\n        address profileOwner = StorageLib.getTokenData(profileId).owner;\\n        if (profileOwner == address(0)) {\\n            revert Errors.TokenDoesNotExist();\\n        }\\n        return profileOwner;\\n    }\\n\\n    function exists(uint256 profileId) internal view returns (bool) {\\n        return StorageLib.getTokenData(profileId).owner != address(0);\\n    }\\n\\n    /**\\n     * @notice Creates a profile with the given parameters to the given address. Minting happens\\n     * in the hub.\\n     *\\n     * @param createProfileParams The CreateProfileParams struct containing the following parameters:\\n     *      to: The address receiving the profile.\\n     *      followModule: The follow module to use, can be the zero address.\\n     *      followModuleInitData: The follow module initialization data, if any\\n     * @param profileId The profile ID to associate with this profile NFT (token ID).\\n     */\\n    function createProfile(Types.CreateProfileParams calldata createProfileParams, uint256 profileId) external {\\n        emit Events.ProfileCreated(profileId, msg.sender, createProfileParams.to, block.timestamp);\\n        emit Events.DelegatedExecutorsConfigApplied(profileId, 0, block.timestamp);\\n        _setFollowModule(\\n            profileId,\\n            createProfileParams.followModule,\\n            createProfileParams.followModuleInitData,\\n            msg.sender // Sender accounts for any initialization requirements (e.g. pay fees, stake asset, etc.).\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets the follow module for a given profile.\\n     *\\n     * @param profileId The profile ID to set the follow module for.\\n     * @param followModule The follow module to set for the given profile, if any.\\n     * @param followModuleInitData The data to pass to the follow module for profile initialization.\\n     */\\n    function setFollowModule(\\n        uint256 profileId,\\n        address followModule,\\n        bytes calldata followModuleInitData,\\n        address transactionExecutor\\n    ) external {\\n        _setFollowModule(profileId, followModule, followModuleInitData, transactionExecutor);\\n    }\\n\\n    function setProfileMetadataURI(\\n        uint256 profileId,\\n        string calldata metadataURI,\\n        address transactionExecutor\\n    ) external {\\n        StorageLib.getProfile(profileId).metadataURI = metadataURI;\\n        emit Events.ProfileMetadataSet(profileId, metadataURI, transactionExecutor, block.timestamp);\\n    }\\n\\n    function _initFollowModule(\\n        uint256 profileId,\\n        address transactionExecutor,\\n        address followModule,\\n        bytes memory followModuleInitData\\n    ) private returns (bytes memory) {\\n        MODULE_REGISTRY().verifyModule(followModule, uint256(IModuleRegistry.ModuleType.FOLLOW_MODULE));\\n        return IFollowModule(followModule).initializeFollowModule(profileId, transactionExecutor, followModuleInitData);\\n    }\\n\\n    function setBlockStatus(\\n        uint256 byProfileId,\\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\\n        bool[] calldata blockStatus,\\n        address transactionExecutor\\n    ) external {\\n        if (idsOfProfilesToSetBlockStatus.length != blockStatus.length) {\\n            revert Errors.ArrayMismatch();\\n        }\\n        address followNFT = StorageLib.getProfile(byProfileId).followNFT;\\n        uint256 i;\\n        uint256 idOfProfileToSetBlockStatus;\\n        bool blockedStatus;\\n        mapping(uint256 => bool) storage _blockedStatus = StorageLib.blockedStatus(byProfileId);\\n        while (i < idsOfProfilesToSetBlockStatus.length) {\\n            idOfProfileToSetBlockStatus = idsOfProfilesToSetBlockStatus[i];\\n            ValidationLib.validateProfileExists(idOfProfileToSetBlockStatus);\\n            if (byProfileId == idOfProfileToSetBlockStatus) {\\n                revert Errors.SelfBlock();\\n            }\\n            blockedStatus = blockStatus[i];\\n            if (followNFT != address(0) && blockedStatus) {\\n                bool hasUnfollowed = IFollowNFT(followNFT).processBlock(idOfProfileToSetBlockStatus);\\n                if (hasUnfollowed) {\\n                    emit Events.Unfollowed(\\n                        idOfProfileToSetBlockStatus,\\n                        byProfileId,\\n                        transactionExecutor,\\n                        block.timestamp\\n                    );\\n                }\\n            }\\n            _blockedStatus[idOfProfileToSetBlockStatus] = blockedStatus;\\n            if (blockedStatus) {\\n                emit Events.Blocked(byProfileId, idOfProfileToSetBlockStatus, transactionExecutor, block.timestamp);\\n            } else {\\n                emit Events.Unblocked(byProfileId, idOfProfileToSetBlockStatus, transactionExecutor, block.timestamp);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function switchToNewFreshDelegatedExecutorsConfig(uint256 profileId) external {\\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig({\\n            delegatorProfileId: profileId\\n        });\\n        _changeDelegatedExecutorsConfig({\\n            _delegatedExecutorsConfig: _delegatedExecutorsConfig,\\n            delegatorProfileId: profileId,\\n            delegatedExecutors: new address[](0),\\n            approvals: new bool[](0),\\n            configNumber: _delegatedExecutorsConfig.maxConfigNumberSet + 1,\\n            switchToGivenConfig: true\\n        });\\n    }\\n\\n    function changeDelegatedExecutorsConfig(\\n        uint256 delegatorProfileId,\\n        address[] calldata delegatedExecutors,\\n        bool[] calldata approvals\\n    ) external {\\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig(\\n            delegatorProfileId\\n        );\\n        _changeDelegatedExecutorsConfig(\\n            _delegatedExecutorsConfig,\\n            delegatorProfileId,\\n            delegatedExecutors,\\n            approvals,\\n            _delegatedExecutorsConfig.configNumber,\\n            false\\n        );\\n    }\\n\\n    function changeGivenDelegatedExecutorsConfig(\\n        uint256 delegatorProfileId,\\n        address[] calldata delegatedExecutors,\\n        bool[] calldata approvals,\\n        uint64 configNumber,\\n        bool switchToGivenConfig\\n    ) external {\\n        _changeDelegatedExecutorsConfig(\\n            StorageLib.getDelegatedExecutorsConfig(delegatorProfileId),\\n            delegatorProfileId,\\n            delegatedExecutors,\\n            approvals,\\n            configNumber,\\n            switchToGivenConfig\\n        );\\n    }\\n\\n    function isExecutorApproved(uint256 delegatorProfileId, address delegatedExecutor) external view returns (bool) {\\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig = StorageLib.getDelegatedExecutorsConfig(\\n            delegatorProfileId\\n        );\\n        return _delegatedExecutorsConfig.isApproved[_delegatedExecutorsConfig.configNumber][delegatedExecutor];\\n    }\\n\\n    function _changeDelegatedExecutorsConfig(\\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig,\\n        uint256 delegatorProfileId,\\n        address[] memory delegatedExecutors,\\n        bool[] memory approvals,\\n        uint64 configNumber,\\n        bool switchToGivenConfig\\n    ) private {\\n        if (delegatedExecutors.length != approvals.length) {\\n            revert Errors.ArrayMismatch();\\n        }\\n        bool configSwitched = _prepareStorageToApplyChangesUnderGivenConfig(\\n            _delegatedExecutorsConfig,\\n            configNumber,\\n            switchToGivenConfig\\n        );\\n        uint256 i;\\n        while (i < delegatedExecutors.length) {\\n            _delegatedExecutorsConfig.isApproved[configNumber][delegatedExecutors[i]] = approvals[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        emit Events.DelegatedExecutorsConfigChanged(\\n            delegatorProfileId,\\n            configNumber,\\n            delegatedExecutors,\\n            approvals,\\n            block.timestamp\\n        );\\n        if (configSwitched) {\\n            emit Events.DelegatedExecutorsConfigApplied(delegatorProfileId, configNumber, block.timestamp);\\n        }\\n    }\\n\\n    function _prepareStorageToApplyChangesUnderGivenConfig(\\n        Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig,\\n        uint64 configNumber,\\n        bool switchToGivenConfig\\n    ) private returns (bool) {\\n        uint64 nextAvailableConfigNumber = _delegatedExecutorsConfig.maxConfigNumberSet + 1;\\n        if (configNumber > nextAvailableConfigNumber) {\\n            revert Errors.InvalidParameter();\\n        }\\n        bool configSwitched;\\n        if (configNumber == nextAvailableConfigNumber) {\\n            // The next configuration available is being changed, it must be marked.\\n            // Otherwise, on a profile transfer, the next owner can inherit a used/dirty configuration.\\n            _delegatedExecutorsConfig.maxConfigNumberSet = nextAvailableConfigNumber;\\n            configSwitched = switchToGivenConfig;\\n            if (configSwitched) {\\n                // The configuration is being switched, previous and current configuration numbers must be updated.\\n                _delegatedExecutorsConfig.prevConfigNumber = _delegatedExecutorsConfig.configNumber;\\n                _delegatedExecutorsConfig.configNumber = nextAvailableConfigNumber;\\n            }\\n        } else {\\n            // The configuration corresponding to the given number is not a fresh/clean one.\\n            uint64 currentConfigNumber = _delegatedExecutorsConfig.configNumber;\\n            // If the given configuration matches the one that is already in use, we keep `configSwitched` as `false`.\\n            if (configNumber != currentConfigNumber) {\\n                configSwitched = switchToGivenConfig;\\n            }\\n            if (configSwitched) {\\n                // The configuration is being switched, previous and current configuration numbers must be updated.\\n                _delegatedExecutorsConfig.prevConfigNumber = currentConfigNumber;\\n                _delegatedExecutorsConfig.configNumber = configNumber;\\n            }\\n        }\\n        return configSwitched;\\n    }\\n\\n    function _setFollowModule(\\n        uint256 profileId,\\n        address followModule,\\n        bytes calldata followModuleInitData,\\n        address transactionExecutor\\n    ) private {\\n        StorageLib.getProfile(profileId).followModule = followModule;\\n        bytes memory followModuleReturnData;\\n        if (followModule != address(0)) {\\n            followModuleReturnData = _initFollowModule(\\n                profileId,\\n                transactionExecutor,\\n                followModule,\\n                followModuleInitData\\n            );\\n        }\\n        emit Events.FollowModuleSet(\\n            profileId,\\n            followModule,\\n            followModuleInitData,\\n            followModuleReturnData,\\n            transactionExecutor,\\n            block.timestamp\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/PublicationLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\nimport {Events} from 'contracts/libraries/constants/Events.sol';\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\nimport {IReferenceModule} from 'contracts/interfaces/IReferenceModule.sol';\\nimport {ILegacyReferenceModule} from 'contracts/interfaces/ILegacyReferenceModule.sol';\\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\\nimport {IPublicationActionModule} from 'contracts/interfaces/IPublicationActionModule.sol';\\nimport {IModuleRegistry} from 'contracts/interfaces/IModuleRegistry.sol';\\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\\n\\nlibrary PublicationLib {\\n    function MODULE_REGISTRY() internal view returns (IModuleRegistry) {\\n        return IModuleRegistry(ILensHub(address(this)).getModuleRegistry());\\n    }\\n\\n    /**\\n     * @notice Publishes a post to a given profile.\\n     *\\n     * @param postParams The PostParams struct.\\n     *\\n     * @return uint256 The created publication's pubId.\\n     */\\n    function post(Types.PostParams calldata postParams, address transactionExecutor) external returns (uint256) {\\n        uint256 pubIdAssigned = ++StorageLib.getProfile(postParams.profileId).pubCount;\\n\\n        Types.Publication storage _post = StorageLib.getPublication(postParams.profileId, pubIdAssigned);\\n        _post.contentURI = postParams.contentURI;\\n        _post.pubType = Types.PublicationType.Post;\\n\\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\\n            InitReferenceModuleParams(\\n                postParams.profileId,\\n                transactionExecutor,\\n                pubIdAssigned,\\n                postParams.referenceModule,\\n                postParams.referenceModuleInitData\\n            )\\n        );\\n\\n        bytes[] memory actionModulesReturnDatas = _initPubActionModules(\\n            InitActionModuleParams(\\n                postParams.profileId,\\n                transactionExecutor,\\n                pubIdAssigned,\\n                postParams.actionModules,\\n                postParams.actionModulesInitDatas\\n            )\\n        );\\n\\n        emit Events.PostCreated(\\n            postParams,\\n            pubIdAssigned,\\n            actionModulesReturnDatas,\\n            referenceModuleReturnData,\\n            transactionExecutor,\\n            block.timestamp\\n        );\\n\\n        return pubIdAssigned;\\n    }\\n\\n    /**\\n     * @notice Publishes a comment to a given profile via signature.\\n     *\\n     * @param commentParams the CommentParams struct.\\n     *\\n     * @return uint256 The created publication's pubId.\\n     */\\n    function comment(\\n        Types.CommentParams calldata commentParams,\\n        address transactionExecutor\\n    ) external returns (uint256) {\\n        (\\n            uint256 pubIdAssigned,\\n            bytes[] memory actionModulesInitReturnDatas,\\n            bytes memory referenceModuleInitReturnData,\\n            Types.PublicationType[] memory referrerPubTypes\\n        ) = _createReferencePublication(\\n                _asReferencePubParams(commentParams),\\n                transactionExecutor,\\n                Types.PublicationType.Comment\\n            );\\n\\n        bytes memory referenceModuleReturnData = _processCommentIfNeeded(\\n            commentParams,\\n            pubIdAssigned,\\n            transactionExecutor,\\n            referrerPubTypes\\n        );\\n\\n        emit Events.CommentCreated(\\n            commentParams,\\n            pubIdAssigned,\\n            referenceModuleReturnData,\\n            actionModulesInitReturnDatas,\\n            referenceModuleInitReturnData,\\n            transactionExecutor,\\n            block.timestamp\\n        );\\n\\n        return pubIdAssigned;\\n    }\\n\\n    /**\\n     * @notice Publishes a mirror to a given profile.\\n     *\\n     * @param mirrorParams the MirrorParams struct.\\n     *\\n     * @return uint256 The created publication's pubId.\\n     */\\n    function mirror(Types.MirrorParams calldata mirrorParams, address transactionExecutor) external returns (uint256) {\\n        ValidationLib.validatePointedPub(mirrorParams.pointedProfileId, mirrorParams.pointedPubId);\\n        ValidationLib.validateNotBlocked({profile: mirrorParams.profileId, byProfile: mirrorParams.pointedProfileId});\\n\\n        Types.PublicationType[] memory referrerPubTypes = ValidationLib.validateReferrersAndGetReferrersPubTypes(\\n            mirrorParams.referrerProfileIds,\\n            mirrorParams.referrerPubIds,\\n            mirrorParams.pointedProfileId,\\n            mirrorParams.pointedPubId\\n        );\\n\\n        uint256 pubIdAssigned = ++StorageLib.getProfile(mirrorParams.profileId).pubCount;\\n\\n        Types.Publication storage _publication = StorageLib.getPublication(mirrorParams.profileId, pubIdAssigned);\\n        _publication.pointedProfileId = mirrorParams.pointedProfileId;\\n        _publication.pointedPubId = mirrorParams.pointedPubId;\\n        _publication.contentURI = mirrorParams.metadataURI;\\n        _publication.pubType = Types.PublicationType.Mirror;\\n        _fillRootOfPublicationInStorage(_publication, mirrorParams.pointedProfileId, mirrorParams.pointedPubId);\\n\\n        bytes memory referenceModuleReturnData = _processMirrorIfNeeded(\\n            mirrorParams,\\n            pubIdAssigned,\\n            transactionExecutor,\\n            referrerPubTypes\\n        );\\n\\n        emit Events.MirrorCreated(\\n            mirrorParams,\\n            pubIdAssigned,\\n            referenceModuleReturnData,\\n            transactionExecutor,\\n            block.timestamp\\n        );\\n\\n        return pubIdAssigned;\\n    }\\n\\n    /**\\n     * @notice Publishes a quote publication to a given profile via signature.\\n     *\\n     * @param quoteParams the QuoteParams struct.\\n     *\\n     * @return uint256 The created publication's pubId.\\n     */\\n    function quote(Types.QuoteParams calldata quoteParams, address transactionExecutor) external returns (uint256) {\\n        (\\n            uint256 pubIdAssigned,\\n            bytes[] memory actionModulesReturnDatas,\\n            bytes memory referenceModuleInitReturnData,\\n            Types.PublicationType[] memory referrerPubTypes\\n        ) = _createReferencePublication(\\n                _asReferencePubParams(quoteParams),\\n                transactionExecutor,\\n                Types.PublicationType.Quote\\n            );\\n\\n        bytes memory referenceModuleReturnData = _processQuoteIfNeeded(\\n            quoteParams,\\n            pubIdAssigned,\\n            transactionExecutor,\\n            referrerPubTypes\\n        );\\n\\n        emit Events.QuoteCreated(\\n            quoteParams,\\n            pubIdAssigned,\\n            referenceModuleReturnData,\\n            actionModulesReturnDatas,\\n            referenceModuleInitReturnData,\\n            transactionExecutor,\\n            block.timestamp\\n        );\\n\\n        return pubIdAssigned;\\n    }\\n\\n    function getPublicationType(uint256 profileId, uint256 pubId) internal view returns (Types.PublicationType) {\\n        Types.Publication storage _publication = StorageLib.getPublication(profileId, pubId);\\n        Types.PublicationType pubType = _publication.pubType;\\n        if (uint8(pubType) == 0) {\\n            // Legacy V1: If the publication type is 0, we check using the legacy rules.\\n            if (_publication.pointedProfileId != 0) {\\n                // It is pointing to a publication, so it can be either a comment or a mirror, depending on if it has a\\n                // collect module or not.\\n                if (_publication.__DEPRECATED__collectModule == address(0)) {\\n                    return Types.PublicationType.Mirror;\\n                } else {\\n                    return Types.PublicationType.Comment;\\n                }\\n            } else if (_publication.__DEPRECATED__collectModule != address(0)) {\\n                return Types.PublicationType.Post;\\n            }\\n        }\\n        return pubType;\\n    }\\n\\n    function getContentURI(uint256 profileId, uint256 pubId) external view returns (string memory) {\\n        Types.Publication storage _publication = StorageLib.getPublication(profileId, pubId);\\n        Types.PublicationType pubType = _publication.pubType;\\n        if (pubType == Types.PublicationType.Nonexistent) {\\n            pubType = getPublicationType(profileId, pubId);\\n        }\\n        if (pubType == Types.PublicationType.Mirror) {\\n            return StorageLib.getPublication(_publication.pointedProfileId, _publication.pointedPubId).contentURI;\\n        } else {\\n            return StorageLib.getPublication(profileId, pubId).contentURI;\\n        }\\n    }\\n\\n    function _asReferencePubParams(\\n        Types.QuoteParams calldata quoteParams\\n    ) private pure returns (Types.ReferencePubParams calldata referencePubParams) {\\n        // We use assembly to cast the types keeping the params in calldata, as they match the fields.\\n        assembly {\\n            referencePubParams := quoteParams\\n        }\\n    }\\n\\n    function _asReferencePubParams(\\n        Types.CommentParams calldata commentParams\\n    ) private pure returns (Types.ReferencePubParams calldata referencePubParams) {\\n        // We use assembly to cast the types keeping the params in calldata, as they match the fields.\\n        assembly {\\n            referencePubParams := commentParams\\n        }\\n    }\\n\\n    function _createReferencePublication(\\n        Types.ReferencePubParams calldata referencePubParams,\\n        address transactionExecutor,\\n        Types.PublicationType referencePubType\\n    ) private returns (uint256, bytes[] memory, bytes memory, Types.PublicationType[] memory) {\\n        ValidationLib.validatePointedPub(referencePubParams.pointedProfileId, referencePubParams.pointedPubId);\\n        ValidationLib.validateNotBlocked({\\n            profile: referencePubParams.profileId,\\n            byProfile: referencePubParams.pointedProfileId\\n        });\\n\\n        Types.PublicationType[] memory referrerPubTypes = ValidationLib.validateReferrersAndGetReferrersPubTypes(\\n            referencePubParams.referrerProfileIds,\\n            referencePubParams.referrerPubIds,\\n            referencePubParams.pointedProfileId,\\n            referencePubParams.pointedPubId\\n        );\\n\\n        (uint256 pubIdAssigned, uint256 rootProfileId) = _fillReferencePublicationStorage(\\n            referencePubParams,\\n            referencePubType\\n        );\\n\\n        if (rootProfileId != referencePubParams.pointedProfileId) {\\n            // We check the block state between the profile commenting/quoting and the root publication's author.\\n            ValidationLib.validateNotBlocked({profile: referencePubParams.profileId, byProfile: rootProfileId});\\n        }\\n\\n        bytes memory referenceModuleReturnData = _initPubReferenceModule(\\n            InitReferenceModuleParams(\\n                referencePubParams.profileId,\\n                transactionExecutor,\\n                pubIdAssigned,\\n                referencePubParams.referenceModule,\\n                referencePubParams.referenceModuleInitData\\n            )\\n        );\\n\\n        bytes[] memory actionModulesReturnDatas = _initPubActionModules(\\n            InitActionModuleParams(\\n                referencePubParams.profileId,\\n                transactionExecutor,\\n                pubIdAssigned,\\n                referencePubParams.actionModules,\\n                referencePubParams.actionModulesInitDatas\\n            )\\n        );\\n\\n        return (pubIdAssigned, actionModulesReturnDatas, referenceModuleReturnData, referrerPubTypes);\\n    }\\n\\n    function _fillReferencePublicationStorage(\\n        Types.ReferencePubParams calldata referencePubParams,\\n        Types.PublicationType referencePubType\\n    ) private returns (uint256, uint256) {\\n        uint256 pubIdAssigned = ++StorageLib.getProfile(referencePubParams.profileId).pubCount;\\n        Types.Publication storage _referencePub;\\n        _referencePub = StorageLib.getPublication(referencePubParams.profileId, pubIdAssigned);\\n        _referencePub.pointedProfileId = referencePubParams.pointedProfileId;\\n        _referencePub.pointedPubId = referencePubParams.pointedPubId;\\n        _referencePub.contentURI = referencePubParams.contentURI;\\n        _referencePub.pubType = referencePubType;\\n        uint256 rootProfileId = _fillRootOfPublicationInStorage(\\n            _referencePub,\\n            referencePubParams.pointedProfileId,\\n            referencePubParams.pointedPubId\\n        );\\n        return (pubIdAssigned, rootProfileId);\\n    }\\n\\n    function _fillRootOfPublicationInStorage(\\n        Types.Publication storage _publication,\\n        uint256 pointedProfileId,\\n        uint256 pointedPubId\\n    ) internal returns (uint256) {\\n        Types.Publication storage _pubPointed = StorageLib.getPublication(pointedProfileId, pointedPubId);\\n        Types.PublicationType pubPointedType = _pubPointed.pubType;\\n        if (pubPointedType == Types.PublicationType.Post) {\\n            // The publication pointed is a Lens V2 post.\\n            _publication.rootPubId = pointedPubId;\\n            return _publication.rootProfileId = pointedProfileId;\\n        } else if (pubPointedType == Types.PublicationType.Comment || pubPointedType == Types.PublicationType.Quote) {\\n            // The publication pointed is either a Lens V2 comment or a Lens V2 quote.\\n            // Note that even when the publication pointed is a V2 one, it will lack `rootProfileId` and `rootPubId` if\\n            // there is a Lens V1 Legacy publication in the thread of interactions (including the root post itself).\\n            _publication.rootPubId = _pubPointed.rootPubId;\\n            return _publication.rootProfileId = _pubPointed.rootProfileId;\\n        }\\n        // Otherwise the root is not filled, as the pointed publication is a Lens V1 Legacy publication, which does not\\n        // support Lens V2 referral system.\\n        return 0;\\n    }\\n\\n    function _processCommentIfNeeded(\\n        Types.CommentParams calldata commentParams,\\n        uint256 pubIdAssigned,\\n        address transactionExecutor,\\n        Types.PublicationType[] memory referrerPubTypes\\n    ) private returns (bytes memory) {\\n        address refModule = StorageLib\\n            .getPublication(commentParams.pointedProfileId, commentParams.pointedPubId)\\n            .referenceModule;\\n        if (refModule != address(0)) {\\n            try\\n                IReferenceModule(refModule).processComment(\\n                    Types.ProcessCommentParams({\\n                        profileId: commentParams.profileId,\\n                        pubId: pubIdAssigned,\\n                        transactionExecutor: transactionExecutor,\\n                        pointedProfileId: commentParams.pointedProfileId,\\n                        pointedPubId: commentParams.pointedPubId,\\n                        referrerProfileIds: commentParams.referrerProfileIds,\\n                        referrerPubIds: commentParams.referrerPubIds,\\n                        referrerPubTypes: referrerPubTypes,\\n                        data: commentParams.referenceModuleData\\n                    })\\n                )\\n            returns (bytes memory returnData) {\\n                return (returnData);\\n            } catch (bytes memory err) {\\n                assembly {\\n                    /// Equivalent to reverting with the returned error selector if\\n                    /// the length is not zero.\\n                    let length := mload(err)\\n                    if iszero(iszero(length)) {\\n                        revert(add(err, 32), length)\\n                    }\\n                }\\n                if (commentParams.referrerProfileIds.length > 0) {\\n                    // Deprecated reference modules don't support referrers.\\n                    revert Errors.InvalidReferrer();\\n                }\\n                ILegacyReferenceModule(refModule).processComment(\\n                    commentParams.profileId,\\n                    commentParams.pointedProfileId,\\n                    commentParams.pointedPubId,\\n                    commentParams.referenceModuleData\\n                );\\n            }\\n        } else {\\n            if (commentParams.referrerProfileIds.length > 0) {\\n                // We don't allow referrers if the reference module is not set.\\n                revert Errors.InvalidReferrer();\\n            }\\n        }\\n        return '';\\n    }\\n\\n    function _processQuoteIfNeeded(\\n        Types.QuoteParams calldata quoteParams,\\n        uint256 pubIdAssigned,\\n        address transactionExecutor,\\n        Types.PublicationType[] memory referrerPubTypes\\n    ) private returns (bytes memory) {\\n        address refModule = StorageLib\\n            .getPublication(quoteParams.pointedProfileId, quoteParams.pointedPubId)\\n            .referenceModule;\\n        if (refModule != address(0)) {\\n            try\\n                IReferenceModule(refModule).processQuote(\\n                    Types.ProcessQuoteParams({\\n                        profileId: quoteParams.profileId,\\n                        pubId: pubIdAssigned,\\n                        transactionExecutor: transactionExecutor,\\n                        pointedProfileId: quoteParams.pointedProfileId,\\n                        pointedPubId: quoteParams.pointedPubId,\\n                        referrerProfileIds: quoteParams.referrerProfileIds,\\n                        referrerPubIds: quoteParams.referrerPubIds,\\n                        referrerPubTypes: referrerPubTypes,\\n                        data: quoteParams.referenceModuleData\\n                    })\\n                )\\n            returns (bytes memory returnData) {\\n                return (returnData);\\n            } catch (bytes memory err) {\\n                assembly {\\n                    /// Equivalent to reverting with the returned error selector if\\n                    /// the length is not zero.\\n                    let length := mload(err)\\n                    if iszero(iszero(length)) {\\n                        revert(add(err, 32), length)\\n                    }\\n                }\\n                if (quoteParams.referrerProfileIds.length > 0) {\\n                    // Deprecated reference modules don't support referrers.\\n                    revert Errors.InvalidReferrer();\\n                }\\n                ILegacyReferenceModule(refModule).processComment(\\n                    quoteParams.profileId,\\n                    quoteParams.pointedProfileId,\\n                    quoteParams.pointedPubId,\\n                    quoteParams.referenceModuleData\\n                );\\n            }\\n        } else {\\n            if (quoteParams.referrerProfileIds.length > 0) {\\n                // We don't allow referrers if the reference module is not set.\\n                revert Errors.InvalidReferrer();\\n            }\\n        }\\n        return '';\\n    }\\n\\n    function _processMirrorIfNeeded(\\n        Types.MirrorParams calldata mirrorParams,\\n        uint256 pubIdAssigned,\\n        address transactionExecutor,\\n        Types.PublicationType[] memory referrerPubTypes\\n    ) private returns (bytes memory) {\\n        address refModule = StorageLib\\n            .getPublication(mirrorParams.pointedProfileId, mirrorParams.pointedPubId)\\n            .referenceModule;\\n        if (refModule != address(0)) {\\n            try\\n                IReferenceModule(refModule).processMirror(\\n                    Types.ProcessMirrorParams({\\n                        profileId: mirrorParams.profileId,\\n                        pubId: pubIdAssigned,\\n                        transactionExecutor: transactionExecutor,\\n                        pointedProfileId: mirrorParams.pointedProfileId,\\n                        pointedPubId: mirrorParams.pointedPubId,\\n                        referrerProfileIds: mirrorParams.referrerProfileIds,\\n                        referrerPubIds: mirrorParams.referrerPubIds,\\n                        referrerPubTypes: referrerPubTypes,\\n                        data: mirrorParams.referenceModuleData\\n                    })\\n                )\\n            returns (bytes memory returnData) {\\n                return (returnData);\\n            } catch (bytes memory err) {\\n                assembly {\\n                    /// Equivalent to reverting with the returned error selector if\\n                    /// the length is not zero.\\n                    let length := mload(err)\\n                    if iszero(iszero(length)) {\\n                        revert(add(err, 32), length)\\n                    }\\n                }\\n                if (mirrorParams.referrerProfileIds.length > 0) {\\n                    // Deprecated reference modules don't support referrers.\\n                    revert Errors.InvalidReferrer();\\n                }\\n                ILegacyReferenceModule(refModule).processMirror(\\n                    mirrorParams.profileId,\\n                    mirrorParams.pointedProfileId,\\n                    mirrorParams.pointedPubId,\\n                    mirrorParams.referenceModuleData\\n                );\\n            }\\n        } else {\\n            if (mirrorParams.referrerProfileIds.length > 0) {\\n                // We don't allow referrers if the reference module is not set.\\n                revert Errors.InvalidReferrer();\\n            }\\n        }\\n        return '';\\n    }\\n\\n    // Needed to avoid 'stack too deep' issue.\\n    struct InitActionModuleParams {\\n        uint256 profileId;\\n        address transactionExecutor;\\n        uint256 pubId;\\n        address[] actionModules;\\n        bytes[] actionModulesInitDatas;\\n    }\\n\\n    function _initPubActionModules(InitActionModuleParams memory params) private returns (bytes[] memory) {\\n        if (params.actionModules.length != params.actionModulesInitDatas.length) {\\n            revert Errors.ArrayMismatch();\\n        }\\n\\n        bytes[] memory actionModuleInitResults = new bytes[](params.actionModules.length);\\n\\n        uint256 i;\\n        while (i < params.actionModules.length) {\\n            MODULE_REGISTRY().verifyModule(\\n                params.actionModules[i],\\n                uint256(IModuleRegistry.ModuleType.PUBLICATION_ACTION_MODULE)\\n            );\\n\\n            StorageLib.getPublication(params.profileId, params.pubId).actionModuleEnabled[\\n                params.actionModules[i]\\n            ] = true;\\n\\n            actionModuleInitResults[i] = IPublicationActionModule(params.actionModules[i]).initializePublicationAction(\\n                params.profileId,\\n                params.pubId,\\n                params.transactionExecutor,\\n                params.actionModulesInitDatas[i]\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return actionModuleInitResults;\\n    }\\n\\n    // Needed to avoid 'stack too deep' issue.\\n    struct InitReferenceModuleParams {\\n        uint256 profileId;\\n        address transactionExecutor;\\n        uint256 pubId;\\n        address referenceModule;\\n        bytes referenceModuleInitData;\\n    }\\n\\n    function _initPubReferenceModule(InitReferenceModuleParams memory params) private returns (bytes memory) {\\n        if (params.referenceModule == address(0)) {\\n            return new bytes(0);\\n        }\\n        MODULE_REGISTRY().verifyModule(params.referenceModule, uint256(IModuleRegistry.ModuleType.REFERENCE_MODULE));\\n        StorageLib.getPublication(params.profileId, params.pubId).referenceModule = params.referenceModule;\\n        return\\n            IReferenceModule(params.referenceModule).initializeReferenceModule(\\n                params.profileId,\\n                params.pubId,\\n                params.transactionExecutor,\\n                params.referenceModuleInitData\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/StorageLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\n\\nlibrary StorageLib {\\n    // uint256 constant NAME_SLOT = 0;\\n    // uint256 constant SYMBOL_SLOT = 1;\\n    uint256 constant TOKEN_DATA_MAPPING_SLOT = 2;\\n    // uint256 constant BALANCES_SLOT = 3;\\n    // uint256 constant TOKEN_APPROVAL_MAPPING_SLOT = 4;\\n    // uint256 constant OPERATOR_APPROVAL_MAPPING_SLOT = 5;\\n    // Slot 6 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `ownedTokens`.\\n    // Slot 7 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `ownedTokensIndex`.\\n    // uint256 constant TOTAL_SUPPLY_SLOT = 8;\\n    // Slot 9 is deprecated in Lens V2. In V1 it was used for ERC-721 Enumerable's `allTokensIndex`.\\n    uint256 constant SIG_NONCES_MAPPING_SLOT = 10;\\n    uint256 constant LAST_INITIALIZED_REVISION_SLOT = 11; // VersionedInitializable's `lastInitializedRevision` field.\\n    uint256 constant PROTOCOL_STATE_SLOT = 12;\\n    uint256 constant PROFILE_CREATOR_WHITELIST_MAPPING_SLOT = 13;\\n    // Slot 14 is deprecated in Lens V2. In V1 it was used for the follow module address whitelist.\\n    // Slot 15 is deprecated in Lens V2. In V1 it was used for the collect module address whitelist.\\n    // Slot 16 is deprecated in Lens V2. In V1 it was used for the reference module address whitelist.\\n    // Slot 17 is deprecated in Lens V2. In V1 it was used for the dispatcher address by profile ID.\\n    uint256 constant PROFILE_ID_BY_HANDLE_HASH_MAPPING_SLOT = 18; // Deprecated slot, but still needed for V2 migration.\\n    uint256 constant PROFILES_MAPPING_SLOT = 19;\\n    uint256 constant PUBLICATIONS_MAPPING_SLOT = 20;\\n    // Slot 21 is deprecated in Lens V2. In V1 it was used for the default profile ID by address.\\n    uint256 constant PROFILE_COUNTER_SLOT = 22;\\n    uint256 constant GOVERNANCE_SLOT = 23;\\n    uint256 constant EMERGENCY_ADMIN_SLOT = 24;\\n    //////////////////////////////////\\n    ///  Introduced in Lens V1.3:  ///\\n    //////////////////////////////////\\n    uint256 constant TOKEN_GUARDIAN_DISABLING_TIMESTAMP_MAPPING_SLOT = 25;\\n    //////////////////////////////////\\n    ///   Introduced in Lens V2:   ///\\n    //////////////////////////////////\\n    uint256 constant DELEGATED_EXECUTOR_CONFIG_MAPPING_SLOT = 26;\\n    uint256 constant BLOCKED_STATUS_MAPPING_SLOT = 27;\\n    uint256 constant PROFILE_ROYALTIES_BPS_SLOT = 28;\\n    uint256 constant MIGRATION_ADMINS_WHITELISTED_MAPPING_SLOT = 29;\\n    uint256 constant TREASURY_DATA_SLOT = 30;\\n\\n    function getPublication(\\n        uint256 profileId,\\n        uint256 pubId\\n    ) internal pure returns (Types.Publication storage _publication) {\\n        assembly {\\n            mstore(0, profileId)\\n            mstore(32, PUBLICATIONS_MAPPING_SLOT)\\n            mstore(32, keccak256(0, 64))\\n            mstore(0, pubId)\\n            _publication.slot := keccak256(0, 64)\\n        }\\n    }\\n\\n    function getPublicationMemory(\\n        uint256 profileId,\\n        uint256 pubId\\n    ) internal pure returns (Types.PublicationMemory memory) {\\n        Types.PublicationMemory storage _publicationStorage;\\n        assembly {\\n            mstore(0, profileId)\\n            mstore(32, PUBLICATIONS_MAPPING_SLOT)\\n            mstore(32, keccak256(0, 64))\\n            mstore(0, pubId)\\n            _publicationStorage.slot := keccak256(0, 64)\\n        }\\n\\n        Types.PublicationMemory memory _publicationMemory;\\n        _publicationMemory = _publicationStorage;\\n\\n        return _publicationMemory;\\n    }\\n\\n    function getProfile(uint256 profileId) internal pure returns (Types.Profile storage _profiles) {\\n        assembly {\\n            mstore(0, profileId)\\n            mstore(32, PROFILES_MAPPING_SLOT)\\n            _profiles.slot := keccak256(0, 64)\\n        }\\n    }\\n\\n    function getDelegatedExecutorsConfig(\\n        uint256 delegatorProfileId\\n    ) internal pure returns (Types.DelegatedExecutorsConfig storage _delegatedExecutorsConfig) {\\n        assembly {\\n            mstore(0, delegatorProfileId)\\n            mstore(32, DELEGATED_EXECUTOR_CONFIG_MAPPING_SLOT)\\n            _delegatedExecutorsConfig.slot := keccak256(0, 64)\\n        }\\n    }\\n\\n    function tokenGuardianDisablingTimestamp()\\n        internal\\n        pure\\n        returns (mapping(address => uint256) storage _tokenGuardianDisablingTimestamp)\\n    {\\n        assembly {\\n            _tokenGuardianDisablingTimestamp.slot := TOKEN_GUARDIAN_DISABLING_TIMESTAMP_MAPPING_SLOT\\n        }\\n    }\\n\\n    function getTokenData(uint256 tokenId) internal pure returns (Types.TokenData storage _tokenData) {\\n        assembly {\\n            mstore(0, tokenId)\\n            mstore(32, TOKEN_DATA_MAPPING_SLOT)\\n            _tokenData.slot := keccak256(0, 64)\\n        }\\n    }\\n\\n    function blockedStatus(\\n        uint256 blockerProfileId\\n    ) internal pure returns (mapping(uint256 => bool) storage _blockedStatus) {\\n        assembly {\\n            mstore(0, blockerProfileId)\\n            mstore(32, BLOCKED_STATUS_MAPPING_SLOT)\\n            _blockedStatus.slot := keccak256(0, 64)\\n        }\\n    }\\n\\n    function nonces() internal pure returns (mapping(address => uint256) storage _nonces) {\\n        assembly {\\n            _nonces.slot := SIG_NONCES_MAPPING_SLOT\\n        }\\n    }\\n\\n    function profileIdByHandleHash()\\n        internal\\n        pure\\n        returns (mapping(bytes32 => uint256) storage _profileIdByHandleHash)\\n    {\\n        assembly {\\n            _profileIdByHandleHash.slot := PROFILE_ID_BY_HANDLE_HASH_MAPPING_SLOT\\n        }\\n    }\\n\\n    function profileCreatorWhitelisted()\\n        internal\\n        pure\\n        returns (mapping(address => bool) storage _profileCreatorWhitelisted)\\n    {\\n        assembly {\\n            _profileCreatorWhitelisted.slot := PROFILE_CREATOR_WHITELIST_MAPPING_SLOT\\n        }\\n    }\\n\\n    function migrationAdminWhitelisted()\\n        internal\\n        pure\\n        returns (mapping(address => bool) storage _migrationAdminWhitelisted)\\n    {\\n        assembly {\\n            _migrationAdminWhitelisted.slot := MIGRATION_ADMINS_WHITELISTED_MAPPING_SLOT\\n        }\\n    }\\n\\n    function getGovernance() internal view returns (address _governance) {\\n        assembly {\\n            _governance := sload(GOVERNANCE_SLOT)\\n        }\\n    }\\n\\n    function setGovernance(address newGovernance) internal {\\n        assembly {\\n            sstore(GOVERNANCE_SLOT, newGovernance)\\n        }\\n    }\\n\\n    function getEmergencyAdmin() internal view returns (address _emergencyAdmin) {\\n        assembly {\\n            _emergencyAdmin := sload(EMERGENCY_ADMIN_SLOT)\\n        }\\n    }\\n\\n    function setEmergencyAdmin(address newEmergencyAdmin) internal {\\n        assembly {\\n            sstore(EMERGENCY_ADMIN_SLOT, newEmergencyAdmin)\\n        }\\n    }\\n\\n    function getState() internal view returns (Types.ProtocolState _state) {\\n        assembly {\\n            _state := sload(PROTOCOL_STATE_SLOT)\\n        }\\n    }\\n\\n    function setState(Types.ProtocolState newState) internal {\\n        assembly {\\n            sstore(PROTOCOL_STATE_SLOT, newState)\\n        }\\n    }\\n\\n    function getLastInitializedRevision() internal view returns (uint256 _lastInitializedRevision) {\\n        assembly {\\n            _lastInitializedRevision := sload(LAST_INITIALIZED_REVISION_SLOT)\\n        }\\n    }\\n\\n    function setLastInitializedRevision(uint256 newLastInitializedRevision) internal {\\n        assembly {\\n            sstore(LAST_INITIALIZED_REVISION_SLOT, newLastInitializedRevision)\\n        }\\n    }\\n\\n    function getTreasuryData() internal pure returns (Types.TreasuryData storage _treasuryData) {\\n        assembly {\\n            _treasuryData.slot := TREASURY_DATA_SLOT\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ValidationLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\\nimport {ProfileLib} from 'contracts/libraries/ProfileLib.sol';\\nimport {PublicationLib} from 'contracts/libraries/PublicationLib.sol';\\n\\n/**\\n * @title ValidationLib\\n * @author Lens Protocol\\n */\\nlibrary ValidationLib {\\n    function validatePointedPub(uint256 profileId, uint256 pubId) internal view {\\n        // If it is pointing to itself it will fail because it will return a non-existent type.\\n        Types.PublicationType pointedPubType = PublicationLib.getPublicationType(profileId, pubId);\\n        if (pointedPubType == Types.PublicationType.Nonexistent || pointedPubType == Types.PublicationType.Mirror) {\\n            revert Errors.InvalidPointedPub();\\n        }\\n    }\\n\\n    function validateAddressIsProfileOwner(address expectedProfileOwner, uint256 profileId) internal view {\\n        if (expectedProfileOwner != ProfileLib.ownerOf(profileId)) {\\n            revert Errors.NotProfileOwner();\\n        }\\n    }\\n\\n    function validateAddressIsProfileOwnerOrDelegatedExecutor(\\n        address expectedOwnerOrDelegatedExecutor,\\n        uint256 profileId\\n    ) internal view {\\n        if (expectedOwnerOrDelegatedExecutor != ProfileLib.ownerOf(profileId)) {\\n            validateAddressIsDelegatedExecutor({\\n                expectedDelegatedExecutor: expectedOwnerOrDelegatedExecutor,\\n                delegatorProfileId: profileId\\n            });\\n        }\\n    }\\n\\n    function validateAddressIsDelegatedExecutor(\\n        address expectedDelegatedExecutor,\\n        uint256 delegatorProfileId\\n    ) internal view {\\n        if (!ProfileLib.isExecutorApproved(delegatorProfileId, expectedDelegatedExecutor)) {\\n            revert Errors.ExecutorInvalid();\\n        }\\n    }\\n\\n    function validateProfileCreatorWhitelisted(address profileCreator) internal view {\\n        if (!StorageLib.profileCreatorWhitelisted()[profileCreator]) {\\n            revert Errors.NotWhitelisted();\\n        }\\n    }\\n\\n    function validateNotBlocked(uint256 profile, uint256 byProfile) internal view {\\n        // By default, block validation is bidirectional, meaning interactions are restricted in both ways.\\n        validateNotBlocked({profile: profile, byProfile: byProfile, unidirectionalCheck: false});\\n    }\\n\\n    function validateNotBlocked(uint256 profile, uint256 byProfile, bool unidirectionalCheck) internal view {\\n        if (\\n            profile != byProfile &&\\n            (StorageLib.blockedStatus(byProfile)[profile] ||\\n                (!unidirectionalCheck && StorageLib.blockedStatus(profile)[byProfile]))\\n        ) {\\n            revert Errors.Blocked();\\n        }\\n    }\\n\\n    function validateProfileExists(uint256 profileId) internal view {\\n        if (!ProfileLib.exists(profileId)) {\\n            revert Errors.TokenDoesNotExist();\\n        }\\n    }\\n\\n    function validateCallerIsGovernance() internal view {\\n        if (msg.sender != StorageLib.getGovernance()) {\\n            revert Errors.NotGovernance();\\n        }\\n    }\\n\\n    function validateReferrersAndGetReferrersPubTypes(\\n        uint256[] memory referrerProfileIds,\\n        uint256[] memory referrerPubIds,\\n        uint256 targetedProfileId,\\n        uint256 targetedPubId\\n    ) internal view returns (Types.PublicationType[] memory) {\\n        if (referrerProfileIds.length != referrerPubIds.length) {\\n            revert Errors.ArrayMismatch();\\n        }\\n        Types.PublicationType[] memory referrerPubTypes = new Types.PublicationType[](referrerProfileIds.length);\\n\\n        // We decided not to check for duplicate referrals here due to gas cost. If transient storage opcodes (EIP-1153)\\n        // get included into the VM, this could be updated to implement an efficient duplicate check mechanism.\\n        // For now, if a module strongly needs to avoid duplicate referrals, it can check for them at its own expense.\\n\\n        uint256 referrerProfileId;\\n        uint256 referrerPubId;\\n        uint256 i;\\n        while (i < referrerProfileIds.length) {\\n            referrerProfileId = referrerProfileIds[i];\\n            referrerPubId = referrerPubIds[i];\\n            referrerPubTypes[i] = _validateReferrerAndGetReferrerPubType(\\n                referrerProfileId,\\n                referrerPubId,\\n                targetedProfileId,\\n                targetedPubId\\n            );\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        return referrerPubTypes;\\n    }\\n\\n    function validateLegacyCollectReferrer(\\n        uint256 referrerProfileId,\\n        uint256 referrerPubId,\\n        uint256 publicationCollectedProfileId,\\n        uint256 publicationCollectedId\\n    ) external view {\\n        if (\\n            !ProfileLib.exists(referrerProfileId) ||\\n            PublicationLib.getPublicationType(referrerProfileId, referrerPubId) != Types.PublicationType.Mirror\\n        ) {\\n            revert Errors.InvalidReferrer();\\n        }\\n        Types.Publication storage _referrerMirror = StorageLib.getPublication(referrerProfileId, referrerPubId);\\n        // A mirror can only be a referrer of a legacy publication if it is pointing to it.\\n        if (\\n            _referrerMirror.pointedProfileId != publicationCollectedProfileId ||\\n            _referrerMirror.pointedPubId != publicationCollectedId\\n        ) {\\n            revert Errors.InvalidReferrer();\\n        }\\n    }\\n\\n    function _validateReferrerAndGetReferrerPubType(\\n        uint256 referrerProfileId,\\n        uint256 referrerPubId,\\n        uint256 targetedProfileId,\\n        uint256 targetedPubId\\n    ) private view returns (Types.PublicationType) {\\n        if (referrerPubId == 0) {\\n            // Unchecked/Unverified referral. Profile referrer, not attached to a publication.\\n            if (!ProfileLib.exists(referrerProfileId) || referrerProfileId == targetedProfileId) {\\n                revert Errors.InvalidReferrer();\\n            }\\n            return Types.PublicationType.Nonexistent;\\n        } else {\\n            // Checked/Verified referral. Publication referrer.\\n            if (\\n                // Cannot pass the targeted publication as a referrer.\\n                referrerProfileId == targetedProfileId && referrerPubId == targetedPubId\\n            ) {\\n                revert Errors.InvalidReferrer();\\n            }\\n            Types.PublicationType referrerPubType = PublicationLib.getPublicationType(referrerProfileId, referrerPubId);\\n            if (referrerPubType == Types.PublicationType.Nonexistent) {\\n                revert Errors.InvalidReferrer();\\n            }\\n            if (referrerPubType == Types.PublicationType.Post) {\\n                _validateReferrerAsPost(referrerProfileId, referrerPubId, targetedProfileId, targetedPubId);\\n            } else {\\n                _validateReferrerAsMirrorOrCommentOrQuote(\\n                    referrerProfileId,\\n                    referrerPubId,\\n                    targetedProfileId,\\n                    targetedPubId\\n                );\\n            }\\n            return referrerPubType;\\n        }\\n    }\\n\\n    function _validateReferrerAsPost(\\n        uint256 referrerProfileId,\\n        uint256 referrerPubId,\\n        uint256 targetedProfileId,\\n        uint256 targetedPubId\\n    ) private view {\\n        Types.Publication storage _targetedPub = StorageLib.getPublication(targetedProfileId, targetedPubId);\\n        // Publication targeted must have the referrer post as the root. This enables the use case of rewarding the\\n        // root publication for an action over any of its descendants.\\n        if (_targetedPub.rootProfileId != referrerProfileId || _targetedPub.rootPubId != referrerPubId) {\\n            revert Errors.InvalidReferrer();\\n        }\\n    }\\n\\n    /**\\n     * @dev Validates that the referrer publication and the interacted publication are linked.\\n     *\\n     * @param referrerProfileId The profile id of the referrer.\\n     * @param referrerPubId The publication id of the referrer.\\n     * @param targetedProfileId The ID of the profile who authored the publication being acted or referenced.\\n     * @param targetedPubId The pub ID being acted or referenced.\\n     */\\n    function _validateReferrerAsMirrorOrCommentOrQuote(\\n        uint256 referrerProfileId,\\n        uint256 referrerPubId,\\n        uint256 targetedProfileId,\\n        uint256 targetedPubId\\n    ) private view {\\n        Types.Publication storage _referrerPub = StorageLib.getPublication(referrerProfileId, referrerPubId);\\n        // A mirror/quote/comment is allowed to be a referrer of a publication if it is pointing to it...\\n        if (_referrerPub.pointedProfileId != targetedProfileId || _referrerPub.pointedPubId != targetedPubId) {\\n            // ...or if the referrer pub's root is the target pub (i.e. target pub is a Lens V2 post)...\\n            if (_referrerPub.rootProfileId != targetedProfileId || _referrerPub.rootPubId != targetedPubId) {\\n                Types.Publication storage _targetedPub = StorageLib.getPublication(targetedProfileId, targetedPubId);\\n                // ...or if the referrer pub shares the root with the target pub.\\n                if (\\n                    // Here the target pub must be a \\\"pure\\\" Lens V2 comment/quote, which means there is no\\n                    // Lens V1 Legacy comment or post on its tree of interactions, and its root pub is filled.\\n                    // Otherwise, two Lens V2 \\\"non-pure\\\" publications could be passed as a referrer to each other,\\n                    // even without having any interaction in common, as they would share the root as zero.\\n                    _referrerPub.rootPubId == 0 ||\\n                    // The referrer publication and the target publication must share the same root.\\n                    _referrerPub.rootProfileId != _targetedPub.rootProfileId ||\\n                    _referrerPub.rootPubId != _targetedPub.rootPubId\\n                ) {\\n                    revert Errors.InvalidReferrer();\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/constants/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nlibrary Errors {\\n    error CannotInitImplementation();\\n    error Initialized();\\n    error SignatureExpired();\\n    error SignatureInvalid();\\n    error InvalidOwner();\\n    error NotOwnerOrApproved();\\n    error NotHub();\\n    error TokenDoesNotExist();\\n    error NotGovernance();\\n    error NotGovernanceOrEmergencyAdmin();\\n    error EmergencyAdminCanOnlyPauseFurther();\\n    error NotProfileOwner();\\n    error PublicationDoesNotExist();\\n    error CallerNotFollowNFT();\\n    error CallerNotCollectNFT(); // Legacy\\n    error ArrayMismatch();\\n    error NotWhitelisted();\\n    error NotRegistered();\\n    error InvalidParameter();\\n    error ExecutorInvalid();\\n    error Blocked();\\n    error SelfBlock();\\n    error NotFollowing();\\n    error SelfFollow();\\n    error InvalidReferrer();\\n    error InvalidPointedPub();\\n    error NonERC721ReceiverImplementer();\\n    error AlreadyEnabled();\\n\\n    // Module Errors\\n    error InitParamsInvalid();\\n    error ActionNotAllowed();\\n\\n    error CollectNotAllowed(); // Used in LegacyCollectLib (pending deprecation)\\n\\n    // MultiState Errors\\n    error Paused();\\n    error PublishingPaused();\\n\\n    // Profile Guardian Errors\\n    error GuardianEnabled();\\n    error NotEOA();\\n    error DisablingAlreadyTriggered();\\n\\n    // Migration Errors\\n    error NotMigrationAdmin();\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/constants/Events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\n\\nlibrary Events {\\n    /**\\n     * @dev Emitted when the NFT contract's name and symbol are set at initialization.\\n     *\\n     * @param name The NFT name set.\\n     * @param symbol The NFT symbol set.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event BaseInitialized(string name, string symbol, uint256 timestamp);\\n\\n    /**\\n     * @dev Emitted when the hub state is set.\\n     *\\n     * @param caller The caller who set the state.\\n     * @param prevState The previous protocol state, an enum of either `Paused`, `PublishingPaused` or `Unpaused`.\\n     * @param newState The newly set state, an enum of either `Paused`, `PublishingPaused` or `Unpaused`.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event StateSet(\\n        address indexed caller,\\n        Types.ProtocolState indexed prevState,\\n        Types.ProtocolState indexed newState,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when the governance address is changed. We emit the caller even though it should be the previous\\n     * governance address, as we cannot guarantee this will always be the case due to upgradeability.\\n     *\\n     * @param caller The caller who set the governance address.\\n     * @param prevGovernance The previous governance address.\\n     * @param newGovernance The new governance address set.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event GovernanceSet(\\n        address indexed caller,\\n        address indexed prevGovernance,\\n        address indexed newGovernance,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when the emergency admin is changed. We emit the caller even though it should be the previous\\n     * governance address, as we cannot guarantee this will always be the case due to upgradeability.\\n     *\\n     * @param caller The caller who set the emergency admin address.\\n     * @param oldEmergencyAdmin The previous emergency admin address.\\n     * @param newEmergencyAdmin The new emergency admin address set.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event EmergencyAdminSet(\\n        address indexed caller,\\n        address indexed oldEmergencyAdmin,\\n        address indexed newEmergencyAdmin,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a profile creator is added to or removed from the whitelist.\\n     *\\n     * @param profileCreator The address of the profile creator.\\n     * @param whitelisted Whether or not the profile creator is being added to the whitelist.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ProfileCreatorWhitelisted(address indexed profileCreator, bool indexed whitelisted, uint256 timestamp);\\n\\n    /**\\n     * @dev Emitted when a profile is created.\\n     *\\n     * @param profileId The newly created profile's token ID.\\n     * @param creator The profile creator, who created the token with the given profile ID.\\n     * @param to The address receiving the profile with the given profile ID.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ProfileCreated(uint256 indexed profileId, address indexed creator, address indexed to, uint256 timestamp);\\n\\n    /**\\n     * @dev Emitted when a delegated executors configuration is changed.\\n     *\\n     * @param delegatorProfileId The ID of the profile for which the delegated executor was changed.\\n     * @param configNumber The number of the configuration where the executor approval state was set.\\n     * @param delegatedExecutors The array of delegated executors whose approval was set for.\\n     * @param approvals The array of booleans indicating the corresponding executor new approval status.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event DelegatedExecutorsConfigChanged(\\n        uint256 indexed delegatorProfileId,\\n        uint256 indexed configNumber,\\n        address[] delegatedExecutors,\\n        bool[] approvals,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a delegated executors configuration is applied.\\n     *\\n     * @param delegatorProfileId The ID of the profile applying the configuration.\\n     * @param configNumber The number of the configuration applied.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event DelegatedExecutorsConfigApplied(\\n        uint256 indexed delegatorProfileId,\\n        uint256 indexed configNumber,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a profile's follow module is set.\\n     *\\n     * @param profileId The profile's token ID.\\n     * @param followModule The profile's newly set follow module. This CAN be the zero address.\\n     * @param followModuleInitData The data passed to the follow module, if any.\\n     * @param followModuleReturnData The data returned from the follow module's initialization. This is ABI-encoded\\n     * and depends on the follow module chosen.\\n     * @param transactionExecutor The address of the account that executed this operation.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FollowModuleSet(\\n        uint256 indexed profileId,\\n        address followModule,\\n        bytes followModuleInitData,\\n        bytes followModuleReturnData,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a post is successfully published.\\n     *\\n     * @param postParams The parameters passed to create the post publication.\\n     * @param pubId The publication ID assigned to the created post.\\n     * @param actionModulesInitReturnDatas The data returned from the action modules' initialization for this given\\n     * publication. This is ABI-encoded and depends on the action module chosen.\\n     * @param referenceModuleInitReturnData The data returned from the reference module at initialization. This is\\n     * ABI-encoded and depends on the reference module chosen.\\n     * @param transactionExecutor The address of the account that executed this operation.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event PostCreated(\\n        Types.PostParams postParams,\\n        uint256 indexed pubId,\\n        bytes[] actionModulesInitReturnDatas,\\n        bytes referenceModuleInitReturnData,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a comment is successfully published.\\n     *\\n     * @param commentParams The parameters passed to create the comment publication.\\n     * @param pubId The publication ID assigned to the created comment.\\n     * @param referenceModuleReturnData The data returned by the commented publication reference module's\\n     * processComment function, if the commented publication has a reference module set.\\n     * @param actionModulesInitReturnDatas The data returned from the action modules' initialization for this given\\n     * publication. This is ABI-encoded and depends on the action module chosen.\\n     * @param referenceModuleInitReturnData The data returned from the reference module at initialization. This is\\n     * ABI-encoded and depends on the reference module chosen.\\n     * @param transactionExecutor The address of the account that executed this operation.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event CommentCreated(\\n        Types.CommentParams commentParams,\\n        uint256 indexed pubId,\\n        bytes referenceModuleReturnData,\\n        bytes[] actionModulesInitReturnDatas,\\n        bytes referenceModuleInitReturnData,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a mirror is successfully published.\\n     *\\n     * @param mirrorParams The parameters passed to create the mirror publication.\\n     * @param pubId The publication ID assigned to the created mirror.\\n     * @param referenceModuleReturnData The data returned by the mirrored publication reference module's\\n     * processMirror function, if the mirrored publication has a reference module set.\\n     * @param transactionExecutor The address of the account that executed this operation.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event MirrorCreated(\\n        Types.MirrorParams mirrorParams,\\n        uint256 indexed pubId,\\n        bytes referenceModuleReturnData,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a quote is successfully published.\\n     *\\n     * @param quoteParams The parameters passed to create the quote publication.\\n     * @param pubId The publication ID assigned to the created quote.\\n     * @param referenceModuleReturnData The data returned by the quoted publication reference module's\\n     * processQuote function, if the quoted publication has a reference module set.\\n     * @param actionModulesInitReturnDatas The data returned from the action modules' initialization for this given\\n     * publication. This is ABI-encoded and depends on the action module chosen.\\n     * @param referenceModuleInitReturnData The data returned from the reference module at initialization. This is\\n     * ABI-encoded and depends on the reference module chosen.\\n     * @param transactionExecutor The address of the account that executed this operation.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event QuoteCreated(\\n        Types.QuoteParams quoteParams,\\n        uint256 indexed pubId,\\n        bytes referenceModuleReturnData,\\n        bytes[] actionModulesInitReturnDatas,\\n        bytes referenceModuleInitReturnData,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a followNFT clone is deployed using a lazy deployment pattern.\\n     *\\n     * @param profileId The token ID of the profile to which this followNFT is associated.\\n     * @param followNFT The address of the newly deployed followNFT clone.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FollowNFTDeployed(uint256 indexed profileId, address indexed followNFT, uint256 timestamp);\\n    /**\\n     * @dev Emitted when a collectNFT clone is deployed using a lazy deployment pattern.\\n     *\\n     * @param profileId The publisher's profile token ID.\\n     * @param pubId The publication associated with the newly deployed collectNFT clone's ID.\\n     * @param collectNFT The address of the newly deployed collectNFT clone.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event LegacyCollectNFTDeployed(\\n        uint256 indexed profileId,\\n        uint256 indexed pubId,\\n        address indexed collectNFT,\\n        uint256 timestamp\\n    );\\n    /**\\n     * @dev Emitted upon a successful action.\\n     *\\n     * @param publicationActionParams The parameters passed to act on a publication.\\n     * @param actionModuleReturnData The data returned from the action modules. This is ABI-encoded and the format\\n     * depends on the action module chosen.\\n     * @param transactionExecutor The address of the account that executed this operation.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event Acted(\\n        Types.PublicationActionParams publicationActionParams,\\n        bytes actionModuleReturnData,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted upon a successful follow operation.\\n     *\\n     * @param followerProfileId The ID of the profile that executed the follow.\\n     * @param idOfProfileFollowed The ID of the profile that was followed.\\n     * @param followTokenIdAssigned The ID of the follow token assigned to the follower.\\n     * @param followModuleData The data to pass to the follow module, if any.\\n     * @param processFollowModuleReturnData The data returned by the followed profile follow module's processFollow\\n     * function, if the followed profile has a reference module set.\\n     * @param transactionExecutor The address of the account that executed this operation.\\n     * @param timestamp The timestamp of the follow operation.\\n     */\\n    event Followed(\\n        uint256 indexed followerProfileId,\\n        uint256 idOfProfileFollowed,\\n        uint256 followTokenIdAssigned,\\n        bytes followModuleData,\\n        bytes processFollowModuleReturnData,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted upon a successful unfollow operation.\\n     *\\n     * @param unfollowerProfileId The ID of the profile that executed the unfollow.\\n     * @param idOfProfileUnfollowed The ID of the profile that was unfollowed.\\n     * @param transactionExecutor The address of the account that executed this operation.\\n     * @param timestamp The timestamp of the unfollow operation.\\n     */\\n    event Unfollowed(\\n        uint256 indexed unfollowerProfileId,\\n        uint256 idOfProfileUnfollowed,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted upon a successful block, through a block status setting operation.\\n     *\\n     * @param byProfileId The ID of the profile that executed the block status change.\\n     * @param idOfProfileBlocked The ID of the profile whose block status have been set to blocked.\\n     * @param transactionExecutor The address of the account that executed this operation.\\n     * @param timestamp The timestamp of the block operation.\\n     */\\n    event Blocked(\\n        uint256 indexed byProfileId,\\n        uint256 idOfProfileBlocked,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted upon a successful unblock, through a block status setting operation.\\n     *\\n     * @param byProfileId The ID of the profile that executed the block status change.\\n     * @param idOfProfileUnblocked The ID of the profile whose block status have been set to unblocked.\\n     * @param transactionExecutor The address of the account that executed this operation.\\n     * @param timestamp The timestamp of the unblock operation.\\n     */\\n    event Unblocked(\\n        uint256 indexed byProfileId,\\n        uint256 idOfProfileUnblocked,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted via callback when a collectNFT is transferred.\\n     *\\n     * @param profileId The token ID of the profile associated with the collectNFT being transferred.\\n     * @param pubId The publication ID associated with the collectNFT being transferred.\\n     * @param collectNFTId The collectNFT being transferred's token ID.\\n     * @param from The address the collectNFT is being transferred from.\\n     * @param to The address the collectNFT is being transferred to.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event CollectNFTTransferred(\\n        uint256 indexed profileId,\\n        uint256 indexed pubId,\\n        uint256 indexed collectNFTId,\\n        address from,\\n        address to,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Emitted when the treasury address is set.\\n     *\\n     * @param prevTreasury The previous treasury address.\\n     * @param newTreasury The new treasury address set.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event TreasurySet(address indexed prevTreasury, address indexed newTreasury, uint256 timestamp);\\n\\n    /**\\n     * @notice Emitted when the treasury fee is set.\\n     *\\n     * @param prevTreasuryFee The previous treasury fee in BPS.\\n     * @param newTreasuryFee The new treasury fee in BPS.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event TreasuryFeeSet(uint16 indexed prevTreasuryFee, uint16 indexed newTreasuryFee, uint256 timestamp);\\n\\n    /**\\n     * @dev Emitted when the metadata associated with a profile is set in the `LensPeriphery`.\\n     *\\n     * @param profileId The profile ID the metadata is set for.\\n     * @param metadata The metadata set for the profile and user.\\n     * @param transactionExecutor The address of the account that executed this operation.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ProfileMetadataSet(\\n        uint256 indexed profileId,\\n        string metadata,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when an address' Profile Guardian state change is triggered.\\n     *\\n     * @param wallet The address whose Token Guardian state change is being triggered.\\n     * @param enabled True if the Token Guardian is being enabled, false if it is being disabled.\\n     * @param tokenGuardianDisablingTimestamp The UNIX timestamp when disabling the Token Guardian will take effect,\\n     * if disabling it. Zero if the protection is being enabled.\\n     * @param timestamp The UNIX timestamp of the change being triggered.\\n     */\\n    event TokenGuardianStateChanged(\\n        address indexed wallet,\\n        bool indexed enabled,\\n        uint256 tokenGuardianDisablingTimestamp,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a signer's nonce is used and, as a consequence, the next available nonce is updated.\\n     *\\n     * @param signer The signer whose next available nonce was updated.\\n     * @param nonce The next available nonce that can be used to execute a meta-tx successfully.\\n     * @param timestamp The UNIX timestamp of the nonce being used.\\n     */\\n    event NonceUpdated(address indexed signer, uint256 nonce, uint256 timestamp);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/constants/Typehash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nlibrary Typehash {\\n\\n    bytes32 constant ACT = keccak256('Act(uint256 publicationActedProfileId,uint256 publicationActedId,uint256 actorProfileId,uint256[] referrerProfileIds,uint256[] referrerPubIds,address actionModuleAddress,bytes actionModuleData,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant CHANGE_DELEGATED_EXECUTORS_CONFIG = keccak256('ChangeDelegatedExecutorsConfig(uint256 delegatorProfileId,address[] delegatedExecutors,bool[] approvals,uint64 configNumber,bool switchToGivenConfig,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant COLLECT_LEGACY = keccak256('CollectLegacy(uint256 publicationCollectedProfileId,uint256 publicationCollectedId,uint256 collectorProfileId,uint256 referrerProfileId,uint256 referrerPubId,bytes collectModuleData,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant COMMENT = keccak256('Comment(uint256 profileId,string contentURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,address[] actionModules,bytes[] actionModulesInitDatas,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant EIP712_DOMAIN = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\\n\\n    bytes32 constant FOLLOW = keccak256('Follow(uint256 followerProfileId,uint256[] idsOfProfilesToFollow,uint256[] followTokenIds,bytes[] datas,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant MIRROR = keccak256('Mirror(uint256 profileId,string metadataURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant POST = keccak256('Post(uint256 profileId,string contentURI,address[] actionModules,bytes[] actionModulesInitDatas,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant QUOTE = keccak256('Quote(uint256 profileId,string contentURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,address[] actionModules,bytes[] actionModulesInitDatas,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant SET_BLOCK_STATUS = keccak256('SetBlockStatus(uint256 byProfileId,uint256[] idsOfProfilesToSetBlockStatus,bool[] blockStatus,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant SET_FOLLOW_MODULE = keccak256('SetFollowModule(uint256 profileId,address followModule,bytes followModuleInitData,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant SET_PROFILE_METADATA_URI = keccak256('SetProfileMetadataURI(uint256 profileId,string metadataURI,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant UNFOLLOW = keccak256('Unfollow(uint256 unfollowerProfileId,uint256[] idsOfProfilesToUnfollow,uint256 nonce,uint256 deadline)');\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/constants/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title Types\\n * @author Lens Protocol\\n *\\n * @notice A standard library of data types used throughout the Lens Protocol.\\n */\\nlibrary Types {\\n    /**\\n     * @notice ERC721Timestamped storage. Contains the owner address and the mint timestamp for every NFT.\\n     *\\n     * Note: Instead of the owner address in the _tokenOwners private mapping, we now store it in the\\n     * _tokenData mapping, alongside the mint timestamp.\\n     *\\n     * @param owner The token owner.\\n     * @param mintTimestamp The mint timestamp.\\n     */\\n    struct TokenData {\\n        address owner;\\n        uint96 mintTimestamp;\\n    }\\n\\n    /**\\n     * @notice A struct containing token follow-related data.\\n     *\\n     * @param followerProfileId The ID of the profile using the token to follow.\\n     * @param originalFollowTimestamp The timestamp of the first follow performed with the token.\\n     * @param followTimestamp The timestamp of the current follow, if a profile is using the token to follow.\\n     * @param profileIdAllowedToRecover The ID of the profile allowed to recover the follow ID, if any.\\n     */\\n    struct FollowData {\\n        uint160 followerProfileId;\\n        uint48 originalFollowTimestamp;\\n        uint48 followTimestamp;\\n        uint256 profileIdAllowedToRecover;\\n    }\\n\\n    /**\\n     * @notice An enum containing the different states the protocol can be in, limiting certain actions.\\n     *\\n     * @param Unpaused The fully unpaused state.\\n     * @param PublishingPaused The state where only publication creation functions are paused.\\n     * @param Paused The fully paused state.\\n     */\\n    enum ProtocolState {\\n        Unpaused,\\n        PublishingPaused,\\n        Paused\\n    }\\n\\n    /**\\n     * @notice An enum specifically used in a helper function to easily retrieve the publication type for integrations.\\n     *\\n     * @param Nonexistent An indicator showing the queried publication does not exist.\\n     * @param Post A standard post, having an URI, action modules and no pointer to another publication.\\n     * @param Comment A comment, having an URI, action modules and a pointer to another publication.\\n     * @param Mirror A mirror, having a pointer to another publication, but no URI or action modules.\\n     * @param Quote A quote, having an URI, action modules, and a pointer to another publication.\\n     */\\n    enum PublicationType {\\n        Nonexistent,\\n        Post,\\n        Comment,\\n        Mirror,\\n        Quote\\n    }\\n\\n    /**\\n     * @notice A struct containing the necessary information to reconstruct an EIP-712 typed data signature.\\n     *\\n     * @param signer The address of the signer. Specially needed as a parameter to support EIP-1271.\\n     * @param v The signature's recovery parameter.\\n     * @param r The signature's r parameter.\\n     * @param s The signature's s parameter.\\n     * @param deadline The signature's deadline.\\n     */\\n    struct EIP712Signature {\\n        address signer;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 deadline;\\n    }\\n\\n    /**\\n     * @notice A struct containing profile data.\\n     *\\n     * @param pubCount The number of publications made to this profile.\\n     * @param followModule The address of the current follow module in use by this profile, can be address(0) in none.\\n     * @param followNFT The address of the followNFT associated with this profile. It can be address(0) if the\\n     * profile has not been followed yet, as the collection is lazy-deployed upon the first follow.\\n     * @param __DEPRECATED__handle DEPRECATED in V2: handle slot, was replaced with LensHandles.\\n     * @param __DEPRECATED__imageURI DEPRECATED in V2: The URI to be used for the profile image.\\n     * @param __DEPRECATED__followNFTURI DEPRECATED in V2: The URI used for the follow NFT image.\\n     * @param metadataURI MetadataURI is used to store the profile's metadata, for example: displayed name, description,\\n     * interests, etc.\\n     */\\n    struct Profile {\\n        uint256 pubCount; // offset 0\\n        address followModule; // offset 1\\n        address followNFT; // offset 2\\n        string __DEPRECATED__handle; // offset 3\\n        string __DEPRECATED__imageURI; // offset 4\\n        string __DEPRECATED__followNFTURI; // Deprecated in V2 as we have a common tokenURI for all Follows, offset 5\\n        string metadataURI; // offset 6\\n    }\\n\\n    /**\\n     * @notice A struct containing publication data.\\n     *\\n     * @param pointedProfileId The profile token ID to point the publication to.\\n     * @param pointedPubId The publication ID to point the publication to.\\n     * These are used to implement the \\\"reference\\\" feature of the platform and is used in:\\n     * - Mirrors\\n     * - Comments\\n     * - Quotes\\n     * There are (0,0) if the publication is not pointing to any other publication (i.e. the publication is a Post).\\n     * @param contentURI The URI to set for the content of publication (can be ipfs, arweave, http, etc).\\n     * @param referenceModule Reference module associated with this profile, if any.\\n     * @param __DEPRECATED__collectModule Collect module associated with this publication, if any. Deprecated in V2.\\n     * @param __DEPRECATED__collectNFT Collect NFT associated with this publication, if any. Deprecated in V2.\\n     * @param pubType The type of publication, can be Nonexistent, Post, Comment, Mirror or Quote.\\n     * @param rootProfileId The profile ID of the root post (to determine if comments/quotes and mirrors come from it).\\n     * Posts, V1 publications and publications rooted in V1 publications don't have it set.\\n     * @param rootPubId The publication ID of the root post (to determine if comments/quotes and mirrors come from it).\\n     * Posts, V1 publications and publications rooted in V1 publications don't have it set.\\n     * @param actionModuleEnabled The action modules enabled in a given publication.\\n     */\\n    struct Publication {\\n        uint256 pointedProfileId;\\n        uint256 pointedPubId;\\n        string contentURI;\\n        address referenceModule;\\n        address __DEPRECATED__collectModule; // Deprecated in V2\\n        address __DEPRECATED__collectNFT; // Deprecated in V2\\n        // Added in Lens V2, so these will be zero for old publications:\\n        PublicationType pubType;\\n        uint256 rootProfileId;\\n        uint256 rootPubId;\\n        mapping(address => bool) actionModuleEnabled;\\n    }\\n\\n    struct PublicationMemory {\\n        uint256 pointedProfileId;\\n        uint256 pointedPubId;\\n        string contentURI;\\n        address referenceModule;\\n        address __DEPRECATED__collectModule; // Deprecated in V2\\n        address __DEPRECATED__collectNFT; // Deprecated in V2\\n        // Added in Lens V2, so these will be zero for old publications:\\n        PublicationType pubType;\\n        uint256 rootProfileId;\\n        uint256 rootPubId;\\n        // bytes32 __ACTION_MODULE_ENABLED_MAPPING; // Mappings are not supported in memory.\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `createProfile()` function.\\n     *\\n     * @param to The address receiving the profile.\\n     * @param followModule The follow module to use, can be the zero address.\\n     * @param followModuleInitData The follow module initialization data, if any.\\n     */\\n    struct CreateProfileParams {\\n        address to;\\n        address followModule;\\n        bytes followModuleInitData;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `post()` function.\\n     *\\n     * @param profileId The token ID of the profile to publish to.\\n     * @param contentURI The URI to set for this new publication.\\n     * @param actionModules The action modules to set for this new publication.\\n     * @param actionModulesInitDatas The data to pass to the action modules' initialization.\\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\\n     */\\n    struct PostParams {\\n        uint256 profileId;\\n        string contentURI;\\n        address[] actionModules;\\n        bytes[] actionModulesInitDatas;\\n        address referenceModule;\\n        bytes referenceModuleInitData;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `comment()` function.\\n     *\\n     * @param profileId The token ID of the profile to publish to.\\n     * @param contentURI The URI to set for this new publication.\\n     * @param pointedProfileId The profile token ID to point the comment to.\\n     * @param pointedPubId The publication ID to point the comment to.\\n     * @param referrerProfileId The profile token ID of the publication that referred to the publication being commented on/quoted.\\n     * @param referrerPubId The ID of the publication that referred to the publication being commented on/quoted.\\n     * @param referenceModuleData The data passed to the reference module.\\n     * @param actionModules The action modules to set for this new publication.\\n     * @param actionModulesInitDatas The data to pass to the action modules' initialization.\\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\\n     */\\n    struct CommentParams {\\n        uint256 profileId;\\n        string contentURI;\\n        uint256 pointedProfileId;\\n        uint256 pointedPubId;\\n        uint256[] referrerProfileIds;\\n        uint256[] referrerPubIds;\\n        bytes referenceModuleData;\\n        address[] actionModules;\\n        bytes[] actionModulesInitDatas;\\n        address referenceModule;\\n        bytes referenceModuleInitData;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `quote()` function.\\n     *\\n     * @param profileId The token ID of the profile to publish to.\\n     * @param contentURI The URI to set for this new publication.\\n     * @param pointedProfileId The profile token ID of the publication author that is quoted.\\n     * @param pointedPubId The publication ID that is quoted.\\n     * @param referrerProfileId The profile token ID of the publication that referred to the publication being commented on/quoted.\\n     * @param referrerPubId The ID of the publication that referred to the publication being commented on/quoted.\\n     * @param referenceModuleData The data passed to the reference module.\\n     * @param actionModules The action modules to set for this new publication.\\n     * @param actionModulesInitDatas The data to pass to the action modules' initialization.\\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\\n     */\\n    struct QuoteParams {\\n        uint256 profileId;\\n        string contentURI;\\n        uint256 pointedProfileId;\\n        uint256 pointedPubId;\\n        uint256[] referrerProfileIds;\\n        uint256[] referrerPubIds;\\n        bytes referenceModuleData;\\n        address[] actionModules;\\n        bytes[] actionModulesInitDatas;\\n        address referenceModule;\\n        bytes referenceModuleInitData;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `comment()` or `quote()` internal functions.\\n     *\\n     * @param profileId The token ID of the profile to publish to.\\n     * @param contentURI The URI to set for this new publication.\\n     * @param pointedProfileId The profile token ID of the publication author that is commented on/quoted.\\n     * @param pointedPubId The publication ID that is commented on/quoted.\\n     * @param referrerProfileId The profile token ID of the publication that referred to the publication being commented on/quoted.\\n     * @param referrerPubId The ID of the publication that referred to the publication being commented on/quoted.\\n     * @param referenceModuleData The data passed to the reference module.\\n     * @param actionModules The action modules to set for this new publication.\\n     * @param actionModulesInitDatas The data to pass to the action modules' initialization.\\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\\n     */\\n    struct ReferencePubParams {\\n        uint256 profileId;\\n        string contentURI;\\n        uint256 pointedProfileId;\\n        uint256 pointedPubId;\\n        uint256[] referrerProfileIds;\\n        uint256[] referrerPubIds;\\n        bytes referenceModuleData;\\n        address[] actionModules;\\n        bytes[] actionModulesInitDatas;\\n        address referenceModule;\\n        bytes referenceModuleInitData;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `mirror()` function.\\n     *\\n     * @param profileId The token ID of the profile to publish to.\\n     * @param metadataURI the URI containing metadata attributes to attach to this mirror publication.\\n     * @param pointedProfileId The profile token ID to point the mirror to.\\n     * @param pointedPubId The publication ID to point the mirror to.\\n     * @param referenceModuleData The data passed to the reference module.\\n     */\\n    struct MirrorParams {\\n        uint256 profileId;\\n        string metadataURI;\\n        uint256 pointedProfileId;\\n        uint256 pointedPubId;\\n        uint256[] referrerProfileIds;\\n        uint256[] referrerPubIds;\\n        bytes referenceModuleData;\\n    }\\n\\n    /**\\n     * Deprecated in V2: Will be removed after some time after upgrading to V2.\\n     * @notice A struct containing the parameters required for the legacy `collect()` function.\\n     * @dev The referrer can only be a mirror of the publication being collected.\\n     *\\n     * @param publicationCollectedProfileId The token ID of the profile that published the publication to collect.\\n     * @param publicationCollectedId The publication to collect's publication ID.\\n     * @param collectorProfileId The collector profile.\\n     * @param referrerProfileId The ID of a profile that authored a mirror that helped discovering the collected pub.\\n     * @param referrerPubId The ID of the mirror that helped discovering the collected pub.\\n     * @param collectModuleData The arbitrary data to pass to the collectModule if needed.\\n     */\\n    struct LegacyCollectParams {\\n        uint256 publicationCollectedProfileId;\\n        uint256 publicationCollectedId;\\n        uint256 collectorProfileId;\\n        uint256 referrerProfileId;\\n        uint256 referrerPubId;\\n        bytes collectModuleData;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `action()` function.\\n     *\\n     * @param publicationActedProfileId The token ID of the profile that published the publication to action.\\n     * @param publicationActedId The publication to action's publication ID.\\n     * @param actorProfileId The actor profile.\\n     * @param referrerProfileId\\n     * @param referrerPubId\\n     * @param actionModuleAddress\\n     * @param actionModuleData The arbitrary data to pass to the actionModule if needed.\\n     */\\n    struct PublicationActionParams {\\n        uint256 publicationActedProfileId;\\n        uint256 publicationActedId;\\n        uint256 actorProfileId;\\n        uint256[] referrerProfileIds;\\n        uint256[] referrerPubIds;\\n        address actionModuleAddress;\\n        bytes actionModuleData;\\n    }\\n\\n    struct ProcessActionParams {\\n        uint256 publicationActedProfileId;\\n        uint256 publicationActedId;\\n        uint256 actorProfileId;\\n        address actorProfileOwner;\\n        address transactionExecutor;\\n        uint256[] referrerProfileIds;\\n        uint256[] referrerPubIds;\\n        Types.PublicationType[] referrerPubTypes;\\n        bytes actionModuleData;\\n    }\\n\\n    struct ProcessCommentParams {\\n        uint256 profileId;\\n        uint256 pubId;\\n        address transactionExecutor;\\n        uint256 pointedProfileId;\\n        uint256 pointedPubId;\\n        uint256[] referrerProfileIds;\\n        uint256[] referrerPubIds;\\n        Types.PublicationType[] referrerPubTypes;\\n        bytes data;\\n    }\\n\\n    struct ProcessQuoteParams {\\n        uint256 profileId;\\n        uint256 pubId;\\n        address transactionExecutor;\\n        uint256 pointedProfileId;\\n        uint256 pointedPubId;\\n        uint256[] referrerProfileIds;\\n        uint256[] referrerPubIds;\\n        Types.PublicationType[] referrerPubTypes;\\n        bytes data;\\n    }\\n\\n    struct ProcessMirrorParams {\\n        uint256 profileId;\\n        uint256 pubId;\\n        address transactionExecutor;\\n        uint256 pointedProfileId;\\n        uint256 pointedPubId;\\n        uint256[] referrerProfileIds;\\n        uint256[] referrerPubIds;\\n        Types.PublicationType[] referrerPubTypes;\\n        bytes data;\\n    }\\n\\n    /**\\n     * @notice A struct containing a profile's delegated executors configuration.\\n     *\\n     * @param isApproved Tells when an address is approved as delegated executor in the given configuration number.\\n     * @param configNumber Current configuration number in use.\\n     * @param prevConfigNumber Previous configuration number set, before switching to the current one.\\n     * @param maxConfigNumberSet Maximum configuration number ever used.\\n     */\\n    struct DelegatedExecutorsConfig {\\n        mapping(uint256 => mapping(address => bool)) isApproved; // isApproved[configNumber][delegatedExecutor]\\n        uint64 configNumber;\\n        uint64 prevConfigNumber;\\n        uint64 maxConfigNumberSet;\\n    }\\n\\n    struct TreasuryData {\\n        address treasury;\\n        uint16 treasuryFeeBPS;\\n    }\\n\\n    struct MigrationParams {\\n        address lensHandlesAddress;\\n        address tokenHandleRegistryAddress;\\n        address legacyFeeFollowModule;\\n        address legacyProfileFollowModule;\\n        address newFeeFollowModule;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/token-uris/FollowTokenURILib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {Base64} from '@openzeppelin/contracts/utils/Base64.sol';\\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\\nimport {ImageTokenURILib} from 'contracts/libraries/token-uris/ImageTokenURILib.sol';\\n\\nlibrary FollowTokenURILib {\\n    using Strings for uint96;\\n    using Strings for uint256;\\n\\n    function getTokenURI(\\n        uint256 followTokenId,\\n        uint256 followedProfileId,\\n        uint256 originalFollowTimestamp\\n    ) external pure returns (string memory) {\\n        string memory followTokenIdAsString = followTokenId.toString();\\n        string memory followedProfileIdAsString = followedProfileId.toString();\\n        return\\n            string(\\n                abi.encodePacked(\\n                    'data:application/json;base64,',\\n                    Base64.encode(\\n                        abi.encodePacked(\\n                            '{\\\"name\\\":\\\"Follower #',\\n                            followTokenIdAsString,\\n                            '\\\",\\\"description\\\":\\\"Lens Protocol - Follower #',\\n                            followTokenIdAsString,\\n                            ' of Profile #',\\n                            followedProfileIdAsString,\\n                            '\\\",\\\"image\\\":\\\"data:image/svg+xml;base64,',\\n                            ImageTokenURILib.getSVGImageBase64Encoded(),\\n                            '\\\",\\\"attributes\\\":[{\\\"display_type\\\": \\\"number\\\", \\\"trait_type\\\":\\\"ID\\\",\\\"value\\\":\\\"',\\n                            followTokenIdAsString,\\n                            '\\\"},{\\\"trait_type\\\":\\\"DIGITS\\\",\\\"value\\\":\\\"',\\n                            bytes(followTokenIdAsString).length.toString(),\\n                            '\\\"},{\\\"trait_type\\\":\\\"MINTED AT\\\",\\\"value\\\":\\\"',\\n                            originalFollowTimestamp.toString(),\\n                            '\\\"}]}'\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/token-uris/HandleTokenURILib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {Base64} from '@openzeppelin/contracts/utils/Base64.sol';\\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\\nimport {ImageTokenURILib} from 'contracts/libraries/token-uris/ImageTokenURILib.sol';\\n\\nlibrary HandleTokenURILib {\\n    using Strings for uint256;\\n\\n    function getTokenURI(\\n        uint256 tokenId,\\n        string memory localName,\\n        string memory namespace\\n    ) external pure returns (string memory) {\\n        return\\n            string.concat(\\n                'data:application/json;base64,',\\n                Base64.encode(\\n                    bytes(\\n                        string.concat(\\n                            '{\\\"name\\\":\\\"@',\\n                            localName,\\n                            '\\\",\\\"description\\\":\\\"Lens Protocol - Handle @',\\n                            localName,\\n                            '\\\",\\\"image\\\":\\\"data:image/svg+xml;base64,',\\n                            ImageTokenURILib.getSVGImageBase64Encoded(),\\n                            '\\\",\\\"attributes\\\":[{\\\"display_type\\\": \\\"number\\\", \\\"trait_type\\\":\\\"ID\\\",\\\"value\\\":\\\"',\\n                            tokenId.toString(),\\n                            '\\\"},{\\\"trait_type\\\":\\\"NAMESPACE\\\",\\\"value\\\":\\\"',\\n                            namespace,\\n                            '\\\"},{\\\"trait_type\\\":\\\"LENGTH\\\",\\\"value\\\":\\\"',\\n                            bytes(localName).length.toString(),\\n                            '\\\"}]}'\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/token-uris/ImageTokenURILib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {Base64} from '@openzeppelin/contracts/utils/Base64.sol';\\n\\nlibrary ImageTokenURILib {\\n    function getSVGImageBase64Encoded() internal pure returns (string memory) {\\n        return\\n            Base64.encode(\\n                '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"263\\\" height=\\\"263\\\" fill=\\\"none\\\"><g clip-path=\\\"url(#a)\\\"><g clip-path=\\\"url(#b)\\\"><path fill=\\\"url(#c)\\\" d=\\\"M0 0h262.6v262.6H0V0Z\\\"/></g><path fill=\\\"#93A97D\\\" d=\\\"m98.7 242.8 16.3 5.4 16 1.3 16-1.3 16.3-5.4v30.7l-7.5 3.4-8 2.4-16.8-4.4-15.4 4.4-9.4-2.4-7.5-3.4v-30.7Z\\\"/><path stroke=\\\"#000\\\" stroke-dasharray=\\\"3.97 3.97\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"1.8\\\" d=\\\"M105 271v-22.3M157.5 271v-22.3\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"3\\\" d=\\\"M131 273.8v-16.6\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"4\\\" d=\\\"M100.1 243c0 10.2 0 20.4-.2 30.9m62-30.8.1 30.8\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"3\\\" d=\\\"M100.3 242.2a57.8 57.8 0 0 0 30.2 7.8c10.7 0 21.7-2.4 31-7.8\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"2\\\" d=\\\"M135.5 256.2s-2.7.5-4.5.5c-1.8 0-4.5-.5-4.5-.5\\\"/><path fill=\\\"#A0D170\\\" d=\\\"m81.9 202.2 13.9 6.7-4.5 17.8 2 12-3 5.8-8.4 1.4H70.4l-9.4-7.2 1.5-13.4 10.4-6.8 9-16.3ZM180.2 203.2l-14 6.7 4.5 17.8-2 12 3 4.8 8.5 2.4h11.4l9.4-7.2-1.5-13.5-10.4-6.7-9-16.3Z\\\"/><path fill=\\\"#F4FFDC\\\" d=\\\"M99.7 179.1s18.8-4.1 31.3-4.1a186 186 0 0 1 31.3 4.1l8.4 6.3 11.4 13-15.6 9 4.2 28.4-8.4 8.7-15.4 4.8-15.9 1.4-15.9-1.4-15.4-4.8-8.4-8.7 4.2-28.3-14.1-9.2 9.9-13 8.4-6.2Z\\\"/><path stroke=\\\"#000\\\" stroke-dasharray=\\\"5 5\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-opacity=\\\".1\\\" stroke-width=\\\"2\\\" d=\\\"M151 184.3c0 9.2-9 16.7-20 16.7s-20-7.5-20-16.7 9-9.3 20-9.3 20 0 20 9.3Z\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"4\\\" d=\\\"M81.9 202.4c-2.6 4.3-5.1 8.6-7.7 13.5a16.2 16.2 0 0 1-6 5.8 15 15 0 0 0-7 10.1 13.6 13.6 0 0 0 7.4 14.1c4.2 2 9.5 1.4 13.3-1.2\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"2\\\" d=\\\"M83.8 240.6a11.2 11.2 0 0 1-5 4.8M178.2 240.6c1.5 2.4 2.4 3.4 5 4.8\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"4\\\" d=\\\"M82 244.7a8 8 0 0 0 7.9 0 7.1 7.1 0 0 0 3.7-6.5\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"3\\\" d=\\\"m96.1 211.2 3.1-10.7M165.8 211.2l-3-10.7M93.8 238.3a55.3 55.3 0 0 0 36.7 12.4\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"4\\\" d=\\\"M100.1 243.8c-2-2-4.1-3.3-5.9-5a10 10 0 0 1-3.2-6c-.2-1.6.2-3.2.6-4.8l4.7-19.4a25.6 25.6 0 0 1-13.7-8.2c-1.1-1.3-1-3.1 0-4.5 2.8-4 5.9-8 9.6-11.6 4.5-4.2 10-7.4 16.3-8h45c6.2.6 11.8 3.8 16.2 8 3.8 3.5 6.8 7.7 9.7 11.6 1 1.4 1 3.2 0 4.5-3.4 4-8.3 7-13.7 8.2l4.7 19.4c.4 1.6.7 3.2.6 4.8a10 10 0 0 1-3.3 6c-1.7 1.7-3.8 3-5.9 5\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"3\\\" d=\\\"M168.2 238.3a58.7 58.7 0 0 1-37.7 12.4\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"4\\\" d=\\\"M180 202.4c2.5 4.3 5 8.6 7.6 13.5 1.3 2.5 3.7 4.3 6.1 5.8a15 15 0 0 1 7 10.1c.9 5.6-2.2 11.6-7.4 14.1-4.2 2-9.6 1.4-13.3-1.2M179.8 244.7a8 8 0 0 1-7.8 0c-2.4-1.4-3.9-3.3-3.8-6\\\"/><path fill=\\\"#A0D170\\\" d=\\\"M147 183.6c0 7.5-7.2 13.5-16 13.5s-16-6-16-13.5 7.2-7.6 16-7.6 16 0 16 7.6Z\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-miterlimit=\\\"10\\\" stroke-width=\\\"2.5\\\" d=\\\"M147 183.6c0 7.5-7.2 13.5-16 13.5s-16-6-16-13.5 7.2-7.6 16-7.6 16 0 16 7.6Z\\\"/><path fill=\\\"#A0D170\\\" stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"1.8\\\" d=\\\"m135.5 216.7-.3.3v-.8c-.1-5.4-8.3-5.4-8.4 0v.8l-.3-.3-.3-.2c-4-3.7-9.7 2-6 6l.3.2a16.3 16.3 0 0 0 10.5 4.5s6 0 10.5-4.5l.3-.3c3.7-3.9-2-9.6-6-6l-.3.3Z\\\"/><path fill=\\\"#A0D170\\\" d=\\\"M169.3 99.8c-.8.8-2.2.3-2.2-.9v-3.3c-1.3-46.1-71-46.1-72.2 0v3.3c0 1.1-1.4 1.7-2.2 1l-2.4-2.4c-33.6-31.7-82.8 17.4-51 50.9l2.3 2.4A138.4 138.4 0 0 0 131 189s51 0 89.4-38.2l2.4-2.4c31.7-33.5-17.5-82.6-51-51l-2.5 2.4Z\\\"/><circle cx=\\\"4\\\" cy=\\\"4\\\" r=\\\"4\\\" fill=\\\"#fff\\\" fill-opacity=\\\".5\\\" transform=\\\"matrix(-1 0 0 1 225.3 121)\\\"/><path fill=\\\"#fff\\\" fill-opacity=\\\".5\\\" d=\\\"M221.5 112.5a5 5 0 0 1-9 4 6.7 6.7 0 0 0-.3-.7l-1.2-2c-1-1.7-2.3-3.5-3.6-4.6-1.5-1.2-2.6-2-3.7-2.5l-1.7-.8a3 3 0 0 1-1.4-4l.1-.3c.8-1.5 0-3.3-1.5-3.5-1.9-.3-3.4-.3-5-.2h-.1a1.8 1.8 0 0 1-.3-3.5 23.6 23.6 0 0 1 16.6 4.8c1 .7 2.2 1.5 3.3 2.5a29.2 29.2 0 0 1 7.7 10.4v.3h.1\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"square\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"4\\\" d=\\\"M169.3 99.8v0c-.8.8-2.2.3-2.2-.9v0-3.3c-1.3-46.1-71-46.1-72.2 0v3.3c0 1.1-1.4 1.7-2.2 1v0l-2.4-2.4c-33.6-31.7-82.8 17.4-51 50.9l2.3 2.4A138.4 138.4 0 0 0 131 189s51 0 89.4-38.2l2.4-2.4c31.7-33.5-17.5-82.6-51-51l-2.5 2.4Z\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-width=\\\"3\\\" d=\\\"M117 154s4.3 6 14 6 14-6 14-6\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"2.5\\\" d=\\\"M115 154c.8-.4 1.5-1 2-2M147 154c-.8-.4-1.5-1-2-2\\\"/><path fill=\\\"#000\\\" fill-rule=\\\"evenodd\\\" d=\\\"M120.1 134c.7-.4 1-1.1.8-1.8-1.4-3.6-4.5-6.2-8-6.2-5 0-8.9 4.7-8.9 10.4s4 10.4 8.8 10.4c3.5 0 6.5-2.4 8-5.8.3-.7-.1-1.5-.8-1.8l-3.6-1.5c-1-.4-1-1.8 0-2.2l3.7-1.6ZM140.9 136.4c0-5.7 4-10.4 8.8-10.4 3.7 0 7 2.7 8.2 6.5.3.7-.1 1.4-.8 1.7l-3 1.3c-1 .4-1 1.8 0 2.2l2.9 1.2c.7.3 1 1 .8 1.8-1.4 3.6-4.5 6.1-8 6.1-5 0-8.9-4.7-8.9-10.4Z\\\" clip-rule=\\\"evenodd\\\"/><path fill=\\\"#000\\\" fill-opacity=\\\".1\\\" d=\\\"M100.7 149.2a1.5 1.5 0 1 1-2.5-1.5 1.5 1.5 0 0 1 2.5 1.5ZM105.8 152.1a1.5 1.5 0 1 1-2.5-1.4 1.5 1.5 0 0 1 2.5 1.4ZM101.3 154a1.5 1.5 0 1 1-2.5-1.4 1.5 1.5 0 0 1 2.5 1.5ZM156.7 150.7a1.5 1.5 0 1 1-2.5 1.4 1.5 1.5 0 0 1 2.5-1.4ZM161.8 147.7a1.5 1.5 0 1 1-2.5 1.5 1.5 1.5 0 0 1 2.5-1.5ZM161.2 152.6a1.5 1.5 0 1 1-2.5 1.4 1.5 1.5 0 0 1 2.5-1.4Z\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"4\\\" d=\\\"M124 61.5s4.2-.5 7-.5c2.6 0 6.8.5 6.8.5\\\"/><path fill=\\\"#A0B884\\\" d=\\\"m179.6 108-.8 2.6-3.3-.8-5.3-4.2-7.8-5-9.2-4.9-9.1-1-10.6-1h-10l-11 2L103 99l-10.6 5.2-8 6.5-2-.8 3-5.7.8-4.2 2.5-3.2 7.1-4.1 8.4-3.6 13.1-3.3 14.6-.9h10.3l23.3 6.8 8.1 5.1 2 4 4.1 7.3Z\\\"/><path fill=\\\"#F4FFDC\\\" d=\\\"m88.5 85.8-2.2 13.8 3.5-3c3-2.4 6.2-4.4 9.6-5.9l1.3-.5 7.2-2.6 7.2-1.9 3.2-.5a91 91 0 0 1 13-.9h4c5.4.4 10.8 1.2 16 2.5l1 .2 8.9 3 3.2 1.5c3.3 1.6 6.2 3.7 8.9 6.2l2.2 1.9-1.9-13.8-2-7.8a30.6 30.6 0 0 0-5-10.9l-.6-.7c-2-2.8-4.4-5.2-7-7.4l-.3-.2c-2.4-2-5-3.6-7.8-5l-1.1-.5a37.2 37.2 0 0 0-16.3-3.7H128.8a36.9 36.9 0 0 0-15 3.2l-1.9.8a39.4 39.4 0 0 0-15.1 12L95.6 67a29.2 29.2 0 0 0-5.1 10.8l-2 8Z\\\"/><path fill=\\\"#000\\\" fill-opacity=\\\".1\\\" d=\\\"m92.2 94.9-6.1 5.9 2.3-14.2 2.6-8.8 4.4-9.4L106.5 57s-8.4 10.6-11 17.5C91.8 83.7 92.1 95 92.1 95ZM169.9 93.9l6 5.9-2.3-14.2-2.6-8.8-4.4-9.4-11-11.4s8.3 10.6 11 17.5C170.1 82.7 170 94 170 94Z\\\"/><path fill=\\\"#F4FFDC\\\" d=\\\"M131.3 49.4h-4a1.4 1.4 0 0 1-1-2.2l.2-.4c.3-.3.6-.5 1-.6l.5-.3c.7-.3 1.5-.4 2.2-.4H131.9c.7 0 1.3 0 2 .3l.7.3c.4.2.8.5 1.2 1l.2.2a1.3 1.3 0 0 1-1 2.1h-3.7Z\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"4\\\" d=\\\"M125.8 49.4v-1.9c0-.4 0-.8.2-1.2.2-.4.5-.8 1-1l.1-.2a9.4 9.4 0 0 1 8 0l.2.1c.4.3.7.7.9 1.1l.2 1.2v2M111 53.6l-1.1.6a39.2 39.2 0 0 0-20.4 26.2c-1.5 6.3-1.8 12.8-3 19l-.4 2.2-3.8 6.9c-.8 1.5 1 3 2.2 2l8.1-6.4 2.5-1.7c4.5-2.5 9.2-4.6 14-6.3l.8-.2.4-.1a85.7 85.7 0 0 1 41.9 0h.3l.8.3a89.6 89.6 0 0 1 16.4 8l8 6.4c1.3 1 3-.5 2.2-2l-3.8-7-.3-2.5c-1.2-6-1.4-12.2-2.8-18.2a39.3 39.3 0 0 0-20.5-26.7l-1-.5c-5.7-2.9-12-4.4-18.3-4.4h-3.8c-6.4 0-12.7 1.5-18.4 4.4Z\\\"/><path fill=\\\"#A0D170\\\" stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"2.5\\\" d=\\\"m135.7 66.1-.2.3v-.7c-.2-5.4-8.4-5.4-8.5 0v.7l-.3-.3-.3-.2c-4-3.7-9.7 2-6 6l.3.2a16.3 16.3 0 0 0 10.5 4.5s6 0 10.5-4.5l.3-.3c3.7-3.9-2-9.6-6-6 0 .2-.2.3-.3.3Z\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"3\\\" d=\\\"M86.9 101.5s13.6-17.7 45-17.7c31.3 0 43.6 17.7 43.6 17.7\\\"/><path stroke=\\\"#000\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-opacity=\\\".1\\\" stroke-width=\\\"4\\\" d=\\\"M84.6 110.6s17.5-14 46.7-14c29.3 0 45 14 45 14\\\"/></g><defs><clipPath id=\\\"a\\\"><path fill=\\\"#fff\\\" d=\\\"M0 9c0-5 4-9 9-9h245c5 0 9 4 9 9v254H0V9Z\\\"/></clipPath><clipPath id=\\\"b\\\"><path fill=\\\"#fff\\\" d=\\\"M0 0h262.6v262.6H0z\\\"/></clipPath><linearGradient id=\\\"c\\\" x1=\\\"131.3\\\" x2=\\\"131.3\\\" y1=\\\"0\\\" y2=\\\"262.6\\\" gradientUnits=\\\"userSpaceOnUse\\\"><stop stop-color=\\\"#DDFFBC\\\"/><stop offset=\\\"1\\\" stop-color=\\\"#fff\\\"/></linearGradient></defs></svg>'\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/ImmutableOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\ncontract ImmutableOwnable {\\n    address public immutable OWNER;\\n    address public immutable LENS_HUB;\\n\\n    error OnlyOwner();\\n    error OnlyOwnerOrHub();\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != OWNER) {\\n            revert OnlyOwner();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyOwnerOrHub() {\\n        if (msg.sender != OWNER && msg.sender != LENS_HUB) {\\n            revert OnlyOwnerOrHub();\\n        }\\n        _;\\n    }\\n\\n    constructor(address owner, address lensHub) {\\n        OWNER = owner;\\n        LENS_HUB = lensHub;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/LensV2Migration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\nimport {MigrationLib} from 'contracts/libraries/MigrationLib.sol';\\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\n\\n// Handles\\nimport {LensHandles} from 'contracts/namespaces/LensHandles.sol';\\nimport {TokenHandleRegistry} from 'contracts/namespaces/TokenHandleRegistry.sol';\\n\\ncontract LensV2Migration {\\n    address internal immutable FEE_FOLLOW_MODULE;\\n    address internal immutable PROFILE_FOLLOW_MODULE;\\n    address internal immutable NEW_FEE_FOLLOW_MODULE;\\n\\n    LensHandles internal immutable lensHandles;\\n    TokenHandleRegistry internal immutable tokenHandleRegistry;\\n\\n    constructor(Types.MigrationParams memory migrationParams) {\\n        FEE_FOLLOW_MODULE = migrationParams.legacyFeeFollowModule;\\n        PROFILE_FOLLOW_MODULE = migrationParams.legacyProfileFollowModule;\\n        NEW_FEE_FOLLOW_MODULE = migrationParams.newFeeFollowModule;\\n        lensHandles = LensHandles(migrationParams.lensHandlesAddress);\\n        tokenHandleRegistry = TokenHandleRegistry(migrationParams.tokenHandleRegistryAddress);\\n    }\\n\\n    function batchMigrateProfiles(uint256[] calldata profileIds) external {\\n        MigrationLib.batchMigrateProfiles(profileIds, lensHandles, tokenHandleRegistry);\\n    }\\n\\n    // This is for public migration by themselves (so we only check the ownership of profile once)\\n    function batchMigrateFollows(\\n        uint256 followerProfileId,\\n        uint256[] calldata idsOfProfileFollowed,\\n        uint256[] calldata followTokenIds\\n    ) external {\\n        ValidationLib.validateAddressIsProfileOwnerOrDelegatedExecutor(msg.sender, followerProfileId);\\n\\n        MigrationLib.batchMigrateFollows(followerProfileId, idsOfProfileFollowed, followTokenIds);\\n    }\\n\\n    // This is for Whitelisted MigrationAdmin (so we only read the FollowNFT once)\\n    function batchMigrateFollowers(\\n        uint256[] calldata followerProfileIds,\\n        uint256 idOfProfileFollowed,\\n        uint256[] calldata followTokenIds\\n    ) external {\\n        if (!StorageLib.migrationAdminWhitelisted()[msg.sender]) {\\n            revert Errors.NotMigrationAdmin();\\n        }\\n\\n        MigrationLib.batchMigrateFollowers(followerProfileIds, idOfProfileFollowed, followTokenIds);\\n    }\\n\\n    function batchMigrateFollowModules(uint256[] calldata profileIds) external {\\n        MigrationLib.batchMigrateFollowModules(\\n            profileIds,\\n            FEE_FOLLOW_MODULE,\\n            PROFILE_FOLLOW_MODULE,\\n            NEW_FEE_FOLLOW_MODULE\\n        );\\n    }\\n\\n    function getProfileIdByHandleHash(bytes32 handleHash) external view returns (uint256) {\\n        return StorageLib.profileIdByHandleHash()[handleHash];\\n    }\\n\\n    function setMigrationAdmins(address[] memory migrationAdmins, bool whitelisted) external {\\n        ValidationLib.validateCallerIsGovernance();\\n        uint256 i;\\n        while (i < migrationAdmins.length) {\\n            StorageLib.migrationAdminWhitelisted()[migrationAdmins[i]] = whitelisted;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/ProfileCreationProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\\nimport {LensV2Migration} from 'contracts/misc/LensV2Migration.sol';\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\nimport {ImmutableOwnable} from 'contracts/misc/ImmutableOwnable.sol';\\n\\nimport {ILensHandles} from 'contracts/interfaces/ILensHandles.sol';\\nimport {ITokenHandleRegistry} from 'contracts/interfaces/ITokenHandleRegistry.sol';\\n\\n/**\\n * @title ProfileCreationProxy\\n * @author Lens Protocol\\n *\\n * @notice This is an ownable proxy contract that enforces \\\".lens\\\" handle suffixes at profile creation.\\n * Only the owner can create profiles.\\n */\\ncontract ProfileCreationProxy is ImmutableOwnable {\\n    ILensHandles immutable LENS_HANDLES;\\n    ITokenHandleRegistry immutable TOKEN_HANDLE_REGISTRY;\\n\\n    error ProfileAlreadyExists();\\n\\n    constructor(\\n        address owner,\\n        address hub,\\n        address lensHandles,\\n        address tokenHandleRegistry\\n    ) ImmutableOwnable(owner, hub) {\\n        LENS_HANDLES = ILensHandles(lensHandles);\\n        TOKEN_HANDLE_REGISTRY = ITokenHandleRegistry(tokenHandleRegistry);\\n    }\\n\\n    function proxyCreateProfile(\\n        Types.CreateProfileParams calldata createProfileParams\\n    ) external onlyOwner returns (uint256) {\\n        return ILensHub(LENS_HUB).createProfile(createProfileParams);\\n    }\\n\\n    function proxyCreateProfileWithHandle(\\n        Types.CreateProfileParams memory createProfileParams,\\n        string calldata handle\\n    ) external onlyOwner returns (uint256, uint256) {\\n        // Check if LensHubV1 already has a profile with this handle that was not migrated yet:\\n        bytes32 handleHash = keccak256(bytes(string.concat(handle, '.lens')));\\n        if (LensV2Migration(LENS_HUB).getProfileIdByHandleHash(handleHash) != 0) {\\n            revert ProfileAlreadyExists();\\n        }\\n\\n        // We mint the handle & profile to this contract first, then link it to the profile\\n        // This will not allow to initialize follow modules that require funds from the msg.sender,\\n        // but we assume only simple follow modules should be set during profile creation.\\n        // Complex ones can be set after the profile is created.\\n        address destination = createProfileParams.to;\\n        createProfileParams.to = address(this);\\n        uint256 profileId = ILensHub(LENS_HUB).createProfile(createProfileParams);\\n        uint256 handleId = LENS_HANDLES.mintHandle(address(this), handle);\\n\\n        TOKEN_HANDLE_REGISTRY.link({handleId: handleId, profileId: profileId});\\n\\n        // Transfer the handle & profile to the destination\\n        LENS_HANDLES.transferFrom(address(this), destination, handleId);\\n        ILensHub(LENS_HUB).transferFrom(address(this), destination, profileId);\\n\\n        return (profileId, handleId);\\n    }\\n\\n    function proxyCreateHandle(address to, string calldata handle) external onlyOwner returns (uint256) {\\n        return LENS_HANDLES.mintHandle(to, handle);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/namespaces/LensHandles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nimport {ERC721} from '@openzeppelin/contracts/token/ERC721/ERC721.sol';\\nimport {ImmutableOwnable} from 'contracts/misc/ImmutableOwnable.sol';\\nimport {ILensHandles} from 'contracts/interfaces/ILensHandles.sol';\\nimport {HandlesEvents} from 'contracts/namespaces/constants/Events.sol';\\nimport {HandlesErrors} from 'contracts/namespaces/constants/Errors.sol';\\nimport {HandleTokenURILib} from 'contracts/libraries/token-uris/HandleTokenURILib.sol';\\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport {ERC2981CollectionRoyalties} from 'contracts/base/ERC2981CollectionRoyalties.sol';\\nimport {IERC165} from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\n\\n/**\\n * A handle is defined as a local name inside a namespace context. A handle is represented as the local name with its\\n * namespace applied as a prefix, using the slash symbol as separator.\\n *\\n *      handle = namespace /@ localName\\n *\\n * Handle and local name can be used interchangeably once you are in a context of a namespace, as it became redundant.\\n *\\n *      handle === ${localName} ; inside some namespace.\\n *\\n * @custom:upgradeable Transparent upgradeable proxy without initializer.\\n */\\ncontract LensHandles is ERC721, ERC2981CollectionRoyalties, ImmutableOwnable, ILensHandles {\\n    using Address for address;\\n\\n    // We used 31 to fit the handle in a single slot, with `.lens` that restricted localName to use 26 characters.\\n    // Can be extended later if needed.\\n    uint256 internal constant MAX_LOCAL_NAME_LENGTH = 26;\\n    string public constant NAMESPACE = 'lens';\\n    uint256 internal immutable NAMESPACE_LENGTH = bytes(NAMESPACE).length;\\n    bytes32 public constant NAMESPACE_HASH = keccak256(bytes(NAMESPACE));\\n    uint256 public immutable TOKEN_GUARDIAN_COOLDOWN;\\n    uint256 internal constant GUARDIAN_ENABLED = type(uint256).max;\\n    mapping(address => uint256) internal _tokenGuardianDisablingTimestamp;\\n\\n    uint256 internal _profileRoyaltiesBps; // Slot 7\\n    uint256 private _totalSupply;\\n\\n    mapping(uint256 tokenId => string localName) internal _localNames;\\n\\n    modifier onlyOwnerOrWhitelistedProfileCreator() {\\n        if (msg.sender != OWNER && !ILensHub(LENS_HUB).isProfileCreatorWhitelisted(msg.sender)) {\\n            revert HandlesErrors.NotOwnerNorWhitelisted();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyEOA() {\\n        if (msg.sender.isContract()) {\\n            revert HandlesErrors.NotEOA();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyHub() {\\n        if (msg.sender != LENS_HUB) {\\n            revert HandlesErrors.NotHub();\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        address owner,\\n        address lensHub,\\n        uint256 tokenGuardianCooldown\\n    ) ERC721('', '') ImmutableOwnable(owner, lensHub) {\\n        TOKEN_GUARDIAN_COOLDOWN = tokenGuardianCooldown;\\n    }\\n\\n    function name() public pure override returns (string memory) {\\n        return string.concat(symbol(), ' Handles');\\n    }\\n\\n    function symbol() public pure override returns (string memory) {\\n        return string.concat(NAMESPACE);\\n    }\\n\\n    function totalSupply() external view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        _requireMinted(tokenId);\\n        return HandleTokenURILib.getTokenURI(tokenId, _localNames[tokenId], NAMESPACE);\\n    }\\n\\n    /// @inheritdoc ILensHandles\\n    function mintHandle(\\n        address to,\\n        string calldata localName\\n    ) external onlyOwnerOrWhitelistedProfileCreator returns (uint256) {\\n        _validateLocalName(localName);\\n        return _mintHandle(to, localName);\\n    }\\n\\n    function migrateHandle(address to, string calldata localName) external onlyHub returns (uint256) {\\n        _validateLocalNameMigration(localName);\\n        return _mintHandle(to, localName);\\n    }\\n\\n    function burn(uint256 tokenId) external {\\n        if (msg.sender != ownerOf(tokenId)) {\\n            revert HandlesErrors.NotOwner();\\n        }\\n        --_totalSupply;\\n        _burn(tokenId);\\n        delete _localNames[tokenId];\\n    }\\n\\n    /// ************************************\\n    /// ****  TOKEN GUARDIAN FUNCTIONS  ****\\n    /// ************************************\\n\\n    function DANGER__disableTokenGuardian() external override onlyEOA {\\n        if (_tokenGuardianDisablingTimestamp[msg.sender] != GUARDIAN_ENABLED) {\\n            revert HandlesErrors.DisablingAlreadyTriggered();\\n        }\\n        _tokenGuardianDisablingTimestamp[msg.sender] = block.timestamp + TOKEN_GUARDIAN_COOLDOWN;\\n        emit HandlesEvents.TokenGuardianStateChanged({\\n            wallet: msg.sender,\\n            enabled: false,\\n            tokenGuardianDisablingTimestamp: block.timestamp + TOKEN_GUARDIAN_COOLDOWN,\\n            timestamp: block.timestamp\\n        });\\n    }\\n\\n    function enableTokenGuardian() external override onlyEOA {\\n        if (_tokenGuardianDisablingTimestamp[msg.sender] == GUARDIAN_ENABLED) {\\n            revert HandlesErrors.AlreadyEnabled();\\n        }\\n        _tokenGuardianDisablingTimestamp[msg.sender] = GUARDIAN_ENABLED;\\n        emit HandlesEvents.TokenGuardianStateChanged({\\n            wallet: msg.sender,\\n            enabled: true,\\n            tokenGuardianDisablingTimestamp: GUARDIAN_ENABLED,\\n            timestamp: block.timestamp\\n        });\\n    }\\n\\n    function approve(address to, uint256 tokenId) public override(IERC721, ERC721) {\\n        // We allow removing approvals even if the wallet has the token guardian enabled\\n        if (to != address(0) && _hasTokenGuardianEnabled(ownerOf(tokenId))) {\\n            revert HandlesErrors.GuardianEnabled();\\n        }\\n        super.approve(to, tokenId);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public override(IERC721, ERC721) {\\n        // We allow removing approvals even if the wallet has the token guardian enabled\\n        if (approved && _hasTokenGuardianEnabled(msg.sender)) {\\n            revert HandlesErrors.GuardianEnabled();\\n        }\\n        super.setApprovalForAll(operator, approved);\\n    }\\n\\n    function exists(uint256 tokenId) external view override returns (bool) {\\n        return _exists(tokenId);\\n    }\\n\\n    function getNamespace() external pure returns (string memory) {\\n        return NAMESPACE;\\n    }\\n\\n    function getNamespaceHash() external pure returns (bytes32) {\\n        return NAMESPACE_HASH;\\n    }\\n\\n    function getLocalName(uint256 tokenId) public view returns (string memory) {\\n        string memory localName = _localNames[tokenId];\\n        if (bytes(localName).length == 0) {\\n            revert HandlesErrors.DoesNotExist();\\n        }\\n        return _localNames[tokenId];\\n    }\\n\\n    function getHandle(uint256 tokenId) public view returns (string memory) {\\n        string memory localName = getLocalName(tokenId);\\n        return string.concat(NAMESPACE, '/@', localName);\\n    }\\n\\n    function getTokenId(string memory localName) public pure returns (uint256) {\\n        return uint256(keccak256(bytes(localName)));\\n    }\\n\\n    function getTokenGuardianDisablingTimestamp(address wallet) external view override returns (uint256) {\\n        return _tokenGuardianDisablingTimestamp[wallet];\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC721, ERC2981CollectionRoyalties, IERC165) returns (bool) {\\n        return (ERC721.supportsInterface(interfaceId) || ERC2981CollectionRoyalties.supportsInterface(interfaceId));\\n    }\\n\\n    //////////////////////////////////////\\n    ///        INTERNAL FUNCTIONS      ///\\n    //////////////////////////////////////\\n\\n    function _mintHandle(address to, string calldata localName) internal returns (uint256) {\\n        uint256 tokenId = getTokenId(localName);\\n        ++_totalSupply;\\n        _mint(to, tokenId);\\n        _localNames[tokenId] = localName;\\n        emit HandlesEvents.HandleMinted(localName, NAMESPACE, tokenId, to, block.timestamp);\\n        return tokenId;\\n    }\\n\\n    /// @dev This function is used to validate the local name when migrating from V1 to V2.\\n    ///      As in V1 we also allowed the Hyphen '-' character, we need to allow it here as well and use a separate\\n    ///      validation function for migration VS newly created handles.\\n    function _validateLocalNameMigration(string memory localName) internal pure {\\n        bytes memory localNameAsBytes = bytes(localName);\\n        uint256 localNameLength = localNameAsBytes.length;\\n\\n        if (localNameLength == 0 || localNameLength > MAX_LOCAL_NAME_LENGTH) {\\n            revert HandlesErrors.HandleLengthInvalid();\\n        }\\n\\n        bytes1 firstByte = localNameAsBytes[0];\\n        if (firstByte == '-' || firstByte == '_') {\\n            revert HandlesErrors.HandleFirstCharInvalid();\\n        }\\n\\n        uint256 i;\\n        while (i < localNameLength) {\\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '-' && localNameAsBytes[i] != '_') {\\n                revert HandlesErrors.HandleContainsInvalidCharacters();\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @dev In V2 we only accept the following characters: [a-z0-9_] to be used in newly created handles.\\n    ///      We also disallow the first character to be an underscore '_'.\\n    function _validateLocalName(string memory localName) internal pure {\\n        bytes memory localNameAsBytes = bytes(localName);\\n        uint256 localNameLength = localNameAsBytes.length;\\n\\n        if (localNameLength == 0 || localNameLength > MAX_LOCAL_NAME_LENGTH) {\\n            revert HandlesErrors.HandleLengthInvalid();\\n        }\\n\\n        if (localNameAsBytes[0] == '_') {\\n            revert HandlesErrors.HandleFirstCharInvalid();\\n        }\\n\\n        uint256 i;\\n        while (i < localNameLength) {\\n            if (!_isAlphaNumeric(localNameAsBytes[i]) && localNameAsBytes[i] != '_') {\\n                revert HandlesErrors.HandleContainsInvalidCharacters();\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @dev We only accept lowercase characters to avoid confusion.\\n    /// @param char The character to check.\\n    /// @return True if the character is alphanumeric, false otherwise.\\n    function _isAlphaNumeric(bytes1 char) internal pure returns (bool) {\\n        return (char >= '0' && char <= '9') || (char >= 'a' && char <= 'z');\\n    }\\n\\n    function _hasTokenGuardianEnabled(address wallet) internal view returns (bool) {\\n        return\\n            !wallet.isContract() &&\\n            (_tokenGuardianDisablingTimestamp[wallet] == GUARDIAN_ENABLED ||\\n                block.timestamp < _tokenGuardianDisablingTimestamp[wallet]);\\n    }\\n\\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256 slot) {\\n        assembly {\\n            slot := _profileRoyaltiesBps.slot\\n        }\\n    }\\n\\n    function _getReceiver(uint256 /* tokenId */) internal view override returns (address) {\\n        return ILensHub(LENS_HUB).getTreasury();\\n    }\\n\\n    function _beforeRoyaltiesSet(uint256 /* royaltiesInBasisPoints */) internal view override {\\n        if (msg.sender != OWNER) {\\n            revert OnlyOwner();\\n        }\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 /* firstTokenId */,\\n        uint256 batchSize\\n    ) internal override {\\n        if (from != address(0) && _hasTokenGuardianEnabled(from)) {\\n            // Cannot transfer handle if the guardian is enabled, except at minting time.\\n            revert HandlesErrors.GuardianEnabled();\\n        }\\n\\n        super._beforeTokenTransfer(from, to, 0, batchSize);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/namespaces/TokenHandleRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nimport {IERC1271} from '@openzeppelin/contracts/interfaces/IERC1271.sol';\\nimport {ITokenHandleRegistry} from 'contracts/interfaces/ITokenHandleRegistry.sol';\\nimport {RegistryTypes} from 'contracts/namespaces/constants/Types.sol';\\nimport {Types} from 'contracts/libraries/constants/Types.sol';\\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\\nimport {RegistryErrors} from 'contracts/namespaces/constants/Errors.sol';\\nimport {RegistryEvents} from 'contracts/namespaces/constants/Events.sol';\\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\\nimport {ILensHandles} from 'contracts/interfaces/ILensHandles.sol';\\nimport {Typehash} from 'contracts/namespaces/constants/Typehash.sol';\\n\\n/**\\n * @title TokenHandleRegistry\\n * @author Lens Protocol\\n * @notice This contract is used to link a token with a handle.\\n * @custom:upgradeable Transparent upgradeable proxy without initializer.\\n */\\ncontract TokenHandleRegistry is ITokenHandleRegistry {\\n    string constant EIP712_DOMAIN_VERSION = '1';\\n    bytes32 constant EIP712_DOMAIN_VERSION_HASH = keccak256(bytes(EIP712_DOMAIN_VERSION));\\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\\n\\n    // First version of TokenHandleRegistry only works with Lens Profiles and .lens namespace.\\n    address immutable LENS_HUB;\\n    address immutable LENS_HANDLES;\\n\\n    // Using _handleHash(Handle) and _tokenHash(Token) as keys given that structs cannot be used as them.\\n    mapping(bytes32 handle => RegistryTypes.Token token) handleToToken;\\n    mapping(bytes32 token => RegistryTypes.Handle handle) tokenToHandle;\\n\\n    mapping(address signer => uint256 nonce) public nonces;\\n\\n    constructor(address lensHub, address lensHandles) {\\n        LENS_HUB = lensHub;\\n        LENS_HANDLES = lensHandles;\\n    }\\n\\n    // Lens V1 to Lens V2 migration function\\n    // WARNING: It is able to link the Token and Handle even if they're not in the same wallet.\\n    //          But it is designed to be only called from LensHub migration function, which assures that they are.\\n    function migrationLink(uint256 handleId, uint256 profileId) external {\\n        if (msg.sender != LENS_HUB) {\\n            revert RegistryErrors.OnlyLensHub();\\n        }\\n        _executeLinkage(\\n            RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId}),\\n            RegistryTypes.Token({collection: LENS_HUB, id: profileId}),\\n            address(0)\\n        );\\n    }\\n\\n    /// @inheritdoc ITokenHandleRegistry\\n    function link(uint256 handleId, uint256 profileId) external {\\n        _link(handleId, profileId, msg.sender);\\n    }\\n\\n    function linkWithSig(uint256 handleId, uint256 profileId, Types.EIP712Signature calldata signature) external {\\n        _validateLinkSignature(signature, handleId, profileId);\\n        _link(handleId, profileId, signature.signer);\\n    }\\n\\n    function _link(uint256 handleId, uint256 profileId, address transactionExecutor) private {\\n        // Handle and profile must be owned by the same address.\\n        // Caller should be the owner of the profile or one of its approved delegated executors.\\n        address profileOwner = ILensHub(LENS_HUB).ownerOf(profileId);\\n        if (profileOwner != ILensHandles(LENS_HANDLES).ownerOf(handleId)) {\\n            revert RegistryErrors.HandleAndTokenNotInSameWallet();\\n        }\\n        if (\\n            transactionExecutor != profileOwner &&\\n            !ILensHub(LENS_HUB).isDelegatedExecutorApproved(profileId, transactionExecutor)\\n        ) {\\n            revert RegistryErrors.DoesNotHavePermissions();\\n        }\\n        _executeLinkage(\\n            RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId}),\\n            RegistryTypes.Token({collection: LENS_HUB, id: profileId}),\\n            transactionExecutor\\n        );\\n    }\\n\\n    /// @notice This function is used to invalidate signatures by incrementing the nonce\\n    /// @param increment The amount to increment the nonce by\\n    function incrementNonce(uint8 increment) external {\\n        uint256 currentNonce = nonces[msg.sender];\\n        nonces[msg.sender] = currentNonce + increment;\\n        emit RegistryEvents.NonceUpdated(msg.sender, currentNonce + increment, block.timestamp);\\n    }\\n\\n    function _validateLinkSignature(\\n        Types.EIP712Signature calldata signature,\\n        uint256 handleId,\\n        uint256 profileId\\n    ) internal {\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.LINK,\\n                        handleId,\\n                        profileId,\\n                        _getNonceIncrementAndEmitEvent(signature.signer),\\n                        signature.deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    function _validateUnlinkSignature(\\n        Types.EIP712Signature calldata signature,\\n        uint256 handleId,\\n        uint256 profileId\\n    ) internal {\\n        _validateRecoveredAddress(\\n            _calculateDigest(\\n                keccak256(\\n                    abi.encode(\\n                        Typehash.UNLINK,\\n                        handleId,\\n                        profileId,\\n                        _getNonceIncrementAndEmitEvent(signature.signer),\\n                        signature.deadline\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n    }\\n\\n    /**\\n     * @dev Wrapper for ecrecover to reduce code size, used in meta-tx specific functions.\\n     */\\n    function _validateRecoveredAddress(bytes32 digest, Types.EIP712Signature calldata signature) private view {\\n        if (block.timestamp > signature.deadline) revert Errors.SignatureExpired();\\n        // If the expected address is a contract, check the signature there.\\n        if (signature.signer.code.length != 0) {\\n            bytes memory concatenatedSig = abi.encodePacked(signature.r, signature.s, signature.v);\\n            if (IERC1271(signature.signer).isValidSignature(digest, concatenatedSig) != EIP1271_MAGIC_VALUE) {\\n                revert Errors.SignatureInvalid();\\n            }\\n        } else {\\n            address recoveredAddress = ecrecover(digest, signature.v, signature.r, signature.s);\\n            if (recoveredAddress == address(0) || recoveredAddress != signature.signer) {\\n                revert Errors.SignatureInvalid();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates EIP712 digest based on the current DOMAIN_SEPARATOR.\\n     *\\n     * @param hashedMessage The message hash from which the digest should be calculated.\\n     *\\n     * @return bytes32 A 32-byte output representing the EIP712 digest.\\n     */\\n    function _calculateDigest(bytes32 hashedMessage) private view returns (bytes32) {\\n        return keccak256(abi.encodePacked('\\\\x19\\\\x01', calculateDomainSeparator(), hashedMessage));\\n    }\\n\\n    function calculateDomainSeparator() internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    Typehash.EIP712_DOMAIN,\\n                    keccak256('TokenHandleRegistry'),\\n                    EIP712_DOMAIN_VERSION_HASH,\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /// @inheritdoc ITokenHandleRegistry\\n    function unlink(uint256 handleId, uint256 profileId) external {\\n        _unlink(handleId, profileId, msg.sender);\\n    }\\n\\n    function unlinkWithSig(uint256 handleId, uint256 profileId, Types.EIP712Signature calldata signature) external {\\n        _validateUnlinkSignature(signature, handleId, profileId);\\n        _unlink(handleId, profileId, signature.signer);\\n    }\\n\\n    function _unlink(uint256 handleId, uint256 profileId, address transactionExecutor) private {\\n        if (handleId == 0 || profileId == 0) {\\n            revert RegistryErrors.DoesNotExist();\\n        }\\n        if (\\n            ILensHandles(LENS_HANDLES).exists(handleId) &&\\n            ILensHandles(LENS_HANDLES).ownerOf(handleId) != transactionExecutor &&\\n            ILensHub(LENS_HUB).exists(profileId) &&\\n            (ILensHub(LENS_HUB).ownerOf(profileId) != transactionExecutor &&\\n                !ILensHub(LENS_HUB).isDelegatedExecutorApproved(profileId, transactionExecutor))\\n        ) {\\n            revert RegistryErrors.NotHandleNorTokenOwner();\\n        }\\n        RegistryTypes.Handle memory handle = RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId});\\n        RegistryTypes.Token memory tokenPointedByHandle = handleToToken[_handleHash(handle)];\\n        // We check if the tokens are (were) linked for the case if some of them doesn't exist\\n        if (tokenPointedByHandle.id != profileId) {\\n            revert RegistryErrors.NotLinked();\\n        }\\n        _executeUnlinkage(handle, tokenPointedByHandle, transactionExecutor);\\n    }\\n\\n    /// @inheritdoc ITokenHandleRegistry\\n    function resolve(uint256 handleId) external view returns (uint256) {\\n        if (!ILensHandles(LENS_HANDLES).exists(handleId)) {\\n            revert RegistryErrors.DoesNotExist();\\n        }\\n        uint256 resolvedTokenId = _resolveHandleToToken(RegistryTypes.Handle({collection: LENS_HANDLES, id: handleId}))\\n            .id;\\n        if (resolvedTokenId == 0 || !ILensHub(LENS_HUB).exists(resolvedTokenId)) {\\n            return 0;\\n        }\\n        return resolvedTokenId;\\n    }\\n\\n    /// @inheritdoc ITokenHandleRegistry\\n    function getDefaultHandle(uint256 profileId) external view returns (uint256) {\\n        if (!ILensHub(LENS_HUB).exists(profileId)) {\\n            revert RegistryErrors.DoesNotExist();\\n        }\\n        uint256 defaultHandleId = _resolveTokenToHandle(RegistryTypes.Token({collection: LENS_HUB, id: profileId})).id;\\n        if (defaultHandleId == 0 || !ILensHandles(LENS_HANDLES).exists(defaultHandleId)) {\\n            return 0;\\n        }\\n        return defaultHandleId;\\n    }\\n\\n    //////////////////////////////////////\\n    ///        INTERNAL FUNCTIONS      ///\\n    //////////////////////////////////////\\n\\n    function _resolveHandleToToken(\\n        RegistryTypes.Handle memory handle\\n    ) internal view returns (RegistryTypes.Token storage) {\\n        return handleToToken[_handleHash(handle)];\\n    }\\n\\n    function _resolveTokenToHandle(\\n        RegistryTypes.Token memory token\\n    ) internal view returns (RegistryTypes.Handle storage) {\\n        return tokenToHandle[_tokenHash(token)];\\n    }\\n\\n    function _executeLinkage(\\n        RegistryTypes.Handle memory handle,\\n        RegistryTypes.Token memory token,\\n        address transactionExecutor\\n    ) internal {\\n        _deleteTokenToHandleLinkageIfAny(handle, transactionExecutor);\\n        handleToToken[_handleHash(handle)] = token;\\n\\n        _deleteHandleToTokenLinkageIfAny(token, transactionExecutor);\\n        tokenToHandle[_tokenHash(token)] = handle;\\n\\n        emit RegistryEvents.HandleLinked(handle, token, transactionExecutor, block.timestamp);\\n    }\\n\\n    function _deleteTokenToHandleLinkageIfAny(\\n        RegistryTypes.Handle memory handle,\\n        address transactionExecutor\\n    ) internal {\\n        RegistryTypes.Token memory tokenPointedByHandle = handleToToken[_handleHash(handle)];\\n        if (tokenPointedByHandle.collection != address(0) || tokenPointedByHandle.id != 0) {\\n            delete tokenToHandle[_tokenHash(tokenPointedByHandle)];\\n            emit RegistryEvents.HandleUnlinked(handle, tokenPointedByHandle, transactionExecutor, block.timestamp);\\n        }\\n    }\\n\\n    function _deleteHandleToTokenLinkageIfAny(RegistryTypes.Token memory token, address transactionExecutor) internal {\\n        RegistryTypes.Handle memory handlePointedByToken = tokenToHandle[_tokenHash(token)];\\n        if (handlePointedByToken.collection != address(0) || handlePointedByToken.id != 0) {\\n            delete handleToToken[_handleHash(handlePointedByToken)];\\n            emit RegistryEvents.HandleUnlinked(handlePointedByToken, token, transactionExecutor, block.timestamp);\\n        }\\n    }\\n\\n    function _executeUnlinkage(\\n        RegistryTypes.Handle memory handle,\\n        RegistryTypes.Token memory token,\\n        address transactionExecutor\\n    ) internal {\\n        delete handleToToken[_handleHash(handle)];\\n        // tokenToHandle is removed too, as the first version linkage is one-to-one.\\n        delete tokenToHandle[_tokenHash(token)];\\n        emit RegistryEvents.HandleUnlinked(handle, token, transactionExecutor, block.timestamp);\\n    }\\n\\n    function _handleHash(RegistryTypes.Handle memory handle) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(handle.collection, handle.id));\\n    }\\n\\n    function _tokenHash(RegistryTypes.Token memory token) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(token.collection, token.id));\\n    }\\n\\n    /**\\n     * @dev This fetches a signer's current nonce and increments it so it's ready for the next meta-tx. Also emits\\n     * the `NonceUpdated` event.\\n     *\\n     * @param signer The address to get and increment the nonce for.\\n     *\\n     * @return uint256 The current nonce for the given signer prior to being incremented.\\n     */\\n    function _getNonceIncrementAndEmitEvent(address signer) private returns (uint256) {\\n        uint256 currentNonce;\\n        unchecked {\\n            currentNonce = nonces[signer]++;\\n        }\\n        emit RegistryEvents.NonceUpdated(signer, currentNonce + 1, block.timestamp);\\n        return currentNonce;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/namespaces/constants/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nlibrary RegistryErrors {\\n    error NotHandleNorTokenOwner();\\n    error OnlyLensHub();\\n    error NotLinked();\\n    error DoesNotExist();\\n    error DoesNotHavePermissions();\\n    error HandleAndTokenNotInSameWallet();\\n    error SignatureInvalid();\\n}\\n\\nlibrary HandlesErrors {\\n    error HandleLengthInvalid();\\n    error HandleContainsInvalidCharacters();\\n    error HandleFirstCharInvalid();\\n    error NotOwnerNorWhitelisted();\\n    error NotOwner();\\n    error NotHub();\\n    error DoesNotExist();\\n    error NotEOA();\\n    error DisablingAlreadyTriggered();\\n    error GuardianEnabled();\\n    error AlreadyEnabled();\\n}\\n\"\r\n    },\r\n    \"contracts/namespaces/constants/Events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nimport {RegistryTypes} from 'contracts/namespaces/constants/Types.sol';\\n\\nlibrary HandlesEvents {\\n    event HandleMinted(string handle, string namespace, uint256 handleId, address to, uint256 timestamp);\\n\\n    /**\\n     * @dev Emitted when an address' Token Guardian state change is triggered.\\n     *\\n     * @param wallet The address whose Token Guardian state change is being triggered.\\n     * @param enabled True if the Token Guardian is being enabled, false if it is being disabled.\\n     * @param tokenGuardianDisablingTimestamp The UNIX timestamp when disabling the Token Guardian will take effect,\\n     * if disabling it. Zero if the protection is being enabled.\\n     * @param timestamp The UNIX timestamp of the change being triggered.\\n     */\\n    event TokenGuardianStateChanged(\\n        address indexed wallet,\\n        bool indexed enabled,\\n        uint256 tokenGuardianDisablingTimestamp,\\n        uint256 timestamp\\n    );\\n}\\n\\nlibrary RegistryEvents {\\n    event HandleLinked(\\n        RegistryTypes.Handle handle,\\n        RegistryTypes.Token token,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * WARNING: If a linked handle or token is burnt, this event will not be emitted.\\n     * Indexers should also take into account token burns through ERC-721 Transfer events to track all unlink actions.\\n     * The `resolveHandle` and `resolveToken` functions will properly reflect the unlink in any case.\\n     */\\n    event HandleUnlinked(\\n        RegistryTypes.Handle handle,\\n        RegistryTypes.Token token,\\n        address transactionExecutor,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a signer's nonce is used and, as a consequence, the next available nonce is updated.\\n     *\\n     * @param signer The signer whose next available nonce was updated.\\n     * @param nonce The next available nonce that can be used to execute a meta-tx successfully.\\n     * @param timestamp The UNIX timestamp of the nonce being used.\\n     */\\n    event NonceUpdated(address indexed signer, uint256 nonce, uint256 timestamp);\\n}\\n\"\r\n    },\r\n    \"contracts/namespaces/constants/Typehash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\nlibrary Typehash {\\n\\n    bytes32 constant EIP712_DOMAIN = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\\n\\n    bytes32 constant LINK = keccak256('Link(uint256 handleId,uint256 profileId,uint256 nonce,uint256 deadline)');\\n\\n    bytes32 constant UNLINK = keccak256('Unlink(uint256 handleId,uint256 profileId,uint256 nonce,uint256 deadline)');\\n}\\n\"\r\n    },\r\n    \"contracts/namespaces/constants/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title Namespaces Types\\n * @author Lens Protocol\\n */\\nlibrary RegistryTypes {\\n    struct Token {\\n        uint256 id; // SLOT 0\\n        address collection; // SLOT 1 - end\\n        // uint96 _gap; // SLOT 1 - start\\n    }\\n\\n    struct Handle {\\n        uint256 id; // SLOT 0\\n        address collection; // SLOT 1 - end\\n        // uint96 _gap; // SLOT 1 - start\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner or approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = ERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256, /* firstTokenId */\\n        uint256 batchSize\\n    ) internal virtual {\\n        if (batchSize > 1) {\\n            if (from != address(0)) {\\n                _balances[from] -= batchSize;\\n            }\\n            if (to != address(0)) {\\n                _balances[to] += batchSize;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@seadrop/=lib/seadrop/src/\",\r\n      \"ERC721A-Upgradeable/=lib/seadrop/lib/ERC721A-Upgradeable/contracts/\",\r\n      \"ERC721A/=lib/seadrop/lib/ERC721A/contracts/\",\r\n      \"create2-helpers/=lib/seadrop/lib/create2-helpers/\",\r\n      \"create2-scripts/=lib/seadrop/lib/create2-helpers/script/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/seadrop/lib/operator-filter-registry/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"murky/=lib/seadrop/lib/murky/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/seadrop/lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin-contracts/=lib/seadrop/lib/openzeppelin-contracts/contracts/\",\r\n      \"operator-filter-registry/=lib/seadrop/lib/operator-filter-registry/src/\",\r\n      \"seadrop/=lib/seadrop/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solmate/=lib/seadrop/lib/solmate/src/\",\r\n      \"utility-contracts/=lib/seadrop/lib/utility-contracts/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {\r\n      \"contracts/libraries/ActionLib.sol\": {\r\n        \"ActionLib\": \"0x7990dac84e3241fe314b980bba1466ac08715c4f\"\r\n      },\r\n      \"contracts/libraries/FollowLib.sol\": {\r\n        \"FollowLib\": \"0xe280cb21fb36b6b2d584428b809a6b822a5c2260\"\r\n      },\r\n      \"contracts/libraries/GovernanceLib.sol\": {\r\n        \"GovernanceLib\": \"0x5268512d20bf7653cf6d54b7c485ae3fbc658451\"\r\n      },\r\n      \"contracts/libraries/LegacyCollectLib.sol\": {\r\n        \"LegacyCollectLib\": \"0x5f0f24377c00f1517b4de496cf49eec8beb4ecb4\"\r\n      },\r\n      \"contracts/libraries/MetaTxLib.sol\": {\r\n        \"MetaTxLib\": \"0xf191c489e4ba0f448ea08a5fd27e9c928643f5c7\"\r\n      },\r\n      \"contracts/libraries/MigrationLib.sol\": {\r\n        \"MigrationLib\": \"0x0deced9ac3833b687d69d4eac6655f0f1279acee\"\r\n      },\r\n      \"contracts/libraries/ProfileLib.sol\": {\r\n        \"ProfileLib\": \"0x3fce2475a92c185f9634f5638f6b33306d77bb10\"\r\n      },\r\n      \"contracts/libraries/PublicationLib.sol\": {\r\n        \"PublicationLib\": \"0x90654f24a2c164a4da8f763ac8bc032d3d083a1b\"\r\n      },\r\n      \"contracts/libraries/ValidationLib.sol\": {\r\n        \"ValidationLib\": \"0x9cafd24d2851d9eb56e5a8fd394ab2ac0ef99849\"\r\n      },\r\n      \"contracts/libraries/token-uris/FollowTokenURILib.sol\": {\r\n        \"FollowTokenURILib\": \"0xc58f0e2a361e35c08619ef5f6122dc15180d783e\"\r\n      },\r\n      \"contracts/libraries/token-uris/HandleTokenURILib.sol\": {\r\n        \"HandleTokenURILib\": \"0x0e20f112689c7894ab8142108574e45d2650f529\"\r\n      },\r\n      \"contracts/libraries/token-uris/ProfileTokenURILib.sol\": {\r\n        \"ProfileTokenURILib\": \"0xf167835e74eecfe4bc571701d34fd38f4b61a830\"\r\n      }\r\n    }\r\n  },\r\n  \"language\": \"Solidity\"\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"hub\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lensHandles\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHandleRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwnerOrHub\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProfileAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LENS_HUB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"}],\"name\":\"proxyCreateHandle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"followModule\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"followModuleInitData\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.CreateProfileParams\",\"name\":\"createProfileParams\",\"type\":\"tuple\"}],\"name\":\"proxyCreateProfile\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"followModule\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"followModuleInitData\",\"type\":\"bytes\"}],\"internalType\":\"struct Types.CreateProfileParams\",\"name\":\"createProfileParams\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"}],\"name\":\"proxyCreateProfileWithHandle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ProfileCreationProxy", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "000000000000000000000000e7af8325aa443f7678b651d4f0de23663e818691000000000000000000000000db46d1dc155634fbc732f92e853b10b288ad5a1d000000000000000000000000e7e7ead361f3aacd73a61a9bd6c10ca17f38e945000000000000000000000000d4f2f33680fccb36748fa9831851643781608844", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}