{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/GenesisStaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract GenesisStaker {\\n    address public constant CRE = 0xe81432473290F4ffCFc5E823F8069Db83e8A677B;\\n    address public constant CREPE = 0x5516d551Af482B4eef4B909138d5e48e05a7f50a;\\n\\n    struct StakeConfig {\\n        uint32 start;\\n        uint32 end;\\n        uint128 exchangeRate;\\n        uint256 totalStaked;\\n        uint256 totalStaker;\\n    }\\n\\n    mapping(uint8 => StakeConfig) public stakeConfigs;\\n    mapping(uint8 => mapping(address => uint256)) public userStakedAmount;\\n\\n    event Stake(address indexed staker, uint8 stakeId, uint256 indexed unstakedAmount, uint256 indexed stakedAmount);\\n    event Unstake(address indexed staker, uint8 stakeId, uint256 indexed unstakedAmount);\\n\\n    constructor(uint32[3] memory start_, uint32[3] memory end_) {\\n        stakeConfigs[0] =\\n            StakeConfig({start: start_[0], end: end_[0], exchangeRate: 104 * 1e16, totalStaked: 0, totalStaker: 0});\\n\\n        stakeConfigs[1] =\\n            StakeConfig({start: start_[1], end: end_[1], exchangeRate: 112 * 1e16, totalStaked: 0, totalStaker: 0});\\n\\n        stakeConfigs[2] =\\n            StakeConfig({start: start_[2], end: end_[2], exchangeRate: 136 * 1e16, totalStaked: 0, totalStaker: 0});\\n    }\\n\\n    /// @notice burn CREPE tokens and record the balance for paying rewards in CRE tokens\\n    /// @param stakeId ID to identify lockup period(3, 6, 12 month)\\n    /// @param amount amount of CREPE token\\n    function stake(uint8 stakeId, uint256 amount) external {\\n        require(amount > 0, \\\"GenesisStaker: invalid amount\\\");\\n        require(stakeConfigs[stakeId].start > block.timestamp, \\\"GenesisStaker: already started\\\");\\n\\n        unchecked {\\n            if (userStakedAmount[stakeId][msg.sender] == 0) {\\n                stakeConfigs[stakeId].totalStaker++;\\n            }\\n\\n            // Since the total amount of CREPE tokens issued does not exceed the overflow range of uint256 type\\n            // there is no need to check overflow.\\n            userStakedAmount[stakeId][msg.sender] += amount;\\n            stakeConfigs[stakeId].totalStaked += amount;\\n        }\\n\\n        IERC20(CREPE).transferFrom(msg.sender, 0x000000000000000000000000000000000000dEaD, amount);\\n\\n        emit Stake(msg.sender, stakeId, lockedCreToken(stakeId), amount);\\n    }\\n\\n    function lockedCreToken(uint8 stakeId) public view returns (uint256) {\\n        unchecked {\\n            return userStakedAmount[stakeId][msg.sender] * stakeConfigs[stakeId].exchangeRate / 1e18;\\n        }\\n    }\\n\\n    /// @notice claim staking rewards after lockup period\\n    /// @param stakeId ID to identify lock-up period(3, 6, 12 month)\\n    function unstake(uint8 stakeId) external {\\n        require(stakeConfigs[stakeId].end <= block.timestamp, \\\"GenesisStaker: not ended\\\");\\n\\n        uint256 lockedCreAmount = lockedCreToken(stakeId);\\n\\n        uint256 stakedAmount = userStakedAmount[stakeId][msg.sender];\\n        require(stakedAmount > 0, \\\"GenesisStaker: not enough stake amount\\\");\\n\\n        unchecked {\\n            userStakedAmount[stakeId][msg.sender] = 0;\\n            stakeConfigs[stakeId].totalStaked -= stakedAmount;\\n            stakeConfigs[stakeId].totalStaker -= 1;\\n        }\\n\\n        IERC20(CRE).transfer(msg.sender, lockedCreAmount);\\n\\n        emit Unstake(msg.sender, stakeId, lockedCreAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin-upgradeable/contracts/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint32[3]\",\"name\":\"start_\",\"type\":\"uint32[3]\"},{\"internalType\":\"uint32[3]\",\"name\":\"end_\",\"type\":\"uint32[3]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"stakeId\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"unstakedAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"stakeId\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"unstakedAmount\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CRE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CREPE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"stakeId\",\"type\":\"uint8\"}],\"name\":\"lockedCreToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"stakeId\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"stakeConfigs\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"exchangeRate\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaker\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"stakeId\",\"type\":\"uint8\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GenesisStaker", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000064a20f800000000000000000000000000000000000000000000000000000000064a20f800000000000000000000000000000000000000000000000000000000064a20f80000000000000000000000000000000000000000000000000000000006518b6800000000000000000000000000000000000000000000000000000000065920080000000000000000000000000000000000000000000000000000000006681f180", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}