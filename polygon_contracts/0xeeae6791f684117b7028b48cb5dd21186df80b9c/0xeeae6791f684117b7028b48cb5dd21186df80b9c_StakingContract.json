{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"StakingContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./IStakingContract.sol\\\";\\nimport \\\"./IStakeChangeNotifier.sol\\\";\\n\\n/// @title Orbs staking smart contract.\\ncontract StakingContract is IStakingContract, IMigratableStakingContract {\\n    using SafeMath for uint256;\\n\\n    struct Stake {\\n        uint256 amount;\\n        uint256 cooldownAmount;\\n        uint256 cooldownEndTime;\\n    }\\n\\n    struct WithdrawResult {\\n        uint256 withdrawnAmount;\\n        uint256 stakedAmount;\\n        uint256 stakedAmountDiff;\\n    }\\n\\n    // The version of the smart contract.\\n    uint public constant VERSION = 1;\\n\\n    // The maximum number of approved staking contracts as migration destinations.\\n    uint public constant MAX_APPROVED_STAKING_CONTRACTS = 10;\\n\\n    // The mapping between stake owners and their data.\\n    mapping(address => Stake) internal stakes;\\n\\n    // Total amount of staked tokens (not including unstaked tokes in cooldown or pending withdrawal).\\n    uint256 internal totalStakedTokens;\\n\\n    // The period (in seconds) between a stake owner's request to stop staking and being able to withdraw them.\\n    uint256 public cooldownPeriodInSec;\\n\\n    // The address responsible for managing migration to a new staking contract.\\n    address public migrationManager;\\n\\n    // The address responsible for emergency operations and graceful return of staked tokens back to their owners.\\n    address public emergencyManager;\\n\\n    // The list of staking contracts that are approved by this contract. It would be only allowed to migrate a stake to\\n    // one of these contracts.\\n    IMigratableStakingContract[] public approvedStakingContracts;\\n\\n    // The address of the contract responsible for publishing stake change notifications.\\n    IStakeChangeNotifier public notifier;\\n\\n    // The address of the ORBS token.\\n    IERC20 internal token;\\n\\n    // Represents whether the contract accepts new staking requests. Please note, that even when it's turned off,\\n    // it'd be still possible to unstake or withdraw tokens.\\n    //\\n    // Note: This can be turned off only once by the emergency manager of the contract.\\n    bool public acceptingNewStakes = true;\\n\\n    // Represents whether this staking contract allows releasing all unstaked tokens unconditionally. When it's turned\\n    // on, stake owners could release their staked tokens, without explicitly requesting to unstake them, and their\\n    // previously unstaked tokens, regardless of the cooldown period. This also stops the contract from accepting new\\n    // stakes.\\n    //\\n    // Note: This can be turned off only once by the emergency manager of the contract.\\n    bool public releasingAllStakes = false;\\n\\n    event MigrationManagerUpdated(address indexed migrationManager);\\n    event MigrationDestinationAdded(IMigratableStakingContract indexed stakingContract);\\n    event MigrationDestinationRemoved(IMigratableStakingContract indexed stakingContract);\\n    event EmergencyManagerUpdated(address indexed emergencyManager);\\n    event StakeChangeNotifierUpdated(IStakeChangeNotifier indexed notifier);\\n    event StoppedAcceptingNewStake();\\n    event ReleasedAllStakes();\\n\\n    modifier onlyMigrationManager() {\\n        require(msg.sender == migrationManager, \\\"StakingContract: caller is not the migration manager\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyEmergencyManager() {\\n        require(msg.sender == emergencyManager, \\\"StakingContract: caller is not the emergency manager\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyWhenAcceptingNewStakes() {\\n        require(acceptingNewStakes && !releasingAllStakes, \\\"StakingContract: not accepting new stakes\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyWhenStakesReleased() {\\n        require(releasingAllStakes, \\\"StakingContract: not releasing all stakes\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyWhenStakesNotReleased() {\\n        require(!releasingAllStakes, \\\"StakingContract: releasing all stakes\\\");\\n\\n        _;\\n    }\\n\\n    /// @dev Initializes the staking contract.\\n    /// @param _cooldownPeriodInSec uint256 The period (in seconds) between a stake owner's request to stop staking and being\\n    /// able to withdraw them.\\n    /// @param _migrationManager address The address responsible for managing migration to a new staking contract.\\n    /// @param _emergencyManager address The address responsible for emergency operations and graceful return of staked\\n    /// tokens back to their owners.\\n    /// @param _token IERC20 The address of the ORBS token.\\n    constructor(uint256 _cooldownPeriodInSec, address _migrationManager, address _emergencyManager, IERC20 _token) public {\\n        require(_cooldownPeriodInSec > 0, \\\"StakingContract::ctor - cooldown period must be greater than 0\\\");\\n        require(_migrationManager != address(0), \\\"StakingContract::ctor - migration manager must not be 0\\\");\\n        require(_emergencyManager != address(0), \\\"StakingContract::ctor - emergency manager must not be 0\\\");\\n        require(address(_token) != address(0), \\\"StakingContract::ctor - ORBS token must not be 0\\\");\\n\\n        cooldownPeriodInSec = _cooldownPeriodInSec;\\n        migrationManager = _migrationManager;\\n        emergencyManager = _emergencyManager;\\n        token = _token;\\n    }\\n\\n    /// @dev Sets the address of the migration manager.\\n    /// @param _newMigrationManager address The address of the new migration manager.\\n    function setMigrationManager(address _newMigrationManager) external onlyMigrationManager {\\n        require(_newMigrationManager != address(0), \\\"StakingContract::setMigrationManager - address must not be 0\\\");\\n        require(migrationManager != _newMigrationManager,\\n            \\\"StakingContract::setMigrationManager - address must be different than the current address\\\");\\n\\n        migrationManager = _newMigrationManager;\\n\\n        emit MigrationManagerUpdated(_newMigrationManager);\\n    }\\n\\n    /// @dev Sets the address of the emergency manager.\\n    /// @param _newEmergencyManager address The address of the new emergency manager.\\n    function setEmergencyManager(address _newEmergencyManager) external onlyEmergencyManager {\\n        require(_newEmergencyManager != address(0), \\\"StakingContract::setEmergencyManager - address must not be 0\\\");\\n        require(emergencyManager != _newEmergencyManager,\\n            \\\"StakingContract::setEmergencyManager - address must be different than the current address\\\");\\n\\n        emergencyManager = _newEmergencyManager;\\n\\n        emit EmergencyManagerUpdated(_newEmergencyManager);\\n    }\\n\\n    /// @dev Sets the address of the stake change notifier contract.\\n    /// @param _newNotifier IStakeChangeNotifier The address of the new stake change notifier contract.\\n    ///\\n    /// Note: it's allowed to reset the notifier to a zero address.\\n    function setStakeChangeNotifier(IStakeChangeNotifier _newNotifier) external onlyMigrationManager {\\n        require(notifier != _newNotifier,\\n            \\\"StakingContract::setStakeChangeNotifier - address must be different than the current address\\\");\\n\\n        notifier = _newNotifier;\\n\\n        emit StakeChangeNotifierUpdated(notifier);\\n    }\\n\\n    /// @dev Adds a new contract to the list of approved staking contract migration destinations.\\n    /// @param _newStakingContract IMigratableStakingContract The new contract to add.\\n    function addMigrationDestination(IMigratableStakingContract _newStakingContract) external onlyMigrationManager {\\n        require(address(_newStakingContract) != address(0),\\n            \\\"StakingContract::addMigrationDestination - address must not be 0\\\");\\n\\n        uint length = approvedStakingContracts.length;\\n        require(length + 1 <= MAX_APPROVED_STAKING_CONTRACTS,\\n            \\\"StakingContract::addMigrationDestination - can't add more staking contracts\\\");\\n\\n        // Check for duplicates.\\n        for (uint i = 0; i < length; ++i) {\\n            require(approvedStakingContracts[i] != _newStakingContract,\\n                \\\"StakingContract::addMigrationDestination - can't add a duplicate staking contract\\\");\\n        }\\n\\n        approvedStakingContracts.push(_newStakingContract);\\n\\n        emit MigrationDestinationAdded(_newStakingContract);\\n    }\\n\\n    /// @dev Removes a contract from the list of approved staking contract migration destinations.\\n    /// @param _stakingContract IMigratableStakingContract The contract to remove.\\n    function removeMigrationDestination(IMigratableStakingContract _stakingContract) external onlyMigrationManager {\\n        require(address(_stakingContract) != address(0),\\n            \\\"StakingContract::removeMigrationDestination - address must not be 0\\\");\\n\\n        // Check for existence.\\n        (uint i, bool exists) = findApprovedStakingContractIndex(_stakingContract);\\n        require(exists, \\\"StakingContract::removeMigrationDestination - staking contract doesn't exist\\\");\\n\\n        // Swap the requested element with the last element and then delete it using pop/\\n        approvedStakingContracts[i] = approvedStakingContracts[approvedStakingContracts.length - 1];\\n        approvedStakingContracts.pop();\\n\\n        emit MigrationDestinationRemoved(_stakingContract);\\n    }\\n\\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\\n    /// the required amount using ERC20 approve.\\n    /// @param _amount uint256 The amount of tokens to stake.\\n    function stake(uint256 _amount) external override onlyWhenAcceptingNewStakes {\\n        address stakeOwner = msg.sender;\\n\\n        uint256 totalStakedAmount = stake(stakeOwner, _amount);\\n\\n        emit Staked(stakeOwner, _amount, totalStakedAmount);\\n\\n        // Note: we aren't concerned with reentrancy since:\\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\\n        //   2. The notifier is set and managed by the migration manager.\\n        stakeChange(stakeOwner, _amount, true, totalStakedAmount);\\n    }\\n\\n    /// @dev Unstakes ORBS tokens from msg.sender. If successful, this will start the cooldown period, after which\\n    /// msg.sender would be able to withdraw all of his tokens.\\n    /// @param _amount uint256 The amount of tokens to unstake.\\n    function unstake(uint256 _amount) external override {\\n        require(_amount > 0, \\\"StakingContract::unstake - amount must be greater than 0\\\");\\n\\n        address stakeOwner = msg.sender;\\n        Stake storage stakeData = stakes[stakeOwner];\\n        uint256 stakedAmount = stakeData.amount;\\n        uint256 cooldownAmount = stakeData.cooldownAmount;\\n        uint256 cooldownEndTime = stakeData.cooldownEndTime;\\n\\n        require(_amount <= stakedAmount, \\\"StakingContract::unstake - can't unstake more than the current stake\\\");\\n\\n        // If any tokens in cooldown are ready for withdrawal - revert. Stake owner should withdraw their unstaked\\n        // tokens first.\\n        require(cooldownAmount == 0 || cooldownEndTime > now,\\n            \\\"StakingContract::unstake - unable to unstake when there are tokens pending withdrawal\\\");\\n\\n        // Update the amount of tokens in cooldown. Please note that this will also restart the cooldown period of all\\n        // tokens in cooldown.\\n        stakeData.amount = stakedAmount.sub(_amount);\\n        stakeData.cooldownAmount = cooldownAmount.add(_amount);\\n        stakeData.cooldownEndTime = now.add(cooldownPeriodInSec);\\n\\n        totalStakedTokens = totalStakedTokens.sub(_amount);\\n\\n        uint256 totalStakedAmount = stakeData.amount;\\n\\n        emit Unstaked(stakeOwner, _amount, totalStakedAmount);\\n\\n        // Note: we aren't concerned with reentrancy since:\\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\\n        //   2. The notifier is set and managed by the migration manager.\\n        stakeChange(stakeOwner, _amount, false, totalStakedAmount);\\n    }\\n\\n    /// @dev Requests to withdraw all of staked ORBS tokens back to msg.sender. Stake owners can withdraw their ORBS\\n    /// tokens only after previously unstaking them and after the cooldown period has passed (unless the contract was\\n    /// requested to release all stakes).\\n    function withdraw() external override {\\n        address stakeOwner = msg.sender;\\n\\n        WithdrawResult memory res = withdraw(stakeOwner);\\n\\n        emit Withdrew(stakeOwner, res.withdrawnAmount, res.stakedAmount);\\n\\n        // Trigger staking state change notifications only if the staking amount was changed.\\n        if (res.stakedAmountDiff == 0) {\\n            return;\\n        }\\n\\n        // Note: we aren't concerned with reentrancy since:\\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\\n        //   2. The notifier is set and managed by the migration manager.\\n        stakeChange(stakeOwner, res.stakedAmountDiff, false, res.stakedAmount);\\n    }\\n\\n    /// @dev Restakes unstaked ORBS tokens (in or after cooldown) for msg.sender.\\n    function restake() external override onlyWhenAcceptingNewStakes {\\n        address stakeOwner = msg.sender;\\n        Stake storage stakeData = stakes[stakeOwner];\\n        uint256 cooldownAmount = stakeData.cooldownAmount;\\n\\n        require(cooldownAmount > 0, \\\"StakingContract::restake - no unstaked tokens\\\");\\n\\n        stakeData.amount = stakeData.amount.add(cooldownAmount);\\n        stakeData.cooldownAmount = 0;\\n        stakeData.cooldownEndTime = 0;\\n\\n        totalStakedTokens = totalStakedTokens.add(cooldownAmount);\\n\\n        uint256 totalStakedAmount = stakeData.amount;\\n\\n        emit Restaked(stakeOwner, cooldownAmount, totalStakedAmount);\\n\\n        // Note: we aren't concerned with reentrancy since:\\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\\n        //   2. The notifier is set and managed by the migration manager.\\n        stakeChange(stakeOwner, cooldownAmount, true, totalStakedAmount);\\n    }\\n\\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\\n    /// the required amount using ERC20 approve.\\n    /// @param _stakeOwner address The specified stake owner.\\n    /// @param _amount uint256 The amount of tokens to stake.\\n    function acceptMigration(address _stakeOwner, uint256 _amount) external override onlyWhenAcceptingNewStakes {\\n        uint256 totalStakedAmount = stake(_stakeOwner, _amount);\\n\\n        emit AcceptedMigration(_stakeOwner, _amount, totalStakedAmount);\\n\\n        // Note: we aren't concerned with reentrancy since:\\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\\n        //   2. The notifier is set and managed by the migration manager.\\n        stakeChange(_stakeOwner, _amount, true, totalStakedAmount);\\n    }\\n\\n    /// @dev Migrates the stake of msg.sender from this staking contract to a new approved staking contract.\\n    /// @param _newStakingContract IMigratableStakingContract The new staking contract which supports stake migration.\\n    /// @param _amount uint256 The amount of tokens to migrate.\\n    function migrateStakedTokens(IMigratableStakingContract _newStakingContract, uint256 _amount) external override\\n        onlyWhenStakesNotReleased {\\n        require(isApprovedStakingContract(_newStakingContract),\\n            \\\"StakingContract::migrateStakedTokens - migration destination wasn't approved\\\");\\n        require(_amount > 0, \\\"StakingContract::migrateStakedTokens - amount must be greater than 0\\\");\\n\\n        address stakeOwner = msg.sender;\\n        Stake storage stakeData = stakes[stakeOwner];\\n        uint256 stakedAmount = stakeData.amount;\\n\\n        require(stakedAmount > 0, \\\"StakingContract::migrateStakedTokens - no staked tokens\\\");\\n        require(_amount <= stakedAmount, \\\"StakingContract::migrateStakedTokens - amount exceeds staked token balance\\\");\\n\\n        stakeData.amount = stakedAmount.sub(_amount);\\n\\n        totalStakedTokens = totalStakedTokens.sub(_amount);\\n\\n        require(_newStakingContract.getToken() == token,\\n            \\\"StakingContract::migrateStakedTokens - staked tokens must be the same\\\");\\n        require(token.approve(address(_newStakingContract), _amount),\\n            \\\"StakingContract::migrateStakedTokens - couldn't approve transfer\\\");\\n\\n        emit MigratedStake(stakeOwner, _amount, stakeData.amount);\\n\\n        _newStakingContract.acceptMigration(stakeOwner, _amount);\\n\\n        // Note: we aren't concerned with reentrancy since:\\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\\n        //   2. The notifier is set and managed by the migration manager.\\n        stakeMigration(stakeOwner, _amount);\\n    }\\n\\n    /// @dev Distributes staking rewards to a list of addresses by directly adding rewards to their stakes. This method\\n    /// assumes that the user has already approved at least the required amount using ERC20 approve. Since this is a\\n    /// convenience method, we aren't concerned about reaching block gas limit by using large lists. We assume that\\n    /// callers will be able to batch/paginate their requests properly.\\n    /// @param _totalAmount uint256 The total amount of rewards to distribute.\\n    /// @param _stakeOwners address[] The addresses of the stake owners.\\n    /// @param _amounts uint256[] The amounts of the rewards.\\n    function distributeRewards(uint256 _totalAmount, address[] calldata _stakeOwners, uint256[] calldata _amounts) external override\\n        onlyWhenAcceptingNewStakes {\\n        require(_totalAmount > 0, \\\"StakingContract::distributeRewards - total amount must be greater than 0\\\");\\n\\n        uint256 stakeOwnersLength = _stakeOwners.length;\\n        uint256 amountsLength = _amounts.length;\\n\\n        require(stakeOwnersLength > 0 && amountsLength > 0,\\n            \\\"StakingContract::distributeRewards - lists can't be empty\\\");\\n        require(stakeOwnersLength == amountsLength,\\n            \\\"StakingContract::distributeRewards - lists must be of the same size\\\");\\n\\n        // Transfer all the tokens to the smart contract and update the stake owners list accordingly.\\n        require(token.transferFrom(msg.sender, address(this), _totalAmount),\\n            \\\"StakingContract::distributeRewards - insufficient allowance\\\");\\n\\n        bool[] memory signs = new bool[](amountsLength);\\n        uint256[] memory totalStakedAmounts = new uint256[](amountsLength);\\n\\n        uint256 expectedTotalAmount = 0;\\n        for (uint i = 0; i < stakeOwnersLength; ++i) {\\n            address stakeOwner = _stakeOwners[i];\\n            uint256 amount = _amounts[i];\\n\\n            require(stakeOwner != address(0), \\\"StakingContract::distributeRewards - stake owner can't be 0\\\");\\n            require(amount > 0, \\\"StakingContract::distributeRewards - amount must be greater than 0\\\");\\n\\n            Stake storage stakeData = stakes[stakeOwner];\\n            stakeData.amount = stakeData.amount.add(amount);\\n\\n            expectedTotalAmount = expectedTotalAmount.add(amount);\\n\\n            uint256 totalStakedAmount = stakeData.amount;\\n            signs[i] = true;\\n            totalStakedAmounts[i] = totalStakedAmount;\\n\\n            emit Staked(stakeOwner, amount, totalStakedAmount);\\n        }\\n\\n        require(_totalAmount == expectedTotalAmount, \\\"StakingContract::distributeRewards - incorrect total amount\\\");\\n\\n        totalStakedTokens = totalStakedTokens.add(_totalAmount);\\n\\n        // Note: we aren't concerned with reentrancy since:\\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\\n        //   2. The notifier is set and managed by the migration manager.\\n        stakeChangeBatch(_stakeOwners, _amounts, signs, totalStakedAmounts);\\n    }\\n\\n    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\\n    /// @param _stakeOwner address The address to check.\\n    /// @return uint256 The stake of the stake owner.\\n    function getStakeBalanceOf(address _stakeOwner) external override view returns (uint256) {\\n        return stakes[_stakeOwner].amount;\\n    }\\n\\n    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\\n    /// @return uint256 The total staked tokens of all stake owners.\\n    function getTotalStakedTokens() external override view returns (uint256) {\\n        return totalStakedTokens;\\n    }\\n\\n    /// @dev Returns the time that the cooldown period ends (or ended) and the amount of tokens to be released.\\n    /// @param _stakeOwner address The address to check.\\n    /// @return cooldownAmount uint256 The total tokens in cooldown.\\n    /// @return cooldownEndTime uint256 The time when the cooldown period ends (in seconds).\\n    function getUnstakeStatus(address _stakeOwner) external override view returns (uint256 cooldownAmount,\\n        uint256 cooldownEndTime) {\\n        Stake memory stakeData = stakes[_stakeOwner];\\n        cooldownAmount = stakeData.cooldownAmount;\\n        cooldownEndTime = stakeData.cooldownEndTime;\\n    }\\n\\n    /// @dev Returns the address of the underlying staked token.\\n    /// @return IERC20 The address of the token.\\n    function getToken() external override view returns (IERC20) {\\n        return token;\\n    }\\n\\n    /// @dev Requests the contract to stop accepting new staking requests.\\n    function stopAcceptingNewStakes() external onlyEmergencyManager onlyWhenAcceptingNewStakes {\\n        acceptingNewStakes = false;\\n\\n        emit StoppedAcceptingNewStake();\\n    }\\n\\n    /// @dev Requests the contract to release all stakes.\\n    function releaseAllStakes() external onlyEmergencyManager onlyWhenStakesNotReleased {\\n        releasingAllStakes = true;\\n\\n        emit ReleasedAllStakes();\\n    }\\n\\n    /// @dev Requests withdraw of released tokens for a list of addresses.\\n    /// @param _stakeOwners address[] The addresses of the stake owners.\\n    function withdrawReleasedStakes(address[] calldata _stakeOwners) external onlyWhenStakesReleased {\\n        uint256 stakeOwnersLength = _stakeOwners.length;\\n        uint256[] memory stakedAmountDiffs = new uint256[](stakeOwnersLength);\\n        bool[] memory signs = new bool[](stakeOwnersLength);\\n        uint256[] memory totalStakedAmounts = new uint256[](stakeOwnersLength);\\n\\n        for (uint i = 0; i < stakeOwnersLength; ++i) {\\n            address stakeOwner = _stakeOwners[i];\\n\\n            WithdrawResult memory res = withdraw(stakeOwner);\\n            stakedAmountDiffs[i] = res.stakedAmountDiff;\\n            signs[i] = false;\\n            totalStakedAmounts[i] = res.stakedAmount;\\n\\n            emit Withdrew(stakeOwner, res.withdrawnAmount, res.stakedAmount);\\n        }\\n\\n        // Note: we aren't concerned with reentrancy since:\\n        //   1. At this point, due to the CEI pattern, a reentrant notifier can't affect the effects of this method.\\n        //   2. The notifier is set and managed by the migration manager.\\n        stakeChangeBatch(_stakeOwners, stakedAmountDiffs, signs, totalStakedAmounts);\\n    }\\n\\n    /// @dev Returns whether a specific staking contract was approved as a migration destination.\\n    /// @param _stakingContract IMigratableStakingContract The staking contract to look for.\\n    /// @return exists bool The approval status.\\n    function isApprovedStakingContract(IMigratableStakingContract _stakingContract) public view returns (bool exists) {\\n        (, exists) = findApprovedStakingContractIndex(_stakingContract);\\n    }\\n\\n    /// @dev Returns whether stake change notification is enabled.\\n    function shouldNotifyStakeChange() view internal returns (bool) {\\n        return address(notifier) != address(0);\\n    }\\n\\n    /// @dev Notifies of stake change events.\\n    /// @param _stakeOwner address The address of the subject stake owner.\\n    /// @param _amount int256 The difference in the total staked amount.\\n    /// @param _sign bool The sign of the added (true) or subtracted (false) amount.\\n    /// @param _updatedStake uint256 The updated total staked amount.\\n    function stakeChange(address _stakeOwner, uint256 _amount, bool _sign, uint256 _updatedStake) internal {\\n        if (!shouldNotifyStakeChange()) {\\n            return;\\n        }\\n\\n        notifier.stakeChange(_stakeOwner, _amount, _sign, _updatedStake);\\n    }\\n\\n    /// @dev Notifies of multiple stake change events.\\n    /// @param _stakeOwners address[] The addresses of subject stake owners.\\n    /// @param _amounts uint256[] The differences in total staked amounts.\\n    /// @param _signs bool[] The signs of the added (true) or subtracted (false) amounts.\\n    /// @param _updatedStakes uint256[] The updated total staked amounts.\\n    function stakeChangeBatch(address[] memory _stakeOwners, uint256[] memory _amounts, bool[] memory _signs,\\n        uint256[] memory _updatedStakes) internal {\\n        if (!shouldNotifyStakeChange()) {\\n            return;\\n        }\\n\\n        notifier.stakeChangeBatch(_stakeOwners, _amounts, _signs, _updatedStakes);\\n    }\\n\\n    /// @dev Notifies of stake migration event.\\n    /// @param _stakeOwner address The address of the subject stake owner.\\n    /// @param _amount uint256 The migrated amount.\\n    function stakeMigration(address _stakeOwner, uint256 _amount) internal {\\n        if (!shouldNotifyStakeChange()) {\\n            return;\\n        }\\n\\n        notifier.stakeMigration(_stakeOwner, _amount);\\n    }\\n\\n    /// @dev Stakes amount of ORBS tokens on behalf of the specified stake owner.\\n    /// @param _stakeOwner address The specified stake owner.\\n    /// @param _amount uint256 The amount of tokens to stake.\\n    /// @return totalStakedAmount uint256 The total stake of the stake owner.\\n    function stake(address _stakeOwner, uint256 _amount) private returns (uint256 totalStakedAmount) {\\n        require(_stakeOwner != address(0), \\\"StakingContract::stake - stake owner can't be 0\\\");\\n        require(_amount > 0, \\\"StakingContract::stake - amount must be greater than 0\\\");\\n\\n        Stake storage stakeData = stakes[_stakeOwner];\\n        stakeData.amount = stakeData.amount.add(_amount);\\n\\n        totalStakedTokens = totalStakedTokens.add(_amount);\\n\\n        totalStakedAmount = stakeData.amount;\\n\\n        // Transfer the tokens to the smart contract and update the stake owners list accordingly.\\n        require(token.transferFrom(msg.sender, address(this), _amount),\\n            \\\"StakingContract::stake - insufficient allowance\\\");\\n    }\\n\\n    /// @dev Requests to withdraw all of staked ORBS tokens back to the specified stake owner. Stake owners can withdraw\\n    /// their ORBS tokens only after previously unstaking them and after the cooldown period has passed (unless the\\n    /// contract was requested to release all stakes).\\n    /// @return res WithdrawResult The result of the withdraw operation.\\n    function withdraw(address _stakeOwner) private returns (WithdrawResult memory res) {\\n        require(_stakeOwner != address(0), \\\"StakingContract::withdraw - stake owner can't be 0\\\");\\n\\n        Stake storage stakeData = stakes[_stakeOwner];\\n        res.stakedAmount = stakeData.amount;\\n        res.withdrawnAmount = stakeData.cooldownAmount;\\n        res.stakedAmountDiff = 0;\\n\\n        if (!releasingAllStakes) {\\n            require(res.withdrawnAmount > 0, \\\"StakingContract::withdraw - no unstaked tokens\\\");\\n            require(stakeData.cooldownEndTime <= now, \\\"StakingContract::withdraw - tokens are still in cooldown\\\");\\n        } else {\\n            // If the contract was requested to release all stakes - allow to withdraw all staked and unstaked tokens.\\n            res.withdrawnAmount = res.withdrawnAmount.add(res.stakedAmount);\\n            res.stakedAmountDiff = res.stakedAmount;\\n\\n            require(res.withdrawnAmount > 0, \\\"StakingContract::withdraw - no staked or unstaked tokens\\\");\\n\\n            stakeData.amount = 0;\\n\\n            totalStakedTokens = totalStakedTokens.sub(res.stakedAmount);\\n\\n            res.stakedAmount = 0;\\n        }\\n\\n        stakeData.cooldownAmount = 0;\\n        stakeData.cooldownEndTime = 0;\\n\\n        require(token.transfer(_stakeOwner, res.withdrawnAmount),\\n            \\\"StakingContract::withdraw - couldn't transfer stake\\\");\\n    }\\n\\n    /// @dev Returns an index of an existing approved staking contract.\\n    /// @param _stakingContract IMigratableStakingContract The staking contract to look for.\\n    /// @return index uint The index of the located staking contract (in the case that it was found).\\n    /// @return exists bool The search result.\\n    function findApprovedStakingContractIndex(IMigratableStakingContract _stakingContract) private view returns\\n        (uint index, bool exists) {\\n        uint length = approvedStakingContracts.length;\\n        for (index = 0; index < length; ++index) {\\n            if (approvedStakingContracts[index] == _stakingContract) {\\n                exists = true;\\n                return (index, exists);\\n            }\\n        }\\n\\n        exists = false;\\n    }\\n}\\n\"\r\n    },\r\n    \"IMigratableStakingContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title An interface for staking contracts which support stake migration.\\ninterface IMigratableStakingContract {\\n    /// @dev Returns the address of the underlying staked token.\\n    /// @return IERC20 The address of the token.\\n    function getToken() external view returns (IERC20);\\n\\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\\n    /// the required amount using ERC20 approve.\\n    /// @param _stakeOwner address The specified stake owner.\\n    /// @param _amount uint256 The number of tokens to stake.\\n    function acceptMigration(address _stakeOwner, uint256 _amount) external;\\n\\n    event AcceptedMigration(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\\n}\\n\"\r\n    },\r\n    \"IStakeChangeNotifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/// @title An interface for notifying of stake change events (e.g., stake, unstake, partial unstake, restate, etc.).\\ninterface IStakeChangeNotifier {\\n    /// @dev Notifies of stake change event.\\n    /// @param _stakeOwner address The address of the subject stake owner.\\n    /// @param _amount uint256 The difference in the total staked amount.\\n    /// @param _sign bool The sign of the added (true) or subtracted (false) amount.\\n    /// @param _updatedStake uint256 The updated total staked amount.\\n    function stakeChange(address _stakeOwner, uint256 _amount, bool _sign, uint256 _updatedStake) external;\\n\\n    /// @dev Notifies of multiple stake change events.\\n    /// @param _stakeOwners address[] The addresses of subject stake owners.\\n    /// @param _amounts uint256[] The differences in total staked amounts.\\n    /// @param _signs bool[] The signs of the added (true) or subtracted (false) amounts.\\n    /// @param _updatedStakes uint256[] The updated total staked amounts.\\n    function stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs,\\n        uint256[] calldata _updatedStakes) external;\\n\\n    /// @dev Notifies of stake migration event.\\n    /// @param _stakeOwner address The address of the subject stake owner.\\n    /// @param _amount uint256 The migrated amount.\\n    function stakeMigration(address _stakeOwner, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"IStakingContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IMigratableStakingContract.sol\\\";\\n\\n/// @title An interface for staking contracts.\\ninterface IStakingContract {\\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\\n    /// the required amount using ERC20 approve.\\n    /// @param _amount uint256 The amount of tokens to stake.\\n    function stake(uint256 _amount) external;\\n\\n    /// @dev Unstakes ORBS tokens from msg.sender. If successful, this will start the cooldown period, after which\\n    /// msg.sender would be able to withdraw all of his tokens.\\n    /// @param _amount uint256 The amount of tokens to unstake.\\n    function unstake(uint256 _amount) external;\\n\\n    /// @dev Requests to withdraw all of staked ORBS tokens back to msg.sender. Stake owners can withdraw their ORBS\\n    /// tokens only after previously unstaking them and after the cooldown period has passed (unless the contract was\\n    /// requested to release all stakes).\\n    function withdraw() external;\\n\\n    /// @dev Restakes unstaked ORBS tokens (in or after cooldown) for msg.sender.\\n    function restake() external;\\n\\n    /// @dev Distributes staking rewards to a list of addresses by directly adding rewards to their stakes. This method\\n    /// assumes that the user has already approved at least the required amount using ERC20 approve. Since this is a\\n    /// convenience method, we aren't concerned about reaching block gas limit by using large lists. We assume that\\n    /// callers will be able to properly batch/paginate their requests.\\n    /// @param _totalAmount uint256 The total amount of rewards to distribute.\\n    /// @param _stakeOwners address[] The addresses of the stake owners.\\n    /// @param _amounts uint256[] The amounts of the rewards.\\n    function distributeRewards(uint256 _totalAmount, address[] calldata _stakeOwners, uint256[] calldata _amounts) external;\\n\\n    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\\n    /// @param _stakeOwner address The address to check.\\n    /// @return uint256 The total stake.\\n    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);\\n\\n    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\\n    /// @return uint256 The total staked tokens of all stake owners.\\n    function getTotalStakedTokens() external view returns (uint256);\\n\\n    /// @dev Returns the time that the cooldown period ends (or ended) and the amount of tokens to be released.\\n    /// @param _stakeOwner address The address to check.\\n    /// @return cooldownAmount uint256 The total tokens in cooldown.\\n    /// @return cooldownEndTime uint256 The time when the cooldown period ends (in seconds).\\n    function getUnstakeStatus(address _stakeOwner) external view returns (uint256 cooldownAmount,\\n        uint256 cooldownEndTime);\\n\\n    /// @dev Migrates the stake of msg.sender from this staking contract to a new approved staking contract.\\n    /// @param _newStakingContract IMigratableStakingContract The new staking contract which supports stake migration.\\n    /// @param _amount uint256 The amount of tokens to migrate.\\n    function migrateStakedTokens(IMigratableStakingContract _newStakingContract, uint256 _amount) external;\\n\\n    event Staked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\\n    event Unstaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\\n    event Withdrew(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\\n    event Restaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\\n    event MigratedStake(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cooldownPeriodInSec\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_migrationManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_emergencyManager\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"AcceptedMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"emergencyManager\",\"type\":\"address\"}],\"name\":\"EmergencyManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"MigratedStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"stakingContract\",\"type\":\"address\"}],\"name\":\"MigrationDestinationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"stakingContract\",\"type\":\"address\"}],\"name\":\"MigrationDestinationRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"migrationManager\",\"type\":\"address\"}],\"name\":\"MigrationManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ReleasedAllStakes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"Restaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IStakeChangeNotifier\",\"name\":\"notifier\",\"type\":\"address\"}],\"name\":\"StakeChangeNotifierUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StoppedAcceptingNewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrew\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_APPROVED_STAKING_CONTRACTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"acceptMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptingNewStakes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"_newStakingContract\",\"type\":\"address\"}],\"name\":\"addMigrationDestination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedStakingContracts\",\"outputs\":[{\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownPeriodInSec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_stakeOwners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"distributeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeOwner\",\"type\":\"address\"}],\"name\":\"getStakeBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeOwner\",\"type\":\"address\"}],\"name\":\"getUnstakeStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cooldownAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownEndTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"_stakingContract\",\"type\":\"address\"}],\"name\":\"isApprovedStakingContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"_newStakingContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"migrateStakedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notifier\",\"outputs\":[{\"internalType\":\"contract IStakeChangeNotifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseAllStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releasingAllStakes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMigratableStakingContract\",\"name\":\"_stakingContract\",\"type\":\"address\"}],\"name\":\"removeMigrationDestination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newEmergencyManager\",\"type\":\"address\"}],\"name\":\"setEmergencyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMigrationManager\",\"type\":\"address\"}],\"name\":\"setMigrationManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStakeChangeNotifier\",\"name\":\"_newNotifier\",\"type\":\"address\"}],\"name\":\"setStakeChangeNotifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopAcceptingNewStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_stakeOwners\",\"type\":\"address[]\"}],\"name\":\"withdrawReleasedStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakingContract", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000127500000000000000000000000000b7d1068f267ab092973108f0f8cd914830cc1795000000000000000000000000b7d1068f267ab092973108f0f8cd914830cc1795000000000000000000000000614389eaae0a6821dc49062d56bda3d9d45fa2ff", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bd2a08f3f3797a16551c10401240093f8b3bbaa1aec3e85ad8a0930cef6c050e"}