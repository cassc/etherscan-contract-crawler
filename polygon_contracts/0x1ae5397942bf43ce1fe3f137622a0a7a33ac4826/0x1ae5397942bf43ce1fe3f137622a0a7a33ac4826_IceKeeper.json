{"SourceCode": "{\"IceKeeper.sol\":{\"content\":\"// SPDX-License-Identifier: -- DG --\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"MerkleProof.sol\\\";\\nimport \\\"SafeTransfer.sol\\\";\\n\\n/**\\n  * @title Smart Ice Keeper\\n  * @author Vitally Marinchenko\\n  */\\n\\ncontract IceKeeper is SafeTransfer {\\n\\n    address public constant distributionToken = address(\\n        0xc6C855AD634dCDAd23e64DA71Ba85b8C51E5aD7c\\n    );\\n\\n    uint256 public maximumDrop;\\n    uint256 public icedropCount;\\n\\n    uint256 public totalRequired;\\n    uint256 public totalCollected;\\n\\n    address public masterAccount;\\n\\n    struct Keeper {\\n        bytes32 root;\\n        uint256 total;\\n        uint256 claimed;\\n    }\\n\\n    mapping(address =\\u003e bool) public dropsWorkers;\\n    mapping(address =\\u003e bool) public claimWorkers;\\n\\n    mapping(uint256 =\\u003e string) public ipfsData;\\n    mapping(bytes32 =\\u003e Keeper) public icedrops;\\n\\n    mapping(bytes32 =\\u003e mapping(address =\\u003e bool)) public hasClaimed;\\n\\n    modifier onlyMaster() {\\n        require(\\n            msg.sender == masterAccount,\\n            \\u0027IceKeeper: invalid master\\u0027\\n        );\\n        _;\\n    }\\n\\n    modifier onlyDropsWorker() {\\n        require(\\n            dropsWorkers[msg.sender] == true,\\n            \\u0027IceKeeper: invalid drops worker\\u0027\\n        );\\n        _;\\n    }\\n\\n    modifier onlyClaimWorker() {\\n        require(\\n            claimWorkers[msg.sender] == true,\\n            \\u0027IceKeeper: invalid claim worker\\u0027\\n        );\\n        _;\\n    }\\n\\n    event Withdraw(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    event NewIcedrop(\\n        bytes32 indexed hash,\\n        address indexed master,\\n        string indexed ipfsAddress,\\n        uint256 total\\n    );\\n\\n    event Claimed(\\n        uint256 indexed index,\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    constructor(\\n        address _masterAccount,\\n        address _claimWorker,\\n        address _dropsWorker,\\n        uint256 _maximumDrop\\n    ) {\\n        masterAccount = _masterAccount;\\n\\n        claimWorkers[_claimWorker] = true;\\n        dropsWorkers[_dropsWorker] = true;\\n\\n        maximumDrop = _maximumDrop;\\n    }\\n\\n    function changeMaximumDrop(\\n        uint256 _newMaximumDrop\\n    )\\n        external\\n        onlyMaster\\n    {\\n        maximumDrop = _newMaximumDrop;\\n    }\\n\\n    function createIceDrop(\\n        bytes32 _root,\\n        uint256 _total,\\n        string calldata _ipfsAddress\\n    )\\n        external\\n        onlyDropsWorker\\n    {\\n        require(\\n            _total \\u003e 0,\\n            \\u0027IceKeeper: invalid total\\u0027\\n        );\\n\\n        bytes32 hash = getHash(\\n            _ipfsAddress\\n        );\\n\\n        require(\\n            icedrops[hash].total == 0,\\n            \\u0027IceKeeper: already created\\u0027\\n        );\\n\\n        icedrops[hash] = Keeper({\\n            root: _root,\\n            total: _total,\\n            claimed: 0\\n        });\\n\\n        icedropCount =\\n        icedropCount + 1;\\n\\n        ipfsData[icedropCount] = _ipfsAddress;\\n\\n        totalRequired =\\n        totalRequired + _total;\\n\\n        emit NewIcedrop(\\n            _root,\\n            masterAccount,\\n            _ipfsAddress,\\n            _total\\n        );\\n    }\\n\\n    function getHash(\\n        string calldata _ipfsAddress\\n    )\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                _ipfsAddress\\n            )\\n        );\\n    }\\n\\n    function isClaimed(\\n        bytes32 _hash,\\n        address _account\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return hasClaimed[_hash][_account];\\n    }\\n\\n    function getClaim(\\n        bytes32 _hash,\\n        uint256 _index,\\n        uint256 _amount,\\n        bytes32[] calldata _merkleProof\\n    )\\n        external\\n    {\\n        _doClaim(\\n            _hash,\\n            _index,\\n            _amount,\\n            msg.sender,\\n            _merkleProof\\n        );\\n    }\\n\\n    function getClaimBulk(\\n        bytes32[] calldata _hash,\\n        uint256[] calldata _index,\\n        uint256[] calldata _amount,\\n        bytes32[][] calldata _merkleProof\\n    )\\n        external\\n    {\\n        for (uint256 i = 0; i \\u003c _hash.length; i++) {\\n            _doClaim(\\n                _hash[i],\\n                _index[i],\\n                _amount[i],\\n                msg.sender,\\n                _merkleProof[i]\\n            );\\n        }\\n    }\\n\\n    function giveClaim(\\n        bytes32 _hash,\\n        uint256 _index,\\n        uint256 _amount,\\n        address _account,\\n        bytes32[] calldata _merkleProof\\n    )\\n        external\\n        onlyClaimWorker\\n    {\\n        _doClaim(\\n            _hash,\\n            _index,\\n            _amount,\\n            _account,\\n            _merkleProof\\n        );\\n    }\\n\\n    function giveClaimBulk(\\n        bytes32[] calldata _hash,\\n        uint256[] calldata _index,\\n        uint256[] calldata _amount,\\n        address[] calldata _account,\\n        bytes32[][] calldata _merkleProof\\n    )\\n        external\\n        onlyClaimWorker\\n    {\\n        for (uint256 i = 0; i \\u003c _hash.length; i++) {\\n            _doClaim(\\n                _hash[i],\\n                _index[i],\\n                _amount[i],\\n                _account[i],\\n                _merkleProof[i]\\n            );\\n        }\\n    }\\n\\n    function _doClaim(\\n        bytes32 _hash,\\n        uint256 _index,\\n        uint256 _amount,\\n        address _account,\\n        bytes32[] calldata _merkleProof\\n    )\\n        private\\n    {\\n        require(\\n            isClaimed(_hash, _account) == false,\\n            \\u0027IceKeeper: already claimed\\u0027\\n        );\\n\\n        require(\\n            _amount \\u003c= maximumDrop,\\n            \\u0027IceKeeper: invalid amount\\u0027\\n        );\\n\\n        bytes32 node = keccak256(\\n            abi.encodePacked(\\n                _index,\\n                _account,\\n                _amount\\n            )\\n        );\\n\\n        require(\\n            MerkleProof.verify(\\n                _merkleProof,\\n                icedrops[_hash].root,\\n                node\\n            ),\\n            \\u0027IceKeeper: invalid proof\\u0027\\n        );\\n\\n        icedrops[_hash].claimed =\\n        icedrops[_hash].claimed + _amount;\\n\\n        totalCollected =\\n        totalCollected + _amount;\\n\\n        require(\\n            icedrops[_hash].total \\u003e=\\n            icedrops[_hash].claimed,\\n            \\u0027IceKeeper: claim excess\\u0027\\n        );\\n\\n        _setClaimed(\\n            _hash,\\n            _account\\n        );\\n\\n        safeTransfer(\\n            distributionToken,\\n            _account,\\n            _amount\\n        );\\n\\n        emit Claimed(\\n            _index,\\n            _account,\\n            _amount\\n        );\\n    }\\n\\n    function _setClaimed(\\n        bytes32 _hash,\\n        address _account\\n    )\\n        private\\n    {\\n        hasClaimed[_hash][_account] = true;\\n    }\\n\\n    function withdrawFunds(\\n        uint256 _amount\\n    )\\n        external\\n        onlyMaster\\n    {\\n        safeTransfer(\\n            distributionToken,\\n            masterAccount,\\n            _amount\\n        );\\n\\n        emit Withdraw(\\n            masterAccount,\\n            _amount\\n        );\\n    }\\n\\n    function changeMaster(\\n        address _newMaster\\n    )\\n        external\\n        onlyMaster\\n    {\\n        masterAccount = _newMaster;\\n    }\\n\\n    function changeClaimWorker(\\n        address _claimWorker,\\n        bool _isWorker\\n    )\\n        external\\n        onlyMaster\\n    {\\n        claimWorkers[_claimWorker] = _isWorker;\\n    }\\n\\n    function changeDropsWorker(\\n        address _dropsWorker,\\n        bool _isWorker\\n    )\\n        external\\n        onlyMaster\\n    {\\n        dropsWorkers[_dropsWorker] = _isWorker;\\n    }\\n\\n    function getBalance()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return ERC20(distributionToken).balanceOf(\\n            address(this)\\n        );\\n    }\\n\\n    function showRemaining(\\n        bytes32 _hash\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return icedrops[_hash].total - icedrops[_hash].claimed;\\n    }\\n\\n    function showExcess(\\n        bytes32 _hash\\n    )\\n        external\\n        view\\n        returns (int256)\\n    {\\n        return int256(getBalance()) - int256(showRemaining(_hash));\\n    }\\n\\n    function showRemaining()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return totalRequired - totalCollected;\\n    }\\n\\n    function showExcess()\\n        external\\n        view\\n        returns (int256)\\n    {\\n        return int256(getBalance()) - int256(showRemaining());\\n    }\\n}\\n\"},\"MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: -- DG --\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees)\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    )\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i \\u003c proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash \\u003c= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"},\"SafeTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: -- ICE --\\n\\npragma solidity ^0.8.9;\\n\\ninterface ERC20 {\\n\\n    function balanceOf(\\n        address _iceKeeper\\n    )\\n        external\\n        view\\n        returns (uint256);\\n}\\n\\ncontract SafeTransfer {\\n\\n    bytes4 constant TRANSFER = bytes4(\\n        keccak256(\\n            bytes(\\n                \\u0027transfer(address,uint256)\\u0027\\n            )\\n        )\\n    );\\n\\n    function safeTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _value\\n    )\\n      internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                TRANSFER,\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\u0027TransferHelper: TRANSFER_FAILED\\u0027\\n        );\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_claimWorker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dropsWorker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maximumDrop\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"master\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"ipfsAddress\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"NewIcedrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_claimWorker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isWorker\",\"type\":\"bool\"}],\"name\":\"changeClaimWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dropsWorker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isWorker\",\"type\":\"bool\"}],\"name\":\"changeDropsWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMaster\",\"type\":\"address\"}],\"name\":\"changeMaster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaximumDrop\",\"type\":\"uint256\"}],\"name\":\"changeMaximumDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimWorkers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_ipfsAddress\",\"type\":\"string\"}],\"name\":\"createIceDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dropsWorkers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"getClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_hash\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_index\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[][]\"}],\"name\":\"getClaimBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_ipfsAddress\",\"type\":\"string\"}],\"name\":\"getHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"giveClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_hash\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_index\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_account\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[][]\"}],\"name\":\"giveClaimBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"icedropCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"icedrops\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ipfsData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumDrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"showExcess\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showExcess\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"showRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IceKeeper", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a61a0ed364e599ae4748d1ebe74bf236dd27b090000000000000000000000003c383b7ffd5d2bf24ebd1fc8509cefa9b7d1976f000000000000000000000000c6c855ad634dcdad23e64da71ba85b8c51e5ad7c0000000000000000000000000000000000000000000000056bc75e2d63100000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3c47b573b7e43a67019e92310a5bf53209319a4f040165f5f3fe143568f125e2"}