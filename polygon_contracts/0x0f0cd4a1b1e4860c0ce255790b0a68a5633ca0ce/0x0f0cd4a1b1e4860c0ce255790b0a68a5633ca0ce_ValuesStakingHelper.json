{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ValuesStakingHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IValuesStaking.sol';\\nimport './libraries/SafeMath.sol';\\n\\ncontract ValuesStakingHelper {\\n    using SafeMath for uint256;\\n\\n    address public immutable staking;\\n    address public immutable VALUES;\\n\\n    constructor(address _staking, address _VALUES) {\\n        require(_staking != address(0));\\n        staking = _staking;\\n        require(_VALUES != address(0));\\n        VALUES = _VALUES;\\n    }\\n\\n    function stake(uint256 _amount, address _recipient) external {\\n        IERC20(VALUES).transferFrom(msg.sender, address(this), _amount);\\n        IERC20(VALUES).approve(staking, _amount);\\n        IValuesStaking(staking).stake(_amount, _recipient);\\n        IValuesStaking(staking).claim(_recipient);\\n    }\\n\\n    function stakeToMany(\\n        uint256 _amount,\\n        address[] memory _recipients,\\n        uint256[] memory _shares\\n    ) external {\\n        require(\\n            _shares.length > 0 && _recipients.length > 0,\\n            'Must be at least one recipient and one share'\\n        );\\n        require(\\n            _shares.length == _recipients.length,\\n            'Recipients and shares length must be equal'\\n        );\\n        uint256 totalShare = 0;\\n        for (uint256 i; i < _shares.length; i++) {\\n            totalShare = totalShare + _shares[i];\\n        }\\n        require(\\n            totalShare == uint256(100000),\\n            'Total shares must equal 100000'\\n        );\\n        IERC20(VALUES).transferFrom(msg.sender, address(this), _amount);\\n        IERC20(VALUES).approve(staking, _amount);\\n        for (uint256 i; i < _recipients.length; i++) {\\n            uint256 _recipientAmount = _calculateShareAmount(\\n                _shares[i],\\n                _amount\\n            );\\n            IValuesStaking(staking).stake(_recipientAmount, _recipients[i]);\\n            IValuesStaking(staking).claim(_recipients[i]);\\n        }\\n    }\\n\\n    function _calculateShareAmount(uint256 share, uint256 amount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return amount.mul(share).div(uint256(100000));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\\ninterface IERC20Mintable {\\n  function mint( uint256 amount_ ) external;\\n\\n  function mint( address account_, uint256 ammount_ ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IValuesStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\ninterface IValuesStaking {\\n    function stake(uint256 _amount, address _recipient) external returns (bool);\\n\\n    function claim(address _recipient) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function sqrrt(uint256 a) internal pure returns (uint c) {\\n        if (a > 3) {\\n            c = a;\\n            uint b = add( div( a, 2), 1 );\\n            while (b < c) {\\n                c = b;\\n                b = div( add( div( a, b ), b), 2 );\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_VALUES\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"VALUES\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_shares\",\"type\":\"uint256[]\"}],\"name\":\"stakeToMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ValuesStakingHelper", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000022178820600751631bb2e93e85b259248d1e8eed0000000000000000000000005bf624b420f3adc7dec720998b7fb2a6edc8484c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}