{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/helpers/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { IERC721Receiver } from \\\"../interfaces/IERC721Receiver.sol\\\";\\n\\nimport \\\"./TransferHelperStructs.sol\\\";\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport {\\n    ConduitControllerInterface\\n} from \\\"../interfaces/ConduitControllerInterface.sol\\\";\\n\\nimport { Conduit } from \\\"../conduit/Conduit.sol\\\";\\n\\nimport { ConduitTransfer } from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\nimport {\\n    TransferHelperInterface\\n} from \\\"../interfaces/TransferHelperInterface.sol\\\";\\n\\nimport { TransferHelperErrors } from \\\"../interfaces/TransferHelperErrors.sol\\\";\\n\\n/**\\n * @title TransferHelper\\n * @author stephankmin, stuckinaboot, ryanio\\n * @notice TransferHelper is a utility contract for transferring\\n *         ERC20/ERC721/ERC1155 items in bulk to specific recipients.\\n */\\ncontract TransferHelper is TransferHelperInterface, TransferHelperErrors {\\n    // Allow for interaction with the conduit controller.\\n    ConduitControllerInterface internal immutable _CONDUIT_CONTROLLER;\\n\\n    // Set conduit creation code and runtime code hashes as immutable arguments.\\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\\n    bytes32 internal immutable _CONDUIT_RUNTIME_CODE_HASH;\\n\\n    /**\\n     * @dev Set the supplied conduit controller and retrieve its\\n     *      conduit creation code hash.\\n     *\\n     *\\n     * @param conduitController A contract that deploys conduits, or proxies\\n     *                          that may optionally be used to transfer approved\\n     *                          ERC20/721/1155 tokens.\\n     */\\n    constructor(address conduitController) {\\n        // Get the conduit creation code and runtime code hashes from the\\n        // supplied conduit controller and set them as an immutable.\\n        ConduitControllerInterface controller = ConduitControllerInterface(\\n            conduitController\\n        );\\n        (_CONDUIT_CREATION_CODE_HASH, _CONDUIT_RUNTIME_CODE_HASH) = controller\\n            .getConduitCodeHashes();\\n\\n        // Set the supplied conduit controller as an immutable.\\n        _CONDUIT_CONTROLLER = controller;\\n    }\\n\\n    /**\\n     * @notice Transfer multiple ERC20/ERC721/ERC1155 items to\\n     *         specified recipients.\\n     *\\n     * @param items      The items to transfer to an intended recipient.\\n     * @param conduitKey An optional conduit key referring to a conduit through\\n     *                   which the bulk transfer should occur.\\n     *\\n     * @return magicValue A value indicating that the transfers were successful.\\n     */\\n    function bulkTransfer(\\n        TransferHelperItemsWithRecipient[] calldata items,\\n        bytes32 conduitKey\\n    ) external override returns (bytes4 magicValue) {\\n        // Ensure that a conduit key has been supplied.\\n        if (conduitKey == bytes32(0)) {\\n            revert InvalidConduit(conduitKey, address(0));\\n        }\\n\\n        // Use conduit derived from supplied conduit key to perform transfers.\\n        _performTransfersWithConduit(items, conduitKey);\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.bulkTransfer.selector;\\n    }\\n\\n    /**\\n     * @notice Perform multiple transfers to specified recipients via the\\n     *         conduit derived from the provided conduit key.\\n     *\\n     * @param transfers  The items to transfer.\\n     * @param conduitKey The conduit key referring to the conduit through\\n     *                   which the bulk transfer should occur.\\n     */\\n    function _performTransfersWithConduit(\\n        TransferHelperItemsWithRecipient[] calldata transfers,\\n        bytes32 conduitKey\\n    ) internal {\\n        // Retrieve total number of transfers and place on stack.\\n        uint256 numTransfers = transfers.length;\\n\\n        // Derive the conduit address from the deployer, conduit key\\n        // and creation code hash.\\n        address conduit = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(_CONDUIT_CONTROLLER),\\n                            conduitKey,\\n                            _CONDUIT_CREATION_CODE_HASH\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Declare a variable to store the sum of all items across transfers.\\n        uint256 sumOfItemsAcrossAllTransfers;\\n\\n        // Skip overflow checks: all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over each transfer.\\n            for (uint256 i = 0; i < numTransfers; ++i) {\\n                // Retrieve the transfer in question.\\n                TransferHelperItemsWithRecipient calldata transfer = transfers[\\n                    i\\n                ];\\n\\n                // Increment totalItems by the number of items in the transfer.\\n                sumOfItemsAcrossAllTransfers += transfer.items.length;\\n            }\\n        }\\n\\n        // Declare a new array in memory with length totalItems to populate with\\n        // each conduit transfer.\\n        ConduitTransfer[] memory conduitTransfers = new ConduitTransfer[](\\n            sumOfItemsAcrossAllTransfers\\n        );\\n\\n        // Declare an index for storing ConduitTransfers in conduitTransfers.\\n        uint256 itemIndex;\\n\\n        // Skip overflow checks: all for loops are indexed starting at zero.\\n        unchecked {\\n            // Iterate over each transfer.\\n            for (uint256 i = 0; i < numTransfers; ++i) {\\n                // Retrieve the transfer in question.\\n                TransferHelperItemsWithRecipient calldata transfer = transfers[\\n                    i\\n                ];\\n\\n                // Retrieve the items of the transfer in question.\\n                TransferHelperItem[] calldata transferItems = transfer.items;\\n\\n                // Ensure recipient is not the zero address.\\n                _checkRecipientIsNotZeroAddress(transfer.recipient);\\n\\n                // Create a boolean indicating whether validateERC721Receiver\\n                // is true and recipient is a contract.\\n                bool callERC721Receiver = transfer.validateERC721Receiver &&\\n                    transfer.recipient.code.length != 0;\\n\\n                // Retrieve the total number of items in the transfer and\\n                // place on stack.\\n                uint256 numItemsInTransfer = transferItems.length;\\n\\n                // Iterate over each item in the transfer to create a\\n                // corresponding ConduitTransfer.\\n                for (uint256 j = 0; j < numItemsInTransfer; ++j) {\\n                    // Retrieve the item from the transfer.\\n                    TransferHelperItem calldata item = transferItems[j];\\n\\n                    if (item.itemType == ConduitItemType.ERC20) {\\n                        // Ensure that the identifier of an ERC20 token is 0.\\n                        if (item.identifier != 0) {\\n                            revert InvalidERC20Identifier();\\n                        }\\n                    }\\n\\n                    // If the item is an ERC721 token and\\n                    // callERC721Receiver is true...\\n                    if (item.itemType == ConduitItemType.ERC721) {\\n                        if (callERC721Receiver) {\\n                            // Check if the recipient implements\\n                            // onERC721Received for the given tokenId.\\n                            _checkERC721Receiver(\\n                                conduit,\\n                                transfer.recipient,\\n                                item.identifier\\n                            );\\n                        }\\n                    }\\n\\n                    // Create a ConduitTransfer corresponding to each\\n                    // TransferHelperItem.\\n                    conduitTransfers[itemIndex] = ConduitTransfer(\\n                        item.itemType,\\n                        item.token,\\n                        msg.sender,\\n                        transfer.recipient,\\n                        item.identifier,\\n                        item.amount\\n                    );\\n\\n                    // Increment the index for storing ConduitTransfers.\\n                    ++itemIndex;\\n                }\\n            }\\n        }\\n\\n        // Attempt the external call to transfer tokens via the derived conduit.\\n        try ConduitInterface(conduit).execute(conduitTransfers) returns (\\n            bytes4 conduitMagicValue\\n        ) {\\n            // Check if the value returned from the external call matches\\n            // the conduit `execute` selector.\\n            if (conduitMagicValue != ConduitInterface.execute.selector) {\\n                // If the external call fails, revert with the conduit key\\n                // and conduit address.\\n                revert InvalidConduit(conduitKey, conduit);\\n            }\\n        } catch Error(string memory reason) {\\n            // Catch reverts with a provided reason string and\\n            // revert with the reason, conduit key and conduit address.\\n            revert ConduitErrorRevertString(reason, conduitKey, conduit);\\n        } catch (bytes memory data) {\\n            // Conduits will throw a custom error when attempting to transfer\\n            // native token item types or an ERC721 item amount other than 1.\\n            // Bubble up these custom errors when encountered. Note that the\\n            // conduit itself will bubble up revert reasons from transfers as\\n            // well, meaning that these errors are not necessarily indicative of\\n            // an issue with the item type or amount in cases where the same\\n            // custom error signature is encountered during a conduit transfer.\\n\\n            // Set initial value of first four bytes of revert data to the mask.\\n            bytes4 customErrorSelector = bytes4(0xffffffff);\\n\\n            // Utilize assembly to read first four bytes (if present) directly.\\n            assembly {\\n                // Combine original mask with first four bytes of revert data.\\n                customErrorSelector := and(\\n                    mload(add(data, 0x20)), // Data begins after length offset.\\n                    customErrorSelector\\n                )\\n            }\\n\\n            // Pass through the custom error in question if the revert data is\\n            // the correct length and matches an expected custom error selector.\\n            if (\\n                data.length == 4 &&\\n                (customErrorSelector == InvalidItemType.selector ||\\n                    customErrorSelector == InvalidERC721TransferAmount.selector)\\n            ) {\\n                // \\\"Bubble up\\\" the revert reason.\\n                assembly {\\n                    revert(add(data, 0x20), 0x04)\\n                }\\n            }\\n\\n            // Catch all other reverts from the external call to the conduit and\\n            // include the conduit's raw revert reason as a data argument to a\\n            // new custom error.\\n            revert ConduitErrorRevertBytes(data, conduitKey, conduit);\\n        }\\n    }\\n\\n    /**\\n     * @notice An internal function to check if a recipient address implements\\n     *         onERC721Received for a given tokenId. Note that this check does\\n     *         not adhere to the safe transfer specification and is only meant\\n     *         to provide an additional layer of assurance that the recipient\\n     *         can receive the tokens \u2014 any hooks or post-transfer checks will\\n     *         fail and the caller will be the transfer helper rather than the\\n     *         ERC721 contract. Note that the conduit is set as the operator, as\\n     *         it will be the caller once the transfer is performed.\\n     *\\n     * @param conduit   The conduit to provide as the operator when calling\\n     *                  onERC721Received.\\n     * @param recipient The ERC721 recipient on which to call onERC721Received.\\n     * @param tokenId   The ERC721 tokenId of the token being transferred.\\n     */\\n    function _checkERC721Receiver(\\n        address conduit,\\n        address recipient,\\n        uint256 tokenId\\n    ) internal {\\n        // Check if recipient can receive ERC721 tokens.\\n        try\\n            IERC721Receiver(recipient).onERC721Received(\\n                conduit,\\n                msg.sender,\\n                tokenId,\\n                \\\"\\\"\\n            )\\n        returns (bytes4 selector) {\\n            // Check if onERC721Received selector is valid.\\n            if (selector != IERC721Receiver.onERC721Received.selector) {\\n                // Revert if recipient cannot accept\\n                // ERC721 tokens.\\n                revert InvalidERC721Recipient(recipient);\\n            }\\n        } catch (bytes memory data) {\\n            // \\\"Bubble up\\\" recipient's revert reason.\\n            revert ERC721ReceiverErrorRevertBytes(\\n                data,\\n                recipient,\\n                msg.sender,\\n                tokenId\\n            );\\n        } catch Error(string memory reason) {\\n            // \\\"Bubble up\\\" recipient's revert reason.\\n            revert ERC721ReceiverErrorRevertString(\\n                reason,\\n                recipient,\\n                msg.sender,\\n                tokenId\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice An internal function that reverts if the passed-in recipient\\n     *         is the zero address.\\n     *\\n     * @param recipient The recipient on which to perform the check.\\n     */\\n    function _checkRecipientIsNotZeroAddress(address recipient) internal pure {\\n        // Revert if the recipient is the zero address.\\n        if (recipient == address(0x0)) {\\n            revert RecipientCannotBeZeroAddress();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/TransferHelperStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { ConduitItemType } from \\\"../conduit/lib/ConduitEnums.sol\\\";\\n\\n/**\\n * @dev A TransferHelperItem specifies the itemType (ERC20/ERC721/ERC1155),\\n *      token address, token identifier, and amount of the token to be\\n *      transferred via the TransferHelper. For ERC20 tokens, identifier\\n *      must be 0. For ERC721 tokens, amount must be 1.\\n */\\nstruct TransferHelperItem {\\n    ConduitItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev A TransferHelperItemsWithRecipient specifies the tokens to transfer\\n *      via the TransferHelper, their intended recipient, and a boolean flag\\n *      indicating whether onERC721Received should be called on a recipient\\n *      contract.\\n */\\nstruct TransferHelperItemsWithRecipient {\\n    TransferHelperItem[] items;\\n    address recipient;\\n    bool validateERC721Receiver;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConduitInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\n/**\\n * @title ConduitInterface\\n * @author 0age\\n * @notice ConduitInterface contains all external function interfaces, events,\\n *         and errors for conduit contracts.\\n */\\ninterface ConduitInterface {\\n    /**\\n     * @dev Revert with an error when attempting to execute transfers using a\\n     *      caller that does not have an open channel.\\n     */\\n    error ChannelClosed(address channel);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update a channel to the\\n     *      current status of that channel.\\n     */\\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute a transfer for an\\n     *      item that does not have an ERC20/721/1155 item type.\\n     */\\n    error InvalidItemType();\\n\\n    /**\\n     * @dev Revert with an error when attempting to update the status of a\\n     *      channel from a caller that is not the conduit controller.\\n     */\\n    error InvalidController();\\n\\n    /**\\n     * @dev Emit an event whenever a channel is opened or closed.\\n     *\\n     * @param channel The channel that has been updated.\\n     * @param open    A boolean indicating whether the conduit is open or not.\\n     */\\n    event ChannelUpdated(address indexed channel, bool open);\\n\\n    /**\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\n     *         with an open channel can call this function.\\n     *\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function execute(ConduitTransfer[] calldata transfers)\\n        external\\n        returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\\n     *         open channel can call this function.\\n     *\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\\n     *         a caller with an open channel can call this function.\\n     *\\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata standardTransfers,\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Open or close a given channel. Only callable by the controller.\\n     *\\n     * @param channel The channel to open or close.\\n     * @param isOpen  The status of the channel (either open or closed).\\n     */\\n    function updateChannel(address channel, bool isOpen) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ConduitControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @title ConduitControllerInterface\\n * @author 0age\\n * @notice ConduitControllerInterface contains all external function interfaces,\\n *         structs, events, and errors for the conduit controller.\\n */\\ninterface ConduitControllerInterface {\\n    /**\\n     * @dev Track the conduit key, current owner, new potential owner, and open\\n     *      channels for each deployed conduit.\\n     */\\n    struct ConduitProperties {\\n        bytes32 key;\\n        address owner;\\n        address potentialOwner;\\n        address[] channels;\\n        mapping(address => uint256) channelIndexesPlusOne;\\n    }\\n\\n    /**\\n     * @dev Emit an event whenever a new conduit is created.\\n     *\\n     * @param conduit    The newly created conduit.\\n     * @param conduitKey The conduit key used to create the new conduit.\\n     */\\n    event NewConduit(address conduit, bytes32 conduitKey);\\n\\n    /**\\n     * @dev Emit an event whenever conduit ownership is transferred.\\n     *\\n     * @param conduit       The conduit for which ownership has been\\n     *                      transferred.\\n     * @param previousOwner The previous owner of the conduit.\\n     * @param newOwner      The new owner of the conduit.\\n     */\\n    event OwnershipTransferred(\\n        address indexed conduit,\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever a conduit owner registers a new potential\\n     *      owner for that conduit.\\n     *\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit using a\\n     *      conduit key where the first twenty bytes of the key do not match the\\n     *      address of the caller.\\n     */\\n    error InvalidCreator();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit when no\\n     *      initial owner address is supplied.\\n     */\\n    error InvalidInitialOwner();\\n\\n    /**\\n     * @dev Revert with an error when attempting to set a new potential owner\\n     *      that is already set.\\n     */\\n    error NewPotentialOwnerAlreadySet(\\n        address conduit,\\n        address newPotentialOwner\\n    );\\n\\n    /**\\n     * @dev Revert with an error when attempting to cancel ownership transfer\\n     *      when no new potential owner is currently set.\\n     */\\n    error NoPotentialOwnerCurrentlySet(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to interact with a conduit that\\n     *      does not yet exist.\\n     */\\n    error NoConduit();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a conduit that\\n     *      already exists.\\n     */\\n    error ConduitAlreadyExists(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update channels or transfer\\n     *      ownership of a conduit when the caller is not the owner of the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to register a new potential\\n     *      owner and supplying the null address.\\n     */\\n    error NewPotentialOwnerIsZeroAddress(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to claim ownership of a conduit\\n     *      with a caller that is not the current potential owner for the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotNewPotentialOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to retrieve a channel using an\\n     *      index that is out of range.\\n     */\\n    error ChannelOutOfRange(address conduit);\\n\\n    /**\\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\\n     *         an initial owner for the deployed conduit. Note that the first\\n     *         twenty bytes of the supplied conduit key must match the caller\\n     *         and that a new conduit cannot be created if one has already been\\n     *         deployed using the same conduit key.\\n     *\\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\\n     *                     the first twenty bytes of the conduit key must match\\n     *                     the caller of this contract.\\n     * @param initialOwner The initial owner to set for the new conduit.\\n     *\\n     * @return conduit The address of the newly deployed conduit.\\n     */\\n    function createConduit(bytes32 conduitKey, address initialOwner)\\n        external\\n        returns (address conduit);\\n\\n    /**\\n     * @notice Open or close a channel on a given conduit, thereby allowing the\\n     *         specified account to execute transfers against that conduit.\\n     *         Extreme care must be taken when updating channels, as malicious\\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\\n     *         tokens where the token holder has granted the conduit approval.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to open or close the channel.\\n     * @param channel The channel to open or close on the conduit.\\n     * @param isOpen  A boolean indicating whether to open or close the channel.\\n     */\\n    function updateChannel(\\n        address conduit,\\n        address channel,\\n        bool isOpen\\n    ) external;\\n\\n    /**\\n     * @notice Initiate conduit ownership transfer by assigning a new potential\\n     *         owner for the given conduit. Once set, the new potential owner\\n     *         may call `acceptOwnership` to claim ownership of the conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to initiate ownership transfer.\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    function transferOwnership(address conduit, address newPotentialOwner)\\n        external;\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any, from a conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to cancel ownership transfer.\\n     */\\n    function cancelOwnershipTransfer(address conduit) external;\\n\\n    /**\\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     *\\n     * @param conduit The conduit for which to accept ownership.\\n     */\\n    function acceptOwnership(address conduit) external;\\n\\n    /**\\n     * @notice Retrieve the current owner of a deployed conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated owner.\\n     *\\n     * @return owner The owner of the supplied conduit.\\n     */\\n    function ownerOf(address conduit) external view returns (address owner);\\n\\n    /**\\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\\n     *         lookup.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated conduit\\n     *                key.\\n     *\\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\\n     */\\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\\n\\n    /**\\n     * @notice Derive the conduit associated with a given conduit key and\\n     *         determine whether that conduit exists (i.e. whether it has been\\n     *         deployed).\\n     *\\n     * @param conduitKey The conduit key used to derive the conduit.\\n     *\\n     * @return conduit The derived address of the conduit.\\n     * @return exists  A boolean indicating whether the derived conduit has been\\n     *                 deployed or not.\\n     */\\n    function getConduit(bytes32 conduitKey)\\n        external\\n        view\\n        returns (address conduit, bool exists);\\n\\n    /**\\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\\n     *         current owner may set a new potential owner via\\n     *         `transferOwnership` and that owner may then accept ownership of\\n     *         the conduit in question via `acceptOwnership`.\\n     *\\n     * @param conduit The conduit for which to retrieve the potential owner.\\n     *\\n     * @return potentialOwner The potential owner, if any, for the conduit.\\n     */\\n    function getPotentialOwner(address conduit)\\n        external\\n        view\\n        returns (address potentialOwner);\\n\\n    /**\\n     * @notice Retrieve the status (either open or closed) of a given channel on\\n     *         a conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the channel status.\\n     * @param channel The channel for which to retrieve the status.\\n     *\\n     * @return isOpen The status of the channel on the given conduit.\\n     */\\n    function getChannelStatus(address conduit, address channel)\\n        external\\n        view\\n        returns (bool isOpen);\\n\\n    /**\\n     * @notice Retrieve the total number of open channels for a given conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the total channel count.\\n     *\\n     * @return totalChannels The total number of open channels for the conduit.\\n     */\\n    function getTotalChannels(address conduit)\\n        external\\n        view\\n        returns (uint256 totalChannels);\\n\\n    /**\\n     * @notice Retrieve an open channel at a specific index for a given conduit.\\n     *         Note that the index of a channel can change as a result of other\\n     *         channels being closed on the conduit.\\n     *\\n     * @param conduit      The conduit for which to retrieve the open channel.\\n     * @param channelIndex The index of the channel in question.\\n     *\\n     * @return channel The open channel, if any, at the specified channel index.\\n     */\\n    function getChannel(address conduit, uint256 channelIndex)\\n        external\\n        view\\n        returns (address channel);\\n\\n    /**\\n     * @notice Retrieve all open channels for a given conduit. Note that calling\\n     *         this function for a conduit with many channels will revert with\\n     *         an out-of-gas error.\\n     *\\n     * @param conduit The conduit for which to retrieve open channels.\\n     *\\n     * @return channels An array of open channels on the given conduit.\\n     */\\n    function getChannels(address conduit)\\n        external\\n        view\\n        returns (address[] memory channels);\\n\\n    /**\\n     * @dev Retrieve the conduit creation code and runtime code hashes.\\n     */\\n    function getConduitCodeHashes()\\n        external\\n        view\\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/Conduit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { ConduitInterface } from \\\"../interfaces/ConduitInterface.sol\\\";\\n\\nimport { ConduitItemType } from \\\"./lib/ConduitEnums.sol\\\";\\n\\nimport { TokenTransferrer } from \\\"../lib/TokenTransferrer.sol\\\";\\n\\nimport {\\n    ConduitTransfer,\\n    ConduitBatch1155Transfer\\n} from \\\"./lib/ConduitStructs.sol\\\";\\n\\nimport \\\"./lib/ConduitConstants.sol\\\";\\n\\n/**\\n * @title Conduit\\n * @author 0age\\n * @notice This contract serves as an originator for \\\"proxied\\\" transfers. Each\\n *         conduit is deployed and controlled by a \\\"conduit controller\\\" that can\\n *         add and remove \\\"channels\\\" or contracts that can instruct the conduit\\n *         to transfer approved ERC20/721/1155 tokens. *IMPORTANT NOTE: each\\n *         conduit has an owner that can arbitrarily add or remove channels, and\\n *         a malicious or negligent owner can add a channel that allows for any\\n *         approved ERC20/721/1155 tokens to be taken immediately \u2014 be extremely\\n *         cautious with what conduits you give token approvals to!*\\n */\\ncontract Conduit is ConduitInterface, TokenTransferrer {\\n    // Set deployer as an immutable controller that can update channel statuses.\\n    address private immutable _controller;\\n\\n    // Track the status of each channel.\\n    mapping(address => bool) private _channels;\\n\\n    /**\\n     * @notice Ensure that the caller is currently registered as an open channel\\n     *         on the conduit.\\n     */\\n    modifier onlyOpenChannel() {\\n        // Utilize assembly to access channel storage mapping directly.\\n        assembly {\\n            // Write the caller to scratch space.\\n            mstore(ChannelKey_channel_ptr, caller())\\n\\n            // Write the storage slot for _channels to scratch space.\\n            mstore(ChannelKey_slot_ptr, _channels.slot)\\n\\n            // Derive the position in storage of _channels[msg.sender]\\n            // and check if the stored value is zero.\\n            if iszero(\\n                sload(keccak256(ChannelKey_channel_ptr, ChannelKey_length))\\n            ) {\\n                // The caller is not an open channel; revert with\\n                // ChannelClosed(caller). First, set error signature in memory.\\n                mstore(ChannelClosed_error_ptr, ChannelClosed_error_signature)\\n\\n                // Next, set the caller as the argument.\\n                mstore(ChannelClosed_channel_ptr, caller())\\n\\n                // Finally, revert, returning full custom error with argument.\\n                revert(ChannelClosed_error_ptr, ChannelClosed_error_length)\\n            }\\n        }\\n\\n        // Continue with function execution.\\n        _;\\n    }\\n\\n    /**\\n     * @notice In the constructor, set the deployer as the controller.\\n     */\\n    constructor() {\\n        // Set the deployer as the controller.\\n        _controller = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function execute(ConduitTransfer[] calldata transfers)\\n        external\\n        override\\n        onlyOpenChannel\\n        returns (bytes4 magicValue)\\n    {\\n        // Retrieve the total number of transfers and place on the stack.\\n        uint256 totalStandardTransfers = transfers.length;\\n\\n        // Iterate over each transfer.\\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\\n            // Retrieve the transfer in question and perform the transfer.\\n            _transfer(transfers[i]);\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.execute.selector;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of batch 1155 item transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param batchTransfers The 1155 batch item transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the item transfers were\\n     *                    performed successfully.\\n     */\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\\n        // Perform 1155 batch transfers. Note that memory should be considered\\n        // entirely corrupted from this point forward.\\n        _performERC1155BatchTransfers(batchTransfers);\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.executeBatch1155.selector;\\n    }\\n\\n    /**\\n     * @notice Execute a sequence of transfers, both single ERC20/721/1155 item\\n     *         transfers as well as batch 1155 item transfers. Only a caller\\n     *         with an open channel can call this function. Note that channels\\n     *         are expected to implement reentrancy protection if desired, and\\n     *         that cross-channel reentrancy may be possible if the conduit has\\n     *         multiple open channels at once. Also note that channels are\\n     *         expected to implement checks against transferring any zero-amount\\n     *         items if that constraint is desired.\\n     *\\n     * @param standardTransfers The ERC20/721/1155 item transfers to perform.\\n     * @param batchTransfers    The 1155 batch item transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the item transfers were\\n     *                    performed successfully.\\n     */\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata standardTransfers,\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\\n        // Retrieve the total number of transfers and place on the stack.\\n        uint256 totalStandardTransfers = standardTransfers.length;\\n\\n        // Iterate over each standard transfer.\\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\\n            // Retrieve the transfer in question and perform the transfer.\\n            _transfer(standardTransfers[i]);\\n\\n            // Skip overflow check as for loop is indexed starting at zero.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Perform 1155 batch transfers. Note that memory should be considered\\n        // entirely corrupted from this point forward aside from the free memory\\n        // pointer having the default value.\\n        _performERC1155BatchTransfers(batchTransfers);\\n\\n        // Return a magic value indicating that the transfers were performed.\\n        magicValue = this.executeWithBatch1155.selector;\\n    }\\n\\n    /**\\n     * @notice Open or close a given channel. Only callable by the controller.\\n     *\\n     * @param channel The channel to open or close.\\n     * @param isOpen  The status of the channel (either open or closed).\\n     */\\n    function updateChannel(address channel, bool isOpen) external override {\\n        // Ensure that the caller is the controller of this contract.\\n        if (msg.sender != _controller) {\\n            revert InvalidController();\\n        }\\n\\n        // Ensure that the channel does not already have the indicated status.\\n        if (_channels[channel] == isOpen) {\\n            revert ChannelStatusAlreadySet(channel, isOpen);\\n        }\\n\\n        // Update the status of the channel.\\n        _channels[channel] = isOpen;\\n\\n        // Emit a corresponding event.\\n        emit ChannelUpdated(channel, isOpen);\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer a given ERC20/721/1155 item. Note that\\n     *      channels are expected to implement checks against transferring any\\n     *      zero-amount items if that constraint is desired.\\n     *\\n     * @param item The ERC20/721/1155 item to transfer.\\n     */\\n    function _transfer(ConduitTransfer calldata item) internal {\\n        // Determine the transfer method based on the respective item type.\\n        if (item.itemType == ConduitItemType.ERC20) {\\n            // Transfer ERC20 token. Note that item.identifier is ignored and\\n            // therefore ERC20 transfer items are potentially malleable \u2014 this\\n            // check should be performed by the calling channel if a constraint\\n            // on item malleability is desired.\\n            _performERC20Transfer(item.token, item.from, item.to, item.amount);\\n        } else if (item.itemType == ConduitItemType.ERC721) {\\n            // Ensure that exactly one 721 item is being transferred.\\n            if (item.amount != 1) {\\n                revert InvalidERC721TransferAmount();\\n            }\\n\\n            // Transfer ERC721 token.\\n            _performERC721Transfer(\\n                item.token,\\n                item.from,\\n                item.to,\\n                item.identifier\\n            );\\n        } else if (item.itemType == ConduitItemType.ERC1155) {\\n            // Transfer ERC1155 token.\\n            _performERC1155Transfer(\\n                item.token,\\n                item.from,\\n                item.to,\\n                item.identifier,\\n                item.amount\\n            );\\n        } else {\\n            // Throw with an error.\\n            revert InvalidItemType();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { ConduitItemType } from \\\"./ConduitEnums.sol\\\";\\n\\nstruct ConduitTransfer {\\n    ConduitItemType itemType;\\n    address token;\\n    address from;\\n    address to;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\nstruct ConduitBatch1155Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256[] ids;\\n    uint256[] amounts;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TransferHelperInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport {\\n    TransferHelperItem,\\n    TransferHelperItemsWithRecipient\\n} from \\\"../helpers/TransferHelperStructs.sol\\\";\\n\\ninterface TransferHelperInterface {\\n    /**\\n     * @notice Transfer multiple items to a single recipient.\\n     *\\n     * @param items The items to transfer.\\n     * @param conduitKey  The key of the conduit performing the bulk transfer.\\n     */\\n    function bulkTransfer(\\n        TransferHelperItemsWithRecipient[] calldata items,\\n        bytes32 conduitKey\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/TransferHelperErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @title TransferHelperErrors\\n */\\ninterface TransferHelperErrors {\\n    /**\\n     * @dev Revert with an error when attempting to execute transfers with a\\n     *      NATIVE itemType.\\n     */\\n    error InvalidItemType();\\n\\n    /**\\n     * @dev Revert with an error when an ERC721 transfer with amount other than\\n     *      one is attempted.\\n     */\\n    error InvalidERC721TransferAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute an ERC721 transfer\\n     *      to an invalid recipient.\\n     */\\n    error InvalidERC721Recipient(address recipient);\\n\\n    /**\\n     * @dev Revert with an error when a call to a ERC721 receiver reverts with\\n     *      bytes data.\\n     */\\n    error ERC721ReceiverErrorRevertBytes(\\n        bytes reason,\\n        address receiver,\\n        address sender,\\n        uint256 identifier\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a call to a ERC721 receiver reverts with\\n     *      string reason.\\n     */\\n    error ERC721ReceiverErrorRevertString(\\n        string reason,\\n        address receiver,\\n        address sender,\\n        uint256 identifier\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an ERC20 token has an invalid identifier.\\n     */\\n    error InvalidERC20Identifier();\\n\\n    /**\\n     * @dev Revert with an error if the recipient is the zero address.\\n     */\\n    error RecipientCannotBeZeroAddress();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order referencing an\\n     *      invalid conduit (i.e. one that has not been deployed).\\n     */\\n    error InvalidConduit(bytes32 conduitKey, address conduit);\\n\\n    /**\\n     * @dev Revert with an error when a call to a conduit reverts with a\\n     *      reason string.\\n     */\\n    error ConduitErrorRevertString(\\n        string reason,\\n        bytes32 conduitKey,\\n        address conduit\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a call to a conduit reverts with bytes\\n     *      data.\\n     */\\n    error ConduitErrorRevertBytes(\\n        bytes reason,\\n        bytes32 conduitKey,\\n        address conduit\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nenum ConduitItemType {\\n    NATIVE, // unused\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\"\r\n    },\r\n    \"contracts/lib/TokenTransferrer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./TokenTransferrerConstants.sol\\\";\\n\\nimport {\\n    TokenTransferrerErrors\\n} from \\\"../interfaces/TokenTransferrerErrors.sol\\\";\\n\\nimport { ConduitBatch1155Transfer } from \\\"../conduit/lib/ConduitStructs.sol\\\";\\n\\n/**\\n * @title TokenTransferrer\\n * @author 0age\\n * @custom:coauthor d1ll0n\\n * @custom:coauthor transmissions11\\n * @notice TokenTransferrer is a library for performing optimized ERC20, ERC721,\\n *         ERC1155, and batch ERC1155 transfers, used by both Seaport as well as\\n *         by conduits deployed by the ConduitController. Use great caution when\\n *         considering these functions for use in other codebases, as there are\\n *         significant side effects and edge cases that need to be thoroughly\\n *         understood and carefully addressed.\\n */\\ncontract TokenTransferrer is TokenTransferrerErrors {\\n    /**\\n     * @dev Internal function to transfer ERC20 tokens from a given originator\\n     *      to a given recipient. Sufficient approvals must be set on the\\n     *      contract performing the transfer.\\n     *\\n     * @param token      The ERC20 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC20Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC20 token transfer.\\n        assembly {\\n            // The free memory pointer memory slot will be used when populating\\n            // call data for the transfer; read the value and restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write call data into memory, starting with function selector.\\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\\n            mstore(ERC20_transferFrom_from_ptr, from)\\n            mstore(ERC20_transferFrom_to_ptr, to)\\n            mstore(ERC20_transferFrom_amount_ptr, amount)\\n\\n            // Make call & copy up to 32 bytes of return data to scratch space.\\n            // Scratch space does not need to be cleared ahead of time, as the\\n            // subsequent check will ensure that either at least a full word of\\n            // return data is received (in which case it will be overwritten) or\\n            // that no data is received (in which case scratch space will be\\n            // ignored) on a successful call to the given token.\\n            let callStatus := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC20_transferFrom_sig_ptr,\\n                ERC20_transferFrom_length,\\n                0,\\n                OneWord\\n            )\\n\\n            // Determine whether transfer was successful using status & result.\\n            let success := and(\\n                // Set success to whether the call reverted, if not check it\\n                // either returned exactly 1 (can't just be non-zero data), or\\n                // had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                callStatus\\n            )\\n\\n            // Handle cases where either the transfer failed or no data was\\n            // returned. Group these, as most transfers will succeed with data.\\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\\n            // but after it's inverted for JUMPI this expression is cheaper.\\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\\n                // If the token has no code or the transfer failed: Equivalent\\n                // to `or(iszero(success), iszero(extcodesize(token)))` but\\n                // after it's inverted for JUMPI this expression is cheaper.\\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\\n                    // If the transfer failed:\\n                    if iszero(success) {\\n                        // If it was due to a revert:\\n                        if iszero(callStatus) {\\n                            // If it returned a message, bubble it up as long as\\n                            // sufficient gas remains to do so:\\n                            if returndatasize() {\\n                                // Ensure that sufficient gas is available to\\n                                // copy returndata while expanding memory where\\n                                // necessary. Start by computing the word size\\n                                // of returndata and allocated memory. Round up\\n                                // to the nearest full word.\\n                                let returnDataWords := div(\\n                                    add(returndatasize(), AlmostOneWord),\\n                                    OneWord\\n                                )\\n\\n                                // Note: use the free memory pointer in place of\\n                                // msize() to work around a Yul warning that\\n                                // prevents accessing msize directly when the IR\\n                                // pipeline is activated.\\n                                let msizeWords := div(memPointer, OneWord)\\n\\n                                // Next, compute the cost of the returndatacopy.\\n                                let cost := mul(CostPerWord, returnDataWords)\\n\\n                                // Then, compute cost of new memory allocation.\\n                                if gt(returnDataWords, msizeWords) {\\n                                    cost := add(\\n                                        cost,\\n                                        add(\\n                                            mul(\\n                                                sub(\\n                                                    returnDataWords,\\n                                                    msizeWords\\n                                                ),\\n                                                CostPerWord\\n                                            ),\\n                                            div(\\n                                                sub(\\n                                                    mul(\\n                                                        returnDataWords,\\n                                                        returnDataWords\\n                                                    ),\\n                                                    mul(msizeWords, msizeWords)\\n                                                ),\\n                                                MemoryExpansionCoefficient\\n                                            )\\n                                        )\\n                                    )\\n                                }\\n\\n                                // Finally, add a small constant and compare to\\n                                // gas remaining; bubble up the revert data if\\n                                // enough gas is still available.\\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\\n                                    // Copy returndata to memory; overwrite\\n                                    // existing memory.\\n                                    returndatacopy(0, 0, returndatasize())\\n\\n                                    // Revert, specifying memory region with\\n                                    // copied returndata.\\n                                    revert(0, returndatasize())\\n                                }\\n                            }\\n\\n                            // Otherwise revert with a generic error message.\\n                            mstore(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_signature\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_token_ptr,\\n                                token\\n                            )\\n                            mstore(\\n                                TokenTransferGenericFailure_error_from_ptr,\\n                                from\\n                            )\\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                            mstore(TokenTransferGenericFailure_error_id_ptr, 0)\\n                            mstore(\\n                                TokenTransferGenericFailure_error_amount_ptr,\\n                                amount\\n                            )\\n                            revert(\\n                                TokenTransferGenericFailure_error_sig_ptr,\\n                                TokenTransferGenericFailure_error_length\\n                            )\\n                        }\\n\\n                        // Otherwise revert with a message about the token\\n                        // returning false or non-compliant return values.\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            BadReturnValueFromERC20OnTransfer_error_signature\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\\n                            token\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\\n                            from\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\\n                            to\\n                        )\\n                        mstore(\\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\\n                            amount\\n                        )\\n                        revert(\\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\\n                            BadReturnValueFromERC20OnTransfer_error_length\\n                        )\\n                    }\\n\\n                    // Otherwise, revert with error about token not having code:\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Otherwise, the token just returned no data despite the call\\n                // having succeeded; no need to optimize for this as it's not\\n                // technically ERC20 compliant.\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer an ERC721 token from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer. Note that this function does\\n     *      not check whether the receiver can accept the ERC721 token (i.e. it\\n     *      does not use `safeTransferFrom`).\\n     *\\n     * @param token      The ERC721 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The tokenId to transfer.\\n     */\\n    function _performERC721Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC721 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                mstore(NoContract_error_token_ptr, token)\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\n            }\\n\\n            // The free memory pointer memory slot will be used when populating\\n            // call data for the transfer; read the value and restore it later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n\\n            // Write call data to memory starting with function selector.\\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\\n            mstore(ERC721_transferFrom_from_ptr, from)\\n            mstore(ERC721_transferFrom_to_ptr, to)\\n            mstore(ERC721_transferFrom_id_ptr, identifier)\\n\\n            // Perform the call, ignoring return data.\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC721_transferFrom_sig_ptr,\\n                ERC721_transferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    // Round up to the nearest full word.\\n                    let returnDataWords := div(\\n                        add(returndatasize(), AlmostOneWord),\\n                        OneWord\\n                    )\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := div(memPointer, OneWord)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                div(\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    ),\\n                                    MemoryExpansionCoefficient\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n                mstore(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_signature\\n                )\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\\n                revert(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\n     *      are willing to accept the transfer.\\n     *\\n     * @param token      The ERC1155 token to transfer.\\n     * @param from       The originator of the transfer.\\n     * @param to         The recipient of the transfer.\\n     * @param identifier The id to transfer.\\n     * @param amount     The amount to transfer.\\n     */\\n    function _performERC1155Transfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    ) internal {\\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\\n        assembly {\\n            // If the token has no code, revert.\\n            if iszero(extcodesize(token)) {\\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                mstore(NoContract_error_token_ptr, token)\\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\\n            }\\n\\n            // The following memory slots will be used when populating call data\\n            // for the transfer; read the values and restore them later.\\n            let memPointer := mload(FreeMemoryPointerSlot)\\n            let slot0x80 := mload(Slot0x80)\\n            let slot0xA0 := mload(Slot0xA0)\\n            let slot0xC0 := mload(Slot0xC0)\\n\\n            // Write call data into memory, beginning with function selector.\\n            mstore(\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_signature\\n            )\\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\\n            mstore(\\n                ERC1155_safeTransferFrom_data_offset_ptr,\\n                ERC1155_safeTransferFrom_data_length_offset\\n            )\\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\\n\\n            // Perform the call, ignoring return data.\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                ERC1155_safeTransferFrom_sig_ptr,\\n                ERC1155_safeTransferFrom_length,\\n                0,\\n                0\\n            )\\n\\n            // If the transfer reverted:\\n            if iszero(success) {\\n                // If it returned a message, bubble it up as long as sufficient\\n                // gas remains to do so:\\n                if returndatasize() {\\n                    // Ensure that sufficient gas is available to copy\\n                    // returndata while expanding memory where necessary. Start\\n                    // by computing word size of returndata & allocated memory.\\n                    // Round up to the nearest full word.\\n                    let returnDataWords := div(\\n                        add(returndatasize(), AlmostOneWord),\\n                        OneWord\\n                    )\\n\\n                    // Note: use the free memory pointer in place of msize() to\\n                    // work around a Yul warning that prevents accessing msize\\n                    // directly when the IR pipeline is activated.\\n                    let msizeWords := div(memPointer, OneWord)\\n\\n                    // Next, compute the cost of the returndatacopy.\\n                    let cost := mul(CostPerWord, returnDataWords)\\n\\n                    // Then, compute cost of new memory allocation.\\n                    if gt(returnDataWords, msizeWords) {\\n                        cost := add(\\n                            cost,\\n                            add(\\n                                mul(\\n                                    sub(returnDataWords, msizeWords),\\n                                    CostPerWord\\n                                ),\\n                                div(\\n                                    sub(\\n                                        mul(returnDataWords, returnDataWords),\\n                                        mul(msizeWords, msizeWords)\\n                                    ),\\n                                    MemoryExpansionCoefficient\\n                                )\\n                            )\\n                        )\\n                    }\\n\\n                    // Finally, add a small constant and compare to gas\\n                    // remaining; bubble up the revert data if enough gas is\\n                    // still available.\\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\\n                        // Copy returndata to memory; overwrite existing memory.\\n                        returndatacopy(0, 0, returndatasize())\\n\\n                        // Revert, giving memory region with copied returndata.\\n                        revert(0, returndatasize())\\n                    }\\n                }\\n\\n                // Otherwise revert with a generic error message.\\n                mstore(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_signature\\n                )\\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\\n                revert(\\n                    TokenTransferGenericFailure_error_sig_ptr,\\n                    TokenTransferGenericFailure_error_length\\n                )\\n            }\\n\\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\\n\\n            // Restore the original free memory pointer.\\n            mstore(FreeMemoryPointerSlot, memPointer)\\n\\n            // Restore the zero slot to zero.\\n            mstore(ZeroSlot, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ERC1155 tokens from a given\\n     *      originator to a given recipient. Sufficient approvals must be set on\\n     *      the contract performing the transfer and contract recipients must\\n     *      implement the ERC1155TokenReceiver interface to indicate that they\\n     *      are willing to accept the transfer. NOTE: this function is not\\n     *      memory-safe; it will overwrite existing memory, restore the free\\n     *      memory pointer to the default value, and overwrite the zero slot.\\n     *      This function should only be called once memory is no longer\\n     *      required and when uninitialized arrays are not utilized, and memory\\n     *      should be considered fully corrupted (aside from the existence of a\\n     *      default-value free memory pointer) after calling this function.\\n     *\\n     * @param batchTransfers The group of 1155 batch transfers to perform.\\n     */\\n    function _performERC1155BatchTransfers(\\n        ConduitBatch1155Transfer[] calldata batchTransfers\\n    ) internal {\\n        // Utilize assembly to perform optimized batch 1155 transfers.\\n        assembly {\\n            let len := batchTransfers.length\\n            // Pointer to first head in the array, which is offset to the struct\\n            // at each index. This gets incremented after each loop to avoid\\n            // multiplying by 32 to get the offset for each element.\\n            let nextElementHeadPtr := batchTransfers.offset\\n\\n            // Pointer to beginning of the head of the array. This is the\\n            // reference position each offset references. It's held static to\\n            // let each loop calculate the data position for an element.\\n            let arrayHeadPtr := nextElementHeadPtr\\n\\n            // Write the function selector, which will be reused for each call:\\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\n            mstore(\\n                ConduitBatch1155Transfer_from_offset,\\n                ERC1155_safeBatchTransferFrom_signature\\n            )\\n\\n            // Iterate over each batch transfer.\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n                i := add(i, 1)\\n            } {\\n                // Read the offset to the beginning of the element and add\\n                // it to pointer to the beginning of the array head to get\\n                // the absolute position of the element in calldata.\\n                let elementPtr := add(\\n                    arrayHeadPtr,\\n                    calldataload(nextElementHeadPtr)\\n                )\\n\\n                // Retrieve the token from calldata.\\n                let token := calldataload(elementPtr)\\n\\n                // If the token has no code, revert.\\n                if iszero(extcodesize(token)) {\\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\\n                    mstore(NoContract_error_token_ptr, token)\\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\\n                }\\n\\n                // Get the total number of supplied ids.\\n                let idsLength := calldataload(\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\\n                )\\n\\n                // Determine the expected offset for the amounts array.\\n                let expectedAmountsOffset := add(\\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\\n                    mul(idsLength, OneWord)\\n                )\\n\\n                // Validate struct encoding.\\n                let invalidEncoding := iszero(\\n                    and(\\n                        // ids.length == amounts.length\\n                        eq(\\n                            idsLength,\\n                            calldataload(add(elementPtr, expectedAmountsOffset))\\n                        ),\\n                        and(\\n                            // ids_offset == 0xa0\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatch1155Transfer_ids_head_offset\\n                                    )\\n                                ),\\n                                ConduitBatch1155Transfer_ids_length_offset\\n                            ),\\n                            // amounts_offset == 0xc0 + ids.length*32\\n                            eq(\\n                                calldataload(\\n                                    add(\\n                                        elementPtr,\\n                                        ConduitBatchTransfer_amounts_head_offset\\n                                    )\\n                                ),\\n                                expectedAmountsOffset\\n                            )\\n                        )\\n                    )\\n                )\\n\\n                // Revert with an error if the encoding is not valid.\\n                if invalidEncoding {\\n                    mstore(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_selector\\n                    )\\n                    revert(\\n                        Invalid1155BatchTransferEncoding_ptr,\\n                        Invalid1155BatchTransferEncoding_length\\n                    )\\n                }\\n\\n                // Update the offset position for the next loop\\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\\n\\n                // Copy the first section of calldata (before dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\\n                    ConduitBatch1155Transfer_usable_head_size\\n                )\\n\\n                // Determine size of calldata required for ids and amounts. Note\\n                // that the size includes both lengths as well as the data.\\n                let idsAndAmountsSize := add(TwoWords, mul(idsLength, TwoWords))\\n\\n                // Update the offset for the data array in memory.\\n                mstore(\\n                    BatchTransfer1155Params_data_head_ptr,\\n                    add(\\n                        BatchTransfer1155Params_ids_length_offset,\\n                        idsAndAmountsSize\\n                    )\\n                )\\n\\n                // Set the length of the data array in memory to zero.\\n                mstore(\\n                    add(\\n                        BatchTransfer1155Params_data_length_basePtr,\\n                        idsAndAmountsSize\\n                    ),\\n                    0\\n                )\\n\\n                // Determine the total calldata size for the call to transfer.\\n                let transferDataSize := add(\\n                    BatchTransfer1155Params_calldata_baseSize,\\n                    idsAndAmountsSize\\n                )\\n\\n                // Copy second section of calldata (including dynamic values).\\n                calldatacopy(\\n                    BatchTransfer1155Params_ids_length_ptr,\\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\\n                    idsAndAmountsSize\\n                )\\n\\n                // Perform the call to transfer 1155 tokens.\\n                let success := call(\\n                    gas(),\\n                    token,\\n                    0,\\n                    ConduitBatch1155Transfer_from_offset, // Data portion start.\\n                    transferDataSize, // Location of the length of callData.\\n                    0,\\n                    0\\n                )\\n\\n                // If the transfer reverted:\\n                if iszero(success) {\\n                    // If it returned a message, bubble it up as long as\\n                    // sufficient gas remains to do so:\\n                    if returndatasize() {\\n                        // Ensure that sufficient gas is available to copy\\n                        // returndata while expanding memory where necessary.\\n                        // Start by computing word size of returndata and\\n                        // allocated memory. Round up to the nearest full word.\\n                        let returnDataWords := div(\\n                            add(returndatasize(), AlmostOneWord),\\n                            OneWord\\n                        )\\n\\n                        // Note: use transferDataSize in place of msize() to\\n                        // work around a Yul warning that prevents accessing\\n                        // msize directly when the IR pipeline is activated.\\n                        // The free memory pointer is not used here because\\n                        // this function does almost all memory management\\n                        // manually and does not update it, and transferDataSize\\n                        // should be the largest memory value used (unless a\\n                        // previous batch was larger).\\n                        let msizeWords := div(transferDataSize, OneWord)\\n\\n                        // Next, compute the cost of the returndatacopy.\\n                        let cost := mul(CostPerWord, returnDataWords)\\n\\n                        // Then, compute cost of new memory allocation.\\n                        if gt(returnDataWords, msizeWords) {\\n                            cost := add(\\n                                cost,\\n                                add(\\n                                    mul(\\n                                        sub(returnDataWords, msizeWords),\\n                                        CostPerWord\\n                                    ),\\n                                    div(\\n                                        sub(\\n                                            mul(\\n                                                returnDataWords,\\n                                                returnDataWords\\n                                            ),\\n                                            mul(msizeWords, msizeWords)\\n                                        ),\\n                                        MemoryExpansionCoefficient\\n                                    )\\n                                )\\n                            )\\n                        }\\n\\n                        // Finally, add a small constant and compare to gas\\n                        // remaining; bubble up the revert data if enough gas is\\n                        // still available.\\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\\n                            // Copy returndata to memory; overwrite existing.\\n                            returndatacopy(0, 0, returndatasize())\\n\\n                            // Revert with memory region containing returndata.\\n                            revert(0, returndatasize())\\n                        }\\n                    }\\n\\n                    // Set the error signature.\\n                    mstore(\\n                        0,\\n                        ERC1155BatchTransferGenericFailure_error_signature\\n                    )\\n\\n                    // Write the token.\\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\\n\\n                    // Increase the offset to ids by 32.\\n                    mstore(\\n                        BatchTransfer1155Params_ids_head_ptr,\\n                        ERC1155BatchTransferGenericFailure_ids_offset\\n                    )\\n\\n                    // Increase the offset to amounts by 32.\\n                    mstore(\\n                        BatchTransfer1155Params_amounts_head_ptr,\\n                        add(\\n                            OneWord,\\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\\n                        )\\n                    )\\n\\n                    // Return modified region. The total size stays the same as\\n                    // `token` uses the same number of bytes as `data.length`.\\n                    revert(0, transferDataSize)\\n                }\\n            }\\n\\n            // Reset the free memory pointer to the default value; memory must\\n            // be assumed to be dirtied and not reused from this point forward.\\n            // Also note that the zero slot is not reset to zero, meaning empty\\n            // arrays cannot be safely created or utilized until it is restored.\\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/conduit/lib/ConduitConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n// error ChannelClosed(address channel)\\nuint256 constant ChannelClosed_error_signature = (\\n    0x93daadf200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ChannelClosed_error_ptr = 0x00;\\nuint256 constant ChannelClosed_channel_ptr = 0x4;\\nuint256 constant ChannelClosed_error_length = 0x24;\\n\\n// For the mapping:\\n// mapping(address => bool) channels\\n// The position in storage for a particular account is:\\n// keccak256(abi.encode(account, channels.slot))\\nuint256 constant ChannelKey_channel_ptr = 0x00;\\nuint256 constant ChannelKey_slot_ptr = 0x20;\\nuint256 constant ChannelKey_length = 0x40;\\n\"\r\n    },\r\n    \"contracts/lib/TokenTransferrerConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/*\\n * -------------------------- Disambiguation & Other Notes ---------------------\\n *    - The term \\\"head\\\" is used as it is in the documentation for ABI encoding,\\n *      but only in reference to dynamic types, i.e. it always refers to the\\n *      offset or pointer to the body of a dynamic type. In calldata, the head\\n *      is always an offset (relative to the parent object), while in memory,\\n *      the head is always the pointer to the body. More information found here:\\n *      https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#argument-encoding\\n *        - Note that the length of an array is separate from and precedes the\\n *          head of the array.\\n *\\n *    - The term \\\"body\\\" is used in place of the term \\\"head\\\" used in the ABI\\n *      documentation. It refers to the start of the data for a dynamic type,\\n *      e.g. the first word of a struct or the first word of the first element\\n *      in an array.\\n *\\n *    - The term \\\"pointer\\\" is used to describe the absolute position of a value\\n *      and never an offset relative to another value.\\n *        - The suffix \\\"_ptr\\\" refers to a memory pointer.\\n *        - The suffix \\\"_cdPtr\\\" refers to a calldata pointer.\\n *\\n *    - The term \\\"offset\\\" is used to describe the position of a value relative\\n *      to some parent value. For example, OrderParameters_conduit_offset is the\\n *      offset to the \\\"conduit\\\" value in the OrderParameters struct relative to\\n *      the start of the body.\\n *        - Note: Offsets are used to derive pointers.\\n *\\n *    - Some structs have pointers defined for all of their fields in this file.\\n *      Lines which are commented out are fields that are not used in the\\n *      codebase but have been left in for readability.\\n */\\n\\nuint256 constant AlmostOneWord = 0x1f;\\nuint256 constant OneWord = 0x20;\\nuint256 constant TwoWords = 0x40;\\nuint256 constant ThreeWords = 0x60;\\n\\nuint256 constant FreeMemoryPointerSlot = 0x40;\\nuint256 constant ZeroSlot = 0x60;\\nuint256 constant DefaultFreeMemoryPointer = 0x80;\\n\\nuint256 constant Slot0x80 = 0x80;\\nuint256 constant Slot0xA0 = 0xa0;\\nuint256 constant Slot0xC0 = 0xc0;\\n\\n// abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\")\\nuint256 constant ERC20_transferFrom_signature = (\\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeTransferFrom_signature = (\\n    0xf242432a00000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\\n\\n// abi.encodeWithSignature(\\n//     \\\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\\"\\n// )\\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\\n);\\n\\nbytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\\n    bytes32(ERC1155_safeBatchTransferFrom_signature)\\n);\\n\\nuint256 constant ERC721_transferFrom_signature = ERC20_transferFrom_signature;\\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\\n\\n// abi.encodeWithSignature(\\\"NoContract(address)\\\")\\nuint256 constant NoContract_error_signature = (\\n    0x5f15d67200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant NoContract_error_sig_ptr = 0x0;\\nuint256 constant NoContract_error_token_ptr = 0x4;\\nuint256 constant NoContract_error_length = 0x24; // 4 + 32 == 36\\n\\n// abi.encodeWithSignature(\\n//     \\\"TokenTransferGenericFailure(address,address,address,uint256,uint256)\\\"\\n// )\\nuint256 constant TokenTransferGenericFailure_error_signature = (\\n    0xf486bc8700000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant TokenTransferGenericFailure_error_sig_ptr = 0x0;\\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x4;\\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x24;\\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x44;\\nuint256 constant TokenTransferGenericFailure_error_id_ptr = 0x64;\\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0x84;\\n\\n// 4 + 32 * 5 == 164\\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\\n\\n// abi.encodeWithSignature(\\n//     \\\"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\\\"\\n// )\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_signature = (\\n    0x9889192300000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_sig_ptr = 0x0;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x4;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x24;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x44;\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x64;\\n\\n// 4 + 32 * 4 == 132\\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\\n\\nuint256 constant ExtraGasBuffer = 0x20;\\nuint256 constant CostPerWord = 3;\\nuint256 constant MemoryExpansionCoefficient = 0x200;\\n\\n// Values are offset by 32 bytes in order to write the token to the beginning\\n// in the event of a revert\\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\\n\\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\\nuint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\\nuint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\\n\\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\\n\\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\\nuint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\\nuint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\\n\\n// Note: abbreviated version of above constant to adhere to line length limit.\\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\\n\\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\\n);\\n\\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\\n    0xafc445e200000000000000000000000000000000000000000000000000000000\\n);\\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\\n\"\r\n    },\r\n    \"contracts/interfaces/TokenTransferrerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @title TokenTransferrerErrors\\n */\\ninterface TokenTransferrerErrors {\\n    /**\\n     * @dev Revert with an error when an ERC721 transfer with amount other than\\n     *      one is attempted.\\n     */\\n    error InvalidERC721TransferAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has an amount of zero.\\n     */\\n    error MissingItemAmount();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order where an\\n     *      item has unused parameters. This includes both the token and the\\n     *      identifier parameters for native transfers as well as the identifier\\n     *      parameter for ERC20 transfers. Note that the conduit does not\\n     *      perform this check, leaving it up to the calling channel to enforce\\n     *      when desired.\\n     */\\n    error UnusedItemParameters();\\n\\n    /**\\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\\n     *      transfer reverts.\\n     *\\n     * @param token      The token for which the transfer was attempted.\\n     * @param from       The source of the attempted transfer.\\n     * @param to         The recipient of the attempted transfer.\\n     * @param identifier The identifier for the attempted transfer.\\n     * @param amount     The amount for the attempted transfer.\\n     */\\n    error TokenTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 identifier,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\\n     *\\n     * @param token       The token for which the transfer was attempted.\\n     * @param from        The source of the attempted transfer.\\n     * @param to          The recipient of the attempted transfer.\\n     * @param identifiers The identifiers for the attempted transfer.\\n     * @param amounts     The amounts for the attempted transfer.\\n     */\\n    error ERC1155BatchTransferGenericFailure(\\n        address token,\\n        address from,\\n        address to,\\n        uint256[] identifiers,\\n        uint256[] amounts\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\\n     *      value.\\n     *\\n     * @param token      The token for which the ERC20 transfer was attempted.\\n     * @param from       The source of the attempted ERC20 transfer.\\n     * @param to         The recipient of the attempted ERC20 transfer.\\n     * @param amount     The amount for the attempted ERC20 transfer.\\n     */\\n    error BadReturnValueFromERC20OnTransfer(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when an account being called as an assumed\\n     *      contract does not have code and returns no data.\\n     *\\n     * @param account The account that should contain code.\\n     */\\n    error NoContract(address account);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute an 1155 batch\\n     *      transfer using calldata not produced by default ABI encoding or with\\n     *      different lengths for ids and amounts arrays.\\n     */\\n    error Invalid1155BatchTransferEncoding();\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduitController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"ConduitErrorRevertBytes\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"ConduitErrorRevertString\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"}],\"name\":\"ERC721ReceiverErrorRevertBytes\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"}],\"name\":\"ERC721ReceiverErrorRevertString\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidConduit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidERC20Identifier\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"InvalidERC721Recipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidERC721TransferAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidItemType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RecipientCannotBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ConduitItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct TransferHelperItem[]\",\"name\":\"items\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"validateERC721Receiver\",\"type\":\"bool\"}],\"internalType\":\"struct TransferHelperItemsWithRecipient[]\",\"name\":\"items\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"name\":\"bulkTransfer\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TransferHelper", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000000000000f9490004c11cef243f5400493c00ad63", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}