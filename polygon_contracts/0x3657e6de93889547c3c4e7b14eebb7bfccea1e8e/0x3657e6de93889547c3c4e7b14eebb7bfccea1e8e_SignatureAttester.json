{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/attesters/signature/SignatureAttester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.14;\\npragma experimental ABIEncoderV2;\\n\\nimport '@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol';\\n// Core protocol Protocol imports\\nimport {ISignatureAttester} from './interfaces/ISignatureAttester.sol';\\nimport {Request, Attestation, Claim} from './../../core/libs/Structs.sol';\\nimport {Attester, IAttester, IAttestationsRegistry} from './../../core/Attester.sol';\\nimport {EIP712Signature} from './libs/SignatureAttesterLib.sol';\\n\\n/**\\n * @title  Signature Attester\\n * @author Kleoverse\\n * @notice This attester is based on ECDSA signature verfication method.\\n * Signature attester enables users to generate attestations based on signature signed using ECDSA scheme off-chain by a centralised verifier.\\n **/\\ncontract SignatureAttester is ISignatureAttester, Attester, EIP712 {\\n  bytes32 private constant _ATTESTATION_REQUEST_TYPEHASH =\\n    keccak256(\\n      'AttestationRequest(uint256 groupId,uint256 claimedValue,bytes extraData,address destination,uint256 deadline)'\\n    );\\n\\n  address public immutable VERIFIER;\\n  address public immutable MIGRATION_CONTRACT;\\n  mapping(uint256 => mapping(address => address)) internal _sourcesToDestinations;\\n\\n  modifier onlyMigrationContractOrOwner() {\\n    require(\\n      msg.sender == MIGRATION_CONTRACT || msg.sender == owner(),\\n      'Only migration contract or owner can call this function'\\n    );\\n    _;\\n  }\\n\\n  /*******************************************************\\n    INITIALIZATION FUNCTIONS                           \\n  *******************************************************/\\n  /**\\n   * @dev Constructor. Initializes the contract\\n   * @param attestationsRegistryAddress Attestations Registry contract on which the attester will write attestations\\n   * @param collectionIdFirst Id of the first collection in which the attester is supposed to record\\n   * @param collectionIdLast Id of the last collection in which the attester is supposed to record\\n   * @param verifierAddress Address of the off-chain attester signer\\n   * @param migrationContract Address of the migration contract\\n   */\\n  constructor(\\n    address attestationsRegistryAddress,\\n    uint256 collectionIdFirst,\\n    uint256 collectionIdLast,\\n    address verifierAddress,\\n    address migrationContract\\n  )\\n    Attester(attestationsRegistryAddress, collectionIdFirst, collectionIdLast)\\n    EIP712('SignatureAttester', '1')\\n  {\\n    VERIFIER = verifierAddress;\\n    MIGRATION_CONTRACT = migrationContract;\\n  }\\n\\n  /*******************************************************\\n    MANDATORY FUNCTIONS TO OVERRIDE FROM ATTESTER.SOL\\n  *******************************************************/\\n\\n  /**\\n   * @dev Throws if user request is invalid when verified against\\n   * @param request users request. Claim of having met the badge requirement\\n   * @param proofData Signature proof\\n   */\\n  function _verifyRequest(Request calldata request, bytes calldata proofData)\\n    internal\\n    virtual\\n    override\\n  {\\n    EIP712Signature memory sig = abi.decode(proofData, (EIP712Signature));\\n    if (sig.deadline < block.timestamp) {\\n      revert SignatureDeadlineExpired(sig.deadline);\\n    }\\n    bytes32 structHash = keccak256(\\n      abi.encode(\\n        _ATTESTATION_REQUEST_TYPEHASH,\\n        request.claims[0].groupId,\\n        request.claims[0].claimedValue,\\n        keccak256(request.claims[0].extraData),\\n        request.destination,\\n        sig.deadline\\n      )\\n    );\\n\\n    bytes32 hash = _hashTypedDataV4(structHash);\\n\\n    address signer = ECDSA.recover(hash, sig.v, sig.r, sig.s);\\n    if (signer != VERIFIER) {\\n      revert SignatureInvalid(VERIFIER, signer);\\n    }\\n  }\\n\\n  /**\\n   * @dev Throws if user attestations deletion request is not made by its owner\\n   * @param attestations attestations to delete\\n   */\\n  function _verifyAttestationsDeletionRequest(Attestation[] memory attestations, bytes calldata)\\n    internal\\n    view\\n    override\\n  {\\n    for (uint256 i = 0; i < attestations.length; i++) {\\n      if (attestations[i].owner != msg.sender)\\n        revert NotAttestationOwner(attestations[i].collectionId, msg.sender);\\n      address destination = _getDestinationOfSource(attestations[i].collectionId, msg.sender);\\n      if (destination != msg.sender) revert SourceDestinationNotSame(msg.sender, destination);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns attestations that will be recorded, constructed from the user request\\n   * @param request users request. Claim of having met the badge requirement\\n   */\\n  function buildAttestations(Request calldata request, bytes calldata)\\n    public\\n    view\\n    virtual\\n    override(Attester)\\n    returns (Attestation[] memory)\\n  {\\n    Claim memory claim = request.claims[0];\\n\\n    Attestation[] memory attestations = new Attestation[](1);\\n\\n    uint256 attestationCollectionId = AUTHORIZED_COLLECTION_ID_FIRST + claim.groupId;\\n\\n    if (attestationCollectionId > AUTHORIZED_COLLECTION_ID_LAST)\\n      revert CollectionIdOutOfBound(attestationCollectionId);\\n\\n    address issuer = address(this);\\n\\n    attestations[0] = Attestation(\\n      attestationCollectionId,\\n      request.destination,\\n      issuer,\\n      claim.claimedValue,\\n      uint32(block.timestamp),\\n      claim.extraData\\n    );\\n    return (attestations);\\n  }\\n\\n  /*******************************************************\\n    OPTIONAL HOOK VIRTUAL FUNCTIONS FROM ATTESTER.SOL\\n  *******************************************************/\\n\\n  /**\\n   * @dev Hook run before recording the attestation.\\n   * Throws if source already used for another destination\\n   * @param request users request. Claim of having met the badge requirement\\n   * @param proofData provided to back the request.\\n   */\\n  function _beforeRecordAttestations(Request calldata request, bytes calldata proofData)\\n    internal\\n    virtual\\n    override\\n  {\\n    uint256 attestationCollectionId = AUTHORIZED_COLLECTION_ID_FIRST + request.claims[0].groupId;\\n    address currentDestination = _getDestinationOfSource(attestationCollectionId, msg.sender);\\n\\n    if (currentDestination != address(0) && currentDestination != request.destination) {\\n      revert SourceAlreadyUsed(msg.sender);\\n    }\\n\\n    _setDestinationForSource(attestationCollectionId, msg.sender, request.destination);\\n  }\\n\\n  /**\\n   * @dev Hook run before deleting the attestations.\\n   * Unsets destination for the source and collectionId\\n   * @param attestations Attestations that will be deleted\\n   * @param proofData Data sent along the request to prove its validity\\n   */\\n  function _beforeDeleteAttestations(Attestation[] memory attestations, bytes calldata proofData)\\n    internal\\n    override\\n  {\\n    for (uint256 i = 0; i < attestations.length; i++) {\\n      _setDestinationForSource(attestations[i].collectionId, msg.sender, address(0));\\n    }\\n  }\\n\\n  /*******************************************************\\n    Signature Attester Specific Functions\\n  *******************************************************/\\n\\n  function setDestinationForSource(\\n    uint256 attestationId,\\n    address source,\\n    address destination\\n  ) external onlyMigrationContractOrOwner {\\n    _setDestinationForSource(attestationId, source, destination);\\n  }\\n\\n  /**\\n   * @dev Getter, returns the last attestation's destination of a source\\n   * @param attestationId Id of the specific attestation mapped to source\\n   * @param source address used\\n   **/\\n  function getDestinationOfSource(uint256 attestationId, address source)\\n    external\\n    view\\n    override\\n    returns (address)\\n  {\\n    return _getDestinationOfSource(attestationId, source);\\n  }\\n\\n  /**\\n   * @dev Internal Setter, sets the mapping of source-destination for attestationId\\n   * @param attestationId Id of the specific attestation mapped to source\\n   * @param source address used\\n   * @param destination address of the attestation destination\\n   **/\\n  function _setDestinationForSource(\\n    uint256 attestationId,\\n    address source,\\n    address destination\\n  ) internal virtual {\\n    _sourcesToDestinations[attestationId][source] = destination;\\n    emit SourceToDestinationUpdated(attestationId, source, destination);\\n  }\\n\\n  /**\\n   * @dev Internal Getter, returns the last attestation's destination of a source\\n   * @param attestationId Id of the specific attestation mapped to source\\n   * @param source address used\\n   **/\\n  function _getDestinationOfSource(uint256 attestationId, address source)\\n    internal\\n    view\\n    returns (address)\\n  {\\n    return _sourcesToDestinations[attestationId][source];\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/attesters/signature/interfaces/ISignatureAttester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.14;\\npragma experimental ABIEncoderV2;\\n\\ninterface ISignatureAttester {\\n  error SignatureDeadlineExpired(uint256 deadline);\\n  error SignatureInvalid(address expectedSigner, address signer);\\n  error SourceAlreadyUsed(address source);\\n  error NotAttestationOwner(uint256 collectionId, address sender);\\n  error SourceDestinationNotSame(address source, address destination);\\n\\n  event SourceToDestinationUpdated(uint256 attestationId, address source, address destination);\\n\\n  /**\\n   * @dev Getter, returns the last attestation destination of a source\\n   * @param attestationId attestation id\\n   * @param source address used\\n   **/\\n  function getDestinationOfSource(uint256 attestationId, address source)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/core/libs/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\n/**\\n * @title  Attestations Registry State\\n * @author Kleoverse - Forked from Sismo Protocol\\n * @notice This contract holds all of the storage variables and data\\n *         structures used by the AttestationsRegistry and parent\\n *         contracts.\\n */\\n\\n// User Attestation Request, can be made by any user\\n// The context of an Attestation Request is a specific attester contract\\n// Each attester has groups of accounts in its available data\\n// eg: for a specific attester:\\n//     group 1 <=> accounts that sent txs on mainnet\\n//     group 2 <=> accounts that sent txs on polygon\\n// eg: for another attester:\\n//     group 1 <=> accounts that sent eth txs in 2022\\n//     group 2 <=> accounts sent eth txs in 2021\\nstruct Request {\\n  // implicit address attester;\\n  // implicit uint256 chainId;\\n  Claim[] claims;\\n  address destination; // destination that will receive the end attestation\\n}\\n\\nstruct Claim {\\n  uint256 groupId; // user claims to have an account in this group\\n  uint256 claimedValue; // user claims this value for its account in the group\\n  bytes extraData; // arbitrary data, may be required by the attester to verify claims or generate a specific attestation\\n}\\n\\n/**\\n * @dev Attestation Struct. This is the struct receive as argument by the Attestation Registry.\\n * @param collectionId Attestation collection\\n * @param owner Attestation collection\\n * @param issuer Attestation collection\\n * @param value Attestation collection\\n * @param timestamp Attestation collection\\n * @param extraData Attestation collection\\n */\\nstruct Attestation {\\n  // implicit uint256 chainId;\\n  uint256 collectionId; // Id of the attestation collection (in the registry)\\n  address owner; // Owner of the attestation\\n  address issuer; // Contract that created or last updated the record.\\n  uint256 value; // Value of the attestation\\n  uint32 timestamp; // Timestamp chosen by the attester, should correspond to the effective date of the attestation\\n  // it is different from the recording timestamp (date when the attestation was recorded)\\n  // e.g a proof of NFT ownership may have be recorded today which is 2 month old data.\\n  bytes extraData; // arbitrary data that can be added by the attester\\n}\\n\\n// Attestation Data, stored in the registry\\n// The context is a specific owner of a specific collection\\nstruct AttestationData {\\n  // implicit uint256 chainId\\n  // implicit uint256 collectionId - from context\\n  // implicit owner\\n  address issuer; // Address of the contract that recorded the attestation\\n  uint256 value; // Value of the attestation\\n  uint32 timestamp; // Effective date of issuance of the attestation. (can be different from the recording timestamp)\\n  bytes extraData; // arbitrary data that can be added by the attester\\n}\\n\"\r\n    },\r\n    \"contracts/core/Attester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport {IAttester} from './interfaces/IAttester.sol';\\nimport {IAttestationsRegistry} from './interfaces/IAttestationsRegistry.sol';\\nimport {Request, Attestation, AttestationData} from './libs/Structs.sol';\\n\\n/**\\n * @title Attester Abstract Contract\\n * @author Kleoverse - Forked from Sismo Protocol\\n * @notice Contract to be inherited by Attesters\\n * All attesters that expect to be authorized in Proof of Talent Protocol (i.e write access on the registry)\\n * are recommended to implemented this abstract contract\\n\\n * Take a look at the HydraS1SimpleAttester.sol for example on how to implement this abstract contract\\n *\\n * This contracts is built around two main external standard functions.\\n * They must NOT be override them, unless your really know what you are doing\\n \\n * - generateAttestations(request, proof) => will write attestations in the registry\\n * 1. (MANDATORY) Implement the buildAttestations() view function which generate attestations from user request\\n * 2. (MANDATORY) Implement teh _verifyRequest() internal function where to write checks\\n * 3. (OPTIONAL)  Override _beforeRecordAttestations and _afterRecordAttestations hooks\\n\\n * - deleteAttestations(collectionId, owner, proof) => will delete attestations in the registry\\n * 1. (DEFAULT)  By default this function throws (see _verifyAttestationsDeletionRequest)\\n * 2. (OPTIONAL) Override the _verifyAttestationsDeletionRequest so it no longer throws\\n * 3. (OPTIONAL) Override _beforeDeleteAttestations and _afterDeleteAttestations hooks\\n\\n * For more information: https://attesters.docs.sismo.io\\n **/\\nabstract contract Attester is IAttester, Ownable {\\n  // Registry where all attestations are stored\\n  IAttestationsRegistry internal immutable ATTESTATIONS_REGISTRY;\\n  // The deployed contract will need to be authorized to write into the Attestation registry\\n  // It should get write access on attestation collections from AUTHORIZED_COLLECTION_ID_FIRST to AUTHORIZED_COLLECTION_ID_LAST.\\n  uint256 public immutable AUTHORIZED_COLLECTION_ID_FIRST;\\n  uint256 public immutable AUTHORIZED_COLLECTION_ID_LAST;\\n  mapping(uint256 => uint64) internal _badgeMintingPrice;\\n\\n  /**\\n   * @dev Constructor\\n   * @param attestationsRegistryAddress The address of the AttestationsRegistry contract storing attestations\\n   */\\n  constructor(\\n    address attestationsRegistryAddress,\\n    uint256 collectionIdFirst,\\n    uint256 collectionIdLast\\n  ) Ownable() {\\n    ATTESTATIONS_REGISTRY = IAttestationsRegistry(attestationsRegistryAddress);\\n    AUTHORIZED_COLLECTION_ID_FIRST = collectionIdFirst;\\n    AUTHORIZED_COLLECTION_ID_LAST = collectionIdLast;\\n  }\\n\\n  /**\\n   * @dev Main external function. Allows to generate attestations by making a request and submitting proof\\n   * @param request User request\\n   * @param proofData Data sent along the request to prove its validity\\n   * @return attestations Attestations that has been recorded\\n   */\\n  function generateAttestations(Request calldata request, bytes calldata proofData)\\n    external\\n    payable\\n    override\\n    returns (Attestation[] memory)\\n  {\\n    // Verify if request is valid by verifying against proof\\n    _verifyRequest(request, proofData);\\n    uint256 attestationCollectionId = AUTHORIZED_COLLECTION_ID_FIRST + request.claims[0].groupId;\\n    _verifyBadgePayment(attestationCollectionId);\\n\\n    // Generate the actual attestations from user request\\n    Attestation[] memory attestations = buildAttestations(request, proofData);\\n\\n    _beforeRecordAttestations(request, proofData);\\n\\n    ATTESTATIONS_REGISTRY.recordAttestations(attestations);\\n\\n    _afterRecordAttestations(attestations);\\n\\n    for (uint256 i = 0; i < attestations.length; i++) {\\n      emit AttestationGenerated(attestations[i]);\\n    }\\n\\n    return attestations;\\n  }\\n\\n  /**\\n   * @dev External facing function. Allows to delete attestations by submitting proof\\n   * @param collectionIds Collection identifier of attestations to delete\\n   * @param attestationsOwner Owner of attestations to delete\\n   * @param proofData Data sent along the deletion request to prove its validity\\n   * @return attestations Attestations that were deleted\\n   */\\n  function deleteAttestations(\\n    uint256[] calldata collectionIds,\\n    address attestationsOwner,\\n    bytes calldata proofData\\n  ) external override returns (Attestation[] memory) {\\n    // fetch attestations from the registry\\n    address[] memory attestationOwners = new address[](collectionIds.length);\\n    uint256[] memory attestationCollectionIds = new uint256[](collectionIds.length);\\n    Attestation[] memory attestationsToDelete = new Attestation[](collectionIds.length);\\n    for (uint256 i = 0; i < collectionIds.length; i++) {\\n      (\\n        address issuer,\\n        uint256 attestationValue,\\n        uint32 timestamp,\\n        bytes memory extraData\\n      ) = ATTESTATIONS_REGISTRY.getAttestationDataTuple(collectionIds[i], attestationsOwner);\\n\\n      attestationOwners[i] = attestationsOwner;\\n      attestationCollectionIds[i] = collectionIds[i];\\n\\n      attestationsToDelete[i] = (\\n        Attestation(\\n          collectionIds[i],\\n          attestationsOwner,\\n          issuer,\\n          attestationValue,\\n          timestamp,\\n          extraData\\n        )\\n      );\\n    }\\n\\n    _verifyAttestationsDeletionRequest(attestationsToDelete, proofData);\\n\\n    _beforeDeleteAttestations(attestationsToDelete, proofData);\\n\\n    ATTESTATIONS_REGISTRY.deleteAttestations(attestationOwners, attestationCollectionIds);\\n\\n    _afterDeleteAttestations(attestationsToDelete, proofData);\\n\\n    for (uint256 i = 0; i < collectionIds.length; i++) {\\n      emit AttestationDeleted(attestationsToDelete[i]);\\n    }\\n    return attestationsToDelete;\\n  }\\n\\n  /**\\n   * @dev MANDATORY: must be implemented in attesters\\n   * It should build attestations from the user request and the proof\\n   * @param request User request\\n   * @param proofData Data sent along the request to prove its validity\\n   * @return attestations Attestations that will be recorded\\n   */\\n  function buildAttestations(Request calldata request, bytes calldata proofData)\\n    public\\n    view\\n    virtual\\n    returns (Attestation[] memory);\\n\\n  /**\\n   * @dev Attestation registry getter\\n   * @return attestationRegistry\\n   */\\n  function getAttestationRegistry() external view override returns (IAttestationsRegistry) {\\n    return ATTESTATIONS_REGISTRY;\\n  }\\n\\n  function setBadgeMintingPrice(uint256[] memory collectionIds, uint64[] memory priceList)\\n    external\\n    onlyOwner\\n  {\\n    if (collectionIds.length != priceList.length) {\\n      revert LengthMismatch('colletionIds vs priceList');\\n    }\\n    for (uint256 i = 0; i < collectionIds.length; i++) {\\n      _setBadgeMintingPrice(collectionIds[i], priceList[i]);\\n    }\\n  }\\n\\n  function _setBadgeMintingPrice(uint256 collectionId, uint64 price) internal {\\n    if (\\n      collectionId < AUTHORIZED_COLLECTION_ID_FIRST || collectionId > AUTHORIZED_COLLECTION_ID_LAST\\n    ) {\\n      revert CollectionIdOutOfBound(collectionId);\\n    }\\n    _badgeMintingPrice[collectionId] = price;\\n  }\\n\\n  /**\\n   * @dev MANDATORY: must be implemented in attesters\\n   * It should verify the user request is valid\\n   * @param request User request\\n   * @param proofData Data sent along the request to prove its validity\\n   */\\n  function _verifyRequest(Request calldata request, bytes calldata proofData) internal virtual;\\n\\n  /**\\n   * @dev Optional: must be overridden by attesters that want to feature attestations deletion\\n   * Default behavior: throws\\n   * It should verify attestations deletion request is valid\\n   * @param attestations Attestations that will be deleted\\n   * @param proofData Data sent along the request to prove its validity\\n   */\\n  function _verifyAttestationsDeletionRequest(\\n    Attestation[] memory attestations,\\n    bytes calldata proofData\\n  ) internal virtual {\\n    revert AttestationDeletionNotImplemented();\\n  }\\n\\n  /**\\n   * @dev Optional: Hook, can be overridden in attesters\\n   * Will be called before recording attestations in the registry\\n   * @param request User request\\n   * @param proofData Data sent along the request to prove its validity\\n   */\\n  function _beforeRecordAttestations(Request calldata request, bytes calldata proofData)\\n    internal\\n    virtual\\n  {}\\n\\n  /**\\n   * @dev (Optional) Can be overridden in attesters inheriting this contract\\n   * Will be called after recording an attestation\\n   * @param attestations Recorded attestations\\n   */\\n  function _afterRecordAttestations(Attestation[] memory attestations) internal virtual {}\\n\\n  /**\\n   * @dev Optional: Hook, can be overridden in attesters\\n   * Will be called before deleting attestations from the registry\\n   * @param attestations Attestations to delete\\n   * @param proofData Data sent along the deletion request to prove its validity\\n   */\\n  function _beforeDeleteAttestations(Attestation[] memory attestations, bytes calldata proofData)\\n    internal\\n    virtual\\n  {}\\n\\n  /**\\n   * @dev Optional: Hook, can be overridden in attesters\\n   * Will be called after deleting attestations from the registry\\n   * @param attestations Attestations to delete\\n   * @param proofData Data sent along the deletion request to prove its validity\\n   */\\n  function _afterDeleteAttestations(Attestation[] memory attestations, bytes calldata proofData)\\n    internal\\n    virtual\\n  {}\\n\\n  function _verifyBadgePayment(uint256 collectionId) internal view {\\n    if (_badgeMintingPrice[collectionId] > 0 && msg.value != _badgeMintingPrice[collectionId]) {\\n      revert InsufficientMintingPrice(_badgeMintingPrice[collectionId], msg.value);\\n    }\\n  }\\n\\n  function withdrawFees() external onlyOwner {\\n    payable(msg.sender).transfer(address(this).balance);\\n  }\\n\\n  function getBadgeMintingPrice(uint256 collectionId) external view returns (uint64) {\\n    return _badgeMintingPrice[collectionId];\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/attesters/signature/libs/SignatureAttesterLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nstruct SignatureGroupProperties {\\n  uint128 groupIndex;\\n  uint32 generationTimestamp;\\n  string badgeType; // identity, credential, skill\\n  string source; // github, discord...\\n  bytes badgeData;\\n}\\n\\nstruct EIP712Signature {\\n  uint8 v;\\n  bytes32 r;\\n  bytes32 s;\\n  uint256 deadline;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IAttester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport {Request, Attestation} from '../libs/Structs.sol';\\nimport {IAttestationsRegistry} from '../interfaces/IAttestationsRegistry.sol';\\n\\n/**\\n * @title IAttester\\n * @author Kleoverse - Forked from Sismo Protocol\\n * @notice This is the interface for the attesters in Proof of Talent Protocol\\n */\\ninterface IAttester {\\n  event AttestationGenerated(Attestation attestation);\\n\\n  event AttestationDeleted(Attestation attestation);\\n\\n  error AttestationDeletionNotImplemented();\\n  error InsufficientMintingPrice(uint256 price, uint256 sent);\\n  error LengthMismatch(string msg);\\n  error CollectionIdOutOfBound(uint256 collectionId);\\n\\n  /**\\n   * @dev Main external function. Allows to generate attestations by making a request and submitting proof\\n   * @param request User request\\n   * @param proofData Data sent along the request to prove its validity\\n   * @return attestations Attestations that has been recorded\\n   */\\n  function generateAttestations(Request calldata request, bytes calldata proofData)\\n    external\\n    payable\\n    returns (Attestation[] memory);\\n\\n  /**\\n   * @dev External facing function. Allows to delete an attestation by submitting proof\\n   * @param collectionIds Collection identifier of attestations to delete\\n   * @param attestationsOwner Owner of attestations to delete\\n   * @param proofData Data sent along the deletion request to prove its validity\\n   * @return attestations Attestations that was deleted\\n   */\\n  function deleteAttestations(\\n    uint256[] calldata collectionIds,\\n    address attestationsOwner,\\n    bytes calldata proofData\\n  ) external returns (Attestation[] memory);\\n\\n  /**\\n   * @dev MANDATORY: must be implemented in attesters\\n   * It should build attestations from the user request and the proof\\n   * @param request User request\\n   * @param proofData Data sent along the request to prove its validity\\n   * @return attestations Attestations that will be recorded\\n   */\\n  function buildAttestations(Request calldata request, bytes calldata proofData)\\n    external\\n    view\\n    returns (Attestation[] memory);\\n\\n  /**\\n   * @dev Attestation registry address getter\\n   * @return attestationRegistry Address of the registry\\n   */\\n  function getAttestationRegistry() external view returns (IAttestationsRegistry);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IAttestationsRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport {Attestation, AttestationData} from '../libs/Structs.sol';\\n\\n/**\\n * @title IAttestationsRegistry\\n * @author Kleoverse - Forked from Sismo Protocol\\n * @notice This is the interface of the AttestationRegistry\\n */\\ninterface IAttestationsRegistry {\\n  error IssuerNotAuthorized(address issuer, uint256 collectionId);\\n  error OwnersAndCollectionIdsLengthMismatch(address[] owners, uint256[] collectionIds);\\n  event AttestationRecorded(Attestation attestation);\\n  event AttestationDeleted(Attestation attestation);\\n\\n  /**\\n   * @dev Main function to be called by authorized issuers\\n   * @param attestations Attestations to be recorded (creates a new one or overrides an existing one)\\n   */\\n  function recordAttestations(Attestation[] calldata attestations) external;\\n\\n  /**\\n   * @dev Delete function to be called by authorized issuers\\n   * @param owners The owners of the attestations to be deleted\\n   * @param collectionIds The collection ids of the attestations to be deleted\\n   */\\n  function deleteAttestations(address[] calldata owners, uint256[] calldata collectionIds) external;\\n\\n  /**\\n   * @dev Returns whether a user has an attestation from a collection\\n   * @param collectionId Collection identifier of the targeted attestation\\n   * @param owner Owner of the targeted attestation\\n   */\\n  function hasAttestation(uint256 collectionId, address owner) external returns (bool);\\n\\n  /**\\n   * @dev Getter of the data of a specific attestation\\n   * @param collectionId Collection identifier of the targeted attestation\\n   * @param owner Owner of the targeted attestation\\n   */\\n  function getAttestationData(uint256 collectionId, address owner)\\n    external\\n    view\\n    returns (AttestationData memory);\\n\\n  /**\\n   * @dev Getter of the value of a specific attestation\\n   * @param collectionId Collection identifier of the targeted attestation\\n   * @param owner Owner of the targeted attestation\\n   */\\n  function getAttestationValue(uint256 collectionId, address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of the data of a specific attestation as tuple\\n   * @param collectionId Collection identifier of the targeted attestation\\n   * @param owner Owner of the targeted attestation\\n   */\\n  function getAttestationDataTuple(uint256 collectionId, address owner)\\n    external\\n    view\\n    returns (\\n      address,\\n      uint256,\\n      uint32,\\n      bytes memory\\n    );\\n\\n  /**\\n   * @dev Getter of the extraData of a specific attestation\\n   * @param collectionId Collection identifier of the targeted attestation\\n   * @param owner Owner of the targeted attestation\\n   */\\n  function getAttestationExtraData(uint256 collectionId, address owner)\\n    external\\n    view\\n    returns (bytes memory);\\n\\n  /**\\n   * @dev Getter of the issuer of a specific attestation\\n   * @param collectionId Collection identifier of the targeted attestation\\n   * @param owner Owner of the targeted attestation\\n   */\\n  function getAttestationIssuer(uint256 collectionId, address owner)\\n    external\\n    view\\n    returns (address);\\n\\n  /**\\n   * @dev Getter of the timestamp of a specific attestation\\n   * @param collectionId Collection identifier of the targeted attestation\\n   * @param owner Owner of the targeted attestation\\n   */\\n  function getAttestationTimestamp(uint256 collectionId, address owner)\\n    external\\n    view\\n    returns (uint32);\\n\\n  /**\\n   * @dev Getter of the data of specific attestations\\n   * @param collectionIds Collection identifiers of the targeted attestations\\n   * @param owners Owners of the targeted attestations\\n   */\\n  function getAttestationDataBatch(uint256[] memory collectionIds, address[] memory owners)\\n    external\\n    view\\n    returns (AttestationData[] memory);\\n\\n  /**\\n   * @dev Getter of the values of specific attestations\\n   * @param collectionIds Collection identifiers of the targeted attestations\\n   * @param owners Owners of the targeted attestations\\n   */\\n  function getAttestationValueBatch(uint256[] memory collectionIds, address[] memory owners)\\n    external\\n    view\\n    returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"attestationsRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collectionIdFirst\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectionIdLast\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifierAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"migrationContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AttestationDeletionNotImplemented\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"}],\"name\":\"CollectionIdOutOfBound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sent\",\"type\":\"uint256\"}],\"name\":\"InsufficientMintingPrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotAttestationOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"SignatureDeadlineExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"expectedSigner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"SignatureInvalid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"}],\"name\":\"SourceAlreadyUsed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"SourceDestinationNotSame\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct Attestation\",\"name\":\"attestation\",\"type\":\"tuple\"}],\"name\":\"AttestationDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct Attestation\",\"name\":\"attestation\",\"type\":\"tuple\"}],\"name\":\"AttestationGenerated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"attestationId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"SourceToDestinationUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AUTHORIZED_COLLECTION_ID_FIRST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AUTHORIZED_COLLECTION_ID_LAST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIGRATION_CONTRACT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERIFIER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Claim[]\",\"name\":\"claims\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"internalType\":\"struct Request\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"buildAttestations\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Attestation[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"collectionIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"attestationsOwner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"deleteAttestations\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Attestation[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Claim[]\",\"name\":\"claims\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"internalType\":\"struct Request\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"proofData\",\"type\":\"bytes\"}],\"name\":\"generateAttestations\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Attestation[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAttestationRegistry\",\"outputs\":[{\"internalType\":\"contract IAttestationsRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"}],\"name\":\"getBadgeMintingPrice\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"attestationId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"}],\"name\":\"getDestinationOfSource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"collectionIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint64[]\",\"name\":\"priceList\",\"type\":\"uint64[]\"}],\"name\":\"setBadgeMintingPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"attestationId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"setDestinationForSource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SignatureAttester", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c33926eef7195cc1128f48e8e877694dfe3c2dc400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000989680000000000000000000000000e5c7bd50c532c518fc2613c2934bd2003940298c000000000000000000000000f125d0cb945ef0e7f171062351c71ba9d90a865f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}