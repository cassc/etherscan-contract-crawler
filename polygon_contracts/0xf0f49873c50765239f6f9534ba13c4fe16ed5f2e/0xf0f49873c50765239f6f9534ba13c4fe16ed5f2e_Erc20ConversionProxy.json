{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/Erc20ConversionProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./ChainlinkConversionPath.sol\\\";\\nimport \\\"./interfaces/ERC20FeeProxy.sol\\\";\\n\\n\\n/**\\n * @title Erc20ConversionProxy\\n * @notice This contract convert from chainlink then swaps ERC20 tokens before paying a request thanks to a conversion payment proxy\\n  */\\ncontract Erc20ConversionProxy {\\n  using SafeMath for uint256;\\n\\n  address public paymentProxy;\\n  ChainlinkConversionPath public chainlinkConversionPath;\\n\\n  constructor(address _paymentProxyAddress, address _chainlinkConversionPathAddress) public {\\n    paymentProxy = _paymentProxyAddress;\\n    chainlinkConversionPath = ChainlinkConversionPath(_chainlinkConversionPathAddress);\\n  }\\n\\n  // Event to declare a conversion with a reference\\n  event TransferWithConversionAndReference(\\n    uint256 amount,\\n    address currency,\\n    bytes indexed paymentReference,\\n    uint256 feeAmount,\\n    uint256 maxRateTimespan\\n  );\\n  \\n  // Event to declare a transfer with a reference\\n  event TransferWithReferenceAndFee(\\n    address tokenAddress,\\n    address to,\\n    uint256 amount,\\n    bytes indexed paymentReference,\\n    uint256 feeAmount,\\n    address feeAddress\\n  );\\n\\n  /**\\n   * @notice Performs an ERC20 token transfer with a reference computing the payment amount based on the request amount\\n   * @param _to Transfer recipient of the payement\\n   * @param _requestAmount Request amount\\n   * @param _path Conversion path\\n   * @param _paymentReference Reference of the payment related\\n   * @param _feeAmount The amount of the payment fee\\n   * @param _feeAddress The fee recipient\\n   * @param _maxToSpend Amount max that we can spend on the behalf of the user\\n   * @param _maxRateTimespan Max time span with the oldestrate, ignored if zero\\n   */\\n  function transferFromWithReferenceAndFee(\\n    address _to,\\n    uint256 _requestAmount,\\n    address[] calldata _path,\\n    bytes calldata _paymentReference,\\n    uint256 _feeAmount,\\n    address _feeAddress,\\n    uint256 _maxToSpend,\\n    uint256 _maxRateTimespan\\n  )\\n  external\\n  {\\n    (uint256 amountToPay, uint256 amountToPayInFees) = getConversions(\\n      _path,\\n      _requestAmount,\\n      _feeAmount,\\n      _maxRateTimespan);\\n\\n    require(\\n      amountToPay.add(amountToPayInFees) <= _maxToSpend,\\n      \\\"Amount to pay is over the user limit\\\"\\n    );\\n\\n    // Pay the request and fees\\n    (bool status, ) = paymentProxy.delegatecall(\\n      abi.encodeWithSignature(\\n        \\\"transferFromWithReferenceAndFee(address,address,uint256,bytes,uint256,address)\\\",\\n        // payment currency\\n        _path[_path.length - 1],\\n        _to,\\n        amountToPay,\\n        _paymentReference,\\n        amountToPayInFees,\\n        _feeAddress\\n      )\\n    );\\n    require(status, \\\"transferFromWithReferenceAndFee failed\\\");\\n\\n    // Event to declare a transfer with a reference\\n    emit TransferWithConversionAndReference(\\n      _requestAmount,\\n      // request currency\\n      _path[0],\\n      _paymentReference,\\n      _feeAmount,\\n      _maxRateTimespan\\n    );\\n  }\\n\\n  function getConversions(\\n    address[] memory _path,\\n    uint256 _requestAmount,\\n    uint256 _feeAmount,\\n    uint256 _maxRateTimespan\\n  )\\n    internal\\n    returns (uint256 amountToPay, uint256 amountToPayInFees)\\n  {\\n    (uint256 rate, uint256 oldestTimestampRate, uint256 decimals) = chainlinkConversionPath.getRate(_path);\\n\\n    // Check rate timespan\\n    require(\\n      _maxRateTimespan == 0 || block.timestamp.sub(oldestTimestampRate) <= _maxRateTimespan,\\n      \\\"aggregator rate is outdated\\\"\\n    );\\n\\n    // Get the amount to pay in the crypto currency chosen\\n    amountToPay = _requestAmount.mul(rate).div(decimals);\\n    amountToPayInFees = _feeAmount.mul(rate).div(decimals);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/contracts/ChainlinkConversionPath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.25 <0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\\\";\\n\\ninterface ERC20fraction {\\n  function decimals() external view returns (uint8);\\n}\\n\\ninterface AggregatorFraction {\\n  function decimals() external view returns (uint8);\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n}\\n\\n\\n/**\\n * @title ChainlinkConversionPath\\n *\\n * @notice ChainlinkConversionPath is a contract computing currency conversion rates based on Chainlink aggretators\\n */\\ncontract ChainlinkConversionPath is WhitelistAdminRole {\\n  using SafeMath for uint256;\\n\\n  uint constant DECIMALS = 1e18;\\n\\n  // Mapping of Chainlink aggregators (input currency => output currency => contract address)\\n  // input & output currencies are the addresses of the ERC20 contracts OR the sha3(\\\"currency code\\\")\\n  mapping(address => mapping(address => address)) public allAggregators;\\n\\n  // declare a new aggregator\\n  event AggregatorUpdated(address _input, address _output, address _aggregator);\\n\\n  /**\\n    * @notice Update an aggregator\\n    * @param _input address representing the input currency\\n    * @param _output address representing the output currency\\n    * @param _aggregator address of the aggregator contract\\n  */\\n  function updateAggregator(address _input, address _output, address _aggregator)\\n    external\\n    onlyWhitelistAdmin\\n  {\\n    allAggregators[_input][_output] = _aggregator;\\n    emit AggregatorUpdated(_input, _output, _aggregator);\\n  }\\n\\n  /**\\n    * @notice Update a list of aggregators\\n    * @param _inputs list of addresses representing the input currencies\\n    * @param _outputs list of addresses representing the output currencies\\n    * @param _aggregators list of addresses of the aggregator contracts\\n  */\\n  function updateAggregatorsList(address[] calldata _inputs, address[] calldata _outputs, address[] calldata _aggregators)\\n    external\\n    onlyWhitelistAdmin\\n  {\\n    require(_inputs.length == _outputs.length, \\\"arrays must have the same length\\\");\\n    require(_inputs.length == _aggregators.length, \\\"arrays must have the same length\\\");\\n\\n    // For every conversions of the path\\n    for (uint i; i < _inputs.length; i++) {\\n      allAggregators[_inputs[i]][_outputs[i]] = _aggregators[i];\\n      emit AggregatorUpdated(_inputs[i], _outputs[i], _aggregators[i]);\\n    }\\n  }\\n\\n  /**\\n  * @notice Computes the conversion of an amount through a list of intermediate conversions\\n  * @param _amountIn Amount to convert\\n  * @param _path List of addresses representing the currencies for the intermediate conversions\\n  * @return result The result after all the conversions\\n  * @return oldestRateTimestamp The oldest timestamp of the path\\n  */\\n  function getConversion(\\n    uint256 _amountIn,\\n    address[] calldata _path\\n  )\\n    external\\n    view\\n    returns (uint256 result, uint256 oldestRateTimestamp)\\n  {\\n    (uint256 rate, uint256 timestamp, uint256 decimals) = getRate(_path);\\n\\n    // initialize the result\\n    result = _amountIn.mul(rate).div(decimals);\\n\\n    oldestRateTimestamp = timestamp;\\n  }\\n\\n  /**\\n  * @notice Computes the conversion rate from a list of currencies\\n  * @param _path List of addresses representing the currencies for the conversions\\n  * @return rate The rate\\n  * @return oldestRateTimestamp The oldest timestamp of the path\\n  * @return decimals of the conversion rate\\n  */\\n  function getRate(\\n    address[] memory _path\\n  )\\n    public\\n    view\\n    returns (uint256 rate, uint256 oldestRateTimestamp, uint256 decimals)\\n  {\\n    // initialize the result with 18 decimals (for more precision)\\n    rate = DECIMALS;\\n    decimals = DECIMALS;\\n    oldestRateTimestamp = block.timestamp;\\n\\n    // For every conversion of the path\\n    for (uint i; i < _path.length - 1; i++) {\\n      (AggregatorFraction aggregator, bool reverseAggregator, uint256 decimalsInput, uint256 decimalsOutput) = getAggregatorAndDecimals(_path[i], _path[i + 1]);\\n\\n      // store the latest timestamp of the path\\n      uint256 currentTimestamp = aggregator.latestTimestamp();\\n      if (currentTimestamp < oldestRateTimestamp) {\\n        oldestRateTimestamp = currentTimestamp;\\n      }\\n\\n      // get the rate of the current step\\n      uint256 currentRate = uint256(aggregator.latestAnswer());\\n      // get the number of decimals of the current rate\\n      uint256 decimalsAggregator = uint256(aggregator.decimals());\\n\\n      // mul with the difference of decimals before the current rate computation (for more precision)\\n      if (decimalsAggregator > decimalsInput) {\\n        rate = rate.mul(10**(decimalsAggregator-decimalsInput));\\n      }\\n      if (decimalsAggregator < decimalsOutput) {\\n        rate = rate.mul(10**(decimalsOutput-decimalsAggregator));\\n      }\\n\\n      // Apply the current rate (if path uses an aggregator in the reverse way, div instead of mul)\\n      if (reverseAggregator) {\\n        rate = rate.mul(10**decimalsAggregator).div(currentRate);\\n      } else {\\n        rate = rate.mul(currentRate).div(10**decimalsAggregator);\\n      }\\n\\n      // div with the difference of decimals AFTER the current rate computation (for more precision)\\n      if (decimalsAggregator < decimalsInput) {\\n        rate = rate.div(10**(decimalsInput-decimalsAggregator));\\n      }\\n      if (decimalsAggregator > decimalsOutput) {\\n        rate = rate.div(10**(decimalsAggregator-decimalsOutput));\\n      }\\n    }\\n  }\\n\\n  /**\\n  * @notice Gets aggregators and decimals of two currencies\\n  * @param _input input Address\\n  * @param _output output Address\\n  * @return aggregator to get the rate between the two currencies\\n  * @return reverseAggregator true if the aggregator returned give the rate from _output to _input\\n  * @return decimalsInput decimals of _input\\n  * @return decimalsOutput decimals of _output\\n  */\\n  function getAggregatorAndDecimals(address _input, address _output)\\n    private\\n    view\\n    returns (AggregatorFraction aggregator, bool reverseAggregator, uint256 decimalsInput, uint256 decimalsOutput)\\n  {\\n    // Try to get the right aggregator for the conversion\\n    aggregator = AggregatorFraction(allAggregators[_input][_output]);\\n    reverseAggregator = false;\\n\\n    // if no aggregator found we try to find an aggregator in the reverse way\\n    if (address(aggregator) == address(0x00)) {\\n      aggregator = AggregatorFraction(allAggregators[_output][_input]);\\n      reverseAggregator = true;\\n    }\\n\\n    require(address(aggregator) != address(0x00), \\\"No aggregator found\\\");\\n\\n    // get the decimals for the two currencies\\n    decimalsInput = getDecimals(_input);\\n    decimalsOutput = getDecimals(_output);\\n  }\\n\\n  /**\\n  * @notice Gets decimals from an address currency\\n  * @param _addr address to check\\n  * @return number of decimals\\n  */\\n  function getDecimals(address _addr)\\n    private\\n    view\\n    returns (uint256 decimals)\\n  {\\n    // by default we assume it is FIAT so 8 decimals\\n    decimals = 8;\\n    // if address is the hash of the ETH currency\\n    if (_addr == address(0xF5AF88e117747e87fC5929F2ff87221B1447652E)) {\\n      decimals = 18;\\n    } else if (isContract(_addr)) {\\n      // otherwise, we get the decimals from the erc20 directly\\n      decimals = ERC20fraction(_addr).decimals();\\n    }\\n  }\\n\\n  /**\\n  * @notice Checks if an address is a contract\\n  * @param _addr Address to check\\n  * @return true if the address hosts a contract, false otherwise\\n  */\\n  function isContract(address _addr)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    uint32 size;\\n    // solium-disable security/no-inline-assembly\\n    assembly {\\n      size := extcodesize(_addr)\\n    }\\n    return (size > 0);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/ERC20FeeProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.12;\\n\\ninterface IERC20FeeProxy {\\n  event TransferWithReferenceAndFee(\\n    address tokenAddress,\\n    address to,\\n    uint256 amount,\\n    bytes indexed paymentReference,\\n    uint256 feeAmount,\\n    address feeAddress\\n  );\\n\\n  function transferFromWithReferenceAndFee(\\n    address _tokenAddress,\\n    address _to,\\n    uint256 _amount,\\n    bytes calldata _paymentReference,\\n    uint256 _feeAmount,\\n    address _feeAddress\\n    ) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"../Roles.sol\\\";\\n\\n/**\\n * @title WhitelistAdminRole\\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\\n */\\ncontract WhitelistAdminRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event WhitelistAdminAdded(address indexed account);\\n    event WhitelistAdminRemoved(address indexed account);\\n\\n    Roles.Role private _whitelistAdmins;\\n\\n    constructor () internal {\\n        _addWhitelistAdmin(_msgSender());\\n    }\\n\\n    modifier onlyWhitelistAdmin() {\\n        require(isWhitelistAdmin(_msgSender()), \\\"WhitelistAdminRole: caller does not have the WhitelistAdmin role\\\");\\n        _;\\n    }\\n\\n    function isWhitelistAdmin(address account) public view returns (bool) {\\n        return _whitelistAdmins.has(account);\\n    }\\n\\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\\n        _addWhitelistAdmin(account);\\n    }\\n\\n    function renounceWhitelistAdmin() public {\\n        _removeWhitelistAdmin(_msgSender());\\n    }\\n\\n    function _addWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.add(account);\\n        emit WhitelistAdminAdded(account);\\n    }\\n\\n    function _removeWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.remove(account);\\n        emit WhitelistAdminRemoved(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Roles.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentProxyAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chainlinkConversionPathAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"paymentReference\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxRateTimespan\",\"type\":\"uint256\"}],\"name\":\"TransferWithConversionAndReference\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"paymentReference\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeAddress\",\"type\":\"address\"}],\"name\":\"TransferWithReferenceAndFee\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"chainlinkConversionPath\",\"outputs\":[{\"internalType\":\"contract ChainlinkConversionPath\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requestAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"_paymentReference\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxToSpend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxRateTimespan\",\"type\":\"uint256\"}],\"name\":\"transferFromWithReferenceAndFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Erc20ConversionProxy", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000dfbee143b42b41efc5a6f87bfd1ffc78c2f0ac9000000000000000000000000eec4790306c43dc00cebbe4d0c36fadf8634b533", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x0dfbee143b42b41efc5a6f87bfd1ffc78c2f0ac9", "SwarmSource": ""}