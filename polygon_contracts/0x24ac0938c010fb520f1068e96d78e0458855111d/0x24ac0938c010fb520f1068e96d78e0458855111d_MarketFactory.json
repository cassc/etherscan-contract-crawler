{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MarketFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -\\n// License: https://license.clober.io/LICENSE.pdf\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./interfaces/CloberMarketFactory.sol\\\";\\nimport \\\"./Errors.sol\\\";\\nimport \\\"./utils/RevertOnDelegateCall.sol\\\";\\nimport \\\"./utils/ReentrancyGuard.sol\\\";\\nimport \\\"./OrderNFT.sol\\\";\\nimport \\\"./utils/BoringERC20.sol\\\";\\nimport \\\"./interfaces/CloberMarketDeployer.sol\\\";\\nimport \\\"./interfaces/CloberOrderNFTDeployer.sol\\\";\\nimport \\\"./interfaces/CloberPriceBookDeployer.sol\\\";\\nimport \\\"./GeometricPriceBook.sol\\\";\\nimport \\\"./ArithmeticPriceBook.sol\\\";\\n\\ncontract MarketFactory is CloberMarketFactory, ReentrancyGuard, RevertOnDelegateCall {\\n    using BoringERC20 for IERC20;\\n\\n    uint24 private constant _MAX_FEE = 500000; // 50%\\n    int24 private constant _MIN_FEE = -500000; // -50%\\n    uint24 private constant _VOLATILE_MIN_NET_FEE = 400; // 0.04%\\n    uint24 private constant _STABLE_MIN_NET_FEE = 80; // 0.008%\\n\\n    uint256 private immutable _cachedChainId;\\n    address public immutable override marketDeployer;\\n    address public immutable override priceBookDeployer;\\n    address public immutable override orderTokenDeployer;\\n    address public immutable override canceler;\\n\\n    mapping(bytes32 => address) private _deployedPriceBook;\\n    mapping(address => bool) public override registeredQuoteTokens;\\n    address public override owner;\\n    address public override futureOwner;\\n    address public override daoTreasury;\\n    uint256 public override nonce;\\n\\n    mapping(address => MarketInfo) private _marketInfos;\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    function _checkOwner() internal view {\\n        if (msg.sender != owner) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n    }\\n\\n    modifier onlyRegisteredQuoteToken(address token) {\\n        if (!registeredQuoteTokens[token]) {\\n            revert Errors.CloberError(Errors.INVALID_QUOTE_TOKEN);\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        address marketDeployer_,\\n        address priceBookDeployer_,\\n        address orderTokenDeployer_,\\n        address initialDaoTreasury,\\n        address canceler_,\\n        address[] memory initialQuoteTokenRegistrations_\\n    ) {\\n        _cachedChainId = block.chainid;\\n        owner = msg.sender;\\n        emit ChangeOwner(address(0), msg.sender);\\n\\n        marketDeployer = marketDeployer_;\\n        priceBookDeployer = priceBookDeployer_;\\n        orderTokenDeployer = orderTokenDeployer_;\\n        daoTreasury = initialDaoTreasury;\\n        emit ChangeDaoTreasury(address(0), initialDaoTreasury);\\n        canceler = canceler_;\\n\\n        for (uint256 i = 0; i < initialQuoteTokenRegistrations_.length; ++i) {\\n            registeredQuoteTokens[initialQuoteTokenRegistrations_[i]] = true;\\n        }\\n    }\\n\\n    function createVolatileMarket(\\n        address marketHost,\\n        address quoteToken,\\n        address baseToken,\\n        uint96 quoteUnit,\\n        int24 makerFee,\\n        uint24 takerFee,\\n        uint128 a,\\n        uint128 r\\n    ) external revertOnDelegateCall onlyRegisteredQuoteToken(quoteToken) returns (address market) {\\n        _checkFee(marketHost, makerFee, takerFee, _VOLATILE_MIN_NET_FEE);\\n        bytes32 salt = _calculateSalt(nonce);\\n        address orderToken = _deployToken(salt);\\n        if (quoteUnit == 0) {\\n            revert Errors.CloberError(Errors.EMPTY_INPUT);\\n        }\\n        address priceBook;\\n        {\\n            bytes32 priceBookKey = _priceBookKey(a, r, MarketType.VOLATILE);\\n            priceBook = _deployedPriceBook[priceBookKey];\\n            if (priceBook == address(0)) {\\n                priceBook = CloberPriceBookDeployer(priceBookDeployer).deployGeometricPriceBook(a, r);\\n                _deployedPriceBook[priceBookKey] = priceBook;\\n            }\\n        }\\n        market = CloberMarketDeployer(marketDeployer).deploy(\\n            orderToken,\\n            quoteToken,\\n            baseToken,\\n            salt,\\n            quoteUnit,\\n            makerFee,\\n            takerFee,\\n            priceBook\\n        );\\n        emit CreateVolatileMarket(\\n            market,\\n            orderToken,\\n            quoteToken,\\n            baseToken,\\n            quoteUnit,\\n            nonce,\\n            makerFee,\\n            takerFee,\\n            a,\\n            r\\n        );\\n        _storeMarketInfo(market, marketHost, MarketType.VOLATILE, a, r);\\n        _initToken(orderToken, quoteToken, baseToken, nonce, market);\\n        nonce++;\\n    }\\n\\n    function createStableMarket(\\n        address marketHost,\\n        address quoteToken,\\n        address baseToken,\\n        uint96 quoteUnit,\\n        int24 makerFee,\\n        uint24 takerFee,\\n        uint128 a,\\n        uint128 d\\n    ) external revertOnDelegateCall onlyRegisteredQuoteToken(quoteToken) returns (address market) {\\n        _checkFee(marketHost, makerFee, takerFee, _STABLE_MIN_NET_FEE);\\n        bytes32 salt = _calculateSalt(nonce);\\n        address orderToken = _deployToken(salt);\\n        if (quoteUnit == 0) {\\n            revert Errors.CloberError(Errors.EMPTY_INPUT);\\n        }\\n        address priceBook;\\n        {\\n            bytes32 priceBookKey = _priceBookKey(a, d, MarketType.STABLE);\\n            priceBook = _deployedPriceBook[priceBookKey];\\n            if (priceBook == address(0)) {\\n                priceBook = CloberPriceBookDeployer(priceBookDeployer).deployArithmeticPriceBook(a, d);\\n                _deployedPriceBook[priceBookKey] = priceBook;\\n            }\\n        }\\n\\n        market = CloberMarketDeployer(marketDeployer).deploy(\\n            orderToken,\\n            quoteToken,\\n            baseToken,\\n            salt,\\n            quoteUnit,\\n            makerFee,\\n            takerFee,\\n            priceBook\\n        );\\n        emit CreateStableMarket(market, orderToken, quoteToken, baseToken, quoteUnit, nonce, makerFee, takerFee, a, d);\\n        _storeMarketInfo(market, marketHost, MarketType.STABLE, a, d);\\n        _initToken(orderToken, quoteToken, baseToken, nonce, market);\\n        nonce++;\\n    }\\n\\n    function changeDaoTreasury(address treasury) external onlyOwner {\\n        emit ChangeDaoTreasury(daoTreasury, treasury);\\n        daoTreasury = treasury;\\n    }\\n\\n    function prepareChangeOwner(address newOwner) external onlyOwner {\\n        futureOwner = newOwner;\\n    }\\n\\n    function executeChangeOwner() external {\\n        address newOwner = futureOwner;\\n        if (msg.sender != newOwner) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        emit ChangeOwner(owner, newOwner);\\n        owner = newOwner;\\n        delete futureOwner;\\n    }\\n\\n    function _priceBookKey(\\n        uint128 a,\\n        uint128 factor,\\n        MarketType marketType\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(a, factor, marketType));\\n    }\\n\\n    function deployedGeometricPriceBook(uint128 a, uint128 r) public view returns (address) {\\n        return _deployedPriceBook[_priceBookKey(a, r, MarketType.VOLATILE)];\\n    }\\n\\n    function deployedArithmeticPriceBook(uint128 a, uint128 d) public view returns (address) {\\n        return _deployedPriceBook[_priceBookKey(a, d, MarketType.STABLE)];\\n    }\\n\\n    function getMarketHost(address market) external view returns (address) {\\n        return _marketInfos[market].host;\\n    }\\n\\n    function prepareHandOverHost(address market, address newHost) external {\\n        address previousHost = _marketInfos[market].host;\\n        if (previousHost != msg.sender) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        _marketInfos[market].futureHost = newHost;\\n    }\\n\\n    function executeHandOverHost(address market) external {\\n        MarketInfo storage info = _marketInfos[market];\\n        address previousHost = info.host;\\n        address newHost = info.futureHost;\\n        if (newHost != msg.sender) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        info.host = newHost;\\n        delete info.futureHost;\\n        emit ChangeHost(market, previousHost, newHost);\\n    }\\n\\n    function _checkFee(\\n        address marketHost,\\n        int24 makerFee,\\n        uint24 takerFee,\\n        uint24 minNetFee\\n    ) internal view {\\n        // check makerFee\\n        if (makerFee < _MIN_FEE || int24(_MAX_FEE) < makerFee) {\\n            revert Errors.CloberError(Errors.INVALID_FEE);\\n        }\\n        // check takerFee\\n        // takerFee is always positive\\n        if (_MAX_FEE < takerFee) {\\n            revert Errors.CloberError(Errors.INVALID_FEE);\\n        }\\n        // check net fee\\n        if (marketHost != owner && int256(uint256(takerFee)) + makerFee < int256(uint256(minNetFee))) {\\n            revert Errors.CloberError(Errors.INVALID_FEE);\\n        } else if (makerFee < 0 && int256(uint256(takerFee)) + makerFee < 0) {\\n            revert Errors.CloberError(Errors.INVALID_FEE);\\n        }\\n    }\\n\\n    function _deployToken(bytes32 salt) internal returns (address) {\\n        return CloberOrderNFTDeployer(orderTokenDeployer).deploy(salt);\\n    }\\n\\n    function _initToken(\\n        address token,\\n        address quoteToken,\\n        address baseToken,\\n        uint256 marketNonce,\\n        address market\\n    ) internal {\\n        OrderNFT(token).init(\\n            formatOrderTokenName(quoteToken, baseToken, marketNonce),\\n            formatOrderTokenSymbol(quoteToken, baseToken, marketNonce),\\n            market\\n        );\\n    }\\n\\n    function _storeMarketInfo(\\n        address market,\\n        address host,\\n        MarketType marketType,\\n        uint128 a,\\n        uint128 factor\\n    ) internal {\\n        if (host == address(0)) {\\n            revert Errors.CloberError(Errors.EMPTY_INPUT);\\n        }\\n        _marketInfos[market] = MarketInfo({\\n            host: host,\\n            marketType: marketType,\\n            a: a,\\n            factor: factor,\\n            futureHost: address(0)\\n        });\\n        emit ChangeHost(market, address(0), host);\\n    }\\n\\n    function getMarketInfo(address market) external view returns (MarketInfo memory) {\\n        return _marketInfos[market];\\n    }\\n\\n    function registerQuoteToken(address token) external onlyOwner {\\n        registeredQuoteTokens[token] = true;\\n    }\\n\\n    function unregisterQuoteToken(address token) external onlyOwner {\\n        registeredQuoteTokens[token] = false;\\n    }\\n\\n    function _calculateSalt(uint256 marketNonce) internal view returns (bytes32) {\\n        return keccak256(abi.encode(_cachedChainId, marketNonce));\\n    }\\n\\n    function formatOrderTokenName(\\n        address quoteToken,\\n        address baseToken,\\n        uint256 marketNonce\\n    ) public view returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"Clober Order: \\\",\\n                    IERC20(baseToken).safeSymbol(),\\n                    \\\"/\\\",\\n                    IERC20(quoteToken).safeSymbol(),\\n                    \\\"(\\\",\\n                    Strings.toString(marketNonce),\\n                    \\\")\\\"\\n                )\\n            );\\n    }\\n\\n    function formatOrderTokenSymbol(\\n        address quoteToken,\\n        address baseToken,\\n        uint256 marketNonce\\n    ) public view returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"CLOB-\\\",\\n                    IERC20(baseToken).safeSymbol(),\\n                    \\\"/\\\",\\n                    IERC20(quoteToken).safeSymbol(),\\n                    \\\"(\\\",\\n                    Strings.toString(marketNonce),\\n                    \\\")\\\"\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -\\n// License: https://license.clober.io/LICENSE.pdf\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Errors {\\n    error CloberError(uint256 errorCode); // 0x1d25260a\\n\\n    uint256 public constant ACCESS = 0;\\n    uint256 public constant FAILED_TO_SEND_VALUE = 1;\\n    uint256 public constant INSUFFICIENT_BALANCE = 2;\\n    uint256 public constant OVERFLOW_UNDERFLOW = 3;\\n    uint256 public constant EMPTY_INPUT = 4;\\n    uint256 public constant DELEGATE_CALL = 5;\\n    uint256 public constant DEADLINE = 6;\\n    uint256 public constant NOT_IMPLEMENTED_INTERFACE = 7;\\n    uint256 public constant INVALID_FEE = 8;\\n    uint256 public constant REENTRANCY = 9;\\n    uint256 public constant POST_ONLY = 10;\\n    uint256 public constant SLIPPAGE = 11;\\n    uint256 public constant QUEUE_REPLACE_FAILED = 12;\\n    uint256 public constant INVALID_COEFFICIENTS = 13;\\n    uint256 public constant INVALID_ID = 14;\\n    uint256 public constant INVALID_QUOTE_TOKEN = 15;\\n    uint256 public constant INVALID_PRICE = 16;\\n    uint256 public constant INVALID_PRICE_INDEX = 17;\\n}\\n\"\r\n    },\r\n    \"contracts/OrderNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -\\n// License: https://license.clober.io/LICENSE.pdf\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nimport \\\"./interfaces/CloberMarketFactory.sol\\\";\\nimport \\\"./interfaces/CloberOrderBook.sol\\\";\\nimport \\\"./interfaces/CloberOrderNFT.sol\\\";\\nimport \\\"./Errors.sol\\\";\\nimport \\\"./utils/OrderKeyUtils.sol\\\";\\n\\ncontract OrderNFT is ERC165, CloberOrderNFT {\\n    using Address for address;\\n    using Strings for uint256;\\n    using OrderKeyUtils for OrderKey;\\n\\n    CloberMarketFactory private immutable _factory;\\n    address private immutable _canceler;\\n\\n    string public override name;\\n    string public override symbol;\\n    string public override baseURI;\\n    string public override contractURI;\\n    address public override market;\\n\\n    mapping(address => uint256) private _balances;\\n    mapping(uint256 => address) private _tokenApprovals;\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    constructor(address factory, address canceler) {\\n        _factory = CloberMarketFactory(factory);\\n        _canceler = canceler;\\n    }\\n\\n    function init(\\n        string memory name_,\\n        string memory symbol_,\\n        address market_\\n    ) external {\\n        if (market != address(0)) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        if (market_ == address(0)) {\\n            revert Errors.CloberError(Errors.EMPTY_INPUT);\\n        }\\n        name = name_;\\n        symbol = symbol_;\\n        market = market_;\\n    }\\n\\n    modifier onlyMarket() {\\n        if (msg.sender != market) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyExists(uint256 tokenId) {\\n        if (_getOrderOwner(tokenId) == address(0)) {\\n            revert Errors.CloberError(Errors.INVALID_ID);\\n        }\\n        _;\\n    }\\n\\n    function changeBaseURI(string memory newBaseURI) external {\\n        if (_getHost() != msg.sender) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        baseURI = newBaseURI;\\n    }\\n\\n    function changeContractURI(string memory newContractURI) external {\\n        if (_getHost() != msg.sender) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        contractURI = newContractURI;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function balanceOf(address user) public view returns (uint256) {\\n        if (user == address(0)) {\\n            revert Errors.CloberError(Errors.EMPTY_INPUT);\\n        }\\n        uint256 balance = _balances[user];\\n        return balance > 0 ? balance - 1 : balance;\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        address tokenOwner = _getOrderOwner(tokenId);\\n        if (tokenOwner == address(0)) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        return tokenOwner;\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view onlyExists(tokenId) returns (string memory) {\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    function approve(address to, uint256 tokenId) public {\\n        address tokenOwner = ownerOf(tokenId);\\n        if (to == tokenOwner) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n\\n        if (msg.sender != tokenOwner && !isApprovedForAll(tokenOwner, msg.sender)) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n\\n        _approve(tokenOwner, to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId) public view onlyExists(tokenId) returns (address) {\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public {\\n        if (msg.sender == operator) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(address tokenOwner, address operator) public view returns (bool) {\\n        return _operatorApprovals[tokenOwner][operator];\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public {\\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public {\\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal {\\n        _transfer(from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, data)) {\\n            revert Errors.CloberError(Errors.NOT_IMPLEMENTED_INTERFACE);\\n        }\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        address tokenOwner = ownerOf(tokenId);\\n        return (spender == tokenOwner || isApprovedForAll(tokenOwner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    function _increaseBalance(address to) internal {\\n        _balances[to] += _balances[to] > 0 ? 1 : 2;\\n    }\\n\\n    function _decreaseBalance(address to) internal {\\n        _balances[to] -= 1;\\n    }\\n\\n    function onMint(address to, uint256 tokenId) external onlyMarket {\\n        if (to == address(0)) {\\n            revert Errors.CloberError(Errors.EMPTY_INPUT);\\n        }\\n\\n        _increaseBalance(to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function onBurn(uint256 tokenId) external onlyMarket {\\n        address tokenOwner = ownerOf(tokenId);\\n\\n        // Clear approvals\\n        _approve(tokenOwner, address(0), tokenId);\\n\\n        _decreaseBalance(tokenOwner);\\n\\n        emit Transfer(tokenOwner, address(0), tokenId);\\n    }\\n\\n    function cancel(\\n        address from,\\n        uint256[] calldata tokenIds,\\n        address receiver\\n    ) external {\\n        if (msg.sender != _canceler) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        OrderKey[] memory orderKeys = new OrderKey[](tokenIds.length);\\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\\n            if (!_isApprovedOrOwner(from, tokenIds[i])) {\\n                revert Errors.CloberError(Errors.ACCESS);\\n            }\\n            orderKeys[i] = decodeId(tokenIds[i]);\\n        }\\n        CloberOrderBook(market).cancel(receiver, orderKeys);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        if (ownerOf(tokenId) != from) {\\n            revert Errors.CloberError(Errors.ACCESS);\\n        }\\n        if (to == address(0)) {\\n            revert Errors.CloberError(Errors.EMPTY_INPUT);\\n        }\\n\\n        // Clear approvals from the previous owner\\n        _approve(from, address(0), tokenId);\\n\\n        _decreaseBalance(from);\\n        _increaseBalance(to);\\n        CloberOrderBook(market).changeOrderOwner(decodeId(tokenId), to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _approve(\\n        address tokenOwner,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(tokenOwner, to, tokenId);\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert Errors.CloberError(Errors.NOT_IMPLEMENTED_INTERFACE);\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function decodeId(uint256 id) public pure returns (OrderKey memory) {\\n        return OrderKeyUtils.decode(id);\\n    }\\n\\n    function encodeId(OrderKey memory orderKey) external pure returns (uint256 id) {\\n        return orderKey.encode();\\n    }\\n\\n    function owner() external view returns (address) {\\n        return _getHost();\\n    }\\n\\n    function _getHost() internal view returns (address) {\\n        return _factory.getMarketHost(market);\\n    }\\n\\n    function _getOrderOwner(uint256 tokenId) internal view returns (address) {\\n        return CloberOrderBook(market).getOrder(decodeId(tokenId)).owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GeometricPriceBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -\\n// License: https://license.clober.io/LICENSE.pdf\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Errors.sol\\\";\\nimport \\\"./interfaces/CloberPriceBook.sol\\\";\\n\\ncontract GeometricPriceBook is CloberPriceBook {\\n    uint256 private immutable _a;\\n    uint256 private immutable _r0;\\n    uint256 private immutable _r1;\\n    uint256 private immutable _r2;\\n    uint256 private immutable _r3;\\n    uint256 private immutable _r4;\\n    uint256 private immutable _r5;\\n    uint256 private immutable _r6;\\n    uint256 private immutable _r7;\\n    uint256 private immutable _r8;\\n    uint256 private immutable _r9;\\n    uint256 private immutable _r10;\\n    uint256 private immutable _r11;\\n    uint256 private immutable _r12;\\n    uint256 private immutable _r13;\\n    uint256 private immutable _r14;\\n    uint256 private immutable _r15;\\n    uint256 private immutable _r16;\\n\\n    uint16 public immutable maxPriceIndex;\\n    uint256 public immutable override priceUpperBound;\\n\\n    constructor(uint128 a_, uint128 r_) {\\n        uint256 castedR = uint256(r_);\\n        _a = a_;\\n        // precision of `_r0~16` is 2^64\\n        _r0 = (castedR << 64) / 10**18;\\n        // when `r_` <= 1\\n        if ((a_ * _r0) >> 64 <= a_) {\\n            revert Errors.CloberError(Errors.INVALID_COEFFICIENTS);\\n        }\\n        uint16 maxIndex_;\\n        uint256 maxPrice_ = 1 << 64;\\n\\n        uint256 r;\\n        if (_r0 < type(uint256).max / _r0) {\\n            r = (_r0 * _r0) >> 64;\\n            maxIndex_ = maxIndex_ | 0x1;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r1 = r;\\n\\n        if (_r1 < type(uint256).max / _r1) {\\n            r = (_r1 * _r1) >> 64;\\n            maxIndex_ = maxIndex_ | 0x2;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r2 = r;\\n\\n        if (_r2 < type(uint256).max / _r2) {\\n            r = (_r2 * _r2) >> 64;\\n            maxIndex_ = maxIndex_ | 0x4;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r3 = r;\\n\\n        if (_r3 < type(uint256).max / _r3) {\\n            r = (_r3 * _r3) >> 64;\\n            maxIndex_ = maxIndex_ | 0x8;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r4 = r;\\n\\n        if (_r4 < type(uint256).max / _r4) {\\n            r = (_r4 * _r4) >> 64;\\n            maxIndex_ = maxIndex_ | 0x10;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r5 = r;\\n\\n        if (_r5 < type(uint256).max / _r5) {\\n            r = (_r5 * _r5) >> 64;\\n            maxIndex_ = maxIndex_ | 0x20;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r6 = r;\\n\\n        if (_r6 < type(uint256).max / _r6) {\\n            r = (_r6 * _r6) >> 64;\\n            maxIndex_ = maxIndex_ | 0x40;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r7 = r;\\n\\n        if (_r7 < type(uint256).max / _r7) {\\n            r = (_r7 * _r7) >> 64;\\n            maxIndex_ = maxIndex_ | 0x80;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r8 = r;\\n\\n        if (_r8 < type(uint256).max / _r8) {\\n            r = (_r8 * _r8) >> 64;\\n            maxIndex_ = maxIndex_ | 0x100;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r9 = r;\\n\\n        if (_r9 < type(uint256).max / _r9) {\\n            r = (_r9 * _r9) >> 64;\\n            maxIndex_ = maxIndex_ | 0x200;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r10 = r;\\n\\n        if (_r10 < type(uint256).max / _r10) {\\n            r = (_r10 * _r10) >> 64;\\n            maxIndex_ = maxIndex_ | 0x400;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r11 = r;\\n\\n        if (_r11 < type(uint256).max / _r11) {\\n            r = (_r11 * _r11) >> 64;\\n            maxIndex_ = maxIndex_ | 0x800;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r12 = r;\\n\\n        if (_r12 < type(uint256).max / _r12) {\\n            r = (_r12 * _r12) >> 64;\\n            maxIndex_ = maxIndex_ | 0x1000;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r13 = r;\\n\\n        if (_r13 < type(uint256).max / _r13) {\\n            r = (_r13 * _r13) >> 64;\\n            maxIndex_ = maxIndex_ | 0x2000;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r14 = r;\\n\\n        if (_r14 < type(uint256).max / _r14) {\\n            r = (_r14 * _r14) >> 64;\\n            maxIndex_ = maxIndex_ | 0x4000;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r15 = r;\\n\\n        if (_r15 < type(uint256).max / _r15) {\\n            r = (_r15 * _r15) >> 64;\\n            maxIndex_ = maxIndex_ | 0x8000;\\n            maxPrice_ = r;\\n        } else {\\n            r = type(uint256).max;\\n        }\\n        _r16 = r;\\n\\n        maxPriceIndex = maxIndex_;\\n        priceUpperBound = (maxPrice_ >> 64) * a_ + (((maxPrice_ & 0xffffffffffffffff) * a_) >> 64);\\n    }\\n\\n    function indexToPrice(uint16 priceIndex) public view returns (uint256 price) {\\n        if (priceIndex > maxPriceIndex) {\\n            revert Errors.CloberError(Errors.INVALID_PRICE_INDEX);\\n        }\\n        price = _a;\\n        unchecked {\\n            if (priceIndex & (maxPriceIndex & 0x8000) != 0) price = (price * _r15) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x4000) != 0) price = (price * _r14) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x2000) != 0) price = (price * _r13) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x1000) != 0) price = (price * _r12) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x800) != 0) price = (price * _r11) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x400) != 0) price = (price * _r10) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x200) != 0) price = (price * _r9) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x100) != 0) price = (price * _r8) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x80) != 0) price = (price * _r7) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x40) != 0) price = (price * _r6) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x20) != 0) price = (price * _r5) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x10) != 0) price = (price * _r4) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x8) != 0) price = (price * _r3) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x4) != 0) price = (price * _r2) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x2) != 0) price = (price * _r1) >> 64;\\n            if (priceIndex & (maxPriceIndex & 0x1) != 0) price = (price * _r0) >> 64;\\n        }\\n    }\\n\\n    function priceToIndex(uint256 price, bool roundingUp) external view returns (uint16 index, uint256 correctedPrice) {\\n        if (price < _a || price >= priceUpperBound) {\\n            revert Errors.CloberError(Errors.INVALID_PRICE);\\n        }\\n        index = 0;\\n        uint256 _correctedPrice = _a;\\n        uint256 shiftedPrice = (price + 1) << 64;\\n\\n        unchecked {\\n            if (maxPriceIndex > 0x8000 && shiftedPrice > _r15 * _correctedPrice) {\\n                index = index | 0x8000;\\n                _correctedPrice = (_correctedPrice * _r15) >> 64;\\n            }\\n            if (maxPriceIndex > 0x4000 && shiftedPrice > _r14 * _correctedPrice) {\\n                index = index | 0x4000;\\n                _correctedPrice = (_correctedPrice * _r14) >> 64;\\n            }\\n            if (maxPriceIndex > 0x2000 && shiftedPrice > _r13 * _correctedPrice) {\\n                index = index | 0x2000;\\n                _correctedPrice = (_correctedPrice * _r13) >> 64;\\n            }\\n            if (maxPriceIndex > 0x1000 && shiftedPrice > _r12 * _correctedPrice) {\\n                index = index | 0x1000;\\n                _correctedPrice = (_correctedPrice * _r12) >> 64;\\n            }\\n            if (maxPriceIndex > 0x800 && shiftedPrice > _r11 * _correctedPrice) {\\n                index = index | 0x0800;\\n                _correctedPrice = (_correctedPrice * _r11) >> 64;\\n            }\\n            if (maxPriceIndex > 0x400 && shiftedPrice > _r10 * _correctedPrice) {\\n                index = index | 0x0400;\\n                _correctedPrice = (_correctedPrice * _r10) >> 64;\\n            }\\n            if (maxPriceIndex > 0x200 && shiftedPrice > _r9 * _correctedPrice) {\\n                index = index | 0x0200;\\n                _correctedPrice = (_correctedPrice * _r9) >> 64;\\n            }\\n            if (maxPriceIndex > 0x100 && shiftedPrice > _r8 * _correctedPrice) {\\n                index = index | 0x0100;\\n                _correctedPrice = (_correctedPrice * _r8) >> 64;\\n            }\\n            if (maxPriceIndex > 0x80 && shiftedPrice > _r7 * _correctedPrice) {\\n                index = index | 0x0080;\\n                _correctedPrice = (_correctedPrice * _r7) >> 64;\\n            }\\n            if (maxPriceIndex > 0x40 && shiftedPrice > _r6 * _correctedPrice) {\\n                index = index | 0x0040;\\n                _correctedPrice = (_correctedPrice * _r6) >> 64;\\n            }\\n            if (maxPriceIndex > 0x20 && shiftedPrice > _r5 * _correctedPrice) {\\n                index = index | 0x0020;\\n                _correctedPrice = (_correctedPrice * _r5) >> 64;\\n            }\\n            if (maxPriceIndex > 0x10 && shiftedPrice > _r4 * _correctedPrice) {\\n                index = index | 0x0010;\\n                _correctedPrice = (_correctedPrice * _r4) >> 64;\\n            }\\n            if (maxPriceIndex > 0x8 && shiftedPrice > _r3 * _correctedPrice) {\\n                index = index | 0x0008;\\n                _correctedPrice = (_correctedPrice * _r3) >> 64;\\n            }\\n            if (maxPriceIndex > 0x4 && shiftedPrice > _r2 * _correctedPrice) {\\n                index = index | 0x0004;\\n                _correctedPrice = (_correctedPrice * _r2) >> 64;\\n            }\\n            if (maxPriceIndex > 0x2 && shiftedPrice > _r1 * _correctedPrice) {\\n                index = index | 0x0002;\\n                _correctedPrice = (_correctedPrice * _r1) >> 64;\\n            }\\n            if (shiftedPrice > _r0 * _correctedPrice) {\\n                index = index | 0x0001;\\n                _correctedPrice = (_correctedPrice * _r0) >> 64;\\n            }\\n        }\\n        if (roundingUp && _correctedPrice < price) {\\n            unchecked {\\n                if (index >= maxPriceIndex) {\\n                    revert Errors.CloberError(Errors.INVALID_PRICE);\\n                }\\n                index += 1;\\n            }\\n            correctedPrice = indexToPrice(index);\\n        } else {\\n            correctedPrice = _correctedPrice;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ArithmeticPriceBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -\\n// License: https://license.clober.io/LICENSE.pdf\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Errors.sol\\\";\\nimport \\\"./interfaces/CloberPriceBook.sol\\\";\\n\\ncontract ArithmeticPriceBook is CloberPriceBook {\\n    uint128 private immutable _a;\\n    uint128 private immutable _d;\\n\\n    uint16 public immutable override maxPriceIndex;\\n    uint256 public immutable override priceUpperBound;\\n\\n    constructor(uint128 a, uint128 d) {\\n        _a = a;\\n        _d = d;\\n\\n        maxPriceIndex = type(uint16).max;\\n        priceUpperBound = a + type(uint16).max * d;\\n\\n        if (d == 0) {\\n            revert Errors.CloberError(Errors.INVALID_COEFFICIENTS);\\n        }\\n    }\\n\\n    function indexToPrice(uint16 priceIndex) external view returns (uint256) {\\n        return _a + _d * priceIndex;\\n    }\\n\\n    function priceToIndex(uint256 price, bool roundingUp) external view returns (uint16 index, uint256 correctedPrice) {\\n        if (price < _a || price >= _a + _d * (2**16)) {\\n            revert Errors.CloberError(Errors.INVALID_PRICE);\\n        }\\n        index = uint16((price - _a) / _d);\\n        if (roundingUp && (price - _a) % _d > 0) {\\n            unchecked {\\n                if (index == type(uint16).max) {\\n                    revert Errors.CloberError(Errors.INVALID_PRICE);\\n                }\\n                index += 1;\\n            }\\n        }\\n        correctedPrice = _a + _d * index;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CloberMarketFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\ninterface CloberMarketFactory {\\n    /**\\n     * @notice Emitted when a new volatile market is created.\\n     * @param market The address of the new market.\\n     * @param orderToken The address of the new market's order token.\\n     * @param quoteToken The address of the new market's quote token.\\n     * @param baseToken The address of the new market's base token.\\n     * @param quoteUnit The amount that one raw amount represents in quote tokens.\\n     * @param nonce The nonce for this market.\\n     * @param makerFee The maker fee.\\n     * Paid to the maker when negative, paid by the maker when positive.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @param takerFee The taker fee.\\n     * Paid by the taker.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @param a The scale factor of the price points.\\n     * @param r The common ratio between price points.\\n     */\\n    event CreateVolatileMarket(\\n        address indexed market,\\n        address orderToken,\\n        address quoteToken,\\n        address baseToken,\\n        uint256 quoteUnit,\\n        uint256 nonce,\\n        int24 makerFee,\\n        uint24 takerFee,\\n        uint128 a,\\n        uint128 r\\n    );\\n\\n    /**\\n     * @notice Emitted when a new stable market is created.\\n     * @param market The address of the new market.\\n     * @param orderToken The address of the new market's order token.\\n     * @param quoteToken The address of the new market's quote token.\\n     * @param baseToken The address of the new market's base token.\\n     * @param quoteUnit The amount that one raw amount represents in quote tokens.\\n     * @param nonce The nonce for this market.\\n     * @param makerFee The maker fee.\\n     * Paid to the maker when negative, paid by the maker when positive.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @param takerFee The taker fee.\\n     * Paid by the taker.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @param a The starting price point.\\n     * @param d The common difference between price points.\\n     */\\n    event CreateStableMarket(\\n        address indexed market,\\n        address orderToken,\\n        address quoteToken,\\n        address baseToken,\\n        uint256 quoteUnit,\\n        uint256 nonce,\\n        int24 makerFee,\\n        uint24 takerFee,\\n        uint128 a,\\n        uint128 d\\n    );\\n\\n    /**\\n     * @notice Emitted when the address of the owner has changed.\\n     * @param previousOwner The address of the previous owner.\\n     * @param newOwner The address of the new owner.\\n     */\\n    event ChangeOwner(address previousOwner, address newOwner);\\n\\n    /**\\n     * @notice Emitted when the DAO Treasury address has changed.\\n     * @param previousTreasury The address of the previous DAO Treasury.\\n     * @param newTreasury The address of the new DAO Treasury.\\n     */\\n    event ChangeDaoTreasury(address previousTreasury, address newTreasury);\\n\\n    /**\\n     * @notice Emitted when the host address has changed.\\n     * @param market The address of the market that had a change of hosts.\\n     * @param previousHost The address of the previous host.\\n     * @param newHost The address of a new host.\\n     */\\n    event ChangeHost(address indexed market, address previousHost, address newHost);\\n\\n    /**\\n     * @notice Returns the address of the deployed GeometricPriceBook.\\n     * @return The address of the GeometricPriceBook.\\n     */\\n    function deployedGeometricPriceBook(uint128 a, uint128 r) external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the deployed GeometricPriceBook.\\n     * @return The address of the GeometricPriceBook.\\n     */\\n    function deployedArithmeticPriceBook(uint128 a, uint128 d) external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the MarketDeployer.\\n     * @return The address of the MarketDeployer.\\n     */\\n    function marketDeployer() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the priceBookDeployer.\\n     * @return The address of the priceBookDeployer.\\n     */\\n    function priceBookDeployer() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the orderTokenDeployer.\\n     * @return The address of the orderTokenDeployer.\\n     */\\n    function orderTokenDeployer() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the OrderCanceler.\\n     * @return The address of the OrderCanceler.\\n     */\\n    function canceler() external view returns (address);\\n\\n    /**\\n     * @notice Returns whether the specified token address has been registered as a quote token.\\n     * @param token The address of the token to check.\\n     * @return bool Whether the token is registered as a quote token.\\n     */\\n    function registeredQuoteTokens(address token) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the address of the factory owner\\n     * @return The address of the factory owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the factory owner candidate\\n     * @return The address of the factory owner candidate\\n     */\\n    function futureOwner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the DAO Treasury\\n     * @return The address of the DAO Treasury\\n     */\\n    function daoTreasury() external view returns (address);\\n\\n    /**\\n     * @notice Returns the current nonce\\n     * @return The current nonce\\n     */\\n    function nonce() external view returns (uint256);\\n\\n    /**\\n     * @notice Creates a new market with a VolatilePriceBook.\\n     * @param host The address of the new market's host.\\n     * @param quoteToken The address of the new market's quote token.\\n     * @param baseToken The address of the new market's base token.\\n     * @param quoteUnit The amount that one raw amount represents in quote tokens.\\n     * @param makerFee The maker fee.\\n     * Paid to the maker when negative, paid by the maker when positive.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @param takerFee The taker fee.\\n     * Paid by the taker.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @param a The scale factor of the price points.\\n     * @param r The common ratio between price points.\\n     * @return The address of the created market.\\n     */\\n    function createVolatileMarket(\\n        address host,\\n        address quoteToken,\\n        address baseToken,\\n        uint96 quoteUnit,\\n        int24 makerFee,\\n        uint24 takerFee,\\n        uint128 a,\\n        uint128 r\\n    ) external returns (address);\\n\\n    /**\\n     * @notice Creates a new market with a StablePriceBook\\n     * @param host The address of the new market's host\\n     * @param quoteToken The address of the new market's quote token\\n     * @param baseToken The address of the new market's base token\\n     * @param quoteUnit The amount that one raw amount represents in quote tokens\\n     * @param makerFee The maker fee.\\n     * Paid to the maker when negative, paid by the maker when positive.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @param takerFee The taker fee.\\n     * Paid by the taker.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @param a The starting price point.\\n     * @param d The common difference between price points.\\n     * @return The address of the created market.\\n     */\\n    function createStableMarket(\\n        address host,\\n        address quoteToken,\\n        address baseToken,\\n        uint96 quoteUnit,\\n        int24 makerFee,\\n        uint24 takerFee,\\n        uint128 a,\\n        uint128 d\\n    ) external returns (address);\\n\\n    /**\\n     * @notice Change the DAO Treasury address.\\n     * @dev Only the factory owner can call this function.\\n     * @param treasury The new address of the DAO Treasury.\\n     */\\n    function changeDaoTreasury(address treasury) external;\\n\\n    /**\\n     * @notice Sets the new owner address for this contract.\\n     * @dev Only the factory owner can call this function.\\n     * @param newOwner The new owner address for this contract.\\n     */\\n    function prepareChangeOwner(address newOwner) external;\\n\\n    /**\\n     * @notice Changes the owner of this contract to the address set by `prepareChangeOwner`.\\n     * @dev Only the future owner can call this function.\\n     */\\n    function executeChangeOwner() external;\\n\\n    /**\\n     * @notice Returns the host address of the given market.\\n     * @param market The address of the target market.\\n     * @return The host address of the market.\\n     */\\n    function getMarketHost(address market) external view returns (address);\\n\\n    /**\\n     * @notice Prepares to set a new host address for the given market address.\\n     * @dev Only the market host can call this function.\\n     * @param market The market address for which the host will be changed.\\n     * @param newHost The new host address for the given market.\\n     */\\n    function prepareHandOverHost(address market, address newHost) external;\\n\\n    /**\\n     * @notice Changes the host address of the given market to the address set by `prepareHandOverHost`.\\n     * @dev Only the future market host can call this function.\\n     * @param market The market address for which the host will be changed.\\n     */\\n    function executeHandOverHost(address market) external;\\n\\n    enum MarketType {\\n        NONE,\\n        VOLATILE,\\n        STABLE\\n    }\\n\\n    /**\\n     * @notice MarketInfo struct that contains information about a market.\\n     * @param host The address of the market host.\\n     * @param marketType The market type, either VOLATILE or STABLE.\\n     * @param a The starting price point.\\n     * @param factor The either the common ratio or common difference between price points.\\n     * @param futureHost The address set by `prepareHandOverHost` to change the market host.\\n     */\\n    struct MarketInfo {\\n        address host;\\n        MarketType marketType;\\n        uint128 a;\\n        uint128 factor;\\n        address futureHost;\\n    }\\n\\n    /**\\n     * @notice Returns key information about the market.\\n     * @param market The address of the market.\\n     * @return marketInfo The MarketInfo structure of the given market.\\n     */\\n    function getMarketInfo(address market) external view returns (MarketInfo memory marketInfo);\\n\\n    /**\\n     * @notice Allows the specified token to be used as the quote token.\\n     * @dev Only the factory owner can call this function.\\n     * @param token The address of the token to register.\\n     */\\n    function registerQuoteToken(address token) external;\\n\\n    /**\\n     * @notice Revokes the token's right to be used as a quote token.\\n     * @dev Only the factory owner can call this function.\\n     * @param token The address of the token to unregister.\\n     */\\n    function unregisterQuoteToken(address token) external;\\n\\n    /**\\n     * @notice Returns the order token name.\\n     * @param quoteToken The address of the market's quote token.\\n     * @param baseToken The address of the market's base token.\\n     * @param marketNonce The market nonce.\\n     * @return The order token name.\\n     */\\n    function formatOrderTokenName(\\n        address quoteToken,\\n        address baseToken,\\n        uint256 marketNonce\\n    ) external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the order token symbol.\\n     * @param quoteToken The address of a new market's quote token.\\n     * @param baseToken The address of a new market's base token.\\n     * @param marketNonce The market nonce.\\n     * @return The order token symbol.\\n     */\\n    function formatOrderTokenSymbol(\\n        address quoteToken,\\n        address baseToken,\\n        uint256 marketNonce\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"../Errors.sol\\\";\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Clober (https://github.com/clober-dex/core/blob/main/contracts/utils/ReentrancyGuard.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 internal _locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        if (_locked != 1) {\\n            revert Errors.CloberError(Errors.REENTRANCY);\\n        }\\n\\n        _locked = 2;\\n\\n        _;\\n\\n        _locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/RevertOnDelegateCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -\\n// License: https://license.clober.io/LICENSE.pdf\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Errors.sol\\\";\\n\\ncontract RevertOnDelegateCall {\\n    address private immutable _thisAddress;\\n\\n    modifier revertOnDelegateCall() {\\n        _revertOnDelegateCall();\\n        _;\\n    }\\n\\n    function _revertOnDelegateCall() internal view {\\n        // revert when calling this contract via DELEGATECALL\\n        if (address(this) != _thisAddress) {\\n            revert Errors.CloberError(Errors.DELEGATE_CALL);\\n        }\\n    }\\n\\n    constructor() {\\n        _thisAddress = address(this);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/BoringERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n// @author BoringCrypto (https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/libraries/BoringERC20.sol)\\n// solhint-disable avoid-low-level-calls\\nlibrary BoringERC20 {\\n    bytes4 private constant _SIG_SYMBOL = 0x95d89b41; // symbol()\\n    bytes4 private constant _SIG_NAME = 0x06fdde03; // name()\\n    bytes4 private constant _SIG_DECIMALS = 0x313ce567; // decimals()\\n    bytes4 private constant _SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\\n    bytes4 private constant _SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\\n    bytes4 private constant _SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\\n\\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\\n        if (data.length >= 64) {\\n            return abi.decode(data, (string));\\n        } else if (data.length == 32) {\\n            uint8 i = 0;\\n            while (i < 32 && data[i] != 0) {\\n                i++;\\n            }\\n            bytes memory bytesArray = new bytes(i);\\n            for (i = 0; i < 32 && data[i] != 0; i++) {\\n                bytesArray[i] = data[i];\\n            }\\n            return string(bytesArray);\\n        } else {\\n            return \\\"???\\\";\\n        }\\n    }\\n\\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\\n    /// @param token The address of the ERC-20 token contract.\\n    /// @return (string) Token symbol.\\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(_SIG_SYMBOL));\\n        return success ? returnDataToString(data) : \\\"???\\\";\\n    }\\n\\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\\n    /// @param token The address of the ERC-20 token contract.\\n    /// @return (string) Token name.\\n    function safeName(IERC20 token) internal view returns (string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(_SIG_NAME));\\n        return success ? returnDataToString(data) : \\\"???\\\";\\n    }\\n\\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\\n    /// @param token The address of the ERC-20 token contract.\\n    /// @return (uint8) Token decimals.\\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(_SIG_DECIMALS));\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\n    }\\n\\n    /// @notice Provides a gas-optimized balance check to avoid a redundant ext code size check in addition to the\\n    ///         return data size check.\\n    /// @param token The address of the ERC-20 token.\\n    /// @param to The address of the user to check.\\n    /// @return amount The token amount.\\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(_SIG_BALANCE_OF, to));\\n        require(success && data.length >= 32, \\\"BoringERC20: BalanceOf failed\\\");\\n        amount = abi.decode(data, (uint256));\\n    }\\n\\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\\n    /// Reverts on a failed transfer.\\n    /// @param token The address of the ERC-20 token.\\n    /// @param to Transfer tokens to.\\n    /// @param amount The token amount.\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(_SIG_TRANSFER, to, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: Transfer failed\\\");\\n    }\\n\\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\\n    /// Reverts on a failed transfer.\\n    /// @param token The address of the ERC-20 token.\\n    /// @param from Transfer tokens from.\\n    /// @param to Transfer tokens to.\\n    /// @param amount The token amount.\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(_SIG_TRANSFER_FROM, from, to, amount)\\n        );\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: TransferFrom failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CloberOrderNFTDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\ninterface CloberOrderNFTDeployer {\\n    /**\\n     * @notice Deploys the OrderNFT contract.\\n     * @param salt The salt to compute the OrderNFT contract address via CREATE2.\\n     */\\n    function deploy(bytes32 salt) external returns (address);\\n\\n    /**\\n     * @notice Computes the OrderNFT contract address.\\n     * @param salt The salt to compute the OrderNFT contract address via CREATE2.\\n     */\\n    function computeTokenAddress(bytes32 salt) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CloberMarketDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\ninterface CloberMarketDeployer {\\n    /**\\n     * @notice Emitted when a new market is deployed.\\n     * @param market The address of the generated market.\\n     */\\n    event Deploy(address indexed market);\\n\\n    /**\\n     * @notice Deploys a new stable market.\\n     * @dev Only the market factory can call this function.\\n     * @param orderToken The address of the new market's order token.\\n     * @param quoteToken The quote token address.\\n     * @param baseToken The base token address.\\n     * @param salt The salt used to compute the address of the contract.\\n     * @param quoteUnit The amount that one raw amount represents in quote tokens.\\n     * @param makerFee The maker fee.\\n     * Paid to the maker when negative, paid by the maker when positive.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @param takerFee The taker fee.\\n     * Paid by the taker.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @param priceBook The address of the price book.\\n     * @return The address of the deployed stable market.\\n     */\\n    function deploy(\\n        address orderToken,\\n        address quoteToken,\\n        address baseToken,\\n        bytes32 salt,\\n        uint96 quoteUnit,\\n        int24 makerFee,\\n        uint24 takerFee,\\n        address priceBook\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CloberPriceBookDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\ninterface CloberPriceBookDeployer {\\n    /**\\n     * @notice Deploys an arithmetic price book.\\n     * @param a The starting price point.\\n     * @param d The common difference between price points.\\n     * @return The address of the deployed arithmetic price book.\\n     */\\n    function deployArithmeticPriceBook(uint128 a, uint128 d) external returns (address);\\n\\n    /**\\n     * @notice Deploys a geometric price book.\\n     * @param a The scale factor of the price points.\\n     * @param r The common ratio between price points.\\n     * @return The address of the deployed geometric price book.\\n     */\\n    function deployGeometricPriceBook(uint128 a, uint128 r) external returns (address);\\n\\n    /**\\n     * @notice Computes the address of an arithmetic price book.\\n     * @param a The starting price point.\\n     * @param d The common difference between price points.\\n     * @return The address of where the arithmetic price book is or would be deployed.\\n     */\\n    function computeArithmeticPriceBookAddress(uint128 a, uint128 d) external view returns (address);\\n\\n    /**\\n     * @notice Computes the address of a geometric price book.\\n     * @param a The scale factor of the price points.\\n     * @param r The common ratio between price points.\\n     * @return The address of where the geometric price book is or would be deployed.\\n     */\\n    function computeGeometricPriceBookAddress(uint128 a, uint128 r) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CloberOrderBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./CloberOrderKey.sol\\\";\\n\\ninterface CloberOrderBook {\\n    /**\\n     * @notice Emitted when an order is created.\\n     * @param sender The address who sent the tokens to make the order.\\n     * @param user The address with the rights to claim the proceeds of the order.\\n     * @param rawAmount The ordered raw amount.\\n     * @param orderIndex The order index.\\n     * @param priceIndex The price book index.\\n     * @param options LSB: 0 - Ask, 1 - Bid.\\n     */\\n    event MakeOrder(\\n        address indexed sender,\\n        address indexed user,\\n        uint64 rawAmount,\\n        uint32 claimBounty,\\n        uint256 orderIndex,\\n        uint16 priceIndex,\\n        uint8 options\\n    );\\n\\n    /**\\n     * @notice Emitted when an order takes from the order book.\\n     * @param sender The address who sent the tokens to take the order.\\n     * @param user The recipient address of the traded token.\\n     * @param priceIndex The price book index.\\n     * @param rawAmount The ordered raw amount.\\n     * @param options MSB: 0 - Limit, 1 - Market / LSB: 0 - Ask, 1 - Bid.\\n     */\\n    event TakeOrder(address indexed sender, address indexed user, uint16 priceIndex, uint64 rawAmount, uint8 options);\\n\\n    /**\\n     * @notice Emitted when an order is canceled.\\n     * @param user The owner of the order.\\n     * @param rawAmount The raw amount remaining that was canceled.\\n     * @param orderIndex The order index.\\n     * @param priceIndex The price book index.\\n     * @param isBid The flag indicating whether it's a bid order or an ask order.\\n     */\\n    event CancelOrder(address indexed user, uint64 rawAmount, uint256 orderIndex, uint16 priceIndex, bool isBid);\\n\\n    /**\\n     * @notice Emitted when the proceeds of an order is claimed.\\n     * @param claimer The address that initiated the claim.\\n     * @param user The owner of the order.\\n     * @param rawAmount The ordered raw amount.\\n     * @param bountyAmount The size of the claim bounty.\\n     * @param orderIndex The order index.\\n     * @param priceIndex The price book index.\\n     * @param isBase The flag indicating whether the user receives the base token or the quote token.\\n     */\\n    event ClaimOrder(\\n        address indexed claimer,\\n        address indexed user,\\n        uint64 rawAmount,\\n        uint256 bountyAmount,\\n        uint256 orderIndex,\\n        uint16 priceIndex,\\n        bool isBase\\n    );\\n\\n    /**\\n     * @notice Emitted when a flash-loan is taken.\\n     * @param caller The caller address of the flash-loan.\\n     * @param borrower The address of the flash loan token receiver.\\n     * @param quoteAmount The amount of quote tokens the user has borrowed.\\n     * @param baseAmount The amount of base tokens the user has borrowed.\\n     * @param earnedQuote The amount of quote tokens the protocol earned in quote tokens.\\n     * @param earnedBase The amount of base tokens the protocol earned in base tokens.\\n     */\\n    event Flash(\\n        address indexed caller,\\n        address indexed borrower,\\n        uint256 quoteAmount,\\n        uint256 baseAmount,\\n        uint256 earnedQuote,\\n        uint256 earnedBase\\n    );\\n\\n    /**\\n     * @notice A struct that represents an order.\\n     * @param amount The raw amount not filled yet. In case of a stale order, the amount not claimed yet.\\n     * @param claimBounty The bounty amount in gwei that can be collected by the party that fully claims the order.\\n     * @param owner The address of the order owner.\\n     */\\n    struct Order {\\n        uint64 amount;\\n        uint32 claimBounty;\\n        address owner;\\n    }\\n\\n    /**\\n     * @notice A struct that represents a block trade log.\\n     * @param blockTime The timestamp of the block.\\n     * @param askVolume The volume taken on the ask side.\\n     * @param bidVolume The volume taken on the bid side.\\n     * @param open The price book index on the open.\\n     * @param high The highest price book index in the block.\\n     * @param low The lowest price book index in the block.\\n     * @param close The price book index on the close.\\n     */\\n    struct BlockTradeLog {\\n        uint64 blockTime;\\n        uint64 askVolume;\\n        uint64 bidVolume;\\n        uint16 open;\\n        uint16 high;\\n        uint16 low;\\n        uint16 close;\\n    }\\n\\n    /**\\n     * @notice Take orders better or equal to the given priceIndex and make an order with the remaining tokens.\\n     * @dev `msg.value` will be used as the claimBounty.\\n     * @param user The taker/maker address.\\n     * @param priceIndex The price book index.\\n     * @param rawAmount The raw quote amount to trade, utilized by bids.\\n     * @param baseAmount The base token amount to trade, utilized by asks.\\n     * @param options LSB: 0 - Ask, 1 - Bid. Second bit: 1 - Post only.\\n     * @param data Custom callback data\\n     * @return The order index. If an order is not made `type(uint256).max` is returned instead.\\n     */\\n    function limitOrder(\\n        address user,\\n        uint16 priceIndex,\\n        uint64 rawAmount,\\n        uint256 baseAmount,\\n        uint8 options,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Returns the expected input amount and output amount.\\n     * @param limitPriceIndex The price index to take until.\\n     * @param rawAmount The raw amount to trade.\\n     * Bid & expendInput => Used as input amount.\\n     * Bid & !expendInput => Not used.\\n     * Ask & expendInput => Not used.\\n     * Ask & !expendInput => Used as output amount.\\n     * @param baseAmount The base token amount to trade.\\n     * Bid & expendInput => Not used.\\n     * Bid & !expendInput => Used as output amount.\\n     * Ask & expendInput => Used as input amount.\\n     * Ask & !expendInput => Not used.\\n     * @param options LSB: 0 - Ask, 1 - Bid. Second bit: 1 - expend input.\\n     */\\n    function getExpectedAmount(\\n        uint16 limitPriceIndex,\\n        uint64 rawAmount,\\n        uint256 baseAmount,\\n        uint8 options\\n    ) external view returns (uint256, uint256);\\n\\n    /**\\n     * @notice Take opens orders until certain conditions are met.\\n     * @param user The taker address.\\n     * @param limitPriceIndex The price index to take until.\\n     * @param rawAmount The raw amount to trade.\\n     * This value is used as the maximum input amount by bids and minimum output amount by asks.\\n     * @param baseAmount The base token amount to trade.\\n     * This value is used as the maximum input amount by asks and minimum output amount by bids.\\n     * @param options LSB: 0 - Ask, 1 - Bid. Second bit: 1 - expend input.\\n     * @param data Custom callback data.\\n     */\\n    function marketOrder(\\n        address user,\\n        uint16 limitPriceIndex,\\n        uint64 rawAmount,\\n        uint256 baseAmount,\\n        uint8 options,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @notice Cancel orders.\\n     * @dev The length of orderKeys must be controlled by the caller to avoid block gas limit exceeds.\\n     * @param receiver The address to receive canceled tokens.\\n     * @param orderKeys The order keys of the orders to cancel.\\n     */\\n    function cancel(address receiver, OrderKey[] calldata orderKeys) external;\\n\\n    /**\\n     * @notice Claim the proceeds of orders.\\n     * @dev The length of orderKeys must be controlled by the caller to avoid block gas limit exceeds.\\n     * @param claimer The address to receive the claim bounties.\\n     * @param orderKeys The order keys of the orders to claim.\\n     */\\n    function claim(address claimer, OrderKey[] calldata orderKeys) external;\\n\\n    /**\\n     * @notice Get the claimable proceeds of an order.\\n     * @param orderKey The order key of the order.\\n     * @return claimableRawAmount The claimable raw amount.\\n     * @return claimableAmount The claimable amount after fees.\\n     * @return feeAmount The maker fee to be paid on claim.\\n     * @return rebateAmount The rebate to be received on claim.\\n     */\\n    function getClaimable(OrderKey calldata orderKey)\\n        external\\n        view\\n        returns (\\n            uint64 claimableRawAmount,\\n            uint256 claimableAmount,\\n            uint256 feeAmount,\\n            uint256 rebateAmount\\n        );\\n\\n    /**\\n     * @notice Flash loan the tokens in the OrderBook.\\n     * @param borrower The address to receive the loan.\\n     * @param quoteAmount The quote token amount to borrow.\\n     * @param baseAmount The base token amount to borrow.\\n     * @param data The user's custom callback data.\\n     */\\n    function flash(\\n        address borrower,\\n        uint256 quoteAmount,\\n        uint256 baseAmount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @notice Returns the quote unit amount.\\n     * @return The amount that one raw amount represent in quote tokens.\\n     */\\n    function quoteUnit() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the maker fee.\\n     * Paid to the maker when negative, paid by the maker when positive.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @return The maker fee. 100 = 1bp.\\n     */\\n    function makerFee() external view returns (int24);\\n\\n    /**\\n     * @notice Returns the take fee\\n     * Paid by the taker.\\n     * Every 10000 represents a 1% fee on trade volume.\\n     * @return The taker fee. 100 = 1bps.\\n     */\\n    function takerFee() external view returns (uint24);\\n\\n    /**\\n     * @notice Returns the address of the order NFT contract.\\n     * @return The address of the order NFT contract.\\n     */\\n    function orderToken() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the quote token.\\n     * @return The address of the quote token.\\n     */\\n    function quoteToken() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the base token.\\n     * @return The address of the base token.\\n     */\\n    function baseToken() external view returns (address);\\n\\n    /**\\n     * @notice Returns the current total open amount at the given price.\\n     * @param isBid The flag to choose which side to check the depth for.\\n     * @param priceIndex The price book index.\\n     * @return The total open amount.\\n     */\\n    function getDepth(bool isBid, uint16 priceIndex) external view returns (uint64);\\n\\n    /**\\n     * @notice Returns the fee balance that has not been collected yet.\\n     * @return quote The current fee balance for the quote token.\\n     * @return base The current fee balance for the base token.\\n     */\\n    function getFeeBalance() external view returns (uint128 quote, uint128 base);\\n\\n    /**\\n     * @notice Returns the amount of tokens that can be collected by the host.\\n     * @param token The address of the token to be collected.\\n     * @return The amount of tokens that can be collected by the host.\\n     */\\n    function uncollectedHostFees(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the amount of tokens that can be collected by the dao treasury.\\n     * @param token The address of the token to be collected.\\n     * @return The amount of tokens that can be collected by the dao treasury.\\n     */\\n    function uncollectedProtocolFees(address token) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns whether the order book is empty or not.\\n     * @param isBid The flag to choose which side to check the emptiness of.\\n     * @return Whether the order book is empty or not on that side.\\n     */\\n    function isEmpty(bool isBid) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the order information.\\n     * @param orderKey The order key of the order.\\n     * @return The order struct of the given order key.\\n     */\\n    function getOrder(OrderKey calldata orderKey) external view returns (Order memory);\\n\\n    /**\\n     * @notice Returns the lowest ask price index or the highest bid price index.\\n     * @param isBid Returns the lowest ask price if false, highest bid price if true.\\n     * @return The current price index. If the order book is empty, it will revert.\\n     */\\n    function bestPriceIndex(bool isBid) external view returns (uint16);\\n\\n    /**\\n     * @notice Returns the current block trade log index.\\n     * @return The current block trade log index.\\n     */\\n    function blockTradeLogIndex() external view returns (uint16);\\n\\n    /**\\n     * @notice Returns the block trade log for a certain index.\\n     * @param index The block trade log index used to query the block trade log.\\n     * @return The queried block trade log.\\n     */\\n    function blockTradeLogs(uint16 index) external view returns (BlockTradeLog memory);\\n\\n    /**\\n     * @notice Converts a raw amount to its corresponding base amount using a given price index.\\n     * @param rawAmount The raw amount to be converted.\\n     * @param priceIndex The index of the price to be used for the conversion.\\n     * @param roundingUp Specifies whether the result should be rounded up or down.\\n     * @return The converted base amount.\\n     */\\n    function rawToBase(\\n        uint64 rawAmount,\\n        uint16 priceIndex,\\n        bool roundingUp\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Converts a raw amount to its corresponding quote amount.\\n     * @param rawAmount The raw amount to be converted.\\n     * @return The converted quote amount.\\n     */\\n    function rawToQuote(uint64 rawAmount) external view returns (uint256);\\n\\n    /**\\n     * @notice Converts a base amount to its corresponding raw amount using a given price index.\\n     * @param baseAmount The base amount to be converted.\\n     * @param priceIndex The index of the price to be used for the conversion.\\n     * @param roundingUp Specifies whether the result should be rounded up or down.\\n     * @return The converted raw amount.\\n     */\\n    function baseToRaw(\\n        uint256 baseAmount,\\n        uint16 priceIndex,\\n        bool roundingUp\\n    ) external view returns (uint64);\\n\\n    /**\\n     * @notice Converts a quote amount to its corresponding raw amount.\\n     * @param quoteAmount The quote amount to be converted.\\n     * @param roundingUp Specifies whether the result should be rounded up or down.\\n     * @return The converted raw amount.\\n     */\\n    function quoteToRaw(uint256 quoteAmount, bool roundingUp) external view returns (uint64);\\n\\n    /**\\n     * @notice Collects fees for either the protocol or host.\\n     * @param token The token address to collect. It should be the quote token or the base token.\\n     * @param destination The destination address to transfer fees.\\n     * It should be the dao treasury address or the host address.\\n     */\\n    function collectFees(address token, address destination) external;\\n\\n    /**\\n     * @notice Change the owner of the order.\\n     * @dev Only the OrderToken contract can call this function.\\n     * @param orderKey The order key of the order.\\n     * @param newOwner The new owner address.\\n     */\\n    function changeOrderOwner(OrderKey calldata orderKey, address newOwner) external;\\n\\n    /**\\n     * @notice Converts the price index into the actual price.\\n     * @param priceIndex The price book index.\\n     * @return price The actual price.\\n     */\\n    function indexToPrice(uint16 priceIndex) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the price book index closest to the provided price.\\n     * @param price Provided price.\\n     * @param roundingUp Determines whether to round up or down.\\n     * @return index The price book index.\\n     * @return correctedPrice The actual price for the price book index.\\n     */\\n    function priceToIndex(uint256 price, bool roundingUp) external view returns (uint16 index, uint256 correctedPrice);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/OrderKeyUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -\\n// License: https://license.clober.io/LICENSE.pdf\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Errors.sol\\\";\\nimport \\\"../interfaces/CloberOrderKey.sol\\\";\\n\\nlibrary OrderKeyUtils {\\n    function encode(OrderKey memory orderKey) internal pure returns (uint256) {\\n        return encode(orderKey.isBid, orderKey.priceIndex, orderKey.orderIndex);\\n    }\\n\\n    function encode(\\n        bool isBid,\\n        uint16 priceIndex,\\n        uint256 orderIndex\\n    ) internal pure returns (uint256 id) {\\n        if (orderIndex > type(uint232).max) {\\n            revert Errors.CloberError(Errors.INVALID_ID);\\n        }\\n        assembly {\\n            id := add(orderIndex, add(shl(232, priceIndex), shl(248, isBid)))\\n        }\\n    }\\n\\n    function decode(uint256 id) internal pure returns (OrderKey memory) {\\n        uint8 isBid;\\n        uint16 priceIndex;\\n        uint232 orderIndex;\\n        assembly {\\n            orderIndex := id\\n            priceIndex := shr(232, id)\\n            isBid := shr(248, id)\\n        }\\n        if (isBid > 1) {\\n            revert Errors.CloberError(Errors.INVALID_ID);\\n        }\\n        return OrderKey({isBid: isBid == 1, priceIndex: priceIndex, orderIndex: orderIndex});\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CloberOrderNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\\nimport \\\"./CloberOrderKey.sol\\\";\\n\\ninterface CloberOrderNFT is IERC721, IERC721Metadata {\\n    /**\\n     * @notice Returns the base URI for the metadata of this NFT collection.\\n     * @return The base URI for the metadata of this NFT collection.\\n     */\\n    function baseURI() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the contract URI for the metadata of this NFT collection.\\n     * @return The contract URI for the metadata of this NFT collection.\\n     */\\n    function contractURI() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the address of the market contract that manages this token.\\n     * @return The address of the market contract that manages this token.\\n     */\\n    function market() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of contract owner.\\n     * @return The address of the contract owner.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Called when a new token is minted.\\n     * @param to The receiver address of the minted token.\\n     * @param tokenId The id of the token minted.\\n     */\\n    function onMint(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @notice Called when a token is burned.\\n     * @param tokenId The id of the token burned.\\n     */\\n    function onBurn(uint256 tokenId) external;\\n\\n    /**\\n     * @notice Changes the base URI for the metadata of this NFT collection.\\n     * @param newBaseURI The new base URI for the metadata of this NFT collection.\\n     */\\n    function changeBaseURI(string memory newBaseURI) external;\\n\\n    /**\\n     * @notice Changes the contract URI for the metadata of this NFT collection.\\n     * @param newContractURI The new contract URI for the metadata of this NFT collection.\\n     */\\n    function changeContractURI(string memory newContractURI) external;\\n\\n    /**\\n     * @notice Decodes a token id into an order key.\\n     * @param id The id to decode.\\n     * @return The order key corresponding to the given id.\\n     */\\n    function decodeId(uint256 id) external pure returns (OrderKey memory);\\n\\n    /**\\n     * @notice Encodes an order key to a token id.\\n     * @param orderKey The order key to encode.\\n     * @return The id corresponding to the given order key.\\n     */\\n    function encodeId(OrderKey memory orderKey) external pure returns (uint256);\\n\\n    /**\\n     * @notice Cancels orders with token ids.\\n     * @dev Only the OrderCanceler can call this function.\\n     * @param from The address of the owner of the tokens.\\n     * @param tokenIds The ids of the tokens to cancel.\\n     * @param receiver The address to send the underlying assets to.\\n     */\\n    function cancel(\\n        address from,\\n        uint256[] calldata tokenIds,\\n        address receiver\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CloberOrderKey.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice A struct that represents a unique key for an order.\\n * @param isBid The flag indicating whether it's a bid order or an ask order.\\n * @param priceIndex The price book index.\\n * @param orderIndex The order index.\\n */\\nstruct OrderKey {\\n    bool isBid;\\n    uint16 priceIndex;\\n    uint256 orderIndex;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/CloberPriceBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\ninterface CloberPriceBook {\\n    /**\\n     * @notice Returns the biggest price book index supported.\\n     * @return The biggest price book index supported.\\n     */\\n    function maxPriceIndex() external view returns (uint16);\\n\\n    /**\\n     * @notice Returns the upper bound of prices supported.\\n     * @dev The price upper bound can be greater than `indexToPrice(maxPriceIndex())`.\\n     * @return The the upper bound of prices supported.\\n     */\\n    function priceUpperBound() external view returns (uint256);\\n\\n    /**\\n     * @notice Converts the price index into the actual price.\\n     * @param priceIndex The price book index.\\n     * @return price The actual price.\\n     */\\n    function indexToPrice(uint16 priceIndex) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the price book index closest to the provided price.\\n     * @param price Provided price.\\n     * @param roundingUp Determines whether to round up or down.\\n     * @return index The price book index.\\n     * @return correctedPrice The actual price for the price book index.\\n     */\\n    function priceToIndex(uint256 price, bool roundingUp) external view returns (uint16 index, uint256 correctedPrice);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketDeployer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"priceBookDeployer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"orderTokenDeployer_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDaoTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"canceler_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"initialQuoteTokenRegistrations_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"CloberError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousTreasury\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"ChangeDaoTreasury\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousHost\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newHost\",\"type\":\"address\"}],\"name\":\"ChangeHost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ChangeOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"orderToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteUnit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"makerFee\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"takerFee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"a\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"d\",\"type\":\"uint128\"}],\"name\":\"CreateStableMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"orderToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteUnit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"makerFee\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"takerFee\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"a\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"r\",\"type\":\"uint128\"}],\"name\":\"CreateVolatileMarket\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"canceler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"changeDaoTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketHost\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"quoteUnit\",\"type\":\"uint96\"},{\"internalType\":\"int24\",\"name\":\"makerFee\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"takerFee\",\"type\":\"uint24\"},{\"internalType\":\"uint128\",\"name\":\"a\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"d\",\"type\":\"uint128\"}],\"name\":\"createStableMarket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketHost\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"quoteUnit\",\"type\":\"uint96\"},{\"internalType\":\"int24\",\"name\":\"makerFee\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"takerFee\",\"type\":\"uint24\"},{\"internalType\":\"uint128\",\"name\":\"a\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"r\",\"type\":\"uint128\"}],\"name\":\"createVolatileMarket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"a\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"d\",\"type\":\"uint128\"}],\"name\":\"deployedArithmeticPriceBook\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"a\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"r\",\"type\":\"uint128\"}],\"name\":\"deployedGeometricPriceBook\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executeChangeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"executeHandOverHost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"marketNonce\",\"type\":\"uint256\"}],\"name\":\"formatOrderTokenName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"quoteToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"marketNonce\",\"type\":\"uint256\"}],\"name\":\"formatOrderTokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"futureOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"getMarketHost\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"getMarketInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"enum CloberMarketFactory.MarketType\",\"name\":\"marketType\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"a\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"factor\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"futureHost\",\"type\":\"address\"}],\"internalType\":\"struct CloberMarketFactory.MarketInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderTokenDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"prepareChangeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newHost\",\"type\":\"address\"}],\"name\":\"prepareHandOverHost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceBookDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"registerQuoteToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registeredQuoteTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unregisterQuoteToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MarketFactory", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000bb40ac34ae9bcbc30a035eb12b998f1f52f966c000000000000000000000000062c439963c50b70d57ee7c79fa329c0301d48d3900000000000000000000000058ed1f4913e652baf17c154551bd8e9dbc73fc56000000000000000000000000309bcc19dc4d8f4c31312df2befb3b2821646e7f000000000000000000000000fc03c0bad134a0c0151db9358ad697c5daf611ee00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000030000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000008f3cf7ad23cd3cadbd9735aff958023239c6a063000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}