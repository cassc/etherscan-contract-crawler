{"SourceCode": "// SPDX-License-Identifier: NONE\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: TokenSwap.sol\r\n\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\ninterface IERC20{\r\n\r\n    function balanceOf(\r\n        address account\r\n    ) external view returns (\r\n        uint256\r\n    );\r\n \r\n}\r\n\r\n\r\ninterface IUniswapV2CustomRouter {\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address[] calldata feePath,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (\r\n        uint[] memory amounts\r\n    );\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address[] calldata feePath,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (\r\n        uint[] memory amounts\r\n    );\r\n    function swapTokensForExactETH(\r\n        uint amountOut, \r\n        uint amountInMax, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline\r\n    ) external payable returns (\r\n        uint[] memory amounts\r\n    );\r\n    function swapExactTokensForETH(\r\n        uint amountIn, \r\n        uint amountOutMin, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline\r\n    ) external payable returns (\r\n        uint[] memory amounts\r\n    );\r\n    function swapExactETHForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline\r\n    ) external payable returns (\r\n        uint[] memory amounts\r\n    );\r\n    function swapETHForExactTokens(\r\n        uint amountIn,\r\n        uint amountOut, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline\r\n    ) external payable returns (\r\n        uint[] memory amounts\r\n    );\r\n    function quote(\r\n        uint amountA, \r\n        uint reserveA, \r\n        uint reserveB\r\n    ) external pure returns (\r\n        uint amountB\r\n    );\r\n    function getAmountOut(\r\n        uint amountIn, \r\n        uint reserveIn, \r\n        uint reserveOut\r\n    ) external pure returns (\r\n        uint amountOut\r\n    );\r\n    function getAmountIn(\r\n        uint amountOut, \r\n        uint reserveIn, \r\n        uint reserveOut\r\n    ) external pure returns (\r\n        uint amountIn\r\n    );\r\n    function getAmountsOut(\r\n        uint amountIn, \r\n        address[] calldata path\r\n    ) external view returns (\r\n        uint[] memory amounts\r\n    );\r\n    function getAmountsIn(\r\n        uint amountOut, \r\n        address[] calldata path\r\n    ) external view returns (\r\n        uint[] memory amounts\r\n    );\r\n\r\n}\r\n\r\n\r\ninterface IWETH {\r\n\r\n    function transfer(\r\n        address to, \r\n        uint value\r\n    ) external returns (\r\n        bool\r\n    );\r\n    function withdraw(\r\n        uint\r\n    ) external;\r\n    function deposit() external payable;\r\n\r\n}\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n\r\n    event Approval(\r\n        address indexed owner, \r\n        address indexed spender, \r\n        uint value\r\n    );\r\n    event Transfer(\r\n        address indexed from, \r\n        address indexed to, \r\n        uint value\r\n    );\r\n    event Mint(\r\n        address indexed sender, \r\n        uint amount0, \r\n        uint amount1\r\n    );\r\n    event Burn(\r\n        address indexed sender, \r\n        uint amount0, \r\n        uint amount1, \r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(\r\n        uint112 reserve0, \r\n        uint112 reserve1\r\n    );\r\n\r\n    function approve(\r\n        address spender, \r\n        uint value\r\n    ) external returns (\r\n        bool\r\n    );\r\n    function transfer(\r\n        address to, \r\n        uint value\r\n    ) external returns (\r\n        bool\r\n    );\r\n    function transferFrom(\r\n        address from, \r\n        address to, \r\n        uint value\r\n    ) external returns (\r\n        bool\r\n    );\r\n    function mint(\r\n        address to\r\n    ) external returns (\r\n        uint liquidity\r\n    );\r\n    function burn(\r\n        address to\r\n    ) external returns (\r\n        uint amount0, \r\n        uint amount1\r\n    );\r\n    function swap(\r\n        uint amount0Out, \r\n        uint amount1Out, \r\n        address to, \r\n        bytes calldata data\r\n    ) external;\r\n    function skim(\r\n        address to\r\n    ) external;\r\n    function sync() external;\r\n    function initialize(\r\n        address, address\r\n    ) external;\r\n    function permit(\r\n        address owner, \r\n        address spender, \r\n        uint value, \r\n        uint deadline, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s\r\n    ) external;\r\n    function MINIMUM_LIQUIDITY() external pure returns (\r\n        uint\r\n    );\r\n    function PERMIT_TYPEHASH() external pure returns (\r\n        bytes32\r\n    );\r\n    function name() external pure returns (\r\n        string memory\r\n    );\r\n    function symbol() external pure returns (\r\n        string memory\r\n    );\r\n    function decimals() external pure returns (\r\n        uint8\r\n    );\r\n    function totalSupply() external view returns (\r\n        uint\r\n    );\r\n    function balanceOf(\r\n        address owner\r\n    ) external view returns (\r\n        uint\r\n    );\r\n    function allowance(\r\n        address owner, \r\n        address spender\r\n    ) external view returns (\r\n        uint\r\n    );\r\n    function DOMAIN_SEPARATOR() external view returns (\r\n        bytes32\r\n    );\r\n    function nonces(\r\n        address owner\r\n    ) external view returns (\r\n        uint\r\n    );\r\n    function factory() external view returns (\r\n        address\r\n    );\r\n    function token0() external view returns (\r\n        address\r\n    );\r\n    function token1() external view returns (\r\n        address\r\n    );\r\n    function getReserves() external view returns (\r\n        uint112 reserve0, \r\n        uint112 reserve1, \r\n        uint32 blockTimestampLast\r\n    );\r\n    function price0CumulativeLast() external view returns (\r\n        uint\r\n    );\r\n    function price1CumulativeLast() external view returns (\r\n        uint\r\n    );\r\n    function kLast() external view returns (\r\n        uint\r\n    );\r\n\r\n}\r\n\r\n\r\nlibrary TransferHelper {\r\n\r\n    function safeApprove(\r\n        address token, \r\n        address to, \r\n        uint value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token, \r\n        address to, \r\n        uint value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token, \r\n        address from, \r\n        address to, \r\n        uint value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(\r\n        address to, \r\n        uint value\r\n    ) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n\r\n}\r\n\r\n\r\nlibrary SafeMathUniswap {\r\n\r\n    function add(\r\n        uint x, \r\n        uint y\r\n    ) internal pure returns (\r\n        uint z\r\n    ) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(\r\n        uint x, \r\n        uint y\r\n    ) internal pure returns (\r\n        uint z\r\n    ) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(\r\n        uint x, \r\n        uint y\r\n    ) internal pure returns (\r\n        uint z\r\n    ) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n\r\n}\r\n\r\n\r\nlibrary UniswapV2Library {\r\n\r\n    using SafeMathUniswap for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(\r\n        address tokenA, \r\n        address tokenB\r\n    ) internal pure returns (\r\n        address token0, \r\n        address token1\r\n    ) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory, \r\n        address tokenA, \r\n        address tokenB\r\n    ) internal pure returns (\r\n        address pair\r\n    ) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint160(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\r\n            )))));\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(\r\n        address factory, \r\n        address tokenA, \r\n        address tokenB\r\n    ) internal view returns (\r\n        uint reserveA, \r\n        uint reserveB\r\n    ) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(\r\n        uint amountA, \r\n        uint reserveA, \r\n        uint reserveB\r\n    ) internal pure returns (\r\n        uint amountB\r\n    ) {\r\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint amountIn, \r\n        uint reserveIn, \r\n        uint reserveOut\r\n    ) internal pure returns (\r\n        uint amountOut\r\n    ) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(\r\n        uint amountOut, \r\n        uint reserveIn, \r\n        uint reserveOut\r\n    ) internal pure returns (\r\n        uint amountIn\r\n    ) {\r\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(\r\n        address factory, \r\n        uint amountIn, \r\n        address[] memory path\r\n    ) internal view returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(\r\n        address factory, \r\n        uint amountOut, \r\n        address[] memory path\r\n    ) internal view returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @author Bhupesh Dubey\r\n*/\r\ncontract TokensSwap is IUniswapV2CustomRouter, Ownable {\r\n\r\n    using SafeMathUniswap for uint;\r\n\r\n    struct SwapUtils {\r\n        uint appFee;\r\n        uint appFeeInEther;\r\n        uint[] resultAmount;  \r\n    }\r\n    struct DiscountRates{\r\n        uint amount;\r\n        uint8 discountPercent;\r\n    }\r\n\r\n    address public immutable factory;\r\n    address public immutable WETH;\r\n    address public immutable USDC;\r\n    address public feeHolderAddress;\r\n    address public gieTokenContract;\r\n\r\n    DiscountRates[4] public discountRates; \r\n\r\n    uint public gieAppFees;\r\n    uint public gieAppFeesDecimals;\r\n    uint public donationFees;\r\n    uint public donationFeesDecimals;\r\n    uint public totalCollectedFee;\r\n    uint public totalCollectedDonationFee;\r\n\r\n    modifier ensure(\r\n        uint deadline\r\n    ) {\r\n        require(\r\n            deadline >= block.timestamp, \r\n            'UniswapV2Router: EXPIRED'\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidFees(\r\n        uint fees, \r\n        uint decimals\r\n    ) {\r\n        require(\r\n            fees != 0 && \r\n            decimals != 0, \r\n            \"Invalid fees!\"\r\n        );\r\n        require(\r\n            fees/decimals <= 100, \r\n            \"Fee percent should be greater than 0 & less than equal to 100!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    event FeesPaid(\r\n        address indexed swapper,\r\n        uint indexed feesPaid\r\n    );\r\n    event DonationFeesPaid(\r\n        address indexed donater,\r\n        address indexed treasuryAddress,\r\n        uint indexed treasuryAmount,\r\n        uint donationFeesPaid\r\n    );\r\n\r\n    /**\r\n     *\r\n     * @notice constructor initializes sushiswap and fees contracts\r\n       @param _factory sushiswap's factory contract address\r\n       @param _WETH sushiswap's WETH contract address\r\n       @param _USDC sushiswap's USDC contract address\r\n       @param _gieTokenContract gie token contract address\r\n       @param _feeHolderAddress fee holder address\r\n       @param _fees fees percent to be dedcuted from transaction of user\r\n       @param _decimals decimals for gie app fees fraction value\r\n       @param _donationFees fees percent to be dedcuted for donation\r\n       @param _donationFeesDecimals decimals for donation fees fraction value\r\n    */\r\n    constructor(\r\n        address _factory, \r\n        address _WETH,\r\n        address _USDC,\r\n        address _gieTokenContract,\r\n        address _feeHolderAddress,\r\n        uint _fees,\r\n        uint _decimals,\r\n        uint _donationFees,\r\n        uint _donationFeesDecimals\r\n    ) onlyValidFees(_fees, _decimals) onlyValidFees(_donationFees, _donationFeesDecimals) {\r\n        require(\r\n            _factory != address(0) && \r\n            _WETH != address(0) && \r\n            _USDC != address(0) && \r\n            _gieTokenContract != address(0) &&\r\n            _feeHolderAddress != address(0), \r\n            \"Swap: zero address not allowed!\"\r\n        );\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n        USDC =_USDC;\r\n        gieTokenContract = _gieTokenContract;\r\n        feeHolderAddress = _feeHolderAddress;\r\n        gieAppFees = _fees;\r\n        gieAppFeesDecimals = _decimals;\r\n        donationFees = _donationFees;\r\n        donationFeesDecimals = _donationFeesDecimals;\r\n        discountRates[0] = DiscountRates(50000 * 10 ** 18, 5);\r\n        discountRates[1] = DiscountRates(250000 * 10 ** 18, 10);\r\n        discountRates[2] = DiscountRates(500000 * 10 ** 18, 25);\r\n        discountRates[3] = DiscountRates(1000000 * 10 ** 18, 60);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice gets called when someone sends ether to this contract\r\n    */\r\n    receive() external payable {\r\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice swaps first token with second token provided in path array such that user      \r\n       specifies the input token amount here and accordingly output tokens are derived\r\n       @return amounts array consisting on input tokens and output tokens amount\r\n       @param amountIn amount to provide as a input for swap\r\n       @param amountOutMin amount to expect as a output for swap\r\n       @param path array of addresses with input and output tokens to make a swap\r\n       @param feePath array of addresses with input and Ether address to charge fees\r\n       @param to user's wallet address where output token has to be sent\r\n       @param deadline timestamp before which transaction should be completed\r\n    */\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address[] calldata feePath,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override payable ensure(deadline) returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        require(path[0] == feePath[0], \"Invalid input token!\");\r\n        require(feePath[feePath.length-1] == WETH, \"Invalid fee token!\");\r\n        SwapUtils memory swapUtils = _swapPreCheck(msg.sender, feePath, amountIn, false, msg.value);\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Insufficient output amount!\");\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n        totalCollectedFee += swapUtils.appFeeInEther;\r\n        TransferHelper.safeTransferETH(feeHolderAddress, swapUtils.appFeeInEther);\r\n        if(msg.value > swapUtils.appFeeInEther){\r\n            TransferHelper.safeTransferETH(msg.sender, (msg.value - swapUtils.appFeeInEther));\r\n        }\r\n        emit FeesPaid(\r\n            msg.sender,\r\n            swapUtils.appFeeInEther\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice swaps first token with second token provided in path array such that user      \r\n       specifies the output token amount here and accordingly input tokens are derived\r\n       @return amounts array consisting on input tokens and output tokens amount\r\n       @param amountOut amount to expect as a output for swap\r\n       @param amountInMax amount to provide as a input for swap\r\n       @param path array of addresses with input and output tokens to make a swap\r\n       @param feePath array of addresses with input and Ether address to charge fees\r\n       @param to user's wallet address where output token has to be sent\r\n       @param deadline timestamp before which transaction should be completed\r\n    */\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address[] calldata feePath,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual override payable ensure(deadline) returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        require(path[0] == feePath[0], \"Invalid input token!\");\r\n        require(feePath[feePath.length-1] == WETH, \"Invalid fee token!\");\r\n        SwapUtils memory swapUtils = _swapPreCheck(msg.sender, feePath, amountInMax, false, msg.value);\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, \"Excessive input amount!\");\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n         totalCollectedFee += swapUtils.appFeeInEther;\r\n        TransferHelper.safeTransferETH(feeHolderAddress, swapUtils.appFeeInEther);\r\n        if(msg.value > swapUtils.appFeeInEther){\r\n            TransferHelper.safeTransferETH(msg.sender, (msg.value - swapUtils.appFeeInEther));\r\n        }\r\n        emit FeesPaid(\r\n            msg.sender,\r\n            swapUtils.appFeeInEther\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice swaps first token with ether provided in path array such that user      \r\n       specifies the ether output amount here and accordingly input tokens are derived\r\n       @return amounts array consisting on input tokens and output tokens amount\r\n       @param amountOut amount to expect as a output for swap\r\n       @param amountInMax amount to provide as a input for swap\r\n       @param path array of addresses with input and output tokens to make a swap\r\n       @param to user's wallet address where output token has to be sent\r\n       @param deadline timestamp before which transaction should be completed\r\n    */\r\n    function swapTokensForExactETH(\r\n        uint amountOut, \r\n        uint amountInMax, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline\r\n    ) external virtual override payable ensure(deadline) returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        require(path[path.length - 1] == WETH, \"Invalid path!\");\r\n        SwapUtils memory swapUtils = _swapPreCheck(msg.sender, path, amountInMax, false, msg.value);\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= amountInMax, \"Excessive input amount!\");\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n         totalCollectedFee += swapUtils.appFeeInEther;\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(feeHolderAddress, swapUtils.appFeeInEther);\r\n        if(msg.value > swapUtils.appFeeInEther){\r\n            TransferHelper.safeTransferETH(msg.sender, (msg.value - swapUtils.appFeeInEther));\r\n        }\r\n        emit FeesPaid(\r\n            msg.sender,\r\n            swapUtils.appFeeInEther\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice swaps first token with ether provided in path array such that user      \r\n       specifies the input amount of first token here and accordingly output token ether is derived\r\n       @return amounts array consisting on input tokens and output tokens amount\r\n       @param amountIn amount to provide as a input for swap\r\n       @param amountOutMin amount to expect as a output for swap\r\n       @param path array of addresses with input and output tokens to make a swap\r\n       @param to user's wallet address where output token has to be sent\r\n       @param deadline timestamp before which transaction should be completed\r\n    */\r\n    function swapExactTokensForETH(\r\n        uint amountIn, \r\n        uint amountOutMin, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline\r\n    ) external virtual override payable ensure(deadline) returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        require(path[path.length - 1] == WETH, \"Invalid path!\");\r\n        SwapUtils memory swapUtils = _swapPreCheck(msg.sender, path, amountIn, false, msg.value);\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Insufficient output amount!\");\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n         totalCollectedFee += swapUtils.appFeeInEther;\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(feeHolderAddress, swapUtils.appFeeInEther);\r\n        if(msg.value > swapUtils.appFeeInEther){\r\n            TransferHelper.safeTransferETH(msg.sender, (msg.value - swapUtils.appFeeInEther));\r\n        }\r\n        emit FeesPaid(\r\n            msg.sender,\r\n            swapUtils.appFeeInEther\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice swaps ether with second token provided in path array such that user      \r\n       specifies the second token output amount here and accordingly input ether is derived\r\n       @return amounts array consisting on input tokens and output tokens amount\r\n       @param amountIn amount to provide as a input for swap\r\n       @param amountOut amount to expect as a output for swap\r\n       @param path array of addresses with input and output tokens to make a swap\r\n       @param to user's wallet address where output token has to be sent\r\n       @param deadline timestamp before which transaction should be completed\r\n    */\r\n    function swapETHForExactTokens(\r\n        uint amountIn,\r\n        uint amountOut, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline\r\n    ) external virtual override payable ensure(deadline) returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        require(path[0] == WETH, \"Invalid path!\");\r\n        SwapUtils memory swapUtils = _swapPreCheck(msg.sender, path, amountIn, true, msg.value);\r\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n        require(amounts[0] <= (msg.value - swapUtils.appFeeInEther), \"Excessive input amount!\");\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n        totalCollectedFee += swapUtils.appFeeInEther;\r\n        TransferHelper.safeTransferETH(feeHolderAddress, swapUtils.appFeeInEther);\r\n        if(msg.value > (swapUtils.appFeeInEther + amounts[0])){\r\n            TransferHelper.safeTransferETH(msg.sender, (msg.value - (swapUtils.appFeeInEther + amounts[0])));\r\n        }\r\n        emit FeesPaid(\r\n            msg.sender,\r\n            swapUtils.appFeeInEther\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice swaps ether with output token provided in path array such that user      \r\n       specifies the input amount of ether here and accordingly output token amount is derived\r\n       @return amounts array consisting on input tokens and output tokens amount\r\n       @param amountIn amount to provide as a input for swap\r\n       @param amountOutMin amount to expect as a output for swap\r\n       @param path array of addresses with input and output tokens to make a swap\r\n       @param to user's wallet address where output token has to be sent\r\n       @param deadline timestamp before which transaction should be completed\r\n    */\r\n    function swapExactETHForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline\r\n    ) external virtual override payable ensure(deadline) returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        require(path[0] == WETH, \"Invalid path!\");\r\n        SwapUtils memory swapUtils = _swapPreCheck(msg.sender, path, amountIn, true, msg.value);\r\n        amounts = UniswapV2Library.getAmountsOut(factory, (msg.value - swapUtils.appFeeInEther), path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, \"Insufficient output amount!\");\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, to);\r\n         totalCollectedFee += swapUtils.appFeeInEther;\r\n        TransferHelper.safeTransferETH(feeHolderAddress, swapUtils.appFeeInEther);\r\n        if(msg.value > (swapUtils.appFeeInEther + amounts[0])){\r\n            TransferHelper.safeTransferETH(msg.sender, (msg.value - (swapUtils.appFeeInEther + amounts[0])));\r\n        }\r\n        emit FeesPaid(\r\n            msg.sender,\r\n            swapUtils.appFeeInEther\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice swaps first token with USDC provided in path array such that user      \r\n       specifies the input token amount here and accordingly output tokens are derived\r\n       @return amounts array consisting on input tokens and output tokens amount\r\n       @param amountIn amount to provide as a input for swap\r\n       @param path array of addresses with input and output tokens to make a swap\r\n       @param to treasury wallet address where output token has to be sent\r\n       @param deadline timestamp before which transaction should be completed\r\n    */\r\n    function swapExactTokensToUSDCForDonation(\r\n        uint amountIn,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual ensure(deadline) returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        uint donationAmount;\r\n        uint treasuryAmount;\r\n        string memory underflowErrorMessage = \"Underflow value\";\r\n        if(path[0] == USDC){\r\n            require((amountIn * donationFees) >= (donationFeesDecimals * 100), underflowErrorMessage);\r\n            donationAmount = (amountIn * donationFees)/(donationFeesDecimals * 100);\r\n            treasuryAmount = amountIn - donationAmount;\r\n            TransferHelper.safeTransferFrom(USDC, msg.sender, feeHolderAddress, donationAmount);\r\n            TransferHelper.safeTransferFrom(USDC, msg.sender, to, treasuryAmount);\r\n        }else{\r\n            require(path[path.length-1] == USDC, \"Invalid input token!\");\r\n            amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n            require((amounts[amounts.length-1] * (donationFees)) >= (donationFeesDecimals * 100), underflowErrorMessage);\r\n            TransferHelper.safeTransferFrom(\r\n                path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n            );\r\n            _swap(amounts, path, address(this));\r\n            donationAmount = (amounts[amounts.length-1] * (donationFees))/(donationFeesDecimals * 100);   \r\n            treasuryAmount = amounts[amounts.length-1] - donationAmount;\r\n            TransferHelper.safeTransfer(USDC, feeHolderAddress, donationAmount);\r\n            TransferHelper.safeTransfer(USDC, to, treasuryAmount);\r\n        }\r\n        totalCollectedDonationFee += donationAmount;\r\n        emit DonationFeesPaid(\r\n            msg.sender,\r\n            to,\r\n            treasuryAmount,\r\n            donationAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice swaps ether with USDC provided in path array such that user specifies the \r\n       input amount of ether here and accordingly output token amount is derived\r\n       @return amounts array consisting on input tokens and output tokens amount\r\n       @param amountIn amount to provide as a input for swap\r\n       @param path array of addresses with input and output tokens to make a swap\r\n       @param to treasury address where output token has to be sent\r\n       @param deadline timestamp before which transaction should be completed\r\n    */\r\n    function swapExactETHToUSDCForDonation(\r\n        uint amountIn, \r\n        address[] calldata path, \r\n        address to, \r\n        uint deadline\r\n    ) external payable ensure(deadline) returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        uint donationAmount;\r\n        uint treasuryAmount;\r\n        require(path[0] == WETH && path[path.length-1] == USDC, \"Invalid tokens path!\");\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, address(this));\r\n        donationAmount = (amounts[amounts.length-1] * (donationFees))/(donationFeesDecimals * 100) ;\r\n        treasuryAmount = amounts[amounts.length-1] - donationAmount;\r\n        TransferHelper.safeTransfer(USDC, feeHolderAddress, donationAmount);\r\n        TransferHelper.safeTransfer(USDC, to, treasuryAmount);\r\n        totalCollectedDonationFee += donationAmount;\r\n        emit DonationFeesPaid(\r\n            msg.sender,\r\n            to,\r\n            treasuryAmount,\r\n            donationAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice swaps ether with USDC provided in path array such that user specifies the \r\n       input amount of ether here and accordingly output token amount is derived\r\n       @return amounts array consisting on input tokens and output tokens amount\r\n       @param amountIn amount to provide as a input for swap\r\n       @param path array of addresses with input and output tokens to make a swap\r\n       @param deadline timestamp before which transaction should be completed\r\n    */\r\n    function swapExactETHToUSDCForConversion(\r\n        uint amountIn, \r\n        address[] calldata path, \r\n        uint deadline\r\n    ) external payable ensure(deadline) onlyOwner() returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        require(path[0] == WETH && path[path.length-1] == USDC, \"Invalid tokens path!\");\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        IWETH(WETH).deposit{value: amounts[0]}();\r\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\r\n        _swap(amounts, path, msg.sender);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice modifies the Donation fees and can be called by contract owner only\r\n       @notice zero's appended in the last of input number represents decimal places\r\n       @param _fees fees percent to be dedcuted from donation of user\r\n       @param _decimals decimals for donation fees fraction value\r\n    */\r\n    function setDonationFees(\r\n        uint _fees,\r\n        uint _decimals\r\n    ) external onlyOwner() onlyValidFees(_fees, _decimals) {\r\n        require(\r\n            _fees != donationFees || \r\n            _decimals != donationFeesDecimals, \r\n            \"Already same fee used!\"\r\n        );        \r\n        donationFees = _fees;\r\n        donationFeesDecimals = _decimals;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice modifies the Gie app fees and can be called by contract owner only\r\n       @notice zero's appended in the last of input number represents decimal places\r\n       @param fees fees percent to be dedcuted from transaction of user\r\n       @param decimals decimals for gie app fees fraction value\r\n    */\r\n    function setGieAppFees(\r\n        uint fees,\r\n        uint decimals\r\n    ) external onlyOwner() onlyValidFees(fees, decimals) {\r\n        require(\r\n            fees != gieAppFees || \r\n            decimals != gieAppFeesDecimals, \r\n            \"Already same fee used!\"\r\n        );        \r\n        gieAppFees = fees;\r\n        gieAppFeesDecimals = decimals;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice modifies the fee holder address and can be called by contract owner only\r\n       @param _feeHolderAddress new donation holder address\r\n    */\r\n    function setFeeHolderAddress(\r\n        address _feeHolderAddress\r\n    ) external onlyOwner() {\r\n        require(_feeHolderAddress != address(0), \"Fee holder is the zero address\");\r\n        require(feeHolderAddress != _feeHolderAddress, \"Already a fee holder address!\");\r\n        feeHolderAddress = _feeHolderAddress;\r\n    }\r\n    \r\n    /**\r\n     *\r\n     * @notice modifies the gie token contract address and can be called by contract owner only\r\n       @param _gieTokenContract new gie token contract address\r\n    */\r\n    function setGieTokenContract(\r\n        address _gieTokenContract\r\n    ) external onlyOwner() {\r\n        require(_gieTokenContract != address(0), \"Swap: gie token contract is the zero address\");\r\n        require(_gieTokenContract != gieTokenContract, \"Already a GIE Token contract address!\");\r\n        gieTokenContract = _gieTokenContract;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice updates discount rates for GIE token holders, only owner allowed\r\n       @param _tierNo tier no. whose rate is to be changes\r\n       @param _amount new amount for the tier for discount\r\n       @param _discountPercent new discount percent for tier\r\n    */\r\n    function updateDiscount(\r\n        uint _tierNo, \r\n        uint _amount, \r\n        uint8 _discountPercent\r\n    ) external onlyOwner() {\r\n        require(_tierNo > 0 && _tierNo < 5, \"tier no. should be between 0 and 5!\");\r\n        require(_amount > 0 && _discountPercent > 0, \"amount & discount should be greater than 0!\");\r\n        if(_tierNo > 1 && _tierNo < 4){\r\n            _preUpdateDiscountCheck(_tierNo, _amount, _discountPercent, 0);\r\n            _preUpdateDiscountCheck(_tierNo, _amount, _discountPercent, 2);\r\n            _updateDiscount(_tierNo, _amount, _discountPercent);\r\n        } else if(_tierNo == 1){\r\n            _preUpdateDiscountCheck(_tierNo, _amount, _discountPercent, 0);\r\n            _updateDiscount(_tierNo, _amount, _discountPercent);\r\n        } else{\r\n            _preUpdateDiscountCheck(_tierNo, _amount, _discountPercent, 2);\r\n            _updateDiscount(_tierNo, _amount, _discountPercent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n       @notice changes the owner to new owner\r\n       @param newOwner address of the new owner\r\n    */\r\n    function transferOwnership(\r\n        address newOwner\r\n    ) public override onlyOwner {\r\n        require(newOwner != address(0), \"Swap: new owner is the zero address\");\r\n        require(newOwner != owner(), \"Swap: Already a owner\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice swaps one token with another token\r\n       @param amounts array of input and output tokens amount\r\n       @param path array of input and output tokens addresses\r\n       @param _to address of user where swapped tokens has to be sent\r\n    */\r\n    function _swap(\r\n        uint[] memory amounts, \r\n        address[] memory path, \r\n        address _to\r\n    ) internal {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\r\n                amount0Out, amount1Out, to, new bytes(0)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice modifies the discount rate states\r\n       @param _tierNo tier no. whose rate is to be changes\r\n       @param _amount new amount for the tier for discount\r\n       @param _discountPercent new discount percent for tier\r\n    */\r\n    function _updateDiscount(\r\n        uint _tierNo, \r\n        uint _amount, \r\n        uint8 _discountPercent\r\n    ) internal {\r\n        require(\r\n            discountRates[_tierNo-1].amount != _amount ||\r\n            discountRates[_tierNo-1].discountPercent != _discountPercent, \r\n            \"Already same discount exists!\"\r\n        );\r\n        discountRates[_tierNo-1].amount = _amount;\r\n        discountRates[_tierNo-1].discountPercent = _discountPercent;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice checks the parameters whether valid for swap or not\r\n       @return returns structure to be used for further calculation of swapping\r\n       @param account address which calls the swap function \r\n       @param feePath array of addresses pf path for input token to ETH\r\n       @param amountIn input amount for swapping\r\n       @param isInputEth boolean value to check input token is ETH or not\r\n       @param ethAsFee amount as gie app fees for swap\r\n    */\r\n    function _swapPreCheck(\r\n        address account,\r\n        address[] memory feePath,\r\n        uint amountIn,\r\n        bool isInputEth,\r\n        uint ethAsFee\r\n    ) internal view returns(\r\n        SwapUtils memory\r\n    ) {\r\n        SwapUtils memory swapUtils = SwapUtils(0,0, new uint[](feePath.length));\r\n        swapUtils.appFee = calculateFeesForTransaction(account, amountIn);\r\n        if(isInputEth){\r\n            swapUtils.appFeeInEther = swapUtils.appFee;\r\n        }else{\r\n            swapUtils.resultAmount = getAmountsOut(swapUtils.appFee, feePath);\r\n            swapUtils.appFeeInEther = swapUtils.resultAmount[swapUtils.resultAmount.length - 1];\r\n        }\r\n        require(ethAsFee >= swapUtils.appFeeInEther, \"Insufficient transaction fees!\");  \r\n        return swapUtils;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice checks discount rate values before changing discount rate\r\n       @param _tierNo tier no. whose rate is to be changes\r\n       @param _amount new amount for the tier for discount\r\n       @param _discountPercent new discount percent for tier\r\n       @param _index number to check where tier lies in between or at edges\r\n    */\r\n    function _preUpdateDiscountCheck(\r\n        uint _tierNo, \r\n        uint _amount, \r\n        uint8 _discountPercent,\r\n        uint8 _index\r\n    ) internal view {\r\n        string memory errorMessage = \"amount & discount must be lesser than next tier & greater than previous tier!\";\r\n        if(_index == 2){\r\n            require(\r\n                discountRates[_tierNo - _index].amount <  _amount && \r\n                discountRates[_tierNo - _index].discountPercent < _discountPercent, \r\n                errorMessage\r\n            );\r\n        } else{\r\n            require(\r\n                discountRates[_tierNo].amount > _amount && \r\n                discountRates[_tierNo].discountPercent > _discountPercent, \r\n                errorMessage\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice calculates amount of tokenB to get in return when some amount of tokenA is provided \r\n       @return amountB output token amount\r\n       @param amountA input token amount\r\n       @param reserveA reserve of pool for input token A\r\n       @param reserveB reserve of pool for output token B\r\n    */\r\n    function quote(\r\n        uint amountA, \r\n        uint reserveA, \r\n        uint reserveB\r\n    ) public pure virtual override returns (\r\n        uint amountB\r\n    ) {\r\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice calculates amount of tokenA to get in return when some amount of tokenB is provided\r\n       @return amountOut output token amount\r\n       @param amountIn input token amount\r\n       @param reserveIn reserve of pool for input token \r\n       @param reserveOut reserve of pool for output token\r\n    */\r\n    function getAmountOut(\r\n        uint amountIn, \r\n        uint reserveIn, \r\n        uint reserveOut\r\n    ) public pure virtual override returns (\r\n        uint amountOut\r\n    ) {\r\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice calculates amount of tokenA to give when some amount of tokenB is expected in return\r\n       @return amountIn input token amount\r\n       @param amountOut output token amount\r\n       @param reserveIn reserve of pool for input token \r\n       @param reserveOut reserve of pool for output token\r\n    */\r\n    function getAmountIn(\r\n        uint amountOut, \r\n        uint reserveIn, \r\n        uint reserveOut\r\n    ) public pure virtual override returns (\r\n        uint amountIn\r\n    ) {\r\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\r\n    }\r\n\r\n    function allTiers() public pure returns(\r\n        uint8[4] memory\r\n    ) {\r\n        return [1,2,3,4];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice calculates amount of tokenA to get in return when some amount of tokenB is provided \r\n       @return amounts array of input and output tokens amount\r\n       @param amountIn input token amount\r\n       @param path array of addresses with input and output tokens\r\n    */\r\n    function getAmountsOut(\r\n        uint amountIn, \r\n        address[] memory path\r\n    ) public view virtual override returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice calculates amount of tokenA to give when some amount of tokenB is expected in return\r\n       @return amounts array of input and output tokens amount\r\n       @param amountOut output token amount\r\n       @param path array of addresses with input and output tokens\r\n    */\r\n    function getAmountsIn(\r\n        uint amountOut, \r\n        address[] memory path\r\n    ) public view virtual override returns (\r\n        uint[] memory amounts\r\n    ) {\r\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice provides reserves of two tokens pair\r\n       @return reserveA reserve of first token\r\n       @return reserveB reserve of second token\r\n       @param tokenA address of first token \r\n       @param tokenB address of second token \r\n    */\r\n    function getReserves(\r\n        address tokenA, \r\n        address tokenB\r\n    ) public view returns (\r\n        uint reserveA, \r\n        uint reserveB\r\n    ) {\r\n        return UniswapV2Library.getReserves(factory, tokenA, tokenB);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice calculates gie app for some amount of input tokens provided by \r\n       the user to swap\r\n       @return gieAppFee gie app fee to be charged from for swapping\r\n       @param account address that called to swap function of tokens\r\n       @param amount input amount to swap \r\n    */\r\n    function calculateFeesForTransaction(\r\n        address account,\r\n        uint amount\r\n    ) public view returns(\r\n        uint gieAppFee\r\n    ){\r\n        require(amount != 0, \"Invalid amount!\");\r\n        uint discountPercent = calculateDiscountPercent(account);\r\n        gieAppFee = (amount * gieAppFees * (100 - discountPercent)) / (gieAppFeesDecimals * 100 * 100);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice calculates discount percentage on transaction fees\r\n       @return discountPercent returns discount percentage for GIE token holder\r\n       @param account address for which discount percentage if to find\r\n    */\r\n    function calculateDiscountPercent(\r\n        address account\r\n    ) public view returns (\r\n        uint256 discountPercent\r\n    ){\r\n        uint userBalance = IERC20(gieTokenContract).balanceOf(account);\r\n        for(int i = int(discountRates.length-1); i >= 0; i--){\r\n            if(userBalance > discountRates[uint(i)].amount){\r\n                discountPercent = discountRates[uint(i)].discountPercent;\r\n                break;\r\n            }\r\n        }\r\n        return discountPercent;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_USDC\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gieTokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeHolderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_donationFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_donationFeesDecimals\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"donater\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"treasuryAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"treasuryAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"donationFeesPaid\",\"type\":\"uint256\"}],\"name\":\"DonationFeesPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"feesPaid\",\"type\":\"uint256\"}],\"name\":\"FeesPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allTiers\",\"outputs\":[{\"internalType\":\"uint8[4]\",\"name\":\"\",\"type\":\"uint8[4]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"calculateDiscountPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"discountPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateFeesForTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gieAppFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"discountRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"discountPercent\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donationFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donationFeesDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeHolderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gieAppFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gieAppFeesDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gieTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"setDonationFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeHolderAddress\",\"type\":\"address\"}],\"name\":\"setFeeHolderAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"setGieAppFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gieTokenContract\",\"type\":\"address\"}],\"name\":\"setGieTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHToUSDCForConversion\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHToUSDCForDonation\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"feePath\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensToUSDCForDonation\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"feePath\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollectedDonationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollectedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tierNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_discountPercent\",\"type\":\"uint8\"}],\"name\":\"updateDiscount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokensSwap", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c35dadb65012ec5796536bd9864ed8773abc74c40000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000d7a035318d988457a832a256db68ce3288422bba000000000000000000000000fde1266e8e1a576bc7d95194b102671abe3e028d0000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000000a", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8a03ee7187e4ba0257af056824d49c69b8c23df2084952d946e87a50ee44eb6a"}