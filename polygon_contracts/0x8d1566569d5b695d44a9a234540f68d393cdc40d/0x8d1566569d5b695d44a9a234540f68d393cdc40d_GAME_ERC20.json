{"SourceCode": "pragma solidity ^0.7.0;\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - Addition cannot overflow.\r\n    */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - Subtraction cannot overflow.\r\n    */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - Subtraction cannot overflow.\r\n    */\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - Multiplication cannot overflow.\r\n    */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts with custom message when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\nabstract contract EIP712Base {\r\n  struct EIP712Domain {\r\n    string name;\r\n    string version;\r\n    uint256 chainId;\r\n    address verifyingContract;\r\n  }\r\n\r\n  bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256(\r\n    bytes(\r\n      \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n    )\r\n  );\r\n  bytes32 internal domainSeperator;\r\n  bytes32 internal workerDomainSeperator;\r\n\r\n  constructor(\r\n      string memory name,\r\n      string memory version\r\n  ) {\r\n    domainSeperator = encodeDomainSeperator(name, version);\r\n    workerDomainSeperator = encodeWorkerDomainSeperator(name, version);\r\n  }\r\n\r\n  function getChainId() public pure returns (uint256) {\r\n    uint256 id;\r\n    assembly {\r\n      id := chainid()\r\n    }\r\n    return id;\r\n  }\r\n\r\n  function getDomainSeperator() public view returns (bytes32) {\r\n    return domainSeperator;\r\n  }\r\n\r\n  function getWorkerDomainSeperator() public view returns (bytes32) {\r\n    return workerDomainSeperator;\r\n  }\r\n\r\n  function encodeDomainSeperator(string memory name, string memory version) public view returns (bytes32) {\r\n    uint chainId = getChainId();\r\n    require(chainId != 0, \"chain ID must not be zero\");\r\n    return keccak256(\r\n      abi.encode(\r\n        EIP712_DOMAIN_TYPEHASH,\r\n        keccak256(bytes(name)),\r\n        keccak256(bytes(version)),\r\n        chainId,\r\n        address(this)\r\n      )\r\n    );\r\n  }\r\n\r\n  // This encodes the domain separator to the root chain, rather than the main chain.\r\n  function encodeWorkerDomainSeperator(string memory name, string memory version) public view returns (bytes32) {\r\n    uint chainId = getChainId();\r\n\r\n    // 1 == truffle test; 1 == Ethereum\r\n    // 137 == matic mainnet; 1 == Ethereum\r\n    // 80001 == matic mumbai; 5 == Goerli\r\n    chainId = chainId == 137 || chainId == 1 ? 1 : chainId == 80001 ? 5 : 0;\r\n    require(chainId != 0, \"chain ID must not be zero\");\r\n    return keccak256(\r\n      abi.encode(\r\n        EIP712_DOMAIN_TYPEHASH,\r\n        keccak256(bytes(name)),\r\n        keccak256(bytes(version)),\r\n        chainId,\r\n        address(this)\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n    * Accept message hash and returns hash message in EIP712 compatible form\r\n    * So that it can be used to recover signer from signature signed using EIP712 formatted data\r\n    * https://eips.ethereum.org/EIPS/eip-712\r\n    * \"\\\\x19\" makes the encoding deterministic\r\n    * \"\\\\x01\" is the version byte to make it compatible to EIP-191\r\n    */\r\n  function toTypedMessageHash(bytes32 messageHash)\r\n    internal\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    return\r\n      keccak256(\r\n        abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(), messageHash)\r\n      );\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n\r\n  function _msgSender()\r\n    internal\r\n    virtual\r\n    view\r\n    returns (address payable sender)\r\n  {\r\n    if (msg.sender == address(this)) {\r\n      bytes memory array = msg.data;\r\n      uint256 index = msg.data.length;\r\n      assembly {\r\n        // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\r\n        sender := and(\r\n            mload(add(array, index)),\r\n            0xffffffffffffffffffffffffffffffffffffffff\r\n        )\r\n      }\r\n    } else {\r\n      sender = msg.sender;\r\n    }\r\n    return sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface iERC20 {\r\n  /**\r\n    * @dev Returns the amount of tokens in existence.\r\n    */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n    * @dev Returns the amount of tokens owned by `account`.\r\n    */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n    * @dev Returns the remaining number of tokens that `spender` will be\r\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n    * zero by default.\r\n    *\r\n    * This value changes when {approve} or {transferFrom} are called.\r\n    */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n    * that someone may use both the old and the new allowance by unfortunate\r\n    * transaction ordering. One possible solution to mitigate this race\r\n    * condition is to first reduce the spender's allowance to 0 and set the\r\n    * desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    *\r\n    * Emits an {Approval} event.\r\n    */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n    * allowance mechanism. `amount` is then deducted from the caller's\r\n    * allowance.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n    * another (`to`).\r\n    *\r\n    * Note that `value` may be zero.\r\n    */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n    * a call to {approve}. `value` is the new allowance.\r\n    */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\nabstract contract ERC20 is Context, iERC20 {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  mapping (address => uint256) internal _balances;\r\n\r\n  mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  /**\r\n    * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n    * a default value of 18.\r\n    *\r\n    * To select a different value for {decimals}, use {_setupDecimals}.\r\n    *\r\n    * All three of these values are immutable: they can only be set once during\r\n    * construction.\r\n    */\r\n  constructor (string memory name, string memory symbol) {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _decimals = 18;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the name of the token.\r\n    */\r\n  function name() public view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the symbol of the token, usually a shorter version of the\r\n    * name.\r\n    */\r\n  function symbol() public view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the number of decimals used to get its user representation.\r\n    * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n    * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n    *\r\n    * Tokens usually opt for a value of 18, imitating the relationship between\r\n    * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n    * called.\r\n    *\r\n    * NOTE: This information is only used for _display_ purposes: it in\r\n    * no way affects any of the arithmetic of the contract, including\r\n    * {IERC20-balanceOf} and {IERC20-transfer}.\r\n    */\r\n  function decimals() public view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC20-totalSupply}.\r\n    */\r\n  function totalSupply() public view override returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC20-balanceOf}.\r\n    */\r\n  function balanceOf(address account) public view override returns (uint256) {\r\n    return _balances[account];\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC20-transfer}.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `recipient` cannot be the zero address.\r\n    * - the caller must have a balance of at least `amount`.\r\n    */\r\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC20-allowance}.\r\n    */\r\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC20-approve}.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * @dev See {IERC20-transferFrom}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance. This is not\r\n    * required by the EIP. See the note at the beginning of {ERC20};\r\n    *\r\n    * Requirements:\r\n    * - `sender` and `recipient` cannot be the zero address.\r\n    * - `sender` must have a balance of at least `amount`.\r\n    * - the caller must have allowance for ``sender``'s tokens of at least\r\n    * `amount`.\r\n    */\r\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n    *\r\n    * This is an alternative to {approve} that can be used as a mitigation for\r\n    * problems described in {IERC20-approve}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n    *\r\n    * This is an alternative to {approve} that can be used as a mitigation for\r\n    * problems described in {IERC20-approve}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    * - `spender` must have allowance for the caller of at least\r\n    * `subtractedValue`.\r\n    */\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n    * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n    *\r\n    * This is internal function is equivalent to {transfer}, and can be used to\r\n    * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `sender` cannot be the zero address.\r\n    * - `recipient` cannot be the zero address.\r\n    * - `sender` must have a balance of at least `amount`.\r\n    */\r\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n    _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n    _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n    _balances[recipient] = _balances[recipient].add(amount);\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n    * the total supply.\r\n    *\r\n    * Emits a {Transfer} event with `from` set to the zero address.\r\n    *\r\n    * Requirements\r\n    *\r\n    * - `to` cannot be the zero address.\r\n    */\r\n  function _mint(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n    _beforeTokenTransfer(address(0), account, amount);\r\n\r\n    _totalSupply = _totalSupply.add(amount);\r\n    _balances[account] = _balances[account].add(amount);\r\n    emit Transfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n    * @dev Destroys `amount` tokens from `account`, reducing the\r\n    * total supply.\r\n    *\r\n    * Emits a {Transfer} event with `to` set to the zero address.\r\n    *\r\n    * Requirements\r\n    *\r\n    * - `account` cannot be the zero address.\r\n    * - `account` must have at least `amount` tokens.\r\n    */\r\n  function _burn(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n    _beforeTokenTransfer(account, address(0), amount);\r\n\r\n    _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n\r\n  /**\r\n    * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n    *\r\n    * This internal function is equivalent to `approve`, and can be used to\r\n    * e.g. set automatic allowances for certain subsystems, etc.\r\n    *\r\n    * Emits an {Approval} event.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `owner` cannot be the zero address.\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n    require(owner != address(0), \"ERC20: approve from the zero address\");\r\n    require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  /**\r\n    * @dev Sets {decimals} to a value other than the default one of 18.\r\n    *\r\n    * WARNING: This function should only be called from the constructor. Most\r\n    * applications that interact with token contracts will not expect\r\n    * {decimals} to ever change, and may work incorrectly if it does.\r\n    */\r\n  function _setupDecimals(uint8 decimals_) internal {\r\n    _decimals = decimals_;\r\n  }\r\n\r\n  /**\r\n    * @dev Hook that is called before any transfer of tokens. This includes\r\n    * minting and burning.\r\n    *\r\n    * Calling conditions:\r\n    *\r\n    * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n    * will be to transferred to `to`.\r\n    * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n    * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n    * - `from` and `to` are never both zero.\r\n    *\r\n    * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n    */\r\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n\r\n\r\ninterface iChildToken {\r\n    function deposit(address user, bytes calldata depositData) external;\r\n}\r\n\r\n\r\n\r\nabstract contract NetworkAgnostic is EIP712Base, Context {\r\n  using SafeMath for uint256;\r\n  bytes32 internal constant META_TRANSACTION_TYPEHASH = keccak256(\r\n    bytes(\r\n      \"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\"\r\n    )\r\n  );\r\n  event MetaTransactionExecuted(\r\n    address userAddress,\r\n    address payable relayerAddress,\r\n    bytes functionSignature\r\n  );\r\n  mapping(address => uint256) nonces;\r\n\r\n  /*\r\n    * Meta transaction structure.\r\n    * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\r\n    * He should call the desired function directly in that case.\r\n    */\r\n  struct MetaTransaction {\r\n    uint256 nonce;\r\n    address from;\r\n    bytes functionSignature;\r\n  }\r\n\r\n  constructor(\r\n    string memory name,\r\n    string memory version\r\n  ) EIP712Base(name, version) {}\r\n\r\n  function executeMetaTransaction(\r\n    address userAddress,\r\n    bytes memory functionSignature,\r\n    bytes32 sigR,\r\n    bytes32 sigS,\r\n    uint8 sigV\r\n  ) public payable returns (bytes memory) {\r\n    MetaTransaction memory metaTx = MetaTransaction({\r\n      nonce: nonces[userAddress],\r\n      from: userAddress,\r\n      functionSignature: functionSignature\r\n    });\r\n\r\n    require(\r\n      verify(userAddress, metaTx, sigR, sigS, sigV),\r\n      \"Signer and signature do not match\"\r\n    );\r\n\r\n    // increase nonce for user (to avoid re-use)\r\n    nonces[userAddress] = nonces[userAddress].add(1);\r\n\r\n    emit MetaTransactionExecuted(\r\n      userAddress,\r\n      msg.sender,\r\n      functionSignature\r\n    );\r\n\r\n    // Append userAddress and relayer address at the end to extract it from calling context\r\n    (bool success, bytes memory returnData) = address(this).call(\r\n      abi.encodePacked(functionSignature, userAddress)\r\n    );\r\n    require(success, \"Function call not successful\");\r\n\r\n    return returnData;\r\n  }\r\n\r\n  function hashMetaTransaction(MetaTransaction memory metaTx)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    return\r\n      keccak256(\r\n        abi.encode(\r\n          META_TRANSACTION_TYPEHASH,\r\n          metaTx.nonce,\r\n          metaTx.from,\r\n          keccak256(metaTx.functionSignature)\r\n        )\r\n      );\r\n  }\r\n\r\n  function getNonce(address user) public view returns (uint256 nonce) {\r\n    nonce = nonces[user];\r\n  }\r\n\r\n  function verify(\r\n    address signer,\r\n    MetaTransaction memory metaTx,\r\n    bytes32 sigR,\r\n    bytes32 sigS,\r\n    uint8 sigV\r\n  ) internal view returns (bool) {\r\n    return\r\n      signer != address(0) && signer ==\r\n      ecrecover(\r\n        toTypedMessageHash(hashMetaTransaction(metaTx)),\r\n        sigV,\r\n        sigR,\r\n        sigS\r\n      );\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n// @title iLocalContract\r\n// @dev The interface for the main Token Manager contract\r\n//  Only methods required for calling by sibling contracts are required here\r\n// @author GAME Credits (gamecredits.org)\r\n// (c) 2020 GAME Credits All Rights Reserved. This code is not open source.\r\n\r\nabstract contract iLocalContract {\r\n\r\n  function updateLocalContract(address contract_, bool isLocal_) virtual external;\r\n\r\n  function metaTxSenderIsWorkerOrMinion() internal virtual returns (bool);\r\n\r\n  function isLocalContract()\r\n    external\r\n    virtual\r\n    pure\r\n  returns(bool) {\r\n    return true;\r\n  }\r\n}\r\n\r\nabstract contract WorkerMetaTransactions is NetworkAgnostic, iLocalContract {\r\n  using SafeMath for uint256;\r\n  bytes32 private constant WORKER_META_TRANSACTION_TYPEHASH = keccak256(\r\n    bytes(\r\n      \"WorkerMetaTransaction(bytes32 replayPrevention,address from,bytes functionSignature)\"\r\n    )\r\n  );\r\n\r\n  // This mapping records all meta-transactions that have been played.\r\n  // It costs more than the nonce method, but this is permissioned, so it's more reliable.\r\n  mapping(address => mapping(bytes32 => bool)) playedTransactions;\r\n\r\n  /*\r\n    * Meta transaction structure.\r\n    * No point of including value field here as a user who is doing value transfer has the funds to pay for gas\r\n    *   and should call the desired function directly in that case.\r\n    */\r\n  struct WorkerMetaTransaction {\r\n    bytes32 replayPrevention;\r\n    address from;\r\n    bytes functionSignature;\r\n  }\r\n\r\n  function workerExecuteMetaTransaction(\r\n    address userAddress_,\r\n    bytes32 replayPrevention_,\r\n    bytes memory functionSignature_,\r\n    bytes32 sigR_,\r\n    bytes32 sigS_,\r\n    uint8 sigV_\r\n  )\r\n    public\r\n    payable\r\n  returns (bytes memory) {\r\n    require(metaTxSenderIsWorkerOrMinion(), \"Worker Meta-Transaction sent by account other than a worker/minion\");\r\n    WorkerMetaTransaction memory metaTx = WorkerMetaTransaction({\r\n      replayPrevention: replayPrevention_,\r\n      from: userAddress_,\r\n      functionSignature: functionSignature_\r\n    });\r\n\r\n    require(\r\n      workerVerify(userAddress_, metaTx, sigR_, sigS_, sigV_),\r\n      \"Signer and signature do not match\"\r\n    );\r\n\r\n    require(playedTransactions[userAddress_][replayPrevention_] == false, \"REPLAY of a previous transaction\");\r\n    playedTransactions[userAddress_][replayPrevention_] = true;\r\n\r\n    emit MetaTransactionExecuted(\r\n      userAddress_,\r\n      msg.sender,\r\n      functionSignature_\r\n    );\r\n\r\n    // Append userAddress and relayer address at the end to extract it from calling context\r\n    (bool success, bytes memory returnData) = address(this).call(\r\n      abi.encodePacked(functionSignature_, userAddress_)\r\n    );\r\n    require(success, \"Function call not successful\");\r\n\r\n    return returnData;\r\n  }\r\n\r\n  function hashWorkerMetaTransaction(WorkerMetaTransaction memory metaTx_)\r\n    internal\r\n    pure\r\n  returns (bytes32) {\r\n    return\r\n      keccak256(\r\n        abi.encode(\r\n          WORKER_META_TRANSACTION_TYPEHASH,\r\n          metaTx_.replayPrevention,\r\n          metaTx_.from,\r\n          keccak256(metaTx_.functionSignature)\r\n        )\r\n      );\r\n  }\r\n\r\n  function workerVerify(\r\n    address signer_,\r\n    WorkerMetaTransaction memory metaTx_,\r\n    bytes32 sigR_,\r\n    bytes32 sigS_,\r\n    uint8 sigV_\r\n  ) \r\n    internal\r\n    view\r\n  returns (bool) {\r\n    return\r\n      signer_ != address(0) && signer_ ==\r\n      ecrecover(\r\n        toWorkerTypedMessageHash(hashWorkerMetaTransaction(metaTx_)),\r\n        sigV_,\r\n        sigR_,\r\n        sigS_\r\n      );\r\n  }\r\n\r\n  /**\r\n    * Accept message hash and returns hash message in EIP712 compatible form\r\n    * So that it can be used to recover signer from signature signed using EIP712 formatted data\r\n    * https://eips.ethereum.org/EIPS/eip-712\r\n    * \"\\\\x19\" makes the encoding deterministic\r\n    * \"\\\\x01\" is the version byte to make it compatible to EIP-191\r\n    */\r\n  function toWorkerTypedMessageHash(bytes32 messageHash_)\r\n    internal\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    return\r\n      keccak256(\r\n        abi.encodePacked(\"\\x19\\x01\", getWorkerDomainSeperator(), messageHash_)\r\n      );\r\n  }\r\n}\r\n\r\n\r\n\r\nabstract contract ChildERC20 is ERC20, iChildToken, WorkerMetaTransactions {\r\n\r\n  address public depositor;\r\n\r\n  constructor(\r\n    string memory name_,\r\n    string memory symbol_,\r\n    uint8 decimals_,\r\n    address depositor_\r\n  ) ERC20(name_, symbol_) {\r\n    _setupDecimals(decimals_);\r\n    depositor = depositor_;\r\n  }\r\n\r\n  modifier onlyDepositor() {\r\n    require(_msgSender() == depositor, \"ChildERC20: INSUFFICIENT_PERMISSIONS\");\r\n    _;\r\n  }\r\n\r\n  function _setDepositor(address _depositor)\r\n    internal\r\n  {\r\n    depositor = _depositor;\r\n  }\r\n\r\n  /**\r\n    * @notice called when token is deposited on root chain\r\n    * @dev Should be callable only by ChildChainManager\r\n    * Should handle deposit by minting the required amount for user\r\n    * Make sure minting is done only by this function\r\n    * @param user user address for whom deposit is being done\r\n    * @param depositData abi encoded amount\r\n    */\r\n  function deposit(address user, bytes calldata depositData)\r\n    external\r\n    override\r\n    onlyDepositor\r\n  {\r\n    uint256 amount = abi.decode(depositData, (uint256));\r\n    _mint(user, amount);\r\n  }\r\n\r\n  /**\r\n    * @notice called when user wants to withdraw tokens back to root chain\r\n    * @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\r\n    * @param amount amount of tokens to withdraw\r\n    */\r\n  function withdraw(uint256 amount) external {\r\n    _burn(_msgSender(), amount);\r\n  }\r\n\r\n  // To recieve ether in contract\r\n  receive() external payable {}\r\n}\r\n\r\n\r\n\r\n// @title iGAME_Game\r\n// @dev The interface for the GAME Credits Game Data contract\r\n//  Only methods required for calling by sibling contracts are required here\r\n// @author GAME Credits (gamecredits.org)\r\n// (c) 2020 GAME Credits All Rights Reserved. This code is not open source.\r\n\r\nabstract contract iGAME_Game {\r\n  mapping(uint => mapping(address => bool)) public gameAdmins;\r\n  mapping(uint => mapping(address => bool)) public gameOperators;\r\n\r\n  function getCardPrice(uint game_, uint set_, uint card_) virtual external view returns(uint256);\r\n  function getCardLoyaltyPrice(uint game_, uint set_, uint card_) virtual external view returns(uint256);\r\n  function isGameAdmin(uint game_, address admin_) virtual external view returns(bool);\r\n  function linkContracts(address erc721Contract_, address erc20Contract_) virtual external;\r\n  function isOperatorOrMinion(uint game_, address sender_) virtual external returns(bool);\r\n  function isValidCaller(address account_, bool isMinion_, uint game_) virtual external view returns(bool isValid);\r\n  function burnToken(uint tokenId_) virtual external;\r\n  function createTokenFromCard(uint game_, uint set_, uint card_) virtual external returns(uint tokenId, uint tradeLockTime, uint fixedXp);\r\n}\r\n\r\n\r\n\r\n// @title iGAME_Master\r\n// @dev The interface for the Master contract\r\n//  Only methods required for calling by sibling contracts are required here\r\n// @author GAME Credits (gamecredits.org)\r\n// (c) 2020 GAME Credits All Rights Reserved. This code is not open source.\r\n\r\nabstract contract iGAME_Master {\r\n  function isOwner(address owner_) virtual external view returns (bool);\r\n  function isCFO(address cfo_) virtual external view returns (bool);\r\n  function isCOO(address coo_) virtual external view returns (bool);\r\n  function isWorker(address account_) virtual external view returns (bool);\r\n  function isWorkerOrMinion(address account_) virtual external view returns (bool);\r\n  function makeFundedCall(address account_) virtual external returns (bool);\r\n  function updateCollectibleSaleStatus(uint game_, uint card_, bool isOnSale_) virtual external;\r\n\r\n  function isMaster()\r\n    external\r\n    pure\r\n  returns(bool) {\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\r\n// @title iGAME_ERC721\r\n// @dev The interface for the main Token Manager contract\r\n//  Only methods required for calling by sibling contracts are required here\r\n// @author GAME Credits (gamecredits.org)\r\n// (c) 2020 GAME Credits All Rights Reserved. This code is not open source.\r\n\r\nabstract contract iGAME_ERC721 {\r\n\r\n  function auctionTransfer(address from_, address to_, uint tokenId_) virtual external;\r\n\r\n  function inGameOwnerOf(uint tokenId_) virtual external view returns (bytes32 owner_);\r\n\r\n  function revokeToken(uint game_, uint tokenId_, bytes32 purchaseId_)\r\n    virtual external returns (bool _isRevoked);\r\n\r\n  function transferNewToken(bytes32 recipient_, uint tokenId_, uint tradeLockTime_)\r\n    virtual external;\r\n\r\n  function getCryptoAccount(uint game_, bytes32 inGameAccount_)\r\n    virtual public view returns(address cryptoAccount);\r\n\r\n  function getValidCryptoAccount(uint game_, bytes32 inGameAccount_)\r\n    virtual public view returns(address cryptoAccount);\r\n\r\n  function getInGameAccount(uint game_, address cryptoAccount_)\r\n    virtual public view returns(bytes32 inGameAccount);\r\n\r\n  function getValidInGameAccount(uint game_, address cryptoAccount_)\r\n    virtual public view returns(bytes32 inGameAccount);\r\n\r\n  function getOrCreateInGameAccount(uint game_, address cryptoAccount_)\r\n    virtual external returns(bytes32 inGameAccount);\r\n\r\n  function linkContracts(address gameContract_, address erc20Contract_) virtual external;\r\n\r\n  function generateCollectible(uint tokenId_, uint xp_, uint xpPerHour_, uint creationTime_) virtual external;\r\n}\r\n\r\n\r\n\r\n// @title iGAME_ERC20\r\n// @dev The interface for the Auction & ERC-20 contract\r\n//  Only methods required for calling by sibling contracts are required here\r\n// @author GAME Credits (gamecredits.org)\r\n// (c) 2020 GAME Credits All Rights Reserved. This code is not open source.\r\n\r\nabstract contract iGAME_ERC20 {\r\n\r\n  function cancelAuctionByManager(uint tokenId_) virtual external;\r\n\r\n  function transferByContract(address from_, address to_, uint256 value_) virtual external;\r\n\r\n  function linkContracts(address gameContract_, address erc721Contract_) virtual external;\r\n\r\n  function getGameBalance(uint game_) virtual public view returns(uint balance);\r\n\r\n  function getLoyaltyPointsGranted(uint game_, address account_) virtual public view returns(uint currentPoints);\r\n\r\n  function getLoyaltyPointSpends(uint game_, address account_) virtual public view returns(uint currentPoints);\r\n\r\n  function getLoyaltyPointsTotal(uint game_, address account_) virtual public view returns(uint currentPoints);\r\n\r\n  function thirdPartySpendLoyaltyPoints(uint game_, address account_, uint pointsToSpend_) virtual external;\r\n}\r\n\r\n\r\n// @title ERC20 Sidechain manager imlpementation\r\n// @dev Utility contract that manages Ethereum and ERC-20 tokens transferred in from the main chain\r\n// @dev Can manage any number of tokens\r\n// @author GAME Credits (gamecredits.org)\r\n// (c) 2020 GAME Credits All Rights Reserved. This code is not open source.\r\n\r\nabstract contract GAME_ERC20Access is iGAME_ERC20, ChildERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  event Balance(address account, uint256 value);\r\n\r\n  iGAME_Master public masterContract;\r\n  iGAME_Game public gameContract;\r\n  iGAME_ERC721 public erc721Contract;\r\n  mapping(address => bool) public localContracts;\r\n\r\n  // Tracks contracts that are allowed to spend Loyalty Points\r\n  mapping(address => bool) public approvedLoyaltySpenders;\r\n\r\n  event ThirdPartyRewwardsSpender(address indexed spenderContract, bool isSpender);\r\n\r\n  constructor(address masterContract_)\r\n  {\r\n    masterContract = iGAME_Master(masterContract_);\r\n    localContracts[masterContract_] = true;\r\n  }\r\n\r\n\r\n  modifier workerOrMinion() {\r\n    require(masterContract.makeFundedCall(_msgSender()), \"must be called by a worker or minion\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyCFO() {\r\n    require(masterContract.isCFO(_msgSender()), \"sender must be the cfo\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(masterContract.isOwner(_msgSender()), \"sender must be the owner\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGameAdmin(uint game_) {\r\n    require(gameContract.isGameAdmin(game_, _msgSender()), \"sender must be a game admin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyLocalContract() {\r\n    // Cannot be called using native meta-transactions\r\n    require(localContracts[msg.sender], \"must be called by a local contract\");\r\n    _;\r\n  }\r\n\r\n  function updateLocalContract(address contract_, bool isLocal_)\r\n    external\r\n    override\r\n    onlyLocalContract\r\n  {\r\n    require(contract_ != address(masterContract), \"can't reset the master contract\");\r\n    require(contract_ != address(erc721Contract), \"can't reset the erc721 contract\");\r\n    require(contract_ != address(0), \"can't be the zero address\");\r\n    localContracts[contract_] = isLocal_;\r\n  }\r\n\r\n  function linkContracts(address gameContract_, address erc721Contract_)\r\n    external\r\n    override\r\n    onlyLocalContract\r\n  {\r\n    require(address(gameContract) == address(0), \"token contract must be blank\");\r\n    require(address(erc721Contract) == address(0), \"token contract must be blank\");\r\n    gameContract = iGAME_Game(gameContract_);\r\n    erc721Contract = iGAME_ERC721(erc721Contract_);\r\n\r\n    approvedLoyaltySpenders[gameContract_] = true;\r\n    emit ThirdPartyRewwardsSpender(gameContract_, true);\r\n    approvedLoyaltySpenders[erc721Contract_] = true;\r\n    emit ThirdPartyRewwardsSpender(erc721Contract_, true);\r\n    approvedLoyaltySpenders[address(masterContract)] = true;\r\n    emit ThirdPartyRewwardsSpender(address(masterContract), true);\r\n  }\r\n\r\n  function setDepositor(address depositor_)\r\n    external\r\n    onlyOwner\r\n  {\r\n    _setDepositor(depositor_);\r\n  }\r\n\r\n  function transferByContract(address from_, address to_, uint256 value_)\r\n    external\r\n    override\r\n    onlyLocalContract\r\n  {\r\n    _transfer(from_, to_, value_);\r\n  }\r\n\r\n  function metaTxSenderIsWorkerOrMinion()\r\n    internal\r\n    override\r\n  returns (bool) {\r\n    return masterContract.makeFundedCall(msg.sender);\r\n  }\r\n}\r\n\r\n// @author GAME Credits (gamecredits.org)\r\n// (c) 2020 GAME Credits All Rights Reserved. This code is not open source.\r\n\r\nabstract contract GAME_ERC20Loyalty is GAME_ERC20Access {\r\n  using SafeMath for uint256;\r\n\r\n  // Emitted whenever a user's stake is increased or decreased.\r\n  event LoyaltyPointsChange(\r\n    uint indexed game,\r\n    address indexed account,\r\n    uint indexed week,\r\n    uint currentStake,\r\n    uint totalGranted,\r\n    uint totalSpent\r\n  );\r\n  event LoyaltyPointsGranted(uint indexed game, address indexed account, uint pointsGrant);\r\n  event LoyaltyPointsRemoved(uint indexed game, address indexed account, uint pointsRemoved);\r\n  event LoyaltyPartnerSet(uint indexed game, address indexed account, uint week);\r\n\r\n  // GAME stake needed to gain one Loyalty Point, per week (10 ** 18 is 1 GAME)\r\n  uint public gcPerLoyaltyPoint = 10 ** 18;\r\n\r\n  uint public constant WEEK_ZERO_START = 1538352000; // 10/1/2018 @ 00:00:00\r\n  uint public constant SECONDS_PER_WEEK = 604800;\r\n\r\n  // Granted by the account stake amount; can also be granted\r\n  mapping(uint => mapping (address => uint)) public gameAccountLoyaltyPoints;\r\n\r\n  // Tracks the user's spending of Loyalty Points.\r\n  mapping(uint => mapping (address => uint)) public gameAccountPointsSpent;\r\n\r\n  // Used to manage updates to gameAccountStaked and gameStake;\r\n  mapping(uint => mapping (address => uint)) public gameAccountStakeWeek;\r\n\r\n  // Tracks the user's current stake\r\n  mapping(uint => mapping (address => uint)) public gameAccountStaked;\r\n\r\n  mapping(address => uint) public loyaltyPartners;\r\n\r\n  // Tracks the current\r\n  mapping(address => uint) public loyaltyWeeks;\r\n\r\n  function getCurrentWeek()\r\n    public\r\n    view\r\n  returns(uint) {\r\n    return (block.timestamp - WEEK_ZERO_START) / SECONDS_PER_WEEK;\r\n  }\r\n\r\n  function workerGrantLoyaltyPoints(uint game_, address account_, uint pointsGrant_)\r\n    external\r\n    workerOrMinion\r\n  {\r\n    emit LoyaltyPointsGranted(game_, account_, pointsGrant_);\r\n    _addLoyaltyPoints(game_, account_, pointsGrant_);\r\n  }\r\n\r\n  function _addLoyaltyPoints(uint game_, address account_, uint pointsGrant_)\r\n    internal\r\n  {\r\n    gameAccountLoyaltyPoints[game_][account_] = gameAccountLoyaltyPoints[game_][account_].add(pointsGrant_);\r\n\r\n    uint newBalance = getLoyaltyPointsGranted(game_, account_);\r\n\r\n    emit LoyaltyPointsChange(\r\n      game_,\r\n      account_,\r\n      getCurrentWeek(),\r\n      gameAccountStaked[game_][account_],\r\n      newBalance,\r\n      gameAccountPointsSpent[game_][account_]);\r\n  }\r\n\r\n  function workerRemoveLoyaltyPoints(uint game_, address account_, uint pointsToRemove_)\r\n    external\r\n    workerOrMinion\r\n  {\r\n    gameAccountLoyaltyPoints[game_][account_] = gameAccountLoyaltyPoints[game_][account_].sub(pointsToRemove_);\r\n\r\n    uint newBalance = getLoyaltyPointsGranted(game_, account_);\r\n\r\n    emit LoyaltyPointsRemoved(game_, account_, pointsToRemove_);\r\n    emit LoyaltyPointsChange(\r\n      game_,\r\n      account_,\r\n      getCurrentWeek(),\r\n      gameAccountStaked[game_][account_],\r\n      newBalance,\r\n      gameAccountPointsSpent[game_][account_]);\r\n  }\r\n\r\n  function approveThirdPartyLoyaltySpender(address contract_, bool isSpender_)\r\n    external\r\n    onlyCFO\r\n  {\r\n    if(isSpender_) {\r\n      require(!approvedLoyaltySpenders[contract_], \"Contract is already a spender\");\r\n    } else {\r\n      require(approvedLoyaltySpenders[contract_], \"Contract isn't an existing spender\");\r\n    }\r\n    approvedLoyaltySpenders[contract_] = isSpender_;\r\n    emit ThirdPartyRewwardsSpender(contract_, isSpender_);\r\n  }\r\n\r\n  function thirdPartySpendLoyaltyPoints(uint game_, address account_, uint pointsToSpend_)\r\n    external\r\n    override\r\n  {\r\n    // Cannot be called using native meta-transactions\r\n    require(approvedLoyaltySpenders[msg.sender], \"must be an approved Loyalty Points spender contract\");\r\n    _spendLoyaltyPoints(game_, account_, pointsToSpend_);\r\n  }\r\n\r\n  function workerSpendLoyaltyPoints(uint game_, address account_, uint pointsToSpend_)\r\n    external\r\n    workerOrMinion\r\n  {\r\n    _spendLoyaltyPoints(game_, account_, pointsToSpend_);\r\n  }\r\n\r\n  function _spendLoyaltyPoints(uint game_, address account_, uint pointsToSpend_)\r\n    internal\r\n  {\r\n    uint currentPoints = getLoyaltyPointsGranted(game_, account_);\r\n    // Ensure balance is sufficient\r\n    uint newSpend = gameAccountPointsSpent[game_][account_].add(pointsToSpend_);\r\n    require(currentPoints >= newSpend, \"spent more Loyalty Points than current balance\");\r\n    gameAccountPointsSpent[game_][account_] = newSpend;\r\n    emit LoyaltyPointsChange(game_, account_, getCurrentWeek(), gameAccountStaked[game_][account_], currentPoints, newSpend);\r\n  }\r\n\r\n  // What happens if we spend during an update; we don't want to update the actual balance, just calculate it.\r\n  function getLoyaltyPointsGranted(uint game_, address account_)\r\n    public\r\n    override\r\n    view\r\n  returns(uint currentPoints)\r\n  {\r\n    uint stakeWeek = gameAccountStakeWeek[game_][account_];\r\n    uint _currentWeek = getCurrentWeek();\r\n    uint currentStake = gameAccountStaked[game_][account_];\r\n\r\n\r\n    currentPoints = gameAccountLoyaltyPoints[game_][account_]\r\n      .add((_currentWeek.sub(stakeWeek)).mul(currentStake.div(gcPerLoyaltyPoint)));\r\n    // add their outstanding balance LP \r\n\r\n    uint currentPartner = loyaltyPartners[account_]; \r\n    if(currentPartner == game_ && game_ != 0) {\r\n      uint loyaltyWeek = loyaltyWeeks[account_];\r\n      if(loyaltyWeek < _currentWeek) {\r\n        uint balance = _balances[account_];\r\n        uint pointsToAdd = balance.div(gcPerLoyaltyPoint).mul(_currentWeek.sub(loyaltyWeek));\r\n        currentPoints = currentPoints.add(pointsToAdd);\r\n      }\r\n    }\r\n  }\r\n\r\n  function getLoyaltyPointSpends(uint game_, address account_)\r\n    public\r\n    override\r\n    view\r\n  returns(uint totalSpend)\r\n  {\r\n    totalSpend = gameAccountPointsSpent[game_][account_];\r\n  }\r\n\r\n  function getLoyaltyPointsTotal(uint game_, address account_)\r\n    public\r\n    override\r\n    view\r\n  returns(uint totalRemaining)\r\n  {\r\n    uint points = getLoyaltyPointsGranted(game_, account_);\r\n    uint spent = getLoyaltyPointSpends(game_, account_);\r\n    if(points <= spent) {\r\n      totalRemaining = 0;\r\n    } else {\r\n      totalRemaining = points.sub(spent);\r\n    }\r\n  }\r\n\r\n  // Internal transfer of ERC20 tokens to complete payment of an auction.\r\n  // @param from_ The address which you want to send tokens from\r\n  // @param to_ The address which you want to transfer to\r\n  // @param value_ The amout of tokens to be transferred\r\n  function _beforeTokenTransfer(address from_, address to_, uint256 value_)\r\n    internal\r\n    override\r\n  {\r\n    if(from_ != address(0)) {\r\n      emit Balance(from_, _balances[from_].sub(value_));\r\n      _updateLoyalty(from_);\r\n    }\r\n    if(to_ != address(0)) {\r\n      emit Balance(to_, _balances[to_].add(value_));\r\n      _updateLoyalty(to_);\r\n    }\r\n  }\r\n\r\n  function selectLoyaltyPartner(uint partnerId_)\r\n    external\r\n  {\r\n    _setLoyaltyPartner(_msgSender(), partnerId_);\r\n  }\r\n\r\n  function workerSelectLoyaltyPartner(address account_, uint partnerId_)\r\n    external\r\n    workerOrMinion\r\n  {\r\n    _setLoyaltyPartner(account_, partnerId_);\r\n  }\r\n\r\n\r\n  // When a user picks a game,\r\n  // if the user has a game picked and their last update week is last week or before\r\n  // then grant N weeks of LP based on their prior balance\r\n  // and update their last update week to this week\r\n  function _setLoyaltyPartner(address account_, uint partnerId_)\r\n    internal\r\n  {\r\n    _updateLoyalty(account_);\r\n    uint currentPartner = loyaltyPartners[account_];\r\n    loyaltyPartners[account_] = partnerId_;\r\n    uint loyaltyWeek = loyaltyWeeks[account_];\r\n    uint currentWeek = getCurrentWeek();\r\n    if(loyaltyWeek == 0) {\r\n      loyaltyWeeks[account_] = currentWeek;\r\n    }\r\n    if(currentPartner != partnerId_) {\r\n      emit LoyaltyPartnerSet(partnerId_, account_, currentWeek);\r\n    }\r\n  }\r\n\r\n  // handle loyalty points here\r\n  // if the user has a game picked and their last update week is last week or before\r\n  // then grant N weeks of LP based on their prior balance\r\n  // and update their last update week to this week\r\n  function _updateLoyalty(address account_)\r\n    internal\r\n  {\r\n    uint currentPartner = loyaltyPartners[account_]; \r\n    if(currentPartner != 0) {\r\n      uint loyaltyWeek = loyaltyWeeks[account_];\r\n      uint currentWeek = getCurrentWeek();\r\n      if(loyaltyWeek < currentWeek) {\r\n        uint balance = _balances[account_];\r\n        uint pointsToAdd = balance.div(gcPerLoyaltyPoint).mul(currentWeek.sub(loyaltyWeek));\r\n        _addLoyaltyPoints(currentPartner, account_, pointsToAdd);\r\n        loyaltyWeeks[account_] = currentWeek;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// @author GAME Credits (gamecredits.org)\r\n// (c) 2020 GAME Credits All Rights Reserved. This code is not open source.\r\n\r\nabstract contract GAME_ERC20Staking is GAME_ERC20Loyalty {\r\n  using SafeMath for uint256;\r\n\r\n  event OracleTransaction(bytes32 indexed txHash);\r\n\r\n  uint[] public gameStakeLevelCaps = [1, 2, 3, 4, 5, 6, 100000000000];\r\n\r\n  uint public gameLevelPoints = 50;\r\n  uint public auctionSitePoints = 100;\r\n  uint public totalFeePoints = 400;\r\n\r\n\r\n  // Tracks the current stake of each game.\r\n  mapping(uint => uint) public gameStaked;\r\n  // Stake\r\n  uint public totalStaked;\r\n\r\n\r\n  mapping(bytes32 => bool) public updateStakesOracleHashes;\r\n\r\n  function setGameLevelPoints(uint points_)\r\n    external\r\n    onlyCFO\r\n  {\r\n    require(points_ <= 100, \"must be less than or equal to 1%\");\r\n    gameLevelPoints = points_;\r\n    totalFeePoints = auctionSitePoints.add(points_.mul(6));\r\n  }\r\n\r\n  function setAuctionSitePoints(uint points_)\r\n    external\r\n    onlyCFO\r\n  {\r\n    require(points_ <= 500, \"must be less than or equal to 5%\");\r\n    auctionSitePoints = points_;\r\n    totalFeePoints = points_.add(gameLevelPoints.mul(6));\r\n  }\r\n\r\n  function setGameStakeLevelCaps(uint[7] calldata caps_)\r\n    external\r\n    onlyCFO\r\n  {\r\n    uint previousData = 0;\r\n    uint cap = 0;\r\n    for(uint i = 0; i < 7; i++) {\r\n      cap = caps_[i];\r\n      require(cap > previousData, \"caps must be ascending and non-zero\");\r\n      gameStakeLevelCaps[i] = cap;\r\n      previousData = cap;\r\n    }\r\n    require(cap == 100000000000, \"highest cap must be 100 billion\");\r\n  }\r\n\r\n  function getGameStakeLevel(uint game_)\r\n    public\r\n    view\r\n  returns (uint level) {\r\n    uint gameStake = gameStaked[game_];\r\n    for(level = 0; level < 7; level++) {\r\n      if(gameStake < gameStakeLevelCaps[level]) {\r\n        return level;\r\n      }\r\n    }\r\n  }\r\n\r\n  function getGameBalance(uint game_)\r\n    public\r\n    override\r\n    view\r\n  returns(uint balance) {\r\n    balance = _balances[game_ == 0 ? address(this) : address(game_)];\r\n  }\r\n\r\n  // @dev Internal function to calculate the game, account, and total stakes on a stake change\r\n  // @param week_ - the week we're updating (must be current or past)\r\n  // @param game_ - the game to be staked on\r\n  // @param staker_ - the account doing the staking\r\n  // @param newStake_ - the newly updated stake of the staker on that game\r\n  function oracleUpdateStakes(bytes32 txHash_, uint week_, uint game_, address staker_, uint newStake_)\r\n    external\r\n    workerOrMinion\r\n  {\r\n    if(updateStakesOracleHashes[txHash_]) {\r\n      return;\r\n    }\r\n    updateStakesOracleHashes[txHash_] = true;\r\n    emit OracleTransaction(txHash_);\r\n\r\n    uint _currentWeek = getCurrentWeek();\r\n    require(week_ <= _currentWeek, \"requested week must be now or in the past\");\r\n    require(newStake_ <= 10 ** 29, \"account stake underflow - must be <100Bn\");\r\n\r\n    // Check if the week is (a) less (do nothing), (b) equal (diff the stake), (c) greater (update everything)\r\n    uint stakeWeek = gameAccountStakeWeek[game_][staker_];\r\n\r\n    // If this is data for a previous week, ignore it\r\n    // (we could adjust based on complex logic, but ignore is safer)\r\n    require(stakeWeek <= week_, \"requested week must be equal or later than stake week\");\r\n\r\n    uint playerStake = gameAccountStaked[game_][staker_];\r\n    bool isStakeIncrease = newStake_ > playerStake ? true : false;\r\n    uint stakeChange = isStakeIncrease ? newStake_ - playerStake : playerStake - newStake_;\r\n    // update gameAccountStaked to the new stake amount\r\n    // update gameStake based on the diff\r\n    // update totalStake based on the diff\r\n    gameAccountStakeWeek[game_][staker_] = week_;\r\n    gameAccountStaked[game_][staker_] = newStake_;\r\n    gameStaked[game_] = isStakeIncrease\r\n      ? gameStaked[game_] + stakeChange\r\n      : gameStaked[game_] - stakeChange;\r\n    require(gameStaked[game_] <= 10 ** 29, \"game stake underflow\");\r\n    totalStaked = isStakeIncrease\r\n      ? totalStaked + stakeChange\r\n      : totalStaked - stakeChange;\r\n    require(totalStaked <= 10 ** 29, \"total stake underflow\");\r\n\r\n    uint weeksToPay = (stakeWeek >= _currentWeek || stakeWeek >= week_ || stakeWeek == 0)\r\n      ? 0\r\n      : week_ - stakeWeek;\r\n    uint pointsSpent = gameAccountPointsSpent[game_][staker_];\r\n    // Update the Loyalty Points with the change\r\n    gameAccountLoyaltyPoints[game_][staker_] = gameAccountLoyaltyPoints[game_][staker_].add(weeksToPay.mul(playerStake.div(gcPerLoyaltyPoint)));\r\n    // If the last edit was made more than a week ago, collect Loyalty Points for the intervening weeks.\r\n\r\n    // The current points is \"what the points would be if you\r\n    uint grantedPoints = getLoyaltyPointsGranted(game_, staker_);\r\n\r\n    emit LoyaltyPointsChange(\r\n      game_,\r\n      staker_,\r\n      week_,\r\n      newStake_,\r\n      grantedPoints,\r\n      pointsSpent);\r\n  }\r\n}\r\n\r\n\r\n// @title Auction Base\r\n// @dev Contains models, variables, and internal methods for the auction.\r\n// @notice We omit a fallback function to prevent accidental sends to this contract.\r\n// @author GAME Credits (gamecredits.org)\r\n// (c) 2020 GAME Credits All Rights Reserved. This code is not open source.\r\n\r\nabstract contract AuctionBase is GAME_ERC20Staking {\r\n  using SafeMath for uint256;\r\n\r\n  // @dev Map from tokenId to their corresponding auction data.\r\n  // @notice We use two uints here because it's much more efficient than a struct\r\n  mapping (uint => uint) public auctionIdToMetadata;\r\n  mapping (uint => uint) public auctionIdToPrices;\r\n\r\n  event AuctionCreated(\r\n    address indexed seller,\r\n    uint indexed tokenId,\r\n    uint startingPrice,\r\n    uint endingPrice,\r\n    uint startTime,\r\n    uint duration\r\n  );\r\n\r\n  event AuctionSuccessful(\r\n    address indexed seller,\r\n    address indexed buyer,\r\n    uint indexed tokenId,\r\n    uint totalPrice\r\n  );\r\n\r\n  event AuctionCancelled(address indexed seller, uint indexed tokenId);\r\n\r\n  // @dev Adds an auction to the list of open auctions. Also fires the\r\n  //  AuctionCreated event.\r\n  // @param tokenId_ The Id of the token to be put on auction.\r\n  // @param startingPrice - the start price of the Auction to add.\r\n  // @param endingPrice - the end price of the Auction to add.\r\n  // @param duration - the length of the Auction in seconds.\r\n  // @param seller - the seller of the token.\r\n  function _addAuction(\r\n    uint tokenId_,\r\n    uint startingPrice_,\r\n    uint endingPrice_,\r\n    uint duration_,\r\n    address seller_\r\n  )\r\n    internal\r\n  {\r\n    require(duration_ == uint(uint48(duration_)), \"add auction: duration must be a uint48\");\r\n    require(startingPrice_ == uint(uint128(startingPrice_)), \"add auction: start price must be a uint128\");\r\n    require(endingPrice_ == uint(uint128(endingPrice_)), \"add auction: end price must be a uint128\");\r\n    require(startingPrice_ > 0, \"starting price must be non-zero\");\r\n    require(endingPrice_ > 0, \"ending price must be non-zero\");\r\n    // Require that all auctions have a duration of\r\n    // at least one minute. (Keeps our math from getting hairy!)\r\n    require(duration_ >= 1 minutes, \"auctions must be 1 minute long or more\");\r\n\r\n    uint auctionMetadata = uint(seller_)|duration_<<160|uint(uint48(block.timestamp))<<208;\r\n    uint auctionPrices = endingPrice_|startingPrice_<<128;\r\n    auctionIdToMetadata[tokenId_] = auctionMetadata;\r\n    auctionIdToPrices[tokenId_] = auctionPrices;\r\n\r\n    emit AuctionCreated(\r\n      seller_,\r\n      uint(tokenId_),\r\n      uint(startingPrice_),\r\n      uint(endingPrice_),\r\n      uint(block.timestamp),\r\n      uint(duration_)\r\n    );\r\n  }\r\n\r\n  // @dev Cancels an auction unconditionally.\r\n  // @param tokenId_ The Id of the token to cancelled.\r\n  // @param seller_ - the seller of the token.\r\n  function _cancelAuction(uint tokenId_, address seller_)\r\n    internal\r\n  {\r\n    _removeAuction(tokenId_);\r\n    erc721Contract.auctionTransfer(address(this), seller_, tokenId_);\r\n    emit AuctionCancelled(seller_, tokenId_);\r\n  }\r\n\r\n  // @dev Retrieves the auction details for the requested auction\r\n  // @param tokenId_ The Id of the token to be bid on.\r\n  function _getAuction(uint tokenId_)\r\n    internal\r\n    view\r\n    returns\r\n  (\r\n    address seller,\r\n    uint startingPrice,\r\n    uint endingPrice,\r\n    uint duration,\r\n    uint startedAt\r\n  )\r\n  {\r\n    uint auctionMetadata = auctionIdToMetadata[tokenId_];\r\n    uint auctionPrices = auctionIdToPrices[tokenId_];\r\n    seller = address(auctionMetadata);\r\n    duration = uint(uint48(auctionMetadata>>160));\r\n    startedAt = uint(uint48(auctionMetadata>>208));\r\n    startingPrice = uint(uint128(auctionPrices>>128));\r\n    endingPrice = uint(uint128(auctionPrices));\r\n  }\r\n\r\n  // @dev Removes an auction from the list of open auctions.\r\n  // @param tokenId_ - Id of NFT on auction.\r\n  function _removeAuction(uint tokenId_)\r\n    internal\r\n  {\r\n    delete auctionIdToMetadata[tokenId_];\r\n    delete auctionIdToPrices[tokenId_];\r\n  }\r\n\r\n  // @dev Returns true if the NFT is on auction.\r\n  // @param startedAt - the start time of the Auction to check.\r\n  function _isOnAuction(uint startedAt_)\r\n    internal\r\n    pure\r\n  returns (bool) {\r\n    return (startedAt_ > 0);\r\n  }\r\n\r\n  // @dev Returns current price of an NFT on auction. Broken into two\r\n  //  functions (this one, that computes the duration from the auction\r\n  //  structure, and the other that does the price computation) so we\r\n  //  can easily test that the price computation works correctly.\r\n  function _auctionCurrentPrice(uint startingPrice_, uint endingPrice_, uint duration_, uint startedAt_)\r\n    internal\r\n    view\r\n    returns (uint)\r\n  {\r\n    require(_isOnAuction(startedAt_), \"must be on auction\");\r\n    uint secondsPassed = 0;\r\n\r\n    // A bit of insurance against negative values (or wraparound).\r\n    // Probably not necessary (since Ethereum guarnatees that the\r\n    // now variable doesn't ever go backwards).\r\n    if (block.timestamp > startedAt_) {\r\n      secondsPassed = block.timestamp.sub(startedAt_);\r\n    }\r\n\r\n    return _computeAuctionCurrentPrice(\r\n      startingPrice_,\r\n      endingPrice_,\r\n      duration_,\r\n      secondsPassed\r\n    );\r\n  }\r\n\r\n  // @dev Computes the current price of an auction. Factored out\r\n  //  from _currentPrice so we can run extensive unit tests.\r\n  //  When testing, make this function public and turn on\r\n  //  `Current price computation` test suite.\r\n  function _computeAuctionCurrentPrice(\r\n    uint startingPrice_,\r\n    uint endingPrice_,\r\n    uint duration_,\r\n    uint secondsPassed_\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n  {\r\n    // NOTE: We don't use SafeMath (or similar) in this function because\r\n    //  all of our public functions cap the maximum values for\r\n    //  time (at 48-bits) and currency (at 128-bits). duration_ is\r\n    //  also known to be non-zero (see the require() statement in\r\n    //  _addAuction())\r\n    if (secondsPassed_ >= duration_) {\r\n      // We've reached the end of the dynamic pricing portion\r\n      // of the auction, just return the end price.\r\n      return endingPrice_;\r\n    } else {\r\n      // Starting price can be higher than ending price (and often is!), so\r\n      // this delta can be negative.\r\n      int256 totalPriceChange = int256(endingPrice_) - int256(startingPrice_);\r\n\r\n      // This multiplication can't overflow, secondsPassed_ will easily fit within\r\n      // 48-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n      // will always fit within 256-bits.\r\n      int256 currentPriceChange = totalPriceChange * int256(secondsPassed_) / int256(duration_);\r\n\r\n      // currentPriceChange can be negative, but if so, will have a magnitude\r\n      // less that startingPrice_. Thus, this result will always end up positive.\r\n      int256 currentPrice = int256(startingPrice_) + currentPriceChange;\r\n\r\n      return uint(currentPrice);\r\n    }\r\n  }\r\n\r\n  function _payForAuction(uint game_, uint price_, address auctionSite_, address seller_, address buyer_)\r\n    internal\r\n  {\r\n    uint totalFee = price_.mul(totalFeePoints).div(10000);\r\n    uint level = getGameStakeLevel(game_);\r\n    uint auctioneerFee = auctionSite_ == address(0) ? 0 : price_.mul(auctionSitePoints).div(10000);\r\n    uint gameFee = price_.mul(level).mul(gameLevelPoints).div(10000);\r\n    uint systemFee = totalFee.sub(auctioneerFee).sub(gameFee);\r\n\r\n    // Transfer payment to the seller, then from the seller to the fee takers.\r\n    _transfer(buyer_, seller_, price_);\r\n    _transfer(seller_, address(this), systemFee);\r\n    _transfer(seller_, game_ == 0 ? address(this) : address(game_), gameFee);\r\n    if(auctioneerFee > 0) {\r\n      _transfer(seller_, auctionSite_, auctioneerFee);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n// @title ERC-721 Non-Fungible Token Standard\r\n// @dev Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n//  Note: the ERC-165 identifier for this interface is 0x80ac58cd\r\n\r\ninterface iERC721 {\r\n\r\n  // @notice Count all NFTs assigned to an owner\r\n  // @dev NFTs assigned to the zero address are considered invalid, and this\r\n  //  function throws for queries about the zero address.\r\n  // @param owner_ An address for whom to query the balance\r\n  // @return The number of NFTs owned by `owner_`, possibly zero\r\n  function balanceOf(address owner_) external view returns (uint);\r\n\r\n  // @notice Find the owner of an NFT\r\n  // @param tokenId_ The identifier for an NFT\r\n  // @dev NFTs assigned to zero address are considered invalid, and queries\r\n  //  about them do throw.\r\n  // @return The address of the owner of the NFT\r\n  function ownerOf(uint tokenId_) external view returns (address);\r\n\r\n  // @notice Transfers the ownership of an NFT from one address to another address\r\n  // @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  //  operator, or the approved address for this NFT. Throws if `from_` is\r\n  //  not the current owner. Throws if `to_` is the zero address. Throws if\r\n  //  `tokenId_` is not a valid NFT. When transfer is complete, this function\r\n  //  checks if `to_` is a smart contract (code size > 0). If so, it calls\r\n  //  `onERC721Received` on `to_` and throws if the return value is not\r\n  //  `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\r\n  // @param from_ The current owner of the NFT\r\n  // @param to_ The new owner\r\n  // @param tokenId_ The NFT to transfer\r\n  // @param data Additional data with no specified format, sent in call to `to_`\r\n  function safeTransferFrom(address from_, address to_, uint tokenId_, bytes calldata data_) external;\r\n\r\n  // @notice Transfers the ownership of an NFT from one address to another address\r\n  // @dev This works identically to the other function with an extra data parameter,\r\n  //  except this function just sets data to \"\"\r\n  // @param from_ The current owner of the NFT\r\n  // @param to_ The new owner\r\n  // @param tokenId_ The NFT to transfer\r\n  function safeTransferFrom(address from_, address to_, uint tokenId_) external;\r\n\r\n  // @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n  //  TO CONFIRM THAT `to_` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n  //  THEY MAY BE PERMANENTLY LOST\r\n  // @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  //  operator, or the approved address for this NFT. Throws if `from_` is\r\n  //  not the current owner. Throws if `to_` is the zero address. Throws if\r\n  //  `tokenId_` is not a valid NFT.\r\n  // @param from_ The current owner of the NFT\r\n  // @param to_ The new owner\r\n  // @param tokenId_ The NFT to transfer\r\n  function transferFrom(address from_, address to_, uint tokenId_) external;\r\n\r\n  // @notice Set or reaffirm the approved address for an NFT\r\n  // @dev The zero address indicates there is no approved address.\r\n  // @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n  //  operator of the current owner.\r\n  // @param approved_ The new approved NFT controller\r\n  // @param tokenId_ The NFT to approve\r\n  function approve(address approved_, uint tokenId_) external;\r\n\r\n  // @notice Enable or disable approval for a third party (\"operator\") to manage\r\n  //  all your assets.\r\n  // @dev Throws unless `msg.sender` is the current NFT owner.\r\n  // @dev Emits the ApprovalForAll event\r\n  // @param operator_ Address to add to the set of authorized operators.\r\n  // @param approved_ True if the operators is approved, false to revoke approval\r\n  function setApprovalForAll(address operator_, bool approved_) external;\r\n\r\n  // @notice Get the approved address for a single NFT\r\n  // @dev Throws if `tokenId_` is not a valid NFT\r\n  // @param tokenId_ The NFT to find the approved address for\r\n  // @return The approved address for this NFT, or the zero address if there is none\r\n  function getApproved(uint tokenId_) external view returns (address);\r\n\r\n  // @notice Query if an address is an authorized operator for another address\r\n  // @param owner_ The address that owns the NFTs\r\n  // @param operator_ The address that acts on behalf of the owner\r\n  // @return True if `operator_` is an approved operator for `owner_`, false otherwise\r\n  function isApprovedForAll(address owner_, address operator_) external view returns (bool);\r\n}\r\n\r\n\r\n// @title AuctionContract\r\n// @dev Clock auction designed for sale of tokens\r\n// @author GAME Credits (gamecredits.org)\r\n// (c) 2020 GAME Credits All Rights Reserved. This code is not open source.\r\n\r\nabstract contract AuctionExternal is AuctionBase {\r\n\r\n  // @dev Returns auction info for an NFT on auction.\r\n  // @param tokenId_ - Id of NFT on auction.\r\n  function getExistingAuction(uint tokenId_)\r\n    external\r\n    view\r\n    returns\r\n  (\r\n    address seller,\r\n    uint startingPrice,\r\n    uint endingPrice,\r\n    uint duration,\r\n    uint startedAt\r\n  )\r\n  {\r\n    (seller, startingPrice, endingPrice, duration, startedAt) = _getAuction(tokenId_);\r\n\r\n    require(_isOnAuction(startedAt), \"must be on auction\");\r\n  }\r\n\r\n  // @dev Returns the current price of an auction.\r\n  // @param tokenId_ - Id of the token price we are checking.\r\n  function getAuctionCurrentPrice(uint tokenId_)\r\n    external\r\n    view\r\n  returns (uint) {\r\n    address seller;\r\n    uint startingPrice;\r\n    uint endingPrice;\r\n    uint duration;\r\n    uint startedAt;\r\n    (seller, startingPrice, endingPrice, duration, startedAt) = _getAuction(tokenId_);\r\n    return _auctionCurrentPrice(startingPrice, endingPrice, duration, startedAt);\r\n  }\r\n\r\n  // @dev Put a token up for auction. Does some ownership trickery to create auctions in one tx.\r\n  //   Also fires the AuctionCreated event.\r\n  // @param tokenId_ The Id of the token to be put on auction.\r\n  // @param startingPrice_ - the start price of the Auction to add.\r\n  // @param endingPrice_ - the end price of the Auction to add.\r\n  // @param duration_ - the length of the Auction in seconds.\r\n  function createAuction(\r\n    uint tokenId_,\r\n    uint startingPrice_,\r\n    uint endingPrice_,\r\n    uint duration_\r\n  )\r\n    external\r\n  {\r\n    // Sanity check that no inputs overflow how many bits we've allocated\r\n    // to store them in the auction struct.\r\n    require(startingPrice_ == uint(uint128(startingPrice_)), \"starting price under/overflow\");\r\n    require(endingPrice_ == uint(uint128(endingPrice_)), \"ending price under/overflow\");\r\n    require(duration_ == uint(uint48(duration_)), \"duration under/overflow\");\r\n\r\n    // Our auctions are only Dutch or fixed price.\r\n    require(startingPrice_ >= endingPrice_, \"starting price must be >= ending price\");\r\n\r\n    // Auctions can be no more than 7 days, and no less than 10 minutes\r\n    require(duration_ <= 7 days, \"duration must be <= 7 days\");\r\n    require(duration_ >= 10 minutes, \"duration must be >= 10 minutes\");\r\n\r\n    address sender = _msgSender();\r\n    // This checks \"can transfer\"\r\n    erc721Contract.auctionTransfer(sender, address(this), tokenId_);\r\n    // Auction throws if inputs are invalid and clears transfer of the token.\r\n\r\n    _addAuction(tokenId_, startingPrice_, endingPrice_, duration_, sender);\r\n  }\r\n\r\n  // @dev Bids on an open auction, completing the auction and transferring\r\n  //  ownership of the NFT if enough Ether is supplied.\r\n  // @param tokenId_ - Id of token to bid on.\r\n  // @param bidAmount_ - The amount of the bid (for safety, to ensure people don't pay too much)\r\n  // @param auctioneer_ - The account that will receive 1% of the auction proceeds\r\n  //   Usually, an exchange website will put its own address in as auctioneer_, so it can\r\n  //   earn revenue for the public-facing portion of sales.\r\n  function bidOnAuction(uint tokenId_, uint bidAmount_, address auctioneer_)\r\n    external\r\n  {\r\n    address seller;\r\n    uint startingPrice;\r\n    uint endingPrice;\r\n    uint duration;\r\n    uint startedAt;\r\n    (seller, startingPrice, endingPrice, duration, startedAt) = _getAuction(tokenId_);\r\n\r\n    // This contract must own the on sale token\r\n    require(iERC721(address(erc721Contract)).ownerOf(tokenId_) == address(this), \"contract must own on-sale token\");\r\n\r\n    // Explicitly check that this auction is currently live.\r\n    require(_isOnAuction(startedAt), \"auction must be live\");\r\n\r\n    // Check that the bid is greater than or equal to the current price\r\n    uint price = _auctionCurrentPrice(startingPrice, endingPrice, duration, startedAt);\r\n    require(bidAmount_ >= price, \"bid must be greater than or equal to price\");\r\n\r\n    // The bid is good! Remove the auction before sending the fees\r\n    // so we can't have a reentrancy attack.\r\n    _removeAuction(tokenId_);\r\n\r\n    uint game = uint256(uint64(tokenId_));\r\n    address sender = _msgSender();\r\n\r\n    // Transfer the payment from the buyer to the seller, and the fees to the game, system, and auctioneer\r\n    _payForAuction(game, price, auctioneer_, seller, sender);\r\n\r\n    // Tell the world!\r\n    emit AuctionSuccessful(seller, sender, tokenId_, price);\r\n\r\n    // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n    erc721Contract.auctionTransfer(address(this), sender, tokenId_);\r\n  }\r\n\r\n  // @dev Cancels an auction that hasn't been won yet.\r\n  //  Returns the NFT to original owner.\r\n  // @param tokenId_ - Id of token on auction\r\n  function cancelAuction(uint tokenId_)\r\n    external\r\n  {\r\n    uint auctionMetadata = auctionIdToMetadata[tokenId_];\r\n    address seller = address(auctionMetadata);\r\n    uint startedAt = uint(uint48(auctionMetadata>>208));\r\n\r\n    require(_isOnAuction(startedAt), \"token must be on auction\");\r\n    require(_msgSender() == seller, \"token seller must be sender\");\r\n    _cancelAuction(tokenId_, seller);\r\n  }\r\n\r\n  // @dev Cancels an auction.\r\n  //  Only the manager may do this, and NFTs are returned to\r\n  //  the seller. This should only be used in emergencies.\r\n  // @param tokenId_ - Id of the NFT on auction to cancel.\r\n  function cancelAuctionByManager(uint tokenId_)\r\n    external\r\n    override\r\n    onlyLocalContract\r\n  {\r\n    uint auctionMetadata = auctionIdToMetadata[tokenId_];\r\n    address seller = address(auctionMetadata);\r\n    uint startedAt = uint(uint48(auctionMetadata>>208));\r\n    require(_isOnAuction(startedAt), \"token must be on auction\");\r\n    _cancelAuction(tokenId_, seller);\r\n  }\r\n}\r\n\r\n\r\n// @title GAME Credits ERC20 contract\r\n// @dev ERC20 management contract, designed to make using ERC-20 tokens easier\r\n// @author GAME Credits (gamecredits.org)\r\n// (c) 2020 GAME Credits All Rights Reserved. This code is not open source.\r\n\r\ncontract GAME_ERC20 is AuctionExternal {\r\n  using SafeMath for uint256;\r\n\r\n  string constant public CONTRACT_ERC712_VERSION = \"1\";\r\n  string constant public CONTRACT_ERC712_NAME = \"GAME Credits Sidechain ERC20 Contract\";\r\n\r\n  // @dev Constructor creates a reference to the master contract\r\n  //  and the ERC20 depositor contract.\r\n  // @param masterContract_ - address of the master contract\r\n  // @param depositor_ - address of the erc20 depositor contract\r\n  // @param rootChainId_ - ID of the chain the contract is deployed on\r\n  constructor(address masterContract_, address depositor_)\r\n    GAME_ERC20Access(masterContract_)\r\n    ChildERC20(\"GAME Credits\", \"GAME\", 18, depositor_)\r\n    NetworkAgnostic(CONTRACT_ERC712_NAME, CONTRACT_ERC712_VERSION)\r\n  {\r\n  }\r\n\r\n  // @dev Withdraws the whole balance of a game to an admin account.\r\n  // @param uint game_ The game Id of the game for which sender is an admin\r\n  function withdrawGameBalance(uint game_)\r\n    external\r\n    onlyGameAdmin(game_)\r\n  {\r\n    require(game_ > 0, \"can't withdraw from the zero address\");\r\n    _transfer(address(game_), _msgSender(), _balances[address(game_)]);\r\n  }\r\n\r\n  // @dev Withdraws the whole balance of the system to an admin account.\r\n  // @param uint game_ The game Id of the game for which sender is an admin\r\n  function withdrawSystemBalance()\r\n    external\r\n    onlyCFO\r\n  {\r\n    _transfer(address(this), _msgSender(), _balances[address(this)]);\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"masterContract_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"depositor_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPrice\",\"type\":\"uint256\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Balance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"game\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"week\",\"type\":\"uint256\"}],\"name\":\"LoyaltyPartnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"game\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"week\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalGranted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSpent\",\"type\":\"uint256\"}],\"name\":\"LoyaltyPointsChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"game\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pointsGrant\",\"type\":\"uint256\"}],\"name\":\"LoyaltyPointsGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"game\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pointsRemoved\",\"type\":\"uint256\"}],\"name\":\"LoyaltyPointsRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"}],\"name\":\"OracleTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spenderContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSpender\",\"type\":\"bool\"}],\"name\":\"ThirdPartyRewwardsSpender\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTRACT_ERC712_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONTRACT_ERC712_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_WEEK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WEEK_ZERO_START\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSpender_\",\"type\":\"bool\"}],\"name\":\"approveThirdPartyLoyaltySpender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedLoyaltySpenders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionIdToMetadata\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionIdToPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionSitePoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"auctioneer_\",\"type\":\"address\"}],\"name\":\"bidOnAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionByManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration_\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"depositData\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"encodeDomainSeperator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"encodeWorkerDomainSeperator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc721Contract\",\"outputs\":[{\"internalType\":\"contract iGAME_ERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameAccountLoyaltyPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameAccountPointsSpent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameAccountStakeWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameAccountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameContract\",\"outputs\":[{\"internalType\":\"contract iGAME_Game\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameLevelPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameStakeLevelCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gcPerLoyaltyPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getAuctionCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDomainSeperator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getExistingAuction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"game_\",\"type\":\"uint256\"}],\"name\":\"getGameBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"game_\",\"type\":\"uint256\"}],\"name\":\"getGameStakeLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"game_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"getLoyaltyPointSpends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSpend\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"game_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"getLoyaltyPointsGranted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentPoints\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"game_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"getLoyaltyPointsTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalRemaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWorkerDomainSeperator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLocalContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameContract_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc721Contract_\",\"type\":\"address\"}],\"name\":\"linkContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"localContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"loyaltyPartners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"loyaltyWeeks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterContract\",\"outputs\":[{\"internalType\":\"contract iGAME_Master\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"txHash_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"week_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"game_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newStake_\",\"type\":\"uint256\"}],\"name\":\"oracleUpdateStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"partnerId_\",\"type\":\"uint256\"}],\"name\":\"selectLoyaltyPartner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"points_\",\"type\":\"uint256\"}],\"name\":\"setAuctionSitePoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor_\",\"type\":\"address\"}],\"name\":\"setDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"points_\",\"type\":\"uint256\"}],\"name\":\"setGameLevelPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[7]\",\"name\":\"caps_\",\"type\":\"uint256[7]\"}],\"name\":\"setGameStakeLevelCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"game_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pointsToSpend_\",\"type\":\"uint256\"}],\"name\":\"thirdPartySpendLoyaltyPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFeePoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"}],\"name\":\"transferByContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLocal_\",\"type\":\"bool\"}],\"name\":\"updateLocalContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"updateStakesOracleHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"game_\",\"type\":\"uint256\"}],\"name\":\"withdrawGameBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawSystemBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"replayPrevention_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature_\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS_\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV_\",\"type\":\"uint8\"}],\"name\":\"workerExecuteMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"game_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pointsGrant_\",\"type\":\"uint256\"}],\"name\":\"workerGrantLoyaltyPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"game_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pointsToRemove_\",\"type\":\"uint256\"}],\"name\":\"workerRemoveLoyaltyPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"partnerId_\",\"type\":\"uint256\"}],\"name\":\"workerSelectLoyaltyPartner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"game_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pointsToSpend_\",\"type\":\"uint256\"}],\"name\":\"workerSpendLoyaltyPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GAME_ERC20", "CompilerVersion": "v0.7.0+commit.9e61f92b", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002550aa5c84edb92a66125a85527c151923be35e1000000000000000000000000a6fa4fb5f76172d178d61b04b0ecd319c5d1c0aa", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}