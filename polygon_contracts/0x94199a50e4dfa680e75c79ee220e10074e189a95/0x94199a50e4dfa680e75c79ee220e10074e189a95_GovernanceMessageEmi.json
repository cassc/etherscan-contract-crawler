{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@pnetwork-association/dao-v2-contracts/contracts/interfaces/IEpochsManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title IEpochsManager\\n * @author pNetwork\\n *\\n * @notice\\n */\\ninterface IEpochsManager {\\n    /*\\n     * @notice Returns the current epoch number.\\n     *\\n     * @return uint16 representing the current epoch.\\n     */\\n    function currentEpoch() external view returns (uint16);\\n\\n    /*\\n     * @notice Returns the epoch duration.\\n     *\\n     * @return uint256 representing the epoch duration.\\n     */\\n    function epochDuration() external view returns (uint256);\\n\\n    /*\\n     * @notice Returns the timestamp at which the first epoch is started\\n     *\\n     * @return uint256 representing the timestamp at which the first epoch is started.\\n     */\\n    function startFirstEpochTimestamp() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@pnetwork-association/dao-v2-contracts/contracts/interfaces/ILendingManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title ILendingManager\\n * @author pNetwork\\n *\\n * @notice\\n */\\ninterface ILendingManager {\\n    /**\\n     * @dev Emitted when an user increases his lend position by increasing his lock time within the Staking Manager.\\n     *\\n     * @param lender The lender\\n     * @param endEpoch The new end epoch\\n     */\\n    event DurationIncreased(address indexed lender, uint16 endEpoch);\\n\\n    /**\\n     * @dev Emitted when the lended amount for a certain epoch increase.\\n     *\\n     * @param lender The lender\\n     * @param startEpoch The start epoch\\n     * @param endEpoch The end epoch\\n     * @param amount The amount\\n     */\\n    event Lended(address indexed lender, uint256 indexed startEpoch, uint256 indexed endEpoch, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when a borrower borrows a certain amount of tokens for a number of epochs.\\n     *\\n     * @param borrower The borrower address\\n     * @param epoch The epoch\\n     * @param amount The amount\\n     */\\n    event Borrowed(address indexed borrower, uint256 indexed epoch, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when an reward is claimed\\n     *\\n     * @param lender The lender address\\n     * @param asset The claimed asset address\\n     * @param epoch The epoch\\n     * @param amount The amount\\n     */\\n    event RewardClaimed(address indexed lender, address indexed asset, uint256 indexed epoch, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when an reward is lended\\n     *\\n     * @param asset The asset\\n     * @param epoch The current epoch\\n     * @param amount The amount\\n     */\\n    event RewardDeposited(address indexed asset, uint256 indexed epoch, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when a borrower borrow is released.\\n     *\\n     * @param borrower The borrower address\\n     * @param epoch The current epoch\\n     * @param amount The amount\\n     */\\n    event Released(address indexed borrower, uint256 indexed epoch, uint256 amount);\\n\\n    /*\\n     * @notice Borrow a certain amount of tokens in a given epoch\\n     *\\n     * @param amount\\n     * @param epoch\\n     * @param borrower\\n     *\\n     */\\n    function borrow(uint256 amount, uint16 epoch, address borrower) external;\\n\\n    /*\\n     * @notice Returns the borrowable amount for the given epoch\\n     *\\n     * @param epoch\\n     *\\n     * @return uint24 an integer representing the borrowable amount for the given epoch.\\n     */\\n    function borrowableAmountByEpoch(uint16 epoch) external view returns (uint24);\\n\\n    /*\\n     * @notice Returns the borrowed amount of a given user in a given epoch\\n     *\\n     * @param borrower\\n     * @param epoch\\n     *\\n     * @return uint24 an integer representing the borrowed amount of a given user in a given epoch.\\n     */\\n    function borrowedAmountByEpochOf(address borrower, uint16 epoch) external view returns (uint24);\\n\\n    /*\\n     * @notice Returns the lender's claimable amount for a given asset in a specifich epoch.\\n     *\\n     * @param lender\\n     * @param asset\\n     * @param epoch\\n     *\\n     * @return uint256 an integer representing the lender's claimable value for a given asset in a specifich epoch..\\n     */\\n    function claimableRewardsByEpochOf(address lender, address asset, uint16 epoch) external view returns (uint256);\\n\\n    /*\\n     * @notice Returns the lender's claimable amount for a set of assets in an epochs range\\n     *\\n     * @param lender\\n     * @param assets\\n     * @param startEpoch\\n     * @param endEpoch\\n     *\\n     * @return uint256 an integer representing the lender's claimable amount for a set of assets in an epochs range.\\n     */\\n    function claimableAssetsAmountByEpochsRangeOf(\\n        address lender,\\n        address[] calldata assets,\\n        uint16 startEpoch,\\n        uint16 endEpoch\\n    ) external view returns (uint256[] memory);\\n\\n    /*\\n     * @notice Claim the rewards earned by the lender for a given epoch for a given asset.\\n     *\\n     * @param asset\\n     * @param epoch\\n     *\\n     */\\n    function claimRewardByEpoch(address asset, uint16 epoch) external;\\n\\n    /*\\n     * @notice Claim the reward earned by the lender in an epochs range for a given asset.\\n     *\\n     * @param asset\\n     * @param startEpoch\\n     * @param endEpoch\\n     *\\n     */\\n    function claimRewardByEpochsRange(address asset, uint16 startEpoch, uint16 endEpoch) external;\\n\\n    /*\\n     * @notice Deposit an reward amount of an asset in a given epoch.\\n     *\\n     * @param amount\\n     * @param asset\\n     * @param epoch\\n     *\\n     */\\n    function depositReward(address asset, uint16 epoch, uint256 amount) external;\\n\\n    /*\\n     * @notice Returns the number of votes and the number of voted votes by a lender. This function is needed\\n     *         in order to allow the lender to be able to claim the rewards only if he voted to all votes\\n     *         within an epoch\\n     *\\n     * @param lender\\n     * @param epoch\\n     *\\n     * @return (uint256,uint256) representing the total number of votes within an epoch an the number of voted votes by a lender.\\n     */\\n    function getLenderVotingStateByEpoch(address lender, uint16 epoch) external returns (uint256, uint256);\\n\\n    /*\\n     * @notice Increase the duration of a lending position by increasing the lock time of the staked tokens.\\n     *\\n     * @param duration\\n     *\\n     */\\n    function increaseDuration(uint64 duration) external;\\n\\n    /*\\n     * @notice Increase the duration of a lending position by increasing the lock time of the staked tokens.\\n     *         This function is used togheter with onlyForwarder in order to enable cross chain duration increasing\\n     *\\n     * @param duration\\n     *\\n     */\\n    function increaseDuration(address lender, uint64 duration) external;\\n\\n    /*\\n     * @notice Lend in behalf of lender a certain amount of tokens locked for a given period of time. The lended\\n     * tokens are forwarded within the StakingManager. This fx is just a proxy fx to the StakingManager.stake that counts\\n     * how many tokens can be borrowed.\\n     *\\n     * @param lender\\n     * @param amount\\n     * @param duration\\n     *\\n     */\\n    function lend(address lender, uint256 amount, uint64 duration) external;\\n\\n    /*\\n     * @notice Returns the borrowed amount for a given epoch.\\n     *\\n     * @param epoch\\n     *\\n     * @return uint24 representing an integer representing the borrowed amount for a given epoch.\\n     */\\n    function totalBorrowedAmountByEpoch(uint16 epoch) external view returns (uint24);\\n\\n    /*\\n     * @notice Returns the borrowed amount in an epochs range.\\n     *\\n     * @param startEpoch\\n     * @param endEpoch\\n     *\\n     * @return uint24[] representing an integer representing the borrowed amount in an epochs range.\\n     */\\n    function totalBorrowedAmountByEpochsRange(\\n        uint16 startEpoch,\\n        uint16 endEpoch\\n    ) external view returns (uint24[] memory);\\n\\n    /*\\n     * @notice Returns the lended amount for a given epoch.\\n     *\\n     * @param epoch\\n     *\\n     * @return uint256 an integer representing the lended amount for a given epoch.\\n     */\\n    function totalLendedAmountByEpoch(uint16 epoch) external view returns (uint24);\\n\\n    /*\\n     * @notice Returns the maximum lended amount for the selected epochs.\\n     *\\n     * @param startEpoch\\n     * @param endEpoch\\n     *\\n     * @return uint24[] representing an array of integers representing the maximum lended amount for a given epoch.\\n     */\\n    function totalLendedAmountByEpochsRange(uint16 startEpoch, uint16 endEpoch) external view returns (uint24[] memory);\\n\\n    /*\\n     * @notice Delete the borrower for a given epoch.\\n     * In order to call it the sender must have the RELEASE_ROLE role.\\n     *\\n     * @param borrower\\n     * @param epoch\\n     * @param amount\\n     *\\n     */\\n    function release(address borrower, uint16 epoch, uint256 amount) external;\\n\\n    /*\\n     * @notice Returns the current total asset reward amount by epoch\\n     *\\n     * @param asset\\n     * @param epoch\\n     *\\n     * @return (uint256,uint256) representing the total asset reward amount by epoch.\\n     */\\n    function totalAssetRewardAmountByEpoch(address asset, uint16 epoch) external view returns (uint256);\\n\\n    /*\\n     * @notice Returns the current total weight for a given epoch. The total weight is the sum of the user weights in a specific epoch.\\n     *\\n     * @param asset\\n     * @param epoch\\n     *\\n     * @return uint32 representing the current total weight for a given epoch.\\n     */\\n    function totalWeightByEpoch(uint16 epoch) external view returns (uint32);\\n\\n    /*\\n     * @notice Returns the current total weight for a given epochs range. The total weight is the sum of the user weights in a specific epochs range.\\n     *\\n     * @param asset\\n     * @param epoch\\n     *\\n     * @return uint32 representing the current total weight for a given epochs range.\\n     */\\n    function totalWeightByEpochsRange(uint16 startEpoch, uint16 endEpoch) external view returns (uint32[] memory);\\n\\n    /*\\n     * @notice Returns the utilization rate (percentage of borrowed tokens compared to the lended ones) in the given epoch\\n     *\\n     * @param epoch\\n     *\\n     * @return uint24 an integer representing the utilization rate in a given epoch.\\n     */\\n    function utilizationRatioByEpoch(uint16 epoch) external view returns (uint24);\\n\\n    /*\\n     * @notice Returns the utilization rate (percentage of borrowed tokens compared to the lended ones) given the start end the end epoch\\n     *\\n     * @param startEpoch\\n     * @param endEpoch\\n     *\\n     * @return uint24 an integer representing the utilization rate in a given the start end the end epoch.\\n     */\\n    function utilizationRatioByEpochsRange(uint16 startEpoch, uint16 endEpoch) external view returns (uint24[] memory);\\n\\n    /*\\n     * @notice Returns the user weight in a given epoch. The user weight is calculated with\\n     * the following formula: lendedAmount * numberOfEpochsLeft in a given epoch\\n     *\\n     * @param lender\\n     * @param epoch\\n     *\\n     * @return uint32 an integer representing the user weight in a given epoch.\\n     */\\n    function weightByEpochOf(address lender, uint16 epoch) external view returns (uint32);\\n\\n    /*\\n     * @notice Returns the user weights in an epochs range. The user weight is calculated with\\n     * the following formula: lendedAmount * numberOfEpochsLeft in a given epoch\\n     *\\n     * @param lender\\n     * @param epoch\\n     *\\n     * @return uint32[] an integer representing the user weights in an epochs range.\\n     */\\n    function weightByEpochsRangeOf(\\n        address lender,\\n        uint16 startEpoch,\\n        uint16 endEpoch\\n    ) external view returns (uint32[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/core/IRegistrationManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title IRegistrationManager\\n * @author pNetwork\\n *\\n * @notice\\n */\\ninterface IRegistrationManager {\\n    struct Registration {\\n        address owner;\\n        uint16 startEpoch;\\n        uint16 endEpoch;\\n        bytes1 kind;\\n    }\\n\\n    /**\\n     * @dev Emitted when a borrowing sentinel is slashed.\\n     *\\n     * @param sentinel The sentinel\\n     */\\n    event BorrowingSentinelSlashed(address indexed sentinel);\\n\\n    /**\\n     * @dev Emitted when an user increases his staking sentinel registration position by increasing his lock time within the Staking Manager.\\n     *\\n     * @param sentinel The sentinel\\n     * @param endEpoch The new end epoch\\n     */\\n    event DurationIncreased(address indexed sentinel, uint16 endEpoch);\\n\\n    /**\\n     * @dev Emitted when a guardian is slashed.\\n     *\\n     * @param guardian The guardian\\n     */\\n    event GuardianSlashed(address indexed guardian);\\n\\n    /**\\n     * @dev Emitted when a guardian is registered.\\n     *\\n     * @param owner The sentinel owner\\n     * @param startEpoch The epoch in which the registration starts\\n     * @param endEpoch The epoch at which the registration ends\\n     * @param guardian The sentinel address\\n     * @param kind The type of registration\\n     */\\n    event GuardianRegistrationUpdated(\\n        address indexed owner,\\n        uint16 indexed startEpoch,\\n        uint16 indexed endEpoch,\\n        address guardian,\\n        bytes1 kind\\n    );\\n\\n    /**\\n     * @dev Emitted when a actor is light-resumed.\\n     *\\n     * @param actor The actor\\n     */\\n    event LightResumed(address indexed actor, bytes1 registrationKind);\\n\\n    /**\\n     * @dev Emitted when a sentinel registration is completed.\\n     *\\n     * @param owner The sentinel owner\\n     * @param startEpoch The epoch in which the registration starts\\n     * @param endEpoch The epoch at which the registration ends\\n     * @param sentinel The sentinel address\\n     * @param kind The type of registration\\n     * @param amount The amount used to register a sentinel\\n     */\\n    event SentinelRegistrationUpdated(\\n        address indexed owner,\\n        uint16 indexed startEpoch,\\n        uint16 indexed endEpoch,\\n        address sentinel,\\n        bytes1 kind,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted when a sentinel is hard-resumed.\\n     *\\n     * @param sentinel The sentinel\\n     */\\n    event SentinelHardResumed(address indexed sentinel);\\n\\n    /**\\n     * @dev Emitted when a staking sentinel increased its amount at stake.\\n     *\\n     * @param sentinel The sentinel\\n     */\\n    event StakedAmountIncreased(address indexed sentinel, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when a staking sentinel is slashed.\\n     *\\n     * @param sentinel The sentinel\\n     * @param amount The amount\\n     */\\n    event StakingSentinelSlashed(address indexed sentinel, uint256 amount);\\n\\n    /*\\n     * @notice Return the current signature nonce by the actor owner\\n     *\\n     * @param owner\\n     *\\n     */\\n    function getSignatureNonceByOwner(address owner) external view returns (uint256);\\n\\n    /*\\n     * @notice Returns a guardian by its owner.\\n     *\\n     * @param owner\\n     *\\n     * @return the guardian.\\n     */\\n    function guardianOf(address owner) external view returns (address);\\n\\n    /*\\n     * @notice Resume a sentinel that was hard-slashed that means that its amount went below 200k PNT\\n     *         and its address was removed from the merkle tree. In order to be able to hard-resume a\\n     *         sentinel, when the function is called, StakingManager.increaseAmount is also called in\\n     *         order to increase the amount at stake.\\n     *\\n     * @param amount\\n     * @param owner\\n     * @param signature\\n     * @param nonce\\n     *\\n     */\\n    function hardResume(uint256 amount, bytes calldata signature, uint256 nonce) external;\\n\\n    /*\\n     * @notice Increase the duration of a staking sentinel registration.\\n     *\\n     * @param duration\\n     */\\n    function increaseSentinelRegistrationDuration(uint64 duration) external;\\n\\n    /*\\n     * @notice Increase the duration  of a staking sentinel registration. This function is used togheter with\\n     *         onlyForwarder modifier in order to enable cross chain duration increasing\\n     *\\n     * @param owner\\n     * @param duration\\n     */\\n    function increaseSentinelRegistrationDuration(address owner, uint64 duration) external;\\n\\n    /*\\n     * @notice Resume an actor that was light-slashed\\n     *\\n     * @param signature\\n     * @param nonce\\n     *\\n     */\\n    function lightResume(bytes calldata signature, uint256 nonce) external;\\n\\n    /*\\n     * @notice Returns the sentinel of a given owner\\n     *\\n     * @param owner\\n     *\\n     * @return address representing the address of the sentinel.\\n     */\\n    function sentinelOf(address owner) external view returns (address);\\n\\n    /*\\n     * @notice Returns the actor registration\\n     *\\n     * @param actor\\n     *\\n     * @return address representing the actor registration data.\\n     */\\n    function registrationOf(address actor) external view returns (Registration memory);\\n\\n    /*\\n     * @notice Return the staked amount by a sentinel in a given epoch.\\n     *\\n     * @param epoch\\n     *\\n     * @return uint256 representing staked amount by a sentinel in a given epoch.\\n     */\\n    function sentinelStakedAmountByEpochOf(address sentinel, uint16 epoch) external view returns (uint256);\\n\\n    /*\\n     * @notice Return the number of times an actor (sentinel or guardian) has been slashed in an epoch.\\n     *\\n     * @param epoch\\n     * @param actor\\n     *\\n     * @return uint16 representing the number of times an actor has been slashed in an epoch.\\n     */\\n    function slashesByEpochOf(uint16 epoch, address actor) external view returns (uint16);\\n\\n    /*\\n     * @notice Set FeesManager\\n     *\\n     * @param feesManager\\n     *\\n     */\\n    function setFeesManager(address feesManager) external;\\n\\n    /*\\n     * @notice Set GovernanceMessageEmitter\\n     *\\n     * @param feesManager\\n     *\\n     */\\n    function setGovernanceMessageEmitter(address governanceMessageEmitter) external;\\n\\n    /*\\n     * @notice Slash a sentinel or a guardian. This function is callable only by the PNetworkHub\\n     *\\n     * @param actor\\n     * @param amount\\n     * @param challenger\\n     *\\n     */\\n    function slash(address actor, uint256 amount, address challenger) external;\\n\\n    /*\\n     * @notice Return the total number of guardians in a specific epoch.\\n     *\\n     * @param epoch\\n     *\\n     * @return uint256 the total number of guardians in a specific epoch.\\n     */\\n    function totalNumberOfGuardiansByEpoch(uint16 epoch) external view returns (uint16);\\n\\n    /*\\n     * @notice Return the total staked amount by the sentinels in a given epoch.\\n     *\\n     * @param epoch\\n     *\\n     * @return uint256 representing  total staked amount by the sentinels in a given epoch.\\n     */\\n    function totalSentinelStakedAmountByEpoch(uint16 epoch) external view returns (uint256);\\n\\n    /*\\n     * @notice Return the total staked amount by the sentinels in a given epochs range.\\n     *\\n     * @param epoch\\n     *\\n     * @return uint256[] representing  total staked amount by the sentinels in a given epochs range.\\n     */\\n    function totalSentinelStakedAmountByEpochsRange(\\n        uint16 startEpoch,\\n        uint16 endEpoch\\n    ) external view returns (uint256[] memory);\\n\\n    /*\\n     * @notice Update guardians registrations. UPDATE_GUARDIAN_REGISTRATION_ROLE is needed to call this function\\n     *\\n     * @param owners\\n     * @param numbersOfEpochs\\n     * @param guardians\\n     *\\n     */\\n    function updateGuardiansRegistrations(\\n        address[] calldata owners,\\n        uint16[] calldata numbersOfEpochs,\\n        address[] calldata guardians\\n    ) external;\\n\\n    /*\\n     * @notice Update a guardian registration. UPDATE_GUARDIAN_REGISTRATION_ROLE is needed to call this function\\n     *\\n     * @param owners\\n     * @param numbersOfEpochs\\n     * @param guardians\\n     *\\n     */\\n    function updateGuardianRegistration(address owner, uint16 numberOfEpochs, address guardian) external;\\n\\n    /*\\n     * @notice Registers/Renew a sentinel by borrowing the specified amount of tokens for a given number of epochs.\\n     *         This function is used togheter with onlyForwarder.\\n     *\\n     * @params owner\\n     * @param numberOfEpochs\\n     * @param signature\\n     * @param nonce\\n     *\\n     */\\n    function updateSentinelRegistrationByBorrowing(\\n        address owner,\\n        uint16 numberOfEpochs,\\n        bytes calldata signature,\\n        uint256 nonce\\n    ) external;\\n\\n    /*\\n     * @notice Registers/Renew a sentinel by borrowing the specified amount of tokens for a given number of epochs.\\n     *\\n     * @param numberOfEpochs\\n     * @param signature\\n     * @param nonce\\n     *\\n     */\\n    function updateSentinelRegistrationByBorrowing(\\n        uint16 numberOfEpochs,\\n        bytes calldata signature,\\n        uint256 nonce\\n    ) external;\\n\\n    /*\\n     * @notice Registers/Renew a sentinel for a given duration in behalf of owner\\n     *\\n     * @param amount\\n     * @param duration\\n     * @param signature\\n     * @param owner\\n     * @param nonce\\n     *\\n     */\\n    function updateSentinelRegistrationByStaking(\\n        address owner,\\n        uint256 amount,\\n        uint64 duration,\\n        bytes calldata signature,\\n        uint256 nonce\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/GovernanceMessageEmitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {IGovernanceMessageEmitter} from \\\"../interfaces/IGovernanceMessageEmitter.sol\\\";\\nimport {IRegistrationManager} from \\\"../core/IRegistrationManager.sol\\\";\\nimport {ILendingManager} from \\\"@pnetwork-association/dao-v2-contracts/contracts/interfaces/ILendingManager.sol\\\";\\nimport {IEpochsManager} from \\\"@pnetwork-association/dao-v2-contracts/contracts/interfaces/IEpochsManager.sol\\\";\\nimport {IPRegistry} from \\\"../interfaces/IPRegistry.sol\\\";\\nimport {IPNetworkHub} from \\\"../interfaces/IPNetworkHub.sol\\\";\\nimport {MerkleTree} from \\\"../libraries/MerkleTree.sol\\\";\\n\\nerror InvalidAmount(uint256 amount, uint256 expectedAmount);\\nerror InvalidGovernanceMessageVerifier(address governanceMessagerVerifier, address expectedGovernanceMessageVerifier);\\nerror InvalidSentinelRegistration(bytes1 kind);\\nerror NotRegistrationManager(address registrationManager, address expectedRegistrationManager);\\nerror NotDandelionVoting(address dandelionVoting, address expectedDandelionVoting);\\nerror InvalidNumberOfGuardians(uint16 numberOfGuardians, uint16 expectedNumberOfGuardians);\\nerror NetworkNotSupported(bytes4 networkId);\\nerror InvalidRegistrationKind(bytes1 kind);\\n\\ncontract GovernanceMessageEmitter is IGovernanceMessageEmitter {\\n    bytes32 public constant GOVERNANCE_MESSAGE_ACTORS = keccak256(\\\"GOVERNANCE_MESSAGE_ACTORS\\\");\\n    bytes32 public constant GOVERNANCE_MESSAGE_SLASH_ACTOR = keccak256(\\\"GOVERNANCE_MESSAGE_SLASH_ACTOR\\\");\\n    bytes32 public constant GOVERNANCE_MESSAGE_RESUME_ACTOR = keccak256(\\\"GOVERNANCE_MESSAGE_RESUME_ACTOR\\\");\\n    bytes32 public constant GOVERNANCE_MESSAGE_PROTOCOL_GOVERNANCE_CANCEL_OPERATION =\\n        keccak256(\\\"GOVERNANCE_MESSAGE_PROTOCOL_GOVERNANCE_CANCEL_OPERATION\\\");\\n\\n    address public immutable epochsManager;\\n    address public immutable lendingManager;\\n    address public immutable registrationManager;\\n    address public immutable dandelionVoting;\\n    address public immutable registry;\\n\\n    uint256 public totalNumberOfMessages;\\n\\n    modifier onlyRegistrationManager() {\\n        if (msg.sender != registrationManager) {\\n            revert NotRegistrationManager(msg.sender, dandelionVoting);\\n        }\\n\\n        _;\\n    }\\n\\n    modifier onlyDandelionVoting() {\\n        if (msg.sender != dandelionVoting) {\\n            revert NotDandelionVoting(msg.sender, dandelionVoting);\\n        }\\n\\n        _;\\n    }\\n\\n    constructor(\\n        address epochsManager_,\\n        address lendingManager_,\\n        address registrationManager_,\\n        address dandelionVoting_,\\n        address registry_\\n    ) {\\n        registry = registry_;\\n        epochsManager = epochsManager_;\\n        lendingManager = lendingManager_;\\n        dandelionVoting = dandelionVoting_;\\n        registrationManager = registrationManager_;\\n    }\\n\\n    /// @inheritdoc IGovernanceMessageEmitter\\n    function propagateActors(address[] calldata guardians, address[] calldata sentinels) external {\\n        uint16 currentEpoch = IEpochsManager(epochsManager).currentEpoch();\\n\\n        address[] memory effectiveGuardians = _filterGuardians(guardians);\\n        address[] memory effectiveSentinels = _filterSentinels(sentinels);\\n\\n        uint256 length = effectiveGuardians.length + effectiveSentinels.length;\\n        address[] memory actors = new address[](length);\\n        IPNetworkHub.ActorTypes[] memory actorsType = new IPNetworkHub.ActorTypes[](length);\\n\\n        for (uint256 i = 0; i < effectiveGuardians.length; ) {\\n            actors[i] = effectiveGuardians[i];\\n            actorsType[i] = IPNetworkHub.ActorTypes.Guardian;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        for (uint256 i = effectiveGuardians.length; i < length; ) {\\n            actors[i] = effectiveSentinels[i - effectiveGuardians.length];\\n            actorsType[i] = IPNetworkHub.ActorTypes.Sentinel;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit ActorsPropagated(currentEpoch, actors, actorsType);\\n\\n        _sendMessage(\\n            abi.encode(\\n                GOVERNANCE_MESSAGE_ACTORS,\\n                abi.encode(\\n                    currentEpoch,\\n                    effectiveGuardians.length,\\n                    effectiveSentinels.length,\\n                    MerkleTree.getRoot(_hashActorAddressesWithType(actors, actorsType))\\n                )\\n            )\\n        );\\n    }\\n\\n    /// @inheritdoc IGovernanceMessageEmitter\\n    function protocolGovernanceCancelOperation(\\n        IPNetworkHub.Operation calldata operation,\\n        bytes4 networkId\\n    ) external onlyDandelionVoting {\\n        address[] memory hubs = new address[](1);\\n        uint32[] memory chainIds = new uint32[](1);\\n\\n        address hub = IPRegistry(registry).getHubByNetworkId(networkId);\\n        if (hub == address(0)) {\\n            revert NetworkNotSupported(networkId);\\n        }\\n\\n        uint32 chainId = IPRegistry(registry).getChainIdByNetworkId(networkId);\\n        hubs[0] = hub;\\n        chainIds[0] = chainId;\\n\\n        emit GovernanceMessage(\\n            abi.encode(\\n                totalNumberOfMessages,\\n                chainIds,\\n                hubs,\\n                abi.encode(GOVERNANCE_MESSAGE_PROTOCOL_GOVERNANCE_CANCEL_OPERATION, abi.encode(operation))\\n            )\\n        );\\n\\n        unchecked {\\n            ++totalNumberOfMessages;\\n        }\\n    }\\n\\n    /// @inheritdoc IGovernanceMessageEmitter\\n    function resumeActor(address actor, bytes1 registrationKind) external onlyRegistrationManager {\\n        _sendMessage(\\n            abi.encode(\\n                GOVERNANCE_MESSAGE_RESUME_ACTOR,\\n                abi.encode(\\n                    IEpochsManager(epochsManager).currentEpoch(),\\n                    actor,\\n                    _getActorTypeByRegistrationKind(registrationKind)\\n                )\\n            )\\n        );\\n    }\\n\\n    /// @inheritdoc IGovernanceMessageEmitter\\n    function slashActor(address actor, bytes1 registrationKind) external onlyRegistrationManager {\\n        _sendMessage(\\n            abi.encode(\\n                GOVERNANCE_MESSAGE_SLASH_ACTOR,\\n                abi.encode(\\n                    IEpochsManager(epochsManager).currentEpoch(),\\n                    actor,\\n                    _getActorTypeByRegistrationKind(registrationKind)\\n                )\\n            )\\n        );\\n    }\\n\\n    function _filterGuardians(address[] calldata guardians) internal view returns (address[] memory) {\\n        uint16 currentEpoch = IEpochsManager(epochsManager).currentEpoch();\\n        // uint16 totalNumberOfGuardians = IRegistrationManager(registrationManager).totalNumberOfGuardiansByEpoch(\\n        //     currentEpoch\\n        // );\\n\\n        // uint16 numberOfValidGuardians;\\n        // for (uint16 index = 0; index < guardians; ) {\\n        //     IRegistrationManager.Registration memory registration = IRegistrationManager(registrationManager)\\n        //         .guardianRegistration(guardians[index]);\\n\\n        //     if (registration.kind == 0x03 && currentEpoch >= registration.startEpoch && currentEpoch <= registration.endEpoch) {\\n        //         unchecked {\\n        //             ++numberOfValidGuardians;\\n        //         }\\n        //     }\\n        //     unchecked {\\n        //         ++index;\\n        //     }\\n        // }\\n\\n        // if (totalNumberOfGuardians != numberOfValidGuardians) {\\n        //     revert InvalidNumberOfGuardians(numberOfValidGuardians, totalNumberOfGuardians);\\n        // }\\n\\n        return guardians;\\n    }\\n\\n    function _filterSentinels(address[] memory sentinels) internal view returns (address[] memory) {\\n        uint16 currentEpoch = IEpochsManager(epochsManager).currentEpoch();\\n        uint32 totalBorrowedAmount = ILendingManager(lendingManager).totalBorrowedAmountByEpoch(currentEpoch);\\n        uint256 totalSentinelStakedAmount = IRegistrationManager(registrationManager).totalSentinelStakedAmountByEpoch(\\n            currentEpoch\\n        );\\n        uint256 totalAmount = totalBorrowedAmount + totalSentinelStakedAmount;\\n\\n        int256[] memory validIndexes = new int256[](sentinels.length);\\n        uint256 totalValidSentinels = 0;\\n        uint256 cumulativeAmount = 0;\\n\\n        // NOTE: be sure that totalSentinelStakedAmount + totalBorrowedAmount = cumulativeAmount.\\n        // There could be also sentinels that has less than 200k PNT because of slashing.\\n        // These sentinels will be filtered in the next step\\n        for (uint256 index; index < sentinels.length; ) {\\n            IRegistrationManager.Registration memory registration = IRegistrationManager(registrationManager)\\n                .registrationOf(sentinels[index]);\\n\\n            bytes1 registrationKind = registration.kind;\\n            if (registrationKind == 0x01) {\\n                // NOTE: no need to check startEpoch and endEpoch since we are using sentinelStakedAmountByEpochOf\\n                uint256 amount = IRegistrationManager(registrationManager).sentinelStakedAmountByEpochOf(\\n                    sentinels[index],\\n                    currentEpoch\\n                );\\n                cumulativeAmount += amount;\\n                if (amount >= 200000) {\\n                    validIndexes[index] = int256(index);\\n                    unchecked {\\n                        totalValidSentinels++;\\n                    }\\n                } else {\\n                    validIndexes[index] = -1;\\n                }\\n            } else if (\\n                registrationKind == 0x02 &&\\n                currentEpoch >= registration.startEpoch &&\\n                currentEpoch <= registration.endEpoch\\n            ) {\\n                cumulativeAmount += 200000;\\n                validIndexes[index] = int256(index);\\n                unchecked {\\n                    totalValidSentinels++;\\n                }\\n            } else {\\n                revert InvalidSentinelRegistration(registrationKind);\\n            }\\n\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n\\n        if (totalAmount != cumulativeAmount) {\\n            revert InvalidAmount(totalAmount, cumulativeAmount);\\n        }\\n\\n        address[] memory effectiveSentinels = new address[](totalValidSentinels);\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < validIndexes.length; ) {\\n            int256 validIndex = validIndexes[i];\\n            if (validIndex != -1) {\\n                effectiveSentinels[j] = sentinels[uint256(validIndex)];\\n                unchecked {\\n                    j++;\\n                }\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        return effectiveSentinels;\\n    }\\n\\n    function _getActorTypeByRegistrationKind(bytes1 registrationKind) internal pure returns (IPNetworkHub.ActorTypes) {\\n        if (registrationKind == 0x01) return IPNetworkHub.ActorTypes.Sentinel;\\n        if (registrationKind == 0x02) return IPNetworkHub.ActorTypes.Sentinel;\\n        if (registrationKind == 0x03) return IPNetworkHub.ActorTypes.Guardian;\\n        revert InvalidRegistrationKind(registrationKind);\\n    }\\n\\n    function _hashActorAddressesWithType(\\n        address[] memory actors,\\n        IPNetworkHub.ActorTypes[] memory actorTypes\\n    ) internal pure returns (bytes32[] memory) {\\n        bytes32[] memory data = new bytes32[](actors.length);\\n        for (uint256 i = 0; i < actors.length; i++) {\\n            data[i] = keccak256(abi.encodePacked(actors[i], actorTypes[i]));\\n        }\\n        return data;\\n    }\\n\\n    function _sendMessage(bytes memory message) internal {\\n        address[] memory hubs = IPRegistry(registry).getSupportedHubs();\\n        uint32[] memory chainIds = IPRegistry(registry).getSupportedChainIds();\\n\\n        emit GovernanceMessage(abi.encode(totalNumberOfMessages, chainIds, hubs, message));\\n\\n        unchecked {\\n            ++totalNumberOfMessages;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/ITelepathyHandler.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\n\\ninterface ITelepathyHandler {\\n    function handleTelepathy(uint32 sourceChainId, address sourceSender, bytes memory data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernanceMessageEmitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport {IPNetworkHub} from \\\"./IPNetworkHub.sol\\\";\\n\\n/**\\n * @title IGovernanceMessageEmitter\\n * @author pNetwork\\n *\\n * @notice\\n */\\n\\ninterface IGovernanceMessageEmitter {\\n    /**\\n     * @dev Emitted when actors are emitted.\\n     *\\n     * @param epoch The epoch\\n     * @param actors The actors\\n     * @param actorsType The actor types\\n     */\\n    event ActorsPropagated(uint16 indexed epoch, address[] actors, IPNetworkHub.ActorTypes[] actorsType);\\n\\n    /**\\n     * @dev Emitted when a governance message must be propagated on the other chains\\n     *\\n     * @param data The data\\n     */\\n    event GovernanceMessage(bytes data);\\n\\n    /*\\n     * @notice Emit a GovernanceMessage event containing the total number of actors (sentinels and guardians) and\\n     *         the actors merkle root for the current epoch. This message will be verified by GovernanceMessageVerifier.\\n     *\\n     * @param sentinels\\n     * @param guardians\\n     */\\n    function propagateActors(address[] calldata sentinels, address[] calldata guardians) external;\\n\\n    /*\\n     * @notice Emit a GovernanceMessage to cancel an operation on a given network\\n     *\\n     * @param operation\\n     * @param networkId\\n     */\\n    function protocolGovernanceCancelOperation(IPNetworkHub.Operation calldata operation, bytes4 networkId) external;\\n\\n    /*\\n     * @notice Emit a GovernanceMessage event containing the address and the type of the resumed actor\\n     *\\n     * @param actor\\n     * @param registrationKind\\n     */\\n    function resumeActor(address actor, bytes1 registrationKind) external;\\n\\n    /*\\n     * @notice Emit a GovernanceMessage event containing the address and the type of the slashed actor\\n     *\\n     * @param actor\\n     * @param registrationKind\\n     */\\n    function slashActor(address actor, bytes1 registrationKind) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernanceMessageHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport {ITelepathyHandler} from \\\"../interfaces/external/ITelepathyHandler.sol\\\";\\n\\n/**\\n * @title IGovernanceMessageHandler\\n * @author pNetwork\\n *\\n * @notice\\n */\\n\\ninterface IGovernanceMessageHandler is ITelepathyHandler {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPNetworkHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport {IGovernanceMessageHandler} from \\\"./IGovernanceMessageHandler.sol\\\";\\n\\n/**\\n * @title IPNetworkHub\\n * @author pNetwork\\n *\\n * @notice\\n */\\ninterface IPNetworkHub is IGovernanceMessageHandler {\\n    enum ActorTypes {\\n        Governance,\\n        Guardian,\\n        Sentinel\\n    }\\n\\n    enum ActorStatus {\\n        Active,\\n        Challenged,\\n        Inactive\\n    }\\n\\n    enum ChallengeStatus {\\n        Null,\\n        Pending,\\n        Solved,\\n        Unsolved,\\n        PartiallyUnsolved,\\n        Cancelled\\n    }\\n\\n    enum OperationStatus {\\n        NotQueued,\\n        Queued,\\n        Executed,\\n        Cancelled\\n    }\\n\\n    struct Action {\\n        address actor;\\n        uint64 timestamp;\\n    }\\n\\n    struct Challenge {\\n        uint256 nonce;\\n        address actor;\\n        address challenger;\\n        ActorTypes actorType;\\n        uint64 timestamp;\\n        bytes4 networkId;\\n    }\\n\\n    struct Operation {\\n        bytes32 originBlockHash;\\n        bytes32 originTransactionHash;\\n        bytes32 optionsMask;\\n        uint256 nonce;\\n        uint256 underlyingAssetDecimals;\\n        uint256 assetAmount;\\n        uint256 userDataProtocolFeeAssetAmount;\\n        uint256 networkFeeAssetAmount;\\n        uint256 forwardNetworkFeeAssetAmount;\\n        address underlyingAssetTokenAddress;\\n        bytes4 originNetworkId;\\n        bytes4 destinationNetworkId;\\n        bytes4 forwardDestinationNetworkId;\\n        bytes4 underlyingAssetNetworkId;\\n        string originAccount;\\n        string destinationAccount;\\n        string underlyingAssetName;\\n        string underlyingAssetSymbol;\\n        bytes userData;\\n        bool isForProtocol;\\n    }\\n\\n    /**\\n     * @dev Emitted when an actor is resumed after having being slashed\\n     *\\n     * @param epoch The epoch in which the actor has been resumed\\n     * @param actor The resumed actor\\n     */\\n    event ActorResumed(uint16 indexed epoch, address indexed actor);\\n\\n    /**\\n     * @dev Emitted when an actor has been slashed on the interim chain.\\n     *\\n     * @param epoch The epoch in which the actor has been slashed\\n     * @param actor The slashed actor\\n     */\\n    event ActorSlashed(uint16 indexed epoch, address indexed actor);\\n\\n    /**\\n     * @dev Emitted when a challenge is cancelled.\\n     *\\n     * @param challenge The challenge\\n     */\\n    event ChallengeCancelled(Challenge challenge);\\n\\n    /**\\n     * @dev Emitted when a challenger claims the lockedAmountStartChallenge by providing a challenge.\\n     *\\n     * @param challenge The challenge\\n     */\\n    event ChallengePartiallyUnsolved(Challenge challenge);\\n\\n    /**\\n     * @dev Emitted when a challenge is started.\\n     *\\n     * @param challenge The challenge\\n     */\\n    event ChallengePending(Challenge challenge);\\n\\n    /**\\n     * @dev Emitted when a challenge is solved.\\n     *\\n     * @param challenge The challenge\\n     */\\n    event ChallengeSolved(Challenge challenge);\\n\\n    /**\\n     * @dev Emitted when a challenge is used to slash an actor.\\n     *\\n     * @param challenge The challenge\\n     */\\n    event ChallengeUnsolved(Challenge challenge);\\n\\n    /**\\n     * @dev Emitted when an operation is cancelled.\\n     *\\n     * @param operation The cancelled operation\\n     */\\n    event OperationCancelFinalized(Operation operation);\\n\\n    /**\\n     * @dev Emitted when an actor instructs a cancel operation.\\n     *\\n     * @param operation The cancelled operation\\n     * @param actor the actor\\n     * @param actorType the actor type\\n     */\\n    event OperationCancelled(Operation operation, address indexed actor, ActorTypes indexed actorType);\\n\\n    /**\\n     * @dev Emitted when an operation is executed.\\n     *\\n     * @param operation The executed operation\\n     */\\n    event OperationExecuted(Operation operation);\\n\\n    /**\\n     * @dev Emitted when an operation is queued.\\n     *\\n     * @param operation The queued operation\\n     */\\n    event OperationQueued(Operation operation);\\n\\n    /**\\n     * @dev Emitted when an user operation is generated.\\n     *\\n     * @param nonce The nonce\\n     * @param originAccount The account that triggered the user operation\\n     * @param destinationAccount The account to which the funds will be delivered\\n     * @param destinationNetworkId The destination network id\\n     * @param underlyingAssetName The name of the underlying asset\\n     * @param underlyingAssetSymbol The symbol of the underlying asset\\n     * @param underlyingAssetDecimals The number of decimals of the underlying asset\\n     * @param underlyingAssetTokenAddress The address of the underlying asset\\n     * @param underlyingAssetNetworkId The network id of the underlying asset\\n     * @param assetTokenAddress The asset token address\\n     * @param assetAmount The asset mount\\n     * @param userDataProtocolFeeAssetAmount the protocol fee asset amount for the user data\\n     * @param networkFeeAssetAmount the network fee asset amount\\n     * @param forwardNetworkFeeAssetAmount the forward network fee asset amount\\n     * @param forwardDestinationNetworkId the forward destination network id\\n     * @param userData The user data\\n     * @param optionsMask The options\\n     */\\n    event UserOperation(\\n        uint256 nonce,\\n        string originAccount,\\n        string destinationAccount,\\n        bytes4 destinationNetworkId,\\n        string underlyingAssetName,\\n        string underlyingAssetSymbol,\\n        uint256 underlyingAssetDecimals,\\n        address underlyingAssetTokenAddress,\\n        bytes4 underlyingAssetNetworkId,\\n        address assetTokenAddress,\\n        uint256 assetAmount,\\n        uint256 userDataProtocolFeeAssetAmount,\\n        uint256 networkFeeAssetAmount,\\n        uint256 forwardNetworkFeeAssetAmount,\\n        bytes4 forwardDestinationNetworkId,\\n        bytes userData,\\n        bytes32 optionsMask,\\n        bool isForProtocol\\n    );\\n\\n    /*\\n     * @notice Calculates the challenge id.\\n     *\\n     * @param challenge\\n     *\\n     * @return bytes32 representing the challenge id.\\n     */\\n    function challengeIdOf(Challenge memory challenge) external view returns (bytes32);\\n\\n    /*\\n     * @notice Calculates the operation challenge period.\\n     *\\n     * @param operation\\n     *\\n     * @return (uint64, uin64) representing the start and end timestamp of an operation challenge period.\\n     */\\n    function challengePeriodOf(Operation calldata operation) external view returns (uint64, uint64);\\n\\n    /*\\n     * @notice Offer the possibilty to claim the lockedAmountStartChallenge for a given challenge in a previous epoch in case it happens the following scenario:\\n     *          - A challenger initiates a challenge against a guardian/sentinel close to an epoch's end (within permissible limits).\\n     *          - The maxChallengeDuration elapses, disabling the sentinel from resolving the challenge within the currentEpoch.\\n     *          - The challenger fails to invoke slashByChallenge before the epoch terminates.\\n     *          - A new epoch initiates.\\n     *          - Result: lockedAmountStartChallenge STUCK.\\n     *\\n     * @param challenge\\n     *\\n     */\\n    function claimLockedAmountStartChallenge(Challenge calldata challenge) external;\\n\\n    /*\\n     * @notice Return the epoch in which a challenge was started.\\n     *\\n     * @param challenge\\n     *\\n     * @return uint16 representing the epoch in which a challenge was started.\\n     */\\n    function getChallengeEpoch(Challenge calldata challenge) external view returns (uint16);\\n\\n    /*\\n     * @notice Return the status of a challenge.\\n     *\\n     * @param challenge\\n     *\\n     * @return (ChallengeStatus) representing the challenge status\\n     */\\n    function getChallengeStatus(Challenge calldata challenge) external view returns (ChallengeStatus);\\n\\n    /*\\n     * @notice Calculates the current active actors duration which is use to secure the system when few there are few active actors.\\n     *\\n     * @return uint64 representing the current active actors duration.\\n     */\\n    //function getCurrentActiveActorsAdjustmentDuration() external view returns (uint64);\\n\\n    /*\\n     * @notice Calculates the current challenge period duration considering the number of operations in queue and the total number of active actors.\\n     *\\n     * @return uint64 representing the current challenge period duration.\\n     */\\n    function getCurrentChallengePeriodDuration() external view returns (uint64);\\n\\n    /*\\n     * @notice Calculates the adjustment duration based on the total number of operations in queue.\\n     *\\n     * @return uint64 representing the adjustment duration based on the total number of operations in queue.\\n     */\\n    function getCurrentQueuedOperationsAdjustmentDuration() external view returns (uint64);\\n\\n    /*\\n     * @notice Returns the pending challenge id for an actor in a given epoch.\\n     *\\n     * @param epoch\\n     * @param actor\\n     *\\n     * @return bytes32 representing the pending challenge id for an actor in a given epoch.\\n     */\\n    function getPendingChallengeIdByEpochOf(uint16 epoch, address actor) external view returns (bytes32);\\n\\n    /*\\n     * @notice Returns the total number of actors in an epoch.\\n     *\\n     * @param epoch\\n     * @param actorType\\n     *\\n     * @return uint16 representing the total number of actors in an epoch.\\n     */\\n    function getTotalNumberOfActorsByEpochAndType(uint16 epoch, ActorTypes actorType) external view returns (uint16);\\n\\n    /*\\n     * @notice Returns the total number of inactive actors in an epoch.\\n     *\\n     * @param epoch\\n     * @param actorType\\n     *\\n     * @return uint16 representing the total number of inactive actors in an epoch.\\n     */\\n    function getTotalNumberOfInactiveActorsByEpochAndType(\\n        uint16 epoch,\\n        ActorTypes actorType\\n    ) external view returns (uint16);\\n\\n    /*\\n     * @notice Indicates if the protocol is in lockdown\\n     *\\n     * @return bool indicating if the protocol is in lockdown\\n     */\\n    function isLockedDown() external view returns (bool);\\n\\n    /*\\n     * @notice Calculates the operation id.\\n     *\\n     * @param operation\\n     *\\n     * @return (bytes32) the operation id.\\n     */\\n    function operationIdOf(Operation memory operation) external pure returns (bytes32);\\n\\n    /*\\n     * @notice Return the status of an operation.\\n     *\\n     * @param operation\\n     *\\n     * @return (OperationStatus) the operation status.\\n     */\\n    function operationStatusOf(Operation calldata operation) external view returns (OperationStatus);\\n\\n    /*\\n     * @notice An actor instruct a cancel action. If 2 actors agree on it the operation is cancelled.\\n     *\\n     * @param operation\\n     * @param actorType\\n     * @param proof\\n     * @param signature\\n     *\\n     */\\n    function protocolCancelOperation(\\n        Operation calldata operation,\\n        ActorTypes actorType,\\n        bytes32[] calldata proof,\\n        bytes calldata signature\\n    ) external;\\n\\n    /*\\n     * @notice Execute an operation that has been queued.\\n     *\\n     * @param operation\\n     *\\n     */\\n    function protocolExecuteOperation(Operation calldata operation) external payable;\\n\\n    /*\\n     * @notice The Governance instruct a cancel action. If 2 actors agree on it the operation is cancelled.\\n     *          This function can be invoked ONLY by the DandelionVoting contract ONLY on the interim chain\\n     *\\n     * @param operation\\n     *\\n     */\\n    function protocolGovernanceCancelOperation(Operation calldata operation) external;\\n\\n    /*\\n     * @notice Queue an operation.\\n     *\\n     * @param operation\\n     *\\n     */\\n    function protocolQueueOperation(Operation calldata operation) external payable;\\n\\n    /*\\n     * @notice Slash a sentinel of a guardians previously challenges if it was not able to solve the challenge in time.\\n     *\\n     * @param challenge\\n     *\\n     */\\n    function slashByChallenge(Challenge calldata challenge) external;\\n\\n    /*\\n     * @notice Solve a challenge of an actor and sends the bond (lockedAmountStartChallenge) to the DAO.\\n     *\\n     * @param challenge\\n     * @param actorType\\n     * @param proof\\n     * @param signature\\n     *\\n     */\\n    function solveChallenge(\\n        Challenge calldata challenge,\\n        ActorTypes actorType,\\n        bytes32[] calldata proof,\\n        bytes calldata signature\\n    ) external;\\n\\n    /*\\n     * @notice Start a challenge for an actor.\\n     *\\n     * @param actor\\n     * @param actorType\\n     * @param proof\\n     *\\n     */\\n    function startChallenge(address actor, ActorTypes actorType, bytes32[] memory proof) external payable;\\n\\n    /*\\n     * @notice Generate an user operation which will be used by the relayers to be able\\n     *         to queue this operation on the destination network through the StateNetwork of that chain\\n     *\\n     * @param destinationAccount\\n     * @param destinationNetworkId\\n     * @param underlyingAssetName\\n     * @param underlyingAssetSymbol\\n     * @param underlyingAssetDecimals\\n     * @param underlyingAssetTokenAddress\\n     * @param underlyingAssetNetworkId\\n     * @param assetTokenAddress\\n     * @param assetAmount\\n     * @param networkFeeAssetAmount\\n     * @param forwardNetworkFeeAssetAmount\\n     * @param userData\\n     * @param optionsMask\\n     */\\n    function userSend(\\n        string calldata destinationAccount,\\n        bytes4 destinationNetworkId,\\n        string calldata underlyingAssetName,\\n        string calldata underlyingAssetSymbol,\\n        uint256 underlyingAssetDecimals,\\n        address underlyingAssetTokenAddress,\\n        bytes4 underlyingAssetNetworkId,\\n        address assetTokenAddress,\\n        uint256 assetAmount,\\n        uint256 networkFeeAssetAmount,\\n        uint256 forwardNetworkFeeAssetAmount,\\n        bytes calldata userData,\\n        bytes32 optionsMask\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/**\\n * Created on 2023-09-15 14:48\\n * @summary:\\n * @author: mauro\\n */\\npragma solidity ^0.8.19;\\n\\ninterface IPRegistry {\\n    /**\\n     * @dev Emitted when a challenge is started.\\n     *\\n     * @param networkId The network id\\n     * @param chainId The chain id\\n     * @param hub The hub\\n     */\\n    event NetworkAdded(bytes4 indexed networkId, uint32 indexed chainId, address hub);\\n\\n    /**\\n     * @dev Returns the chain id for the given network ID\\n     *\\n     * @param networkId a network ID\\n     *\\n     * @return uint32 chain id for the given network ID\\n     */\\n    function getChainIdByNetworkId(bytes4 networkId) external view returns (uint32);\\n\\n    /**\\n     * @dev Returns the pNetwork hub address for the given network ID\\n     *\\n     * @param networkId a network ID\\n     *\\n     * @return address pNetwork hub address on the given network ID\\n     */\\n    function getHubByNetworkId(bytes4 networkId) external view returns (address);\\n\\n    /**\\n     * @dev Return the supported chain IDs\\n     * @return uint32[] the array of supported chain ids\\n     */\\n    function getSupportedChainIds() external view returns (uint32[] memory);\\n\\n    /**\\n     * @dev Return the supported hubs\\n     */\\n    function getSupportedHubs() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Return the supported chain ID\\n     * @param chainId the chain id\\n     */\\n    function isChainIdSupported(uint32 chainId) external view returns (bool);\\n\\n    /*\\n     * @dev Return true if the given network id has been registered on pNetwork\\n     *\\n     * @param networkId the network ID\\n     *\\n     * @return bool true or false\\n     */\\n    function isNetworkIdSupported(bytes4 networkId) external view returns (bool);\\n\\n    /*\\n     * @dev Add a new entry for the map network ID => hub\\n     *\\n     * @param networkId the network ID\\n     * @param hub pNetwork hub contract address\\n     */\\n    function protocolAddNetwork(uint32 chainId, address hub) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MerkleTree.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nlibrary MerkleTree {\\n    function getRoot(bytes32[] memory data) internal pure returns (bytes32) {\\n        uint256 n = data.length;\\n\\n        if (n == 1) {\\n            return data[0];\\n        }\\n\\n        uint256 j = 0;\\n        uint256 layer = 0;\\n        uint256 leaves = Math.log2(n) + 1;\\n        bytes32[][] memory nodes = new bytes32[][](leaves * (2 * n - 1));\\n\\n        for (uint256 i = 0; i <= leaves; ) {\\n            nodes[i] = new bytes32[](2 * n - 1);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        for (uint256 i = 0; i < data.length; ) {\\n            nodes[layer][j] = data[i];\\n            unchecked {\\n                ++j;\\n                ++i;\\n            }\\n        }\\n\\n        while (n > 1) {\\n            uint256 layerNodes = 0;\\n            uint256 k = 0;\\n\\n            for (uint256 i = 0; i < n; i += 2) {\\n                if (i + 1 == n) {\\n                    if (n % 2 == 1) {\\n                        nodes[layer + 1][k] = nodes[layer][n - 1];\\n                        unchecked {\\n                            ++j;\\n                            ++layerNodes;\\n                        }\\n                        continue;\\n                    }\\n                }\\n\\n                nodes[layer + 1][k] = _hashPair(nodes[layer][i], nodes[layer][i + 1]);\\n\\n                unchecked {\\n                    ++k;\\n                    layerNodes += 2;\\n                }\\n            }\\n\\n            n = (n / 2) + (layerNodes % 2 == 0 ? 0 : 1);\\n            unchecked {\\n                ++layer;\\n            }\\n        }\\n\\n        return nodes[layer][0];\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) internal pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"epochsManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lendingManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registrationManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dandelionVoting_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedAmount\",\"type\":\"uint256\"}],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes1\",\"name\":\"kind\",\"type\":\"bytes1\"}],\"name\":\"InvalidRegistrationKind\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes1\",\"name\":\"kind\",\"type\":\"bytes1\"}],\"name\":\"InvalidSentinelRegistration\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"networkId\",\"type\":\"bytes4\"}],\"name\":\"NetworkNotSupported\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dandelionVoting\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expectedDandelionVoting\",\"type\":\"address\"}],\"name\":\"NotDandelionVoting\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registrationManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expectedRegistrationManager\",\"type\":\"address\"}],\"name\":\"NotRegistrationManager\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"epoch\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"actors\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"enum IPNetworkHub.ActorTypes[]\",\"name\":\"actorsType\",\"type\":\"uint8[]\"}],\"name\":\"ActorsPropagated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"GovernanceMessage\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GOVERNANCE_MESSAGE_ACTORS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOVERNANCE_MESSAGE_PROTOCOL_GOVERNANCE_CANCEL_OPERATION\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOVERNANCE_MESSAGE_RESUME_ACTOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOVERNANCE_MESSAGE_SLASH_ACTOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dandelionVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochsManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"sentinels\",\"type\":\"address[]\"}],\"name\":\"propagateActors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"originBlockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"originTransactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"optionsMask\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAssetDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userDataProtocolFeeAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"networkFeeAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"forwardNetworkFeeAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingAssetTokenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"originNetworkId\",\"type\":\"bytes4\"},{\"internalType\":\"bytes4\",\"name\":\"destinationNetworkId\",\"type\":\"bytes4\"},{\"internalType\":\"bytes4\",\"name\":\"forwardDestinationNetworkId\",\"type\":\"bytes4\"},{\"internalType\":\"bytes4\",\"name\":\"underlyingAssetNetworkId\",\"type\":\"bytes4\"},{\"internalType\":\"string\",\"name\":\"originAccount\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destinationAccount\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"underlyingAssetName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"underlyingAssetSymbol\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"isForProtocol\",\"type\":\"bool\"}],\"internalType\":\"struct IPNetworkHub.Operation\",\"name\":\"operation\",\"type\":\"tuple\"},{\"internalType\":\"bytes4\",\"name\":\"networkId\",\"type\":\"bytes4\"}],\"name\":\"protocolGovernanceCancelOperation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registrationManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"actor\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"registrationKind\",\"type\":\"bytes1\"}],\"name\":\"resumeActor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"actor\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"registrationKind\",\"type\":\"bytes1\"}],\"name\":\"slashActor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNumberOfMessages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GovernanceMessageEmitter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000091f2008cca89114ccbef2dea1f3e677b68df69a00000000000000000000000039697da77dfb1be70c8684e5787c101cee69525d0000000000000000000000009bbd6a8e738de6ac5ed11ced0e209ad7798e7b460000000000000000000000000ef13b2668dbe1b3edfe9ffb7cbc398363b50f79000000000000000000000000b55860594fcbee06bd38010aa1faaf3b2e2d1fe1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}