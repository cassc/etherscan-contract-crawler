{"SourceCode": "// File: contracts/IPredictionPool.sol\r\n\r\npragma solidity ^0.7.4;\r\n\r\n\r\ninterface IPredictionPool {\r\n    function buyWhite(uint256 maxPrice, uint256 payment) external;\r\n\r\n    function buyBlack(uint256 maxPrice, uint256 payment) external;\r\n\r\n    function sellWhite(uint256 tokensAmount, uint256 minPrice) external;\r\n\r\n    function sellBlack(uint256 tokensAmount, uint256 minPrice) external;\r\n\r\n    function changeGovernanceAddress(address governanceAddress) external;\r\n\r\n    function _whitePrice() external returns (uint256);\r\n\r\n    function _blackPrice() external returns (uint256);\r\n\r\n    function _whiteBought() external returns (uint256);\r\n\r\n    function _blackBought() external returns (uint256);\r\n\r\n    function _whiteToken() external returns (address);\r\n\r\n    function _blackToken() external returns (address);\r\n\r\n    function _thisCollateralization() external returns (address);\r\n\r\n    function _eventStarted() external view returns (bool);\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function FEE() external returns (uint256);\r\n\r\n    function init(\r\n        address governanceWalletAddress,\r\n        address eventContractAddress,\r\n        address controllerWalletAddress,\r\n        address ordererAddress,\r\n        bool onlyOrderer\r\n    ) external;\r\n\r\n    function changeFees(\r\n        uint256 fee,\r\n        uint256 governanceFee,\r\n        uint256 controllerFee,\r\n        uint256 bwAdditionFee\r\n    ) external;\r\n\r\n    function changeOrderer(address newOrderer) external;\r\n\r\n    function setOnlyOrderer(bool only) external;\r\n}\r\n\r\n// File: contracts/IEventLifeCycle.sol\r\n\r\npragma solidity ^0.7.4;\r\n\r\n// pragma abicoder v2;\r\n\r\ninterface IEventLifeCycle {\r\n    struct GameEvent {\r\n        /* solhint-disable prettier/prettier */\r\n        uint256 priceChangePart;        // in percent\r\n        uint256 eventStartTimeExpected; // in seconds since 1970\r\n        uint256 eventEndTimeExpected;   // in seconds since 1970\r\n        string blackTeam;\r\n        string whiteTeam;\r\n        string eventType;\r\n        string eventSeries;\r\n        string eventName;\r\n        uint256 eventId;\r\n        /* solhint-enable prettier/prettier */\r\n    }\r\n\r\n    function addNewEvent(\r\n        uint256 priceChangePart_,\r\n        uint256 eventStartTimeExpected_,\r\n        uint256 eventEndTimeExpected_,\r\n        string calldata blackTeam_,\r\n        string calldata whiteTeam_,\r\n        string calldata eventType_,\r\n        string calldata eventSeries_,\r\n        string calldata eventName_,\r\n        uint256 eventId_\r\n    ) external;\r\n\r\n    function addAndStartEvent(\r\n        uint256 priceChangePart_, // in 0.0001 parts percent of a percent dose\r\n        uint256 eventStartTimeExpected_,\r\n        uint256 eventEndTimeExpected_,\r\n        string calldata blackTeam_,\r\n        string calldata whiteTeam_,\r\n        string calldata eventType_,\r\n        string calldata eventSeries_,\r\n        string calldata eventName_,\r\n        uint256 eventId_\r\n    ) external returns (uint256);\r\n\r\n    function startEvent() external returns (uint256);\r\n\r\n    function endEvent(int8 _result) external;\r\n\r\n    function _ongoingEvent()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 priceChangePart,\r\n            uint256 eventStartTimeExpected,\r\n            uint256 eventEndTimeExpected,\r\n            string calldata blackTeam,\r\n            string calldata whiteTeam,\r\n            string calldata eventType,\r\n            string calldata eventSeries,\r\n            string calldata eventName,\r\n            uint256 gameEventId\r\n        );\r\n\r\n    function _usePendingOrders() external view returns (bool);\r\n\r\n    function _pendingOrders() external view returns (address);\r\n\r\n    function setPendingOrders(\r\n        address pendingOrdersAddress,\r\n        bool usePendingOrders\r\n    ) external;\r\n\r\n    function setLeverage(address leverageAddress, bool useLeverage) external;\r\n\r\n    function changeGovernanceAddress(address governanceAddress) external;\r\n}\r\n\r\n// File: contracts/IPendingOrders.sol\r\n\r\npragma solidity ^0.7.4;\r\n\r\n\r\ninterface IPendingOrders {\r\n    function eventStart(uint256 _eventId) external;\r\n\r\n    function eventEnd(uint256 _eventId) external;\r\n\r\n    function createOrder(\r\n        uint256 _amount,\r\n        bool _isWhite,\r\n        uint256 _eventId\r\n    ) external;\r\n\r\n    function cancelOrder(uint256 orderId) external;\r\n\r\n    function _eventContractAddress() external view returns (address);\r\n\r\n    function _predictionPool() external view returns (address);\r\n\r\n    function withdrawCollateral() external returns (uint256);\r\n}\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\npragma solidity >=0.5.16;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n// File: contracts/Common/Ownable.sol\r\n\r\npragma solidity ^0.7.4;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n// File: contracts/DSMath.sol\r\n\r\n\r\n// See <http://www.gnu.org/licenses/>\r\n\r\npragma solidity >0.4.13;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    //rounds to zero if x*y < RAY / 2\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Common/IERC20.sol\r\n\r\npragma solidity ^0.7.4;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: contracts/LeverageToken.sol\r\n\r\npragma solidity ^0.7.4;\r\n\r\n\r\n\r\ncontract LeverageTokenERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    /* solhint-disable const-name-snakecase */\r\n    string public constant name = \"Polars Leverage Liquidity\";\r\n    string public constant symbol = \"PL\";\r\n    uint8 public constant decimals = 18;\r\n    /* solhint-enable const-name-snakecase */\r\n    uint256 public override totalSupply;\r\n    mapping(address => uint256) public override balanceOf;\r\n    mapping(address => mapping(address => uint256)) public override allowance;\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint256) public nonces;\r\n\r\n    constructor() {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\r\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n                ),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(\"1\")),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint256 value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint256 value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint256 value)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 value)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external override returns (bool) {\r\n        if (allowance[from][msg.sender] != uint256(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\r\n                value\r\n            );\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, \"UniswapV2: EXPIRED\");\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(\r\n                        PERMIT_TYPEHASH,\r\n                        owner,\r\n                        spender,\r\n                        value,\r\n                        nonces[owner]++,\r\n                        deadline\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(\r\n            recoveredAddress != address(0) && recoveredAddress == owner,\r\n            \"UniswapV2: INVALID_SIGNATURE\"\r\n        );\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n\r\n// File: contracts/Leverage.sol\r\n\r\npragma solidity ^0.7.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Leverage is DSMath, Ownable, LeverageTokenERC20 {\r\n    IERC20 public _collateralToken;\r\n    IPendingOrders public _pendingOrders;\r\n    IEventLifeCycle public _eventLifeCycle;\r\n    IPredictionPool public _predictionPool;\r\n\r\n    uint256 public _maxUsageThreshold = 0.8 * 1e18; // Default 80%\r\n    uint256 public _maxLossThreshold = 0.5 * 1e18; // Default 50%\r\n\r\n    uint256 public _lpTokens = 0; // in 1e18\r\n    uint256 public _collateralTokens = 0; // in 1e18\r\n    uint256 public _borrowedCollateral = 0; // in 1e18\r\n\r\n    uint256 public _predictionPoolFee = 0;\r\n\r\n    uint256 public _leverageFee = 0.001 * 1e18; // Default 0.1%\r\n\r\n    uint256 public _priceChangePart = 0.05 * 1e18; // Default 0.05%\r\n\r\n    struct Order {\r\n        /* solhint-disable prettier/prettier */\r\n        address orderer;        // address of user placing order\r\n        uint256 cross;          // multiplicator\r\n        uint256 ownAmount;      // amount of user`s collateral tokens\r\n        uint256 borrowedAmount; // amount of given collateral tokens\r\n        bool isWhite;           // TRUE for white side, FALSE for black side\r\n        uint256 eventId;        // order target eventId\r\n        bool isPending;        // TRUE when placed, FALSE when canceled\r\n        /* solhint-enable prettier/prettier */\r\n    }\r\n\r\n    uint256 public _ordersCounter = 0;\r\n\r\n    // mapping from order ID to Cross Order detail\r\n    mapping(uint256 => Order) public _orders;\r\n\r\n    // mapping from user address to order IDs for that user\r\n    mapping(address => uint256[]) public _ordersOfUser;\r\n\r\n    struct LeverageEvent {\r\n        /* solhint-disable prettier/prettier */\r\n        uint256 eventId;\r\n        uint256 whitePriceBefore;       // price of white token before the event\r\n        uint256 blackPriceBefore;       // price of black token before the event\r\n        uint256 whitePriceAfter;        // price of white token after the event\r\n        uint256 blackPriceAfter;        // price of black token after the event\r\n        uint256 blackCollateral;        // total amount of collateral for black side of the event\r\n        uint256 whiteCollateral;        // total amount of collateral for white side of the event\r\n        bool isExecuted;                // FALSE before the event, TRUE after the event start\r\n        bool isStarted;                 // FALSE before the event, TRUE after the event end\r\n        uint256 totalBorrowed;             // total borrowed amount of collateral of the event\r\n        /* solhint-enable prettier/prettier */\r\n    }\r\n\r\n    mapping(uint256 => LeverageEvent) public _events;\r\n\r\n    // Modifier to ensure call has been made by event contract\r\n    modifier onlyEventContract() {\r\n        require(\r\n            msg.sender == address(_eventLifeCycle),\r\n            \"CALLER SHOULD BE EVENT CONTRACT\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    event OrderCreated(\r\n        uint256 orderId,\r\n        address user,\r\n        uint256 maxLoss,\r\n        uint256 priceChangePart,\r\n        uint256 cross,\r\n        uint256 ownAmount,\r\n        uint256 orderAmount,\r\n        bool isWhite,\r\n        uint256 eventId\r\n    );\r\n    event OrderCanceled(uint256 id, address user);\r\n    event AddLiquidity(\r\n        address user,\r\n        uint256 lpAmount,\r\n        uint256 colaterallAmount\r\n    );\r\n    event WithdrawLiquidity(\r\n        address user,\r\n        uint256 lpAmount,\r\n        uint256 colaterallAmount\r\n    );\r\n    event CollateralWithdrew(uint256 amount, address user, address caller);\r\n    event MaxUsageThresholdChanged(uint256 newValue);\r\n    event MaxLossThresholdChanged(uint256 newValue);\r\n    event PriceChangePartChanged(uint256 newValue);\r\n\r\n    constructor(address collateralTokenAddress, address pendingOrdersAddress) {\r\n        require(\r\n            collateralTokenAddress != address(0),\r\n            \"Collateral token address should not be null\"\r\n        );\r\n        require(\r\n            pendingOrdersAddress != address(0),\r\n            \"PendingOrders address should not be null\"\r\n        );\r\n\r\n        _collateralToken = IERC20(collateralTokenAddress);\r\n        _pendingOrders = IPendingOrders(pendingOrdersAddress);\r\n        _eventLifeCycle = IEventLifeCycle(\r\n            _pendingOrders._eventContractAddress()\r\n        );\r\n        _predictionPool = IPredictionPool(_pendingOrders._predictionPool());\r\n\r\n        _predictionPoolFee = _predictionPool.FEE();\r\n\r\n        require(\r\n            _collateralToken.approve(\r\n                address(_pendingOrders),\r\n                type(uint256).max\r\n            ),\r\n            \"Approve error\"\r\n        );\r\n    }\r\n\r\n    function ordersOfUser(address user)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return _ordersOfUser[user];\r\n    }\r\n\r\n    function getOngoingEvent() public view returns (uint256, uint256) {\r\n        /* solhint-disable prettier/prettier */\r\n        (\r\n            uint256 priceChangePart,\r\n            , // uint256 eventStartTimeExpected\r\n            , // uint256 eventEndTimeExpected\r\n            , // string blackTeam\r\n            , // string whiteTeam\r\n            , // string eventType\r\n            , // string eventSeries\r\n            , // string eventName\r\n            uint256 gameEventId\r\n        ) = _eventLifeCycle._ongoingEvent();\r\n        /* solhint-enable prettier/prettier */\r\n        return (priceChangePart, gameEventId);\r\n    }\r\n\r\n    function isPendingEnabled() public view returns (bool) {\r\n        return (_eventLifeCycle._usePendingOrders() &&\r\n            _eventLifeCycle._pendingOrders() == address(_pendingOrders));\r\n    }\r\n\r\n    function allowedBorrowTotal() public view returns (uint256) {\r\n        return wmul(_collateralTokens, _maxUsageThreshold);\r\n    }\r\n\r\n    function allowedBorrowLeft() public view returns (uint256) {\r\n        uint256 allowedTotal = allowedBorrowTotal();\r\n        if(allowedTotal > _borrowedCollateral) {\r\n            return sub(allowedTotal, _borrowedCollateral);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function createOrder(\r\n        uint256 amount,\r\n        bool isWhite,\r\n        uint256 maxLoss,\r\n        uint256 eventId\r\n    ) external {\r\n        require(!_events[eventId].isStarted, \"EVENT ALREADY STARTED\");\r\n        require(maxLoss != 0, \"MAX LOSS PERCENT CANNOT BE 0\");\r\n        require(maxLoss <= _maxLossThreshold, \"MAX LOSS PERCENT IS VERY BIG\");\r\n\r\n        require(\r\n            _collateralToken.balanceOf(msg.sender) >= amount,\r\n            \"NOT ENOUGH COLLATERAL IN USER ACCOUNT\"\r\n        );\r\n        require(\r\n            _collateralToken.allowance(msg.sender, address(this)) >= amount,\r\n            \"NOT ENOUGHT DELEGATED TOKENS\"\r\n        );\r\n\r\n        uint256 cross = wdiv(maxLoss, _priceChangePart);\r\n\r\n        require(cross > 1 * 1e18, \"ERROR BORROWING\");\r\n\r\n        uint256 orderAmount = wmul(amount, cross);\r\n\r\n        uint256 userBorrowAmount = sub(orderAmount, amount);\r\n\r\n        uint256 threshold = allowedBorrowLeft();\r\n\r\n        require(\r\n            userBorrowAmount <= threshold,\r\n            \"NOT ENOUGH COLLATERAL BALANCE FOR BORROW\"\r\n        );\r\n\r\n        /* solhint-disable prettier/prettier */\r\n        _orders[_ordersCounter] = Order(\r\n            msg.sender,         // address orderer\r\n            cross,              // uint256 cross\r\n            amount,             // uint256 ownAmount\r\n            userBorrowAmount,   // uint256 borrowedAmount\r\n            isWhite,            // bool    isWhite\r\n            eventId,            // uint256 eventId\r\n            true\r\n        );\r\n        /* solhint-enable prettier/prettier */\r\n\r\n        _events[eventId].eventId = eventId;\r\n        _events[eventId].totalBorrowed = add(\r\n            _events[eventId].totalBorrowed,\r\n            userBorrowAmount\r\n        );\r\n\r\n        _ordersOfUser[msg.sender].push(_ordersCounter);\r\n\r\n        _borrowedCollateral = add(_borrowedCollateral, userBorrowAmount);\r\n\r\n        /* solhint-disable prettier/prettier */\r\n        isWhite\r\n            ? _events[eventId].whiteCollateral = add(_events[eventId].whiteCollateral, orderAmount)\r\n            : _events[eventId].blackCollateral = add(_events[eventId].blackCollateral, orderAmount);\r\n        /* solhint-enable prettier/prettier */\r\n\r\n        emit OrderCreated(\r\n            _ordersCounter,\r\n            msg.sender,\r\n            maxLoss,\r\n            _priceChangePart,\r\n            cross,\r\n            amount,\r\n            orderAmount,\r\n            isWhite,\r\n            eventId\r\n        );\r\n\r\n        require(\r\n            _collateralToken.transferFrom(msg.sender, address(this), amount),\r\n            \"Error transfer from\"\r\n        );\r\n        _ordersCounter = add(_ordersCounter, 1);\r\n    }\r\n\r\n    function cancelOrder(uint256 orderId) external {\r\n        Order memory order = _orders[orderId];\r\n        require(msg.sender == order.orderer, \"NOT YOUR ORDER\");\r\n        cancelOrderInternal(orderId, order);\r\n    }\r\n\r\n    function cancelOrderByAdmin(uint256 orderId) external onlyOwner {\r\n        Order memory order = _orders[orderId];\r\n        cancelOrderInternal(orderId, order);\r\n    }\r\n\r\n    function cancelOrderInternal(uint256 orderId, Order memory order) internal {\r\n        require(order.isPending, \"ORDER HAS ALREADY BEEN CANCELED\");\r\n\r\n        LeverageEvent memory eventById = _events[order.eventId];\r\n\r\n        require(!eventById.isExecuted, \"EVENT ALREADY ENDED\");\r\n\r\n        require(!eventById.isStarted, \"EVENT IN PROGRESS\");\r\n\r\n        uint256 totalAmount = add(order.ownAmount, order.borrowedAmount);\r\n\r\n        /* solhint-disable prettier/prettier */\r\n        order.isWhite\r\n            ? _events[order.eventId].whiteCollateral = sub(eventById.whiteCollateral, totalAmount)\r\n            : _events[order.eventId].blackCollateral = sub(eventById.blackCollateral, totalAmount);\r\n\r\n        _borrowedCollateral = sub(_borrowedCollateral, _orders[orderId].borrowedAmount);\r\n\r\n        _events[order.eventId].totalBorrowed = sub(\r\n            eventById.totalBorrowed,\r\n            order.borrowedAmount\r\n        );\r\n        /* solhint-enable prettier/prettier */\r\n\r\n        _orders[orderId].isPending = false;\r\n\r\n        emit OrderCanceled(orderId, msg.sender);\r\n\r\n        require(\r\n            _collateralToken.transfer(order.orderer, order.ownAmount),\r\n            \"Error transfer\"\r\n        );\r\n    }\r\n\r\n    function withdrawCollateral(address user) external returns (uint256) {\r\n        require(_ordersOfUser[user].length > 0, \"ACCOUNT HAS NO ORDERS\");\r\n\r\n        // total amount of collateral token that should be returned to user\r\n        // feeAmount should be subtracted before actual return\r\n        uint256 totalWithdrawAmount = 0;\r\n\r\n        uint256 i = 0;\r\n        while (i < _ordersOfUser[user].length) {\r\n            uint256 _oId = _ordersOfUser[user][i]; // order ID\r\n            Order memory order = _orders[_oId];\r\n            uint256 _eId = order.eventId; // event ID\r\n            LeverageEvent memory eventDetail = _events[_eId];\r\n\r\n            // calculate and sum up collaterals to be returned\r\n            // exclude canceled orders, only include executed orders\r\n            if (order.isPending && eventDetail.isExecuted) {\r\n                uint256 withdrawAmount = 0;\r\n                uint256 priceAfter = 0;\r\n                uint256 priceBefore = 0;\r\n\r\n                uint256 orderAmount = add(\r\n                    order.ownAmount,\r\n                    order.borrowedAmount\r\n                );\r\n\r\n                if (order.isWhite) {\r\n                    priceBefore = eventDetail.whitePriceBefore;\r\n                    priceAfter = eventDetail.whitePriceAfter;\r\n                } else {\r\n                    priceBefore = eventDetail.blackPriceBefore;\r\n                    priceAfter = eventDetail.blackPriceAfter;\r\n                }\r\n\r\n                withdrawAmount = sub(\r\n                    orderAmount,\r\n                    wmul(orderAmount, _predictionPoolFee)\r\n                );\r\n                withdrawAmount = wdiv(withdrawAmount, priceBefore);\r\n                withdrawAmount = wmul(withdrawAmount, priceAfter);\r\n                withdrawAmount = sub(\r\n                    withdrawAmount,\r\n                    wmul(withdrawAmount, _predictionPoolFee)\r\n                );\r\n                withdrawAmount = sub(withdrawAmount, order.borrowedAmount);\r\n                totalWithdrawAmount = add(totalWithdrawAmount, withdrawAmount);\r\n            }\r\n\r\n            // pop IDs of canceled or executed orders from ordersOfUser array\r\n            if (!_orders[_oId].isPending || eventDetail.isExecuted) {\r\n                delete _ordersOfUser[user][i];\r\n                _ordersOfUser[user][i] = _ordersOfUser[user][\r\n                    _ordersOfUser[user].length - 1\r\n                ];\r\n                _ordersOfUser[user].pop();\r\n\r\n                delete _orders[_oId];\r\n            } else {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit CollateralWithdrew(totalWithdrawAmount, user, msg.sender);\r\n\r\n        require(\r\n            _collateralToken.transfer(user, totalWithdrawAmount),\r\n            \"Error transfer\"\r\n        );\r\n\r\n        return totalWithdrawAmount;\r\n    }\r\n\r\n    function eventStart(uint256 eventId) external onlyEventContract {\r\n        LeverageEvent memory eventById = _events[eventId];\r\n\r\n        eventById.whitePriceBefore = _predictionPool._whitePrice();\r\n        eventById.blackPriceBefore = _predictionPool._blackPrice();\r\n\r\n        (uint256 priceChangePart, ) = getOngoingEvent();\r\n\r\n        require(isPendingEnabled(), \"PENDING ORDERS DISABLED\");\r\n\r\n        require(priceChangePart == _priceChangePart, \"WRONG PRICE CHANGE PART\");\r\n\r\n        eventById.isStarted = true;\r\n\r\n        if (eventById.whiteCollateral > 0) {\r\n            _pendingOrders.createOrder(\r\n                eventById.whiteCollateral,\r\n                true,\r\n                eventId\r\n            );\r\n        }\r\n        if (eventById.blackCollateral > 0) {\r\n            _pendingOrders.createOrder(\r\n                eventById.blackCollateral,\r\n                false,\r\n                eventId\r\n            );\r\n        }\r\n        _events[eventId] = eventById;\r\n    }\r\n\r\n    function eventEnd(uint256 eventId) external onlyEventContract {\r\n        LeverageEvent memory nowEvent = _events[eventId];\r\n\r\n        nowEvent.whitePriceAfter = _predictionPool._whitePrice();\r\n        nowEvent.blackPriceAfter = _predictionPool._blackPrice();\r\n\r\n        nowEvent.isExecuted = true;\r\n\r\n        if ((nowEvent.whiteCollateral > 0) || (nowEvent.blackCollateral > 0)) {\r\n            require(\r\n                _pendingOrders.withdrawCollateral() >= 0,\r\n                \"Error withdraw collateral\"\r\n            );\r\n        }\r\n\r\n        _borrowedCollateral = sub(_borrowedCollateral, nowEvent.totalBorrowed);\r\n\r\n        uint256 fee = wmul(nowEvent.totalBorrowed, _leverageFee);\r\n        _collateralTokens = add(_collateralTokens, fee);\r\n\r\n        _events[eventId] = nowEvent;\r\n    }\r\n\r\n    function getLpRatio() public view returns (uint256) {\r\n        if ((_collateralTokens == _lpTokens) || (_lpTokens == 0)) {\r\n            return 1e18;\r\n        }\r\n        return wdiv(_collateralTokens, _lpTokens);\r\n    }\r\n\r\n    function updateBalances(uint256 collateralAmount, uint256 lpAmount)\r\n        public\r\n        onlyOwner\r\n    {\r\n        _collateralTokens = add(_collateralTokens, collateralAmount);\r\n        _lpTokens = add(_lpTokens, lpAmount);\r\n    }\r\n\r\n    function addLiquidity(uint256 tokensAmount) public {\r\n        require(tokensAmount > 0, \"TOKENS AMOUNT CANNOT BE 0\");\r\n        require(\r\n            _collateralToken.allowance(msg.sender, address(this)) >=\r\n                tokensAmount,\r\n            \"NOT ENOUGH COLLATERAL TOKENS ARE DELEGATED\"\r\n        );\r\n        require(\r\n            _collateralToken.balanceOf(msg.sender) >= tokensAmount,\r\n            \"NOT ENOUGH COLLATERAL TOKENS ON THE USER BALANCE\"\r\n        );\r\n\r\n        uint256 lpRatio = getLpRatio();\r\n        uint256 lpAmount = wdiv(tokensAmount, lpRatio);\r\n\r\n        _collateralTokens = add(_collateralTokens, tokensAmount);\r\n        _lpTokens = add(_lpTokens, lpAmount);\r\n\r\n        _mint(msg.sender, lpAmount);\r\n\r\n        emit AddLiquidity(msg.sender, lpAmount, tokensAmount);\r\n\r\n        require(\r\n            _collateralToken.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                tokensAmount\r\n            ),\r\n            \"Error transfer from\"\r\n        );\r\n    }\r\n\r\n    function withdrawLiquidity(uint256 lpTokensAmount) public {\r\n        require(\r\n            balanceOf[msg.sender] >= lpTokensAmount,\r\n            \"NOT ENOUGH LIQUIDITY TOKENS ON THE USER BALANCE\"\r\n        );\r\n        require(\r\n            allowance[msg.sender][address(this)] >= lpTokensAmount,\r\n            \"NOT ENOUGH LIQUIDITY TOKENS ARE DELEGATED\"\r\n        );\r\n\r\n        uint256 lpRatio = getLpRatio();\r\n        uint256 collateralToSend = wmul(lpTokensAmount, lpRatio);\r\n\r\n        require(\r\n            sub(_collateralTokens, _borrowedCollateral) >= collateralToSend,\r\n            \"NOT ENOUGH FREE COLLATERAL IN THE CONTRACT\"\r\n        );\r\n\r\n        _collateralTokens = sub(_collateralTokens, collateralToSend);\r\n        _lpTokens = sub(_lpTokens, lpTokensAmount);\r\n\r\n        _burn(msg.sender, lpTokensAmount);\r\n\r\n        emit WithdrawLiquidity(msg.sender, lpTokensAmount, collateralToSend);\r\n\r\n        require(\r\n            _collateralToken.transfer(msg.sender, collateralToSend),\r\n            \"Error transfer\"\r\n        );\r\n    }\r\n\r\n    function changeMaxUsageThreshold(uint256 percent) external onlyOwner {\r\n        require(\r\n            percent >= 0.1 * 1e18,\r\n            \"NEW MAX USAGE THRESHOLD SHOULD BE MORE THAN 10%\"\r\n        );\r\n        _maxUsageThreshold = percent;\r\n        emit MaxUsageThresholdChanged(percent);\r\n    }\r\n\r\n    function changeMaxLossThreshold(uint256 percent) external onlyOwner {\r\n        require(\r\n            percent <= 0.5 * 1e18,\r\n            \"NEW MAX LOSS THRESHOLD SHOULD BE LESS THAN 50%\"\r\n        );\r\n        _maxLossThreshold = percent;\r\n        emit MaxLossThresholdChanged(percent);\r\n    }\r\n\r\n    function changePriceChangePart(uint256 priceChangePart) external onlyOwner {\r\n        _priceChangePart = priceChangePart;\r\n        emit PriceChangePartChanged(priceChangePart);\r\n    }\r\n\r\n    function changeLeverageFee(uint256 leverageFee) external onlyOwner {\r\n        _leverageFee = leverageFee;\r\n    }\r\n\r\n    function updatePredictionPoolFee() external onlyOwner {\r\n        _predictionPoolFee = _predictionPool.FEE();\r\n    }\r\n\r\n    function emergencyWithdrawCollateral() public onlyOwner {\r\n        uint256 balance = _collateralToken.balanceOf(address(this));\r\n        require(\r\n            _collateralToken.transfer(msg.sender, balance),\r\n            \"Unable to transfer\"\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pendingOrdersAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"colaterallAmount\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CollateralWithdrew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"MaxLossThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"MaxUsageThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"OrderCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxLoss\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceChangePart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cross\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWhite\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"OrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"PriceChangePartChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"colaterallAmount\",\"type\":\"uint256\"}],\"name\":\"WithdrawLiquidity\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_borrowedCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_collateralToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_collateralTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_eventLifeCycle\",\"outputs\":[{\"internalType\":\"contract IEventLifeCycle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_events\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"whitePriceBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blackPriceBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"whitePriceAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blackPriceAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blackCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"whiteCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isStarted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_leverageFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lpTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxLossThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxUsageThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_orders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"orderer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cross\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ownAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWhite\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPending\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ordersCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_ordersOfUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pendingOrders\",\"outputs\":[{\"internalType\":\"contract IPendingOrders\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_predictionPool\",\"outputs\":[{\"internalType\":\"contract IPredictionPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_predictionPoolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_priceChangePart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowedBorrowLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowedBorrowTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrderByAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"leverageFee\",\"type\":\"uint256\"}],\"name\":\"changeLeverageFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"changeMaxLossThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"changeMaxUsageThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceChangePart\",\"type\":\"uint256\"}],\"name\":\"changePriceChangePart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWhite\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"createOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"eventEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"eventStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLpRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOngoingEvent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPendingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ordersOfUser\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"updateBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePredictionPoolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdrawCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpTokensAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Leverage", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000b2bf74767ed91c022ad137b9b32739e84a761b49", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://48ae97d5b31f8b9cca1f7c5cd83cea2e57ef3c8671c6a942c6cdbedda904c3af"}