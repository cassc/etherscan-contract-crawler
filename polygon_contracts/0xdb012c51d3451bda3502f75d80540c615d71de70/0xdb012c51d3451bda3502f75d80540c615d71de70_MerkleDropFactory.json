{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2022-07-18\r\n*/\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.8.12;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary MerkleLib {\r\n\r\n    function verifyProof(bytes32 root, bytes32 leaf, bytes32[] calldata proof) public pure returns (bool) {\r\n        bytes32 currentHash = leaf;\r\n\r\n        uint proofLength = proof.length;\r\n        for (uint i; i < proofLength;) {\r\n            currentHash = parentHash(currentHash, proof[i]);\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        return currentHash == root;\r\n    }\r\n\r\n    function parentHash(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n        return keccak256(a < b ? abi.encode(a, b) : abi.encode(b, a));\r\n    }\r\n\r\n}\r\n\r\n/// @title A factory pattern for merkledrops, that is, airdrops using merkleproofs to compute eligibility\r\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\r\n/// @notice This contract is permissionless and public facing. Any fees must be included in the data of the merkle tree.\r\n/// @dev The contract cannot introspect into the contents of the merkle tree, except when provided a merkle proof,\r\n/// @dev therefore the total liabilities of the merkle tree are untrusted and tree balances must be managed separately\r\ncontract MerkleDropFactory {\r\n    using MerkleLib for bytes32;\r\n\r\n    // the number of airdrops in this contract\r\n    uint public numTrees;\r\n\r\n    // this represents a single airdrop\r\n    struct MerkleTree {\r\n        bytes32 merkleRoot;  // merkleroot of tree whose leaves are (address,uint) pairs representing amount owed to user\r\n        bytes32 ipfsHash; // ipfs hash of entire dataset, as backup in case our servers turn off...\r\n        address tokenAddress; // address of token that is being airdropped\r\n        uint tokenBalance; // amount of tokens allocated for this tree\r\n        uint spentTokens; // amount of tokens dispensed from this tree\r\n        mapping (bytes32 => bool) withdrawn;\r\n    }\r\n\r\n    // array-like map for all ze merkle trees (airdrops)\r\n    mapping (uint => MerkleTree) public merkleTrees;\r\n\r\n    // every time there's a withdraw\r\n    event WithdrawalOccurred(uint indexed treeIndex, address indexed destination, uint value);\r\n\r\n    // every time a tree is added\r\n    event MerkleTreeAdded(uint indexed treeIndex, address indexed tokenAddress, bytes32 newRoot, bytes32 ipfsHash);\r\n\r\n    // every time a tree is topped up\r\n    event TokensDeposited(uint indexed treeIndex, address indexed tokenAddress, uint amount);\r\n\r\n    error BadTreeIndex(uint treeIndex);\r\n    error LeafAlreadyClaimed(uint treeIndex, bytes32 leafHash);\r\n    error BadProof(uint treeIndex, bytes32 leaf, bytes32[] proof);\r\n    error TokensNotTransferred(uint treeIndex, bytes32 leaf);\r\n\r\n    /// @notice Add a new merkle tree to the contract, creating a new merkle-drop\r\n    /// @dev Anyone may call this function, therefore we must make sure trees cannot affect each other\r\n    /// @param newRoot root hash of merkle tree representing liabilities == (destination, value) pairs\r\n    /// @param ipfsHash the ipfs hash of the entire dataset, used for redundance so that creator can ensure merkleproof are always computable\r\n    /// @param tokenAddress the address of the token contract that is being distributed\r\n    /// @param tokenBalance the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\r\n    function addMerkleTree(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\r\n        // prefix operator ++ increments then evaluates\r\n        MerkleTree storage tree = merkleTrees[++numTrees];\r\n        tree.merkleRoot = newRoot;\r\n        tree.ipfsHash = ipfsHash;\r\n        tree.tokenAddress = tokenAddress;\r\n\r\n        // you don't get to add a tree without funding it\r\n        depositTokens(numTrees, tokenBalance);\r\n        // I guess we should tell people (interfaces) what happened\r\n        emit MerkleTreeAdded(numTrees, tokenAddress, newRoot, ipfsHash);\r\n    }\r\n\r\n    /// @notice Add funds to an existing merkle-drop\r\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\r\n    /// @param treeIndex index into array-like map of merkleTrees\r\n    /// @param value the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\r\n    function depositTokens(uint treeIndex, uint value) public {\r\n        if (treeIndex == 0 || treeIndex > numTrees) {\r\n            revert BadTreeIndex(treeIndex);\r\n        }\r\n        // storage since we are editing\r\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\r\n\r\n        IERC20 token = IERC20(merkleTree.tokenAddress);\r\n        uint balanceBefore = token.balanceOf(address(this));\r\n\r\n        // yes this could fail, but the balance checker will handle that\r\n        // balance checking also handles fee-on-transfer tokens\r\n        // but not malicious tokens, which could lie about balances\r\n        token.transferFrom(msg.sender, address(this), value);\r\n\r\n        uint balanceAfter = token.balanceOf(address(this));\r\n\r\n        uint diff = balanceAfter - balanceBefore;\r\n\r\n        // bookkeeping to make sure trees don't share tokens\r\n        merkleTree.tokenBalance += diff;\r\n\r\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\r\n        // but it does not effect the other trees\r\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, diff);\r\n    }\r\n\r\n    /// @notice Claim funds as a recipient in the merkle-drop\r\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\r\n    /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\r\n    /// @param treeIndex index into array-like map of merkleTrees, which tree should we apply the proof to?\r\n    /// @param destination recipient of tokens\r\n    /// @param value amount of tokens that will be sent to destination\r\n    /// @param proof array of hashes bridging from leaf (hash of destination | value) to merkle root\r\n    function withdraw(uint treeIndex, address destination, uint value, bytes32[] memory proof) public {\r\n        // no withdrawing from uninitialized merkle trees\r\n        if (treeIndex == 0 || treeIndex > numTrees) {\r\n            revert BadTreeIndex(treeIndex);\r\n        }\r\n\r\n        // storage because we edit\r\n        MerkleTree storage tree = merkleTrees[treeIndex];\r\n\r\n        // compute merkle leaf, this is first element of proof\r\n        bytes32 leaf = keccak256(abi.encode(destination, value));\r\n\r\n        // no withdrawing same airdrop twice\r\n        if (tree.withdrawn[leaf]) {\r\n            revert LeafAlreadyClaimed(treeIndex, leaf);\r\n        }\r\n\r\n        // this calls to MerkleLib, will return false if recursive hashes do not end in merkle root\r\n        if (tree.merkleRoot.verifyProof(leaf, proof) == false) {\r\n            revert BadProof(treeIndex, leaf, proof);\r\n        }\r\n\r\n        // close re-entrance gate, prevent double claims\r\n        tree.withdrawn[leaf] = true;\r\n\r\n        IERC20 token = IERC20(tree.tokenAddress);\r\n        uint balanceBefore = token.balanceOf(address(this));\r\n\r\n        // transfer the tokens\r\n        // NOTE: if the token contract is malicious this call could re-enter this function\r\n        // which will fail because withdrawn will be set to true\r\n        // Also if this line silently fails then diff will be 0, reverting whole transaction\r\n        // This also covers the case of fee-on-transfer tokens, but again, not malicious tokens\r\n        token.transfer(destination, value);\r\n\r\n        uint balanceAfter = token.balanceOf(address(this));\r\n        uint diff = balanceBefore - balanceAfter;\r\n        if (diff == 0) {\r\n            revert TokensNotTransferred(treeIndex, leaf);\r\n        }\r\n\r\n        // update struct\r\n        tree.tokenBalance -= diff;\r\n        tree.spentTokens += diff;\r\n\r\n        emit WithdrawalOccurred(treeIndex, destination, value);\r\n    }\r\n\r\n    function getWithdrawn(uint treeIndex, bytes32 leaf) external view returns (bool) {\r\n        return merkleTrees[treeIndex].withdrawn[leaf];\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treeIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"BadProof\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treeIndex\",\"type\":\"uint256\"}],\"name\":\"BadTreeIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treeIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"leafHash\",\"type\":\"bytes32\"}],\"name\":\"LeafAlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treeIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"TokensNotTransferred\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"treeIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"MerkleTreeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"treeIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"treeIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WithdrawalOccurred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"}],\"name\":\"addMerkleTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treeIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"getWithdrawn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleTrees\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spentTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTrees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treeIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MerkleDropFactory", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "MerkleLib:6f67bfc4413fd89db01580dcaaddc4afa4aebbcc", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://82eaeb1de5b99ea3180eb7b05ec6fa13d69629d57826c236f128087b33628647"}