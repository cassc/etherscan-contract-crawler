{"SourceCode": "// File: @chainlink/contracts/src/v0.8/interfaces/VRFV2WrapperInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface VRFV2WrapperInterface {\r\n  /**\r\n   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\r\n   * be relied option within the same transaction that the request was made.\r\n   */\r\n  function lastRequestId() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\r\n   * @notice block.\r\n   *\r\n   * @dev This function relies on the transaction gas price which is not automatically set during\r\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\r\n   *\r\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\r\n   */\r\n  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\r\n   *\r\n   * @dev This is a convenience function that can be called in simulation to better understand\r\n   * @dev pricing.\r\n   *\r\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\r\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\r\n   */\r\n  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n\r\n  function name() external view returns (string memory tokenName);\r\n\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n\r\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\r\n\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/** *******************************************************************************\r\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\r\n * ********************************************************************************\r\n * @dev PURPOSE\r\n *\r\n * @dev Create VRF V2 requests without the need for subscription management. Rather than creating\r\n * @dev and funding a VRF V2 subscription, a user can use this wrapper to create one off requests,\r\n * @dev paying up front rather than at fulfillment.\r\n *\r\n * @dev Since the price is determined using the gas price of the request transaction rather than\r\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\r\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\r\n * *****************************************************************************\r\n * @dev USAGE\r\n *\r\n * @dev Calling contracts must inherit from VRFV2WrapperConsumerBase. The consumer must be funded\r\n * @dev with enough LINK to make the request, otherwise requests will revert. To request randomness,\r\n * @dev call the 'requestRandomness' function with the desired VRF parameters. This function handles\r\n * @dev paying for the request based on the current pricing.\r\n *\r\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\r\n * @dev fulfillment with the randomness result.\r\n */\r\nabstract contract VRFV2WrapperConsumerBase {\r\n  LinkTokenInterface internal immutable LINK;\r\n  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;\r\n\r\n  /**\r\n   * @param _link is the address of LinkToken\r\n   * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract\r\n   */\r\n  constructor(address _link, address _vrfV2Wrapper) {\r\n    LINK = LinkTokenInterface(_link);\r\n    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);\r\n  }\r\n\r\n  /**\r\n   * @dev Requests randomness from the VRF V2 wrapper.\r\n   *\r\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\r\n   *        fulfillRandomWords function.\r\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\r\n   *        request. A higher number of confirmations increases security by reducing the likelihood\r\n   *        that a chain re-org changes a published randomness outcome.\r\n   * @param _numWords is the number of random words to request.\r\n   *\r\n   * @return requestId is the VRF V2 request ID of the newly created randomness request.\r\n   */\r\n  function requestRandomness(\r\n    uint32 _callbackGasLimit,\r\n    uint16 _requestConfirmations,\r\n    uint32 _numWords\r\n  ) internal returns (uint256 requestId) {\r\n    LINK.transferAndCall(\r\n      address(VRF_V2_WRAPPER),\r\n      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),\r\n      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)\r\n    );\r\n    return VRF_V2_WRAPPER.lastRequestId();\r\n  }\r\n\r\n  /**\r\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\r\n   * @notice implement it.\r\n   *\r\n   * @param _requestId is the VRF V2 request ID.\r\n   * @param _randomWords is the randomness result.\r\n   */\r\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\r\n\r\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\r\n    require(msg.sender == address(VRF_V2_WRAPPER), \"only VRF V2 wrapper can fulfill\");\r\n    fulfillRandomWords(_requestId, _randomWords);\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IOwnable {\r\n  function owner() external returns (address);\r\n\r\n  function transferOwnership(address recipient) external;\r\n\r\n  function acceptOwnership() external;\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwnerWithProposal is IOwnable {\r\n  address private s_owner;\r\n  address private s_pendingOwner;\r\n\r\n  event OwnershipTransferRequested(address indexed from, address indexed to);\r\n  event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n  constructor(address newOwner, address pendingOwner) {\r\n    require(newOwner != address(0), \"Cannot set owner to zero\");\r\n\r\n    s_owner = newOwner;\r\n    if (pendingOwner != address(0)) {\r\n      _transferOwnership(pendingOwner);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an owner to begin transferring ownership to a new address,\r\n   * pending.\r\n   */\r\n  function transferOwnership(address to) public override onlyOwner {\r\n    _transferOwnership(to);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an ownership transfer to be completed by the recipient.\r\n   */\r\n  function acceptOwnership() external override {\r\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\r\n\r\n    address oldOwner = s_owner;\r\n    s_owner = msg.sender;\r\n    s_pendingOwner = address(0);\r\n\r\n    emit OwnershipTransferred(oldOwner, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the current owner\r\n   */\r\n  function owner() public view override returns (address) {\r\n    return s_owner;\r\n  }\r\n\r\n  /**\r\n   * @notice validate, transfer ownership, and emit relevant events\r\n   */\r\n  function _transferOwnership(address to) private {\r\n    require(to != msg.sender, \"Cannot transfer to self\");\r\n\r\n    s_pendingOwner = to;\r\n\r\n    emit OwnershipTransferRequested(s_owner, to);\r\n  }\r\n\r\n  /**\r\n   * @notice validate access\r\n   */\r\n  function _validateOwnership() internal view {\r\n    require(msg.sender == s_owner, \"Only callable by owner\");\r\n  }\r\n\r\n  /**\r\n   * @notice Reverts if called by anyone other than the contract owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    _validateOwnership();\r\n    _;\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\r\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\r\n}\r\n\r\n// File: contracts/Random.sol\r\n\r\n\r\n// An example of a consumer contract that directly pays for each request.\r\npragma solidity ^0.8.7;\r\n\r\n\r\n\r\n/**\r\n * Request testnet LINK and ETH here: https://faucets.chain.link/\r\n * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/\r\n */\r\n\r\n/**\r\n * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.\r\n * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.\r\n * DO NOT USE THIS CODE IN PRODUCTION.\r\n */\r\n\r\ncontract VRFv2DirectFundingConsumer is\r\n    VRFV2WrapperConsumerBase,\r\n    ConfirmedOwner\r\n{\r\n    event RequestSent(uint256 requestId, uint32 numWords);\r\n    event RequestFulfilled(\r\n        uint256 requestId,\r\n        uint256[] randomWords,\r\n        uint256 payment\r\n    );\r\n\r\n    struct RequestStatus {\r\n        uint256 paid; // amount paid in link\r\n        bool fulfilled; // whether the request has been successfully fulfilled\r\n        uint256[] randomWords;\r\n    }\r\n    mapping(uint256 => RequestStatus) public s_requests; /* requestId --> requestStatus */\r\n\r\n    // past requests Id.\r\n    uint256[] public requestIds;\r\n    uint256 public lastRequestId;\r\n\r\n    // Depends on the number of requested values that you want sent to the\r\n    // fulfillRandomWords() function. Test and adjust\r\n    // this limit based on the network that you select, the size of the request,\r\n    // and the processing of the callback request in the fulfillRandomWords()\r\n    // function.\r\n    uint32 callbackGasLimit = 100000;\r\n\r\n    // The default is 3, but you can set this higher.\r\n    uint16 requestConfirmations = 3;\r\n\r\n    // For this example, retrieve 2 random values in one request.\r\n    // Cannot exceed VRFV2Wrapper.getConfig().maxNumWords.\r\n    uint32 numWords = 1;\r\n\r\n    // Address LINK - hardcoded for Sepolia\r\n    address linkAddress = 0xb0897686c545045aFc77CF20eC7A532E3120E0F1;\r\n\r\n    // address WRAPPER - hardcoded for Sepolia\r\n    address wrapperAddress = 0x4e42f0adEB69203ef7AaA4B7c414e5b1331c14dc;\r\n\r\n    constructor()\r\n        ConfirmedOwner(msg.sender)\r\n        VRFV2WrapperConsumerBase(linkAddress, wrapperAddress)\r\n    {}\r\n\r\n    function requestRandomWords()\r\n        external\r\n        onlyOwner\r\n        returns (uint256 requestId)\r\n    {\r\n        requestId = requestRandomness(\r\n            callbackGasLimit,\r\n            requestConfirmations,\r\n            numWords\r\n        );\r\n        s_requests[requestId] = RequestStatus({\r\n            paid: VRF_V2_WRAPPER.calculateRequestPrice(callbackGasLimit),\r\n            randomWords: new uint256[](0),\r\n            fulfilled: false\r\n        });\r\n        requestIds.push(requestId);\r\n        lastRequestId = requestId;\r\n        emit RequestSent(requestId, numWords);\r\n        return requestId;\r\n    }\r\n\r\n    function fulfillRandomWords(\r\n        uint256 _requestId,\r\n        uint256[] memory _randomWords\r\n    ) internal override {\r\n        require(s_requests[_requestId].paid > 0, \"request not found\");\r\n        s_requests[_requestId].fulfilled = true;\r\n        s_requests[_requestId].randomWords = _randomWords;\r\n        emit RequestFulfilled(\r\n            _requestId,\r\n            _randomWords,\r\n            s_requests[_requestId].paid\r\n        );\r\n    }\r\n\r\n    function getRequestStatus(uint256 _requestId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 paid,\r\n            bool fulfilled,\r\n            uint256[] memory randomWords\r\n        )\r\n    {\r\n        require(s_requests[_requestId].paid > 0, \"request not found\");\r\n        RequestStatus memory request = s_requests[_requestId];\r\n        return (request.paid, request.fulfilled, request.randomWords);\r\n    }\r\n\r\n    /**\r\n     * Allow withdraw of Link tokens from the contract\r\n     */\r\n    function withdraw(address addr) public onlyOwner {\r\n        LinkTokenInterface link = LinkTokenInterface(linkAddress);\r\n        require(\r\n            link.transfer(addr, link.balanceOf(address(this))),\r\n            \"Unable to transfer\"\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"RequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"}],\"name\":\"RequestSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getRequestStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestRandomWords\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"s_requests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VRFv2DirectFundingConsumer", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://615ff75a6c9e76c24b3d876b03ff2f0f47789bc65391cddf74e0f19ed5b6e1b6"}