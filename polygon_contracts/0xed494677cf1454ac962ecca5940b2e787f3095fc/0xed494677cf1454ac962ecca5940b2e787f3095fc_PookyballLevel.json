{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/game/PookyballLevel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { IPOK } from \\\"../interfaces/IPOK.sol\\\";\\nimport { IPookyball, PookyballMetadata, PookyballRarity } from \\\"../interfaces/IPookyball.sol\\\";\\n\\nstruct Pricing {\\n  uint256 requiredPXP;\\n  uint256 remainingPXP;\\n  uint256 newLevel;\\n  uint256 gapPOK;\\n  uint256 feePOK;\\n}\\n\\ncontract PookyballLevel {\\n  uint256 public constant PXP_DECIMALS = 18;\\n  uint256 public constant BASE_RATIO = 10000;\\n  /// @dev How much PXP is necessary is required to pass to the level 0 => 1.\\n  uint256 public constant BASE_PXP = 60 * 10 ** PXP_DECIMALS;\\n  /// @dev The POK fee is required to pass the level (over 10000).\\n  uint256 public constant FEE_RATIO = 800;\\n  /// @dev Level up POK ratio increase (over 10000).\\n  uint256 public constant LEVEL_RATIO = 10750;\\n  /// @dev How much POK is 1 PXP point (over 10000).\\n  uint256 public constant PXP_POK_RATIO = 1250;\\n  /// @dev How much POK is 1 MATIC point (over 10000).\\n  uint256 public constant MATIC_POK_RATIO = 350;\\n\\n  IPookyball immutable pookyball;\\n  IPOK immutable pok;\\n  address immutable treasury;\\n\\n  mapping(uint256 => uint256) public slots;\\n  mapping(PookyballRarity => uint256) public maxLevel;\\n\\n  /// Thrown when an account tries to level a ball above its maximum level.\\n  error MaximumLevelReached(uint256 tokenId, uint256 maxLevel);\\n  /// Thrown when an account does own enough $POK token to pay the level up fee\\n  error InsufficientPOK(uint256 expected, uint256 actual);\\n  /// Thrown when the native transfer has failed.\\n  error TransferFailed(address recipient, uint256 amount);\\n\\n  constructor(IPookyball _pookyball, IPOK _pok, address _treasury) {\\n    pookyball = _pookyball;\\n    pok = _pok;\\n    treasury = _treasury;\\n\\n    maxLevel[PookyballRarity.COMMON] = 40;\\n    maxLevel[PookyballRarity.RARE] = 60;\\n    maxLevel[PookyballRarity.EPIC] = 80;\\n    maxLevel[PookyballRarity.LEGENDARY] = 100;\\n    maxLevel[PookyballRarity.MYTHIC] = 120;\\n\\n    slots[1] = BASE_PXP;\\n    compute(2, 120);\\n  }\\n\\n  function compute(uint256 from, uint256 to) public {\\n    for (uint256 i = from; i <= to;) {\\n      slots[i] = slots[i - 1] * LEVEL_RATIO / 10000;\\n      unchecked {\\n        i++;\\n      }\\n    }\\n  }\\n\\n  function getPricing(uint256 tokenId, uint256 increase, uint256 value)\\n    public\\n    view\\n    returns (Pricing memory pricing)\\n  {\\n    PookyballMetadata memory metadata = pookyball.metadata(tokenId);\\n\\n    // Ensure the ball does not go over the maximum allowed level\\n    if (metadata.level + increase > maxLevel[metadata.rarity]) {\\n      revert MaximumLevelReached(tokenId, maxLevel[metadata.rarity]);\\n    }\\n\\n    for (uint256 i = 1; i <= increase; i++) {\\n      pricing.requiredPXP += slots[metadata.level + i];\\n    }\\n\\n    if (pricing.requiredPXP > metadata.pxp) {\\n      pricing.gapPOK = (pricing.requiredPXP - metadata.pxp) * PXP_POK_RATIO / BASE_RATIO;\\n    } else {\\n      pricing.remainingPXP = metadata.pxp - pricing.requiredPXP;\\n    }\\n\\n    pricing.feePOK = pricing.requiredPXP * FEE_RATIO / BASE_RATIO;\\n    uint256 coverPOK = value * BASE_RATIO / MATIC_POK_RATIO;\\n\\n    if (pricing.feePOK > coverPOK) {\\n      pricing.feePOK -= coverPOK;\\n    } else {\\n      pricing.feePOK = 0;\\n    }\\n\\n    pricing.newLevel = metadata.level + increase;\\n  }\\n\\n  function levelUp(uint256 tokenId, uint256 increase) external payable {\\n    Pricing memory pricing = getPricing(tokenId, increase, msg.value);\\n    uint256 requiredPOK = pricing.gapPOK + pricing.feePOK;\\n\\n    uint256 balancePOK = pok.balanceOf(msg.sender);\\n    if (requiredPOK > balancePOK) {\\n      revert InsufficientPOK(requiredPOK, balancePOK);\\n    }\\n\\n    // Burn $POK tokens\\n    pok.burn(msg.sender, requiredPOK);\\n\\n    // Reset the ball PXP\\n    pookyball.setPXP(tokenId, pricing.remainingPXP);\\n    // Increment the ball level\\n    pookyball.setLevel(tokenId, pricing.newLevel);\\n\\n    if (msg.value > 0) {\\n      // Forward the funds to the treasury wallet\\n      (bool sent,) = treasury.call{ value: msg.value }(\\\"\\\");\\n      if (!sent) {\\n        revert TransferFailed(treasury, msg.value);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPOK.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Pooky Game Contracts (interfaces/IPOK.sol)\\npragma solidity ^0.8.17;\\n\\nimport \\\"openzeppelin/access/IAccessControl.sol\\\";\\nimport \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title IPOK\\n * @author Mathieu Bour\\n * @notice Minimal $POK ERC20 token interface.\\n */\\ninterface IPOK is IAccessControl, IERC20 {\\n  /**\\n   * @notice Mint an arbitrary amount of $POK to an account.\\n   * @dev Requirements:\\n   * - only MINTER role can mint $POK tokens\\n   */\\n  function mint(address to, uint256 amount) external;\\n\\n  /**\\n   * @notice Burn an arbitrary amount of $POK of an sender account.\\n   * It is acknowledged that burning directly from the user wallet is anti-pattern\\n   * but since $POK is soulbounded, this allow to skip the ERC20 approve call.\\n   * @dev Requirements:\\n   * - only BURNER role can burn $POK tokens\\n   */\\n  function burn(address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPookyball.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Pooky Game Contracts (interfaces/IPookyball.sol)\\npragma solidity ^0.8.17;\\n\\nimport \\\"openzeppelin/access/IAccessControl.sol\\\";\\nimport \\\"openzeppelin/token/ERC721/IERC721.sol\\\";\\nimport \\\"openzeppelin/interfaces/IERC2981.sol\\\";\\n\\n/**\\n * @title PookyballMetadata\\n * @notice The Pookyball rarities are represented on chain by this enum.\\n */\\nenum PookyballRarity {\\n  COMMON,\\n  RARE,\\n  EPIC,\\n  LEGENDARY,\\n  MYTHIC\\n}\\n\\n/**\\n * @title PookyballMetadata\\n * @notice Pookyballs NFT have the following features:\\n * - rarity: integer enum.\\n * - level: token level, can be increase by spending token experiences points (PXP).\\n * - pxp: token experience points.\\n * - seed: a random uint256 word provided by Chainlink VRF service that will be used by Pooky's NFT generator\\n *     back-end to generate the NFT visuals and in-game statistics\\\\.\\n */\\nstruct PookyballMetadata {\\n  PookyballRarity rarity;\\n  uint256 level;\\n  uint256 pxp;\\n  uint256 seed;\\n}\\n\\n/**\\n * @title IPookyball\\n * @author Mathieu Bour\\n * @notice Minimal Pookyball interface.\\n */\\ninterface IPookyball is IAccessControl, IERC2981, IERC721 {\\n  /// Fired when the seed of a Pookyball token is set by the VRFCoordinator\\n  event SeedSet(uint256 indexed tokenId, uint256 seed);\\n  /// Fired when the level of a Pookyball token is changed\\n  event LevelChanged(uint256 indexed tokenId, uint256 level);\\n  /// Fired when the PXP of a Pookyball token is changed\\n  event PXPChanged(uint256 indexed tokenId, uint256 amount);\\n\\n  /// Thrown when the length of two parameters mismatch. Used in the mint batched function.\\n  error ArgumentSizeMismatch(uint256 x, uint256 y);\\n\\n  /**\\n   * @notice PookyballMetadata of the token {tokenId}.\\n   * @dev Requirements:\\n   * - Pookyball {tokenId} should exist (minted and not burned).\\n   */\\n  function metadata(uint256 tokenId) external view returns (PookyballMetadata memory);\\n\\n  /**\\n   * @notice Change the secondary sale royalties receiver address.\\n   */\\n  function setERC2981Receiver(address newReceiver) external;\\n\\n  /**\\n   * @notice Mint a new Pookyball token with a given rarity.\\n   */\\n  function mint(address[] memory recipients, PookyballRarity[] memory rarities)\\n    external\\n    returns (uint256);\\n\\n  /**\\n   * @notice Change the level of a Pookyball token.\\n   * @dev Requirements:\\n   * - Pookyball {tokenId} should exist (minted and not burned).\\n   */\\n  function setLevel(uint256 tokenId, uint256 newLevel) external;\\n\\n  /**\\n   * @notice Change the PXP of a Pookyball token.\\n   * @dev Requirements:\\n   * - Pookyball {tokenId} should exist (minted and not burned).\\n   */\\n  function setPXP(uint256 tokenId, uint256 newPXP) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/operator-filter-registry/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"operator-filter-registry/=lib/operator-filter-registry/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solmate/=lib/solady/lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IPookyball\",\"name\":\"_pookyball\",\"type\":\"address\"},{\"internalType\":\"contract IPOK\",\"name\":\"_pok\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InsufficientPOK\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLevel\",\"type\":\"uint256\"}],\"name\":\"MaximumLevelReached\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BASE_PXP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LEVEL_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MATIC_POK_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PXP_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PXP_POK_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"compute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"increase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getPricing\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requiredPXP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingPXP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gapPOK\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePOK\",\"type\":\"uint256\"}],\"internalType\":\"struct Pricing\",\"name\":\"pricing\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"increase\",\"type\":\"uint256\"}],\"name\":\"levelUp\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum PookyballRarity\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"maxLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"slots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PookyballLevel", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b4859acd9b0a65ca4897c31e5cb5160d9ff32c0a0000000000000000000000007b7e3b03f34b17d70c276c4886467d58867bbc94000000000000000000000000703662853d7f9ad9d8c44128222266a736741437", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}