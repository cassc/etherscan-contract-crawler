{"SourceCode": "// SPDX-License-Identifier: GPL 3\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ncontract TokenAccessControl {\r\n    bool public paused = false;\r\n    address public owner;\r\n    address public newContractOwner;\r\n    mapping(address => bool) public authorizedContracts;\r\n\r\n    event Pause();\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier ifNotPaused() {\r\n        require(!paused, \"contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"caller is not an owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorizedUser() {\r\n        require(\r\n            authorizedContracts[msg.sender],\r\n            \"caller is not an authorized user\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrAuthorizedUser() {\r\n        require(\r\n            authorizedContracts[msg.sender] || msg.sender == owner,\r\n            \"caller is not an authorized user or an owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        newContractOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public ifNotPaused {\r\n        require(msg.sender == newContractOwner);\r\n        emit OwnershipTransferred(owner, newContractOwner);\r\n        owner = newContractOwner;\r\n        newContractOwner = address(0);\r\n    }\r\n\r\n    function setAuthorizedUser(\r\n        address _operator,\r\n        bool _approve\r\n    ) public onlyOwner {\r\n        if (_approve) {\r\n            authorizedContracts[_operator] = true;\r\n        } else {\r\n            delete authorizedContracts[_operator];\r\n        }\r\n    }\r\n\r\n    function setPause(bool _paused) public onlyOwner {\r\n        paused = _paused;\r\n        if (paused) {\r\n            emit Pause();\r\n        }\r\n    }\r\n}\r\n\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\ninterface IERC2981 is IERC165 {\r\n    function royaltyInfo(\r\n        uint256 tokenId,\r\n        uint256 salePrice\r\n    ) external view returns (address receiver, uint256 royaltyAmount);\r\n}\r\n\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\nabstract contract ERC2981 is IERC2981, ERC165 {\r\n    struct RoyaltyInfo {\r\n        address receiver;\r\n        uint96 royaltyFraction;\r\n    }\r\n\r\n    RoyaltyInfo private _defaultRoyaltyInfo;\r\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\r\n\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\r\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual override returns (address, uint256) {\r\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenId];\r\n\r\n        if (royalty.receiver == address(0)) {\r\n            royalty = _defaultRoyaltyInfo;\r\n        }\r\n\r\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\r\n\r\n        return (royalty.receiver, royaltyAmount);\r\n    }\r\n\r\n    function _feeDenominator() internal pure virtual returns (uint96) {\r\n        return 10000;\r\n    }\r\n\r\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\r\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\r\n        require(receiver != address(0), \"ERC2981: invalid receiver\");\r\n\r\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\r\n    }\r\n\r\n    function _deleteDefaultRoyalty() internal virtual {\r\n        delete _defaultRoyaltyInfo;\r\n    }\r\n\r\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\r\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\r\n        require(receiver != address(0), \"ERC2981: Invalid parameters\");\r\n\r\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\r\n    }\r\n\r\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\r\n        delete _tokenRoyaltyInfo[tokenId];\r\n    }\r\n}\r\n\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\ninterface IERC1155 is IERC165 {\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\ncontract ERC1155 is ERC165, IERC1155{\r\n    string private _uri;\r\n\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n    mapping(uint256 => mapping(address => uint256)) private _balances;\r\n\r\n\r\n    constructor(string memory uri_) {\r\n        _setURI(uri_);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n    function uri(uint256) public view returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    function balanceOf(address account, uint256 id) public view virtual returns (uint256) {\r\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\r\n        return _balances[id][account];\r\n    }\r\n\r\n    function _setBalance(address account, uint256 id, uint256 amount) internal {\r\n        _balances[id][account] = amount;\r\n    }\r\n\r\n    function balanceOfBatch(address[] memory accounts,uint256[] memory ids)\r\n     public view virtual override returns (uint256[] memory) {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n        return batchBalances;\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        _setApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address account, address operator) public view virtual returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual {\r\n        require(\r\n            from == msg.sender || isApprovedForAll(from, msg.sender),\r\n            \"ERC1155: caller is not token owner or approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual {\r\n        require(\r\n            from == msg.sender || isApprovedForAll(from, msg.sender),\r\n            \"ERC1155: caller is not token owner or approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        _balances[id][to] += amount;\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n            _balances[id][to] += amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n        address operator = msg.sender;\r\n        _balances[id][to] += amount;\r\n        emit TransferSingle(operator, address(0), to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\r\n    }\r\n    function _mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][to] += amounts[i];\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n\r\n        address operator = msg.sender;\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n        uint256[] memory amounts = _asSingletonArray(amount);\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n\r\n        emit TransferSingle(operator, from, address(0), id, amount);\r\n\r\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n    }\r\n\r\n\r\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(operator, from, address(0), ids, amounts);\r\n\r\n    }\r\n\r\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\r\n        require(owner != operator, \"ERC1155: setting approval status for self\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        if (isContract(to)) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (isContract(to)) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\r\n                bytes4 response\r\n            ) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract CC_GameAccess is ERC1155, ERC2981, TokenAccessControl {\r\n    string private _contractUri;\r\n\r\n    constructor(string memory uri_, string memory contractUri_) ERC1155(uri_){\r\n        _contractUri = contractUri_;\r\n    }\r\n\r\n    function contractURI() public view returns (string memory) {\r\n        return _contractUri;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155, ERC2981) returns (bool) {\r\n        return ERC1155.supportsInterface(interfaceId) ||  ERC2981.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function setDefaultRoyalty(address receiver, uint96 feeNumerator) public onlyOwner{\r\n        _setDefaultRoyalty(receiver, feeNumerator);\r\n    }\r\n\r\n    function setUri(string memory uri) public onlyOwner{\r\n        _setURI(uri);\r\n    }\r\n\r\n    function setContractUri(string memory contractUri) public onlyOwner{\r\n        _contractUri = contractUri;\r\n    }\r\n\r\n    function mintTo(address to, uint256 tokenId, uint256 amount) public onlyOwnerOrAuthorizedUser{\r\n        _mint(to, tokenId, amount, \"\");\r\n    }\r\n\r\n    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts) public onlyOwnerOrAuthorizedUser{\r\n        _mintBatch(to, ids, amounts, \"\");\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractUri_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"mintBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newContractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approve\",\"type\":\"bool\"}],\"name\":\"setAuthorizedUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractUri\",\"type\":\"string\"}],\"name\":\"setContractUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeNumerator\",\"type\":\"uint96\"}],\"name\":\"setDefaultRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CC_GameAccess", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000003a68747470733a2f2f6e6674732e7472616465726163656d616e616765722e636f6d2f63632f67616d655f6163636573732f7b69647d2e6a736f6e00000000000000000000000000000000000000000000000000000000000000000000000000036e2f610000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4f36458590896aba75e63ed481c4f58b0e1fc6679be4acc7d1f83bf5e5971f8b"}