{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Binary/BinarySystemContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\\\";\\r\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\\\";\\r\\n\\r\\ninterface ISTX {\\r\\n    function burn(uint256 amount) external;\\r\\n}\\r\\n\\r\\ncontract BinarySystemContract is Ownable {\\r\\n    event ActivateEvent(\\r\\n        address sender,\\r\\n        address parent,\\r\\n        uint256 burnAmount,\\r\\n        string record\\r\\n    );\\r\\n\\r\\n    event PurchaseEvent(\\r\\n        address sender,\\r\\n        address parent,\\r\\n        uint256 star,\\r\\n        uint256 burnAmount,\\r\\n        string record\\r\\n    );\\r\\n\\r\\n    ISwapRouter public immutable swapRouter;\\r\\n\\r\\n    // Declare public variables\\r\\n    address public usdtToken;\\r\\n    address public stxToken;\\r\\n    address public adminA;\\r\\n    address public adminB;\\r\\n    address public adminC;\\r\\n    address public adminD;\\r\\n    address public adminE;\\r\\n    address public pool;\\r\\n\\r\\n    uint public registerContractPercent = 0;\\r\\n    uint public repurchaseContractPercent = 0;\\r\\n\\r\\n    uint24 private poolFee = 3000;\\r\\n\\r\\n    // Constructor\\r\\n    constructor(\\r\\n        address _usdtToken,\\r\\n        address _stxToken,\\r\\n        address _adminA,\\r\\n        address _adminB,\\r\\n        address _adminC,\\r\\n        address _adminD,\\r\\n        address _adminE,\\r\\n        address _pool,\\r\\n        ISwapRouter _swapRouter\\r\\n    ) {\\r\\n        usdtToken = _usdtToken;\\r\\n        stxToken = _stxToken;\\r\\n        adminA = _adminA;\\r\\n        adminB = _adminB;\\r\\n        adminC = _adminC;\\r\\n        adminD = _adminD;\\r\\n        adminE = _adminE;\\r\\n        pool = _pool;\\r\\n        swapRouter = _swapRouter;\\r\\n    }\\r\\n\\r\\n    function activate(address parent, string memory record) external {\\r\\n        require(\\r\\n            IERC20(usdtToken).balanceOf(msg.sender) >= 110000000,\\r\\n            \\\"Amount is not enough!\\\"\\r\\n        );\\r\\n\\r\\n        uint contractAmount = 5000000 +\\r\\n            (45000000 * registerContractPercent) /\\r\\n            100;\\r\\n        uint adminAAmount = 5000000 +\\r\\n            (45000000 * (100 - registerContractPercent)) /\\r\\n            100;\\r\\n\\r\\n        IERC20(usdtToken).transferFrom(msg.sender, parent, 50000000);\\r\\n        IERC20(usdtToken).transferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            contractAmount\\r\\n        );\\r\\n\\r\\n        IERC20(usdtToken).transferFrom(msg.sender, adminA, adminAAmount);\\r\\n        IERC20(usdtToken).transferFrom(msg.sender, adminB, 5000000);\\r\\n        // BBAB\\r\\n        uint256 amountIn = 5000000;\\r\\n        TransferHelper.safeApprove(usdtToken, address(swapRouter), amountIn);\\r\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\\r\\n            .ExactInputSingleParams({\\r\\n                tokenIn: usdtToken,\\r\\n                tokenOut: stxToken,\\r\\n                fee: poolFee,\\r\\n                recipient: address(this),\\r\\n                deadline: block.timestamp,\\r\\n                amountIn: amountIn,\\r\\n                amountOutMinimum: 0,\\r\\n                sqrtPriceLimitX96: 0\\r\\n            });\\r\\n\\r\\n        uint outAmount = swapRouter.exactInputSingle(params);\\r\\n        ISTX(stxToken).burn(outAmount);\\r\\n        // Log\\r\\n        emit ActivateEvent(msg.sender, parent, outAmount, record);\\r\\n    }\\r\\n\\r\\n    function repurchase(\\r\\n        uint star,\\r\\n        address parent,\\r\\n        string memory record\\r\\n    ) external {\\r\\n        uint purchaseAmount = 0;\\r\\n\\r\\n        if (star == 1) purchaseAmount = 110000000;\\r\\n        else if (star == 2) purchaseAmount = 330000000;\\r\\n        else if (star == 3) purchaseAmount = 550000000;\\r\\n        else if (star == 4) purchaseAmount = 1100000000;\\r\\n        else if (star == 5) purchaseAmount = 3300000000;\\r\\n        else if (star == 6) purchaseAmount = 5500000000;\\r\\n\\r\\n        require(purchaseAmount > 0, \\\"Star is not validated!\\\");\\r\\n        require(\\r\\n            IERC20(usdtToken).balanceOf(msg.sender) >= purchaseAmount,\\r\\n            \\\"Amount is not enough\\\"\\r\\n        );\\r\\n\\r\\n        IERC20(usdtToken).transferFrom(msg.sender, parent, purchaseAmount / 11);\\r\\n        IERC20(usdtToken).transferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            (purchaseAmount *\\r\\n                5 +\\r\\n                (purchaseAmount * 75 * repurchaseContractPercent) /\\r\\n                100) / 110\\r\\n        );\\r\\n\\r\\n        if (repurchaseContractPercent != 100) {\\r\\n            IERC20(usdtToken).transferFrom(\\r\\n                msg.sender,\\r\\n                adminA,\\r\\n                ((purchaseAmount * 75 * (100 - repurchaseContractPercent)) /\\r\\n                    100) / 110\\r\\n            );\\r\\n        }\\r\\n\\r\\n        IERC20(usdtToken).transferFrom(\\r\\n            msg.sender,\\r\\n            adminC,\\r\\n            (purchaseAmount * 15) / 110\\r\\n        );\\r\\n        IERC20(usdtToken).transferFrom(\\r\\n            msg.sender,\\r\\n            adminD,\\r\\n            (purchaseAmount * 5) / 110\\r\\n        );\\r\\n        // BBAB\\r\\n        uint256 amountIn = (purchaseAmount * 5) / 110;\\r\\n        TransferHelper.safeApprove(usdtToken, address(swapRouter), amountIn);\\r\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\\r\\n            .ExactInputSingleParams({\\r\\n                tokenIn: usdtToken,\\r\\n                tokenOut: stxToken,\\r\\n                fee: poolFee,\\r\\n                recipient: address(this),\\r\\n                deadline: block.timestamp,\\r\\n                amountIn: amountIn,\\r\\n                amountOutMinimum: 0,\\r\\n                sqrtPriceLimitX96: 0\\r\\n            });\\r\\n\\r\\n        uint outAmount = swapRouter.exactInputSingle(params);\\r\\n        ISTX(stxToken).burn(outAmount);\\r\\n        // Log\\r\\n        emit PurchaseEvent(msg.sender, parent, star, outAmount, record);\\r\\n    }\\r\\n\\r\\n    function runUnilevelBonus(uint256 count) external onlyOwner {\\r\\n        require(count > 0, \\\"Count should be bigger than zero\\\");\\r\\n        require(\\r\\n            IERC20(usdtToken).balanceOf(address(this)) >= 10000000 * count,\\r\\n            \\\"Amount is not enough!\\\"\\r\\n        );\\r\\n\\r\\n        IERC20(usdtToken).transfer(adminE, 5000000 * count);\\r\\n        // BBAB\\r\\n        uint256 amountIn = 5000000 * count;\\r\\n        TransferHelper.safeApprove(usdtToken, address(swapRouter), amountIn);\\r\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\\r\\n            .ExactInputSingleParams({\\r\\n                tokenIn: usdtToken,\\r\\n                tokenOut: stxToken,\\r\\n                fee: poolFee,\\r\\n                recipient: address(this),\\r\\n                deadline: block.timestamp,\\r\\n                amountIn: amountIn,\\r\\n                amountOutMinimum: 0,\\r\\n                sqrtPriceLimitX96: 0\\r\\n            });\\r\\n\\r\\n        uint outAmount = swapRouter.exactInputSingle(params);\\r\\n        ISTX(stxToken).burn(outAmount);\\r\\n    }\\r\\n\\r\\n    function withdrawTokenFromContract(\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        address receiver\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            IERC20(token).balanceOf(address(this)) >= amount,\\r\\n            \\\"token amount is not enough!\\\"\\r\\n        );\\r\\n        IERC20(token).transfer(receiver, amount);\\r\\n    }\\r\\n\\r\\n    function setRegisterContractPercent(uint percent) external onlyOwner {\\r\\n        require(percent <= 100, \\\"should be less than 100!\\\");\\r\\n        registerContractPercent = percent;\\r\\n    }\\r\\n\\r\\n    function setRepurchaseContractPercent(uint percent) external onlyOwner {\\r\\n        require(percent <= 100, \\\"should be less than 100!\\\");\\r\\n        repurchaseContractPercent = percent;\\r\\n    }\\r\\n\\r\\n    function getSTXPrice() external view returns (uint256) {\\r\\n        uint usdtAmountOfPool = IERC20(usdtToken).balanceOf(pool);\\r\\n        uint stxAmountOfPool = IERC20(stxToken).balanceOf(pool);\\r\\n\\r\\n        uint stxPrice = (usdtAmountOfPool * 100000 * 1000000000000) /\\r\\n            stxAmountOfPool;\\r\\n        return stxPrice;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stxToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminC\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminD\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminE\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"contract ISwapRouter\",\"name\":\"_swapRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"record\",\"type\":\"string\"}],\"name\":\"ActivateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"star\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"record\",\"type\":\"string\"}],\"name\":\"PurchaseEvent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"record\",\"type\":\"string\"}],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSTXPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerContractPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"star\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"record\",\"type\":\"string\"}],\"name\":\"repurchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repurchaseContractPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"runUnilevelBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setRegisterContractPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setRepurchaseContractPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stxToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdrawTokenFromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BinarySystemContract", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f000000000000000000000000bc1dc97fc85e8034eb73e286dd4f6595db5b7dfd0000000000000000000000004929065f1d256a83ab4d76252e5ce93ea7a45580000000000000000000000000bf3b49cd5d719e3342eb46433727f3894d8da4d7000000000000000000000000a9c535dea71fd9bbda9122207ba833f58536b0cc000000000000000000000000a2eafa5ad35ef9048d54afcf8605418568f7d3f9000000000000000000000000a8c6b82a88023eed40a92fdb889fed21bb65179c0000000000000000000000005bf5da329935735149d07779f3d14abd381e2890000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}