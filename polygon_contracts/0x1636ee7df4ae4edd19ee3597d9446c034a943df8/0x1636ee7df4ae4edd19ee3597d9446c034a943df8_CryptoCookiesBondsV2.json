{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Bonds.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\nimport {IERC20} from \\\"openzeppelin-contracts/token/ERC20/IERC20.sol\\\";\\nimport {IOracleSimple} from \\\"./interfaces/IOracleSimple.sol\\\";\\n\\ninterface IERC20Burneable is IERC20 {\\n    function burn(uint256 amount) external;\\n}\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n}\\n\\ninterface IBondManagerStrategy {\\n    function run() external;\\n}\\n\\n/// @title Sugar Bonds\\n/// @notice Bonds mechanism to sell $CKIE at a fixed price for $WMATIC, and vested in vestingDays days\\ncontract CryptoCookiesBondsV2 is Owned(msg.sender) {\\n    error errWrongDiscount();\\n\\n    event BondTermsStart(uint128 indexed uid, Bond bond, string details);\\n    event BondTermsEnd(uint128 indexed uid, uint256 cookieRemains);\\n\\n    event NoteAdded(address indexed owner, uint256 indexed noteId, uint256 amountMATIC, uint256 cookiesForUser);\\n    event NoteRedeem(address indexed owner, uint256 indexed noteId, uint256 redeemAmount);\\n\\n    struct Bond {\\n        uint128 uid;\\n        uint40 bondStart;\\n        uint16 vestingDays;\\n        uint24 startDiscount;\\n        uint24 endDiscount;\\n        uint16 dailyDiscount;\\n        uint8 disabled;\\n        uint128 bondedCookies;\\n        uint128 cookiesToBond;\\n        address bondManagerStrategy;\\n    }\\n\\n    struct Note {\\n        uint256 uid;\\n        uint128 uidBond;\\n        uint40 timestampStart;\\n        uint40 timestampLastRedeem;\\n        uint40 timestampEnd;\\n        uint128 paid;\\n        uint128 totalCookies;\\n        address owner;\\n    }\\n\\n    /// @dev base percentage 1e6 = 100%\\n    uint256 constant BASE_PERC = 100_0000;\\n\\n    uint256 constant BASE_ETH = 1 ether;\\n\\n    uint128 private _totalBonds;\\n    uint256 private _noteIdCounter;\\n\\n    ///@dev CKIE\\n    IERC20Burneable public immutable COOKIETOKEN;\\n    ///@dev WMATIC\\n    address public immutable WMATIC;\\n    ///@dev TWAP oracle for CKIE price against WMATIC\\n    IOracleSimple public immutable ORACLE;\\n\\n    address public immutable GAME;\\n\\n    mapping(uint128 => Bond) public bonds;\\n    mapping(uint128 => Note) public notes;\\n    mapping(address => uint128[]) public toNotes;\\n\\n    ///@dev list of active bonds\\n    uint128[] public activeBonds;\\n\\n    constructor(address _cookieToken, address _wmatic, address _oracleSimple, address _game) {\\n        COOKIETOKEN = IERC20Burneable(_cookieToken);\\n        WMATIC = _wmatic;\\n        ORACLE = IOracleSimple(_oracleSimple);\\n        GAME = _game;\\n    }\\n\\n    /// @notice Withdraw a token or ether stuck in the contract\\n    /// @param token Address of the ERC20 to withdraw, use address 0 for MATIC\\n    /// @param amount amount of token to withdraw\\n    function withdraw(address token, uint256 amount) external onlyOwner {\\n        ///@dev cant withdraw CKIE\\n        if (token == address(COOKIETOKEN)) {\\n            revert();\\n        }\\n\\n        if (token == address(0)) {\\n            SafeTransferLib.safeTransferETH(msg.sender, amount);\\n        } else {\\n            ///@dev no need for safeTransfer\\n            IERC20(token).transfer(msg.sender, amount);\\n        }\\n    }\\n\\n    /// @notice Explain to an end user what this does\\n    /// @param _vestingDays number of day for vesting the bond\\n    /// @param _startDiscount BPS discount start (recommend 0)\\n    /// @param _endDiscount BPS discount max\\n    /// @param _dailyDiscount daily BPS discount\\n    /// @param _cookiesToBond amount of CKIE to sell\\n    /// @param _bondManagerStrategy address of the contract that will manage the WMATIC\\n    /// @param details string details of the bond (for graphql)\\n    function startBondSell(\\n        uint16 _vestingDays,\\n        uint24 _startDiscount,\\n        uint24 _endDiscount,\\n        uint16 _dailyDiscount,\\n        uint128 _cookiesToBond,\\n        address _bondManagerStrategy,\\n        string memory details\\n    ) external onlyOwner {\\n        require(_cookiesToBond > 0, \\\"No cookies to bond\\\");\\n        if (_startDiscount > _endDiscount) {\\n            revert errWrongDiscount();\\n        }\\n\\n        uint128 bondUid;\\n        // Sumo 101% del _cookiesToBond, ya que 1% es para devs\\n        (bool success,) = GAME.call(abi.encodeWithSignature(\\\"sugarBondMint(uint256)\\\", (_cookiesToBond * 101) / 100));\\n        require(success, \\\"Bond mint failed\\\");\\n\\n        unchecked {\\n            bondUid = ++_totalBonds;\\n        }\\n\\n        activeBonds.push(bondUid);\\n\\n        emit BondTermsStart(\\n            bondUid,\\n            bonds[bondUid] = Bond({\\n                uid: bondUid,\\n                bondStart: uint40(block.timestamp),\\n                vestingDays: _vestingDays,\\n                startDiscount: _startDiscount,\\n                endDiscount: _endDiscount,\\n                dailyDiscount: _dailyDiscount,\\n                disabled: 0,\\n                bondedCookies: 0,\\n                cookiesToBond: _cookiesToBond,\\n                bondManagerStrategy: _bondManagerStrategy\\n            }),\\n            details\\n            );\\n    }\\n\\n    /// @notice end a bond sell\\n    /// @dev this function will end the bond and burn the remaining cookies\\n    /// @param uid bond uid\\n    function endBondSell(uint128 uid) external onlyOwner {\\n        _endBondSell(uid);\\n    }\\n\\n    function _endBondSell(uint128 uid) private {\\n        Bond memory _bond = bonds[uid];\\n        require(_bond.disabled == 0, \\\"Bond is terminated\\\");\\n        uint256 cookieRemains = _bond.cookiesToBond - _bond.bondedCookies;\\n        if (cookieRemains > 0) {\\n            COOKIETOKEN.burn(cookieRemains);\\n        }\\n        bonds[uid].disabled = 1;\\n\\n        uint128[] storage _activeBonds = activeBonds;\\n        uint256 len = _activeBonds.length;\\n\\n        unchecked {\\n            uint256 pos;\\n            while (true) {\\n                if (_activeBonds[pos] == uid) {\\n                    break;\\n                }\\n                ++pos;\\n            }\\n\\n            if (len - 1 != pos) {\\n                _activeBonds[pos] = _activeBonds[len - 1];\\n            }\\n        }\\n\\n        _activeBonds.pop();\\n\\n        emit BondTermsEnd(uid, cookieRemains);\\n    }\\n\\n    function buyBond(uint128 uid) external payable {\\n        Bond storage _bond = bonds[uid];\\n        require(_bond.cookiesToBond > 0, \\\"The bond was ended\\\");\\n        require(_bond.disabled < 1, \\\"Bond is terminated\\\");\\n\\n        // update oracle if needed\\n        ORACLE.update();\\n\\n        uint128 value = uint128(msg.value);\\n        uint16 vestingDays = _bond.vestingDays;\\n\\n        uint128 discountPrice = priceOfCookieWithDiscount(uid);\\n        uint128 cookiesForUser = (value * uint128(BASE_ETH)) / discountPrice;\\n\\n        uint128 cookieRemains = _bond.cookiesToBond - _bond.bondedCookies;\\n        if (cookieRemains <= cookiesForUser) {\\n            cookiesForUser = cookieRemains;\\n            value = (cookieRemains * discountPrice) / uint128(BASE_ETH);\\n        }\\n        bonds[uid].bondedCookies += uint128(cookiesForUser);\\n\\n        // @dev 100% / 100 = 1%, 1% for devs\\n        uint256 forDev = cookiesForUser / 100;\\n        COOKIETOKEN.transfer(owner, forDev);\\n\\n        uint128 noteUid;\\n        unchecked {\\n            noteUid = uint128(++_noteIdCounter);\\n\\n            notes[noteUid] = Note({\\n                uid: noteUid,\\n                uidBond: _bond.uid,\\n                timestampStart: uint40(block.timestamp),\\n                timestampLastRedeem: uint40(block.timestamp),\\n                timestampEnd: uint40(block.timestamp + vestingDays * 1 days),\\n                paid: 0,\\n                totalCookies: cookiesForUser,\\n                owner: msg.sender\\n            });\\n        }\\n\\n        toNotes[msg.sender].push(noteUid);\\n\\n        /// @dev wrap MATIC\\n        IWETH(WMATIC).deposit{value: value}();\\n        IERC20(WMATIC).transfer(_bond.bondManagerStrategy, value);\\n\\n        // ignore return\\n        _bond.bondManagerStrategy.call(abi.encodeWithSignature(\\\"run()\\\"));\\n\\n        emit NoteAdded(msg.sender, noteUid, value, cookiesForUser);\\n\\n        if (_bond.cookiesToBond == _bond.bondedCookies) {\\n            _endBondSell(uid);\\n        }\\n\\n        if (value < msg.value) {\\n            unchecked {\\n                SafeTransferLib.safeTransferETH(msg.sender, msg.value - value);\\n            }\\n        }\\n    }\\n\\n    /// @notice Redeem all bonds for msg.sender\\n    function redeemAll() external {\\n        uint128[] memory _notes = toNotes[msg.sender];\\n        uint256 len = _notes.length;\\n        unchecked {\\n            while (len > 0) {\\n                redeem(_notes[--len]);\\n            }\\n        }\\n    }\\n\\n    function redeem(uint128 noteId) public returns (bool resize) {\\n        Note storage note = notes[noteId];\\n        require(note.owner == msg.sender, \\\"!noteOwner\\\");\\n\\n        uint256 redeemAmount = _toRedeem(noteId);\\n\\n        if (redeemAmount == 0) {\\n            revert();\\n        }\\n\\n        note.timestampLastRedeem = uint40(block.timestamp);\\n        unchecked {\\n            note.paid += uint128(redeemAmount);\\n        }\\n\\n        if (note.paid == note.totalCookies) {\\n            _deleteNote(msg.sender, noteId);\\n            resize = true;\\n        }\\n\\n        COOKIETOKEN.transfer(msg.sender, redeemAmount);\\n        emit NoteRedeem(msg.sender, noteId, redeemAmount);\\n    }\\n\\n    function getNote(address account, uint256 index) external view returns (Note memory) {\\n        return notes[toNotes[account][index]];\\n    }\\n\\n    function getNotes(address account) external view returns (Note[] memory) {\\n        uint256 len = toNotes[account].length;\\n        Note[] memory ret = new Note[](len);\\n        for (uint256 i; i < len; ++i) {\\n            ret[i] = notes[toNotes[account][i]];\\n        }\\n        return ret;\\n    }\\n\\n    function notesLength(address account) public view returns (uint256) {\\n        return toNotes[account].length;\\n    }\\n\\n    function activeBondsLength() public view returns (uint256) {\\n        return activeBonds.length;\\n    }\\n\\n    function currentDiscount(uint128 uid) public view returns (uint24 discount) {\\n        Bond memory _bond = bonds[uid];\\n        require(_bond.disabled == 0, \\\"Bond is terminated\\\");\\n        \\n        discount = uint24(\\n            uint256(_bond.startDiscount) + ((block.timestamp - uint256(_bond.bondStart)) * uint256(_bond.dailyDiscount)) / 1 days\\n        );\\n\\n        if (discount > _bond.endDiscount) {\\n            discount = _bond.endDiscount;\\n        }\\n\\n        if (discount > BASE_PERC) {\\n            discount = uint24(BASE_PERC);\\n        }\\n    }\\n\\n    function priceOfCookieWithDiscount(uint128 uid) public view returns (uint128 discountPrice) {\\n        discountPrice = uint128(ORACLE.consult(address(COOKIETOKEN), uint256(BASE_ETH)));\\n        discountPrice = discountPrice * (uint128(BASE_PERC) - uint128(currentDiscount(uid))) / uint128(BASE_PERC);\\n    }\\n\\n    function _toRedeem(uint128 _noteId) internal view returns (uint256 ret) {\\n        Note memory note = notes[_noteId];\\n        uint256 _timestampEnd = note.timestampEnd;\\n        uint256 _totalCookies = note.totalCookies;\\n\\n        if (block.timestamp > _timestampEnd) {\\n            uint256 _paid = note.paid;\\n            assembly {\\n                ret := sub(_totalCookies, _paid)\\n            }\\n        } else {\\n            uint256 _timestampLastRedeem = note.timestampLastRedeem;\\n            uint256 _timestampStart = note.timestampStart;\\n\\n            assembly {\\n                if lt(timestamp(), _timestampLastRedeem) { revert(0, 0) }\\n                let deltaY := sub(timestamp(), _timestampLastRedeem)\\n                let redeemPerc := div(mul(deltaY, BASE_ETH), sub(_timestampEnd, _timestampStart))\\n                ret := div(mul(_totalCookies, redeemPerc), BASE_ETH)\\n            }\\n        }\\n    }\\n\\n    function toRedeem(address _account)\\n        external\\n        view\\n        returns (uint128[] memory notesIds, uint256[] memory pendingAmount)\\n    {\\n        notesIds = toNotes[_account];\\n        uint256 len = notesIds.length;\\n        pendingAmount = new uint256[](len);\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                pendingAmount[i] = _toRedeem(uint128(notesIds[i]));\\n            }\\n        }\\n    }\\n\\n    function totalToRedeem(address account) external view returns (uint256 pendingAmount) {\\n        uint128[] memory notesIds = toNotes[account];\\n        uint256 len = notesIds.length;\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                pendingAmount = pendingAmount + _toRedeem(uint128(notesIds[i]));\\n            }\\n        }\\n    }\\n\\n    function detailActiveBonds() external view returns (Bond[] memory ret) {\\n        uint256 len = activeBonds.length;\\n        ret = new Bond[](len);\\n        unchecked {\\n            for (uint256 i; i < len; ++i) {\\n                ret[i] = bonds[activeBonds[i]];\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    /// @dev assume that always noteUid is a note if that exist in the array userNotes\\n    function _deleteNote(address account, uint256 noteUid) internal {\\n        uint128[] storage userNotes = toNotes[account];\\n        uint256 len = userNotes.length;\\n\\n        unchecked {\\n            uint256 pos;\\n            while (true) {\\n                if (userNotes[pos] == noteUid) {\\n                    break;\\n                }\\n                ++pos;\\n            }\\n\\n            if (len - 1 != pos) {\\n                userNotes[pos] = userNotes[len - 1];\\n            }\\n        }\\n\\n        userNotes.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOracleSimple.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOracleSimple {\\n    function update() external;\\n\\n    function consult(address token, uint256 amountIn) external view returns (uint256 amountOut);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"eird-erc20/=lib/zuniswapv2/lib/solmate/lib/weird-erc20/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/v2-periphery/contracts/\",\r\n      \"weird-erc20/=lib/zuniswapv2/lib/solmate/lib/weird-erc20/src/\",\r\n      \"zuniswapv2/=lib/zuniswapv2/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cookieToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wmatic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracleSimple\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_game\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"errWrongDiscount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"uid\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cookieRemains\",\"type\":\"uint256\"}],\"name\":\"BondTermsEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"uid\",\"type\":\"uint128\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"uid\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"bondStart\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"vestingDays\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"startDiscount\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"endDiscount\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"dailyDiscount\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"disabled\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"bondedCookies\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"cookiesToBond\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"bondManagerStrategy\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct CryptoCookiesBondsV2.Bond\",\"name\":\"bond\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"BondTermsStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"noteId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountMATIC\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cookiesForUser\",\"type\":\"uint256\"}],\"name\":\"NoteAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"noteId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"name\":\"NoteRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COOKIETOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20Burneable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAME\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORACLE\",\"outputs\":[{\"internalType\":\"contract IOracleSimple\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WMATIC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activeBonds\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeBondsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"bonds\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"uid\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"bondStart\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"vestingDays\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"startDiscount\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"endDiscount\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"dailyDiscount\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"disabled\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"bondedCookies\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"cookiesToBond\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"bondManagerStrategy\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"uid\",\"type\":\"uint128\"}],\"name\":\"buyBond\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"uid\",\"type\":\"uint128\"}],\"name\":\"currentDiscount\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"discount\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"detailActiveBonds\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"uid\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"bondStart\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"vestingDays\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"startDiscount\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"endDiscount\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"dailyDiscount\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"disabled\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"bondedCookies\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"cookiesToBond\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"bondManagerStrategy\",\"type\":\"address\"}],\"internalType\":\"struct CryptoCookiesBondsV2.Bond[]\",\"name\":\"ret\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"uid\",\"type\":\"uint128\"}],\"name\":\"endBondSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getNote\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"uidBond\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"timestampStart\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"timestampLastRedeem\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"timestampEnd\",\"type\":\"uint40\"},{\"internalType\":\"uint128\",\"name\":\"paid\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalCookies\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"struct CryptoCookiesBondsV2.Note\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getNotes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"uidBond\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"timestampStart\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"timestampLastRedeem\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"timestampEnd\",\"type\":\"uint40\"},{\"internalType\":\"uint128\",\"name\":\"paid\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalCookies\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"struct CryptoCookiesBondsV2.Note[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"notes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"uidBond\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"timestampStart\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"timestampLastRedeem\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"timestampEnd\",\"type\":\"uint40\"},{\"internalType\":\"uint128\",\"name\":\"paid\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalCookies\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"notesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"uid\",\"type\":\"uint128\"}],\"name\":\"priceOfCookieWithDiscount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"discountPrice\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"noteId\",\"type\":\"uint128\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"resize\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_vestingDays\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"_startDiscount\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"_endDiscount\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"_dailyDiscount\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"_cookiesToBond\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_bondManagerStrategy\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"startBondSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"toNotes\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"toRedeem\",\"outputs\":[{\"internalType\":\"uint128[]\",\"name\":\"notesIds\",\"type\":\"uint128[]\"},{\"internalType\":\"uint256[]\",\"name\":\"pendingAmount\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"totalToRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CryptoCookiesBondsV2", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "0000000000000000000000003c0bd2118a5e61c41d2adeebcb8b7567fde1cbaf0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf127000000000000000000000000048cdab9efcdd9fb3132b6cc730a7ad907d52b62700000000000000000000000014db5c0c433a05caeb78dd7515cbaf67aa772d77", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}