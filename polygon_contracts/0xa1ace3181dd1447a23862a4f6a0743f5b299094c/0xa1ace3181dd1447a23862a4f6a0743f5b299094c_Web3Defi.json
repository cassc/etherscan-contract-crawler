{"SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"Web3Defi.sol\":{\"content\":\"// SPDX-License-Identifier: GPLv3\\r\\n\\r\\npragma solidity \\u003e=0.8.0;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ncontract Web3Defi {\\r\\n    using SafeMath for uint256;\\r\\n    IERC20 public usdt;\\r\\n    uint256 private constant baseDivider = 10000;\\r\\n    uint256 private constant limitProfit = 20000;\\r\\n    uint256 private constant boosterLimitProfit = 30000;\\r\\n    uint256 private constant feePercents = 200; \\r\\n    uint256 private constant minDeposit = 100e6; \\r\\n    uint256 private constant maxDeposit = 2500e6; \\r\\n    uint256 private constant freezeIncomePercents = 3000;\\r\\n    uint256 private constant LuckDeposit = 1000e6; \\r\\n    uint256 private constant timeStep = 1 days; \\r\\n    uint256 private constant dayPerCycle = 15 days;\\r\\n    uint256 private constant maxAddFreeze = 50 days; \\r\\n    uint256 private constant normalcycleRewardPercents = 1500;\\r\\n    uint256 private constant boostercycleRewardPercents = 2000;\\r\\n    uint256 private constant referDepth = 12;\\r\\n    uint256 private constant boosterPoolTimeLimit = 90 days;\\r\\n\\r\\n    uint256 private constant directPercents = 500;\\r\\n    uint256[] private diamondLevels = [100,200,100,200]; \\r\\n    uint256[] private blueDiamondLevels = [100,100,100,100,100,50,50]; \\r\\n\\r\\n    uint256 private constant infiniteRewardPercents = 400; \\r\\n    uint256 private constant boosterPoolPercents = 50; \\r\\n    uint256 private constant supportPoolPercents = 100; \\r\\n    uint256 private constant more1kIncomePoolPercents = 50; \\r\\n\\r\\n    address[2] public feeReceivers; \\r\\n    address public supportFundAccount;\\r\\n\\r\\n    address public defaultRefer; \\r\\n    uint256 private startTime;\\r\\n    uint256 public lastDistribute; \\r\\n    uint256 public totalUser;\\r\\n    uint256 public more1kIncomePool;\\r\\n    uint256 public boosterPool;\\r\\n\\r\\n    uint256 private balDown = 40e10;\\r\\n    bool private balReached;\\r\\n    uint256 private balDownRateSL1 = 8000;\\r\\n    uint256 private balDownRateSL2 = 6000;\\r\\n    uint256 private balRecover = 11000;\\r\\n    uint256 public AllTimeHigh;\\r\\n    uint256 public balDownHitAt;\\r\\n    bool public isRecoveredFirstTime = false;\\r\\n    bool public isStopLoss20ofATH = false;\\r\\n    bool public isStopLoss40ofATH = false;\\r\\n    uint256 public lastFreezed;\\r\\n    bool private balanceHitZero;\\r\\n\\r\\n    mapping(uint256=\\u003eaddress[]) public dayMore1kUsers;\\r\\n    address[] public boosterUsers;\\r\\n    uint256 public dayMore1KLastDistributed;\\r\\n\\r\\n    struct OrderInfo {\\r\\n        uint256 amount;\\r\\n        uint256 start;\\r\\n        uint256 unfreeze;\\r\\n        bool isClaimed;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e OrderInfo[]) public orderInfos;\\r\\n\\r\\n    address[] public depositors;\\r\\n\\r\\n    struct UserInfo {\\r\\n        address referrer;\\r\\n        uint256 start; \\r\\n        uint256 level;\\r\\n        uint256 maxDeposit;\\r\\n        uint256 maxDirectDeposit;\\r\\n        uint256 totalDeposit;\\r\\n        uint256 teamNum;\\r\\n        uint256 teamTotalDeposit;\\r\\n        uint256 directTeamTotalVolume;\\r\\n        uint256 totalFreezed;\\r\\n        uint256 totalRevenue;\\r\\n        uint256 depositDistributed;\\r\\n    }\\r\\n\\r\\n    struct UserAchievements {\\r\\n        bool isbooster;\\r\\n        uint256 boosterAcheived;\\r\\n        uint256 boosterAcheivedAmount;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e UserAchievements) public userAchieve;\\r\\n    mapping(address =\\u003e UserInfo) public userInfo;\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e address[])) public teamUsers;\\r\\n    mapping(address =\\u003e address[]) public myTeamUsers;\\r\\n\\r\\n    struct RewardInfo {\\r\\n        uint256 capitals;\\r\\n        uint256 statics;\\r\\n        uint256 directs;\\r\\n        uint256 levelReleased;\\r\\n        uint256 blueDiamondReleased;\\r\\n        uint256 blueDiamondFreezed;\\r\\n        uint256 infinityBonusReleased;\\r\\n        uint256 infinityFreezed;\\r\\n        uint256 blueDiamondReceived;\\r\\n        uint256[2] crownDiamondReceived;\\r\\n        uint256 more1k;\\r\\n        uint256 booster;\\r\\n        uint256 lockusdt;\\r\\n        uint256 lockusdtDebt; \\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e RewardInfo) public rewardInfo;\\r\\n\\r\\n    uint256 private constant maxBlueDiamondFreeze = 50000e6;\\r\\n    uint256 private constant maxCrownDiamondFreeze = 25000e6;\\r\\n    uint256 private constant maxInfinityL1toL5 = 10000e6;\\r\\n\\r\\n    event Register(address user, address referral);\\r\\n    event Deposit(address user, uint256 amount);\\r\\n    event DepositBylockusdt(address user, uint256 amount);\\r\\n    event TransferBylockusdt(address user, address receiver, uint256 amount);\\r\\n    event Withdraw(address user, uint256 withdrawable);\\r\\n\\r\\n    constructor(\\r\\n        address _usdtAddr,\\r\\n        address _defaultRefer,\\r\\n        address _supportFund,\\r\\n        address[2] memory _feeReceivers\\r\\n    ) {\\r\\n        usdt = IERC20(_usdtAddr);\\r\\n        defaultRefer = _defaultRefer;\\r\\n        supportFundAccount = _supportFund;\\r\\n        feeReceivers = _feeReceivers;\\r\\n        startTime = block.timestamp;\\r\\n        lastDistribute = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function register(address _referral) external {\\r\\n        require(userInfo[_referral].totalDeposit \\u003e 0 || _referral == defaultRefer,\\\"invalid refer\\\");\\r\\n        UserInfo storage user = userInfo[msg.sender];\\r\\n        require(user.referrer == address(0), \\\"referrer bonded\\\");\\r\\n        if(msg.sender == defaultRefer) {\\r\\n            user.referrer = address(this);\\r\\n        } else {\\r\\n            user.referrer = _referral;\\r\\n        }\\r\\n        totalUser = totalUser.add(1);\\r\\n        emit Register(msg.sender, _referral);\\r\\n    }\\r\\n    \\r\\n    function _updateTeamNum(address _user) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        address upline = user.referrer;\\r\\n        for (uint256 i = 0; i \\u003c referDepth; i++) {\\r\\n            if (upline != address(0)) {\\r\\n                userInfo[upline].teamNum = userInfo[upline].teamNum.add(1);\\r\\n                teamUsers[upline][i].push(_user);\\r\\n                _updateLevel(upline);\\r\\n                if (upline == defaultRefer) break;\\r\\n                upline = userInfo[upline].referrer;\\r\\n            } else {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updateLevel(address _user) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        user.level = _calLevelNow(_user);\\r\\n    }\\r\\n\\r\\n    function _calLevelNow(address _user) private view returns (uint256) {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        uint256 level;\\r\\n        uint256 directTeam = myTeamUsers[_user].length;\\r\\n        (uint256 maxTeam, uint256 otherTeam, ) = getTeamDeposit(_user);\\r\\n        uint256 totalTeam = user.teamNum;\\r\\n        if(user.maxDeposit \\u003e= 2500e6 \\u0026\\u0026 directTeam \\u003e=15 \\u0026\\u0026 user.maxDirectDeposit \\u003e= 15000e6 \\u0026\\u0026 totalTeam \\u003e= 300 \\u0026\\u0026 maxTeam \\u003e= 150000e6 \\u0026\\u0026 otherTeam \\u003e= 150000e6){\\r\\n            level = 4;\\r\\n        }else if(user.maxDeposit \\u003e= 2500e6 \\u0026\\u0026 directTeam \\u003e=10 \\u0026\\u0026 user.maxDirectDeposit \\u003e= 10000e6 \\u0026\\u0026 totalTeam \\u003e= 180 \\u0026\\u0026 maxTeam \\u003e= 50000e6 \\u0026\\u0026 otherTeam \\u003e= 50000e6){\\r\\n            level = 3;\\r\\n        }else if(user.maxDeposit \\u003e= 1000e6 \\u0026\\u0026 directTeam \\u003e=5 \\u0026\\u0026 user.maxDirectDeposit \\u003e= 5000e6 \\u0026\\u0026 totalTeam \\u003e= 40 \\u0026\\u0026 maxTeam \\u003e= 10000e6 \\u0026\\u0026 otherTeam \\u003e= 10000e6){\\r\\n            level = 2;\\r\\n        } else if(user.maxDeposit \\u003e= minDeposit) {\\r\\n            level = 1;\\r\\n        }\\r\\n        return level;\\r\\n    }\\r\\n\\r\\n    function _updatemaxdirectdepositInfo(address _user, uint256 _amount, uint256 _prevMax) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        address upline = user.referrer;\\r\\n\\r\\n        if (upline != address(0)) {\\r\\n            userInfo[upline].maxDirectDeposit = userInfo[upline]\\r\\n                .maxDirectDeposit\\r\\n                .add(_amount);\\r\\n            userInfo[upline].maxDirectDeposit = userInfo[upline]\\r\\n                .maxDirectDeposit\\r\\n                .sub(_prevMax);\\r\\n\\r\\n            userInfo[upline].directTeamTotalVolume = userInfo[upline].directTeamTotalVolume.add(_amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function deposit(uint256 _amount) external {\\r\\n        require(_amount.mod(minDeposit) == 0,\\\"amount should be multiple of 100\\\");\\r\\n        usdt.transferFrom(msg.sender, address(this), _amount);\\r\\n        _deposit(msg.sender, _amount);\\r\\n        emit Deposit(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    function _deposit(address _user, uint256 _amount) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        uint256 prevMax = user.maxDeposit;\\r\\n        require(user.referrer != address(0),\\\"register first with referral address\\\");\\r\\n        require(_amount \\u003e= minDeposit, \\\"should be more than 100\\\");\\r\\n        require(_amount \\u003c= maxDeposit, \\\"should be less than 2500\\\");\\r\\n        require(user.maxDeposit == 0 || _amount \\u003e= user.maxDeposit,\\\"next deposit should be equal or more than previous\\\");\\r\\n\\r\\n        if (user.maxDeposit == 0) {\\r\\n            user.maxDeposit = _amount;\\r\\n            user.start = block.timestamp;\\r\\n            myTeamUsers[user.referrer].push(_user);\\r\\n            _updateTeamNum(_user);\\r\\n        } else if (user.maxDeposit \\u003c _amount) {\\r\\n            user.maxDeposit = _amount;\\r\\n        }\\r\\n\\r\\n        _distributeDeposit(_amount);\\r\\n\\r\\n        if(user.totalDeposit == 0){\\r\\n            uint256 dayNow = dayMore1KLastDistributed;\\r\\n            _updateDayMore1kUsers(_user, dayNow);\\r\\n        }\\r\\n\\r\\n        _updateDepositors(_user);\\r\\n\\r\\n        user.totalDeposit = user.totalDeposit.add(_amount);\\r\\n        user.totalFreezed = user.totalFreezed.add(_amount);\\r\\n\\r\\n        uint256 addFreeze = (orderInfos[_user].length).mul(timeStep);\\r\\n        if (addFreeze \\u003e maxAddFreeze) {\\r\\n            addFreeze = maxAddFreeze;\\r\\n        }\\r\\n\\r\\n        uint256 unfreezeTime = block.timestamp.add(dayPerCycle).add(addFreeze);\\r\\n        orderInfos[_user].push(OrderInfo(_amount, block.timestamp, unfreezeTime, false));\\r\\n\\r\\n        _updatemaxdirectdepositInfo(_user, _amount, prevMax);\\r\\n        \\r\\n        _unfreezeFundAndUpdateReward(_user, _amount); \\r\\n\\r\\n        _isBooster(_user);\\r\\n\\r\\n        _isBooster(user.referrer);\\r\\n\\r\\n        distributePoolRewards(); \\r\\n\\r\\n        _updateReferInfo(_user, _amount); \\r\\n\\r\\n        _updateReward(_user, _amount, prevMax); \\r\\n\\r\\n        _updateInfinity(_user, _amount);\\r\\n\\r\\n        _updateLevel(_user);\\r\\n\\r\\n        uint256 bal = usdt.balanceOf(address(this));\\r\\n\\r\\n        if(bal \\u003e= balDown) {\\r\\n            balReached = true;\\r\\n        }\\r\\n\\r\\n        if(bal \\u003e AllTimeHigh) {\\r\\n            AllTimeHigh = bal;\\r\\n        }\\r\\n\\r\\n        if (isStopLoss20ofATH || isStopLoss40ofATH) {\\r\\n            _setFreezeReward(bal);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _isBooster(address _user) private {\\r\\n        if(!(userAchieve[_user].isbooster) \\u0026\\u0026 myTeamUsers[_user].length \\u003e= 2 \\u0026\\u0026 userInfo[_user].maxDeposit \\u003e= 500e6) {\\r\\n            uint256 count;\\r\\n            for(uint256 i=0; i\\u003cmyTeamUsers[_user].length; i++) {\\r\\n                address downline = myTeamUsers[_user][i]; \\r\\n                if(userInfo[downline].start \\u003c userInfo[_user].start.add(31 days)) {\\r\\n                    if(userInfo[downline].maxDeposit \\u003e= userInfo[_user].maxDeposit) {\\r\\n                        count = count.add(1);\\r\\n                    }\\r\\n                } else {\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if(count \\u003e= 2) {\\r\\n                if(_user == msg.sender) {\\r\\n                    userAchieve[_user].isbooster = true;\\r\\n                    userAchieve[_user].boosterAcheivedAmount = userInfo[_user].maxDeposit;\\r\\n                } \\r\\n                \\r\\n                if(!(userAchieve[_user].boosterAcheived \\u003e 0)) {\\r\\n                    userAchieve[_user].boosterAcheived = block.timestamp;\\r\\n                    boosterUsers.push(_user);\\r\\n                }\\r\\n            }\\r\\n        } \\r\\n    }\\r\\n\\r\\n    function _updateDayMore1kUsers(address _user, uint256 _dayNow) private {\\r\\n        bool isFound;\\r\\n        for(uint256 i=0; i\\u003cdayMore1kUsers[_dayNow].length; i++) {\\r\\n            if(dayMore1kUsers[_dayNow][i] == userInfo[_user].referrer) {\\r\\n                isFound = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(!isFound) {\\r\\n            address referrer = userInfo[_user].referrer;\\r\\n            uint256 myTeam = myTeamUsers[referrer].length;\\r\\n            uint256 volume;\\r\\n            for(uint256 i=myTeam; i\\u003e0; i--) {\\r\\n                address _newUser = myTeamUsers[referrer][i-1];\\r\\n                if(userInfo[_newUser].start \\u003e lastDistribute) {\\r\\n                    volume = volume.add(userInfo[_newUser].maxDeposit);\\r\\n                } else {\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if(volume \\u003e= LuckDeposit) {\\r\\n                dayMore1kUsers[_dayNow].push(userInfo[_user].referrer);\\r\\n            }\\r\\n        } \\r\\n    }\\r\\n\\r\\n    function _distributeDeposit(uint256 _amount) private {\\r\\n        uint256 fee = _amount.mul(feePercents).div(baseDivider);\\r\\n        usdt.transfer(feeReceivers[0], fee.div(2));\\r\\n        usdt.transfer(feeReceivers[1], fee.div(2));\\r\\n        if(!balanceHitZero) {\\r\\n            uint256 _support = _amount.mul(supportPoolPercents).div(baseDivider);\\r\\n            usdt.transfer(supportFundAccount, _support);\\r\\n        }\\r\\n        uint256 more1kPool = _amount.mul(more1kIncomePoolPercents).div(baseDivider);\\r\\n        more1kIncomePool = more1kIncomePool.add(more1kPool);\\r\\n        uint256 _booster = _amount.mul(more1kIncomePoolPercents).div(baseDivider);\\r\\n        boosterPool = boosterPool.add(_booster); \\r\\n    }\\r\\n\\r\\n    function _unfreezeFundAndUpdateReward(address _user, uint256 _amount) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        bool isUnfreezed;\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c orderInfos[_user].length; i++) {\\r\\n            OrderInfo storage order = orderInfos[_user][i];\\r\\n            if (block.timestamp \\u003e order.unfreeze \\u0026\\u0026 !order.isClaimed) {\\r\\n                if (user.totalFreezed \\u003e order.amount) {\\r\\n                    user.totalFreezed = user.totalFreezed.sub(order.amount);\\r\\n                } else {\\r\\n                    user.totalFreezed = 0;\\r\\n                }\\r\\n\\r\\n                _removeInvalidDeposit(_user, order.amount);\\r\\n\\r\\n                uint256 staticReward = _returnStaticReward(_user, order.amount);\\r\\n\\r\\n                if(user.level \\u003e 2 \\u0026\\u0026 staticReward \\u003e= 25e6 \\u0026\\u0026 !balanceHitZero) {\\r\\n                    usdt.transfer(supportFundAccount, 25e6);\\r\\n                    staticReward = staticReward.sub(25e6);\\r\\n                }\\r\\n\\r\\n                rewardInfo[_user].capitals = rewardInfo[_user].capitals.add(order.amount);\\r\\n                rewardInfo[_user].statics = rewardInfo[_user].statics.add(staticReward);\\r\\n                userInfo[_user].totalRevenue = userInfo[_user].totalRevenue.add(staticReward);\\r\\n                \\r\\n                order.isClaimed = true;\\r\\n                isUnfreezed = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(!isUnfreezed) {\\r\\n            RewardInfo storage userReward = rewardInfo[_user];\\r\\n            uint256 release = _amount;\\r\\n\\r\\n            if(userReward.blueDiamondFreezed \\u003e 0) {\\r\\n                if(release \\u003e= userReward.blueDiamondFreezed) {\\r\\n                  release = release.sub(userReward.blueDiamondFreezed);\\r\\n                  user.totalRevenue = user.totalRevenue.add(userReward.blueDiamondFreezed);\\r\\n                  userReward.blueDiamondReleased = userReward.blueDiamondReleased.add(userReward.blueDiamondFreezed);\\r\\n                  userReward.blueDiamondFreezed = 0;  \\r\\n                } else {\\r\\n                  userReward.blueDiamondFreezed = userReward.blueDiamondFreezed.sub(release);\\r\\n                  userReward.blueDiamondReleased = userReward.blueDiamondReleased.add(release);\\r\\n                  user.totalRevenue = user.totalRevenue.add(release);\\r\\n                  release = 0;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if(userReward.infinityFreezed \\u003e 0 \\u0026\\u0026 release \\u003e 0) {\\r\\n                if(release \\u003e= userReward.infinityFreezed) {\\r\\n                  release = release.sub(userReward.infinityFreezed);\\r\\n                  user.totalRevenue = user.totalRevenue.add(userReward.infinityFreezed);\\r\\n                  userReward.infinityBonusReleased = userReward.infinityBonusReleased.add(userReward.infinityFreezed);\\r\\n                  userReward.infinityFreezed = 0;  \\r\\n                } else {\\r\\n                  userReward.infinityFreezed = userReward.infinityFreezed.sub(release);\\r\\n                  userReward.infinityBonusReleased = userReward.infinityBonusReleased.add(release);\\r\\n                  user.totalRevenue = user.totalRevenue.add(release);\\r\\n                  release = 0;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _returnStaticReward(address _user, uint256 _amount) private view returns(uint256) {\\r\\n        uint256 staticReward;\\r\\n        UserInfo memory user = userInfo[_user];\\r\\n\\r\\n        if(user.totalRevenue \\u003c getMaxFreezing(_user).mul(limitProfit).div(baseDivider) || user.level \\u003e 1 || _isEligible(_user) || _user == defaultRefer) {\\r\\n            staticReward = _amount.mul(normalcycleRewardPercents).div(baseDivider);\\r\\n        }\\r\\n        \\r\\n        if(userAchieve[_user].isbooster){\\r\\n            uint256 boosterIncome;\\r\\n            if(user.level \\u003e 1) {\\r\\n                staticReward = _amount.mul(boostercycleRewardPercents).div(baseDivider);\\r\\n            } else if(user.totalRevenue \\u003c getMaxFreezing(_user).mul(boosterLimitProfit).div(baseDivider) || _isEligible(_user) || _user == defaultRefer) {\\r\\n                if(userAchieve[_user].boosterAcheivedAmount \\u003c _amount) {\\r\\n                    boosterIncome = userAchieve[_user].boosterAcheivedAmount.mul(boostercycleRewardPercents).div(baseDivider);\\r\\n                    staticReward = (_amount.sub(userAchieve[_user].boosterAcheivedAmount)).mul(normalcycleRewardPercents).div(baseDivider);\\r\\n                    staticReward = staticReward.add(boosterIncome);\\r\\n                } else {\\r\\n                    staticReward = _amount.mul(boostercycleRewardPercents).div(baseDivider);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(isStopLoss40ofATH || isStopLoss20ofATH) {\\r\\n            if(user.totalRevenue \\u003e= user.totalFreezed) {\\r\\n                staticReward = 0;\\r\\n            } else {\\r\\n                uint256 temp = user.totalFreezed.sub(user.totalRevenue);\\r\\n                if(temp \\u003c staticReward) {\\r\\n                    staticReward = temp;\\r\\n                }\\r\\n            }\\r\\n        } else if(isRecoveredFirstTime \\u0026\\u0026 staticReward \\u003e 0 \\u0026\\u0026 user.level \\u003e 1) {\\r\\n            staticReward = staticReward.div(2);\\r\\n        }\\r\\n\\r\\n        return staticReward;\\r\\n    }\\r\\n\\r\\n    function _returnDynamicReward(address _user, address _upline, uint256 _amount) private view returns(uint256) {\\r\\n        uint256 newAmount;\\r\\n        UserInfo memory upline = userInfo[_upline];\\r\\n\\r\\n        if(upline.totalRevenue \\u003c getMaxFreezing(_upline).mul(limitProfit).div(baseDivider) || upline.level \\u003e 1 || _isEligible(_upline) || _upline == defaultRefer) {\\r\\n            newAmount = _amount;\\r\\n        } \\r\\n        \\r\\n        if(userAchieve[_upline].isbooster){\\r\\n            if(upline.totalRevenue \\u003c getMaxFreezing(_upline).mul(boosterLimitProfit).div(baseDivider) || upline.level \\u003e 1 || _isEligible(_upline) || _upline == defaultRefer) {\\r\\n                newAmount = _amount;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(isStopLoss20ofATH) {\\r\\n            if(upline.totalRevenue \\u003c upline.totalFreezed || userInfo[_user].start \\u003e lastFreezed) {\\r\\n                newAmount = newAmount;\\r\\n            } else {\\r\\n                newAmount = newAmount.div(2);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(isStopLoss40ofATH) {\\r\\n            if(!(userInfo[_user].start \\u003e lastFreezed)) {\\r\\n                newAmount = 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return newAmount;\\r\\n    }\\r\\n\\r\\n    function _isEligible(address _user) private view returns(bool) {\\r\\n        bool isEligible;\\r\\n        uint256 volume;\\r\\n        for(uint256 j=0; j\\u003cmyTeamUsers[_user].length; j++) {\\r\\n            address downline = myTeamUsers[_user][j]; \\r\\n            if(orderInfos[downline].length \\u003e 0) {\\r\\n                volume = volume.add(userInfo[downline].maxDeposit);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(volume \\u003e= 5000e6 \\u0026\\u0026 myTeamUsers[_user].length \\u003e= 5) {\\r\\n            isEligible = true;\\r\\n        }\\r\\n\\r\\n        return isEligible;\\r\\n    }\\r\\n\\r\\n    function _removeInvalidDeposit(address _user, uint256 _amount) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        address upline = user.referrer;\\r\\n        for (uint256 i = 0; i \\u003c referDepth; i++) {\\r\\n            if (upline != address(0)) {\\r\\n                if (userInfo[upline].teamTotalDeposit \\u003e _amount) {\\r\\n                    userInfo[upline].teamTotalDeposit = userInfo[upline]\\r\\n                        .teamTotalDeposit\\r\\n                        .sub(_amount);\\r\\n                } else {\\r\\n                    userInfo[upline].teamTotalDeposit = 0;\\r\\n                }\\r\\n                if (upline == defaultRefer) break;\\r\\n                upline = userInfo[upline].referrer;\\r\\n            } else {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function distributePoolRewards() public {\\r\\n        if (block.timestamp \\u003e lastDistribute.add(timeStep)) {\\r\\n            uint256 dayNow = dayMore1KLastDistributed;\\r\\n            _distributeLuckPool1k(dayNow);\\r\\n            _distributeBoosterPool();\\r\\n            lastDistribute = block.timestamp;\\r\\n            dayMore1KLastDistributed = dayMore1KLastDistributed.add(1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getCurDay() public view returns(uint256) {\\r\\n        return (block.timestamp.sub(startTime)).div(timeStep);\\r\\n    }\\r\\n\\r\\n    function _distributeLuckPool1k(uint256 _dayNow) private {\\r\\n        uint256 day1kDepositCount = dayMore1kUsers[_dayNow].length;\\r\\n        if(day1kDepositCount \\u003e 0){\\r\\n            uint256 reward = more1kIncomePool.div(day1kDepositCount);\\r\\n            uint256 totalReward;\\r\\n\\r\\n            for(uint256 i = day1kDepositCount; i \\u003e 0; i--){\\r\\n                address userAddr = dayMore1kUsers[_dayNow][i - 1];\\r\\n                if(userAddr != address(0)){\\r\\n                    uint256 givenReward = reward;\\r\\n                    if(!(getMaxFreezing(userAddr) \\u003e 0)) {\\r\\n                        givenReward = 0;\\r\\n                    }\\r\\n                    rewardInfo[userAddr].more1k = rewardInfo[userAddr].more1k.add(givenReward);\\r\\n                    userInfo[userAddr].totalRevenue = userInfo[userAddr].totalRevenue.add(givenReward);\\r\\n                    totalReward = totalReward.add(givenReward);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if(more1kIncomePool \\u003e totalReward){\\r\\n                more1kIncomePool = more1kIncomePool.sub(totalReward);\\r\\n            }else{\\r\\n                more1kIncomePool = 0;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _distributeBoosterPool() private {\\r\\n        uint256 boosterCount;\\r\\n        for(uint256 i=boosterUsers.length; i\\u003e0; i--) {\\r\\n            UserAchievements memory userboost = userAchieve[boosterUsers[i-1]];\\r\\n            if((block.timestamp - userboost.boosterAcheived) \\u003c boosterPoolTimeLimit) {\\r\\n                boosterCount = boosterCount.add(1);\\r\\n            } else {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(boosterCount \\u003e 0) {\\r\\n            uint256 reward = boosterPool.div(boosterCount);\\r\\n            uint256 totalReward;\\r\\n    \\r\\n            for(uint256 i=boosterUsers.length; i\\u003e0; i--) {\\r\\n                address userAddr = boosterUsers[i-1];\\r\\n                UserAchievements memory userboost = userAchieve[boosterUsers[i-1]];\\r\\n                if((block.timestamp - userboost.boosterAcheived) \\u003c boosterPoolTimeLimit \\u0026\\u0026 userAddr != address(0)) {\\r\\n                    uint256 calReward = _returnPoolReward(userAddr, reward);\\r\\n                    rewardInfo[userAddr].booster = rewardInfo[userAddr].booster.add(calReward);\\r\\n                    userInfo[userAddr].totalRevenue = userInfo[userAddr].totalRevenue.add(calReward);\\r\\n                    totalReward = totalReward.add(calReward);\\r\\n                } else {\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if(boosterPool \\u003e totalReward){\\r\\n                boosterPool = boosterPool.sub(totalReward);\\r\\n            }else{\\r\\n                boosterPool = 0;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _returnPoolReward(address _user, uint256 _amount) private view returns(uint256) {\\r\\n        uint256 reward = 0;\\r\\n        UserInfo memory user = userInfo[_user];\\r\\n        \\r\\n        if(user.totalRevenue \\u003c getMaxFreezing(_user).mul(boosterLimitProfit).div(baseDivider) || user.level \\u003e 1) {\\r\\n            reward = _amount;\\r\\n        }\\r\\n\\r\\n        if(isStopLoss20ofATH \\u0026\\u0026 !(user.totalRevenue \\u003c user.totalFreezed)) {\\r\\n            reward = reward.div(2);\\r\\n        }\\r\\n\\r\\n        if(isStopLoss40ofATH) {\\r\\n            reward = 0;\\r\\n        }\\r\\n\\r\\n        if(!(getMaxFreezing(_user) \\u003e 0)) {\\r\\n            reward = 0;\\r\\n        }\\r\\n\\r\\n        return reward;\\r\\n    }\\r\\n\\r\\n    function _updateReferInfo(address _user, uint256 _amount) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        address upline = user.referrer;\\r\\n        for(uint256 i=0; i\\u003creferDepth; i++) {\\r\\n            if (upline != address(0)) {\\r\\n                userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.add(_amount);\\r\\n                upline = userInfo[upline].referrer;\\r\\n            } else {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updateReward(address _user, uint256 _amount, uint256 _prevMax) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        address upline = user.referrer;\\r\\n\\r\\n        bool isDistributed;\\r\\n        bool shouldDistribute;\\r\\n        if (_amount \\u003e _prevMax || user.depositDistributed \\u003c 8) {\\r\\n            shouldDistribute = true;\\r\\n        }\\r\\n\\r\\n        if (_amount \\u003e _prevMax) {\\r\\n            user.depositDistributed = 0;\\r\\n        }\\r\\n\\r\\n        for(uint256 i = 0; i \\u003c referDepth; i++){\\r\\n            if(upline != address(0)){\\r\\n                uint256 newAmount = _amount;\\r\\n\\r\\n                uint256 maxFreezing = getMaxFreezing(upline);\\r\\n                if (maxFreezing \\u003c _amount \\u0026\\u0026 upline != defaultRefer) {\\r\\n                    newAmount = maxFreezing;\\r\\n                }\\r\\n\\r\\n                newAmount = _returnDynamicReward(_user, upline, newAmount);\\r\\n\\r\\n                RewardInfo storage upRewards = rewardInfo[upline];\\r\\n                uint256 reward;\\r\\n\\r\\n                if(i \\u003e 4) {\\r\\n                    if (userInfo[upline].level \\u003e= 3 \\u0026\\u0026 upRewards.blueDiamondReceived \\u003c maxBlueDiamondFreeze) {\\r\\n                        reward = newAmount.mul(blueDiamondLevels[i - 5]).div(baseDivider);\\r\\n                        upRewards.blueDiamondFreezed = upRewards.blueDiamondFreezed.add(reward);\\r\\n                        upRewards.blueDiamondReceived = upRewards.blueDiamondReceived.add(reward);\\r\\n                    } \\r\\n                } else if(i \\u003e 0) {\\r\\n                    if(userInfo[upline].level \\u003e= 2) {\\r\\n                        reward = newAmount.mul(diamondLevels[i - 1]).div(baseDivider);\\r\\n                        upRewards.levelReleased = upRewards.levelReleased.add(reward);\\r\\n                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\\r\\n                    }\\r\\n                } else if(shouldDistribute) {\\r\\n                    reward = newAmount.mul(directPercents).div(baseDivider);\\r\\n                    upRewards.directs = upRewards.directs.add(reward);\\r\\n                    userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\\r\\n                    \\r\\n                    isDistributed = true;\\r\\n                }\\r\\n\\r\\n                if(upline == defaultRefer) break;\\r\\n                upline = userInfo[upline].referrer;\\r\\n            }else{\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (isDistributed) {\\r\\n            user.depositDistributed = (user.depositDistributed).add(1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updateInfinity(address _user, uint256 _amount) private {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        address upline = user.referrer;\\r\\n        uint256 layer = 1;\\r\\n        for(int i=0; i\\u003c50; i++) {\\r\\n            if(upline != address(0)) {\\r\\n                if(userInfo[upline].level \\u003e= 4) {\\r\\n                    uint256 newAmount = _amount;\\r\\n                    uint256 maxFreezing = getMaxFreezing(upline);\\r\\n                    if (maxFreezing \\u003c _amount \\u0026\\u0026 upline != defaultRefer) {\\r\\n                        newAmount = maxFreezing;\\r\\n                    }\\r\\n\\r\\n                    newAmount = _returnDynamicReward(_user, upline, newAmount);\\r\\n\\r\\n                    RewardInfo storage upRewards = rewardInfo[upline];\\r\\n\\r\\n                    if(layer \\u003c= 5 \\u0026\\u0026 upRewards.crownDiamondReceived[0] \\u003c maxInfinityL1toL5) {\\r\\n                        uint256 reward = newAmount.mul(infiniteRewardPercents).div(baseDivider);\\r\\n                        upRewards.crownDiamondReceived[0] = upRewards.crownDiamondReceived[0].add(reward);\\r\\n                        upRewards.infinityBonusReleased = upRewards.infinityBonusReleased.add(reward); \\r\\n                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\\r\\n                    } else if(layer \\u003e 5 \\u0026\\u0026 upRewards.crownDiamondReceived[1] \\u003c maxCrownDiamondFreeze) {\\r\\n                        uint256 reward = newAmount.mul(infiniteRewardPercents).div(baseDivider);\\r\\n                        upRewards.infinityFreezed = upRewards.infinityFreezed.add(reward); \\r\\n                        upRewards.crownDiamondReceived[1] = upRewards.crownDiamondReceived[1].add(reward);\\r\\n                    }\\r\\n\\r\\n                    break;\\r\\n                } else {\\r\\n                    upline = userInfo[upline].referrer;\\r\\n                }\\r\\n\\r\\n                layer = layer.add(1);\\r\\n            } else {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getMaxFreezing(address _user) public view returns (uint256) {\\r\\n        uint256 maxFreezing;\\r\\n        for(uint256 i = orderInfos[_user].length; i \\u003e 0; i--){\\r\\n            OrderInfo storage order = orderInfos[_user][i - 1];\\r\\n            if(order.unfreeze \\u003e block.timestamp){\\r\\n                if(order.amount \\u003e maxFreezing){\\r\\n                    maxFreezing = order.amount;\\r\\n                }\\r\\n            }else{\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return maxFreezing;\\r\\n    }\\r\\n\\r\\n    function _setFreezeReward(uint256 _bal) private {\\r\\n        if(balReached) {\\r\\n            if (_bal \\u003c= AllTimeHigh.mul(balDownRateSL1).div(baseDivider) \\u0026\\u0026 !isStopLoss20ofATH) {\\r\\n                isStopLoss20ofATH = true;\\r\\n                balDownHitAt = AllTimeHigh;\\r\\n                lastFreezed = block.timestamp;\\r\\n                depositFromSupportFunds();\\r\\n            } else if (isStopLoss20ofATH \\u0026\\u0026 _bal \\u003e= balDownHitAt.mul(balRecover).div(baseDivider)) {\\r\\n                isStopLoss20ofATH = false;\\r\\n                isRecoveredFirstTime = true;\\r\\n            }\\r\\n\\r\\n            if (isStopLoss20ofATH \\u0026\\u0026 _bal \\u003c= AllTimeHigh.mul(balDownRateSL2).div(baseDivider)) {\\r\\n                isStopLoss40ofATH = true;\\r\\n            } else if (isStopLoss40ofATH \\u0026\\u0026 _bal \\u003e= balDownHitAt.mul(balRecover).div(baseDivider)) {\\r\\n                isStopLoss40ofATH = false;\\r\\n            }\\r\\n\\r\\n            if(_bal \\u003c= 50e6) {\\r\\n                depositFromSupportFunds();\\r\\n                balanceHitZero = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw() external {\\r\\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\\r\\n        distributePoolRewards();\\r\\n        (uint256 staticReward, uint256 staticlockusdt) = _calCurStaticRewards(msg.sender);\\r\\n        uint256 lockusdtAmt = staticlockusdt;\\r\\n        uint256 withdrawable = staticReward;\\r\\n\\r\\n        (uint256 dynamicReward, uint256 dynamiclockusdt) = _calCurDynamicRewards(msg.sender);\\r\\n        withdrawable = withdrawable.add(dynamicReward);\\r\\n        lockusdtAmt = lockusdtAmt.add(dynamiclockusdt);\\r\\n\\r\\n        UserInfo storage userin = userInfo[msg.sender];\\r\\n\\r\\n        userRewards.lockusdt = userRewards.lockusdt.add(lockusdtAmt);\\r\\n\\r\\n        userRewards.statics = 0;\\r\\n        userRewards.directs = 0;\\r\\n        userRewards.levelReleased = 0;\\r\\n        userRewards.blueDiamondReleased = 0;\\r\\n        userRewards.infinityBonusReleased = 0;\\r\\n        \\r\\n        userRewards.more1k = 0;\\r\\n        userRewards.booster = 0;\\r\\n        withdrawable = withdrawable.add(userRewards.capitals);\\r\\n        userRewards.capitals = 0;\\r\\n\\r\\n        if(userin.maxDeposit \\u003e= 1000e6 \\u0026\\u0026 withdrawable \\u003e= 10e6) {\\r\\n            withdrawable = withdrawable.sub(10e6);\\r\\n        }\\r\\n        \\r\\n       \\r\\n        usdt.transfer(msg.sender, withdrawable);\\r\\n        uint256 bal = usdt.balanceOf(address(this));\\r\\n        _setFreezeReward(bal);\\r\\n\\r\\n        emit Withdraw(msg.sender, withdrawable);\\r\\n    }\\r\\n\\r\\n    function _calCurStaticRewards(address _user) private view returns(uint256, uint256) {\\r\\n        RewardInfo storage userRewards = rewardInfo[_user];\\r\\n        uint256 totalRewards = userRewards.statics;\\r\\n        uint256 lockusdtAmt = totalRewards.mul(freezeIncomePercents).div(baseDivider);\\r\\n        uint256 withdrawable = totalRewards.sub(lockusdtAmt);\\r\\n        return(withdrawable, lockusdtAmt);\\r\\n    }\\r\\n\\r\\n    function _calCurDynamicRewards(address _user) private view returns(uint256, uint256) {\\r\\n        RewardInfo storage userRewards = rewardInfo[_user];\\r\\n        uint256 totalRewards = (userRewards.directs).add(userRewards.levelReleased);\\r\\n        totalRewards = totalRewards.add(userRewards.more1k).add(userRewards.booster).add(userRewards.blueDiamondReleased).add(userRewards.infinityBonusReleased);\\r\\n\\r\\n        uint256 lockusdtAmt = totalRewards.mul(freezeIncomePercents).div(baseDivider);\\r\\n\\r\\n        uint256 withdrawable = totalRewards.sub(lockusdtAmt);\\r\\n        return(withdrawable, lockusdtAmt);\\r\\n    }\\r\\n\\r\\n    function depositBylockusdt(uint256 _amount) external {\\r\\n        require(_amount \\u003e= minDeposit \\u0026\\u0026 _amount.mod(minDeposit) == 0, \\\"amount err\\\");\\r\\n        require(orderInfos[msg.sender].length == 0, \\\"First depositors can only use this function\\\");\\r\\n        uint256 lockusdtLeft = getCurlockusdt(msg.sender);\\r\\n        if(lockusdtLeft \\u003e _amount.div(2)) {\\r\\n            lockusdtLeft = _amount.div(2);\\r\\n        }\\r\\n        usdt.transferFrom(msg.sender, address(this), _amount.sub(lockusdtLeft));\\r\\n        rewardInfo[msg.sender].lockusdtDebt = rewardInfo[msg.sender].lockusdtDebt.add(lockusdtLeft);\\r\\n        _deposit(msg.sender, _amount);\\r\\n        emit DepositBylockusdt(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    function getCurlockusdt(address _user) public view returns(uint256){\\r\\n        (, uint256 staticlockusdt) = _calCurStaticRewards(_user);\\r\\n        (, uint256 dynamiclockusdt) = _calCurDynamicRewards(_user);\\r\\n        return rewardInfo[_user].lockusdt.add(staticlockusdt).add(dynamiclockusdt).sub(rewardInfo[_user].lockusdtDebt);\\r\\n    }\\r\\n\\r\\n    function getCurclaimableusdt(address _user) public view returns(uint256){\\r\\n        (uint256 staticReward,) = _calCurStaticRewards(_user);\\r\\n        (uint256 dynamicReward,) = _calCurDynamicRewards(_user);\\r\\n        return staticReward.add(dynamicReward);\\r\\n    }\\r\\n\\r\\n    function transferBylockusdt(address _receiver, uint256 _amount) external {\\r\\n        require(_amount \\u003e= minDeposit.div(2) \\u0026\\u0026 _amount.mod(minDeposit.div(2)) == 0, \\\"amount err\\\");\\r\\n        require(userInfo[_receiver].referrer != address(0), \\\"Receiver should be registrant\\\");\\r\\n        uint256 lockusdtLeft = getCurlockusdt(msg.sender);\\r\\n        require(lockusdtLeft \\u003e= _amount, \\\"insufficient Locked USDT\\\");\\r\\n        rewardInfo[msg.sender].lockusdtDebt = rewardInfo[msg.sender].lockusdtDebt.add(_amount);\\r\\n        rewardInfo[_receiver].lockusdt = rewardInfo[_receiver].lockusdt.add(_amount);\\r\\n        emit TransferBylockusdt(msg.sender, _receiver, _amount);\\r\\n    }\\r\\n\\r\\n    function getDayMore1kLength(uint256 _day) external view returns(uint256) {\\r\\n        return dayMore1kUsers[_day].length;\\r\\n    }\\r\\n\\r\\n    function getTeamUsersLength(address _user) external view returns(uint256) {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        return user.teamNum;\\r\\n    }\\r\\n\\r\\n    function getOrderLength(address _user) public view returns(uint256) {\\r\\n        return orderInfos[_user].length;\\r\\n    }\\r\\n\\r\\n    function getDepositorsLength() external view returns(uint256) {\\r\\n        return depositors.length;\\r\\n    }\\r\\n\\r\\n    function getTeamDeposit(address _user) public view returns(uint256, uint256, uint256){\\r\\n        uint256 totalTeam;\\r\\n        uint256 maxTeam;\\r\\n        uint256 otherTeam;\\r\\n        for (uint256 i = 0; i \\u003c teamUsers[_user][0].length; i++) {\\r\\n            uint256 userTotalTeam = userInfo[teamUsers[_user][0][i]].teamTotalDeposit.add(userInfo[teamUsers[_user][0][i]].totalDeposit);\\r\\n            totalTeam = totalTeam.add(userTotalTeam);\\r\\n            if (userTotalTeam \\u003e maxTeam) {\\r\\n                maxTeam = userTotalTeam;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        otherTeam = totalTeam.sub(maxTeam);\\r\\n        return (maxTeam, otherTeam, totalTeam);\\r\\n    }\\r\\n\\r\\n    function depositFromSupportFunds() private {\\r\\n        uint256 allowanceAmount = usdt.allowance(supportFundAccount, address(this));\\r\\n        uint256 _bal = usdt.balanceOf(supportFundAccount);\\r\\n        if(allowanceAmount \\u003e= _bal) {\\r\\n            usdt.transferFrom(supportFundAccount, address(this), _bal);\\r\\n        } else if(allowanceAmount \\u003e 0) {\\r\\n            usdt.transferFrom(supportFundAccount, address(this), allowanceAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _checkRegistered(address _user) public view returns(bool) {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        if(user.referrer != address(0)) {\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function getMyTeamNumbers(address _user) public view returns(uint256) {\\r\\n        return myTeamUsers[_user].length;\\r\\n    }\\r\\n\\r\\n    function _updateDepositors(address _user) private {\\r\\n        bool contains = false;\\r\\n        for (uint256 i = 0; i \\u003c depositors.length; i++) {\\r\\n            if(_user == depositors[i]){\\r\\n                contains = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if(!contains){\\r\\n            depositors.push(_user);\\r\\n        }\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultRefer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_supportFund\",\"type\":\"address\"},{\"internalType\":\"address[2]\",\"name\":\"_feeReceivers\",\"type\":\"address[2]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositBylockusdt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferBylockusdt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AllTimeHigh\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"_checkRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balDownHitAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"boosterPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"boosterUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dayMore1KLastDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayMore1kUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRefer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositBylockusdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePoolRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeReceivers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getCurclaimableusdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getCurlockusdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getDayMore1kLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositorsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMaxFreezing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMyTeamNumbers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTeamUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRecoveredFirstTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStopLoss20ofATH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStopLoss40ofATH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastFreezed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"more1kIncomePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"myTeamUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isClaimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"capitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelReleased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blueDiamondReleased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blueDiamondFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"infinityBonusReleased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"infinityFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blueDiamondReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"more1k\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"booster\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockusdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockusdtDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportFundAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferBylockusdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userAchieve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isbooster\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"boosterAcheived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boosterAcheivedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDirectDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directTeamTotalVolume\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDistributed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Web3Defi", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f000000000000000000000000a8ef6b755060cdd48e91530bb2dc567326357fa90000000000000000000000007f39ad22ff132bb5b3e5d4769fbec691b7e4b82a00000000000000000000000056b78d96132bb6fb8229b65a86df9986300aadb6000000000000000000000000b02e29d1cda9e17d014158fb17c716e1dd04ffe4", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b2377111d787296c5295f6f481e9c552eb09ea95248e55ff110b1b3b4a2ff8dc"}