{"SourceCode": "// File: utils/ISpawnContract.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface ISpawnContract{\r\n\r\n    /// @dev This event should be fired whenever the address of CoinB is modified.\r\n    event CoinBChanged(address indexed _from,address indexed _to, uint256 _time);\r\n\r\n    /// @dev This event should be fired whenever the address of CoinA is modified.\r\n    event CoinAChanged(address indexed _from,address indexed _to, uint256 _time);\r\n\r\n    /// @dev Change CoinA contract.\r\n    ///  Caller should always be superAdmin. _to is the address of new CoinA contract.\r\n    function changeCoinA(address addr) external;\r\n\r\n    /// @dev Change CoinB contract.\r\n    ///  Caller should always be superAdmin. _to is the address of new CoinB contract.\r\n    function changeCoinB(address addr) external;\r\n\r\n    function setELFCore(address addr) external;\r\n\r\n    function spawnEgg(uint256 seed, uint256 momGene, uint256 dadGene, uint256 momChildren, uint256 dadChildren, address caller, bool momFromChaos, bool dadFromChaos) external returns(uint256 gene);\r\n}\r\n// File: utils/IGetter.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IGetter {\r\n\r\n    /// @dev Interface used by server to check who can use the _tokenId.\r\n    function getUser(address _nftAddress,uint256 _tokenId) external view returns (address);\r\n    \r\n    /// @dev Interface used by server to check who can claim coin B earned by _tokenId.\r\n    function getCoinB(address _nftAddress,uint256 _tokenId) external view returns (address);\r\n}\r\n// File: utils/ICapsuleContract.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface ICapsuleContract{\r\n    function writePriceInfo(uint256 price) external;\r\n    function getPriceInfo() external view returns(uint256 price,uint256 time);\r\n    function createCapsule(address caller,bool triple) external returns(uint256[] memory, uint256);\r\n    function setELFCoreAddress(address addr) external;\r\n}\r\n// File: utils/Address.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @dev Utility library of inline functions on addresses.\r\n * @notice Based on:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n * Requires EIP-1052.\r\n */\r\nlibrary AddressUtils{\r\n\r\n    /**\r\n    * @dev Returns whether the target address is a contract.\r\n    * @param _addr Address to check.\r\n    * @return addressCheck True if _addr is a contract, false if not.\r\n    */\r\n    function isContract(\r\n    address _addr\r\n    )\r\n    internal\r\n    view\r\n    returns (bool addressCheck)\r\n    {\r\n    // This method relies in extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256('')`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\r\n    addressCheck = (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n}\r\n// File: utils/IERC165.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n// File: token/IERC721Metadata.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface IERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string memory _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string memory _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n// File: token/IERC721TokenReceiver.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface IERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n// File: token/IERC721.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface IERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n// File: security/AccessControl.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ncontract AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant NO_PERMISSION='no permission';\r\n    string constant INVALID_ADDRESS ='invalid address';\r\n    \r\n    /// @dev Administrator with highest authority. Should be a multisig wallet.\r\n    address payable superAdmin;\r\n\r\n    /// @dev Administrator of this contract.\r\n    address payable admin;\r\n\r\n    /// Sets the original admin and superAdmin of the contract to the sender account.\r\n    constructor(){\r\n        superAdmin=payable(msg.sender);\r\n        admin=payable(msg.sender);\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the superAdmin.\r\n    modifier onlySuperAdmin{\r\n        require(msg.sender==superAdmin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the admin.\r\n    modifier onlyAdmin{\r\n        require(msg.sender==admin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change superAdmin.\r\n    /// @param addr The address to transfer the right of superAdmin to.\r\n    function changeSuperAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        superAdmin=addr;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change admin.\r\n    /// @param addr The address to transfer the right of admin to.\r\n    function changeAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        admin=addr;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to withdraw balance.\r\n    function withdrawBalance(uint256 amount) external onlySuperAdmin{\r\n        superAdmin.transfer(amount);\r\n    }\r\n\r\n    fallback() external {}\r\n}\r\n// File: security/Pausable.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\ncontract Pausable is AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant PAUSED='paused';\r\n    string constant NOT_PAUSED='not paused';\r\n\r\n    /// @dev Keeps track whether the contract is paused. When this is true, most actions are blocked.\r\n    bool public paused = false;\r\n\r\n    /// @dev Modifier to allow actions only when the contract is not paused\r\n    modifier whenNotPaused {\r\n        require(!paused,PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract is paused\r\n    modifier whenPaused {\r\n        require(paused,NOT_PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to pause the contract. Used when something goes wrong\r\n    ///  and we need to limit damage.\r\n    function pause() external onlySuperAdmin whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the superAdmin.\r\n    function unpause() external onlySuperAdmin whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n// File: ELFCore.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ELFBase is Pausable, IERC721TokenReceiver, IERC165, IERC721Metadata{\r\n\r\n    /// @dev Used for supportsInterface of ERC165.\r\n    bytes4 constant InterfaceSignature_ERC721=0x80ac58cd;\r\n    bytes4 constant InterfaceSignature_ERC165=0x01ffc9a7;\r\n    bytes4 constant InterfaceSignature_ERC721TokenReceiver=0x150b7a02;\r\n    bytes4 constant InterfaceSignature_ERC721Metadata=0x5b5e139f;\r\n    \r\n    /// @dev Value should be returned when we transfer NFT to a contract via safeTransferFrom.\r\n    bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    /// @dev Error message.\r\n    string constant NOT_VALID_NFT ='invalid NFT';\r\n\r\n    /// @dev The data type of ELF NFT instance.\r\n    struct ELF{\r\n        uint256 label;\r\n        uint256 dad;\r\n        uint256 mom;\r\n        uint256 gene;\r\n        uint256 bornAt;\r\n    }\r\n\r\n    string url='www.roe.com/';\r\n\r\n    /// @dev An array contains all existing ELF NFT instances.\r\n    ///  The tokenId of each NFT is actually an index into this array.\r\n    ELF[] ELFs;\r\n\r\n    /// @dev Mapping from tokenId to whether it is hatched.\r\n    mapping (uint256 => bool) tokenIdToHatched;\r\n\r\n    /// @dev Mapping from tokenId to its children.\r\n    mapping (uint256 => uint256[]) tokenIdToChildren;\r\n\r\n    function setURL(string memory _url) external onlyAdmin {\r\n        url=_url;\r\n    }\r\n\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure override returns (string memory _name){\r\n        return 'ELF';\r\n    }\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure override returns (string memory _symbol){\r\n        return 'ELF';\r\n    }\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view override returns (string memory){\r\n        require(_tokenId<ELFs.length && _tokenId!=0,NOT_VALID_NFT);\r\n        uint256 temp = _tokenId;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (_tokenId != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(_tokenId % 10)));\r\n            _tokenId /= 10;\r\n        }\r\n        return string(abi.encodePacked(url,string(buffer)));\r\n    }\r\n\r\n    ///  @dev Returns true for any standardized interfaces implemented by this contract. We implement\r\n    ///  ERC-165, ERC721TokenReceiver and ERC-721.\r\n    function supportsInterface(bytes4 _interfaceID) override external pure returns (bool){\r\n        return ((_interfaceID == InterfaceSignature_ERC165)||(_interfaceID == InterfaceSignature_ERC721)||(_interfaceID==InterfaceSignature_ERC721TokenReceiver)||(_interfaceID == InterfaceSignature_ERC721Metadata));\r\n    }\r\n\r\n    /// @dev Required for ERC721TokenReceiver compliance.\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) override pure external returns(bytes4){\r\n        return MAGIC_ON_ERC721_RECEIVED;\r\n    }\r\n\r\n    /// @dev Gain information of an ELF instance.\r\n    function gainELF(uint256 _tokenId) external view returns(uint256,uint256,uint256,uint256,uint256,uint256[] memory){\r\n        ELF memory _ELF=ELFs[_tokenId];\r\n        uint256 gene=_ELF.gene;\r\n        if (!tokenIdToHatched[_tokenId]){\r\n            gene=(gene/10000000000000000000000000000000000000000000000000000000000000)%10;\r\n        }\r\n        return(_ELF.label,_ELF.dad,_ELF.mom,gene,_ELF.bornAt,tokenIdToChildren[_tokenId]);\r\n    }\r\n}\r\n\r\ncontract ELFTransfer is ELFBase, IERC721{\r\n\r\n    using AddressUtils for address;\r\n\r\n    /// @dev Error message.\r\n    string constant WRONG_PARAMETER='wrong parameter';\r\n    string constant CANT_RECEIVE_NFT='can not receive NFT';\r\n\r\n    /// @dev Mapping from tokenId to the address that owns it. There is a valid owner\r\n    ///  for every ELF.\r\n    mapping (uint256 => address) tokenIdToOwner;\r\n\r\n    /// @dev Mapping from tokenId to index of arrary storing it.\r\n    mapping (uint256 => uint256) tokenIdToIndex;\r\n\r\n    /// @dev Mapping from owner to list of owned tokenIds.\r\n    mapping (address => uint256[]) ownedTokens;\r\n\r\n    /// @dev Mapping from tokenId to an address that has been approved to transfer this NFT. \r\n    ///  A zero value means no approved address.\r\n    mapping (uint256 => address) tokenIdToApproved;\r\n\r\n    /// @dev Mapping from owner address to authorized operators of that owner.\r\n    ///  true means authorized, false means unauthorized.\r\n    mapping (address => mapping (address => bool)) ownerToOperators;\r\n\r\n    /// @dev Mapping from address to tokenIds usable by the address but not owned by the address.\r\n    mapping (address => uint256[]) ownedByContractTokens;\r\n\r\n    /// @dev When the token is owned by smart contract, mapping from tokenId to its usable address.\r\n    ///  Can only be set by the owned smart contract.  \r\n    mapping (uint256 => address) tokenToUsable;\r\n\r\n    /// @dev Mapping from tokenId to its index of ownedByContractTokens.\r\n    mapping (uint256 => uint256) tokenToOwnedByContractTokensIndex;\r\n\r\n    /// @dev Whether tokenId has been hatched.\r\n    function isHatched(uint256 _tokenId) public view returns(bool res){\r\n        ownerOf(_tokenId);\r\n        res=tokenIdToHatched[_tokenId];\r\n    }\r\n\r\n    /// @dev Return owned tokenIds of an address.\r\n    function gainOwnedTokens(address addr) external view returns(uint256[] memory){\r\n        require(addr!=address(0),INVALID_ADDRESS);\r\n        return(ownedTokens[addr]);\r\n    }\r\n\r\n    /// @dev Internal function used to add ELF NFT instance to address _to.\r\n    /// @param _to Add token to _to.\r\n    /// @param _tokenId ELF NFT instance we want to operate.\r\n    function _addTo(address _to, uint256 _tokenId) internal{\r\n        tokenIdToOwner[_tokenId]=_to;\r\n        uint256[] storage _ownedTokens=ownedTokens[_to];\r\n        tokenIdToIndex[_tokenId]=_ownedTokens.length;\r\n        _ownedTokens.push(_tokenId);\r\n    }\r\n\r\n    /// @dev Internal function used to remove ELF NFT instance.\r\n    /// @param _tokenId ELF NFT instance we want to operate.\r\n    function _removeFrom(address _from,uint256 _tokenId) internal{\r\n        uint256[] storage _ownedTokens=ownedTokens[_from];\r\n        uint256 lastIndex=_ownedTokens.length-1;\r\n        uint256 lastTokenId=_ownedTokens[lastIndex];\r\n        uint256 tokenIndex=tokenIdToIndex[_tokenId];\r\n        delete tokenIdToOwner[_tokenId];\r\n        delete tokenIdToIndex[_tokenId];\r\n        tokenIdToIndex[lastTokenId]=tokenIndex;\r\n        _ownedTokens[tokenIndex]=lastTokenId;\r\n        _ownedTokens.pop();\r\n        if (tokenToUsable[_tokenId]!=address(0)){\r\n            removeFromOwnedByContractTokens(_tokenId);\r\n            tokenToUsable[_tokenId]=address(0);\r\n        }\r\n    }\r\n\r\n    function setTokenToUsable(uint256 tokenId, address addr) external{\r\n        require(msg.sender==ownerOf(tokenId) && msg.sender.isContract(),NO_PERMISSION);\r\n        if (tokenToUsable[tokenId]!=address(0)){\r\n            removeFromOwnedByContractTokens(tokenId);\r\n        }\r\n        tokenToUsable[tokenId]=addr;\r\n        tokenToOwnedByContractTokensIndex[tokenId]=ownedByContractTokens[addr].length;\r\n        ownedByContractTokens[addr].push(tokenId);\r\n    }\r\n\r\n    function removeFromOwnedByContractTokens(uint256 tokenId) internal{\r\n        address from=tokenToUsable[tokenId];\r\n        uint256 index=tokenToOwnedByContractTokensIndex[tokenId];\r\n        uint256 l=ownedByContractTokens[from].length;\r\n        uint256 lastTokenId=ownedByContractTokens[from][l-1];\r\n        ownedByContractTokens[from][index]=lastTokenId;\r\n        ownedByContractTokens[from].pop();\r\n        tokenToOwnedByContractTokensIndex[lastTokenId]=index;\r\n        delete tokenToOwnedByContractTokensIndex[tokenId];\r\n    }\r\n\r\n    /// @dev Return usable tokens of addr.\r\n    function usableTokens(address addr) external view returns(uint256[] memory){\r\n        require(addr!=address(0),INVALID_ADDRESS);\r\n        uint256[] memory temp1=ownedTokens[addr];\r\n        uint256[] memory temp2=ownedByContractTokens[addr];\r\n        uint256 l1=temp1.length;\r\n        uint256 l2=temp2.length;\r\n        uint256[] memory cache1 = new uint256[](l1);\r\n        uint256[] memory cache2 = new uint256[](l2);\r\n        uint256 count1;\r\n        uint256 count2;\r\n        for (uint256 i=0;i<l1;i++){\r\n            if (tokenIdToHatched[temp1[i]]){\r\n                count1++;\r\n                cache1[i]=temp1[i];\r\n            }\r\n        }\r\n        for (uint256 i=0;i<l2;i++){\r\n            if (tokenIdToHatched[temp2[i]]){\r\n                IGetter contractInstance=IGetter(ownerOf(temp2[i]));\r\n                try contractInstance.getUser(address(this),temp2[i]) returns (address tar){\r\n                    if (tar==addr){\r\n                        count2++;\r\n                        cache2[i]=temp2[i];\r\n                    }\r\n                } catch {}\r\n            }\r\n        }\r\n        uint256 index=0;\r\n        uint256[] memory res = new uint256[](count1+count2);\r\n        for (uint256 i=0;i<l1;i++){\r\n            if (cache1[i]!=0){\r\n                res[index]=cache1[i];\r\n                index++;\r\n            }\r\n        }\r\n        for (uint256 i=0;i<l2;i++){\r\n            if (cache2[i]!=0){\r\n                res[index]=cache2[i];\r\n                index++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /// @dev Required for ERC-721 compliance.\r\n    function balanceOf(address _owner) override external view returns (uint256){\r\n        require(_owner!=address(0),INVALID_ADDRESS);\r\n        return ownedTokens[_owner].length;\r\n    }\r\n\r\n    /// @dev Required for ERC-721 compliance.\r\n    function ownerOf(uint256 _tokenId) override public view returns (address res){\r\n        res=tokenIdToOwner[_tokenId];\r\n        require(res!=address(0),NOT_VALID_NFT);\r\n    }\r\n\r\n    /// @dev Required for ERC-721 compliance.\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) override external payable{\r\n        transferFrom(_from, _to, _tokenId);\r\n        if (_to.isContract()){\r\n            bytes4 retval=IERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, data);\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED,CANT_RECEIVE_NFT);\r\n        }\r\n    }\r\n\r\n    /// @dev Required for ERC-721 compliance.\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) override external payable{\r\n        transferFrom(_from, _to, _tokenId);\r\n        if (_to.isContract()){\r\n            bytes4 retval=IERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, '');\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED,CANT_RECEIVE_NFT);\r\n        }\r\n    }\r\n\r\n    /// @dev Required for ERC-721 compliance.\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) override public payable whenNotPaused{\r\n        address _owner=ownerOf(_tokenId);\r\n        require(msg.sender==_owner||ownerToOperators[_owner][msg.sender]||msg.sender==tokenIdToApproved[_tokenId],NO_PERMISSION);\r\n        require(_from==_owner,WRONG_PARAMETER);\r\n        require(_to!=address(0),INVALID_ADDRESS);\r\n        _removeFrom(_from,_tokenId);\r\n        _addTo(_to,_tokenId);\r\n        if (tokenIdToApproved[_tokenId]!=address(0)){\r\n            delete tokenIdToApproved[_tokenId];\r\n            emit Approval(_from, address(0), _tokenId);\r\n        }\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @dev Required for ERC-721 compliance.\r\n    function approve(address _approved, uint256 _tokenId) override external payable whenNotPaused{\r\n        address _owner=ownerOf(_tokenId);\r\n        require(msg.sender==_owner||ownerToOperators[_owner][msg.sender],NO_PERMISSION);\r\n        tokenIdToApproved[_tokenId]=_approved;\r\n        emit Approval(_owner,_approved,_tokenId);\r\n    }\r\n\r\n    /// @dev Required for ERC-721 compliance.\r\n    function setApprovalForAll(address _operator, bool _approved) override external whenNotPaused{\r\n        ownerToOperators[msg.sender][_operator]=_approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /// @dev Required for ERC-721 compliance.\r\n    function getApproved(uint256 _tokenId) override external view returns (address){\r\n        ownerOf(_tokenId);\r\n        return tokenIdToApproved[_tokenId];\r\n    }\r\n\r\n    /// @dev Required for ERC-721 compliance.\r\n    function isApprovedForAll(address _owner, address _operator) override external view returns (bool){\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n\r\n    ///@dev Only res1 can use tokenId. Coin B earned by tokenId should distribute to res2.\r\n    function userOfCoinBTo(uint256[] memory tokenIds) external view returns (address[] memory,address[] memory){\r\n        uint256 l=tokenIds.length;\r\n        address[] memory res1=new address[](l);\r\n        address[] memory res2=new address[](l);\r\n        address owner;\r\n        uint256 tokenId;\r\n        for (uint256 i=0;i<l;i++){\r\n            tokenId=tokenIds[i];\r\n            owner=ownerOf(tokenId);\r\n            if (tokenIdToHatched[tokenId]){\r\n                if (owner.isContract()){\r\n                    IGetter contractInstance=IGetter(owner);\r\n                    try contractInstance.getUser(address(this),tokenId) returns(address temp){\r\n                        res1[i]=temp;\r\n                    }catch{res1[i]=address(0);}\r\n                    try contractInstance.getCoinB(address(this),tokenId) returns(address temp){\r\n                        res2[i]=temp;\r\n                    }catch{res2[i]=address(0);}\r\n                }\r\n                else{\r\n                    res1[i]=owner;\r\n                    res2[i]=owner;\r\n                }\r\n            }\r\n            else{\r\n                res1[i]=address(0);\r\n                res2[i]=address(0);\r\n            }\r\n        }\r\n        return (res1,res2);\r\n    }\r\n\r\n    /// @dev Gain all genes of ELFs in tokenIds.\r\n    function gainGenes(uint256[] memory tokenIds) external view returns(uint256[] memory){\r\n        uint256 l=tokenIds.length;\r\n        uint256[] memory res = new uint256[](l);\r\n        for (uint256 i=0;i<l;i++){\r\n            if (isHatched(tokenIds[i])){\r\n                ELF memory _ELF=ELFs[tokenIds[i]];\r\n                res[i]=_ELF.gene;\r\n            }\r\n            else{\r\n                res[i]=0;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\ncontract ELFCore is ELFTransfer{\r\n\r\n    /// @dev This is the spawan of chaos. Whether it is an ELF is still a mystery. \r\n    ///  No one has the ability to own it.\r\n    constructor(){\r\n        ELF memory _ELF=ELF({\r\n            label:777,\r\n            dad:0,\r\n            mom:0,\r\n            gene:0,\r\n            bornAt:block.timestamp\r\n        });\r\n        ELFs.push(_ELF);\r\n        tokenIdToHatched[0]=true;\r\n    }\r\n\r\n    /// @dev Error message.\r\n    string constant WRONG_MONEY='money not enough';\r\n    string constant EXCEED_MAX_SPAWN_TIMES ='exceed maximum spawan time';\r\n    string constant CLOSE_BREEDING='close breeding';\r\n    string constant NOT_MATURE='egg not mature';\r\n    string constant HATCHED='egg hatched';\r\n\r\n    /// @dev This event should be fired whenever the address of capsule contract is modified.\r\n    event CapsuleContractChanged(address indexed _from,address indexed _to, uint256 _time);\r\n\r\n    /// @dev The address of current capsule contract.\r\n    address public capsuleContractAddress;\r\n\r\n    /// @dev Total capsule number. Can't bigger than 5000.\r\n    uint256 public capsuleCount;\r\n\r\n    /// @dev Change capsule contract.\r\n    ///  Caller should always be administrator. addr is the address of new capsule contract.\r\n    function changeCapsuleContract(address addr) external onlySuperAdmin{\r\n        require(addr!=address(0),INVALID_ADDRESS);\r\n        emit CapsuleContractChanged(capsuleContractAddress,addr,block.timestamp);\r\n        capsuleContractAddress=addr;\r\n    }\r\n\r\n    /// @dev Capsule machine. Capsule contract is assigned by superAdmin, \r\n    ///  so we do not have to worry about reentrancy attack here.\r\n    function capsuleMachine(bool triple) external payable whenNotPaused {\r\n        uint256 count=1;\r\n        if (triple){\r\n            count=3;\r\n        }\r\n        capsuleCount+=count;\r\n        require(capsuleCount<=5000,'capsule limit exceeded');\r\n        ICapsuleContract capsuleContractInstance=ICapsuleContract(capsuleContractAddress);\r\n        (uint256 price,)=capsuleContractInstance.getPriceInfo();\r\n        require(msg.value>=price*count,WRONG_MONEY);\r\n        uint256 label;\r\n        uint256[] memory genes = new uint256[](count);\r\n        (genes,label)=capsuleContractInstance.createCapsule(msg.sender,triple);\r\n        for(uint256 i=0;i<count;i++){\r\n            ELF memory _ELF=ELF({\r\n                label:label,\r\n                dad:0,\r\n                mom:0,\r\n                gene:genes[i],\r\n                bornAt:block.timestamp+432000\r\n            });\r\n            _addTo(msg.sender,ELFs.length);\r\n            emit Transfer(address(0),msg.sender,ELFs.length);\r\n            ELFs.push(_ELF);\r\n        }\r\n        if (msg.value>price*count){\r\n            payable(msg.sender).transfer(msg.value-price*count);\r\n        }\r\n    }\r\n\r\n    /// @dev This event should be fired whenever the address of SpawnContract is modified.\r\n    event SpawnContractChanged(address indexed _from,address indexed _to, uint256 _time);\r\n\r\n    /// @dev The address of SpawnContract.\r\n    address public SpawnContractAddress;\r\n\r\n    /// @dev Change SpawnContract address. \r\n    ///  Caller should always be superAdmin. addr is the address of new SpawnContract address.\r\n    function changeSpawnContract(address addr) external onlySuperAdmin{\r\n        require(addr!=address(0),INVALID_ADDRESS);\r\n        emit SpawnContractChanged(SpawnContractAddress,addr,block.timestamp);\r\n        SpawnContractAddress=addr;\r\n    }\r\n\r\n    /// @dev Maximun spawning time of an ELF.\r\n    uint256 public constant maxSpawnTimes=7;\r\n    \r\n    /// @dev Spawn an egg of ELF. Mint NFT. Spawn contract is assigned by superAdmin, \r\n    ///  so we do not have to worry about reentrancy attack here.\r\n    /// @param momTokenId tokenId of one of parent of new ELF. ELF has no gender, mom and dad is used for convinience.\r\n    /// @param dadTokenId tokenId of one of parent of new ELF.\r\n    function spawnEgg(uint256 momTokenId,uint256 dadTokenId) external whenNotPaused returns (uint256 tokenId){\r\n        require(msg.sender==ownerOf(momTokenId),NO_PERMISSION);\r\n        require(msg.sender==ownerOf(dadTokenId),NO_PERMISSION);\r\n        uint256 dadChildrenCount=tokenIdToChildren[dadTokenId].length;\r\n        uint256 momChildrenCount=tokenIdToChildren[momTokenId].length;\r\n        require(momChildrenCount<maxSpawnTimes,EXCEED_MAX_SPAWN_TIMES);\r\n        require(dadChildrenCount<maxSpawnTimes,EXCEED_MAX_SPAWN_TIMES);\r\n        require(tokenIdToHatched[momTokenId]&&tokenIdToHatched[dadTokenId],WRONG_PARAMETER);\r\n        require(momTokenId!=dadTokenId,WRONG_PARAMETER);\r\n        ELF memory _mom=ELFs[momTokenId];\r\n        ELF memory _dad=ELFs[dadTokenId];\r\n        if (!(fromChaos(_mom) && fromChaos(_dad))){\r\n            require(_mom.mom!=dadTokenId,CLOSE_BREEDING);\r\n            require(_mom.dad!=dadTokenId,CLOSE_BREEDING);\r\n            require(_dad.mom!=momTokenId,CLOSE_BREEDING);\r\n            require(_dad.dad!=momTokenId,CLOSE_BREEDING);\r\n        }\r\n        if (!fromChaos(_mom) && !fromChaos(_dad)){\r\n            require(_mom.mom!=_dad.mom,CLOSE_BREEDING);\r\n            require(_mom.mom!=_dad.dad,CLOSE_BREEDING);\r\n            require(_mom.dad!=_dad.mom,CLOSE_BREEDING);\r\n            require(_mom.dad!=_dad.dad,CLOSE_BREEDING);\r\n        } \r\n        uint256 seed=block.timestamp+dadChildrenCount+momChildrenCount;\r\n        uint256 gene=ISpawnContract(SpawnContractAddress).spawnEgg(seed,_mom.gene,_dad.gene,momChildrenCount,dadChildrenCount,msg.sender,fromChaos(_mom),fromChaos(_dad));\r\n        ELF memory _ELF=ELF({\r\n            label:0,\r\n            dad:dadTokenId,\r\n            mom:momTokenId,\r\n            gene:gene,\r\n            bornAt:seed+432000\r\n        });\r\n        tokenId=ELFs.length;\r\n        ELFs.push(_ELF);\r\n        _addTo(msg.sender,tokenId);\r\n        tokenIdToChildren[momTokenId].push(tokenId);\r\n        tokenIdToChildren[dadTokenId].push(tokenId);\r\n        emit Transfer(address(0),msg.sender,tokenId);\r\n    }\r\n\r\n    /// @dev Hatch an egg.\r\n    function hatchELF(uint256 tokenId) external whenNotPaused{\r\n        ELF memory _ELF=ELFs[tokenId];\r\n        require(!tokenIdToHatched[tokenId],HATCHED);\r\n        require(msg.sender==ownerOf(tokenId),NO_PERMISSION);\r\n        require(block.timestamp>=_ELF.bornAt,NOT_MATURE);\r\n        tokenIdToHatched[tokenId]=true;\r\n    }\r\n\r\n    /// @dev Whether the given ELF is from chaos.\r\n    function fromChaos(ELF memory _ELF) internal pure returns(bool){\r\n        return _ELF.mom==0;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"CapsuleContractChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"SpawnContractChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"SpawnContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"capsuleContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"capsuleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"triple\",\"type\":\"bool\"}],\"name\":\"capsuleMachine\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeCapsuleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeSpawnContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"gainELF\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"gainGenes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"gainOwnedTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"hatchELF\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isHatched\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"res\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSpawnTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"res\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setTokenToUsable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"setURL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"momTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dadTokenId\",\"type\":\"uint256\"}],\"name\":\"spawnEgg\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"usableTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"userOfCoinBTo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ELFCore", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://40c97a41f9a2d3ab5fe92798e5e972d8c276fd1f78c1c05961798d04e5d699d6"}