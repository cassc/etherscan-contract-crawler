{"SourceCode": "// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableSet.\r\n * ====\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: battle.sol\r\n\r\n\r\npragma solidity 0.8.19;\r\n/*\\\r\nCreated by SolidityX for Decision Game\r\nTelegram: @solidityX\r\n\\*/\r\n\r\n\r\n\r\n\r\n/*\\\r\nUniswap router interface so that the contract can swap tokens;\r\n\\*/\r\ninterface IUniswapV2Router {\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n}\r\n\r\n/*\\\r\nused to check if the user has any of the tokens\r\n\\*/\r\ninterface IERC1155 {\r\n    function balanceOf(address account, uint id) external returns(uint);   \r\n}\r\n\r\n/*\\\r\nused to check if the user has any of the tokens\r\n\\*/\r\ninterface IERC721 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n/*\\\r\nused to deposit funds into the treasury\r\n\\*/\r\ninterface IVault {\r\n    function deposit(address _token, uint _amount) external returns(bool);\r\n}\r\n\r\n/*\\\r\nlink swap contract to convert erc20 link into erc677 link\r\n\\*/\r\ninterface ILinkSwap {\r\n    function swap(uint256 amount, address source, address target) external;\r\n}\r\n\r\n/*\\\r\nused to deposit erc677 link into the chainlink automation\r\n\\*/\r\ninterface automation {\r\n    function addFunds(uint256 id, uint96 amount) external;\r\n}\r\n\r\n\r\ncontract Battle {\r\n\r\n    using SafeMath for uint;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    /*\\\r\n    saves all values of each gamme\r\n    \\*/\r\n    struct game {\r\n        address player1;\r\n        address player2;\r\n        uint256 stakes;\r\n        address winner;\r\n        uint startedAt;\r\n        uint feePaid;\r\n    }\r\n\r\n    /*\\\r\n    saves stats of each wallet\r\n    \\*/\r\n    struct player {\r\n        uint[] gamesPlayed;\r\n        uint[] gamesWon;\r\n        uint[] gamesLost;\r\n        uint[] gamesDrawn;\r\n    }\r\n\r\n\r\n    address private owner; // owner of contract\r\n    address private dev; // address of dev \r\n    address private LPstaking; // address of LP staking contract\r\n    address constant private weth = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270; // weth address\r\n    address constant private dead = 0x000000000000000000000000000000000000dEaD; // dead address\r\n\r\n    EnumerableSet.AddressSet private operators; // list of all operators\r\n    IUniswapV2Router private router; // router address of dex\r\n    automation private registry; // registry of chainlink automation\r\n    IVault private team; // address of treasury\r\n    IERC20 constant private mainToken = IERC20(0x8865BC57c58Be23137ACE9ED1Ae1A05fE5c8B209); // main tkens address\r\n    IERC721 constant private erc721 = IERC721(0x564e6588DAfA2F79c5805e07860CB869AEdb33d9); // nft tokens contract\r\n    IERC1155 constant private erc1155 = IERC1155(0x46d0DD5aafeb3cd3Ec75907312e911ea806bDFA7); // address of erc155 tken\r\n    ILinkSwap constant private linkSwap = ILinkSwap(0xAA1DC356dc4B18f30C347798FD5379F3D77ABC5b); // to convert link1 to link2\r\n    IERC20 constant private link = IERC20(0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39); // chainlink's link token\r\n    IERC20 constant private link2 = IERC20(0xb0897686c545045aFc77CF20eC7A532E3120E0F1); //chainlink's link token for automation deposit\r\n    \r\n    mapping(address => uint) private inGame; // mapping to check which game the player is currently on\r\n    mapping(uint => game) private Gamelist; // mapping from gameId to game\r\n    mapping(address => player) private stats; // mapping from player to playerStats\r\n    \r\n\r\n    uint private id; // id of chainlink automation\r\n    uint private currentGame = 1; // current  game  id\r\n    uint private feePP = 5e16; // matic fee per player\r\n    uint private fee; // current fee\r\n    uint private mFee; // current matic fee\r\n    uint private minFeeForExecution = 100e18; // minimum fee to execute proccessing\r\n    uint constant public burnFee = 6; // token burn fee given in percent\r\n    uint constant public teamFee = 1; // treasury fee given in percent\r\n    uint constant public LPStakingFee = 3; // lp staking reward fee given in percent\r\n    uint constant public tFee = 10; // total fee given in percent\r\n\r\n    /*\\\r\n    sets all important variable and approves tokens accordingly at deployment\r\n    \\*/\r\n    constructor(address _operator, address _staking, address _team, address _router, address _registry, uint _id){\r\n        owner = msg.sender;\r\n        dev = msg.sender;\r\n        operators.add(_operator);\r\n        LPstaking = _staking;\r\n        team = IVault(_team);\r\n        router = IUniswapV2Router(_router);\r\n        registry = automation(_registry);\r\n        id = _id;\r\n        mainToken.approve(address(team), 2**256 - 1);\r\n        link2.approve(address(registry), 2**256-1); \r\n        link.approve(address(linkSwap), 2**256-1);\r\n    }\r\n\r\n    /*\\\r\n    functions with this modifier can only be called by the owner or dev\r\n    \\*/\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"!owner\");\r\n        _;\r\n    }\r\n\r\n    /*\\\r\n    functions with this modifier can only be called by the dev or owner\r\n    \\*/\r\n    modifier onlyDev() {\r\n        require(msg.sender == dev || msg.sender == owner, \"!dev\");\r\n        _;\r\n    }\r\n\r\n    /*\\\r\n    functions with this modifier can only be called by the operators\r\n    \\*/\r\n    modifier onlyOperator() {\r\n        require(operators.contains(msg.sender), \"!operator\");\r\n        _;\r\n    }\r\n\r\n    event newGame(uint indexed id, address indexed creator, uint indexed bet); // event for newGame\r\n    event joinedGame(uint indexed id, address indexed player, uint indexed bet); // event for joining game\r\n    event endedGame(uint indexed id, address indexed winner, uint indexed bet); // event for ending games\r\n    event gameCanceled(uint indexed id, address indexed creator); // event for canceled games\r\n    event FeeChanged(uint indexed oldFee, uint indexed newFee); // event for fee changes\r\n    event idChanged(uint indexed oldId, uint indexed newId); // event for chainlink automation id changes\r\n    event treasuryChanged(address indexed oldTreasury, address indexed newTreasury); // event for treasury change\r\n    event registryChanged(address indexed oldRegisty, address indexed newRegistry); // event for chainlink registry change\r\n    event routerChanged(address indexed oldRouter, address indexed newRouter); // event for router change\r\n    event stakingChanged(address indexed oldStaking, address indexed newStaking); // event for staking contract change\r\n    event minFeeForExecutionChanged(uint indexed oldMin, uint indexed newMin); // event for minFeeForExecution change\r\n    event ownershipTransfered(address indexed oldOwner, address indexed newOwner); // event for owner change\r\n    event devTransfered(address indexed oldDev, address indexed newDev); // event for dev change\r\n\r\n/*//////////////////////////////////////////////\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\r\n///////////////////////////////////////////////executeables\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\____________/////////////////////////////////////////////*/\r\n\r\n\r\n    /*\\\r\n    sets id of chainlink automation\r\n    \\*/\r\n    function setId(uint _id) public onlyDev {\r\n        uint oldId = id;\r\n        id = _id;\r\n        emit idChanged(oldId, _id);\r\n    }\r\n\r\n    /*\\\r\n    set matic fee per player\r\n    \\*/\r\n    function setFeePP(uint _fee) public onlyOwner {\r\n        uint oldFee = feePP;\r\n        feePP = _fee;\r\n        emit FeeChanged(oldFee, _fee);\r\n    }\r\n\r\n    /*\\\r\n    sets registry of chainlink automation\r\n    \\*/\r\n    function setRegistry(address _registry) public onlyDev {\r\n        require(_registry != address(0x0), \"registry cannot be 0x0!\");\r\n        address oldRegistry = address(registry);\r\n        registry = automation(_registry);\r\n        emit registryChanged(oldRegistry, address(registry));\r\n    }\r\n\r\n    /*\\\r\n    sets router address\r\n    \\*/\r\n    function setRouter(address _router) public onlyOwner {\r\n        address oldRouter = address(router);\r\n        router = IUniswapV2Router(_router);\r\n        emit routerChanged(oldRouter, _router);\r\n    }\r\n\r\n    /*\\\r\n    transfers owner\r\n    \\*/\r\n    function setOwner(address _add) public onlyOwner{\r\n        require(_add != address(0x0), \"owner cannot be 0x0!\");\r\n        address oldOwner = owner;\r\n        owner = _add;\r\n        emit ownershipTransfered(oldOwner, _add);\r\n    }\r\n\r\n    /*\\\r\n    transfers dev\r\n    \\*/\r\n    function transferDev(address _add) public onlyDev {\r\n        require(_add != address(0x0), \"dev cannot be 0x0!\");\r\n        address oldDev = dev;\r\n        dev = _add;\r\n        emit devTransfered(oldDev, _add);\r\n    }\r\n\r\n    /*\\\r\n    set the dev address to 0x0\r\n    \\*/\r\n    function renounceDev() public onlyDev {\r\n        address oldDev = dev;\r\n        dev = address(0x0);\r\n        emit devTransfered(oldDev, address(0x0));\r\n    }\r\n\r\n    /*\\\r\n    renounce owner\r\n    \\*/\r\n    function renounceOwner() public onlyOwner{\r\n        address oldOwner = owner;\r\n        owner = address(0x0);\r\n        emit ownershipTransfered(oldOwner, address(0x0));\r\n    }\r\n\r\n    /*\\\r\n    set team address (treasury)\r\n    \\*/\r\n    function setTeam(address _add) public onlyOwner {\r\n        require(_add != address(0x0), \"treasury can't be 0x0!\");\r\n        address oldTeam = address(team);\r\n        team = IVault(_add);\r\n        emit treasuryChanged(oldTeam, _add);\r\n    }\r\n\r\n    /*\\\r\n    set staking contract\r\n    \\*/\r\n    function setStaking(address _add) public onlyOwner {\r\n        require(_add != address(0x0), \"staking can't be 0x0!\");\r\n        address oldLPStaking = LPstaking;\r\n        LPstaking = _add;\r\n        emit stakingChanged(oldLPStaking, _add);\r\n    }\r\n\r\n    /*\\\r\n    sets the minimum amount of tokens where the fee distribution is triggered\r\n    \\*/\r\n    function setMinFeeForExecution(uint _min) public onlyDev {\r\n        uint oldMinFeeForExecution = minFeeForExecution;\r\n        minFeeForExecution = _min;\r\n        emit minFeeForExecutionChanged(oldMinFeeForExecution, _min);\r\n    }\r\n\r\n    /*\\\r\n    toggles operator\r\n    \\*/\r\n    function setOperator(address _add) public onlyOwner{\r\n        require(_add != address(0x0), \"operator can't be 0x0!\");\r\n        if (operators.contains(_add))\r\n            operators.remove(_add);\r\n        else\r\n            operators.add(_add);\r\n    }\r\n\r\n    /*\\\r\n    create a new game\r\n    \\*/\r\n    function createGame(uint256 _bet) public payable returns(uint256 _id, uint256 bet, bool started) {\r\n        require(!operators.contains(msg.sender), \"operator cannot create game!\");\r\n        require(inGame[msg.sender] == 0, \"already joined a game atm!\");\r\n        require(msg.value == feePP, \"please provide the required fee!\"); \r\n        require(_bet >= 10e18, \"Bet must be higher than 10!\");\r\n        require(_bet <= 250000e18, \"bet too big!\");\r\n        require(mainToken.transferFrom(msg.sender, address(this), _bet), \"bet transfer failed!\");\r\n        \r\n        if(_bet > 10000e18 && _bet <= 50000e18) {\r\n            require(erc1155.balanceOf(msg.sender, 1) > 0 ||\r\n                    erc1155.balanceOf(msg.sender, 2) > 0 ||\r\n                    erc1155.balanceOf(msg.sender, 3) > 0 ||\r\n                    erc1155.balanceOf(msg.sender, 4) > 0 ||\r\n                    erc1155.balanceOf(msg.sender, 5) > 0, \"Please purchse coin! (erc1155)\");\r\n        }\r\n        if(_bet > 50000e18)\r\n            require(erc721.balanceOf(msg.sender) > 0, \"please purchase a nft. (erc721)\");\r\n        \r\n        inGame[msg.sender] = currentGame;\r\n        game memory Game = game(msg.sender, address(0x0), _bet, address(0x0), block.timestamp, feePP);\r\n        stats[msg.sender].gamesPlayed.push(currentGame);\r\n        Gamelist[currentGame] = Game;\r\n        currentGame++;\r\n        \r\n        emit newGame(currentGame-1, msg.sender, _bet);\r\n        \r\n        return (currentGame, _bet, false);\r\n    }\r\n\r\n    /*\\\r\n    join a game\r\n    \\*/\r\n    function joinGame(uint _id) public payable returns(bool){\r\n        require(!operators.contains(msg.sender), \"operator cannot join game!\");\r\n        require(msg.value == Gamelist[_id].feePaid, \"please provide the required fee!\"); \r\n        require(inGame[msg.sender] == 0, \"already joined a game atm!\");\r\n        require(mainToken.transferFrom(msg.sender, address(this), Gamelist[_id].stakes), \"payment failed!\");\r\n        require(Gamelist[_id].winner == address(0x0), \"game was shut down!\");\r\n        require(Gamelist[_id].player1 != address(0x0), \"invalid id!\");\r\n        require(Gamelist[_id].player2 == address(0x0), \"game full!\");\r\n        \r\n        inGame[msg.sender] = _id;\r\n        Gamelist[_id].player2 = msg.sender;\r\n        stats[msg.sender].gamesPlayed.push(_id);\r\n        \r\n        emit joinedGame(_id, msg.sender, Gamelist[_id].stakes);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /*\\\r\n    cancels game if no other player joins\r\n    \\*/\r\n    function cancel(uint _id) public returns(bool){\r\n        require(Gamelist[_id].player2 == address(0x0), \"opponent already joined!\");\r\n        require(Gamelist[_id].player1 == msg.sender || operators.contains(msg.sender), \"not game creator or operator!\");\r\n        require(mainToken.transfer(Gamelist[_id].player1, Gamelist[_id].stakes), \"refund transfer failed!\");\r\n        \r\n        inGame[Gamelist[_id].player1] = 0;\r\n        Gamelist[_id].player2 = Gamelist[_id].player1;\r\n        Gamelist[_id].winner = Gamelist[_id].player1;\r\n        \r\n        payable(Gamelist[_id].player1).transfer(Gamelist[_id].feePaid);\r\n        \r\n        emit gameCanceled(_id, Gamelist[_id].player1);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /*\\\r\n    operator ends game and sets winner\r\n    \\*/\r\n    function endGame(uint256 _id, address winner) public onlyOperator returns(bool){\r\n        require(Gamelist[_id].winner == address(0x0), \"winner already set!\");\r\n        require(Gamelist[_id].player2 != address(0x0),  \"game not full!\");\r\n        require(winner == address(0x0) || winner == Gamelist[_id].player1 || winner == Gamelist[_id].player2, \"winner not player or draw\");\r\n        \r\n        inGame[Gamelist[_id].player1] = 0;\r\n        inGame[Gamelist[_id].player2] = 0;\r\n        \r\n        Gamelist[_id].winner = winner == address(0x0) ? msg.sender : winner;\r\n        \r\n        payable(msg.sender).transfer(Gamelist[_id].feePaid);\r\n        \r\n        _distributeFee();\r\n\r\n        emit endedGame(_id, winner, Gamelist[_id].stakes);\r\n\r\n        if(winner == address(0x0)) {\r\n            require(mainToken.transfer(Gamelist[_id].player1, Gamelist[_id].stakes), \"transfer failed, 1!\");\r\n            require(mainToken.transfer(Gamelist[_id].player2, Gamelist[_id].stakes), \"transfer failed, 2!\");\r\n            stats[Gamelist[_id].player1].gamesDrawn.push(_id);\r\n            stats[Gamelist[_id].player2].gamesDrawn.push(_id);\r\n            return true;\r\n        }\r\n        \r\n        mFee = mFee.add(Gamelist[_id].feePaid);\r\n        uint _fee = (Gamelist[_id].stakes.mul(2)).mul(tFee).div(100);\r\n        fee = fee.add(_fee);\r\n        uint win = (Gamelist[_id].stakes.mul(2)).sub(_fee);\r\n        require(mainToken.transfer(winner, win), \"transfer failed, winner!\");\r\n\r\n        address loser = winner == Gamelist[_id].player1 ? Gamelist[_id].player2 : Gamelist[_id].player1;\r\n        stats[winner].gamesWon.push(_id);\r\n        stats[loser].gamesLost.push(_id);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*\\\r\n    distributes the fee in it exceeds the minFeeForExecution\r\n    \\*/\r\n    function _distributeFee() private {\r\n        if(fee >= minFeeForExecution) {\r\n            uint _burnFee = fee.mul(burnFee).div(tFee);\r\n            uint _teamFee = fee.mul(teamFee).div(tFee);\r\n            uint _LPStakingFee = fee.mul(LPStakingFee).div(tFee);\r\n            mainToken.transfer(dead, _burnFee);\r\n            require(team.deposit(address(mainToken), _teamFee), \"transfer failed, team vault!\");\r\n            require(mainToken.transfer(LPstaking, _LPStakingFee), \"transfer failed, LP Staking!\");\r\n            require(_fundAutomation(), \"automation funding failed!\");\r\n            fee = 0;\r\n            mFee = 0;\r\n        }\r\n    }\r\n\r\n\r\n    /*\\\r\n    funds chainlink automation with link\r\n    \\*/\r\n    function _fundAutomation() private returns(bool) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = weth;\r\n        path[1] = address(link);\r\n        \r\n        router.swapExactETHForTokens {value: mFee}(\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        \r\n        linkSwap.swap(link.balanceOf(address(this)), address(link), address(link2));\r\n        registry.addFunds(id, uint96(link2.balanceOf(address(this))));\r\n        \r\n        return true;\r\n    }\r\n\r\n    /*\\\r\n    allows contract to receive ETH\r\n    \\*/\r\n    receive() external payable {}\r\n\r\n\r\n/*//////////////////////////////////////////////\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*\\\r\n///////////////////////////////////////////////viewable/misc\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\n\\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____________/////////////////////////////////////////////*/\r\n\r\n\r\n    /*\\\r\n    returns the owner's address\r\n    \\*/\r\n    function getOwner() external view returns(address) {\r\n        return owner;\r\n    }\r\n\r\n    /*\\\r\n    returns the dev's address\r\n    \\*/\r\n    function getDev() external view returns(address) {\r\n        return dev;\r\n    }\r\n\r\n    /*\\\r\n    returns latest game id\r\n    \\*/\r\n    function latestGame() external view returns(uint) {\r\n        return currentGame;\r\n    }\r\n\r\n    /*\\\r\n    return the current feePP\r\n    \\*/\r\n    function getFeePP() external view returns(uint) {\r\n        return feePP;\r\n    }\r\n\r\n    /*\\\r\n    gets the fee paid or that needs to be paid to join the game\r\n    \\*/\r\n    function getFeeFor(uint _id) external view returns(uint) {\r\n        return Gamelist[_id].feePaid;\r\n    }\r\n\r\n    /*\\\r\n    returns total games won of address\r\n    \\*/\r\n    function getTotalWonOf(address _add) public view returns(uint) {\r\n        return stats[_add].gamesWon.length;\r\n    }\r\n\r\n    /*\\\r\n    returns total lost games of address\r\n    \\*/\r\n    function getTotalLostOf(address _add) public view returns(uint) {\r\n        return stats[_add].gamesLost.length;\r\n    }\r\n\r\n    /*\\\r\n    returns total played games of address\r\n    \\*/\r\n    function getTotalPlayedOf(address _add) public view returns(uint) {\r\n        return stats[_add].gamesPlayed.length;\r\n    }\r\n\r\n    /*\\\r\n    return what address is currently playing on\r\n    \\*/\r\n    function playingOn(address _add) external view returns(uint) {\r\n        return inGame[_add];\r\n    }\r\n\r\n    /*\\\r\n    returns all ids of won games of address\r\n    \\*/\r\n    function getAllWonOf(address _add) external view returns(uint[] memory) {\r\n        return stats[_add].gamesWon;\r\n    }\r\n\r\n    /*\\\r\n    returns all ids of games played of address\r\n    \\*/\r\n    function getAllPlayedOf(address _add) external view returns(uint[] memory) {\r\n        return stats[_add].gamesPlayed;\r\n    }\r\n\r\n    /*\\\r\n    returns all ids of lost games of address\r\n    \\*/\r\n    function getAllLostOf(address _add) external view returns(uint[] memory) {\r\n        return stats[_add].gamesLost;\r\n    }\r\n\r\n    /*\\\r\n    returns all ids of draw games of address \r\n    \\*/\r\n    function getAllDrawnOf(address _add) external view returns(uint[] memory) {\r\n        return stats[_add].gamesDrawn;\r\n    }\r\n\r\n    /*\\\r\n    returns total games drawn of address\r\n    \\*/\r\n    function getTotalGamesDrawnOf(address _add) public view returns(uint) {\r\n        return getTotalPlayedOf(_add) - (getTotalWonOf(_add) + getTotalLostOf(_add));\r\n    }\r\n\r\n    /*\\\r\n    returns W/L rate of player\r\n    \\*/\r\n    function getWLOf(address _add) external view returns(uint)  {\r\n        return getTotalWonOf(_add) * 1e18 / getTotalLostOf(_add);\r\n    }  \r\n\r\n    /*\\\r\n    returns win percentage of player\r\n    \\*/\r\n    function getWinPercentageOf(address _add) external view returns(uint) {\r\n        return 100e18 / getTotalPlayedOf(_add) * getTotalWonOf(_add);\r\n    }\r\n\r\n    /*\\\r\n    returns loose percentage of player\r\n    \\*/\r\n    function getLoosePercentageOf(address _add) external view returns(uint) {\r\n        return 100e18 / getTotalPlayedOf(_add) * getTotalLostOf(_add);\r\n    }\r\n\r\n    /*\\\r\n    returns draw percentage of player\r\n    \\*/\r\n    function getDrawPercentageOf(address _add) external view returns(uint) {\r\n        return 100e18 / getTotalPlayedOf(_add) * getTotalGamesDrawnOf(_add);\r\n    }\r\n    \r\n    /*\\\r\n    returns information of game id\r\n    \\*/\r\n    function getGame(uint _id) external view returns(uint, uint, address, address, address, uint) {\r\n        return (getState(_id), Gamelist[_id].stakes, Gamelist[_id].player1, Gamelist[_id].player2, Gamelist[_id].winner, Gamelist[_id].feePaid);\r\n    }\r\n\r\n    /*\\\r\n    returns current state of game id\r\n    \\*/\r\n    function getState(uint _id) public view returns(uint) {\r\n        uint state = 0;\r\n        if(Gamelist[_id].winner != address(0x0))\r\n            state = 3;\r\n        else if(Gamelist[_id].player1 != address(0x0) && Gamelist[_id].player2 == address(0x0))\r\n            state = 1;\r\n        else if(Gamelist[_id].player1 != address(0x0) && Gamelist[_id].player2 != address(0x0))\r\n            state = 2;\r\n        return state;\r\n    }\r\n\r\n    /*\\\r\n    get a list of all operators\r\n    \\*/\r\n    function getOperators() external view returns(address[] memory) {\r\n        address[] memory ops = new address[](operators.length());\r\n        for(uint i; i < ops.length; i++) {\r\n            ops[i] = operators.at(i);\r\n        }\r\n        return ops;\r\n    } \r\n\r\n    /*\\\r\n    returns all current active games\r\n    \\*/\r\n    function getAllActive(uint _start) external view returns(uint[] memory, uint[] memory, uint[] memory, uint) {\r\n        uint count = 0;\r\n        for(uint i = _start; i < currentGame; i++) {\r\n            if(Gamelist[i].winner == address(0x0))\r\n                count++;\r\n        }\r\n        uint[] memory _id = new uint[](count);\r\n        uint[] memory _times = new uint[](count);\r\n        uint[] memory _state = new uint[](count);\r\n        count = 0;\r\n        for(uint i = _start; i < currentGame; i++) {\r\n            if(Gamelist[i].winner == address(0x0)) {\r\n                _id[count] = i;\r\n                _times[count] = Gamelist[i].startedAt;\r\n                _state[count] = getState(i);\r\n                count++;\r\n            }\r\n        }\r\n        return (_id, _times, _state, block.timestamp);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_team\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldDev\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"devTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"endedGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"gameCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newId\",\"type\":\"uint256\"}],\"name\":\"idChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"joinedGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldMin\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newMin\",\"type\":\"uint256\"}],\"name\":\"minFeeForExecutionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"newGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownershipTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRegisty\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRegistry\",\"type\":\"address\"}],\"name\":\"registryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRouter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"routerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldStaking\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newStaking\",\"type\":\"address\"}],\"name\":\"stakingChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldTreasury\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"treasuryChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LPStakingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bet\",\"type\":\"uint256\"}],\"name\":\"createGame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"started\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"endGame\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"getAllActive\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getAllDrawnOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getAllLostOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getAllPlayedOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getAllWonOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getDrawPercentageOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getFeeFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeePP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getGame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getLoosePercentageOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getTotalGamesDrawnOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getTotalLostOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getTotalPlayedOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getTotalWonOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getWLOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getWinPercentageOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"joinGame\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestGame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"playingOn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFeePP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"setId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min\",\"type\":\"uint256\"}],\"name\":\"setMinFeeForExecution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"setStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"setTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"transferDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Battle", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000db2cc8e6747d81399dc6e6619220e8d46f3ce787000000000000000000000000592a33b84907b883a0dbc767a0024d9063f7b3fa000000000000000000000000622decbd2d1dde2af9e12a89e2f71cb541d2564e000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff00000000000000000000000002777053d6764996e594c3e88af1d58d5363a2e6bcae690fd4001ba79c4f4d9401aed3a4644ba7fa07b9e607f004ca6cbe4248d2", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fe708d5006046949b3745e3183b6859b7483bd8355b730e7e2ee4464a17b09b9"}