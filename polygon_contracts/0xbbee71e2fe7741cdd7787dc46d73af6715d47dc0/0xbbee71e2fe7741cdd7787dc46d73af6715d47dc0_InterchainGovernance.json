{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/executable/AxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\\nimport { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';\\n\\ncontract AxelarExecutable is IAxelarExecutable {\\n    IAxelarGateway public immutable gateway;\\n\\n    constructor(address gateway_) {\\n        if (gateway_ == address(0)) revert InvalidAddress();\\n\\n        gateway = IAxelarGateway(gateway_);\\n    }\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external {\\n        bytes32 payloadHash = keccak256(payload);\\n\\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\\n            revert NotApprovedByGateway();\\n\\n        _execute(sourceChain, sourceAddress, payload);\\n    }\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external {\\n        bytes32 payloadHash = keccak256(payload);\\n\\n        if (\\n            !gateway.validateContractCallAndMint(\\n                commandId,\\n                sourceChain,\\n                sourceAddress,\\n                payloadHash,\\n                tokenSymbol,\\n                amount\\n            )\\n        ) revert NotApprovedByGateway();\\n\\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\\n    }\\n\\n    function _execute(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) internal virtual {}\\n\\n    function _executeWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/governance/InterchainGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AxelarExecutable } from '../executable/AxelarExecutable.sol';\\nimport { TimeLock } from '../utils/TimeLock.sol';\\nimport { SafeNativeTransfer } from '../libs/SafeNativeTransfer.sol';\\nimport { IInterchainGovernance } from '../interfaces/IInterchainGovernance.sol';\\nimport { Caller } from '../utils/Caller.sol';\\n\\n/**\\n * @title Interchain Governance contract\\n * @notice This contract handles cross-chain governance actions. It includes functionality\\n * to create, cancel, and execute governance proposals.\\n */\\ncontract InterchainGovernance is AxelarExecutable, TimeLock, Caller, IInterchainGovernance {\\n    using SafeNativeTransfer for address;\\n\\n    enum GovernanceCommand {\\n        ScheduleTimeLockProposal,\\n        CancelTimeLockProposal\\n    }\\n\\n    string public governanceChain;\\n    string public governanceAddress;\\n    bytes32 public immutable governanceChainHash;\\n    bytes32 public immutable governanceAddressHash;\\n\\n    /**\\n     * @notice Initializes the contract\\n     * @param gateway_ The address of the Axelar gateway contract\\n     * @param governanceChain_ The name of the governance chain\\n     * @param governanceAddress_ The address of the governance contract\\n     * @param minimumTimeDelay The minimum time delay for timelock operations\\n     */\\n    constructor(\\n        address gateway_,\\n        string memory governanceChain_,\\n        string memory governanceAddress_,\\n        uint256 minimumTimeDelay\\n    ) AxelarExecutable(gateway_) TimeLock(minimumTimeDelay) {\\n        if (bytes(governanceChain_).length == 0 || bytes(governanceAddress_).length == 0) {\\n            revert InvalidAddress();\\n        }\\n\\n        governanceChain = governanceChain_;\\n        governanceAddress = governanceAddress_;\\n        governanceChainHash = keccak256(bytes(governanceChain_));\\n        governanceAddressHash = keccak256(bytes(governanceAddress_));\\n    }\\n\\n    /**\\n     * @notice Modifier to check if the caller is the governance contract\\n     * @param sourceChain The source chain of the proposal, must equal the governance chain\\n     * @param sourceAddress The source address of the proposal, must equal the governance address\\n     */\\n    modifier onlyGovernance(string calldata sourceChain, string calldata sourceAddress) {\\n        if (\\n            keccak256(bytes(sourceChain)) != governanceChainHash ||\\n            keccak256(bytes(sourceAddress)) != governanceAddressHash\\n        ) revert NotGovernance();\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Modifier to check if the caller is the contract itself\\n     */\\n    modifier onlySelf() {\\n        if (msg.sender != address(this)) revert NotSelf();\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns the ETA of a proposal\\n     * @param target The address of the contract targeted by the proposal\\n     * @param callData The call data to be sent to the target contract\\n     * @param nativeValue The amount of native tokens to be sent to the target contract\\n     * @return uint256 The ETA of the proposal\\n     */\\n    function getProposalEta(\\n        address target,\\n        bytes calldata callData,\\n        uint256 nativeValue\\n    ) external view returns (uint256) {\\n        return _getTimeLockEta(_getProposalHash(target, callData, nativeValue));\\n    }\\n\\n    /**\\n     * @notice Executes a proposal\\n     * @dev The proposal is executed by calling the target contract with calldata. Native value is\\n     * transferred with the call to the target contract.\\n     * @param target The target address of the contract to call\\n     * @param callData The data containing the function and arguments for the contract to call\\n     * @param nativeValue The amount of native token to send to the target contract\\n     */\\n    function executeProposal(\\n        address target,\\n        bytes calldata callData,\\n        uint256 nativeValue\\n    ) external payable {\\n        bytes32 proposalHash = _getProposalHash(target, callData, nativeValue);\\n\\n        _finalizeTimeLock(proposalHash);\\n\\n        emit ProposalExecuted(proposalHash, target, callData, nativeValue, block.timestamp);\\n\\n        _call(target, callData, nativeValue);\\n    }\\n\\n    /**\\n     * @notice Withdraws native token from the contract\\n     * @param recipient The address to send the native token to\\n     * @param amount The amount of native token to send\\n     * @dev This function is only callable by the contract itself after passing according proposal\\n     */\\n    function withdraw(address recipient, uint256 amount) external onlySelf {\\n        recipient.safeNativeTransfer(amount);\\n    }\\n\\n    /**\\n     * @notice Internal function to execute a proposal action\\n     * @param sourceChain The source chain of the proposal, must equal the governance chain\\n     * @param sourceAddress The source address of the proposal, must equal the governance address\\n     * @param payload The payload of the proposal\\n     */\\n    function _execute(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) internal override onlyGovernance(sourceChain, sourceAddress) {\\n        (uint256 command, address target, bytes memory callData, uint256 nativeValue, uint256 eta) = abi.decode(\\n            payload,\\n            (uint256, address, bytes, uint256, uint256)\\n        );\\n\\n        if (target == address(0)) revert InvalidTarget();\\n\\n        _processCommand(command, target, callData, nativeValue, eta);\\n    }\\n\\n    /**\\n     * @notice Internal function to process a governance command\\n     * @param commandType The type of the command, 0 for proposal creation and 1 for proposal cancellation\\n     * @param target The target address the proposal will call\\n     * @param callData The data the encodes the function and arguments to call on the target contract\\n     * @param nativeValue The nativeValue of native token to be sent to the target contract\\n     * @param eta The time after which the proposal can be executed\\n     */\\n    function _processCommand(\\n        uint256 commandType,\\n        address target,\\n        bytes memory callData,\\n        uint256 nativeValue,\\n        uint256 eta\\n    ) internal virtual {\\n        bytes32 proposalHash = _getProposalHash(target, callData, nativeValue);\\n\\n        if (commandType == uint256(GovernanceCommand.ScheduleTimeLockProposal)) {\\n            eta = _scheduleTimeLock(proposalHash, eta);\\n\\n            emit ProposalScheduled(proposalHash, target, callData, nativeValue, eta);\\n            return;\\n        } else if (commandType == uint256(GovernanceCommand.CancelTimeLockProposal)) {\\n            _cancelTimeLock(proposalHash);\\n\\n            emit ProposalCancelled(proposalHash, target, callData, nativeValue, eta);\\n            return;\\n        } else {\\n            revert InvalidCommand();\\n        }\\n    }\\n\\n    /**\\n     * @dev Get proposal hash using the target, callData, and nativeValue\\n     */\\n    function _getProposalHash(\\n        address target,\\n        bytes memory callData,\\n        uint256 nativeValue\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(target, callData, nativeValue));\\n    }\\n\\n    /**\\n     * @notice Overrides internal function of AxelarExecutable, will always revert\\n     * as this governance module does not support execute with token.\\n     */\\n    function _executeWithToken(\\n        string calldata, /* sourceChain */\\n        string calldata, /* sourceAddress */\\n        bytes calldata, /* payload */\\n        string calldata, /* tokenSymbol */\\n        uint256 /* amount */\\n    ) internal pure override {\\n        revert TokenNotSupported();\\n    }\\n\\n    /**\\n     * @notice Allow contract to receive native gas token\\n     */\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from './IAxelarGateway.sol';\\n\\ninterface IAxelarExecutable {\\n    error InvalidAddress();\\n    error NotApprovedByGateway();\\n\\n    function gateway() external view returns (IAxelarGateway);\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAxelarGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IGovernable } from './IGovernable.sol';\\nimport { IImplementation } from './IImplementation.sol';\\n\\ninterface IAxelarGateway is IImplementation, IGovernable {\\n    /**********\\\\\\n    |* Errors *|\\n    \\\\**********/\\n\\n    error NotSelf();\\n    error InvalidCodeHash();\\n    error SetupFailed();\\n    error InvalidAuthModule();\\n    error InvalidTokenDeployer();\\n    error InvalidAmount();\\n    error InvalidChainId();\\n    error InvalidCommands();\\n    error TokenDoesNotExist(string symbol);\\n    error TokenAlreadyExists(string symbol);\\n    error TokenDeployFailed(string symbol);\\n    error TokenContractDoesNotExist(address token);\\n    error BurnFailed(string symbol);\\n    error MintFailed(string symbol);\\n    error InvalidSetMintLimitsParams();\\n    error ExceedMintLimit(string symbol);\\n\\n    /**********\\\\\\n    |* Events *|\\n    \\\\**********/\\n\\n    event TokenSent(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationAddress,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event ContractCall(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload\\n    );\\n\\n    event ContractCallWithToken(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event Executed(bytes32 indexed commandId);\\n\\n    event TokenDeployed(string symbol, address tokenAddresses);\\n\\n    event ContractCallApproved(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event ContractCallApprovedWithMint(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event ContractCallExecuted(bytes32 indexed commandId);\\n\\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\\n\\n    event OperatorshipTransferred(bytes newOperatorsData);\\n\\n    event Upgraded(address indexed implementation);\\n\\n    /********************\\\\\\n    |* Public Functions *|\\n    \\\\********************/\\n\\n    function sendToken(\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function callContract(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function callContractWithToken(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function isContractCallApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash\\n    ) external view returns (bool);\\n\\n    function isContractCallAndMintApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external view returns (bool);\\n\\n    function validateContractCall(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash\\n    ) external returns (bool);\\n\\n    function validateContractCallAndMint(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /***********\\\\\\n    |* Getters *|\\n    \\\\***********/\\n\\n    function authModule() external view returns (address);\\n\\n    function tokenDeployer() external view returns (address);\\n\\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\\n\\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\\n\\n    function allTokensFrozen() external view returns (bool);\\n\\n    function implementation() external view returns (address);\\n\\n    function tokenAddresses(string memory symbol) external view returns (address);\\n\\n    function tokenFrozen(string memory symbol) external view returns (bool);\\n\\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\\n\\n    /************************\\\\\\n    |* Governance Functions *|\\n    \\\\************************/\\n\\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata setupParams\\n    ) external;\\n\\n    /**********************\\\\\\n    |* External Functions *|\\n    \\\\**********************/\\n\\n    function execute(bytes calldata input) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICaller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface ICaller {\\n    error InvalidContract(address target);\\n    error InsufficientBalance();\\n    error ExecutionFailed();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IContractIdentifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// General interface for upgradable contracts\\ninterface IContractIdentifier {\\n    /**\\n     * @notice Returns the contract ID. It can be used as a check during upgrades.\\n     * @dev Meant to be overridden in derived contracts.\\n     * @return bytes32 The contract ID\\n     */\\n    function contractId() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IGovernable Interface\\n * @notice This is an interface used by the AxelarGateway contract to manage governance and mint limiter roles.\\n */\\ninterface IGovernable {\\n    error NotGovernance();\\n    error NotMintLimiter();\\n    error InvalidGovernance();\\n    error InvalidMintLimiter();\\n\\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\\n    event MintLimiterTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    /**\\n     * @notice Returns the governance address.\\n     * @return address of the governance\\n     */\\n    function governance() external view returns (address);\\n\\n    /**\\n     * @notice Returns the mint limiter address.\\n     * @return address of the mint limiter\\n     */\\n    function mintLimiter() external view returns (address);\\n\\n    /**\\n     * @notice Transfer the governance role to another address.\\n     * @param newGovernance The new governance address\\n     */\\n    function transferGovernance(address newGovernance) external;\\n\\n    /**\\n     * @notice Transfer the mint limiter role to another address.\\n     * @param newGovernance The new mint limiter address\\n     */\\n    function transferMintLimiter(address newGovernance) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IContractIdentifier } from './IContractIdentifier.sol';\\n\\ninterface IImplementation is IContractIdentifier {\\n    error NotProxy();\\n\\n    function setup(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterchainGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarExecutable } from './IAxelarExecutable.sol';\\nimport { ICaller } from './ICaller.sol';\\nimport { ITimeLock } from './ITimeLock.sol';\\n\\n/**\\n * @title IInterchainGovernance Interface\\n * @notice This interface extends IAxelarExecutable for interchain governance mechanisms.\\n */\\ninterface IInterchainGovernance is IAxelarExecutable, ICaller, ITimeLock {\\n    error NotGovernance();\\n    error NotSelf();\\n    error InvalidCommand();\\n    error InvalidTarget();\\n    error TokenNotSupported();\\n\\n    event ProposalScheduled(\\n        bytes32 indexed proposalHash,\\n        address indexed target,\\n        bytes callData,\\n        uint256 value,\\n        uint256 indexed eta\\n    );\\n    event ProposalCancelled(\\n        bytes32 indexed proposalHash,\\n        address indexed target,\\n        bytes callData,\\n        uint256 value,\\n        uint256 indexed eta\\n    );\\n    event ProposalExecuted(\\n        bytes32 indexed proposalHash,\\n        address indexed target,\\n        bytes callData,\\n        uint256 value,\\n        uint256 indexed timestamp\\n    );\\n\\n    /**\\n     * @notice Returns the name of the governance chain.\\n     * @return string The name of the governance chain\\n     */\\n    function governanceChain() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the address of the governance address.\\n     * @return string The address of the governance address\\n     */\\n    function governanceAddress() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the hash of the governance chain.\\n     * @return bytes32 The hash of the governance chain\\n     */\\n    function governanceChainHash() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the hash of the governance address.\\n     * @return bytes32 The hash of the governance address\\n     */\\n    function governanceAddressHash() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the ETA of a proposal.\\n     * @param target The address of the contract targeted by the proposal\\n     * @param callData The call data to be sent to the target contract\\n     * @param nativeValue The amount of native tokens to be sent to the target contract\\n     * @return uint256 The ETA of the proposal\\n     */\\n    function getProposalEta(\\n        address target,\\n        bytes calldata callData,\\n        uint256 nativeValue\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Executes a governance proposal.\\n     * @param targetContract The address of the contract targeted by the proposal\\n     * @param callData The call data to be sent to the target contract\\n     * @param value The amount of ETH to be sent to the target contract\\n     */\\n    function executeProposal(\\n        address targetContract,\\n        bytes calldata callData,\\n        uint256 value\\n    ) external payable;\\n\\n    /**\\n     * @notice Withdraws native token from the contract\\n     * @param recipient The address to send the native token to\\n     * @param amount The amount of native token to send\\n     * @dev This function is only callable by the contract itself after passing according proposal\\n     */\\n    function withdraw(address recipient, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITimeLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ITimeLock\\n * @dev Interface for a TimeLock that enables function execution after a certain time has passed.\\n */\\ninterface ITimeLock {\\n    error InvalidTimeLockHash();\\n    error TimeLockAlreadyScheduled();\\n    error TimeLockNotReady();\\n\\n    /**\\n     * @notice Returns a minimum time delay at which the TimeLock may be scheduled.\\n     * @return uint Minimum scheduling delay time (in secs) from the current block timestamp\\n     */\\n    function minimumTimeLockDelay() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the timestamp after which the TimeLock may be executed.\\n     * @param hash The hash of the timelock\\n     * @return uint The timestamp after which the timelock with the given hash can be executed\\n     */\\n    function getTimeLock(bytes32 hash) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/ContractAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ContractAddress {\\n    function isContract(address contractAddress) internal view returns (bool) {\\n        bytes32 existingCodeHash = contractAddress.codehash;\\n\\n        // https://eips.ethereum.org/EIPS/eip-1052\\n        // keccak256('') == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\\n        return\\n            existingCodeHash != bytes32(0) &&\\n            existingCodeHash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/SafeNativeTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nerror NativeTransferFailed();\\n\\n/*\\n * @title SafeNativeTransfer\\n * @dev This library is used for performing safe native value transfers in Solidity by utilizing inline assembly.\\n */\\nlibrary SafeNativeTransfer {\\n    /*\\n     * @notice Perform a native transfer to a given address.\\n     * @param receiver The recipient address to which the amount will be sent.\\n     * @param amount The amount of native value to send.\\n     * @throws NativeTransferFailed error if transfer is not successful.\\n     */\\n    function safeNativeTransfer(address receiver, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            success := call(gas(), receiver, amount, 0, 0, 0, 0)\\n        }\\n\\n        if (!success) revert NativeTransferFailed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Caller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ContractAddress } from '../libs/ContractAddress.sol';\\nimport { ICaller } from '../interfaces/ICaller.sol';\\n\\ncontract Caller is ICaller {\\n    using ContractAddress for address;\\n\\n    /**\\n     * @dev Calls a target address with specified calldata and optionally sends value.\\n     */\\n    function _call(\\n        address target,\\n        bytes calldata callData,\\n        uint256 nativeValue\\n    ) internal returns (bytes memory) {\\n        if (!target.isContract()) revert InvalidContract(target);\\n\\n        if (nativeValue > address(this).balance) revert InsufficientBalance();\\n\\n        (bool success, bytes memory data) = target.call{ value: nativeValue }(callData);\\n        if (!success) {\\n            revert ExecutionFailed();\\n        }\\n\\n        return data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/TimeLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ITimeLock } from '../interfaces/ITimeLock.sol';\\n\\n/**\\n * @title TimeLock\\n * @dev A contract that enables function execution after a certain time has passed.\\n * Implements the {ITimeLock} interface.\\n */\\ncontract TimeLock is ITimeLock {\\n    bytes32 internal constant PREFIX_TIME_LOCK = keccak256('time-lock');\\n\\n    uint256 public immutable minimumTimeLockDelay;\\n\\n    /**\\n     * @notice The constructor for the TimeLock.\\n     * @param minimumTimeDelay The minimum time delay (in secs) that must pass for the TimeLock to be executed\\n     */\\n    constructor(uint256 minimumTimeDelay) {\\n        minimumTimeLockDelay = minimumTimeDelay;\\n    }\\n\\n    /**\\n     * @notice Returns the timestamp after which the TimeLock may be executed.\\n     * @param hash The hash of the timelock\\n     * @return uint The timestamp after which the timelock with the given hash can be executed\\n     */\\n    function getTimeLock(bytes32 hash) external view override returns (uint256) {\\n        return _getTimeLockEta(hash);\\n    }\\n\\n    /**\\n     * @notice Schedules a new timelock.\\n     * @dev The timestamp will be set to the current block timestamp + minimum time delay,\\n     * if the provided timestamp is less than that.\\n     * @param hash The hash of the new timelock\\n     * @param eta The proposed Unix timestamp (in secs) after which the new timelock can be executed\\n     * @return uint The Unix timestamp (in secs) after which the new timelock can be executed\\n     */\\n    function _scheduleTimeLock(bytes32 hash, uint256 eta) internal returns (uint256) {\\n        if (hash == 0) revert InvalidTimeLockHash();\\n        if (_getTimeLockEta(hash) != 0) revert TimeLockAlreadyScheduled();\\n\\n        uint256 minimumEta = block.timestamp + minimumTimeLockDelay;\\n\\n        if (eta < minimumEta) eta = minimumEta;\\n\\n        _setTimeLockEta(hash, eta);\\n\\n        return eta;\\n    }\\n\\n    /**\\n     * @notice Cancels an existing timelock by setting its eta to zero.\\n     * @param hash The hash of the timelock to cancel\\n     */\\n    function _cancelTimeLock(bytes32 hash) internal {\\n        if (hash == 0) revert InvalidTimeLockHash();\\n\\n        _setTimeLockEta(hash, 0);\\n    }\\n\\n    /**\\n     * @notice Finalizes an existing timelock and sets its eta back to zero.\\n     * @dev To finalize, the timelock must currently exist and the required time delay\\n     * must have passed.\\n     * @param hash The hash of the timelock to finalize\\n     */\\n    function _finalizeTimeLock(bytes32 hash) internal {\\n        uint256 eta = _getTimeLockEta(hash);\\n\\n        if (hash == 0 || eta == 0) revert InvalidTimeLockHash();\\n\\n        if (block.timestamp < eta) revert TimeLockNotReady();\\n\\n        _setTimeLockEta(hash, 0);\\n    }\\n\\n    /**\\n     * @dev Returns the timestamp after which the timelock with the given hash can be executed.\\n     */\\n    function _getTimeLockEta(bytes32 hash) internal view returns (uint256 eta) {\\n        bytes32 key = keccak256(abi.encodePacked(PREFIX_TIME_LOCK, hash));\\n\\n        assembly {\\n            eta := sload(key)\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets a new timestamp for the timelock with the given hash.\\n     */\\n    function _setTimeLockEta(bytes32 hash, uint256 eta) private {\\n        bytes32 key = keccak256(abi.encodePacked(PREFIX_TIME_LOCK, hash));\\n\\n        assembly {\\n            sstore(key, eta)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gateway_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"governanceChain_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"governanceAddress_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minimumTimeDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCommand\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"InvalidContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTarget\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTimeLockHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprovedByGateway\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotGovernance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TimeLockAlreadyScheduled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TimeLockNotReady\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotSupported\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"ProposalCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ProposalExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"ProposalScheduled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nativeValue\",\"type\":\"uint256\"}],\"name\":\"executeProposal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"executeWithToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"contract IAxelarGateway\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nativeValue\",\"type\":\"uint256\"}],\"name\":\"getProposalEta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"getTimeLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceAddress\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceAddressHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceChain\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceChainHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTimeLockDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InterchainGovernance", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000006f015f16de9fc8791b234ef68d486d2bf203fba8000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000093a8000000000000000000000000000000000000000000000000000000000000000094178656c61726e65740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002d6178656c6172313064303779323635676d6d757674347a30773961773838306a6e73723730306a37763964616a00000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}