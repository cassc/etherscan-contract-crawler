{"SourceCode": "/**\r\n *Submitted for verification at goerli-optimism.etherscan.io on 2023-06-21\r\n*/\r\n\r\n/*\r\n * Copyright (c) 2022, Circle Internet Financial Limited.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npragma solidity 0.7.6;\r\n\r\n/*\r\n * Copyright (c) 2022, Circle Internet Financial Limited.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @title ITokenMinter\r\n * @notice interface for minter of tokens that are mintable, burnable, and interchangeable\r\n * across domains.\r\n */\r\ninterface ITokenMinter {\r\n    /**\r\n     * @notice Mints `amount` of local tokens corresponding to the\r\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\r\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\r\n     * map to a nonzero local token address. This mapping can be queried using\r\n     * getLocalToken().\r\n     * @param sourceDomain Source domain where `burnToken` was burned.\r\n     * @param burnToken Burned token address as bytes32.\r\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\r\n     * on this domain.\r\n     * @param amount Amount of tokens to mint. Must be less than or equal\r\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\r\n     * @return mintToken token minted.\r\n     */\r\n    function mint(\r\n        uint32 sourceDomain,\r\n        bytes32 burnToken,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (address mintToken);\r\n\r\n    /**\r\n     * @notice Burn tokens owned by this ITokenMinter.\r\n     * @param burnToken burnable token.\r\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\r\n     * account balance of the given `_burnToken`.\r\n     */\r\n    function burn(address burnToken, uint256 amount) external;\r\n\r\n    /**\r\n     * @notice Get the local token associated with the given remote domain and token.\r\n     * @param remoteDomain Remote domain\r\n     * @param remoteToken Remote token\r\n     * @return local token address\r\n     */\r\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * @notice Set the token controller of this ITokenMinter. Token controller\r\n     * is responsible for mapping local tokens to remote tokens, and managing\r\n     * token-specific limits\r\n     * @param newTokenController new token controller address\r\n     */\r\n    function setTokenController(address newTokenController) external;\r\n}\r\n\r\n/*\r\n * Copyright (c) 2022, Circle Internet Financial Limited.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n/**\r\n * @title IMintBurnToken\r\n * @notice interface for mintable and burnable ERC20 token\r\n */\r\ninterface IMintBurnToken is IERC20 {\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param amount The amount of tokens to mint. Must be less than or equal\r\n     * to the minterAllowance of the caller.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev allows a minter to burn some of its own tokens\r\n     * Validates that caller is a minter and that sender is not blacklisted\r\n     * amount is less than or equal to the minter's account balance\r\n     * @param amount uint256 the amount of tokens to be burned\r\n     */\r\n    function burn(uint256 amount) external;\r\n}\r\n\r\n/*\r\n * Copyright (c) 2022, Circle Internet Financial Limited.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7c5f6bc2c8743d83443fa46395d75f2f3f99054a/contracts/access/Ownable.sol\r\n * Modifications:\r\n * 1. Update Solidity version from 0.8.0 to 0.7.6 (11/9/2022). (v8 was used\r\n * as base because it includes internal _transferOwnership method.)\r\n * 2. Remove renounceOwnership function\r\n *\r\n * Description\r\n * Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/7c5f6bc2c8743d83443fa46395d75f2f3f99054a/contracts/access/Ownable2Step.sol\r\n * Modifications:\r\n * 1. Update Solidity version from 0.8.0 to 0.7.6. Version 0.8.0 was used\r\n * as base because this contract was added to OZ repo after version 0.8.0.\r\n *\r\n * Contract module which provides access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership} and {acceptOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available all functions\r\n * from parent (Ownable).\r\n */\r\nabstract contract Ownable2Step is Ownable {\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferStarted(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the address of the pending owner.\r\n     */\r\n    function pendingOwner() public view virtual returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner)\r\n        public\r\n        virtual\r\n        override\r\n        onlyOwner\r\n    {\r\n        _pendingOwner = newOwner;\r\n        emit OwnershipTransferStarted(owner(), newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual override {\r\n        delete _pendingOwner;\r\n        super._transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev The new owner accepts the ownership transfer.\r\n     */\r\n    function acceptOwnership() external {\r\n        address sender = _msgSender();\r\n        require(\r\n            pendingOwner() == sender,\r\n            \"Ownable2Step: caller is not the new owner\"\r\n        );\r\n        _transferOwnership(sender);\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Base contract which allows children to implement an emergency stop\r\n * mechanism\r\n * @dev Forked from https://github.com/centrehq/centre-tokens/blob/0d3cab14ebd133a83fc834dbd48d0468bdf0b391/contracts/v1/Pausable.sol\r\n * Modifications:\r\n * 1. Update Solidity version from 0.6.12 to 0.7.6 (8/23/2022)\r\n * 2. Change pauser visibility to private, declare external getter (11/19/22)\r\n */\r\ncontract Pausable is Ownable2Step {\r\n    event Pause();\r\n    event Unpause();\r\n    event PauserChanged(address indexed newAddress);\r\n\r\n    address private _pauser;\r\n    bool public paused = false;\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev throws if called by any account other than the pauser\r\n     */\r\n    modifier onlyPauser() {\r\n        require(msg.sender == _pauser, \"Pausable: caller is not the pauser\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns current pauser\r\n     * @return Pauser's address\r\n     */\r\n    function pauser() external view returns (address) {\r\n        return _pauser;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() external onlyPauser {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() external onlyPauser {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev update the pauser role\r\n     */\r\n    function updatePauser(address _newPauser) external onlyOwner {\r\n        require(\r\n            _newPauser != address(0),\r\n            \"Pausable: new pauser is the zero address\"\r\n        );\r\n        _pauser = _newPauser;\r\n        emit PauserChanged(_pauser);\r\n    }\r\n}\r\n\r\n/*\r\n * Copyright (c) 2022, Circle Internet Financial Limited.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(\r\n            value\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            \"SafeERC20: decreased allowance below zero\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Base contract which allows children to rescue ERC20 locked in their contract.\r\n * @dev Forked from https://github.com/centrehq/centre-tokens/blob/0d3cab14ebd133a83fc834dbd48d0468bdf0b391/contracts/v1.1/Rescuable.sol\r\n * Modifications:\r\n * 1. Update Solidity version from 0.6.12 to 0.7.6 (8/23/2022)\r\n */\r\ncontract Rescuable is Ownable2Step {\r\n    using SafeERC20 for IERC20;\r\n\r\n    address private _rescuer;\r\n\r\n    event RescuerChanged(address indexed newRescuer);\r\n\r\n    /**\r\n     * @notice Returns current rescuer\r\n     * @return Rescuer's address\r\n     */\r\n    function rescuer() external view returns (address) {\r\n        return _rescuer;\r\n    }\r\n\r\n    /**\r\n     * @notice Revert if called by any account other than the rescuer.\r\n     */\r\n    modifier onlyRescuer() {\r\n        require(msg.sender == _rescuer, \"Rescuable: caller is not the rescuer\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Rescue ERC20 tokens locked up in this contract.\r\n     * @param tokenContract ERC20 token contract address\r\n     * @param to        Recipient address\r\n     * @param amount    Amount to withdraw\r\n     */\r\n    function rescueERC20(\r\n        IERC20 tokenContract,\r\n        address to,\r\n        uint256 amount\r\n    ) external onlyRescuer {\r\n        tokenContract.safeTransfer(to, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Assign the rescuer role to a given address.\r\n     * @param newRescuer New rescuer's address\r\n     */\r\n    function updateRescuer(address newRescuer) external onlyOwner {\r\n        require(\r\n            newRescuer != address(0),\r\n            \"Rescuable: new rescuer is the zero address\"\r\n        );\r\n        _rescuer = newRescuer;\r\n        emit RescuerChanged(newRescuer);\r\n    }\r\n}\r\n\r\n/*\r\n * Copyright (c) 2022, Circle Internet Financial Limited.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @title TokenController\r\n * @notice Base contract which allows children to control tokens, including mapping\r\n * address of local tokens to addresses of corresponding tokens on remote domains,\r\n * and limiting the amount of each token that can be burned per message.\r\n */\r\nabstract contract TokenController {\r\n    // ============ Events ============\r\n    /**\r\n     * @notice Emitted when a token pair is linked\r\n     * @param localToken local token to support\r\n     * @param remoteDomain remote domain\r\n     * @param remoteToken token on `remoteDomain` corresponding to `localToken`\r\n     */\r\n    event TokenPairLinked(\r\n        address localToken,\r\n        uint32 remoteDomain,\r\n        bytes32 remoteToken\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a token pair is unlinked\r\n     * @param localToken local token address\r\n     * @param remoteDomain remote domain\r\n     * @param remoteToken token on `remoteDomain` unlinked from `localToken`\r\n     */\r\n    event TokenPairUnlinked(\r\n        address localToken,\r\n        uint32 remoteDomain,\r\n        bytes32 remoteToken\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a burn limit per message is set for a particular token\r\n     * @param token local token address\r\n     * @param burnLimitPerMessage burn limit per message for `token`\r\n     */\r\n    event SetBurnLimitPerMessage(\r\n        address indexed token,\r\n        uint256 burnLimitPerMessage\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when token controller is set\r\n     * @param tokenController token controller address set\r\n     */\r\n    event SetTokenController(address tokenController);\r\n\r\n    // ============ State Variables ============\r\n    // Supported burnable tokens on the local domain\r\n    // local token (address) => maximum burn amounts per message\r\n    mapping(address => uint256) public burnLimitsPerMessage;\r\n\r\n    // Supported mintable tokens on remote domains, mapped to their corresponding local token\r\n    // hash(remote domain & remote token bytes32 address) => local token (address)\r\n    mapping(bytes32 => address) public remoteTokensToLocalTokens;\r\n\r\n    // Role with permission to manage token address mapping across domains, and per-message burn limits\r\n    address private _tokenController;\r\n\r\n    // ============ Modifiers ============\r\n    /**\r\n     * @dev Throws if called by any account other than the tokenController.\r\n     */\r\n    modifier onlyTokenController() {\r\n        require(\r\n            msg.sender == _tokenController,\r\n            \"Caller is not tokenController\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice ensures that attempted burn does not exceed\r\n     * burn limit per-message for given `burnToken`.\r\n     * @dev reverts if allowed burn amount is 0, or burnAmount exceeds\r\n     * allowed burn amount.\r\n     * @param token address of token to burn\r\n     * @param amount amount of `token` to burn\r\n     */\r\n    modifier onlyWithinBurnLimit(address token, uint256 amount) {\r\n        uint256 _allowedBurnAmount = burnLimitsPerMessage[token];\r\n        require(_allowedBurnAmount > 0, \"Burn token not supported\");\r\n        require(\r\n            amount <= _allowedBurnAmount,\r\n            \"Burn amount exceeds per tx limit\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ============ Public/External Functions  ============\r\n    /**\r\n     * @dev Returns the address of the tokenController\r\n     * @return address of the tokenController\r\n     */\r\n    function tokenController() external view returns (address) {\r\n        return _tokenController;\r\n    }\r\n\r\n    /**\r\n     * @notice Links a pair of local and remote tokens to be supported by this TokenMinter.\r\n     * @dev Associates a (`remoteToken`, `localToken`) pair by updating remoteTokensToLocalTokens mapping.\r\n     * Reverts if the remote token (for the given `remoteDomain`) already maps to a nonzero local token.\r\n     * Note:\r\n     * - A remote token (on a certain remote domain) can only map to one local token, but many remote tokens\r\n     * can map to the same local token.\r\n     * - Setting a token pair does not enable the `localToken` (that requires calling setLocalTokenEnabledStatus.)\r\n     */\r\n    function linkTokenPair(\r\n        address localToken,\r\n        uint32 remoteDomain,\r\n        bytes32 remoteToken\r\n    ) external onlyTokenController {\r\n        bytes32 _remoteTokensKey = _hashRemoteDomainAndToken(\r\n            remoteDomain,\r\n            remoteToken\r\n        );\r\n\r\n        // remote token must not be already linked to a local token\r\n        require(\r\n            remoteTokensToLocalTokens[_remoteTokensKey] == address(0),\r\n            \"Unable to link token pair\"\r\n        );\r\n\r\n        remoteTokensToLocalTokens[_remoteTokensKey] = localToken;\r\n\r\n        emit TokenPairLinked(localToken, remoteDomain, remoteToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Unlinks a pair of local and remote tokens for this TokenMinter.\r\n     * @dev Removes link from `remoteToken`, to `localToken` for given `remoteDomain`\r\n     * by updating remoteTokensToLocalTokens mapping.\r\n     * Reverts if the remote token (for the given `remoteDomain`) already maps to the zero address.\r\n     * Note:\r\n     * - A remote token (on a certain remote domain) can only map to one local token, but many remote tokens\r\n     * can map to the same local token.\r\n     * - Unlinking a token pair does not disable burning the `localToken` (that requires calling setMaxBurnAmountPerMessage.)\r\n     */\r\n    function unlinkTokenPair(\r\n        address localToken,\r\n        uint32 remoteDomain,\r\n        bytes32 remoteToken\r\n    ) external onlyTokenController {\r\n        bytes32 _remoteTokensKey = _hashRemoteDomainAndToken(\r\n            remoteDomain,\r\n            remoteToken\r\n        );\r\n\r\n        // remote token must be linked to a local token before unlink\r\n        require(\r\n            remoteTokensToLocalTokens[_remoteTokensKey] != address(0),\r\n            \"Unable to unlink token pair\"\r\n        );\r\n\r\n        delete remoteTokensToLocalTokens[_remoteTokensKey];\r\n\r\n        emit TokenPairUnlinked(localToken, remoteDomain, remoteToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the maximum burn amount per message for a given `localToken`.\r\n     * @dev Burns with amounts exceeding `burnLimitPerMessage` will revert. Mints do not\r\n     * respect this value, so if this limit is reduced, previously burned tokens will still\r\n     * be mintable.\r\n     * @param localToken Local token to set the maximum burn amount per message of.\r\n     * @param burnLimitPerMessage Maximum burn amount per message to set.\r\n     */\r\n    function setMaxBurnAmountPerMessage(\r\n        address localToken,\r\n        uint256 burnLimitPerMessage\r\n    ) external onlyTokenController {\r\n        burnLimitsPerMessage[localToken] = burnLimitPerMessage;\r\n\r\n        emit SetBurnLimitPerMessage(localToken, burnLimitPerMessage);\r\n    }\r\n\r\n    // ============ Internal Utils ============\r\n    /**\r\n     * @notice Set tokenController to `newTokenController`, and\r\n     * emit `SetTokenController` event.\r\n     * @dev newTokenController must be nonzero.\r\n     * @param newTokenController address of new token controller\r\n     */\r\n    function _setTokenController(address newTokenController) internal {\r\n        require(\r\n            newTokenController != address(0),\r\n            \"Invalid token controller address\"\r\n        );\r\n        _tokenController = newTokenController;\r\n        emit SetTokenController(newTokenController);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the enabled local token associated with the given remote domain and token.\r\n     * @param remoteDomain Remote domain\r\n     * @param remoteToken Remote token\r\n     * @return Local token address\r\n     */\r\n    function _getLocalToken(uint32 remoteDomain, bytes32 remoteToken)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        bytes32 _remoteTokensKey = _hashRemoteDomainAndToken(\r\n            remoteDomain,\r\n            remoteToken\r\n        );\r\n\r\n        return remoteTokensToLocalTokens[_remoteTokensKey];\r\n    }\r\n\r\n    /**\r\n     * @notice hashes packed `_remoteDomain` and `_remoteToken`.\r\n     * @param remoteDomain Domain where message originated from\r\n     * @param remoteToken Address of remote token as bytes32\r\n     * @return keccak hash of packed remote domain and token\r\n     */\r\n    function _hashRemoteDomainAndToken(uint32 remoteDomain, bytes32 remoteToken)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(remoteDomain, remoteToken));\r\n    }\r\n}\r\n\r\n/*\r\n * Copyright (c) 2022, Circle Internet Financial Limited.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @title IMessageHandler\r\n * @notice Handles messages on destination domain forwarded from\r\n * an IReceiver\r\n */\r\ninterface IMessageHandler {\r\n    /**\r\n     * @notice handles an incoming message from a Receiver\r\n     * @param sourceDomain the source domain of the message\r\n     * @param sender the sender of the message\r\n     * @param messageBody The message raw bytes\r\n     * @return success bool, true if successful\r\n     */\r\n    function handleReceiveMessage(\r\n        uint32 sourceDomain,\r\n        bytes32 sender,\r\n        bytes calldata messageBody\r\n    ) external returns (bool);\r\n}\r\n\r\n/*\r\n * Copyright (c) 2022, Circle Internet Financial Limited.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @title IRelayer\r\n * @notice Sends messages from source domain to destination domain\r\n */\r\ninterface IRelayer {\r\n    /**\r\n     * @notice Sends an outgoing message from the source domain.\r\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\r\n     * @param destinationDomain Domain of destination chain\r\n     * @param recipient Address of message recipient on destination domain as bytes32\r\n     * @param messageBody Raw bytes content of message\r\n     * @return nonce reserved by message\r\n     */\r\n    function sendMessage(\r\n        uint32 destinationDomain,\r\n        bytes32 recipient,\r\n        bytes calldata messageBody\r\n    ) external returns (uint64);\r\n\r\n    /**\r\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\r\n     * destination domain.\r\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\r\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\r\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\r\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\r\n     * @param destinationDomain Domain of destination chain\r\n     * @param recipient Address of message recipient on destination domain as bytes32\r\n     * @param destinationCaller caller on the destination domain, as bytes32\r\n     * @param messageBody Raw bytes content of message\r\n     * @return nonce reserved by message\r\n     */\r\n    function sendMessageWithCaller(\r\n        uint32 destinationDomain,\r\n        bytes32 recipient,\r\n        bytes32 destinationCaller,\r\n        bytes calldata messageBody\r\n    ) external returns (uint64);\r\n\r\n    /**\r\n     * @notice Replace a message with a new message body and/or destination caller.\r\n     * @dev The `originalAttestation` must be a valid attestation of `originalMessage`.\r\n     * @param originalMessage original message to replace\r\n     * @param originalAttestation attestation of `originalMessage`\r\n     * @param newMessageBody new message body of replaced message\r\n     * @param newDestinationCaller the new destination caller\r\n     */\r\n    function replaceMessage(\r\n        bytes calldata originalMessage,\r\n        bytes calldata originalAttestation,\r\n        bytes calldata newMessageBody,\r\n        bytes32 newDestinationCaller\r\n    ) external;\r\n}\r\n\r\n/*\r\n * Copyright (c) 2022, Circle Internet Financial Limited.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @title IReceiver\r\n * @notice Receives messages on destination chain and forwards them to IMessageDestinationHandler\r\n */\r\ninterface IReceiver {\r\n    /**\r\n     * @notice Receives an incoming message, validating the header and passing\r\n     * the body to application-specific handler.\r\n     * @param message The message raw bytes\r\n     * @param signature The message signature\r\n     * @return success bool, true if successful\r\n     */\r\n    function receiveMessage(bytes calldata message, bytes calldata signature)\r\n        external\r\n        returns (bool success);\r\n}\r\n\r\n/**\r\n * @title IMessageTransmitter\r\n * @notice Interface for message transmitters, which both relay and receive messages.\r\n */\r\ninterface IMessageTransmitter is IRelayer, IReceiver {\r\n\r\n}\r\n\r\n/*\r\n * Copyright (c) 2022, Circle Internet Financial Limited.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nlibrary TypedMemView {\r\n    using SafeMath for uint256;\r\n\r\n    // Why does this exist?\r\n    // the solidity `bytes memory` type has a few weaknesses.\r\n    // 1. You can't index ranges effectively\r\n    // 2. You can't slice without copying\r\n    // 3. The underlying data may represent any type\r\n    // 4. Solidity never deallocates memory, and memory costs grow\r\n    //    superlinearly\r\n\r\n    // By using a memory view instead of a `bytes memory` we get the following\r\n    // advantages:\r\n    // 1. Slices are done on the stack, by manipulating the pointer\r\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\r\n    // 3. We can insert type info into the pointer, and typecheck at runtime\r\n\r\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\r\n    // algorithms.\r\n\r\n    // Why bytes29?\r\n    // We want to avoid confusion between views, digests, and other common\r\n    // types so we chose a large and uncommonly used odd number of bytes\r\n    //\r\n    // Note that while bytes are left-aligned in a word, integers and addresses\r\n    // are right-aligned. This means when working in assembly we have to\r\n    // account for the 3 unused bytes on the righthand side\r\n    //\r\n    // First 5 bytes are a type flag.\r\n    // - ff_ffff_fffe is reserved for unknown type.\r\n    // - ff_ffff_ffff is reserved for invalid types/errors.\r\n    // next 12 are memory address\r\n    // next 12 are len\r\n    // bottom 3 bytes are empty\r\n\r\n    // Assumptions:\r\n    // - non-modification of memory.\r\n    // - No Solidity updates\r\n    // - - wrt free mem point\r\n    // - - wrt bytes representation in memory\r\n    // - - wrt memory addressing in general\r\n\r\n    // Usage:\r\n    // - create type constants\r\n    // - use `assertType` for runtime type assertions\r\n    // - - unfortunately we can't do this at compile time yet :(\r\n    // - recommended: implement modifiers that perform type checking\r\n    // - - e.g.\r\n    // - - `uint40 constant MY_TYPE = 3;`\r\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\r\n    // - instantiate a typed view from a bytearray using `ref`\r\n    // - use `index` to inspect the contents of the view\r\n    // - use `slice` to create smaller views into the same memory\r\n    // - - `slice` can increase the offset\r\n    // - - `slice can decrease the length`\r\n    // - - must specify the output type of `slice`\r\n    // - - `slice` will return a null view if you try to overrun\r\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\r\n    // - use `equal` for typed comparisons.\r\n\r\n    // The null view\r\n    bytes29 public constant NULL =\r\n        hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\r\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\r\n    uint8 constant TWELVE_BYTES = 96;\r\n\r\n    /**\r\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\r\n     * @param _b    The byte\r\n     * @return      char - The encoded hex character\r\n     */\r\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\r\n        // This can probably be done more efficiently, but it's only in error\r\n        // paths, so we don't really care :)\r\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\r\n        if (_nibble == 0xf0) {\r\n            return 0x30;\r\n        } // 0\r\n        if (_nibble == 0xf1) {\r\n            return 0x31;\r\n        } // 1\r\n        if (_nibble == 0xf2) {\r\n            return 0x32;\r\n        } // 2\r\n        if (_nibble == 0xf3) {\r\n            return 0x33;\r\n        } // 3\r\n        if (_nibble == 0xf4) {\r\n            return 0x34;\r\n        } // 4\r\n        if (_nibble == 0xf5) {\r\n            return 0x35;\r\n        } // 5\r\n        if (_nibble == 0xf6) {\r\n            return 0x36;\r\n        } // 6\r\n        if (_nibble == 0xf7) {\r\n            return 0x37;\r\n        } // 7\r\n        if (_nibble == 0xf8) {\r\n            return 0x38;\r\n        } // 8\r\n        if (_nibble == 0xf9) {\r\n            return 0x39;\r\n        } // 9\r\n        if (_nibble == 0xfa) {\r\n            return 0x61;\r\n        } // a\r\n        if (_nibble == 0xfb) {\r\n            return 0x62;\r\n        } // b\r\n        if (_nibble == 0xfc) {\r\n            return 0x63;\r\n        } // c\r\n        if (_nibble == 0xfd) {\r\n            return 0x64;\r\n        } // d\r\n        if (_nibble == 0xfe) {\r\n            return 0x65;\r\n        } // e\r\n        if (_nibble == 0xff) {\r\n            return 0x66;\r\n        } // f\r\n    }\r\n\r\n    /**\r\n     * @notice      Returns a uint16 containing the hex-encoded byte.\r\n     * @param _b    The byte\r\n     * @return      encoded - The hex-encoded byte\r\n     */\r\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\r\n        encoded |= nibbleHex(_b >> 4); // top 4 bits\r\n        encoded <<= 8;\r\n        encoded |= nibbleHex(_b); // lower 4 bits\r\n    }\r\n\r\n    /**\r\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\r\n     *              `second` contains the encoded lower 16 bytes.\r\n     *\r\n     * @param _b    The 32 bytes as uint256\r\n     * @return      first - The top 16 bytes\r\n     * @return      second - The bottom 16 bytes\r\n     */\r\n    function encodeHex(uint256 _b)\r\n        internal\r\n        pure\r\n        returns (uint256 first, uint256 second)\r\n    {\r\n        for (uint8 i = 31; i > 15; i -= 1) {\r\n            uint8 _byte = uint8(_b >> (i * 8));\r\n            first |= byteHex(_byte);\r\n            if (i != 16) {\r\n                first <<= 16;\r\n            }\r\n        }\r\n\r\n        // abusing underflow here =_=\r\n        for (uint8 i = 15; i < 255; i -= 1) {\r\n            uint8 _byte = uint8(_b >> (i * 8));\r\n            second |= byteHex(_byte);\r\n            if (i != 0) {\r\n                second <<= 16;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Changes the endianness of a uint256.\r\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\r\n     * @param _b        The unsigned integer to reverse\r\n     * @return          v - The reversed value\r\n     */\r\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\r\n        v = _b;\r\n\r\n        // swap bytes\r\n        v =\r\n            ((v >> 8) &\r\n                0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\r\n            ((v &\r\n                0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) <<\r\n                8);\r\n        // swap 2-byte long pairs\r\n        v =\r\n            ((v >> 16) &\r\n                0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\r\n            ((v &\r\n                0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) <<\r\n                16);\r\n        // swap 4-byte long pairs\r\n        v =\r\n            ((v >> 32) &\r\n                0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\r\n            ((v &\r\n                0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) <<\r\n                32);\r\n        // swap 8-byte long pairs\r\n        v =\r\n            ((v >> 64) &\r\n                0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\r\n            ((v &\r\n                0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) <<\r\n                64);\r\n        // swap 16-byte long pairs\r\n        v = (v >> 128) | (v << 128);\r\n    }\r\n\r\n    /**\r\n     * @notice      Create a mask with the highest `_len` bits set.\r\n     * @param _len  The length\r\n     * @return      mask - The mask\r\n     */\r\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\r\n        // ugly. redo without assembly?\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            mask := sar(\r\n                sub(_len, 1),\r\n                0x8000000000000000000000000000000000000000000000000000000000000000\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice      Return the null view.\r\n     * @return      bytes29 - The null view\r\n     */\r\n    function nullView() internal pure returns (bytes29) {\r\n        return NULL;\r\n    }\r\n\r\n    /**\r\n     * @notice      Check if the view is null.\r\n     * @return      bool - True if the view is null\r\n     */\r\n    function isNull(bytes29 memView) internal pure returns (bool) {\r\n        return memView == NULL;\r\n    }\r\n\r\n    /**\r\n     * @notice      Check if the view is not null.\r\n     * @return      bool - True if the view is not null\r\n     */\r\n    function notNull(bytes29 memView) internal pure returns (bool) {\r\n        return !isNull(memView);\r\n    }\r\n\r\n    /**\r\n     * @notice          Check if the view is of a valid type and points to a valid location\r\n     *                  in memory.\r\n     * @dev             We perform this check by examining solidity's unallocated memory\r\n     *                  pointer and ensuring that the view's upper bound is less than that.\r\n     * @param memView   The view\r\n     * @return          ret - True if the view is valid\r\n     */\r\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\r\n        if (typeOf(memView) == 0xffffffffff) {\r\n            return false;\r\n        }\r\n        uint256 _end = end(memView);\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            ret := not(gt(_end, mload(0x40)))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Require that a typed memory view be valid.\r\n     * @dev             Returns the view for easy chaining.\r\n     * @param memView   The view\r\n     * @return          bytes29 - The validated view\r\n     */\r\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\r\n        require(isValid(memView), \"Validity assertion failed\");\r\n        return memView;\r\n    }\r\n\r\n    /**\r\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\r\n     * @param memView   The view\r\n     * @param _expected The expected type\r\n     * @return          bool - True if the memview is of the expected type\r\n     */\r\n    function isType(bytes29 memView, uint40 _expected)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return typeOf(memView) == _expected;\r\n    }\r\n\r\n    /**\r\n     * @notice          Require that a typed memory view has a specific type.\r\n     * @dev             Returns the view for easy chaining.\r\n     * @param memView   The view\r\n     * @param _expected The expected type\r\n     * @return          bytes29 - The view with validated type\r\n     */\r\n    function assertType(bytes29 memView, uint40 _expected)\r\n        internal\r\n        pure\r\n        returns (bytes29)\r\n    {\r\n        if (!isType(memView, _expected)) {\r\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\r\n            (, uint256 e) = encodeHex(uint256(_expected));\r\n            string memory err = string(\r\n                abi.encodePacked(\r\n                    \"Type assertion failed. Got 0x\",\r\n                    uint80(g),\r\n                    \". Expected 0x\",\r\n                    uint80(e)\r\n                )\r\n            );\r\n            revert(err);\r\n        }\r\n        return memView;\r\n    }\r\n\r\n    /**\r\n     * @notice          Return an identical view with a different type.\r\n     * @param memView   The view\r\n     * @param _newType  The new type\r\n     * @return          newView - The new view with the specified type\r\n     */\r\n    function castTo(bytes29 memView, uint40 _newType)\r\n        internal\r\n        pure\r\n        returns (bytes29 newView)\r\n    {\r\n        // then | in the new type\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            // shift off the top 5 bytes\r\n            newView := or(newView, shr(40, shl(40, memView)))\r\n            newView := or(newView, shl(216, _newType))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Unsafe raw pointer construction. This should generally not be called\r\n     *                  directly. Prefer `ref` wherever possible.\r\n     * @dev             Unsafe raw pointer construction. This should generally not be called\r\n     *                  directly. Prefer `ref` wherever possible.\r\n     * @param _type     The type\r\n     * @param _loc      The memory address\r\n     * @param _len      The length\r\n     * @return          newView - The new view with the specified type, location and length\r\n     */\r\n    function unsafeBuildUnchecked(\r\n        uint256 _type,\r\n        uint256 _loc,\r\n        uint256 _len\r\n    ) private pure returns (bytes29 newView) {\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            newView := shl(96, or(newView, _type)) // insert type\r\n            newView := shl(96, or(newView, _loc)) // insert loc\r\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Instantiate a new memory view. This should generally not be called\r\n     *                  directly. Prefer `ref` wherever possible.\r\n     * @dev             Instantiate a new memory view. This should generally not be called\r\n     *                  directly. Prefer `ref` wherever possible.\r\n     * @param _type     The type\r\n     * @param _loc      The memory address\r\n     * @param _len      The length\r\n     * @return          newView - The new view with the specified type, location and length\r\n     */\r\n    function build(\r\n        uint256 _type,\r\n        uint256 _loc,\r\n        uint256 _len\r\n    ) internal pure returns (bytes29 newView) {\r\n        uint256 _end = _loc.add(_len);\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            if gt(_end, mload(0x40)) {\r\n                _end := 0\r\n            }\r\n        }\r\n        if (_end == 0) {\r\n            return NULL;\r\n        }\r\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\r\n    }\r\n\r\n    /**\r\n     * @notice          Instantiate a memory view from a byte array.\r\n     * @dev             Note that due to Solidity memory representation, it is not possible to\r\n     *                  implement a deref, as the `bytes` type stores its len in memory.\r\n     * @param arr       The byte array\r\n     * @param newType   The type\r\n     * @return          bytes29 - The memory view\r\n     */\r\n    function ref(bytes memory arr, uint40 newType)\r\n        internal\r\n        pure\r\n        returns (bytes29)\r\n    {\r\n        uint256 _len = arr.length;\r\n\r\n        uint256 _loc;\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\r\n        }\r\n\r\n        return build(newType, _loc, _len);\r\n    }\r\n\r\n    /**\r\n     * @notice          Return the associated type information.\r\n     * @param memView   The memory view\r\n     * @return          _type - The type associated with the view\r\n     */\r\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            // 216 == 256 - 40\r\n            _type := shr(216, memView) // shift out lower 24 bytes\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\r\n     * @param left      The first view\r\n     * @param right     The second view\r\n     * @return          bool - True if the 5-byte type flag is equal\r\n     */\r\n    function sameType(bytes29 left, bytes29 right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\r\n    }\r\n\r\n    /**\r\n     * @notice          Return the memory address of the underlying bytes.\r\n     * @param memView   The view\r\n     * @return          _loc - The memory address\r\n     */\r\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\r\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\r\n            _loc := and(shr(120, memView), _mask)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          The number of memory words this memory view occupies, rounded up.\r\n     * @param memView   The view\r\n     * @return          uint256 - The number of memory words\r\n     */\r\n    function words(bytes29 memView) internal pure returns (uint256) {\r\n        return uint256(len(memView)).add(32) / 32;\r\n    }\r\n\r\n    /**\r\n     * @notice          The in-memory footprint of a fresh copy of the view.\r\n     * @param memView   The view\r\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\r\n     */\r\n    function footprint(bytes29 memView) internal pure returns (uint256) {\r\n        return words(memView) * 32;\r\n    }\r\n\r\n    /**\r\n     * @notice          The number of bytes of the view.\r\n     * @param memView   The view\r\n     * @return          _len - The length of the view\r\n     */\r\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\r\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            _len := and(shr(24, memView), _mask)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Returns the endpoint of `memView`.\r\n     * @param memView   The view\r\n     * @return          uint256 - The endpoint of `memView`\r\n     */\r\n    function end(bytes29 memView) internal pure returns (uint256) {\r\n        return loc(memView) + len(memView);\r\n    }\r\n\r\n    /**\r\n     * @notice          Safe slicing without memory modification.\r\n     * @param memView   The view\r\n     * @param _index    The start index\r\n     * @param _len      The length\r\n     * @param newType   The new type\r\n     * @return          bytes29 - The new view\r\n     */\r\n    function slice(\r\n        bytes29 memView,\r\n        uint256 _index,\r\n        uint256 _len,\r\n        uint40 newType\r\n    ) internal pure returns (bytes29) {\r\n        uint256 _loc = loc(memView);\r\n\r\n        // Ensure it doesn't overrun the view\r\n        if (_loc.add(_index).add(_len) > end(memView)) {\r\n            return NULL;\r\n        }\r\n\r\n        _loc = _loc.add(_index);\r\n        return build(newType, _loc, _len);\r\n    }\r\n\r\n    /**\r\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\r\n     * @param memView   The view\r\n     * @param _len      The length\r\n     * @param newType   The new type\r\n     * @return          bytes29 - The new view\r\n     */\r\n    function prefix(\r\n        bytes29 memView,\r\n        uint256 _len,\r\n        uint40 newType\r\n    ) internal pure returns (bytes29) {\r\n        return slice(memView, 0, _len, newType);\r\n    }\r\n\r\n    /**\r\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\r\n     * @param memView   The view\r\n     * @param _len      The length\r\n     * @param newType   The new type\r\n     * @return          bytes29 - The new view\r\n     */\r\n    function postfix(\r\n        bytes29 memView,\r\n        uint256 _len,\r\n        uint40 newType\r\n    ) internal pure returns (bytes29) {\r\n        return slice(memView, uint256(len(memView)).sub(_len), _len, newType);\r\n    }\r\n\r\n    /**\r\n     * @notice          Construct an error message for an indexing overrun.\r\n     * @param _loc      The memory address\r\n     * @param _len      The length\r\n     * @param _index    The index\r\n     * @param _slice    The slice where the overrun occurred\r\n     * @return          err - The err\r\n     */\r\n    function indexErrOverrun(\r\n        uint256 _loc,\r\n        uint256 _len,\r\n        uint256 _index,\r\n        uint256 _slice\r\n    ) internal pure returns (string memory err) {\r\n        (, uint256 a) = encodeHex(_loc);\r\n        (, uint256 b) = encodeHex(_len);\r\n        (, uint256 c) = encodeHex(_index);\r\n        (, uint256 d) = encodeHex(_slice);\r\n        err = string(\r\n            abi.encodePacked(\r\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\r\n                uint48(a),\r\n                \" with length 0x\",\r\n                uint48(b),\r\n                \". Attempted to index at offset 0x\",\r\n                uint48(c),\r\n                \" with length 0x\",\r\n                uint48(d),\r\n                \".\"\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice          Load up to 32 bytes from the view onto the stack.\r\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\r\n     *                  This can be immediately cast to a smaller fixed-length byte array.\r\n     *                  To automatically cast to an integer, use `indexUint`.\r\n     * @param memView   The view\r\n     * @param _index    The index\r\n     * @param _bytes    The bytes\r\n     * @return          result - The 32 byte result\r\n     */\r\n    function index(\r\n        bytes29 memView,\r\n        uint256 _index,\r\n        uint8 _bytes\r\n    ) internal pure returns (bytes32 result) {\r\n        if (_bytes == 0) {\r\n            return bytes32(0);\r\n        }\r\n        if (_index.add(_bytes) > len(memView)) {\r\n            revert(\r\n                indexErrOverrun(\r\n                    loc(memView),\r\n                    len(memView),\r\n                    _index,\r\n                    uint256(_bytes)\r\n                )\r\n            );\r\n        }\r\n        require(\r\n            _bytes <= 32,\r\n            \"TypedMemView/index - Attempted to index more than 32 bytes\"\r\n        );\r\n\r\n        uint8 bitLength = _bytes * 8;\r\n        uint256 _loc = loc(memView);\r\n        uint256 _mask = leftMask(bitLength);\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            result := and(mload(add(_loc, _index)), _mask)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Parse an unsigned integer from the view at `_index`.\r\n     * @dev             Requires that the view have >= `_bytes` bytes following that index.\r\n     * @param memView   The view\r\n     * @param _index    The index\r\n     * @param _bytes    The bytes\r\n     * @return          result - The unsigned integer\r\n     */\r\n    function indexUint(\r\n        bytes29 memView,\r\n        uint256 _index,\r\n        uint8 _bytes\r\n    ) internal pure returns (uint256 result) {\r\n        return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\r\n    }\r\n\r\n    /**\r\n     * @notice          Parse an unsigned integer from LE bytes.\r\n     * @param memView   The view\r\n     * @param _index    The index\r\n     * @param _bytes    The bytes\r\n     * @return          result - The unsigned integer\r\n     */\r\n    function indexLEUint(\r\n        bytes29 memView,\r\n        uint256 _index,\r\n        uint8 _bytes\r\n    ) internal pure returns (uint256 result) {\r\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\r\n    }\r\n\r\n    /**\r\n     * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\r\n     *                  following that index.\r\n     * @param memView   The view\r\n     * @param _index    The index\r\n     * @return          address - The address\r\n     */\r\n    function indexAddress(bytes29 memView, uint256 _index)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        return address(uint160(indexUint(memView, _index, 20)));\r\n    }\r\n\r\n    /**\r\n     * @notice          Return the keccak256 hash of the underlying memory\r\n     * @param memView   The view\r\n     * @return          digest - The keccak256 hash of the underlying memory\r\n     */\r\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\r\n        uint256 _loc = loc(memView);\r\n        uint256 _len = len(memView);\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            digest := keccak256(_loc, _len)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Return the sha2 digest of the underlying memory.\r\n     * @dev             We explicitly deallocate memory afterwards.\r\n     * @param memView   The view\r\n     * @return          digest - The sha2 hash of the underlying memory\r\n     */\r\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\r\n        uint256 _loc = loc(memView);\r\n        uint256 _len = len(memView);\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            let ptr := mload(0x40)\r\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\r\n            digest := mload(ptr)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\r\n     * @param memView   The pre-image\r\n     * @return          digest - the Digest\r\n     */\r\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\r\n        uint256 _loc = loc(memView);\r\n        uint256 _len = len(memView);\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            let ptr := mload(0x40)\r\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\r\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\r\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Implements bitcoin's hash256 (double sha2)\r\n     * @param memView   A view of the preimage\r\n     * @return          digest - the Digest\r\n     */\r\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\r\n        uint256 _loc = loc(memView);\r\n        uint256 _len = len(memView);\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            let ptr := mload(0x40)\r\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\r\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\r\n            digest := mload(ptr)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Return true if the underlying memory is equal. Else false.\r\n     * @param left      The first view\r\n     * @param right     The second view\r\n     * @return          bool - True if the underlying memory is equal\r\n     */\r\n    function untypedEqual(bytes29 left, bytes29 right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return\r\n            (loc(left) == loc(right) && len(left) == len(right)) ||\r\n            keccak(left) == keccak(right);\r\n    }\r\n\r\n    /**\r\n     * @notice          Return false if the underlying memory is equal. Else true.\r\n     * @param left      The first view\r\n     * @param right     The second view\r\n     * @return          bool - False if the underlying memory is equal\r\n     */\r\n    function untypedNotEqual(bytes29 left, bytes29 right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !untypedEqual(left, right);\r\n    }\r\n\r\n    /**\r\n     * @notice          Compares type equality.\r\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\r\n     * @param left      The first view\r\n     * @param right     The second view\r\n     * @return          bool - True if the types are the same\r\n     */\r\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\r\n        return\r\n            left == right ||\r\n            (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\r\n    }\r\n\r\n    /**\r\n     * @notice          Compares type inequality.\r\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\r\n     * @param left      The first view\r\n     * @param right     The second view\r\n     * @return          bool - True if the types are not the same\r\n     */\r\n    function notEqual(bytes29 left, bytes29 right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !equal(left, right);\r\n    }\r\n\r\n    /**\r\n     * @notice          Copy the view to a location, return an unsafe memory reference\r\n     * @dev             Super Dangerous direct memory access.\r\n     *\r\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\r\n     *                  As such it MUST be consumed IMMEDIATELY.\r\n     *                  This function is private to prevent unsafe usage by callers.\r\n     * @param memView   The view\r\n     * @param _newLoc   The new location\r\n     * @return          written - the unsafe memory reference\r\n     */\r\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc)\r\n        private\r\n        view\r\n        returns (bytes29 written)\r\n    {\r\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\r\n        require(\r\n            isValid(memView),\r\n            \"TypedMemView/copyTo - Invalid pointer deref\"\r\n        );\r\n        uint256 _len = len(memView);\r\n        uint256 _oldLoc = loc(memView);\r\n\r\n        uint256 ptr;\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            ptr := mload(0x40)\r\n            // revert if we're writing in occupied memory\r\n            if gt(ptr, _newLoc) {\r\n                revert(0x60, 0x20) // empty revert message\r\n            }\r\n\r\n            // use the identity precompile to copy\r\n            // guaranteed not to fail, so pop the success\r\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\r\n        }\r\n\r\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\r\n    }\r\n\r\n    /**\r\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\r\n     *                  the new memory\r\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\r\n     * @param memView   The view\r\n     * @return          ret - The view pointing to the new memory\r\n     */\r\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\r\n        uint256 ptr;\r\n        uint256 _len = len(memView);\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            ptr := mload(0x40) // load unused memory pointer\r\n            ret := ptr\r\n        }\r\n        unsafeCopyTo(memView, ptr + 0x20);\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\r\n            mstore(ptr, _len) // write len of new array (in bytes)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\r\n     * @dev             Super Dangerous direct memory access.\r\n     *\r\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\r\n     *                  As such it MUST be consumed IMMEDIATELY.\r\n     *                  This function is private to prevent unsafe usage by callers.\r\n     * @param memViews  The views\r\n     * @return          unsafeView - The conjoined view pointing to the new memory\r\n     */\r\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\r\n        private\r\n        view\r\n        returns (bytes29 unsafeView)\r\n    {\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            let ptr := mload(0x40)\r\n            // revert if we're writing in occupied memory\r\n            if gt(ptr, _location) {\r\n                revert(0x60, 0x20) // empty revert message\r\n            }\r\n        }\r\n\r\n        uint256 _offset = 0;\r\n        for (uint256 i = 0; i < memViews.length; i++) {\r\n            bytes29 memView = memViews[i];\r\n            unsafeCopyTo(memView, _location + _offset);\r\n            _offset += len(memView);\r\n        }\r\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\r\n    }\r\n\r\n    /**\r\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\r\n     * @param memViews  The views\r\n     * @return          bytes32 - The keccak256 digest\r\n     */\r\n    function joinKeccak(bytes29[] memory memViews)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        uint256 ptr;\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            ptr := mload(0x40) // load unused memory pointer\r\n        }\r\n        return keccak(unsafeJoin(memViews, ptr));\r\n    }\r\n\r\n    /**\r\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\r\n     * @param memViews  The views\r\n     * @return          bytes32 - The sha256 digest\r\n     */\r\n    function joinSha2(bytes29[] memory memViews)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        uint256 ptr;\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            ptr := mload(0x40) // load unused memory pointer\r\n        }\r\n        return sha2(unsafeJoin(memViews, ptr));\r\n    }\r\n\r\n    /**\r\n     * @notice          copies all views, joins them into a new bytearray.\r\n     * @param memViews  The views\r\n     * @return          ret - The new byte array\r\n     */\r\n    function join(bytes29[] memory memViews)\r\n        internal\r\n        view\r\n        returns (bytes memory ret)\r\n    {\r\n        uint256 ptr;\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            ptr := mload(0x40) // load unused memory pointer\r\n        }\r\n\r\n        bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);\r\n        uint256 _written = len(_newView);\r\n        uint256 _footprint = footprint(_newView);\r\n\r\n        assembly {\r\n            // solium-disable-previous-line security/no-inline-assembly\r\n            // store the legnth\r\n            mstore(ptr, _written)\r\n            // new pointer is old + 0x20 + the footprint of the body\r\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\r\n            ret := ptr\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title BurnMessage Library\r\n * @notice Library for formatted BurnMessages used by TokenMessenger.\r\n * @dev BurnMessage format:\r\n * Field                 Bytes      Type       Index\r\n * version               4          uint32     0\r\n * burnToken             32         bytes32    4\r\n * mintRecipient         32         bytes32    36\r\n * amount                32         uint256    68\r\n * messageSender         32         bytes32    100\r\n **/\r\nlibrary BurnMessage {\r\n    using TypedMemView for bytes;\r\n    using TypedMemView for bytes29;\r\n\r\n    uint8 private constant VERSION_INDEX = 0;\r\n    uint8 private constant VERSION_LEN = 4;\r\n    uint8 private constant BURN_TOKEN_INDEX = 4;\r\n    uint8 private constant BURN_TOKEN_LEN = 32;\r\n    uint8 private constant MINT_RECIPIENT_INDEX = 36;\r\n    uint8 private constant MINT_RECIPIENT_LEN = 32;\r\n    uint8 private constant AMOUNT_INDEX = 68;\r\n    uint8 private constant AMOUNT_LEN = 32;\r\n    uint8 private constant MSG_SENDER_INDEX = 100;\r\n    uint8 private constant MSG_SENDER_LEN = 32;\r\n    // 4 byte version + 32 bytes burnToken + 32 bytes mintRecipient + 32 bytes amount + 32 bytes messageSender\r\n    uint8 private constant BURN_MESSAGE_LEN = 132;\r\n\r\n    /**\r\n     * @notice Formats Burn message\r\n     * @param _version The message body version\r\n     * @param _burnToken The burn token address on source domain as bytes32\r\n     * @param _mintRecipient The mint recipient address as bytes32\r\n     * @param _amount The burn amount\r\n     * @param _messageSender The message sender\r\n     * @return Burn formatted message.\r\n     */\r\n    function _formatMessage(\r\n        uint32 _version,\r\n        bytes32 _burnToken,\r\n        bytes32 _mintRecipient,\r\n        uint256 _amount,\r\n        bytes32 _messageSender\r\n    ) internal pure returns (bytes memory) {\r\n        return\r\n            abi.encodePacked(\r\n                _version,\r\n                _burnToken,\r\n                _mintRecipient,\r\n                _amount,\r\n                _messageSender\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the burnToken from a DepositForBurn BurnMessage\r\n     * @param _message The message\r\n     * @return sourceToken address as bytes32\r\n     */\r\n    function _getMessageSender(bytes29 _message)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return _message.index(MSG_SENDER_INDEX, MSG_SENDER_LEN);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the burnToken from a DepositForBurn BurnMessage\r\n     * @param _message The message\r\n     * @return sourceToken address as bytes32\r\n     */\r\n    function _getBurnToken(bytes29 _message) internal pure returns (bytes32) {\r\n        return _message.index(BURN_TOKEN_INDEX, BURN_TOKEN_LEN);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the mintRecipient from a BurnMessage\r\n     * @param _message The message\r\n     * @return mintRecipient\r\n     */\r\n    function _getMintRecipient(bytes29 _message)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return _message.index(MINT_RECIPIENT_INDEX, MINT_RECIPIENT_LEN);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the amount from a BurnMessage\r\n     * @param _message The message\r\n     * @return amount\r\n     */\r\n    function _getAmount(bytes29 _message) internal pure returns (uint256) {\r\n        return _message.indexUint(AMOUNT_INDEX, AMOUNT_LEN);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the version from a Burn message\r\n     * @param _message The message\r\n     * @return version\r\n     */\r\n    function _getVersion(bytes29 _message) internal pure returns (uint32) {\r\n        return uint32(_message.indexUint(VERSION_INDEX, VERSION_LEN));\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if burn message is malformed or invalid length\r\n     * @param _message The burn message as bytes29\r\n     */\r\n    function _validateBurnMessageFormat(bytes29 _message) internal pure {\r\n        require(_message.isValid(), \"Malformed message\");\r\n        require(_message.len() == BURN_MESSAGE_LEN, \"Invalid message length\");\r\n    }\r\n}\r\n\r\n/*\r\n * Copyright (c) 2022, Circle Internet Financial Limited.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @title Message Library\r\n * @notice Library for formatted messages used by Relayer and Receiver.\r\n *\r\n * @dev The message body is dynamically-sized to support custom message body\r\n * formats. Other fields must be fixed-size to avoid hash collisions.\r\n * Each other input value has an explicit type to guarantee fixed-size.\r\n * Padding: uintNN fields are left-padded, and bytesNN fields are right-padded.\r\n *\r\n * Field                 Bytes      Type       Index\r\n * version               4          uint32     0\r\n * sourceDomain          4          uint32     4\r\n * destinationDomain     4          uint32     8\r\n * nonce                 8          uint64     12\r\n * sender                32         bytes32    20\r\n * recipient             32         bytes32    52\r\n * destinationCaller     32         bytes32    84\r\n * messageBody           dynamic    bytes      116\r\n *\r\n **/\r\nlibrary Message {\r\n    using TypedMemView for bytes;\r\n    using TypedMemView for bytes29;\r\n\r\n    // Indices of each field in message\r\n    uint8 private constant VERSION_INDEX = 0;\r\n    uint8 private constant SOURCE_DOMAIN_INDEX = 4;\r\n    uint8 private constant DESTINATION_DOMAIN_INDEX = 8;\r\n    uint8 private constant NONCE_INDEX = 12;\r\n    uint8 private constant SENDER_INDEX = 20;\r\n    uint8 private constant RECIPIENT_INDEX = 52;\r\n    uint8 private constant DESTINATION_CALLER_INDEX = 84;\r\n    uint8 private constant MESSAGE_BODY_INDEX = 116;\r\n\r\n    /**\r\n     * @notice Returns formatted (packed) message with provided fields\r\n     * @param _msgVersion the version of the message format\r\n     * @param _msgSourceDomain Domain of home chain\r\n     * @param _msgDestinationDomain Domain of destination chain\r\n     * @param _msgNonce Destination-specific nonce\r\n     * @param _msgSender Address of sender on source chain as bytes32\r\n     * @param _msgRecipient Address of recipient on destination chain as bytes32\r\n     * @param _msgDestinationCaller Address of caller on destination chain as bytes32\r\n     * @param _msgRawBody Raw bytes of message body\r\n     * @return Formatted message\r\n     **/\r\n    function _formatMessage(\r\n        uint32 _msgVersion,\r\n        uint32 _msgSourceDomain,\r\n        uint32 _msgDestinationDomain,\r\n        uint64 _msgNonce,\r\n        bytes32 _msgSender,\r\n        bytes32 _msgRecipient,\r\n        bytes32 _msgDestinationCaller,\r\n        bytes memory _msgRawBody\r\n    ) internal pure returns (bytes memory) {\r\n        return\r\n            abi.encodePacked(\r\n                _msgVersion,\r\n                _msgSourceDomain,\r\n                _msgDestinationDomain,\r\n                _msgNonce,\r\n                _msgSender,\r\n                _msgRecipient,\r\n                _msgDestinationCaller,\r\n                _msgRawBody\r\n            );\r\n    }\r\n\r\n    // @notice Returns _message's version field\r\n    function _version(bytes29 _message) internal pure returns (uint32) {\r\n        return uint32(_message.indexUint(VERSION_INDEX, 4));\r\n    }\r\n\r\n    // @notice Returns _message's sourceDomain field\r\n    function _sourceDomain(bytes29 _message) internal pure returns (uint32) {\r\n        return uint32(_message.indexUint(SOURCE_DOMAIN_INDEX, 4));\r\n    }\r\n\r\n    // @notice Returns _message's destinationDomain field\r\n    function _destinationDomain(bytes29 _message)\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        return uint32(_message.indexUint(DESTINATION_DOMAIN_INDEX, 4));\r\n    }\r\n\r\n    // @notice Returns _message's nonce field\r\n    function _nonce(bytes29 _message) internal pure returns (uint64) {\r\n        return uint64(_message.indexUint(NONCE_INDEX, 8));\r\n    }\r\n\r\n    // @notice Returns _message's sender field\r\n    function _sender(bytes29 _message) internal pure returns (bytes32) {\r\n        return _message.index(SENDER_INDEX, 32);\r\n    }\r\n\r\n    // @notice Returns _message's recipient field\r\n    function _recipient(bytes29 _message) internal pure returns (bytes32) {\r\n        return _message.index(RECIPIENT_INDEX, 32);\r\n    }\r\n\r\n    // @notice Returns _message's destinationCaller field\r\n    function _destinationCaller(bytes29 _message)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return _message.index(DESTINATION_CALLER_INDEX, 32);\r\n    }\r\n\r\n    // @notice Returns _message's messageBody field\r\n    function _messageBody(bytes29 _message) internal pure returns (bytes29) {\r\n        return\r\n            _message.slice(\r\n                MESSAGE_BODY_INDEX,\r\n                _message.len() - MESSAGE_BODY_INDEX,\r\n                0\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice converts address to bytes32 (alignment preserving cast.)\r\n     * @param addr the address to convert to bytes32\r\n     */\r\n    function addressToBytes32(address addr) external pure returns (bytes32) {\r\n        return bytes32(uint256(uint160(addr)));\r\n    }\r\n\r\n    /**\r\n     * @notice converts bytes32 to address (alignment preserving cast.)\r\n     * @dev Warning: it is possible to have different input values _buf map to the same address.\r\n     * For use cases where this is not acceptable, validate that the first 12 bytes of _buf are zero-padding.\r\n     * @param _buf the bytes32 to convert to address\r\n     */\r\n    function bytes32ToAddress(bytes32 _buf) public pure returns (address) {\r\n        return address(uint160(uint256(_buf)));\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if message is malformed or incorrect length\r\n     * @param _message The message as bytes29\r\n     */\r\n    function _validateMessageFormat(bytes29 _message) internal pure {\r\n        require(_message.isValid(), \"Malformed message\");\r\n        require(\r\n            _message.len() >= MESSAGE_BODY_INDEX,\r\n            \"Invalid message: too short\"\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * @title TokenMessenger\r\n * @notice Sends messages and receives messages to/from MessageTransmitters\r\n * and to/from TokenMinters\r\n */\r\ncontract TokenMessenger is IMessageHandler, Rescuable {\r\n    // ============ Events ============\r\n    /**\r\n     * @notice Emitted when a DepositForBurn message is sent\r\n     * @param nonce unique nonce reserved by message\r\n     * @param burnToken address of token burnt on source domain\r\n     * @param amount deposit amount\r\n     * @param depositor address where deposit is transferred from\r\n     * @param mintRecipient address receiving minted tokens on destination domain as bytes32\r\n     * @param destinationDomain destination domain\r\n     * @param destinationTokenMessenger address of TokenMessenger on destination domain as bytes32\r\n     * @param destinationCaller authorized caller as bytes32 of receiveMessage() on destination domain, if not equal to bytes32(0).\r\n     * If equal to bytes32(0), any address can call receiveMessage().\r\n     */\r\n    event DepositForBurn(\r\n        uint64 indexed nonce,\r\n        address indexed burnToken,\r\n        uint256 amount,\r\n        address indexed depositor,\r\n        bytes32 mintRecipient,\r\n        uint32 destinationDomain,\r\n        bytes32 destinationTokenMessenger,\r\n        bytes32 destinationCaller\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when tokens are minted\r\n     * @param mintRecipient recipient address of minted tokens\r\n     * @param amount amount of minted tokens\r\n     * @param mintToken contract address of minted token\r\n     */\r\n    event MintAndWithdraw(\r\n        address indexed mintRecipient,\r\n        uint256 amount,\r\n        address indexed mintToken\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a remote TokenMessenger is added\r\n     * @param domain remote domain\r\n     * @param tokenMessenger TokenMessenger on remote domain\r\n     */\r\n    event RemoteTokenMessengerAdded(uint32 domain, bytes32 tokenMessenger);\r\n\r\n    /**\r\n     * @notice Emitted when a remote TokenMessenger is removed\r\n     * @param domain remote domain\r\n     * @param tokenMessenger TokenMessenger on remote domain\r\n     */\r\n    event RemoteTokenMessengerRemoved(uint32 domain, bytes32 tokenMessenger);\r\n\r\n    /**\r\n     * @notice Emitted when the local minter is added\r\n     * @param localMinter address of local minter\r\n     * @notice Emitted when the local minter is added\r\n     */\r\n    event LocalMinterAdded(address localMinter);\r\n\r\n    /**\r\n     * @notice Emitted when the local minter is removed\r\n     * @param localMinter address of local minter\r\n     * @notice Emitted when the local minter is removed\r\n     */\r\n    event LocalMinterRemoved(address localMinter);\r\n\r\n    // ============ Libraries ============\r\n    using TypedMemView for bytes;\r\n    using TypedMemView for bytes29;\r\n    using BurnMessage for bytes29;\r\n    using Message for bytes29;\r\n\r\n    // ============ State Variables ============\r\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\r\n    IMessageTransmitter public immutable localMessageTransmitter;\r\n\r\n    // Version of message body format\r\n    uint32 public immutable messageBodyVersion;\r\n\r\n    // Minter responsible for minting and burning tokens on the local domain\r\n    ITokenMinter public localMinter;\r\n\r\n    // Valid TokenMessengers on remote domains\r\n    mapping(uint32 => bytes32) public remoteTokenMessengers;\r\n\r\n    // ============ Modifiers ============\r\n    /**\r\n     * @notice Only accept messages from a registered TokenMessenger contract on given remote domain\r\n     * @param domain The remote domain\r\n     * @param tokenMessenger The address of the TokenMessenger contract for the given remote domain\r\n     */\r\n    modifier onlyRemoteTokenMessenger(uint32 domain, bytes32 tokenMessenger) {\r\n        require(\r\n            _isRemoteTokenMessenger(domain, tokenMessenger),\r\n            \"Remote TokenMessenger unsupported\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Only accept messages from the registered message transmitter on local domain\r\n     */\r\n    modifier onlyLocalMessageTransmitter() {\r\n        // Caller must be the registered message transmitter for this domain\r\n        require(_isLocalMessageTransmitter(), \"Invalid message transmitter\");\r\n        _;\r\n    }\r\n\r\n    // ============ Constructor ============\r\n    /**\r\n     * @param _messageTransmitter Message transmitter address\r\n     * @param _messageBodyVersion Message body version\r\n     */\r\n    constructor(address _messageTransmitter, uint32 _messageBodyVersion) {\r\n        require(\r\n            _messageTransmitter != address(0),\r\n            \"MessageTransmitter not set\"\r\n        );\r\n        localMessageTransmitter = IMessageTransmitter(_messageTransmitter);\r\n        messageBodyVersion = _messageBodyVersion;\r\n    }\r\n\r\n    // ============ External Functions  ============\r\n    /**\r\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\r\n     * Emits a `DepositForBurn` event.\r\n     * @dev reverts if:\r\n     * - given burnToken is not supported\r\n     * - given destinationDomain has no TokenMessenger registered\r\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\r\n     * to this contract is less than `amount`.\r\n     * - burn() reverts. For example, if `amount` is 0.\r\n     * - MessageTransmitter returns false or reverts.\r\n     * @param amount amount of tokens to burn\r\n     * @param destinationDomain destination domain\r\n     * @param mintRecipient address of mint recipient on destination domain\r\n     * @param burnToken address of contract to burn deposited tokens, on local domain\r\n     * @return _nonce unique nonce reserved by message\r\n     */\r\n    function depositForBurn(\r\n        uint256 amount,\r\n        uint32 destinationDomain,\r\n        bytes32 mintRecipient,\r\n        address burnToken\r\n    ) external returns (uint64 _nonce) {\r\n        return\r\n            _depositForBurn(\r\n                amount,\r\n                destinationDomain,\r\n                mintRecipient,\r\n                burnToken,\r\n                // (bytes32(0) here indicates that any address can call receiveMessage()\r\n                // on the destination domain, triggering mint to specified `mintRecipient`)\r\n                bytes32(0)\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\r\n     * on the destination domain must be called by `destinationCaller`.\r\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\r\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\r\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\r\n     * Emits a `DepositForBurn` event.\r\n     * @dev reverts if:\r\n     * - given destinationCaller is zero address\r\n     * - given burnToken is not supported\r\n     * - given destinationDomain has no TokenMessenger registered\r\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\r\n     * to this contract is less than `amount`.\r\n     * - burn() reverts. For example, if `amount` is 0.\r\n     * - MessageTransmitter returns false or reverts.\r\n     * @param amount amount of tokens to burn\r\n     * @param destinationDomain destination domain\r\n     * @param mintRecipient address of mint recipient on destination domain\r\n     * @param burnToken address of contract to burn deposited tokens, on local domain\r\n     * @param destinationCaller caller on the destination domain, as bytes32\r\n     * @return nonce unique nonce reserved by message\r\n     */\r\n    function depositForBurnWithCaller(\r\n        uint256 amount,\r\n        uint32 destinationDomain,\r\n        bytes32 mintRecipient,\r\n        address burnToken,\r\n        bytes32 destinationCaller\r\n    ) external returns (uint64 nonce) {\r\n        // Destination caller must be nonzero. To allow any destination caller, use depositForBurn().\r\n        require(destinationCaller != bytes32(0), \"Invalid destination caller\");\r\n\r\n        return\r\n            _depositForBurn(\r\n                amount,\r\n                destinationDomain,\r\n                mintRecipient,\r\n                burnToken,\r\n                destinationCaller\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Replace a BurnMessage to change the mint recipient and/or\r\n     * destination caller. Allows the sender of a previous BurnMessage\r\n     * (created by depositForBurn or depositForBurnWithCaller)\r\n     * to send a new BurnMessage to replace the original.\r\n     * The new BurnMessage will reuse the amount and burn token of the original,\r\n     * without requiring a new deposit.\r\n     * @dev The new message will reuse the original message's nonce. For a\r\n     * given nonce, all replacement message(s) and the original message are\r\n     * valid to broadcast on the destination domain, until the first message\r\n     * at the nonce confirms, at which point all others are invalidated.\r\n     * Note: The msg.sender of the replaced message must be the same as the\r\n     * msg.sender of the original message.\r\n     * @param originalMessage original message bytes (to replace)\r\n     * @param originalAttestation original attestation bytes\r\n     * @param newDestinationCaller the new destination caller, which may be the\r\n     * same as the original destination caller, a new destination caller, or an empty\r\n     * destination caller (bytes32(0), indicating that any destination caller is valid.)\r\n     * @param newMintRecipient the new mint recipient, which may be the same as the\r\n     * original mint recipient, or different.\r\n     */\r\n    function replaceDepositForBurn(\r\n        bytes calldata originalMessage,\r\n        bytes calldata originalAttestation,\r\n        bytes32 newDestinationCaller,\r\n        bytes32 newMintRecipient\r\n    ) external {\r\n        bytes29 _originalMsg = originalMessage.ref(0);\r\n        _originalMsg._validateMessageFormat();\r\n        bytes29 _originalMsgBody = _originalMsg._messageBody();\r\n        _originalMsgBody._validateBurnMessageFormat();\r\n\r\n        bytes32 _originalMsgSender = _originalMsgBody._getMessageSender();\r\n        // _originalMsgSender must match msg.sender of original message\r\n        require(\r\n            msg.sender == Message.bytes32ToAddress(_originalMsgSender),\r\n            \"Invalid sender for message\"\r\n        );\r\n        require(\r\n            newMintRecipient != bytes32(0),\r\n            \"Mint recipient must be nonzero\"\r\n        );\r\n\r\n        bytes32 _burnToken = _originalMsgBody._getBurnToken();\r\n        uint256 _amount = _originalMsgBody._getAmount();\r\n\r\n        bytes memory _newMessageBody = BurnMessage._formatMessage(\r\n            messageBodyVersion,\r\n            _burnToken,\r\n            newMintRecipient,\r\n            _amount,\r\n            _originalMsgSender\r\n        );\r\n\r\n        localMessageTransmitter.replaceMessage(\r\n            originalMessage,\r\n            originalAttestation,\r\n            _newMessageBody,\r\n            newDestinationCaller\r\n        );\r\n\r\n        emit DepositForBurn(\r\n            _originalMsg._nonce(),\r\n            Message.bytes32ToAddress(_burnToken),\r\n            _amount,\r\n            msg.sender,\r\n            newMintRecipient,\r\n            _originalMsg._destinationDomain(),\r\n            _originalMsg._recipient(),\r\n            newDestinationCaller\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Handles an incoming message received by the local MessageTransmitter,\r\n     * and takes the appropriate action. For a burn message, mints the\r\n     * associated token to the requested recipient on the local domain.\r\n     * @dev Validates the local sender is the local MessageTransmitter, and the\r\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\r\n     * @param remoteDomain The domain where the message originated from.\r\n     * @param sender The sender of the message (remote TokenMessenger).\r\n     * @param messageBody The message body bytes.\r\n     * @return success Bool, true if successful.\r\n     */\r\n    function handleReceiveMessage(\r\n        uint32 remoteDomain,\r\n        bytes32 sender,\r\n        bytes calldata messageBody\r\n    )\r\n        external\r\n        override\r\n        onlyLocalMessageTransmitter\r\n        onlyRemoteTokenMessenger(remoteDomain, sender)\r\n        returns (bool)\r\n    {\r\n        bytes29 _msg = messageBody.ref(0);\r\n        _msg._validateBurnMessageFormat();\r\n        require(\r\n            _msg._getVersion() == messageBodyVersion,\r\n            \"Invalid message body version\"\r\n        );\r\n\r\n        bytes32 _mintRecipient = _msg._getMintRecipient();\r\n        bytes32 _burnToken = _msg._getBurnToken();\r\n        uint256 _amount = _msg._getAmount();\r\n\r\n        ITokenMinter _localMinter = _getLocalMinter();\r\n\r\n        _mintAndWithdraw(\r\n            address(_localMinter),\r\n            remoteDomain,\r\n            _burnToken,\r\n            Message.bytes32ToAddress(_mintRecipient),\r\n            _amount\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the TokenMessenger for a remote domain.\r\n     * @dev Reverts if there is already a TokenMessenger set for domain.\r\n     * @param domain Domain of remote TokenMessenger.\r\n     * @param tokenMessenger Address of remote TokenMessenger as bytes32.\r\n     */\r\n    function addRemoteTokenMessenger(uint32 domain, bytes32 tokenMessenger)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(tokenMessenger != bytes32(0), \"bytes32(0) not allowed\");\r\n\r\n        require(\r\n            remoteTokenMessengers[domain] == bytes32(0),\r\n            \"TokenMessenger already set\"\r\n        );\r\n\r\n        remoteTokenMessengers[domain] = tokenMessenger;\r\n        emit RemoteTokenMessengerAdded(domain, tokenMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the TokenMessenger for a remote domain.\r\n     * @dev Reverts if there is no TokenMessenger set for `domain`.\r\n     * @param domain Domain of remote TokenMessenger\r\n     */\r\n    function removeRemoteTokenMessenger(uint32 domain) external onlyOwner {\r\n        // No TokenMessenger set for given remote domain.\r\n        require(\r\n            remoteTokenMessengers[domain] != bytes32(0),\r\n            \"No TokenMessenger set\"\r\n        );\r\n\r\n        bytes32 _removedTokenMessenger = remoteTokenMessengers[domain];\r\n        delete remoteTokenMessengers[domain];\r\n        emit RemoteTokenMessengerRemoved(domain, _removedTokenMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Add minter for the local domain.\r\n     * @dev Reverts if a minter is already set for the local domain.\r\n     * @param newLocalMinter The address of the minter on the local domain.\r\n     */\r\n    function addLocalMinter(address newLocalMinter) external onlyOwner {\r\n        require(newLocalMinter != address(0), \"Zero address not allowed\");\r\n\r\n        require(\r\n            address(localMinter) == address(0),\r\n            \"Local minter is already set.\"\r\n        );\r\n\r\n        localMinter = ITokenMinter(newLocalMinter);\r\n\r\n        emit LocalMinterAdded(newLocalMinter);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the minter for the local domain.\r\n     * @dev Reverts if the minter of the local domain is not set.\r\n     */\r\n    function removeLocalMinter() external onlyOwner {\r\n        address _localMinterAddress = address(localMinter);\r\n        require(_localMinterAddress != address(0), \"No local minter is set.\");\r\n\r\n        delete localMinter;\r\n        emit LocalMinterRemoved(_localMinterAddress);\r\n    }\r\n\r\n    // ============ Internal Utils ============\r\n    /**\r\n     * @notice Deposits and burns tokens from sender to be minted on destination domain.\r\n     * Emits a `DepositForBurn` event.\r\n     * @param _amount amount of tokens to burn (must be non-zero)\r\n     * @param _destinationDomain destination domain\r\n     * @param _mintRecipient address of mint recipient on destination domain\r\n     * @param _burnToken address of contract to burn deposited tokens, on local domain\r\n     * @param _destinationCaller caller on the destination domain, as bytes32\r\n     * @return nonce unique nonce reserved by message\r\n     */\r\n    function _depositForBurn(\r\n        uint256 _amount,\r\n        uint32 _destinationDomain,\r\n        bytes32 _mintRecipient,\r\n        address _burnToken,\r\n        bytes32 _destinationCaller\r\n    ) internal returns (uint64 nonce) {\r\n        require(_amount > 0, \"Amount must be nonzero\");\r\n        require(_mintRecipient != bytes32(0), \"Mint recipient must be nonzero\");\r\n\r\n        bytes32 _destinationTokenMessenger = _getRemoteTokenMessenger(\r\n            _destinationDomain\r\n        );\r\n\r\n        ITokenMinter _localMinter = _getLocalMinter();\r\n        IMintBurnToken _mintBurnToken = IMintBurnToken(_burnToken);\r\n        require(\r\n            _mintBurnToken.transferFrom(\r\n                msg.sender,\r\n                address(_localMinter),\r\n                _amount\r\n            ),\r\n            \"Transfer operation failed\"\r\n        );\r\n        _localMinter.burn(_burnToken, _amount);\r\n\r\n        // Format message body\r\n        bytes memory _burnMessage = BurnMessage._formatMessage(\r\n            messageBodyVersion,\r\n            Message.addressToBytes32(_burnToken),\r\n            _mintRecipient,\r\n            _amount,\r\n            Message.addressToBytes32(msg.sender)\r\n        );\r\n\r\n        uint64 _nonceReserved = _sendDepositForBurnMessage(\r\n            _destinationDomain,\r\n            _destinationTokenMessenger,\r\n            _destinationCaller,\r\n            _burnMessage\r\n        );\r\n\r\n        emit DepositForBurn(\r\n            _nonceReserved,\r\n            _burnToken,\r\n            _amount,\r\n            msg.sender,\r\n            _mintRecipient,\r\n            _destinationDomain,\r\n            _destinationTokenMessenger,\r\n            _destinationCaller\r\n        );\r\n\r\n        return _nonceReserved;\r\n    }\r\n\r\n    /**\r\n     * @notice Sends a BurnMessage through the local message transmitter\r\n     * @dev calls local message transmitter's sendMessage() function if `_destinationCaller` == bytes32(0),\r\n     * or else calls sendMessageWithCaller().\r\n     * @param _destinationDomain destination domain\r\n     * @param _destinationTokenMessenger address of registered TokenMessenger contract on destination domain, as bytes32\r\n     * @param _destinationCaller caller on the destination domain, as bytes32. If `_destinationCaller` == bytes32(0),\r\n     * any address can call receiveMessage() on destination domain.\r\n     * @param _burnMessage formatted BurnMessage bytes (message body)\r\n     * @return nonce unique nonce reserved by message\r\n     */\r\n    function _sendDepositForBurnMessage(\r\n        uint32 _destinationDomain,\r\n        bytes32 _destinationTokenMessenger,\r\n        bytes32 _destinationCaller,\r\n        bytes memory _burnMessage\r\n    ) internal returns (uint64 nonce) {\r\n        if (_destinationCaller == bytes32(0)) {\r\n            return\r\n                localMessageTransmitter.sendMessage(\r\n                    _destinationDomain,\r\n                    _destinationTokenMessenger,\r\n                    _burnMessage\r\n                );\r\n        } else {\r\n            return\r\n                localMessageTransmitter.sendMessageWithCaller(\r\n                    _destinationDomain,\r\n                    _destinationTokenMessenger,\r\n                    _destinationCaller,\r\n                    _burnMessage\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Mints tokens to a recipient\r\n     * @param _tokenMinter address of TokenMinter contract\r\n     * @param _remoteDomain domain where burned tokens originate from\r\n     * @param _burnToken address of token burned\r\n     * @param _mintRecipient recipient address of minted tokens\r\n     * @param _amount amount of minted tokens\r\n     */\r\n    function _mintAndWithdraw(\r\n        address _tokenMinter,\r\n        uint32 _remoteDomain,\r\n        bytes32 _burnToken,\r\n        address _mintRecipient,\r\n        uint256 _amount\r\n    ) internal {\r\n        ITokenMinter _minter = ITokenMinter(_tokenMinter);\r\n        address _mintToken = _minter.mint(\r\n            _remoteDomain,\r\n            _burnToken,\r\n            _mintRecipient,\r\n            _amount\r\n        );\r\n\r\n        emit MintAndWithdraw(_mintRecipient, _amount, _mintToken);\r\n    }\r\n\r\n    /**\r\n     * @notice return the remote TokenMessenger for the given `_domain` if one exists, else revert.\r\n     * @param _domain The domain for which to get the remote TokenMessenger\r\n     * @return _tokenMessenger The address of the TokenMessenger on `_domain` as bytes32\r\n     */\r\n    function _getRemoteTokenMessenger(uint32 _domain)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        bytes32 _tokenMessenger = remoteTokenMessengers[_domain];\r\n        require(_tokenMessenger != bytes32(0), \"No TokenMessenger for domain\");\r\n        return _tokenMessenger;\r\n    }\r\n\r\n    /**\r\n     * @notice return the local minter address if it is set, else revert.\r\n     * @return local minter as ITokenMinter.\r\n     */\r\n    function _getLocalMinter() internal view returns (ITokenMinter) {\r\n        require(address(localMinter) != address(0), \"Local minter is not set\");\r\n        return localMinter;\r\n    }\r\n\r\n    /**\r\n     * @notice Return true if the given remote domain and TokenMessenger is registered\r\n     * on this TokenMessenger.\r\n     * @param _domain The remote domain of the message.\r\n     * @param _tokenMessenger The address of the TokenMessenger on remote domain.\r\n     * @return true if a remote TokenMessenger is registered for `_domain` and `_tokenMessenger`,\r\n     * on this TokenMessenger.\r\n     */\r\n    function _isRemoteTokenMessenger(uint32 _domain, bytes32 _tokenMessenger)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            _tokenMessenger != bytes32(0) &&\r\n            remoteTokenMessengers[_domain] == _tokenMessenger;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if the message sender is the local registered MessageTransmitter\r\n     * @return true if message sender is the registered local message transmitter\r\n     */\r\n    function _isLocalMessageTransmitter() internal view returns (bool) {\r\n        return\r\n            address(localMessageTransmitter) != address(0) &&\r\n            msg.sender == address(localMessageTransmitter);\r\n    }\r\n}\r\n\r\n/**\r\n * @title TokenMinter\r\n * @notice Token Minter and Burner\r\n * @dev Maintains registry of local mintable tokens and corresponding tokens on remote domains.\r\n * This registry can be used by caller to determine which token on local domain to mint for a\r\n * burned token on a remote domain, and vice versa.\r\n * It is assumed that local and remote tokens are fungible at a constant 1:1 exchange rate.\r\n */\r\ncontract TokenMinter is ITokenMinter, TokenController, Pausable, Rescuable {\r\n    // ============ Events ============\r\n    /**\r\n     * @notice Emitted when a local TokenMessenger is added\r\n     * @param localTokenMessenger address of local TokenMessenger\r\n     * @notice Emitted when a local TokenMessenger is added\r\n     */\r\n    event LocalTokenMessengerAdded(address localTokenMessenger);\r\n\r\n    /**\r\n     * @notice Emitted when a local TokenMessenger is removed\r\n     * @param localTokenMessenger address of local TokenMessenger\r\n     * @notice Emitted when a local TokenMessenger is removed\r\n     */\r\n    event LocalTokenMessengerRemoved(address localTokenMessenger);\r\n\r\n    // ============ State Variables ============\r\n    // Local TokenMessenger with permission to call mint and burn on this TokenMinter\r\n    address public localTokenMessenger;\r\n\r\n    // ============ Modifiers ============\r\n    /**\r\n     * @notice Only accept messages from the registered message transmitter on local domain\r\n     */\r\n    modifier onlyLocalTokenMessenger() {\r\n        require(_isLocalTokenMessenger(), \"Caller not local TokenMessenger\");\r\n        _;\r\n    }\r\n\r\n    // ============ Constructor ============\r\n    /**\r\n     * @param _tokenController Token controller address\r\n     */\r\n    constructor(address _tokenController) {\r\n        _setTokenController(_tokenController);\r\n    }\r\n\r\n    // ============ External Functions  ============\r\n    /**\r\n     * @notice Mints `amount` of local tokens corresponding to the\r\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\r\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\r\n     * map to a nonzero local token address. This mapping can be queried using\r\n     * getLocalToken().\r\n     * @param sourceDomain Source domain where `burnToken` was burned.\r\n     * @param burnToken Burned token address as bytes32.\r\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\r\n     * on this domain.\r\n     * @param amount Amount of tokens to mint. Must be less than or equal\r\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\r\n     * @return mintToken token minted.\r\n     */\r\n    function mint(\r\n        uint32 sourceDomain,\r\n        bytes32 burnToken,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        external\r\n        override\r\n        whenNotPaused\r\n        onlyLocalTokenMessenger\r\n        returns (address mintToken)\r\n    {\r\n        address _mintToken = _getLocalToken(sourceDomain, burnToken);\r\n        require(_mintToken != address(0), \"Mint token not supported\");\r\n        IMintBurnToken _token = IMintBurnToken(_mintToken);\r\n\r\n        require(_token.mint(to, amount), \"Mint operation failed\");\r\n        return _mintToken;\r\n    }\r\n\r\n    /**\r\n     * @notice Burn tokens owned by this TokenMinter.\r\n     * @param burnToken burnable token address.\r\n     * @param burnAmount amount of tokens to burn. Must be\r\n     * > 0, and <= maximum burn amount per message.\r\n     */\r\n    function burn(address burnToken, uint256 burnAmount)\r\n        external\r\n        override\r\n        whenNotPaused\r\n        onlyLocalTokenMessenger\r\n        onlyWithinBurnLimit(burnToken, burnAmount)\r\n    {\r\n        IMintBurnToken _token = IMintBurnToken(burnToken);\r\n        _token.burn(burnAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Add TokenMessenger for the local domain. Only this TokenMessenger\r\n     * has permission to call mint() and burn() on this TokenMinter.\r\n     * @dev Reverts if a TokenMessenger is already set for the local domain.\r\n     * @param newLocalTokenMessenger The address of the new TokenMessenger on the local domain.\r\n     */\r\n    function addLocalTokenMessenger(address newLocalTokenMessenger)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            newLocalTokenMessenger != address(0),\r\n            \"Invalid TokenMessenger address\"\r\n        );\r\n\r\n        require(\r\n            localTokenMessenger == address(0),\r\n            \"Local TokenMessenger already set\"\r\n        );\r\n\r\n        localTokenMessenger = newLocalTokenMessenger;\r\n\r\n        emit LocalTokenMessengerAdded(localTokenMessenger);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove the TokenMessenger for the local domain.\r\n     * @dev Reverts if the TokenMessenger of the local domain is not set.\r\n     */\r\n    function removeLocalTokenMessenger() external onlyOwner {\r\n        address _localTokenMessengerBeforeRemoval = localTokenMessenger;\r\n        require(\r\n            _localTokenMessengerBeforeRemoval != address(0),\r\n            \"No local TokenMessenger is set\"\r\n        );\r\n\r\n        delete localTokenMessenger;\r\n        emit LocalTokenMessengerRemoved(_localTokenMessengerBeforeRemoval);\r\n    }\r\n\r\n    /**\r\n     * @notice Set tokenController to `newTokenController`, and\r\n     * emit `SetTokenController` event.\r\n     * @dev newTokenController must be nonzero.\r\n     * @param newTokenController address of new token controller\r\n     */\r\n    function setTokenController(address newTokenController)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        _setTokenController(newTokenController);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the local token address associated with the given\r\n     * remote domain and token.\r\n     * @param remoteDomain Remote domain\r\n     * @param remoteToken Remote token\r\n     * @return local token address\r\n     */\r\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken)\r\n        external\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return _getLocalToken(remoteDomain, remoteToken);\r\n    }\r\n\r\n    // ============ Internal Utils ============\r\n    /**\r\n     * @notice Returns true if the message sender is the registered local TokenMessenger\r\n     * @return True if the message sender is the registered local TokenMessenger\r\n     */\r\n    function _isLocalTokenMessenger() internal view returns (bool) {\r\n        return\r\n            address(localTokenMessenger) != address(0) &&\r\n            msg.sender == address(localTokenMessenger);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"localTokenMessenger\",\"type\":\"address\"}],\"name\":\"LocalTokenMessengerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"localTokenMessenger\",\"type\":\"address\"}],\"name\":\"LocalTokenMessengerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"PauserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRescuer\",\"type\":\"address\"}],\"name\":\"RescuerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnLimitPerMessage\",\"type\":\"uint256\"}],\"name\":\"SetBurnLimitPerMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenController\",\"type\":\"address\"}],\"name\":\"SetTokenController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"localToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"remoteToken\",\"type\":\"bytes32\"}],\"name\":\"TokenPairLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"localToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"remoteToken\",\"type\":\"bytes32\"}],\"name\":\"TokenPairUnlinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLocalTokenMessenger\",\"type\":\"address\"}],\"name\":\"addLocalTokenMessenger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"burnLimitsPerMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"remoteToken\",\"type\":\"bytes32\"}],\"name\":\"getLocalToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"localToken\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"remoteToken\",\"type\":\"bytes32\"}],\"name\":\"linkTokenPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localTokenMessenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"sourceDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"burnToken\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"mintToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"remoteTokensToLocalTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLocalTokenMessenger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescuer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"localToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"burnLimitPerMessage\",\"type\":\"uint256\"}],\"name\":\"setMaxBurnAmountPerMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTokenController\",\"type\":\"address\"}],\"name\":\"setTokenController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"localToken\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"remoteToken\",\"type\":\"bytes32\"}],\"name\":\"unlinkTokenPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPauser\",\"type\":\"address\"}],\"name\":\"updatePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRescuer\",\"type\":\"address\"}],\"name\":\"updateRescuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenMinter", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "0000000000000000000000000c517ccc6ee685ed820779ac935df0fe4210f13c", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://37224bb8cd1d6105c267ba4d98325c99695b35022354f9a8c5badd2eea50bf1a"}