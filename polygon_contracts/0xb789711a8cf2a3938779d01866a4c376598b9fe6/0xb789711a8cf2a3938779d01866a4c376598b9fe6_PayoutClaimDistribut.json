{"SourceCode": "// Sources flattened with hardhat v2.6.4 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/cryptography/MerkleProof.sol@v3.4.2\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle trees (hash trees),\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets/contracts/token/ERC20/IERC20.sol@v1.1.5\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20 Token Standard, basic interface\r\n * @dev See https://eips.ethereum.org/EIPS/eip-20\r\n * Note: The ERC-165 identifier for this interface is 0x36372b07.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when tokens are transferred, including zero value transfers.\r\n     * @param _from The account where the transferred tokens are withdrawn from.\r\n     * @param _to The account where the transferred tokens are deposited to.\r\n     * @param _value The amount of tokens being transferred.\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n     * @dev Emitted when a successful call to {IERC20-approve(address,uint256)} is made.\r\n     * @param _owner The account granting an allowance to `_spender`.\r\n     * @param _spender The account being granted an allowance from `_owner`.\r\n     * @param _value The allowance amount being granted.\r\n     */\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /**\r\n     * @notice Returns the total token supply.\r\n     * @return The total token supply.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the account balance of another account with address `owner`.\r\n     * @param owner The account whose balance will be returned.\r\n     * @return The account balance of another account with address `owner`.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * Transfers `value` amount of tokens to address `to`.\r\n     * @dev Reverts if `to` is the zero address.\r\n     * @dev Reverts if the sender does not have enough balance.\r\n     * @dev Emits an {IERC20-Transfer} event.\r\n     * @dev Transfers of 0 values are treated as normal transfers and fire the {IERC20-Transfer} event.\r\n     * @param to The receiver account.\r\n     * @param value The amount of tokens to transfer.\r\n     * @return True if the transfer succeeds, false otherwise.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @notice Transfers `value` amount of tokens from address `from` to address `to` via the approval mechanism.\r\n     * @dev Reverts if `to` is the zero address.\r\n     * @dev Reverts if the sender is not `from` and has not been approved by `from` for at least `value`.\r\n     * @dev Reverts if `from` does not have at least `value` of balance.\r\n     * @dev Emits an {IERC20-Transfer} event.\r\n     * @dev Transfers of 0 values are treated as normal transfers and fire the {IERC20-Transfer} event.\r\n     * @param from The emitter account.\r\n     * @param to The receiver account.\r\n     * @param value The amount of tokens to transfer.\r\n     * @return True if the transfer succeeds, false otherwise.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * Sets `value` as the allowance from the caller to `spender`.\r\n     *  IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     *  that someone may use both the old and the new allowance by unfortunate\r\n     *  transaction ordering. One possible solution to mitigate this race\r\n     *  condition is to first reduce the spender's allowance to 0 and set the\r\n     *  desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @dev Reverts if `spender` is the zero address.\r\n     * @dev Emits the {IERC20-Approval} event.\r\n     * @param spender The account being granted the allowance by the message caller.\r\n     * @param value The allowance amount to grant.\r\n     * @return True if the approval succeeds, false otherwise.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * Returns the amount which `spender` is allowed to spend on behalf of `owner`.\r\n     * @param owner The account that has granted an allowance to `spender`.\r\n     * @param spender The account that was granted an allowance by `owner`.\r\n     * @return The amount which `spender` is allowed to spend on behalf of `owner`.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core/contracts/metatx/ManagedIdentity.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/*\r\n * Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner.\r\n */\r\nabstract contract ManagedIdentity {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core/contracts/access/IERC173.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC-173 Contract Ownership Standard\r\n * Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n */\r\ninterface IERC173 {\r\n    /**\r\n     * Event emited when ownership of a contract changes.\r\n     * @param previousOwner the previous owner.\r\n     * @param newOwner the new owner.\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * Get the address of the owner\r\n     * @return The address of the owner.\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * Set the address of the new owner of the contract\r\n     * Set newOwner to address(0) to renounce any ownership.\r\n     * @dev Emits an {OwnershipTransferred} event.\r\n     * @param newOwner The address of the new owner of the contract. Using the zero address means renouncing ownership.\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core/contracts/access/Ownable.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is ManagedIdentity, IERC173 {\r\n    address internal _owner;\r\n\r\n    /**\r\n     * Initializes the contract, setting the deployer as the initial owner.\r\n     * @dev Emits an {IERC173-OwnershipTransferred(address,address)} event.\r\n     */\r\n    constructor(address owner_) {\r\n        _owner = owner_;\r\n        emit OwnershipTransferred(address(0), owner_);\r\n    }\r\n\r\n    /**\r\n     * Gets the address of the current contract owner.\r\n     */\r\n    function owner() public view virtual override returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * See {IERC173-transferOwnership(address)}\r\n     * @dev Reverts if the sender is not the current contract owner.\r\n     * @param newOwner the address of the new owner. Use the zero address to renounce the ownership.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override {\r\n        _requireOwnership(_msgSender());\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if `account` is not the contract owner.\r\n     * @param account the account to test.\r\n     */\r\n    function _requireOwnership(address account) internal virtual {\r\n        require(account == this.owner(), \"Ownable: not the owner\");\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core/contracts/utils/types/AddressIsContract.sol@v1.1.3\r\n\r\n// Partially derived from OpenZeppelin:\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/406c83649bd6169fc1b578e08506d78f0873b276/contracts/utils/Address.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @dev Upgrades the address type to check if it is a contract.\r\n */\r\nlibrary AddressIsContract {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core/contracts/utils/ERC20Wrapper.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20Wrapper\r\n * Wraps ERC20 functions to support non-standard implementations which do not return a bool value.\r\n * Calls to the wrapped functions revert only if they throw or if they return false.\r\n */\r\nlibrary ERC20Wrapper {\r\n    using AddressIsContract for address;\r\n\r\n    function wrappedTransfer(\r\n        IWrappedERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function wrappedTransferFrom(\r\n        IWrappedERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function wrappedApprove(\r\n        IWrappedERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function _callWithOptionalReturnData(IWrappedERC20 token, bytes memory callData) internal {\r\n        address target = address(token);\r\n        require(target.isContract(), \"ERC20Wrapper: non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = target.call(callData);\r\n        if (success) {\r\n            if (data.length != 0) {\r\n                require(abi.decode(data, (bool)), \"ERC20Wrapper: operation failed\");\r\n            }\r\n        } else {\r\n            // revert using a standard revert message\r\n            if (data.length == 0) {\r\n                revert(\"ERC20Wrapper: operation failed\");\r\n            }\r\n\r\n            // revert using the revert message coming from the call\r\n            assembly {\r\n                let size := mload(data)\r\n                revert(add(32, data), size)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IWrappedERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/payout/PayoutClaimDistributor.sol\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n\r\n\r\n/// @title PayoutClaimDistributor\r\ncontract PayoutClaimDistributor is Ownable {\r\n    using MerkleProof for bytes32[];\r\n    using ERC20Wrapper for IWrappedERC20;\r\n\r\n    event SetMerkleRoot(bytes32 indexed merkleRoot);\r\n    event ClaimedPayout(address indexed account, uint256 amount, uint256 salt);\r\n    event DistributionLocked(bool isLocked);\r\n    event SetDistributorAddress(address indexed ownerAddress, address indexed distAddress);\r\n\r\n    bytes32 public merkleRoot;\r\n    IWrappedERC20 public token;\r\n    address public distAddress;\r\n    bool public isLocked;\r\n\r\n    /*\r\n     * Mapping for hash for (index,  address, amount, salt) for claimed status\r\n     */\r\n    mapping(bytes32 => bool) public claimed;\r\n\r\n    /// @dev Constructor for setting ERC token address on deployment\r\n    /// @param token_ Address for token to distribute\r\n    /// @dev `distAddress` deployer address will be distributor address by default\r\n    constructor(IWrappedERC20 token_) Ownable(msg.sender) {\r\n        token = token_;\r\n        distAddress = msg.sender;\r\n    }\r\n\r\n    /// @notice Merkle Root for current period to use for payout\r\n    /// @dev Owner sets merkle hash generated based on the payout set\r\n    /// @param merkleRoot_ bytes32 string of merkle root to set for specific period\r\n    function setMerkleRoot(bytes32 merkleRoot_) public {\r\n        _requireOwnership(_msgSender());\r\n        merkleRoot = merkleRoot_;\r\n        emit SetMerkleRoot(merkleRoot_);\r\n    }\r\n\r\n    /// @notice Set locked/unlocked status  for PayoutClaim Distributor\r\n    /// @dev Owner lock/unlock each time new merkle root is being generated\r\n    /// @param isLocked_ = true/false status\r\n    function setLocked(bool isLocked_) public {\r\n        _requireOwnership(_msgSender());\r\n        isLocked = isLocked_;\r\n        emit DistributionLocked(isLocked_);\r\n    }\r\n\r\n    /// @notice Distributor address in PayoutClaim Distributor\r\n    /// @dev Wallet that holds token for distribution\r\n    /// @param distributorAddress Distributor address used for distribution of `token` token\r\n    function setDistributorAddress(address distributorAddress) public {\r\n        _requireOwnership(_msgSender());\r\n        distAddress = distributorAddress;\r\n        emit SetDistributorAddress(_msgSender(), distributorAddress);\r\n    }\r\n\r\n    /// @notice Payout method that user calls to claim\r\n    /// @dev Method user calls for claiming the payout for user\r\n    /// @param account Address of the user to claim the payout\r\n    /// @param amount Claimable amount of address\r\n    /// @param salt Unique value for user for each new merkle root generating\r\n    /// @param merkleProof Merkle proof of the user based on the merkle root\r\n    function claimPayout(\r\n        address account,\r\n        uint256 amount,\r\n        uint256 salt,\r\n        bytes32[] calldata merkleProof\r\n    ) external {\r\n        require(!isLocked, \"Payout locked\");\r\n\r\n        bytes32 leafHash = keccak256(abi.encodePacked(account, amount, salt));\r\n\r\n        require(!claimed[leafHash], \"Payout already claimed\");\r\n        require(merkleProof.verify(merkleRoot, leafHash), \"Invalid proof\");\r\n\r\n        claimed[leafHash] = true;\r\n\r\n        token.wrappedTransferFrom(distAddress, account, amount);\r\n\r\n        emit ClaimedPayout(account, amount, salt);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IWrappedERC20\",\"name\":\"token_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"ClaimedPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLocked\",\"type\":\"bool\"}],\"name\":\"DistributionLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"distAddress\",\"type\":\"address\"}],\"name\":\"SetDistributorAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"SetMerkleRoot\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"}],\"name\":\"setDistributorAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isLocked_\",\"type\":\"bool\"}],\"name\":\"setLocked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IWrappedERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PayoutClaimDistributor", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "0000000000000000000000002bc07124d8dac638e290f401046ad584546bc47b", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5aaf2ccbc66cfb7298e25a30ffce2aa1adada272b076e71aa760ea2b7cfd9706"}