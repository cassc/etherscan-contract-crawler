{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.0;\r\n\r\n//File: [ReentrancyGuard.sol]\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n//File: [IMigrationManager.sol]\r\n\r\ninterface IMigrationManager\r\n{\r\n    //========================\r\n    // MIGRATION FUNCTIONS\r\n    //========================\r\n\r\n    function requestMigration(address _user, string memory _topic) external returns (uint256);\r\n    function cancelMigration(address _user, uint256 _id) external;\r\n    function executeMigration(address _user, uint256 _id) external returns (bool);\r\n}\r\n\r\n//File: [ML_TransferETH.sol]\r\n\r\ncontract ML_TransferETH\r\n{\r\n    //========================\r\n    // ATTRIBUTES\r\n    //======================== \r\n\r\n    uint256 public transferGas = 30000;\r\n\r\n    //========================\r\n    // CONFIG FUNCTIONS\r\n    //======================== \r\n\r\n    function _setTransferGas(uint256 _gas) internal\r\n    {\r\n        require(_gas >= 30000, \"Gas to low\");\r\n        require(_gas <= 250000, \"Gas to high\");\r\n        transferGas = _gas;\r\n    }\r\n\r\n    //========================\r\n    // TRANSFER FUNCTIONS\r\n    //======================== \r\n\r\n    function transferETH(address _to, uint256 _amount) internal\r\n    {\r\n        (bool success, ) = payable(_to).call{ value: _amount, gas: transferGas }(\"\");\r\n        success; //prevent warning\r\n    }\r\n}\r\n\r\n//File: [ML_ProtectedBalance.sol]\r\n\r\ncontract ML_ProtectedBalance\r\n{\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    mapping(address => uint256) private protectedBalances;\r\n\r\n    //========================\r\n    // INFO FUNCTIONS\r\n    //========================\r\n\r\n    function getProtectedBalance(address _asset) internal view returns (uint256)\r\n    {\r\n        return protectedBalances[_asset];\r\n    }\r\n\r\n    //========================\r\n    // FUNCTIONS\r\n    //========================\r\n\r\n    function increaseProtectedBalance(address _asset, uint256 _amount) internal\r\n    {\r\n        protectedBalances[_asset] += _amount;\r\n    }\r\n\r\n    function decreaseProtectedBalance(address _asset, uint256 _amount) internal\r\n    {\r\n        protectedBalances[_asset] -= _amount;\r\n    }\r\n\r\n    function resetProtectedBalance(address _asset) internal\r\n    {\r\n        protectedBalances[_asset] = 0;\r\n    }\r\n}\r\n\r\n//File: [IERC20.sol]\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n//File: [IERC20Permit.sol]\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n//File: [Address.sol]\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n//File: [IToken.sol]\r\n\r\ninterface IToken\r\n{\r\n\t//========================\r\n    // EVENTS FUNCTIONS\r\n    //========================\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\t//========================\r\n    // INFO FUNCTIONS\r\n    //========================\r\n\t\r\n\tfunction decimals() external view returns (uint8);\t\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction name() external view returns (string memory);\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\t//========================\r\n    // USER INFO FUNCTIONS\r\n    //========================\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    //========================\r\n    // TRANSFER / APPROVE FUNCTIONS\r\n    //========================\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\tfunction transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\n//File: [IMoonAccessManager.sol]\r\n\r\ninterface IMoonAccessManager\r\n{\r\n    //========================\r\n    // SECURITY FUNCTIONS\r\n    //========================\r\n\r\n    function requireAdmin(address _user) external view;\r\n    function requireManager(address _user) external view;\r\n    function requireSecurityAdmin(address _user) external view;\r\n    function requireSecurityMod(address _user) external view;\r\n    function requireDeployer(address _user) external view;    \r\n}\r\n\r\n//File: [SafeERC20.sol]\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\r\n     * Revert on invalid signature.\r\n     */\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return\r\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\r\n    }\r\n}\r\n\r\n//File: [IWrappedCoin.sol]\r\n\r\ninterface IWrappedCoin is IToken\r\n{\r\n\tfunction deposit() external payable;\r\n    function withdraw(uint256 _amount) external;\r\n}\r\n\r\n//File: [IBank.sol]\r\n\r\ninterface IBank\r\n{  \r\n    //========================\r\n    // USER INFO FUNCTIONS\r\n    //========================\r\n\r\n    function balanceOf(IToken _token, address _user) external view returns (uint256);\r\n    function allowance(IToken _token, address _user, address _spender) external view returns (uint256);\r\n    \r\n    //========================\r\n    // DEPOSIT FUNCTIONS\r\n    //========================\r\n\r\n    function depositETHFor(address _user) external payable;\r\n    function depositFor(IToken _token, address _user, uint256 _amount) external;\r\n\r\n    //========================\r\n    // TRANSFER FUNCTIONS\r\n    //========================\r\n\r\n    function transfer(IToken _token, address _from, address _to, uint256 _amount) external;\r\n    function transferToAccount(IToken _token, address _from, address _to, uint256 _amount) external;\r\n\r\n    //========================\r\n    // ALLOWANCE FUNCTIONS\r\n    //========================\r\n\r\n    function approve(IToken _token, address _spender, uint256 _amount) external;\r\n    function increaseAllowance(IToken _token, address _spender, uint256 _amount) external;\r\n    function decreaseAllowance(IToken _token, address _spender, uint256 _amount) external;\r\n}\r\n\r\n//File: [IVaultPoolInfo.sol]\r\n\r\ninterface IVaultPoolInfo\r\n{\r\n    //========================\r\n    // POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    function depositToken() external view returns (address);\r\n    function rewardToken() external view returns (IToken);\r\n\r\n    function poolTotalDeposit() external view returns (uint256);   \r\n\r\n    function poolPending() external view returns (uint256);\r\n    function poolAllocPoints() external view returns (uint256);\r\n    function poolTotalAllocPoints() external view returns (uint256);  \r\n    function poolRewardEmission() external view returns (uint256);\r\n    function poolTotalRewardEmission() external view returns (uint256);    \r\n\r\n    function poolAdditionalReward_Pending(uint256 _rewardIndex) external view returns (uint256);\r\n    function poolAdditionalReward_AllocPoints(uint256 _rewardIndex) external view returns (uint256);\r\n    function poolAdditionalReward_TotalAllocPoints(uint256 _rewardIndex) external view returns (uint256);\r\n    function poolAdditionalReward_RewardEmission(uint256 _rewardIndex) external view returns (uint256);\r\n    function poolAdditionalReward_TotalRewardEmission(uint256 _rewardIndex) external view returns (uint256);\r\n\r\n    function poolBlockOrTime() external view returns (bool);\r\n    function poolDepositFee() external view returns (uint256);\r\n    function poolWithdrawFee() external view returns (uint256); \r\n    function poolStart() external view returns (uint256);\r\n    function poolEnd() external view returns (uint256);\r\n    function poolHarvestLockUntil() external view returns (uint256);\r\n    function poolHarvestLockDelay() external view returns (uint256);\r\n\r\n    //========================\r\n    // STATIC POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    function isPoolFarmable() external view returns (bool);\r\n    function poolPendingETH() external view returns (uint256);    \r\n    function poolCompoundRewardETH() external view returns (uint256);\r\n}\r\n\r\n//File: [ML_Transfer.sol]\r\n\r\nlibrary ML_Transfer\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    //========================\r\n    // ENUM FUNCTIONS\r\n    //========================\r\n\r\n    enum TokenType\r\n    {\r\n        ERC20\r\n    }\r\n\r\n    //========================\r\n    // TOKEN FUNCTIONS\r\n    //========================\r\n\r\n    function balanceOf_token(\r\n        address _token,\r\n        TokenType _type,\r\n        address _user\r\n    ) internal view returns (uint256)\r\n    {\r\n        if (_type == TokenType.ERC20)\r\n        {\r\n            return IERC20(_token).balanceOf(_user);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    //========================\r\n    // ERC20 FUNCTIONS\r\n    //========================\r\n\r\n    function transferFrom_ERC20(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount        \r\n    ) internal\r\n    {\r\n        //transfer\r\n        IERC20(_token).safeTransferFrom(\r\n            _from, \r\n            _to, \r\n            _amount\r\n        );\r\n    }\r\n\r\n    function transfer_ERC20(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount        \r\n    ) internal\r\n    {\r\n        //transfer\r\n        IERC20(_token).safeTransfer(\r\n            _to, \r\n            _amount\r\n        );\r\n    }\r\n\r\n    function safeApprove_ERC20(\r\n        address _token, \r\n        address _spender, \r\n        uint256 _amount\r\n    ) internal\r\n    {\r\n        IERC20(_token).approve(_spender, 0); //first reset to 0 to be safe\r\n        if (_amount != 0)\r\n        {\r\n            IERC20(_token).approve(_spender, _amount);\r\n        }\r\n    }\r\n}\r\n\r\n//File: [ML_RecoverFunds.sol]\r\n\r\ncontract ML_RecoverFunds is ML_TransferETH\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    //========================\r\n    // EMERGENCY FUNCTIONS\r\n    //======================== \r\n\r\n    function _recoverETH(uint256 _amount, address _to) internal\r\n    {\r\n        transferETH(_to, _amount);\r\n    }\r\n\r\n    function _recoverToken(IToken _token, uint256 _amount, address _to) internal\r\n    {\r\n        IERC20(address(_token)).safeTransfer(_to, _amount);\r\n    }  \r\n}\r\n\r\n//File: [IVaultConfig.sol]\r\n\r\ninterface IVaultConfig\r\n{\r\n    //========================\r\n    // CONSTANTS\r\n    //========================\r\n\r\n    function PERCENT_FACTOR() external view returns (uint256);\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n    \r\n    //fees\r\n    function feeReceiver() external view returns (address);\r\n    function compoundFee() external view returns (uint256);\r\n    function rewardFee() external view returns (uint256);\r\n    function payoutFee() external view returns (uint256);\r\n    function withdrawFee() external view returns (uint256);\r\n    function withdrawFeePeriod() external view returns (uint256);\r\n\r\n    //contracts\r\n    function getAccessManager() external view returns (IMoonAccessManager);\r\n    function migrationManager() external view returns (IMigrationManager);\r\n    function bank() external view returns (IBank);\r\n\r\n    //tokens\r\n    function wrappedCoin() external view returns (IWrappedCoin);\r\n}\r\n\r\n//File: [VaultConfigAccessRequest.sol]\r\n\r\nabstract contract VaultConfigAccessRequest\r\n{\r\n    //========================\r\n    // OVERRIDE FUNCTIONS\r\n    //========================\r\n\r\n    function getAccessManager() public virtual view returns (IMoonAccessManager);\r\n\r\n    //========================\r\n    // SECURITY FUNCTIONS                                                              \r\n    //========================\r\n\r\n    function requireAdmin() internal view\r\n    {\r\n        getAccessManager().requireAdmin(msg.sender);\r\n    }\r\n\r\n    function requireManager() internal view\r\n    {\r\n        getAccessManager().requireManager(msg.sender);\r\n    }\r\n\r\n    function requireDeployer() internal view\r\n    {\r\n        getAccessManager().requireDeployer(msg.sender);\r\n    }\r\n\r\n    function requireSecurityAdmin() internal view\r\n    {\r\n        getAccessManager().requireSecurityAdmin(msg.sender);\r\n    }\r\n\r\n    function requireSecurityMod() internal view\r\n    {\r\n        getAccessManager().requireSecurityMod(msg.sender);\r\n    }\r\n}\r\n\r\n//File: [IVault.sol]\r\n\r\ninterface IVault\r\n{\r\n    //========================\r\n    // STRUCTS\r\n    //========================\r\n    \r\n    struct UserInfo\r\n    {\r\n        uint256 layer;              //layer the user is in\r\n        uint256 layerShares;        //user share of layer        \r\n        uint256 lastDepositTime;    //timestamp of last deposit\r\n        uint256 lastActionAtBlock;  //block at last performed action   \r\n        uint256 payoutDebt;         //reward debt for current layer\r\n        uint256 totalClaimed;       //total claimed payout across all layers\r\n    }\r\n\r\n    struct LayerInfo\r\n    {\r\n        uint256 payoutPercent;      //equal to layer ID. say how much % get converted to payout on compound\r\n        uint256 totalLayerShares;   //total shares of user => layer\r\n        uint256 poolShares;         //shares of layer => pool. Gets adjusted each compound)\r\n        uint256 totalClaimed;       //total claimed payout\r\n        uint256 totalPayouts;       //total deposited payouts\r\n        uint256 accPayoutPerShare;  //accumulated payout per share        \r\n        uint256 payoutShares;       //payout part of pool shares\r\n        uint256 compoundShares;     //compound part of pool shares\r\n    }    \r\n\r\n    struct LayerShareInfo\r\n    {\r\n        uint256 layer;              //layer ID / payout %\r\n        uint256 balancePerShare;    //balance per layerShare\r\n        uint256 payoutPerShare;     //payout per layerShare\r\n    }\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //======================== \r\n\r\n    function config() external view returns (IVaultConfig);  \r\n\r\n    function totalPayoutShares() external view returns (uint256);  \r\n    function totalCompoundShares() external view returns (uint256);  \r\n\r\n    //========================\r\n    // USER INFO FUNCTIONS\r\n    //======================== \r\n\r\n    function userRemainingWithdrawFeeTime(address _user) external view returns (uint256);\r\n\r\n    //========================\r\n    // INFO FUNCTIONS\r\n    //======================== \r\n\r\n    function balanceOfVault() external view returns (uint256);\r\n\r\n    //========================\r\n    // LAYER INFO FUNCTIONS\r\n    //======================== \r\n\r\n    function getLayers() external view returns (LayerInfo[] memory);\r\n\r\n    //========================\r\n    // PAYOUT FUNCTIONS\r\n    //======================== \r\n\r\n    function depositPayout(uint256 _amount) external;\r\n    function claim() external;\r\n    function claimFor(address _user) external;\r\n}\r\n\r\n//File: [IVaultStrategy.sol]\r\n\r\ninterface IVaultStrategy is\r\n    IVaultPoolInfo\r\n{\r\n    \r\n    //========================\r\n    // STRUCTS\r\n    //========================\r\n\r\n    struct SwapPath\r\n    {\r\n        address router; //router to use for swap\r\n        address[] path; //only the inbetween path\r\n    }\r\n\r\n    struct Reward\r\n    {\r\n        IToken token; //utilized token\r\n        SwapPath swap; //swap path to swap token to mainReward\r\n    }\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    function vault() external view returns (IVault);\r\n\r\n    //========================\r\n    // POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    function balanceOf() external view returns (uint256);\r\n    function rewardsContainsDepositToken() external view returns (bool);\r\n\r\n    //========================\r\n    // DEPOSIT / WITHDRAW FUNCTIONS / COMPOUND\r\n    //========================\r\n\r\n    function deposit() external returns (uint256);\r\n    function withdraw(address _user, uint256 _amount) external returns (uint256);\r\n    function compound(address _user) external returns (bool);\r\n    function harvest() external;\r\n\r\n    //========================\r\n    // STRATEGY FUNCTIONS\r\n    //========================\r\n\r\n    function retireStrategy(IVaultStrategy _newStrategy) external;  \r\n}\r\n\r\n//File: [Vault_base.sol]\r\n\r\nabstract contract Vault_base is\r\n    IVault,    \r\n    IVaultPoolInfo,\r\n    VaultConfigAccessRequest\r\n{    \r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    mapping(address => UserInfo) public users; //users in the vault\r\n\r\n    //other contracts\r\n    IVaultConfig public override config; //vaultConfig for config data\r\n    IVaultStrategy public strategy; //currently used strategy    \r\n\r\n    //stats\r\n    uint256 public lastCompound; //timestamp of last compound    \r\n\r\n    //========================\r\n    // INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice total balance of strategy + pool, excluding protected amount\r\n    function balanceOfVault() public view override returns (uint256)\r\n    {\r\n        return strategy.balanceOf();\r\n    }\r\n\r\n    //========================\r\n    // POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice deposit token of the pool\r\n    function depositToken() public view override returns (address)\r\n    {\r\n        return strategy.depositToken(); \r\n    }\r\n\r\n    ///@notice main reward token of the pool\r\n    function rewardToken() external view override returns (IToken)\r\n    {\r\n        return strategy.rewardToken(); \r\n    }    \r\n\r\n    ///@notice pool's pending rewards as ETH\r\n    function poolPendingETH() external view virtual override returns (uint256)\r\n    {\r\n        return strategy.poolPendingETH();\r\n    }    \r\n\r\n    ///@notice pool's pending compound reward as ETH\r\n    function poolCompoundRewardETH() external view virtual override returns (uint256)\r\n    {\r\n        return strategy.poolCompoundRewardETH();\r\n    }\r\n\r\n    ///@notice pool provider total deposit (to calculate pool reward emission)\r\n    function poolTotalDeposit() public view virtual override returns (uint256)\r\n    {\r\n        return strategy.poolTotalDeposit();\r\n    }\r\n\r\n    //========================\r\n    // POOL INFO (MAIN REWARD) FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice pending main reward\r\n    function poolPending() public view override returns (uint256)\r\n    {\r\n        return strategy.poolPending(); \r\n    }\r\n\r\n    ///@notice alloc points of the pool\r\n    function poolAllocPoints() external view override returns (uint256)\r\n    {\r\n        return strategy.poolAllocPoints(); \r\n    }\r\n\r\n    ///@notice total alloc points of the pool\r\n    function poolTotalAllocPoints() external view override returns (uint256)\r\n    {\r\n        return strategy.poolTotalAllocPoints(); \r\n    }\r\n\r\n    ///@notice reward emission of the pool\r\n    function poolRewardEmission() external view override returns (uint256)\r\n    {\r\n        return strategy.poolRewardEmission(); \r\n    }\r\n\r\n    ///@notice total reward emission of the pool\r\n    function poolTotalRewardEmission() external view override returns (uint256)\r\n    {\r\n        return strategy.poolTotalRewardEmission(); \r\n    }\r\n\r\n    //========================\r\n    // POOL INFO (ADDITIONAL REWARD) FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice pending additional reward\r\n    function poolAdditionalReward_Pending(uint256 _rewardIndex) external view override returns (uint256)\r\n    {\r\n        return strategy.poolAdditionalReward_Pending(_rewardIndex);\r\n    }\r\n\r\n    ///@notice alloc points of the pool's additional reward\r\n    function poolAdditionalReward_AllocPoints(uint256 _rewardIndex) external view override  returns (uint256)\r\n    {\r\n        return strategy.poolAdditionalReward_AllocPoints(_rewardIndex);\r\n    }\r\n\r\n    ///@notice total alloc points of the pool's additional reward\r\n    function poolAdditionalReward_TotalAllocPoints(uint256 _rewardIndex) external view override  returns (uint256)\r\n    {\r\n        return strategy.poolAdditionalReward_TotalAllocPoints(_rewardIndex);\r\n    }\r\n\r\n    ///@notice reward emission of the pool's additional reward\r\n    function poolAdditionalReward_RewardEmission(uint256 _rewardIndex) external view override  returns (uint256)\r\n    {\r\n        return strategy.poolAdditionalReward_RewardEmission(_rewardIndex);\r\n    }\r\n\r\n    ///@notice total reward emission of the pool's additional reward\r\n    function poolAdditionalReward_TotalRewardEmission(uint256 _rewardIndex) external view override  returns (uint256)\r\n    {\r\n        return strategy.poolAdditionalReward_TotalRewardEmission(_rewardIndex);\r\n    }\r\n\r\n    //========================\r\n    // POOL INFO (META) FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice is pool info block or time based\r\n    function poolBlockOrTime() external view override returns (bool)\r\n    {\r\n        return strategy.poolBlockOrTime(); \r\n    }\r\n\r\n    ///@notice deposit fee of the pool\r\n    function poolDepositFee() external view override returns (uint256)\r\n    {\r\n        return strategy.poolDepositFee(); \r\n    }\r\n\r\n    ///@notice withdraw fee of the pool\r\n    function poolWithdrawFee() external view override returns (uint256)\r\n    {\r\n        return strategy.poolWithdrawFee(); \r\n    }\r\n\r\n    ///@notice start of the pool rewards\r\n    function poolStart() external view override returns (uint256)\r\n    {\r\n        return strategy.poolStart(); \r\n    }\r\n\r\n    ///@notice end of the pool rewards\r\n    function poolEnd() external view override returns (uint256)\r\n    {\r\n        return strategy.poolEnd(); \r\n    }\r\n\r\n    ///@notice harvest locked until\r\n    function poolHarvestLockUntil() external view override returns (uint256)\r\n    {\r\n        return strategy.poolHarvestLockUntil(); \r\n    }\r\n\r\n    ///@notice time between harvests\r\n    function poolHarvestLockDelay() external view override returns (uint256)\r\n    {\r\n        return strategy.poolHarvestLockDelay(); \r\n    }\r\n\r\n    ///@notice is pool still farmable / has rewards\r\n    function isPoolFarmable() external view override returns (bool)\r\n    {\r\n        return strategy.isPoolFarmable(); \r\n    }\r\n\r\n    //========================\r\n    // OVERRIDE FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice get access manager\r\n    function getAccessManager() public override view returns (IMoonAccessManager)\r\n    {\r\n        return config.getAccessManager();\r\n    }\r\n}\r\n\r\n//File: [Vault_withUpgradableStrategy.sol]\r\n\r\n///@notice This part only handles strategy migration / upgrade\r\nabstract contract Vault_withUpgradableStrategy is\r\n    Vault_base\r\n{\r\n    //========================\r\n    // CONSTANTS\r\n    //========================\r\n\r\n    uint256 public constant STRATEGY_APPROVAL_DELAY = 1 days; //minimum time required before upgrade is allowed\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    IVaultStrategy public proposedStrategy; //newly proposed strategy\r\n    uint256 public proposedStrategyAt; //timestamp the new strategy was proposed at\r\n\r\n    //========================\r\n    // EVENTS\r\n    //========================\r\n\r\n    event NewStrategyCandidate(IVaultStrategy newStrategy);\r\n    event UpgradeStrategy(IVaultStrategy newStrategy);\r\n \r\n    //========================\r\n    // STRATEGY FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice propose a new strategy that you can upgrade to after the approval delay\r\n    function proposeStrategy(IVaultStrategy _strategy) external\r\n    {\r\n        //check\r\n        requireDeployer();\r\n        if (address(strategy) != address(0))\r\n        {   \r\n            require(strategy.depositToken() == _strategy.depositToken(), \"Proposal has different deposit token\");\r\n        }\r\n        require(address(this) == address(_strategy.vault()), \"Proposal not valid for this Vault\");\r\n\r\n        //check for initial proposal\r\n        if (address(strategy) == address(0))\r\n        {\r\n            strategy = _strategy;\r\n            emit UpgradeStrategy(strategy);\r\n            return;\r\n        }\r\n        \r\n        //propose\r\n        proposedStrategy = _strategy;\r\n        proposedStrategyAt = block.timestamp;\r\n\r\n        //event\r\n        emit NewStrategyCandidate(_strategy);\r\n    }\r\n\r\n    ///@notice upgrade to already proposed strategy after the approval delay\r\n    function upgradeStrategy() external\r\n    {\r\n        //check\r\n        requireManager();\r\n        require(address(proposedStrategy) != address(0), \"There is no proposed strategy\");\r\n        require(proposedStrategyAt + STRATEGY_APPROVAL_DELAY < block.timestamp, \"Delay has not passed\");\r\n\r\n        //upgrade\r\n        strategy.retireStrategy(proposedStrategy);\r\n        strategy = proposedStrategy;\r\n        strategy.deposit();\r\n\r\n        //disable proposal\r\n        proposedStrategy = IVaultStrategy(address(0));\r\n        proposedStrategyAt = 999999999999;\r\n\r\n        //event\r\n        emit UpgradeStrategy(strategy);\r\n    }\r\n}\r\n\r\n//File: [Vault_withPayoutLayers.sol]\r\n\r\n///@notice This part only handles payout layers\r\nabstract contract Vault_withPayoutLayers is\r\n    Vault_base\r\n{    \r\n    //========================\r\n    // CONSTANTS\r\n    //========================\r\n\r\n    uint256 public constant PAYOUT_PRECISION = 1e18;\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    //layers\r\n    mapping(uint256 => LayerInfo) public layers; //layer info\r\n    uint256 public selectableLayers; //number of selected layers. There is always layer 0 with 100% compound\r\n    uint256 public layerStepSize; //step size from layer to layer\r\n\r\n    //shares    \r\n    uint256 public totalPoolShares; //total shares of all layers in pool\r\n    uint256 public override totalPayoutShares; //total pool shares to payout\r\n    uint256 public override totalCompoundShares; //total pool shares to compound\r\n\r\n    //========================\r\n    // EVENTS\r\n    //========================\r\n\r\n    event UgradeLayers(uint256 oldLayers, uint256 newLayers);\r\n\r\n    //========================\r\n    // CREATE\r\n    //========================\r\n\r\n    constructor()\r\n    {\r\n        //set initial layers\r\n        _upgradeLayers(2);\r\n    }\r\n\r\n    //========================\r\n    // CONFIG FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice upgrade to more layers\r\n    function upgradeLayers(uint256 _newLayers) external\r\n    {\r\n        //check\r\n        requireManager();\r\n\r\n        //upgrade\r\n        _upgradeLayers(_newLayers);\r\n    }\r\n\r\n    ///@notice upgrade to more layers\r\n    function _upgradeLayers(uint256 _newLayers) internal\r\n    {\r\n        //check\r\n        checkValidLayerCount(_newLayers);\r\n        require(_newLayers > selectableLayers, \"Can't downgrade Layers\");\r\n        require((selectableLayers != 2\r\n                || _newLayers != 5),\r\n            \"Invalid upgrade\"\r\n        ); //cant upgrade from 2 => 5 as layer 50 wouldn't be accessible\r\n        require((selectableLayers != 4\r\n                || _newLayers == 20),\r\n            \"Invalid upgrade\"\r\n        ); //can only upgrade from 4 => 20 as layers that have 5% steps wouldn't be accessible\r\n        \r\n        //upgrade\r\n        uint256 oldLayers = selectableLayers;\r\n        selectableLayers = _newLayers;\r\n        layerStepSize = getLayerStepSize();\r\n\r\n        //init layers\r\n        for (uint256 n = layerStepSize; n <= 100; n += layerStepSize)\r\n        {\r\n            layers[n].payoutPercent = n;\r\n        }\r\n\r\n        //event\r\n        emit UgradeLayers(oldLayers, _newLayers);\r\n    }\r\n\r\n    //========================\r\n    // USER INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice balance of given user\r\n    function balanceOf(address _user) public view returns (uint256)\r\n    {\r\n        return getUserShare(_user, balanceOfVault());\r\n    }\r\n\r\n    ///@notice pending reward share of user\r\n    function userPending(address _user) external view returns (uint256)\r\n    {\r\n        return getUserShare(_user, poolPending());\r\n    }\r\n\r\n    //========================\r\n    // LAYER INFO FUNCTIONS\r\n    //========================  \r\n\r\n    ///@notice get step size for current layer count\r\n    function getLayerStepSize() private view returns (uint256)\r\n    {\r\n        return (selectableLayers == 0\r\n            ? 0\r\n            : 100 / selectableLayers\r\n        );\r\n    }\r\n\r\n    ///@notice get list of all layers\r\n    function getLayers() public view override returns (LayerInfo[] memory)\r\n    {\r\n        LayerInfo[] memory l = new LayerInfo[](1 + selectableLayers);\r\n\r\n        l[0] = layers[0];\r\n        if (layerStepSize > 0)\r\n        {\r\n            //load layers\r\n            for (uint256 n = 1; n <= selectableLayers; n++)\r\n            {                \r\n                l[n] = layers[(n * layerStepSize)];\r\n            }\r\n        }\r\n\r\n        return l; \r\n    }\r\n\r\n    ///@notice calculate total compound and payout shares for given layer\r\n    function getPayoutAndCompoundShare(uint256 _layer) public view returns (uint256 compoundShares, uint256 payoutShares)\r\n    {\r\n        uint256 poolShares = layers[_layer].poolShares;\r\n        uint256 pShares = (poolShares * layers[_layer].payoutPercent) / 100; \r\n        return (\r\n            (poolShares - pShares),\r\n            pShares            \r\n        );\r\n    }    \r\n\r\n    ///@notice get balance/payout per share for given layer\r\n    function getLayerShareInfo(uint256 _layer) internal view returns (LayerShareInfo memory)\r\n    {\r\n        return LayerShareInfo(\r\n            {\r\n                layer: _layer,\r\n                balancePerShare: convertTo1LayerShare(\r\n                    _layer, \r\n                    getLayerShare(\r\n                        _layer, \r\n                        balanceOfVault()\r\n                    )\r\n                ),\r\n                payoutPerShare: convertTo1LayerShare(\r\n                    _layer, \r\n                    layers[_layer].totalPayouts\r\n                )\r\n            }\r\n        );\r\n    }\r\n\r\n    function convertTo1LayerShare(uint256 _layer, uint256 _total) internal view returns (uint256)\r\n    {\r\n        LayerInfo storage l = layers[_layer];\r\n        return (l.totalLayerShares == 0\r\n            ? 0\r\n            : (_total * (10 ** IToken(depositToken()).decimals())) / l.totalLayerShares\r\n        );\r\n    }\r\n\r\n    ///@notice get balance/payout per share for all layers\r\n    function getLayersShareInfo() public view returns (LayerShareInfo[] memory)\r\n    {\r\n        LayerShareInfo[] memory l = new LayerShareInfo[](1 + selectableLayers);\r\n\r\n        l[0] = getLayerShareInfo(0);\r\n        if (layerStepSize > 0)\r\n        {\r\n            //load layers\r\n            for (uint256 n = 1; n <= selectableLayers; n++)\r\n            {                \r\n                l[n] = getLayerShareInfo(n * layerStepSize);\r\n            }\r\n        }\r\n\r\n        return l; \r\n    }\r\n\r\n    //========================\r\n    // DEPOSIT / WITHDRAW FUNCTIONS\r\n    //========================    \r\n\r\n    ///@notice deposits funds for a user into his selected layer\r\n    ///@dev this function only handles shares and doesn't transfer funds\r\n    function depositToLayer(\r\n        address _user,\r\n        uint256 _amount,\r\n        uint256 _vaultBalanceBefore //important as function is called AFTER deposit (taxed tokens)\r\n    ) internal\r\n    {\r\n        //get data\r\n        UserInfo storage user = users[_user];\r\n        LayerInfo storage layer = layers[user.layer];\r\n        uint256 layerShare = convertAmountToLayerShare(user.layer, _amount, _vaultBalanceBefore);\r\n        uint256 poolShare = amountToPoolShare(_amount, _vaultBalanceBefore);\r\n\r\n        //layerShares\r\n        user.layerShares += layerShare;\r\n        layer.totalLayerShares += layerShare;\r\n\r\n        //poolShares\r\n        layer.poolShares += poolShare;\r\n        totalPoolShares += poolShare;\r\n\r\n        //compound/payout shares\r\n        adjustPayoutCompoundShares(layer.payoutPercent);\r\n    }\r\n\r\n    ///@notice withdraws funds for a user from his selected layer\r\n    ///@dev this function only handles shares and doesn't transfer funds\r\n    function withdrawFromLayer(address _user, uint256 _shares) internal\r\n    {\r\n        //get data\r\n        UserInfo storage user = users[_user];\r\n        LayerInfo storage layer = layers[user.layer];        \r\n        uint256 amount = convertLayerShareToAmount(user.layer, _shares);\r\n        uint256 poolShare = amountToPoolShare(amount, balanceOfVault());\r\n\r\n        //layerShares\r\n        user.layerShares -= _shares;\r\n        layer.totalLayerShares -= _shares;\r\n\r\n        //poolShares\r\n        layer.poolShares -= poolShare;\r\n        totalPoolShares -= poolShare;\r\n\r\n        //compound/payout shares\r\n        adjustPayoutCompoundShares(layer.payoutPercent);\r\n    }\r\n\r\n    //========================\r\n    // COMPOUND FUNCTIONS\r\n    //======================== \r\n\r\n    ///@notice adjust each layer's pool share in relation to its compound shares\r\n    function adjustPoolSharesAfterCompound(\r\n        uint256 _balanceBefore,\r\n        uint256 _balanceGained\r\n    ) internal\r\n    {   \r\n        //check if layer adjust is required\r\n        if (layerStepSize == 0)\r\n        {            \r\n            return;\r\n        }\r\n\r\n        //calculate       \r\n        uint256 sharesGained = (totalPoolShares * _balanceGained) / _balanceBefore;\r\n        if (sharesGained == 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //spread across layers\r\n        uint256 shares;\r\n        uint256 layerSharesGained;\r\n        uint256 addedShares = 0;  \r\n        uint256 currentTotalCompoundShares = totalCompoundShares; //value changes during adjustment\r\n        for (uint256 n = layerStepSize; n <= 100; n += layerStepSize)\r\n        {\r\n            //calculate\r\n            shares = layers[n].compoundShares;\r\n            if (shares != 0)\r\n            {\r\n                layerSharesGained = (sharesGained * shares) / currentTotalCompoundShares;\r\n                addedShares += layerSharesGained;      \r\n                layers[n].poolShares += layerSharesGained;\r\n                adjustPayoutCompoundShares(n);\r\n            }\r\n        }            \r\n        layers[0].poolShares += (sharesGained - addedShares); //give remaining\r\n        adjustPayoutCompoundShares(0);\r\n        totalPoolShares += sharesGained;\r\n    }\r\n\r\n    //========================\r\n    // USER => LAYER CONVERSION FUNCTIONS\r\n    //========================  \r\n\r\n    ///@notice get share for given amount, at given vault balance\r\n    function convertAmountToLayerShare(\r\n        uint256 _layer,\r\n        uint256 _amount,\r\n        uint256 _atVaultBalance\r\n    ) internal view returns (uint256)\r\n    {\r\n        uint256 totalShares = layers[_layer].totalLayerShares;\r\n        uint256 layerBalance = (totalPoolShares == 0\r\n            ? 0\r\n            : (_atVaultBalance * layers[_layer].poolShares) / totalPoolShares\r\n        );\r\n        return (totalShares == 0\r\n            ? _amount\r\n            : (totalShares * _amount) / layerBalance\r\n        );\r\n    }   \r\n    \r\n    ///@notice get amount for given share, at given vault balance\r\n    function convertLayerShareToAmount(\r\n        uint256 _layer,\r\n        uint256 _shares\r\n    ) internal view returns (uint256)\r\n    {\r\n        uint256 totalShares = layers[_layer].totalLayerShares;\r\n        uint256 totalLayerBalance = poolShareToAmount(layers[_layer].poolShares);\r\n        return (totalShares == 0\r\n            ? _shares\r\n            : (totalLayerBalance * _shares) / totalShares\r\n        );\r\n    }\r\n\r\n    ///@notice get share of user (depending on his selected layer)\r\n    function getUserShare(address _user, uint256 _total) internal view returns (uint256)\r\n    {\r\n        uint256 layer = users[_user].layer;\r\n        uint256 totalShares = layers[layer].totalLayerShares;\r\n        return getLayerShare(\r\n            layer,\r\n            (totalShares == 0\r\n                ? 0\r\n                : (_total * users[_user].layerShares) / totalShares\r\n            )\r\n        );\r\n    }\r\n\r\n    //========================\r\n    // LAYER => POOL CONVERSION FUNCTIONS\r\n    //========================  \r\n\r\n    ///@notice get share for given amount\r\n    function amountToPoolShare(\r\n        uint256 _amount,\r\n        uint256 _atVaultBalance\r\n    ) internal view returns (uint256)\r\n    {\r\n        return (totalPoolShares == 0\r\n            ? _amount\r\n            : (totalPoolShares * _amount) / _atVaultBalance\r\n        );\r\n    }\r\n\r\n    ///@notice get amount for given share\r\n    function poolShareToAmount(uint256 _shares) internal view returns (uint256)\r\n    {\r\n        return (totalPoolShares == 0\r\n            ? _shares\r\n            : (balanceOfVault() * _shares) / totalPoolShares\r\n        );\r\n    }\r\n\r\n    ///@notice get share of layer\r\n    function getLayerShare(uint256 _layer, uint256 _total) internal view returns (uint256)\r\n    {\r\n        return (totalPoolShares == 0\r\n            ? 0\r\n            : (_total * layers[_layer].poolShares) / totalPoolShares\r\n        );\r\n    }\r\n\r\n    //========================\r\n    // HELPER FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice adjust payout/compound shares for a given layer\r\n    function adjustPayoutCompoundShares(uint256 _layer) private\r\n    {\r\n        LayerInfo storage layer = layers[_layer];  \r\n\r\n        //compound/payout shares (substract old => update => add new)\r\n        totalCompoundShares -= layer.compoundShares;\r\n        totalPayoutShares -= layer.payoutShares;\r\n        (layer.compoundShares, layer.payoutShares) = getPayoutAndCompoundShare(_layer);\r\n        totalCompoundShares += layer.compoundShares;\r\n        totalPayoutShares += layer.payoutShares;\r\n    }    \r\n\r\n    function clearUserPayoutDebt(address _user) internal\r\n    {\r\n        UserInfo storage user = users[_user];\r\n        LayerInfo storage layer = layers[user.layer];\r\n        user.payoutDebt = (user.layerShares * layer.accPayoutPerShare) / PAYOUT_PRECISION;\r\n    }\r\n\r\n    //========================\r\n    // SECURITY FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice check if given layer is valid\r\n    function requireValidLayer(uint256 _layer) internal view\r\n    {\r\n        require(_layer <= 100, \"Invalid layer\");\r\n        require(_layer % getLayerStepSize() == 0, \"Non-selectable layer\");\r\n    }\r\n\r\n    ///@notice check if layer count is valid\r\n    function checkValidLayerCount(uint256 _layers) private pure\r\n    {\r\n        require(\r\n            (_layers == 0               //1 layer => 100% compound\r\n                || _layers == 1         //2 layers => 0/100% (100)\r\n                || _layers == 2         //3 layers => 0/50/100 (50)\r\n                || _layers == 4         //4 layers => 0/25/50/75/100 (25)\r\n                || _layers == 5         //5 layers => 0/20/40/60/80/100 (20)\r\n                || _layers == 10        //11 layers => 0/10/20/.../100 (10)\r\n                || _layers == 20        //21 layers => 0/5/10/15.../100 (5)\r\n            ),\r\n            \"Invalid Layer count\"\r\n        );\r\n    }\r\n}\r\n\r\n//File: [Vault_withPayoutManager.sol]\r\n\r\n///@notice This part only handles payouts to a layer and claiming\r\nabstract contract Vault_withPayoutManager is\r\n    Vault_withPayoutLayers,\r\n    ReentrancyGuard,\r\n    ML_ProtectedBalance,\r\n    ML_TransferETH\r\n{\r\n    //========================\r\n    // CONSTANTS\r\n    //========================\r\n\r\n    address public constant COIN = address(0);\r\n\r\n    //========================\r\n    // EVENTS\r\n    //========================\r\n\r\n    event Claim(\r\n        address indexed user,\r\n        uint256 claimed\r\n    );\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    uint256 public totalClaimed; //total claimed payouts\r\n    uint256 public totalPayouts; //total deposited payouts\r\n\r\n    //========================\r\n    // USER INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice pending payout of user\r\n    function userPendingPayouts(address _user) public view returns (uint256)\r\n    {\r\n        //get data\r\n        UserInfo storage user = users[_user];\r\n        LayerInfo storage layer = layers[user.layer];        \r\n\r\n        //calculate\r\n        uint256 payout = (user.layerShares * layer.accPayoutPerShare) / PAYOUT_PRECISION;\r\n        return payout - user.payoutDebt;\r\n    }\r\n\r\n    //========================\r\n    // DEPOSIT PAYOUT FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice deposit and distribute payout to layers\r\n    function depositPayoutToLayers(uint256 _amount) internal\r\n    {\r\n        //deposit newly received payout to layers (skip layer 0)\r\n        if (layerStepSize > 0)\r\n        {            \r\n            for (uint256 n = layerStepSize; n <= 100; n += layerStepSize)\r\n            {\r\n                depositPayoutToLayer(n, _amount);\r\n            }\r\n        }        \r\n        totalPayouts += _amount;\r\n        increaseProtectedBalance(COIN, _amount);\r\n    }\r\n\r\n    ///@notice deposit payout to a given layer and update accumulated payouts\r\n    function depositPayoutToLayer(uint256 _layer, uint256 _amount) private\r\n    {\r\n        LayerInfo storage layer = layers[_layer];\r\n        if (layer.totalLayerShares == 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //calculate payout share\r\n        uint256 layerPayout = (_amount * layers[_layer].payoutShares) / totalPayoutShares;        \r\n\r\n        //adjust\r\n        if (layerPayout > 0)\r\n        {\r\n            layer.totalPayouts += layerPayout;\r\n            layer.accPayoutPerShare += (layerPayout * PAYOUT_PRECISION) / layer.totalLayerShares;\r\n        }\r\n    }\r\n\r\n    //========================\r\n    // PAYOUT FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice claim payout\r\n    function claim() public override\r\n    {\r\n        claimFor(msg.sender);\r\n    }\r\n\r\n    ///@notice claim payout for given user\r\n    function claimFor(address _user) public override nonReentrant\r\n    {   \r\n        _claimFor(_user);\r\n    }\r\n\r\n    function _claimFor(address _user) internal\r\n    {   \r\n        UserInfo storage user = users[_user];\r\n        LayerInfo storage layer = layers[user.layer];        \r\n\r\n        //claim\r\n        uint256 pending = userPendingPayouts(_user);\r\n        if (pending > 0)\r\n        {\r\n            IBank bank = config.bank();\r\n            if (address(bank) == address(0))\r\n            {\r\n                //transfer directly to user\r\n                transferETH(\r\n                    _user,\r\n                    pending\r\n                );\r\n            }\r\n            else\r\n            {\r\n                bank.depositETHFor{ value: pending }(_user);\r\n            }\r\n\r\n            //statistics\r\n            user.totalClaimed += pending;\r\n            layer.totalClaimed += pending;\r\n            totalClaimed += pending;\r\n            decreaseProtectedBalance(COIN, pending);\r\n\r\n            //event\r\n            emit Claim(\r\n                _user,\r\n                pending\r\n            );\r\n        }\r\n\r\n        //payout debt\r\n        clearUserPayoutDebt(_user);\r\n    }\r\n}\r\n\r\n///@notice combines all features and handles logging\r\ncontract VaultV2 is\r\n    Vault_withPayoutManager,\r\n    Vault_withUpgradableStrategy,\r\n    ML_RecoverFunds\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using ML_Transfer for address;\r\n\r\n    //========================\r\n    // STRUCTS\r\n    //========================\r\n\r\n    struct UserTransactionInfo\r\n    {\r\n        uint256 layer;              //layer ID / payout %\r\n        uint256 movedShares;        //shares equal to movedAmount\r\n        uint256 sharesAfter;        //shares after the Tx\r\n        uint256 amount;             //amount of transaction\r\n        uint256 movedAmount;        //actual amount after taxes and fees\r\n        uint256 balanceBefore;      //balance before Tx\r\n        uint256 balanceAfter;       //balance after Tx\r\n        uint256 totalPayout;        //total claimed + unclaimed payout of user\r\n        uint256 totalBalance;       //total balance of vault\r\n        LayerShareInfo infoBefore;  //layer share info before Tx\r\n        LayerShareInfo infoAfter;   //layer share info after Tx,        \r\n    }\r\n\r\n    //========================\r\n    // CONSTANTS\r\n    //========================\r\n\r\n\tstring public constant VERSION = \"2.0.0\";\r\n\r\n    //========================\r\n    // EVENTS\r\n    //========================\r\n\r\n    event Deposit(\r\n        address indexed user,\r\n        UserTransactionInfo userTxInfo\r\n    );\r\n    event Withdraw(\r\n        address indexed user,\r\n        UserTransactionInfo userTxInfo\r\n    );\r\n    event SwitchLayer(\r\n        address indexed user,\r\n        uint256 oldLayer,\r\n        UserTransactionInfo userTxInfo\r\n    );\r\n    event Compound(\r\n        address indexed user,\r\n        uint256 totalBalance,\r\n        LayerShareInfo[] infoBefore,\r\n        LayerShareInfo[] infoAfter\r\n    );   \r\n    event DepositPayout(\r\n        address indexed payer,\r\n        uint256 amount\r\n    );\r\n\r\n    //========================\r\n    // CREATE\r\n    //========================\r\n\r\n    constructor(IVaultConfig _config)\r\n    {\r\n        //init\r\n        config = _config;\r\n    }\r\n\r\n    //========================\r\n    // USER CONFIG FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice switch payout layer for current user\r\n    function switchLayer(uint256 _newLayer) external\r\n    {\r\n        //check\r\n        requireValidLayer(_newLayer);        \r\n        require(_newLayer != users[msg.sender].layer, \"Already in layer\");\r\n\r\n        //check if user has balance\r\n        uint256 balance = balanceOf(msg.sender);\r\n        if (balance == 0)\r\n        {\r\n            //switch layer\r\n            users[msg.sender].layer = _newLayer;\r\n            return;\r\n        }\r\n\r\n        //get data\r\n        UserInfo storage user = users[msg.sender];  \r\n        uint256 oldLayer = user.layer;\r\n\r\n        //claim\r\n        _claimFor(msg.sender);\r\n\r\n        //withdraw => switch layer => deposit\r\n        withdrawFromLayer(\r\n            msg.sender, \r\n            user.layerShares\r\n        );\r\n        users[msg.sender].layer = _newLayer;\r\n        depositToLayer(\r\n            msg.sender, \r\n            balance, \r\n            balanceOfVault() //balance didn't change\r\n        );\r\n\r\n        //payout debt\r\n        clearUserPayoutDebt(msg.sender);\r\n\r\n        //event              \r\n        UserTransactionInfo memory userTxInfo = createUserTxInfo_deposit(msg.sender, 0);\r\n        emit SwitchLayer(\r\n            msg.sender,\r\n            oldLayer,\r\n            fillUserTxInfo(\r\n                msg.sender, \r\n                userTxInfo, \r\n                0\r\n            )\r\n        );\r\n    }\r\n\r\n    //========================\r\n    // USER INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice get remaining time until user can withdraw without early-withdraw fee\r\n    function userRemainingWithdrawFeeTime(address _user) external view override returns (uint256)\r\n    {\r\n        uint256 timeSinceLastDeposit = block.timestamp - users[_user].lastDepositTime;\r\n        if (timeSinceLastDeposit >= config.withdrawFeePeriod())\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        return (config.withdrawFeePeriod() - timeSinceLastDeposit);\r\n    }\r\n\r\n    //========================\r\n    // DEPOSIT FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice deposit for current user\r\n    function deposit(uint256 _amount) external \r\n    {\r\n        depositFor(msg.sender, _amount);        \r\n    }\r\n\r\n    ///@notice deposit for given user\r\n    function depositFor(address _user, uint256 _amount) public nonReentrant\r\n    {\r\n        //check\r\n        requireBlockLock(_user);\r\n        require(address(strategy) != address(0), \"No strategy defined\");        \r\n        require(_amount > 0, \"Invalid amount\");\r\n        require(_amount <= IToken(depositToken()).balanceOf(_user), \"Insufficient balance\");\r\n\r\n        //claim\r\n        _claimFor(_user);\r\n\r\n        //harvest required?\r\n        harvestIfRewardContainsDeposit();\r\n\r\n        //deposit into pool\r\n        UserTransactionInfo memory userTxInfo = createUserTxInfo_deposit(_user, _amount);\r\n        uint256 balanceBefore = balanceOfVault();\r\n        uint256 deposited = farmUser(msg.sender, _amount); //first deposit, to get actual deposit (in case of taxes)\r\n\r\n        //adjust shares\r\n        depositToLayer(_user, deposited, balanceBefore);\r\n\r\n        //user deposit time\r\n        users[_user].lastDepositTime = block.timestamp;\r\n\r\n        //payout debt\r\n        clearUserPayoutDebt(_user);\r\n\r\n        //event for frontend\r\n        emit Deposit(\r\n            _user,\r\n            fillUserTxInfo(\r\n                _user, \r\n                userTxInfo, \r\n                deposited\r\n            )\r\n        );\r\n    }\r\n\r\n    //========================\r\n    // WITHDRAW FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice withdraw shares from vault\r\n    function withdraw(uint256 _shares) external nonReentrant\r\n    {\r\n        //check\r\n        requireBlockLock(msg.sender);\r\n        require(_shares > 0, \"Nothing to withdraw\");\r\n        require(users[msg.sender].layerShares > 0, \"Insufficient shares\");        \r\n\r\n        //limit shares\r\n        if (_shares > users[msg.sender].layerShares)\r\n        {\r\n            _shares = users[msg.sender].layerShares;\r\n        }\r\n\r\n        //claim\r\n        _claimFor(msg.sender);\r\n\r\n        //harvest required?\r\n        harvestIfRewardContainsDeposit();\r\n\r\n        //adjust shares\r\n        UserTransactionInfo memory userTxInfo = createUserTxInfo_withdraw(msg.sender, _shares);\r\n        withdrawFromLayer(msg.sender, _shares);\r\n\r\n        //withdraw from strategy\r\n        uint256 withdrawn = strategy.withdraw(msg.sender, userTxInfo.amount);\r\n\r\n        //payout debt\r\n        clearUserPayoutDebt(msg.sender);\r\n\r\n        //event\r\n        emit Withdraw(\r\n            msg.sender,\r\n            fillUserTxInfo(\r\n                msg.sender,\r\n                userTxInfo,\r\n                withdrawn\r\n            )\r\n        );\r\n    }\r\n\r\n    //========================\r\n    // COMPOUND FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice compound vault\r\n    function compound() external nonReentrant\r\n    {\r\n        _compound(msg.sender);\r\n    }\r\n\r\n    ///@notice compound vault\r\n    function _compound(address _user) private\r\n    {        \r\n        //collect info before\r\n        LayerShareInfo[] memory infoBefore = getLayersShareInfo();\r\n\r\n        //try compound\r\n        uint256 balanceBefore = balanceOfVault();\r\n        (bool compounded) = strategy.compound(_user);\r\n        if (compounded)\r\n        {\r\n            //stats            \r\n            lastCompound = block.timestamp;\r\n\r\n            //adjust pool shares\r\n            uint256 balanceAfter = balanceOfVault();\r\n            uint256 balanceGained = balanceAfter - balanceBefore;\r\n            if (balanceGained > 0)\r\n            {\r\n                adjustPoolSharesAfterCompound(\r\n                    balanceBefore,\r\n                    balanceGained\r\n                );\r\n            }            \r\n\r\n            //collect info after\r\n            LayerShareInfo[] memory infoAfter = getLayersShareInfo();            \r\n\r\n            //event\r\n            emit Compound(\r\n                _user,\r\n                balanceAfter,\r\n                infoBefore,\r\n                infoAfter\r\n            );\r\n        }\r\n    }\r\n\r\n    ///@notice harvest if reward contains deposit token\r\n    function harvestIfRewardContainsDeposit() private\r\n    {\r\n        //check if harvest required\r\n        if (strategy.rewardsContainsDepositToken())\r\n        {\r\n            strategy.harvest();\r\n        }\r\n    }    \r\n\r\n    //========================\r\n    // DEPOSIT PAYOUT FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice deposit payout to vault\r\n    function depositPayout(uint256 _amount) external override\r\n    {\r\n        //transfer payout\r\n        address(config.wrappedCoin()).transferFrom_ERC20(\r\n            msg.sender,\r\n            address(this),\r\n            _amount            \r\n        );\r\n\r\n        //unwrap\r\n        config.wrappedCoin().withdraw(_amount);\r\n\r\n        //deposit payout\r\n        depositPayoutToLayers(_amount);\r\n\r\n        //event\r\n        emit DepositPayout(\r\n            msg.sender,\r\n            _amount\r\n        );\r\n    }\r\n\r\n    //========================\r\n    // FARM FUNCTIONS\r\n    //========================\r\n    \r\n    ///@notice send deposit token into strategy and deposit into pool\r\n    function farmUser(address _payer, uint256 _amount) internal returns (uint256)\r\n    {\r\n        //from user to strategy (this way P2P tax is reduced)\r\n        depositToken().transferFrom_ERC20(            \r\n            _payer,\r\n            address(strategy),\r\n            _amount\r\n        );\r\n        return strategy.deposit();\r\n    }\r\n\r\n    //========================\r\n    // TX INFO FUNCTIONS\r\n    //======================== \r\n\r\n    function createUserTxInfo_deposit(address _user, uint256 _amount) private view returns (UserTransactionInfo memory)\r\n    {\r\n        uint256 userLayer = users[_user].layer;\r\n        return UserTransactionInfo(\r\n        {\r\n            layer: userLayer,\r\n            movedShares: convertAmountToLayerShare(\r\n                userLayer, \r\n                _amount,\r\n                balanceOfVault()\r\n            ),\r\n            sharesAfter: 0,\r\n            amount: _amount,\r\n            movedAmount: 0,\r\n            balanceBefore: balanceOf(_user),\r\n            balanceAfter: 0,\r\n            totalPayout: 0,\r\n            totalBalance: 0,\r\n            infoBefore: getLayerShareInfo(userLayer),\r\n            infoAfter: LayerShareInfo(\r\n            {\r\n                layer: userLayer,\r\n                balancePerShare: 0,\r\n                payoutPerShare: 0\r\n            })\r\n        });\r\n    }\r\n\r\n    function createUserTxInfo_withdraw(address _user, uint256 _shares) private view returns (UserTransactionInfo memory)\r\n    {\r\n        uint256 userLayer = users[_user].layer;\r\n        return UserTransactionInfo(\r\n        {\r\n            layer: userLayer,\r\n            movedShares: _shares,\r\n            sharesAfter: 0,\r\n            amount: convertLayerShareToAmount(userLayer, _shares),\r\n            movedAmount: 0,\r\n            balanceBefore: balanceOf(_user),\r\n            balanceAfter: 0,\r\n            totalPayout: 0,\r\n            totalBalance: 0,\r\n            infoBefore: getLayerShareInfo(userLayer),\r\n            infoAfter: LayerShareInfo(\r\n            {\r\n                layer: userLayer,\r\n                balancePerShare: 0,\r\n                payoutPerShare: 0\r\n            })\r\n        });\r\n    }\r\n\r\n    function fillUserTxInfo(\r\n        address _user, \r\n        UserTransactionInfo memory _data,\r\n        uint256 _movedAmount\r\n    ) private view returns (UserTransactionInfo memory)\r\n    {\r\n        _data.sharesAfter = users[_user].layerShares;\r\n        _data.totalPayout = users[_user].totalClaimed + userPendingPayouts(_user);\r\n        _data.movedAmount = _movedAmount;\r\n        _data.balanceAfter = balanceOf(_user);\r\n        _data.infoAfter = getLayerShareInfo(users[_user].layer);\r\n        _data.totalBalance = balanceOfVault();\r\n        return _data;\r\n    }\r\n\r\n    //========================\r\n    // SECURITY FUNCTIONS\r\n    //======================== \r\n\r\n    ///@notice ensure that user doesn't execute multiple actions in same block\r\n    function requireBlockLock(address _user) private\r\n    {\r\n        require(block.number != users[_user].lastActionAtBlock, \"Block lock\");\r\n        users[_user].lastActionAtBlock = block.number;\r\n    }\r\n\r\n    //========================\r\n    // HELPER FUNCTIONS\r\n    //========================  \r\n\r\n    receive() external payable {}\r\n\r\n    //========================\r\n    // EMERGENCY FUNCTIONS\r\n    //======================== \r\n\r\n    ///@notice recover ETH (can only recover funds that are not reserved for payouts)\r\n    function recoverETH(uint256 _amount, address _to) external\r\n    {\r\n        //check\r\n        requireSecurityAdmin();\r\n        require(\r\n            _amount <= address(this).balance - getProtectedBalance(COIN),\r\n            \"Can't access payouts\"\r\n        );\r\n\r\n        //recover\r\n        _recoverETH(_amount, _to);\r\n    }\r\n\r\n    ///@notice recover token (this contract will normally never hold any tokens)\r\n    function recoverToken(IToken _token, uint256 _amount, address _to) external\r\n    {\r\n        //check\r\n        requireSecurityAdmin();\r\n\r\n        //recover\r\n        _recoverToken(_token, _amount, _to);\r\n    } \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IVaultConfig\",\"name\":\"_config\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutPerShare\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IVault.LayerShareInfo[]\",\"name\":\"infoBefore\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutPerShare\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IVault.LayerShareInfo[]\",\"name\":\"infoAfter\",\"type\":\"tuple[]\"}],\"name\":\"Compound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"movedShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"movedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutPerShare\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.LayerShareInfo\",\"name\":\"infoBefore\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutPerShare\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.LayerShareInfo\",\"name\":\"infoAfter\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct VaultV2.UserTransactionInfo\",\"name\":\"userTxInfo\",\"type\":\"tuple\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IVaultStrategy\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"NewStrategyCandidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLayer\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"movedShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"movedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutPerShare\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.LayerShareInfo\",\"name\":\"infoBefore\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutPerShare\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.LayerShareInfo\",\"name\":\"infoAfter\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct VaultV2.UserTransactionInfo\",\"name\":\"userTxInfo\",\"type\":\"tuple\"}],\"name\":\"SwitchLayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLayers\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLayers\",\"type\":\"uint256\"}],\"name\":\"UgradeLayers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IVaultStrategy\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"UpgradeStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"movedShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"movedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutPerShare\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.LayerShareInfo\",\"name\":\"infoBefore\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutPerShare\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.LayerShareInfo\",\"name\":\"infoAfter\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct VaultV2.UserTransactionInfo\",\"name\":\"userTxInfo\",\"type\":\"tuple\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COIN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYOUT_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STRATEGY_APPROVAL_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"claimFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"contract IVaultConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccessManager\",\"outputs\":[{\"internalType\":\"contract IMoonAccessManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLayers\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"payoutPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLayerShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accPayoutPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compoundShares\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.LayerInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLayersShareInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balancePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutPerShare\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.LayerShareInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getPayoutAndCompoundShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"compoundShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPoolFarmable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastCompound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"layerStepSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"layers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payoutPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLayerShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accPayoutPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compoundShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"}],\"name\":\"poolAdditionalReward_AllocPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"}],\"name\":\"poolAdditionalReward_Pending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"}],\"name\":\"poolAdditionalReward_RewardEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"}],\"name\":\"poolAdditionalReward_TotalAllocPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"}],\"name\":\"poolAdditionalReward_TotalRewardEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolAllocPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolBlockOrTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolCompoundRewardETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolDepositFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolHarvestLockDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolHarvestLockUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolPendingETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolRewardEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTotalAllocPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTotalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTotalRewardEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolWithdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IVaultStrategy\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"proposeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedStrategy\",\"outputs\":[{\"internalType\":\"contract IVaultStrategy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedStrategyAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IToken\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"recoverToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selectableLayers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"contract IVaultStrategy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLayer\",\"type\":\"uint256\"}],\"name\":\"switchLayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCompoundShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayoutShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoolShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLayers\",\"type\":\"uint256\"}],\"name\":\"upgradeLayers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userPendingPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userRemainingWithdrawFeeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"layer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"layerShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDepositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastActionAtBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "VaultV2", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000085e9703da23cd870df89f21bc325d60784291fc1", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bff0d83b37fe56d75bebb85301dc45b26c146e4a5ed41dd30c66f99e4cf43df6"}