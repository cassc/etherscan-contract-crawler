{"SourceCode": "{\"Bucket.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.8.0;\\r\\n\\r\\ncontract Bucket {\\r\\n    struct BucketStock {\\r\\n        uint8[] typeDays;\\r\\n        uint16[] stockPrefixSum;\\r\\n        uint16 currentBucketStock;//\u5f53\u524d\u5e93\u5b58\\r\\n        mapping(uint16 =\\u003e uint16) ledgerStockIndex;\\r\\n        uint256 stockSize;//\u5e93\u5b58\u5927\u5c0f\\r\\n    }\\r\\n\\r\\n    mapping(uint256 =\\u003e BucketStock) public ledgerBucketStock;\\r\\n\\r\\n    /**\\r\\n     * @dev set an array of stock for the blind box\\r\\n     */\\r\\n    function _setStock(\\r\\n        uint256 ledgerType,\\r\\n        uint8[] memory typeDays,\\r\\n        uint16[] memory stock\\r\\n    ) internal {\\r\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\r\\n        uint16 itemCount = 0;\\r\\n        uint16[] storage stockPrefixSum = bucketStock.stockPrefixSum;\\r\\n        uint8[] storage typeDaysStorage = bucketStock.typeDays;\\r\\n        uint256 stockLength = stock.length;\\r\\n        for (uint16 i = 0; i \\u003c stockLength; ++i) {\\r\\n            itemCount += stock[i];\\r\\n            stockPrefixSum.push(itemCount);//\u5e93\u5b58\u524d\u7f00\u603b\u548c\\r\\n            typeDaysStorage.push(typeDays[i]);//\u7c7b\u578b\u5929\u6570\u5b58\u50a8\\r\\n        }\\r\\n        bucketStock.currentBucketStock = itemCount;\\r\\n        bucketStock.stockSize = itemCount;\\r\\n        require(stockPrefixSum.length \\u003c= 2e16, \\\"stock length too long\\\");\\r\\n    }\\r\\n\\r\\n    /** \u8865\u5145\u5e93\u5b58\\r\\n     * @dev refill the stock of the bucket\\r\\n     * @param ledgerType the type of the ledger\\r\\n     */\\r\\n    function _refillStock(uint256 ledgerType) internal {\\r\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\r\\n        bucketStock.currentBucketStock = uint16(bucketStock.stockSize);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Buy only one box \u53ea\u4e70\u4e00\u76d2\\r\\n     */\\r\\n    function _pickDay(uint256 ledgerType, uint256 seed) internal returns (uint16) {\\r\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\r\\n        uint16 randIndex = _getRandomIndex(seed, bucketStock.currentBucketStock);\\r\\n        uint16 location = _pickLocation(randIndex, bucketStock);\\r\\n        uint16 category = binarySearch(bucketStock.stockPrefixSum, location);\\r\\n        return bucketStock.typeDays[category];\\r\\n    }\\r\\n\\r\\n    //\u9009\u62e9\u4f4d\u7f6e\\r\\n    function _pickLocation(uint16 index, BucketStock storage bucketStock) internal returns (uint16) {\\r\\n        uint16 location = bucketStock.ledgerStockIndex[index];\\r\\n        if (location == 0) {\\r\\n            location = index + 1;\\r\\n        }\\r\\n        uint16 lastIndexLocation = bucketStock.ledgerStockIndex[bucketStock.currentBucketStock - 1];\\r\\n\\r\\n        if (lastIndexLocation == 0) {\\r\\n            lastIndexLocation = bucketStock.currentBucketStock;\\r\\n        }\\r\\n        bucketStock.ledgerStockIndex[index] = lastIndexLocation;\\r\\n        bucketStock.currentBucketStock--;\\r\\n        bucketStock.ledgerStockIndex[bucketStock.currentBucketStock] = location;\\r\\n\\r\\n        // refill the bucket\\r\\n        if (bucketStock.currentBucketStock == 0) {\\r\\n            bucketStock.currentBucketStock = uint16(bucketStock.stockSize);\\r\\n        }\\r\\n        return location - 1;\\r\\n    }\\r\\n\\r\\n    function _getRandomIndex(uint256 seed, uint16 size) internal view returns (uint16) {\\r\\n        // NOTICE: We do not to prevent miner from front-running the transaction and the contract. \u6211\u4eec\u4e0d\u4f1a\u963b\u6b62\u77ff\u5de5\u63d0\u524d\u5904\u7406\u4ea4\u6613\u548c\u5408\u540c\u3002\\r\\n        return\\r\\n        uint16(\\r\\n            uint256(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        block.difficulty,\\r\\n                        block.timestamp,\\r\\n                        msg.sender,\\r\\n                        blockhash(block.number - 1),\\r\\n                        seed,\\r\\n                        size\\r\\n                    )\\r\\n                )\\r\\n            ) % size\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getBucketInfo(uint256 ledgerType) external view returns (uint8[] memory, uint16[] memory) {\\r\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\r\\n        return (bucketStock.typeDays, bucketStock.stockPrefixSum);\\r\\n    }\\r\\n\\r\\n    function binarySearch(uint16[] storage array, uint16 target) internal view returns (uint16) {\\r\\n        uint256 left = 0;\\r\\n        uint256 right = array.length - 1;\\r\\n        uint256 mid;\\r\\n        while (left \\u003c right - 1) {\\r\\n            mid = left + (right - left) / 2;\\r\\n            if (array[mid] \\u003e target) {\\r\\n                right = mid;\\r\\n            } else {\\r\\n                left = mid + 1;\\r\\n            }\\r\\n        }\\r\\n        if (target \\u003c array[left]) {\\r\\n            return uint16(left);\\r\\n        } else {\\r\\n            return uint16(right);\\r\\n        }\\r\\n    }\\r\\n}\"},\"DistrictPower.sol\":{\"content\":\"pragma solidity 0.8.19;\\r\\nimport \\\"./ReentrancyGuard.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./Bucket.sol\\\";\\r\\nimport \\\"./IV3SwapRouter.sol\\\";\\r\\nimport \\\"./INonfungiblePositionManager.sol\\\";\\r\\n\\r\\ninterface IERC20EX is IERC20{\\r\\n    function _mint(address account, uint256 amount) external;\\r\\n    function _burn(address account, uint256 amount) external;\\r\\n}\\r\\n\\r\\ncontract DistrictPower is ReentrancyGuard, Bucket {\\r\\n    \\r\\n    uint256 public constant PRINCIPAL_RATIO = 600000;\\r\\n    uint256 public constant INVEST_RATIO = 290000;\\r\\n    uint256 public constant SUPERNODE_RATIO = 10000;\\r\\n    uint256 public constant PLATFORM_RATIO = 10000;\\r\\n    uint256 public constant REFERRER_RATIO = 50000;\\r\\n    uint256 public constant BUYBACK_RATIO = 20000;\\r\\n    uint256 public constant RECOMMENDREWARD_RATIO = 20000;\\r\\n    uint256 public constant PRICE_PRECISION = 1e6;\\r\\n\\r\\n    uint256 public constant ACCURACY = 1e18;\\r\\n\\r\\n    uint256 public constant DEFAULT_INVEST_RETURN_RATE = 10000;\\r\\n\\r\\n    uint256 public constant MAX_INVEST = 1e3 * ACCURACY;\\r\\n    uint256 public constant MIN_INVEST = 1e1 * ACCURACY;\\r\\n\\r\\n    uint256 public constant TIME_UNIT = 1 days;\\r\\n\\r\\n    uint256 public constant MAX_SEARCH_DEPTH = 100;\\r\\n    uint256 public constant RANKED_INCENTIVE = 60;\\r\\n\\r\\n    address public platformAddress;\\r\\n\\r\\n    uint256[4] public currentEpochs;\\r\\n\\r\\n    mapping(uint256 =\\u003e mapping(address =\\u003e PositionInfo[]))[6] public roundLedgers;\\r\\n\\r\\n    mapping(uint256 =\\u003e RoundInfo)[6] public roundInfos;\\r\\n\\r\\n    mapping(address =\\u003e UserRoundInfo[])[6] public userRoundsInfos;\\r\\n\\r\\n    mapping(address =\\u003e UserGlobalInfo) public userGlobalInfos;\\r\\n\\r\\n    mapping(address =\\u003e address[]) public children;\\r\\n\\r\\n    uint256 public totalFlowAmount;\\r\\n\\r\\n    mapping(uint256 =\\u003e uint256) public epochCurrentInvestAmount;\\r\\n\\r\\n    uint256 public stopLossAmount;\\r\\n\\r\\n    address public tempAdmin;\\r\\n    address public operator;\\r\\n    bool public gamePaused;\\r\\n\\r\\n    IV3SwapRouter router =\\r\\n    IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\\r\\n    INonfungiblePositionManager positionManager =\\r\\n    INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\\r\\n    uint24 constant defaultFee = 3000;\\r\\n    address public tokenAddress = 0xC76FBB012f1248fd203DB39C85290f46D288dfDB;//\\r\\n    address public maticAddress = 0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889;\\r\\n    uint256 public positionId = 1027443;\\r\\n    uint256 public lpMaticAmount;\\r\\n    uint256 public lpMaticLimit = 66000 * ACCURACY;\\r\\n\\r\\n    bool[3] public totalAmountMagicBox = [false,false,false];\\r\\n    uint256[3] public totalFlowAmountThreshold = [10000000 * ACCURACY, 20000000 * ACCURACY, 30000000 * ACCURACY];\\r\\n    uint256 public startUseTokenNum = 3300000 * ACCURACY;\\r\\n    uint256[10] public levelSales = [5000 * ACCURACY, 30000 * ACCURACY, 100000 * ACCURACY, 300000 * ACCURACY, 800000 * ACCURACY, 2000000 * ACCURACY, 5000000 * ACCURACY, 15000000 * ACCURACY, 30000000 * ACCURACY, 80000000 * ACCURACY];\\r\\n\\r\\n    struct FundTarget {\\r\\n        uint256 lastCheckTime;\\r\\n        uint256 amount;\\r\\n        uint256 achievedAmount;\\r\\n    }\\r\\n\\r\\n    struct UserGlobalInfo {\\r\\n\\r\\n        address referrer;\\r\\n        uint256 totalReferrerReward;\\r\\n        uint256 referrerRewardClaimed;\\r\\n        uint256 boostCredit;\\r\\n        uint256 maxChildrenSales;\\r\\n        uint256 sales;\\r\\n        uint256 totalPositionAmount;\\r\\n        uint256 reportedSales;\\r\\n        uint8 salesLevel;\\r\\n        uint8 supernode;\\r\\n        address supernodeAddress;\\r\\n        uint256 rewardTime;\\r\\n        uint256 rewardAmount;\\r\\n    }\\r\\n\\r\\n    struct PositionInfo {\\r\\n        uint256 amount;\\r\\n        uint256 openTime;\\r\\n        uint256 expiryTime;\\r\\n        uint256 investReturnRate;\\r\\n        uint256 withdrawnAmount;\\r\\n        uint256 incentiveAmount;\\r\\n        uint256 investReturnAmount;\\r\\n        uint256 index;\\r\\n        bool incentiveClaimable;\\r\\n        uint256 stopLossTime;\\r\\n        uint256 lossAmount;\\r\\n        bool lossAmountExist;\\r\\n        uint256 claimableDays;\\r\\n        uint256 claimableAmount;\\r\\n    }\\r\\n\\r\\n    struct LinkedPosition {\\r\\n        address user;\\r\\n        uint256 userPositionIndex;\\r\\n    }\\r\\n\\r\\n    struct RoundInfo {\\r\\n        FundTarget fundTarget;\\r\\n        uint256 totalPositionAmount;\\r\\n        uint256 currentPrincipalAmount;\\r\\n        uint256 currentInvestAmount;\\r\\n        uint256 totalPositionCount;\\r\\n        uint256 currentPositionCount;\\r\\n        uint256 currentIncentiveAmount;\\r\\n        uint256 incentiveSnapshot;\\r\\n        uint256 head;\\r\\n        mapping(uint256 =\\u003e LinkedPosition) linkedPositions;\\r\\n        mapping(address =\\u003e uint256) ledgerRoundToUserRoundIndex;\\r\\n        bool stopLoss;\\r\\n    }\\r\\n\\r\\n    struct UserRoundInfo {\\r\\n        uint256 epoch;\\r\\n        uint256 totalPositionAmount;\\r\\n        uint256 currentPrincipalAmount;\\r\\n        uint256 totalWithdrawnAmount;\\r\\n        uint256 totalIncentiveClaimedAmount;\\r\\n        uint256 totalClosedPositionCount;\\r\\n        uint256 returnRateBoostedAmount;\\r\\n    }\\r\\n\\r\\n    struct ReferrerSearch {\\r\\n        uint256 currentUserSales;\\r\\n        uint256 currentReferrerSales;\\r\\n        address currentReferrer;\\r\\n        uint256 currentReferrerAmount;\\r\\n        uint256 levelDiffAmount;\\r\\n        uint256 leftLevelDiffAmount;\\r\\n        uint256 levelDiffAmountPerLevel;\\r\\n        uint256 levelSearchAmount;\\r\\n        uint256 leftLevelSearchAmount;\\r\\n        uint256 levelSearchAmountPerReferrer;\\r\\n        uint256 levelSearchSales;\\r\\n        uint256 currentReferrerMaxChildSales;\\r\\n        uint256 currentUserTotalPosAmount;\\r\\n        uint256 currentUserReportedSales;\\r\\n        address currentUser;\\r\\n        uint8 depth;\\r\\n        uint8 levelSearchStep;\\r\\n        uint8 currentLevelDiff;\\r\\n        uint8 numLevelSearchCandidate;\\r\\n        uint8 baseSalesLevel;\\r\\n        uint8 currentReferrerLevel;\\r\\n        bool levelDiffDone;\\r\\n        bool levelSearchDone;\\r\\n        bool levelSalesDone;\\r\\n    }\\r\\n\\r\\n    struct OpenPositionParams {\\r\\n        uint256 principalAmount;\\r\\n        uint256 investAmount;\\r\\n        uint256 referrerAmount;\\r\\n        uint256 incentiveAmount;\\r\\n        uint256 investReturnRate;\\r\\n    }\\r\\n\\r\\n    event PositionOpened(\\r\\n        address indexed user,\\r\\n        uint256 indexed ledgeType,\\r\\n        uint256 indexed epoch,\\r\\n        uint256 positionIndex,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    event PositionClosed(\\r\\n        address indexed user,\\r\\n        uint256 indexed ledgeType,\\r\\n        uint256 indexed epoch,\\r\\n        uint256 positionIndex,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    event NewReferrer(address indexed user, address indexed referrer);\\r\\n    event NewRound(uint256 indexed epoch, uint256 indexed ledgeType);\\r\\n    event ReferrerRewardAdded(address indexed user, uint256 amount, uint256 indexed rewardType);\\r\\n    event ReferrerRewardClaimed(address indexed user, uint256 amount);\\r\\n    event SalesLevelUpdated(address indexed user, uint8 level);\\r\\n    event IncentiveClaimed(address indexed user, uint256 amount);\\r\\n\\r\\n    event AddLiquityEvent(uint256 liquity);\\r\\n\\r\\n    struct AssetPackageInfo {\\r\\n        uint256 birthday;\\r\\n        uint256 amount;\\r\\n        uint256 release;\\r\\n        uint256 withdrawn;\\r\\n        bool state;\\r\\n    }\\r\\n    mapping(address =\\u003e AssetPackageInfo[]) public AssetPackage;\\r\\n\\r\\n    modifier notContract() {\\r\\n        require(msg.sender == tx.origin, \\\"Contract not allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _platformAddress,\\r\\n        address _tempAdmin,\\r\\n        address _operator\\r\\n    ) {\\r\\n        require(\\r\\n            _platformAddress != address(0) \\u0026\\u0026 _tempAdmin != address(0) \\u0026\\u0026 _operator != address(0),\\r\\n            \\\"Invalid address provided\\\"\\r\\n        );\\r\\n        emit NewRound(0, 0);\\r\\n        emit NewRound(0, 1);\\r\\n        emit NewRound(0, 2);\\r\\n        emit NewRound(0, 3);\\r\\n        emit NewRound(0, 4);\\r\\n        emit NewRound(0, 5);\\r\\n\\r\\n        (uint8[] memory typeDays1,uint16[] memory stock1) = generateTypeDaysAndStock(2, 19);\\r\\n        setStock(1, typeDays1, stock1);\\r\\n        (uint8[] memory typeDays2,uint16[] memory stock2) = generateTypeDaysAndStock(20, 39);\\r\\n        setStock(2, typeDays2, stock2);\\r\\n        (uint8[] memory typeDays3,uint16[] memory stock3) = generateTypeDaysAndStock(40, 50);\\r\\n        setStock(3, typeDays3, stock3);\\r\\n\\r\\n        UserGlobalInfo storage userGlobalInfo;\\r\\n        userGlobalInfo = userGlobalInfos[_platformAddress];\\r\\n        userGlobalInfo.referrer = address(0x0000000000000000000000000000000000000000);\\r\\n        userGlobalInfo.salesLevel = 10;\\r\\n        children[address(0x0000000000000000000000000000000000000000)].push(_platformAddress);\\r\\n\\r\\n        tempAdmin = _tempAdmin;\\r\\n        operator = _operator;\\r\\n        platformAddress = _platformAddress;\\r\\n        gamePaused = false;\\r\\n\\r\\n        IERC20(tokenAddress).approve(address(router),type(uint).max);\\r\\n        IERC20(tokenAddress).approve(address(positionManager),type(uint).max);\\r\\n    }\\r\\n    \\r\\n    function generateTypeDaysAndStock(uint8 start, uint8 end) internal pure returns (uint8[] memory, uint16[] memory) {\\r\\n        require(start \\u003c end, \\\"Invalid range\\\");\\r\\n\\r\\n        uint8 length = end - start + 1;\\r\\n        uint8[] memory typeDays = new uint8[](length);\\r\\n        uint16[] memory stock = new uint16[](length);\\r\\n\\r\\n        for (uint8 i = start; i \\u003c= end; i++) {\\r\\n            typeDays[i-start] = i;\\r\\n            stock[i-start] = i;\\r\\n        }\\r\\n\\r\\n        return (typeDays, stock);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the game paused status\\r\\n     * @param _paused: The game paused status\\r\\n     */\\r\\n    function setPause(bool _paused) external {\\r\\n        require(msg.sender == operator, \\\"Only operator\\\");\\r\\n        gamePaused = _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer operator\\r\\n     */\\r\\n    function transferOperator(address _operator) external {\\r\\n        require(msg.sender == operator, \\\"Only operator\\\");\\r\\n        require(_operator != address(0), \\\"Invalid address\\\");\\r\\n        operator = _operator;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Drop the temp admin privilege\\r\\n     */\\r\\n    function dropTempAdmin() external {\\r\\n        require(msg.sender == tempAdmin, \\\"Only admin\\\");\\r\\n        tempAdmin = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Batch set referrer information for users\\r\\n     * @param users: The users to set\\r\\n     * @param referrers: The referrers to set\\r\\n     * @param salesLevels: The sales levels to set\\r\\n     */\\r\\n    function batchSetReferrerInfo(\\r\\n        address[] memory users,\\r\\n        address[] memory referrers,\\r\\n        uint8[] memory salesLevels,\\r\\n        uint8[] memory supernodes,\\r\\n        address[] memory supernodeAddresss\\r\\n    ) external {\\r\\n        require(msg.sender == tempAdmin, \\\"Only admin\\\");\\r\\n        require(users.length == referrers.length \\u0026\\u0026 users.length == salesLevels.length \\u0026\\u0026 users.length == supernodes.length \\u0026\\u0026 users.length == supernodeAddresss.length, \\\"Invalid input\\\");\\r\\n        UserGlobalInfo storage userGlobalInfo;\\r\\n        uint256 userLength = users.length;\\r\\n        for (uint256 i = 0; i \\u003c userLength; ++i) {\\r\\n            require(users[i] != address(0), \\\"Invalid address provided\\\");\\r\\n            userGlobalInfo = userGlobalInfos[users[i]];\\r\\n            require(userGlobalInfo.referrer == address(0), \\\"Referrer already set\\\");\\r\\n            userGlobalInfo.referrer = referrers[i];\\r\\n            userGlobalInfo.salesLevel = salesLevels[i];\\r\\n            userGlobalInfo.supernode = supernodes[i];\\r\\n            userGlobalInfo.supernodeAddress = supernodeAddresss[i];\\r\\n            children[referrers[i]].push(users[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set fixed stock distribution to specific ledger type\\r\\n     * @param ledgerType: The ledger type to set\\r\\n     * @param typeDays: The days to set\\r\\n     * @param stock: The stock to set\\r\\n     */\\r\\n    function setStock(\\r\\n        uint256 ledgerType,\\r\\n        uint8[] memory typeDays,\\r\\n        uint16[] memory stock\\r\\n    ) internal {\\r\\n        require(ledgerType \\u003e 0, \\\"Invalid ledger type\\\");\\r\\n        require(ledgerType \\u003c 4, \\\"Invalid ledger type\\\");\\r\\n        require(stock.length \\u003e 0, \\\"Invalid stock array\\\");\\r\\n        require(typeDays.length == stock.length, \\\"Invalid params\\\");\\r\\n\\r\\n        _setStock(ledgerType, typeDays, stock);\\r\\n    }\\r\\n\\r\\n    function openPosition(\\r\\n        address referrer\\r\\n    ) public payable notContract nonReentrant {\\r\\n        require(msg.value \\u003e= MIN_INVEST, \\\"Too small\\\");\\r\\n        require(msg.value \\u003c= MAX_INVEST, \\\"Too large\\\");\\r\\n        require(!gamePaused, \\\"Paused\\\");\\r\\n\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\r\\n        address _referrer = userGlobalInfo.referrer;\\r\\n\\r\\n        if (_referrer == address(0) \\u0026\\u0026 children[msg.sender].length == 0) {\\r\\n            _referrer = referrer;\\r\\n            require((referrer != address(0) \\u0026\\u0026 referrer != msg.sender) || referrer == platformAddress, \\\"Invalid referrer\\\");\\r\\n\\r\\n            require(\\r\\n                userGlobalInfos[referrer].referrer != address(0) || children[referrer].length \\u003e 0,\\r\\n                \\\"Invalid referrer 2\\\"\\r\\n            );\\r\\n\\r\\n            userGlobalInfo.referrer = referrer;\\r\\n            children[referrer].push(msg.sender);\\r\\n            emit NewReferrer(msg.sender, referrer);\\r\\n\\r\\n        }\\r\\n\\r\\n        if(userGlobalInfo.supernodeAddress == address(0)){\\r\\n            if(userGlobalInfos[_referrer].supernode == 1){\\r\\n                userGlobalInfo.supernodeAddress = _referrer;\\r\\n            }else if(userGlobalInfos[_referrer].supernodeAddress != address(0)){\\r\\n                userGlobalInfo.supernodeAddress = userGlobalInfos[_referrer].supernodeAddress;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 platformAmount = msg.value;\\r\\n        if(totalFlowAmount \\u003e= startUseTokenNum){\\r\\n       \\r\\n            uint256 useTokenAmount = msg.value / 10;\\r\\n            require(IERC20(tokenAddress).balanceOf(msg.sender) \\u003e= useTokenAmount, \\\"Insufficient Token amount\\\");\\r\\n            require(IERC20(tokenAddress).allowance(msg.sender, address(this)) \\u003e= useTokenAmount, \\\"Insufficient Token allowance\\\");\\r\\n            IERC20EX(tokenAddress)._burn(msg.sender, useTokenAmount);\\r\\n        }\\r\\n        bool success;\\r\\n\\r\\n        {\\r\\n            uint256 recommendReward = msg.value * RECOMMENDREWARD_RATIO / PRICE_PRECISION;\\r\\n            platformAmount -= recommendReward;\\r\\n\\r\\n            (success, ) = _referrer.call{value: recommendReward}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        }\\r\\n\\r\\n        {\\r\\n            uint256 buybackAmount = msg.value * BUYBACK_RATIO / PRICE_PRECISION;\\r\\n            platformAmount -= buybackAmount;\\r\\n            if(lpMaticAmount \\u003c= lpMaticLimit){\\r\\n                addLiquitidyWithId(buybackAmount * 100, buybackAmount);\\r\\n                lpMaticAmount += buybackAmount;\\r\\n            }else{\\r\\n                uint256 historyTokenAmount = IERC20(tokenAddress).balanceOf(address(this));\\r\\n                buyBurn(buybackAmount);\\r\\n                uint256 nowTokenAmount = IERC20(tokenAddress).balanceOf(address(this));\\r\\n                uint256 differenceTokenAmount = nowTokenAmount - historyTokenAmount;\\r\\n                if(differenceTokenAmount \\u003e 0){\\r\\n                    IERC20EX(tokenAddress)._burn(address(this), differenceTokenAmount);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        {\\r\\n            if(userGlobalInfo.supernodeAddress != address(0)){\\r\\n                uint256 supernodeAmount = msg.value * SUPERNODE_RATIO / PRICE_PRECISION;\\r\\n                platformAmount -= supernodeAmount;\\r\\n                (success, ) = userGlobalInfo.supernodeAddress.call{value: supernodeAmount}(\\\"\\\");\\r\\n                require(success, \\\"Transfer failed.\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 MagicBoxAmount1 =  msg.value * 40 / 100;\\r\\n        uint256 MagicBoxAmount2 =  msg.value * 20 / 100;\\r\\n        uint256 MagicBoxAmount3 =  msg.value * 30 / 100;\\r\\n        uint256 MagicBoxAmount4 =  msg.value * 10 / 100;\\r\\n        uint256 distributionAmount = 0;\\r\\n        distributionAmount += setPosition(MagicBoxAmount1,0);\\r\\n        distributionAmount += setPosition(MagicBoxAmount2,1);\\r\\n        distributionAmount += setPosition(MagicBoxAmount3,2);\\r\\n        distributionAmount += setPosition(MagicBoxAmount4,3);\\r\\n\\r\\n        platformAmount -= distributionAmount;\\r\\n\\r\\n        if(platformAmount \\u003e 0){\\r\\n            (success, ) = platformAddress.call{\\r\\n            value: platformAmount\\r\\n            }(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        }\\r\\n\\r\\n        totalFlowAmount += msg.value;\\r\\n        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Open a new position\\r\\n     * @param ledgerType: The ledger type to open\\r\\n     */\\r\\n    function setPosition (\\r\\n        uint256 amountValue,\\r\\n        uint256 ledgerType\\r\\n    ) internal returns (uint256) {\\r\\n        require(ledgerType \\u003c 4, \\\"Invalid ledger type\\\");\\r\\n\\r\\n        uint256 targetEpoch = currentEpochs[ledgerType];\\r\\n\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\r\\n\\r\\n        RoundInfo storage roundInfo = roundInfos[ledgerType][targetEpoch];\\r\\n\\r\\n        UserRoundInfo storage userRoundInfo;\\r\\n\\r\\n        OpenPositionParams memory params = OpenPositionParams({\\r\\n        principalAmount: (amountValue * PRINCIPAL_RATIO) / PRICE_PRECISION,\\r\\n        investAmount: (amountValue * INVEST_RATIO) / PRICE_PRECISION,\\r\\n        referrerAmount: (amountValue * REFERRER_RATIO) / PRICE_PRECISION,\\r\\n        incentiveAmount: (amountValue * 0) / PRICE_PRECISION,\\r\\n        investReturnRate: DEFAULT_INVEST_RETURN_RATE\\r\\n        });\\r\\n\\r\\n        uint256 userRoundInfoLength = userRoundsInfos[ledgerType][msg.sender].length;\\r\\n        if (\\r\\n            userRoundInfoLength == 0 ||\\r\\n            userRoundsInfos[ledgerType][msg.sender][userRoundInfoLength - 1].epoch \\u003c targetEpoch\\r\\n        ) {\\r\\n\\r\\n            UserRoundInfo memory _userRoundInfo;\\r\\n            _userRoundInfo = UserRoundInfo({\\r\\n            epoch: targetEpoch,\\r\\n            totalPositionAmount: 0,\\r\\n            currentPrincipalAmount: 0,\\r\\n            totalWithdrawnAmount: 0,\\r\\n            totalIncentiveClaimedAmount: 0,\\r\\n            totalClosedPositionCount: 0,\\r\\n            returnRateBoostedAmount: 0\\r\\n            });\\r\\n\\r\\n            userRoundsInfos[ledgerType][msg.sender].push(_userRoundInfo);\\r\\n            roundInfo.ledgerRoundToUserRoundIndex[msg.sender] = userRoundInfoLength;\\r\\n            userRoundInfoLength += 1;\\r\\n        }\\r\\n\\r\\n        userRoundInfo = userRoundsInfos[ledgerType][msg.sender][userRoundInfoLength - 1];\\r\\n        userRoundInfo.totalPositionAmount += amountValue;\\r\\n        userRoundInfo.currentPrincipalAmount += params.principalAmount;\\r\\n\\r\\n        roundInfo.totalPositionAmount += amountValue;\\r\\n        roundInfo.currentPrincipalAmount += params.principalAmount;\\r\\n\\r\\n        epochCurrentInvestAmount[targetEpoch] += params.investAmount;\\r\\n        roundInfo.currentPositionCount += 1;\\r\\n        roundInfo.currentIncentiveAmount += params.incentiveAmount;\\r\\n        roundInfo.incentiveSnapshot += amountValue;\\r\\n        roundInfo.totalPositionCount += 1;\\r\\n\\r\\n        uint256 userTotalPositionCount = roundLedgers[ledgerType][targetEpoch][msg.sender].length;\\r\\n\\r\\n        {\\r\\n            uint256 openTime = block.timestamp;\\r\\n            uint256 expiryTime = block.timestamp;\\r\\n            if (ledgerType == 0) {\\r\\n                expiryTime += TIME_UNIT;\\r\\n            } else {\\r\\n                expiryTime += _pickDay(ledgerType, roundInfo.totalPositionCount) * TIME_UNIT;\\r\\n            }\\r\\n\\r\\n            uint256 nowInvestReturnRate;\\r\\n            if(expiryTime \\u003e= (openTime + 40 * TIME_UNIT)){\\r\\n                nowInvestReturnRate = 10000;\\r\\n            }else if(expiryTime \\u003e= (openTime + 30 * TIME_UNIT)){\\r\\n                nowInvestReturnRate = 9000;\\r\\n            }else if(expiryTime \\u003e= (openTime + 20 * TIME_UNIT)){\\r\\n                nowInvestReturnRate = 8000;\\r\\n            }else if(expiryTime \\u003e= (openTime + 10 * TIME_UNIT)){\\r\\n                nowInvestReturnRate = 7000;\\r\\n            }else if(expiryTime \\u003e= (openTime + 2 * TIME_UNIT)){\\r\\n                nowInvestReturnRate = 6000;\\r\\n            }else{\\r\\n                nowInvestReturnRate = 10000;\\r\\n            }\\r\\n\\r\\n            params.investReturnRate = nowInvestReturnRate;\\r\\n\\r\\n            PositionInfo memory positionInfo = PositionInfo({\\r\\n            amount: amountValue,\\r\\n            openTime: openTime,\\r\\n            expiryTime: expiryTime,\\r\\n            investReturnRate: params.investReturnRate,\\r\\n            withdrawnAmount: 0,\\r\\n            incentiveAmount: 0,\\r\\n            investReturnAmount: 0,\\r\\n            index: userTotalPositionCount,\\r\\n            incentiveClaimable: true,\\r\\n            stopLossTime: 0,\\r\\n            lossAmount: 0,\\r\\n            lossAmountExist: false,\\r\\n            claimableDays: 0,\\r\\n            claimableAmount: 0\\r\\n            });\\r\\n\\r\\n            if(ledgerType == 3 \\u0026\\u0026 userGlobalInfo.rewardAmount \\u003e 0 \\u0026\\u0026 userGlobalInfo.rewardTime + TIME_UNIT \\u003e block.timestamp){\\r\\n                uint256 claimableDays = 40 + _getRandomIndex(currentEpochs[ledgerType],10);\\r\\n                uint256 claimableAmount = claimableDays * userGlobalInfo.rewardAmount * params.investReturnRate / PRICE_PRECISION;\\r\\n                if(claimableAmount \\u003e amountValue){\\r\\n                    claimableAmount = amountValue;\\r\\n                }\\r\\n                positionInfo.stopLossTime = 0;\\r\\n                positionInfo.lossAmount = 0;\\r\\n                positionInfo.lossAmountExist = false;\\r\\n                positionInfo.claimableDays = claimableDays;\\r\\n                positionInfo.claimableAmount = claimableAmount;\\r\\n            }\\r\\n\\r\\n            roundLedgers[ledgerType][targetEpoch][msg.sender].push(positionInfo);\\r\\n        }\\r\\n\\r\\n        _distributeReferrerReward(amountValue, msg.sender, params.referrerAmount);\\r\\n\\r\\n        {\\r\\n\\r\\n            mapping(uint256 =\\u003e LinkedPosition) storage linkedPositions = roundInfo.linkedPositions;\\r\\n\\r\\n            LinkedPosition storage linkedPosition = linkedPositions[roundInfo.totalPositionCount - 1];\\r\\n            linkedPosition.user = msg.sender;\\r\\n            linkedPosition.userPositionIndex = userTotalPositionCount;\\r\\n\\r\\n            if (roundInfo.totalPositionCount - roundInfo.head \\u003e RANKED_INCENTIVE) {\\r\\n\\r\\n                LinkedPosition storage headLinkedPosition = linkedPositions[roundInfo.head];\\r\\n                PositionInfo storage headPositionInfo = roundLedgers[ledgerType][targetEpoch][headLinkedPosition.user][\\r\\n                headLinkedPosition.userPositionIndex\\r\\n                ];\\r\\n\\r\\n                headPositionInfo.incentiveClaimable = false;\\r\\n\\r\\n                roundInfo.incentiveSnapshot -= headPositionInfo.amount;\\r\\n\\r\\n                roundInfo.head += 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit PositionOpened(msg.sender, ledgerType, targetEpoch, userTotalPositionCount, amountValue);\\r\\n\\r\\n        return  params.principalAmount + params.investAmount + params.referrerAmount + params.incentiveAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Close position\\r\\n     * @param ledgerType: Ledger type\\r\\n     * @param epoch: Epoch of the ledger\\r\\n     * @param positionIndex: Position index of the user\\r\\n     */\\r\\n    function closePosition(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        uint256 positionIndex\\r\\n    ) external notContract nonReentrant {\\r\\n        require(ledgerType \\u003c 4, \\\"Invalid ledger type\\\");\\r\\n        require(epoch \\u003c= currentEpochs[ledgerType], \\\"Invalid epoch\\\");\\r\\n\\r\\n        PositionInfo[] storage positionInfos = roundLedgers[ledgerType][epoch][msg.sender];\\r\\n        require(positionIndex \\u003c positionInfos.length, \\\"Invalid position index\\\");\\r\\n\\r\\n        PositionInfo storage positionInfo = positionInfos[positionIndex];\\r\\n\\r\\n        RoundInfo storage roundInfo = roundInfos[ledgerType][epoch];\\r\\n\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\r\\n\\r\\n        _safeClosePosition(ledgerType, epoch, positionIndex, positionInfo, roundInfo, userGlobalInfo);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Close a batch of positions\\r\\n     * @param ledgerType: Ledger type\\r\\n     * @param epoch: Epoch of the ledger\\r\\n     * @param positionIndexes: Position indexes of the user\\r\\n     */\\r\\n    function batchClosePositions(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        uint256[] calldata positionIndexes\\r\\n    ) external nonReentrant {\\r\\n        require(ledgerType \\u003c 4, \\\"Invalid ledger type\\\");\\r\\n        require(epoch \\u003c= currentEpochs[ledgerType], \\\"Invalid epoch\\\");\\r\\n        require(positionIndexes.length \\u003e 0, \\\"Invalid position indexes\\\");\\r\\n\\r\\n        PositionInfo[] storage positionInfos = roundLedgers[ledgerType][epoch][msg.sender];\\r\\n\\r\\n        RoundInfo storage roundInfo = roundInfos[ledgerType][epoch];\\r\\n\\r\\n        PositionInfo storage positionInfo;\\r\\n\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\r\\n\\r\\n        uint256 positionIndexesLength = positionIndexes.length;\\r\\n        uint256 positionInfosLength = positionInfos.length;\\r\\n        for (uint256 i = 0; i \\u003c positionIndexesLength; ++i) {\\r\\n            require(positionIndexes[i] \\u003c positionInfosLength, \\\"Invalid position index\\\");\\r\\n\\r\\n            positionInfo = positionInfos[positionIndexes[i]];\\r\\n            _safeClosePosition(ledgerType, epoch, positionIndexes[i], positionInfo, roundInfo, userGlobalInfo);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Report a batch users\\u0027 sales\\r\\n     * @param users: list of users\\r\\n     */\\r\\n    function batchReportSales(address[] calldata users) external {\\r\\n        uint256 usersLength = users.length;\\r\\n        for (uint256 i = 0; i \\u003c usersLength; ++i) {\\r\\n            _safeReportSales(users[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Claim referrer reward\\r\\n     * @param referrer: referrer address\\r\\n     */\\r\\n    function claimReferrerReward(address referrer) external notContract nonReentrant {\\r\\n        require(referrer != address(0), \\\"Invalid referrer address\\\");\\r\\n\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[referrer];\\r\\n\\r\\n        uint256 claimableAmount = userGlobalInfo.totalReferrerReward - userGlobalInfo.referrerRewardClaimed;\\r\\n\\r\\n        require(claimableAmount \\u003e 0, \\\"No claimable amount\\\");\\r\\n\\r\\n        userGlobalInfo.referrerRewardClaimed += claimableAmount;\\r\\n\\r\\n        {\\r\\n            (bool success, ) = referrer.call{value: claimableAmount}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        }\\r\\n\\r\\n        emit ReferrerRewardClaimed(referrer, claimableAmount);\\r\\n    }\\r\\n\\r\\n    function getUserRounds(\\r\\n        uint256 ledgerType,\\r\\n        address user,\\r\\n        uint256 cursor,\\r\\n        uint256 size\\r\\n    ) external view returns (UserRoundInfo[] memory, uint256) {\\r\\n        uint256 length = size;\\r\\n        uint256 roundCount = userRoundsInfos[ledgerType][user].length;\\r\\n        if (cursor + length \\u003e roundCount) {\\r\\n            length = roundCount - cursor;\\r\\n        }\\r\\n\\r\\n        UserRoundInfo[] memory userRoundInfos = new UserRoundInfo[](length);\\r\\n        for (uint256 i = 0; i \\u003c length; ++i) {\\r\\n            userRoundInfos[i] = userRoundsInfos[ledgerType][user][cursor + i];\\r\\n        }\\r\\n\\r\\n        return (userRoundInfos, cursor + length);\\r\\n    }\\r\\n\\r\\n    function getUserRoundsLength(uint256 ledgerType, address user) external view returns (uint256) {\\r\\n        return userRoundsInfos[ledgerType][user].length;\\r\\n    }\\r\\n\\r\\n    function getUserRoundLedgers(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        address user,\\r\\n        uint256 cursor,\\r\\n        uint256 size\\r\\n    ) external view returns (PositionInfo[] memory, uint256) {\\r\\n        uint256 length = size;\\r\\n        uint256 positionCount = roundLedgers[ledgerType][epoch][user].length;\\r\\n        if (cursor + length \\u003e positionCount) {\\r\\n            length = positionCount - cursor;\\r\\n        }\\r\\n\\r\\n        PositionInfo[] memory positionInfos = new PositionInfo[](length);\\r\\n        for (uint256 i = 0; i \\u003c length; ++i) {\\r\\n            positionInfos[i] = roundLedgers[ledgerType][epoch][user][cursor + i];\\r\\n        }\\r\\n\\r\\n        return (positionInfos, cursor + length);\\r\\n    }\\r\\n\\r\\n    function getUserRoundLedgersLength(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        address user\\r\\n    ) external view returns (uint256) {\\r\\n        return roundLedgers[ledgerType][epoch][user].length;\\r\\n    }\\r\\n\\r\\n    function getChildren(\\r\\n        address user,\\r\\n        uint256 cursor,\\r\\n        uint256 size\\r\\n    ) external view returns (address[] memory, uint256) {\\r\\n        uint256 length = size;\\r\\n        uint256 childrenCount = children[user].length;\\r\\n        if (cursor + length \\u003e childrenCount) {\\r\\n            length = childrenCount - cursor;\\r\\n        }\\r\\n\\r\\n        address[] memory _children = new address[](length);\\r\\n        for (uint256 i = 0; i \\u003c length; ++i) {\\r\\n            _children[i] = children[user][cursor + i];\\r\\n        }\\r\\n\\r\\n        return (_children, cursor + length);\\r\\n    }\\r\\n\\r\\n    function getLedgerRoundToUserRoundIndex(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        address user\\r\\n    ) external view returns (uint256) {\\r\\n        return roundInfos[ledgerType][epoch].ledgerRoundToUserRoundIndex[user];\\r\\n    }\\r\\n\\r\\n    function getChildrenLength(address user) external view returns (uint256) {\\r\\n        return children[user].length;\\r\\n    }\\r\\n\\r\\n    function getUserDepartSalesAndLevel(address user) external view returns (uint256, uint8) {\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[user];\\r\\n        return (userGlobalInfo.sales - userGlobalInfo.maxChildrenSales, userGlobalInfo.salesLevel);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice close a given position\\r\\n     * @param ledgerType: ledger type\\r\\n     * @param epoch: epoch of the ledger\\r\\n     * @param positionIndex: position index of the user\\r\\n     * @param positionInfo: storage of the position info\\r\\n     * @param roundInfo: storage of the round info\\r\\n     */\\r\\n    function _safeClosePosition(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        uint256 positionIndex,\\r\\n        PositionInfo storage positionInfo,\\r\\n        RoundInfo storage roundInfo,\\r\\n        UserGlobalInfo storage userGlobalInfo\\r\\n    ) internal {\\r\\n        require(positionInfo.withdrawnAmount == 0, \\\"Position already claimed\\\");\\r\\n        require(positionInfo.expiryTime \\u003c= block.timestamp || roundInfo.stopLoss, \\\"Position not expired\\\");\\r\\n\\r\\n        uint256 targetRoundInfoIndex = roundInfo.ledgerRoundToUserRoundIndex[msg.sender];\\r\\n        UserRoundInfo storage userRoundInfo = userRoundsInfos[ledgerType][msg.sender][targetRoundInfoIndex];\\r\\n\\r\\n        uint256 payoutAmount;\\r\\n        uint256 principalAmount = (positionInfo.amount * PRINCIPAL_RATIO) / PRICE_PRECISION;\\r\\n\\r\\n        payoutAmount += principalAmount;\\r\\n\\r\\n        roundInfo.currentPositionCount -= 1;\\r\\n        roundInfo.currentPrincipalAmount -= principalAmount;\\r\\n\\r\\n        if (!roundInfo.stopLoss) {\\r\\n\\r\\n            uint256 daysPassed;\\r\\n            daysPassed = (positionInfo.expiryTime - positionInfo.openTime);\\r\\n\\r\\n            uint256 expectedInvestReturnAmount = (positionInfo.amount * positionInfo.investReturnRate * daysPassed) /\\r\\n            PRICE_PRECISION /\\r\\n            TIME_UNIT;\\r\\n\\r\\n            uint256 investReturnAmount = positionInfo.amount - principalAmount + expectedInvestReturnAmount + positionInfo.claimableAmount;\\r\\n\\r\\n            if (epochCurrentInvestAmount[epoch] \\u003c investReturnAmount) {\\r\\n\\r\\n                investReturnAmount = epochCurrentInvestAmount[epoch];\\r\\n                epochCurrentInvestAmount[epoch] = 0;\\r\\n            } else {\\r\\n\\r\\n            unchecked {\\r\\n                epochCurrentInvestAmount[epoch] -= investReturnAmount;\\r\\n            }\\r\\n            }\\r\\n\\r\\n            if (epochCurrentInvestAmount[epoch] == 0) {\\r\\n\\r\\n                roundInfos[0][epoch].stopLoss = true;\\r\\n                roundInfos[1][epoch].stopLoss = true;\\r\\n                roundInfos[2][epoch].stopLoss = true;\\r\\n                roundInfos[3][epoch].stopLoss = true;\\r\\n                currentEpochs[0] += 1;\\r\\n                currentEpochs[1] += 1;\\r\\n                currentEpochs[2] += 1;\\r\\n                currentEpochs[3] += 1;\\r\\n                _refillStock(0);\\r\\n                _refillStock(1);\\r\\n                _refillStock(2);\\r\\n                _refillStock(3);\\r\\n                emit NewRound(currentEpochs[ledgerType], ledgerType);\\r\\n            }\\r\\n\\r\\n            payoutAmount += investReturnAmount;\\r\\n\\r\\n            positionInfo.investReturnAmount = investReturnAmount;\\r\\n        }else{\\r\\n\\r\\n            uint256 tokenAmount = (positionInfo.amount * (PRICE_PRECISION - PRINCIPAL_RATIO)) / PRICE_PRECISION - positionInfo.investReturnAmount;\\r\\n            positionInfo.stopLossTime = block.timestamp;\\r\\n            positionInfo.lossAmount = tokenAmount;\\r\\n            positionInfo.lossAmountExist = true;\\r\\n\\r\\n            if(stopLossAmount \\u003c 900000000 * ACCURACY){\\r\\n                if(tokenAmount \\u003e 0){\\r\\n                    uint256 DPTAmount;\\r\\n                    if(stopLossAmount \\u003c 200000000 * ACCURACY){\\r\\n                        DPTAmount = tokenAmount * 30;\\r\\n                    }else if(stopLossAmount \\u003c 400000000 * ACCURACY){\\r\\n                        DPTAmount = tokenAmount * 10;\\r\\n                    }else if(stopLossAmount \\u003c 600000000 * ACCURACY){\\r\\n                        DPTAmount = tokenAmount * 5;\\r\\n                    }else if(stopLossAmount \\u003c 800000000 * ACCURACY){\\r\\n                        DPTAmount = tokenAmount * 5 / 2;\\r\\n                    }else{\\r\\n                        DPTAmount = tokenAmount;\\r\\n                    }\\r\\n                    AssetPackage[msg.sender].push(AssetPackageInfo({\\r\\n                    birthday: block.timestamp,\\r\\n                    amount: DPTAmount,\\r\\n                    release: DPTAmount / 100,\\r\\n                    withdrawn: 0,\\r\\n                    state: true\\r\\n                    }));\\r\\n                    stopLossAmount += tokenAmount;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 incentiveAmount = 0;\\r\\n\\r\\n        userRoundInfo.totalWithdrawnAmount += payoutAmount;\\r\\n        userRoundInfo.currentPrincipalAmount -= principalAmount;\\r\\n\\r\\n        positionInfo.withdrawnAmount = payoutAmount;\\r\\n\\r\\n        if (payoutAmount - incentiveAmount \\u003c positionInfo.amount) {\\r\\n            userGlobalInfo.boostCredit += positionInfo.amount;\\r\\n        }\\r\\n\\r\\n        {\\r\\n            (bool success, ) = msg.sender.call{value: payoutAmount}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        }\\r\\n\\r\\n        emit PositionClosed(msg.sender, ledgerType, epoch, positionIndex, payoutAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice process user\\u0027s level info and return the current level\\r\\n     * @param currentLevel: user current level\\r\\n     * @param user: user address\\r\\n     * @param currentSales: user current sales\\r\\n     * @param userGlobalInfo: storage of the user global info\\r\\n     */\\r\\n    function _safeProcessSalesLevel(\\r\\n        uint8 currentLevel,\\r\\n        address user,\\r\\n        uint256 currentSales,\\r\\n        UserGlobalInfo storage userGlobalInfo\\r\\n    ) internal returns (uint8) {\\r\\n        uint8 newLevel = _getSalesToLevel(currentSales);\\r\\n        if (newLevel \\u003e currentLevel) {\\r\\n            userGlobalInfo.salesLevel = newLevel;\\r\\n            emit SalesLevelUpdated(user, newLevel);\\r\\n        } else {\\r\\n            newLevel = currentLevel;\\r\\n        }\\r\\n        return newLevel;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice report user\\u0027s sales and update its referrer sales level\\r\\n     * @param user: user address\\r\\n     */\\r\\n    function _safeReportSales(address user) internal {\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[user];\\r\\n        address referrer = userGlobalInfo.referrer;\\r\\n        uint256 userSales = userGlobalInfo.sales;\\r\\n        uint256 userReportedSales = userGlobalInfo.reportedSales;\\r\\n\\r\\n        uint256 unreportedSales = userSales - userReportedSales;\\r\\n\\r\\n        if (unreportedSales \\u003e 0) {\\r\\n\\r\\n            UserGlobalInfo storage referrerGlobalInfo = userGlobalInfos[referrer];\\r\\n\\r\\n            referrerGlobalInfo.sales += unreportedSales;\\r\\n\\r\\n            userGlobalInfo.reportedSales = userSales;\\r\\n\\r\\n            userSales += userGlobalInfo.totalPositionAmount;\\r\\n\\r\\n            uint256 maxChildrenSales = referrerGlobalInfo.maxChildrenSales;\\r\\n\\r\\n            if (userSales \\u003e maxChildrenSales) {\\r\\n\\r\\n                referrerGlobalInfo.maxChildrenSales = userSales;\\r\\n\\r\\n                maxChildrenSales = userSales;\\r\\n            }\\r\\n\\r\\n            _safeProcessSalesLevel(\\r\\n                referrerGlobalInfo.salesLevel,\\r\\n                referrer,\\r\\n                referrerGlobalInfo.sales - maxChildrenSales,\\r\\n                referrerGlobalInfo\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice distribute referrer reward\\r\\n     * @param user: user address\\r\\n     * @param referrerAmount: total amount of referrer reward\\r\\n     */\\r\\n    function _distributeReferrerReward(uint256 amountValue, address user, uint256 referrerAmount) internal virtual {\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[user];\\r\\n        UserGlobalInfo storage referrerGlobalInfo;\\r\\n        uint256 positionAmount = amountValue;\\r\\n\\r\\n        ReferrerSearch memory search;\\r\\n        search.baseSalesLevel = 0;\\r\\n        search.currentReferrer = userGlobalInfo.referrer;\\r\\n        search.levelDiffAmount = referrerAmount;\\r\\n        search.leftLevelDiffAmount = search.levelDiffAmount;\\r\\n        search.levelDiffAmountPerLevel = search.levelDiffAmount / 10;\\r\\n        search.levelSearchAmount = referrerAmount - search.levelDiffAmount;\\r\\n        search.leftLevelSearchAmount = search.levelSearchAmount;\\r\\n        search.levelSearchAmountPerReferrer = search.levelSearchAmount / 10;\\r\\n        search.currentUserTotalPosAmount = userGlobalInfo.totalPositionAmount + positionAmount;\\r\\n        userGlobalInfo.totalPositionAmount = search.currentUserTotalPosAmount;\\r\\n        search.currentUser = user;\\r\\n\\r\\n        while (search.depth \\u003c MAX_SEARCH_DEPTH) {\\r\\n\\r\\n            if (search.currentReferrer == address(0)) {\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            if (search.depth \\u003e 0) userGlobalInfo.reportedSales += positionAmount;\\r\\n\\r\\n            search.currentUserSales = userGlobalInfo.sales;\\r\\n            search.currentUserReportedSales = userGlobalInfo.reportedSales;\\r\\n\\r\\n            referrerGlobalInfo = userGlobalInfos[search.currentReferrer];\\r\\n\\r\\n            {\\r\\n                search.currentReferrerSales = referrerGlobalInfo.sales;\\r\\n\\r\\n                search.currentReferrerSales += positionAmount;\\r\\n\\r\\n                if (search.currentUserReportedSales \\u003c search.currentUserSales) {\\r\\n\\r\\n                    search.currentReferrerSales += search.currentUserSales - search.currentUserReportedSales;\\r\\n\\r\\n                    userGlobalInfo.reportedSales = search.currentUserSales;\\r\\n                }\\r\\n\\r\\n                referrerGlobalInfo.sales = search.currentReferrerSales;\\r\\n            }\\r\\n\\r\\n            {\\r\\n\\r\\n                search.currentUserSales += search.currentUserTotalPosAmount;\\r\\n\\r\\n                search.currentReferrerMaxChildSales = referrerGlobalInfo.maxChildrenSales;\\r\\n                if (search.currentReferrerMaxChildSales \\u003c search.currentUserSales) {\\r\\n\\r\\n                    referrerGlobalInfo.maxChildrenSales = search.currentUserSales;\\r\\n                    search.currentReferrerMaxChildSales = search.currentUserSales;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            search.currentReferrerLevel = _safeProcessSalesLevel(\\r\\n                referrerGlobalInfo.salesLevel,\\r\\n                search.currentReferrer,\\r\\n                search.currentReferrerSales - search.currentReferrerMaxChildSales,\\r\\n                referrerGlobalInfo\\r\\n            );\\r\\n\\r\\n            if (!search.levelDiffDone) {\\r\\n\\r\\n                if (search.currentReferrerLevel \\u003e search.baseSalesLevel) {\\r\\n\\r\\n                    search.currentLevelDiff = search.currentReferrerLevel - search.baseSalesLevel;\\r\\n\\r\\n                    search.baseSalesLevel = search.currentReferrerLevel;\\r\\n\\r\\n                    search.currentReferrerAmount = search.currentLevelDiff * search.levelDiffAmountPerLevel;\\r\\n\\r\\n                    if (search.currentReferrerAmount + PRICE_PRECISION \\u003e search.leftLevelDiffAmount) {\\r\\n                        search.currentReferrerAmount = search.leftLevelDiffAmount;\\r\\n                    }\\r\\n\\r\\n                    referrerGlobalInfo.totalReferrerReward += search.currentReferrerAmount;\\r\\n                    emit ReferrerRewardAdded(search.currentReferrer, search.currentReferrerAmount, 0);\\r\\n\\r\\n                unchecked {\\r\\n                    search.leftLevelDiffAmount -= search.currentReferrerAmount;\\r\\n                }\\r\\n\\r\\n                    if (search.leftLevelDiffAmount == 0) {\\r\\n                        search.levelDiffDone = true;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            search.currentUser = search.currentReferrer;\\r\\n            search.currentReferrer = referrerGlobalInfo.referrer;\\r\\n\\r\\n            userGlobalInfo = referrerGlobalInfo;\\r\\n            search.currentUserTotalPosAmount = userGlobalInfo.totalPositionAmount;\\r\\n\\r\\n        unchecked {\\r\\n            search.depth += 1;\\r\\n        }\\r\\n        }\\r\\n\\r\\n        if (search.leftLevelDiffAmount \\u003e 0) {\\r\\n            userGlobalInfos[user].totalReferrerReward += search.leftLevelDiffAmount;\\r\\n            emit ReferrerRewardAdded(user, search.leftLevelDiffAmount, 0);\\r\\n        }\\r\\n        if (search.leftLevelSearchAmount \\u003e 0) {\\r\\n            userGlobalInfos[user].totalReferrerReward += search.leftLevelSearchAmount;\\r\\n            emit ReferrerRewardAdded(user, search.leftLevelSearchAmount, 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice get sales level from sales amount\\r\\n     * @param amount: sales amount\\r\\n     */\\r\\n    function _getSalesToLevel(uint256 amount) internal view virtual returns (uint8) {\\r\\n        /* istanbul ignore else  */\\r\\n        if (amount \\u003c levelSales[0]) {\\r\\n            return 0;\\r\\n        } else if (amount \\u003c levelSales[1]) {\\r\\n            return 1;\\r\\n        } else if (amount \\u003c levelSales[2]) {\\r\\n            return 2;\\r\\n        } else if (amount \\u003c levelSales[3]) {\\r\\n            return 3;\\r\\n        } else if (amount \\u003c levelSales[4]) {\\r\\n            return 4;\\r\\n        } else if (amount \\u003c levelSales[5]) {\\r\\n            return 5;\\r\\n        } else if (amount \\u003c levelSales[6]) {\\r\\n            return 6;\\r\\n        } else if (amount \\u003c levelSales[7]) {\\r\\n            return 7;\\r\\n        } else if (amount \\u003c levelSales[8]) {\\r\\n            return 8;\\r\\n        } else if (amount \\u003c levelSales[9]) {\\r\\n            return 9;\\r\\n        }\\r\\n        return 10;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice level search step from level\\r\\n     * @param level: sales level (0-10)\\r\\n     */\\r\\n    function _getLevelToLevelSearchStep(uint8 level) internal pure returns (uint8) {\\r\\n    unchecked {\\r\\n        if (level \\u003c 5) return level * 2;\\r\\n    }\\r\\n        return 10;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function getWithdrawalAmount(\\r\\n        address Addr\\r\\n    ) external view returns (uint256){\\r\\n        AssetPackageInfo[] memory assetPackageArr = AssetPackage[Addr];\\r\\n        uint256 amount;\\r\\n        if(assetPackageArr.length \\u003e 0){\\r\\n            for(uint256 i = 0; i \\u003c assetPackageArr.length; i++){\\r\\n                AssetPackageInfo memory ap = assetPackageArr[i];\\r\\n                if(ap.withdrawn \\u003c ap.amount){\\r\\n                    uint256 dayPassed = (block.timestamp - ap.birthday) / TIME_UNIT;\\r\\n                    uint256 reward = dayPassed * ap.release;\\r\\n                    if ((reward + ap.withdrawn) \\u003e ap.amount){\\r\\n                        reward = ap.amount - ap.withdrawn;\\r\\n                    }\\r\\n                    amount += reward;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return (amount);\\r\\n    }\\r\\n\\r\\n    function withdrawalDPT() external {\\r\\n        AssetPackageInfo[] storage assetPackageArr = AssetPackage[msg.sender];\\r\\n        uint256 amount;\\r\\n        if(assetPackageArr.length \\u003e 0){\\r\\n            for(uint256 i = 0; i \\u003c assetPackageArr.length; i++){\\r\\n                AssetPackageInfo storage ap = assetPackageArr[i];\\r\\n                if(ap.withdrawn \\u003c ap.amount){\\r\\n                    uint256 dayPassed = (block.timestamp - ap.birthday) / TIME_UNIT;\\r\\n                    uint256 reward = dayPassed * ap.release;\\r\\n                    if ((reward + ap.withdrawn) \\u003e ap.amount){\\r\\n                        reward = ap.amount - ap.withdrawn;\\r\\n                        ap.state = false;\\r\\n                    }\\r\\n                    ap.birthday += dayPassed * TIME_UNIT;\\r\\n                    amount += reward;\\r\\n                    ap.withdrawn += reward;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if(amount \\u003e 0){\\r\\n            require(IERC20(tokenAddress).balanceOf(address(this)) \\u003e= amount, \\\"Insufficient number of Tokens\\\");\\r\\n            IERC20EX(tokenAddress)._mint(msg.sender, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addLiquitidyWithId(\\r\\n        uint256 tokenAmount,\\r\\n        uint256 maticAmount\\r\\n    ) internal {\\r\\n        (uint amount0, uint amount1) = tokenAddress \\u003e maticAddress\\r\\n        ? (maticAmount, tokenAmount)\\r\\n        : (tokenAmount, maticAmount);\\r\\n        positionManager.increaseLiquidity{value: maticAmount}(\\r\\n            INonfungiblePositionManager.IncreaseLiquidityParams({\\r\\n        tokenId: positionId,\\r\\n        amount0Desired: amount0,\\r\\n        amount1Desired: amount1,\\r\\n        amount0Min: 0,\\r\\n        amount1Min: 0,\\r\\n        deadline: block.timestamp\\r\\n        })\\r\\n        );\\r\\n        positionManager.refundETH();\\r\\n    }\\r\\n\\r\\n    function buyBurn(\\r\\n        uint256 amountIn\\r\\n    ) internal {\\r\\n        router.exactInputSingle{value: amountIn}(\\r\\n            IV3SwapRouter.ExactInputSingleParams({\\r\\n        tokenIn: maticAddress,\\r\\n        tokenOut: tokenAddress,\\r\\n        fee: defaultFee,\\r\\n        recipient: address(this),\\r\\n        amountIn: amountIn,\\r\\n        amountOutMinimum: 0,\\r\\n        sqrtPriceLimitX96: 0\\r\\n        })\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _tokenAllocation(IERC20 _ERC20, address _address, uint256 _amount) external {\\r\\n        require(msg.sender == platformAddress, \\\"Only platformAddress\\\");\\r\\n        _ERC20.transfer(_address, _amount);\\r\\n    }\\r\\n\\r\\n    function withdrawEth(address to, uint256 value) external {\\r\\n        require(msg.sender == platformAddress, \\\"Only platformAddress\\\");\\r\\n        payable(to).transfer(value);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\"},\"INonfungiblePositionManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.8.0;\\r\\ninterface INonfungiblePositionManager\\r\\n{\\r\\n    function positions(uint256 tokenId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n        uint96 nonce,\\r\\n        address operator,\\r\\n        address token0,\\r\\n        address token1,\\r\\n        uint24 fee,\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 liquidity,\\r\\n        uint256 feeGrowthInside0LastX128,\\r\\n        uint256 feeGrowthInside1LastX128,\\r\\n        uint128 tokensOwed0,\\r\\n        uint128 tokensOwed1\\r\\n    );\\r\\n    struct IncreaseLiquidityParams {\\r\\n        uint256 tokenId;\\r\\n        uint256 amount0Desired;\\r\\n        uint256 amount1Desired;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\\r\\n    external\\r\\n    payable\\r\\n    returns (\\r\\n        uint128 liquidity,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1\\r\\n    );\\r\\n    function refundETH() external payable;\\r\\n}\"},\"IV3SwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.8.0;\\r\\ninterface IV3SwapRouter  {\\r\\n    struct ExactInputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_platformAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tempAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquity\",\"type\":\"uint256\"}],\"name\":\"AddLiquityEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"IncentiveClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"NewReferrer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ledgeType\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ledgeType\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PositionClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ledgeType\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PositionOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewardType\",\"type\":\"uint256\"}],\"name\":\"ReferrerRewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferrerRewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"SalesLevelUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ACCURACY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"AssetPackage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"birthday\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"release\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUYBACK_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_INVEST_RETURN_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INVEST_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_INVEST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SEARCH_DEPTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_INVEST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRINCIPAL_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RANKED_INCENTIVE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RECOMMENDREWARD_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRER_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPERNODE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_UNIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_ERC20\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_tokenAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"positionIndexes\",\"type\":\"uint256[]\"}],\"name\":\"batchClosePositions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"batchReportSales\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referrers\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"salesLevels\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8[]\",\"name\":\"supernodes\",\"type\":\"uint8[]\"},{\"internalType\":\"address[]\",\"name\":\"supernodeAddresss\",\"type\":\"address[]\"}],\"name\":\"batchSetReferrerInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"children\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"claimReferrerReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"}],\"name\":\"closePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentEpochs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropTempAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochCurrentInvestAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"}],\"name\":\"getBucketInfo\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getChildren\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getChildrenLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLedgerRoundToUserRoundIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserDepartSalesAndLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getUserRoundLedgers\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"incentiveClaimable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"stopLossTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lossAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"lossAmountExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"claimableDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimableAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct DistrictPower.PositionInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserRoundLedgersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getUserRounds\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalIncentiveClaimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClosedPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returnRateBoostedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct DistrictPower.UserRoundInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserRoundsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Addr\",\"type\":\"address\"}],\"name\":\"getWithdrawalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ledgerBucketStock\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"currentBucketStock\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"stockSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpMaticAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpMaticLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maticAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"openPosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"positionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastCheckTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"achievedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct DistrictPower.FundTarget\",\"name\":\"fundTarget\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentInvestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentIncentiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"head\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stopLoss\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundLedgers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"incentiveClaimable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"stopLossTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lossAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"lossAmountExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"claimableDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimableAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startUseTokenNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopLossAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tempAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalAmountMagicBox\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFlowAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalFlowAmountThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"transferOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userGlobalInfos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalReferrerReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerRewardClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boostCredit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxChildrenSales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reportedSales\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"salesLevel\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"supernode\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"supernodeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userRoundsInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalIncentiveClaimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClosedPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returnRateBoostedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalDPT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DistrictPower", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000689be073d18dd4d8c9edc1c2baae9e058295919f000000000000000000000000689be073d18dd4d8c9edc1c2baae9e058295919f000000000000000000000000689be073d18dd4d8c9edc1c2baae9e058295919f", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e20a9a412f29c06dfca8b32b674aa3e65ee973df7d80492dc82479c8a821897a"}