{"SourceCode": "# @version 0.2.12\r\n\"\"\"\r\n@title Curve aPool for use on Polygon\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020 - all rights reserved\r\n@notice Pool implementation with aToken-style lending\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface LendingPool:\r\n    def withdraw(_underlying_asset: address, _amount: uint256, _receiver: address): nonpayable\r\n\r\ninterface CurveToken:\r\n    def mint(_to: address, _value: uint256) -> bool: nonpayable\r\n    def burnFrom(_to: address, _value: uint256) -> bool: nonpayable\r\n\r\n\r\n# Events\r\nevent TokenExchange:\r\n    buyer: indexed(address)\r\n    sold_id: int128\r\n    tokens_sold: uint256\r\n    bought_id: int128\r\n    tokens_bought: uint256\r\n\r\nevent TokenExchangeUnderlying:\r\n    buyer: indexed(address)\r\n    sold_id: int128\r\n    tokens_sold: uint256\r\n    bought_id: int128\r\n    tokens_bought: uint256\r\n\r\nevent AddLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: uint256[N_COINS]\r\n    fees: uint256[N_COINS]\r\n    invariant: uint256\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: uint256[N_COINS]\r\n    fees: uint256[N_COINS]\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidityOne:\r\n    provider: indexed(address)\r\n    token_amount: uint256\r\n    coin_amount: uint256\r\n\r\nevent RemoveLiquidityImbalance:\r\n    provider: indexed(address)\r\n    token_amounts: uint256[N_COINS]\r\n    fees: uint256[N_COINS]\r\n    invariant: uint256\r\n    token_supply: uint256\r\n\r\nevent CommitNewAdmin:\r\n    deadline: indexed(uint256)\r\n    admin: indexed(address)\r\n\r\nevent NewAdmin:\r\n    admin: indexed(address)\r\n\r\nevent CommitNewFee:\r\n    deadline: indexed(uint256)\r\n    fee: uint256\r\n    admin_fee: uint256\r\n    offpeg_fee_multiplier: uint256\r\n\r\nevent NewFee:\r\n    fee: uint256\r\n    admin_fee: uint256\r\n    offpeg_fee_multiplier: uint256\r\n\r\nevent RampA:\r\n    old_A: uint256\r\n    new_A: uint256\r\n    initial_time: uint256\r\n    future_time: uint256\r\n\r\nevent StopRampA:\r\n    A: uint256\r\n    t: uint256\r\n\r\n\r\nN_COINS: constant(int128) = 3\r\nPRECISION_MUL: constant(uint256[N_COINS]) = [1, 1000000000000, 1000000000000]\r\nPRECISION: constant(uint256) = 10 ** 18\r\n\r\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\r\nMAX_ADMIN_FEE: constant(uint256) = 10 * 10 ** 9\r\nMAX_FEE: constant(uint256) = 5 * 10 ** 9\r\n\r\nMAX_A: constant(uint256) = 10 ** 6\r\nMAX_A_CHANGE: constant(uint256) = 10\r\nA_PRECISION: constant(uint256) = 100\r\n\r\nADMIN_ACTIONS_DELAY: constant(uint256) = 3 * 86400\r\nMIN_RAMP_TIME: constant(uint256) = 86400\r\n\r\nMATIC_REWARDS: constant(address) = 0x357D51124f59836DeD84c8a1730D72B749d8BC23\r\nAAVE_LENDING_POOL: constant(address) = 0x8dFf5E27EA6b7AC08EbFdf9eB090F32ee9a30fcf\r\nWMATIC: constant(address) = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\r\n\r\ncoins: public(address[N_COINS])\r\nunderlying_coins: public(address[N_COINS])\r\nadmin_balances: public(uint256[N_COINS])\r\n\r\nfee: public(uint256)  # fee * 1e10\r\noffpeg_fee_multiplier: public(uint256)  # * 1e10\r\nadmin_fee: public(uint256)  # admin_fee * 1e10\r\n\r\nowner: public(address)\r\nlp_token: public(address)\r\n\r\naave_lending_pool: address\r\naave_referral: uint256\r\n\r\ninitial_A: public(uint256)\r\nfuture_A: public(uint256)\r\ninitial_A_time: public(uint256)\r\nfuture_A_time: public(uint256)\r\n\r\nadmin_actions_deadline: public(uint256)\r\ntransfer_ownership_deadline: public(uint256)\r\nfuture_fee: public(uint256)\r\nfuture_admin_fee: public(uint256)\r\nfuture_offpeg_fee_multiplier: public(uint256)  # * 1e10\r\nfuture_owner: public(address)\r\n\r\nis_killed: bool\r\nkill_deadline: uint256\r\nKILL_DEADLINE_DT: constant(uint256) = 2 * 30 * 86400\r\n\r\nreward_receiver: public(address)\r\nadmin_fee_receiver: public(address)\r\n\r\n@external\r\ndef __init__(\r\n    _coins: address[N_COINS],\r\n    _underlying_coins: address[N_COINS],\r\n    _pool_token: address,\r\n    _A: uint256,\r\n    _fee: uint256,\r\n    _admin_fee: uint256,\r\n    _offpeg_fee_multiplier: uint256,\r\n):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _coins List of wrapped coin addresses\r\n    @param _underlying_coins List of underlying coin addresses\r\n    @param _pool_token Pool LP token address\r\n    @param _A Amplification coefficient multiplied by n * (n - 1)\r\n    @param _fee Swap fee expressed as an integer with 1e10 precision\r\n    @param _admin_fee Percentage of fee taken as an admin fee,\r\n                      expressed as an integer with 1e10 precision\r\n    @param _offpeg_fee_multiplier Offpeg fee multiplier\r\n    \"\"\"\r\n    for i in range(N_COINS):\r\n        assert _coins[i] != ZERO_ADDRESS\r\n        assert _underlying_coins[i] != ZERO_ADDRESS\r\n\r\n    self.coins = _coins\r\n    self.underlying_coins = _underlying_coins\r\n    self.initial_A = _A * A_PRECISION\r\n    self.future_A = _A * A_PRECISION\r\n    self.fee = _fee\r\n    self.admin_fee = _admin_fee\r\n    self.offpeg_fee_multiplier = _offpeg_fee_multiplier\r\n    self.owner = msg.sender\r\n    self.admin_fee_receiver = msg.sender\r\n    self.kill_deadline = block.timestamp + KILL_DEADLINE_DT\r\n    self.lp_token = _pool_token\r\n\r\n    # approve transfer of underlying coin to aave lending pool\r\n    for coin in _underlying_coins:\r\n        _response: Bytes[32] = raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(AAVE_LENDING_POOL, bytes32),\r\n                convert(MAX_UINT256, bytes32)\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(_response) != 0:\r\n            assert convert(_response, bool)\r\n\r\n\r\n@view\r\n@internal\r\ndef _A() -> uint256:\r\n    t1: uint256 = self.future_A_time\r\n    A1: uint256 = self.future_A\r\n\r\n    if block.timestamp < t1:\r\n        # handle ramping up and down of A\r\n        A0: uint256 = self.initial_A\r\n        t0: uint256 = self.initial_A_time\r\n        # Expressions in uint256 cannot have negative numbers, thus \"if\"\r\n        if A1 > A0:\r\n            return A0 + (A1 - A0) * (block.timestamp - t0) / (t1 - t0)\r\n        else:\r\n            return A0 - (A0 - A1) * (block.timestamp - t0) / (t1 - t0)\r\n\r\n    else:  # when t1 == 0 or block.timestamp >= t1\r\n        return A1\r\n\r\n\r\n@view\r\n@external\r\ndef A() -> uint256:\r\n    return self._A() / A_PRECISION\r\n\r\n\r\n@view\r\n@external\r\ndef A_precise() -> uint256:\r\n    return self._A()\r\n\r\n\r\n@pure\r\n@internal\r\ndef _dynamic_fee(xpi: uint256, xpj: uint256, _fee: uint256, _feemul: uint256) -> uint256:\r\n    if _feemul <= FEE_DENOMINATOR:\r\n        return _fee\r\n    else:\r\n        xps2: uint256 = (xpi + xpj)\r\n        xps2 *= xps2  # Doing just ** 2 can overflow apparently\r\n        return (_feemul * _fee) / (\r\n            (_feemul - FEE_DENOMINATOR) * 4 * xpi * xpj / xps2 + \\\r\n            FEE_DENOMINATOR)\r\n\r\n\r\n@view\r\n@external\r\ndef dynamic_fee(i: int128, j: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Return the fee for swapping between `i` and `j`\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to recieve\r\n    @return Swap fee expressed as an integer with 1e10 precision\r\n    \"\"\"\r\n    precisions: uint256[N_COINS] = PRECISION_MUL\r\n    xpi: uint256 = (ERC20(self.coins[i]).balanceOf(self) - self.admin_balances[i]) * precisions[i]\r\n    xpj: uint256 = (ERC20(self.coins[j]).balanceOf(self) - self.admin_balances[j]) * precisions[j]\r\n    return self._dynamic_fee(xpi, xpj, self.fee, self.offpeg_fee_multiplier)\r\n\r\n\r\n@view\r\n@external\r\ndef balances(i: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current balance of a coin within the\r\n            pool, less the accrued admin fees\r\n    @param i Index value for the coin to query balance of\r\n    @return Token balance\r\n    \"\"\"\r\n    return ERC20(self.coins[i]).balanceOf(self) - self.admin_balances[i]\r\n\r\n\r\n@view\r\n@internal\r\ndef _balances() -> uint256[N_COINS]:\r\n    result: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    for i in range(N_COINS):\r\n        result[i] = ERC20(self.coins[i]).balanceOf(self) - self.admin_balances[i]\r\n    return result\r\n\r\n\r\n@pure\r\n@internal\r\ndef get_D(xp: uint256[N_COINS], amp: uint256) -> uint256:\r\n    \"\"\"\r\n    D invariant calculation in non-overflowing integer operations\r\n    iteratively\r\n\r\n    A * sum(x_i) * n**n + D = A * D * n**n + D**(n+1) / (n**n * prod(x_i))\r\n\r\n    Converging solution:\r\n    D[j+1] = (A * n**n * sum(x_i) - D[j]**(n+1) / (n**n prod(x_i))) / (A * n**n - 1)\r\n    \"\"\"\r\n    S: uint256 = 0\r\n\r\n    for _x in xp:\r\n        S += _x\r\n    if S == 0:\r\n        return 0\r\n\r\n    Dprev: uint256 = 0\r\n    D: uint256 = S\r\n    Ann: uint256 = amp * N_COINS\r\n    for _i in range(255):\r\n        D_P: uint256 = D\r\n        for _x in xp:\r\n            D_P = D_P * D / (_x * N_COINS + 1)  # +1 is to prevent /0\r\n        Dprev = D\r\n        D = (Ann * S / A_PRECISION + D_P * N_COINS) * D / ((Ann - A_PRECISION) * D / A_PRECISION + (N_COINS + 1) * D_P)\r\n        # Equality with the precision of 1\r\n        if D > Dprev:\r\n            if D - Dprev <= 1:\r\n                return D\r\n        else:\r\n            if Dprev - D <= 1:\r\n                return D\r\n    # convergence typically occurs in 4 rounds or less, this should be unreachable!\r\n    # if it does happen the pool is borked and LPs can withdraw via `remove_liquidity`\r\n    raise\r\n\r\n\r\n\r\n@view\r\n@internal\r\ndef get_D_precisions(coin_balances: uint256[N_COINS], amp: uint256) -> uint256:\r\n    xp: uint256[N_COINS] = PRECISION_MUL\r\n    for i in range(N_COINS):\r\n        xp[i] *= coin_balances[i]\r\n    return self.get_D(xp, amp)\r\n\r\n\r\n@view\r\n@external\r\ndef get_virtual_price() -> uint256:\r\n    \"\"\"\r\n    @notice The current virtual price of the pool LP token\r\n    @dev Useful for calculating profits\r\n    @return LP token virtual price normalized to 1e18\r\n    \"\"\"\r\n    D: uint256 = self.get_D_precisions(self._balances(), self._A())\r\n    # D is in the units similar to DAI (e.g. converted to precision 1e18)\r\n    # When balanced, D = n * x_u - total virtual value of the portfolio\r\n    token_supply: uint256 = ERC20(self.lp_token).totalSupply()\r\n    return D * PRECISION / token_supply\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(_amounts: uint256[N_COINS], is_deposit: bool) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate addition or reduction in token supply from a deposit or withdrawal\r\n    @dev This calculation accounts for slippage, but not fees.\r\n         Needed to prevent front-running, not for precise calculations!\r\n    @param _amounts Amount of each coin being deposited\r\n    @param is_deposit set True for deposits, False for withdrawals\r\n    @return Expected amount of LP tokens received\r\n    \"\"\"\r\n    coin_balances: uint256[N_COINS] = self._balances()\r\n    amp: uint256 = self._A()\r\n    D0: uint256 = self.get_D_precisions(coin_balances, amp)\r\n    for i in range(N_COINS):\r\n        if is_deposit:\r\n            coin_balances[i] += _amounts[i]\r\n        else:\r\n            coin_balances[i] -= _amounts[i]\r\n    D1: uint256 = self.get_D_precisions(coin_balances, amp)\r\n    token_amount: uint256 = ERC20(self.lp_token).totalSupply()\r\n    diff: uint256 = 0\r\n    if is_deposit:\r\n        diff = D1 - D0\r\n    else:\r\n        diff = D0 - D1\r\n    return diff * token_amount / D0\r\n\r\n\r\n@internal\r\ndef _claim_rewards():\r\n    # push wMatic rewards into the reward receiver\r\n    reward_receiver: address = self.reward_receiver\r\n    if reward_receiver != ZERO_ADDRESS:\r\n        response: Bytes[32] = raw_call(\r\n            MATIC_REWARDS,\r\n            concat(\r\n                method_id(\"claimRewards(address[],uint256,address)\"),\r\n                convert(32 * 3, bytes32),\r\n                convert(MAX_UINT256, bytes32),\r\n                convert(self, bytes32),\r\n                convert(3, bytes32),\r\n                convert(self.coins[0], bytes32),\r\n                convert(self.coins[1], bytes32),\r\n                convert(self.coins[2], bytes32),\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        amount: uint256 = convert(response, uint256)\r\n        if amount > 0:\r\n            assert ERC20(WMATIC).transfer(reward_receiver, amount)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef add_liquidity(_amounts: uint256[N_COINS], _min_mint_amount: uint256, _use_underlying: bool = False) -> uint256:\r\n    \"\"\"\r\n    @notice Deposit coins into the pool\r\n    @param _amounts List of amounts of coins to deposit\r\n    @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit\r\n    @param _use_underlying If True, deposit underlying assets instead of aTokens\r\n    @return Amount of LP tokens received by depositing\r\n    \"\"\"\r\n\r\n    assert not self.is_killed  # dev: is killed\r\n    self._claim_rewards()\r\n\r\n    # Initial invariant\r\n    amp: uint256 = self._A()\r\n    old_balances: uint256[N_COINS] = self._balances()\r\n    lp_token: address = self.lp_token\r\n    token_supply: uint256 = ERC20(lp_token).totalSupply()\r\n    D0: uint256 = 0\r\n    if token_supply != 0:\r\n        D0 = self.get_D_precisions(old_balances, amp)\r\n\r\n    new_balances: uint256[N_COINS] = old_balances\r\n    for i in range(N_COINS):\r\n        if token_supply == 0:\r\n            assert _amounts[i] != 0  # dev: initial deposit requires all coins\r\n        new_balances[i] += _amounts[i]\r\n\r\n    # Invariant after change\r\n    D1: uint256 = self.get_D_precisions(new_balances, amp)\r\n    assert D1 > D0\r\n\r\n    # We need to recalculate the invariant accounting for fees\r\n    # to calculate fair user's share\r\n    fees: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    mint_amount: uint256 = 0\r\n    if token_supply != 0:\r\n        # Only account for fees if we are not the first to deposit\r\n        ys: uint256 = (D0 + D1) / N_COINS\r\n        _fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\r\n        _feemul: uint256 = self.offpeg_fee_multiplier\r\n        _admin_fee: uint256 = self.admin_fee\r\n        difference: uint256 = 0\r\n        for i in range(N_COINS):\r\n            ideal_balance: uint256 = D1 * old_balances[i] / D0\r\n            new_balance: uint256 = new_balances[i]\r\n            if ideal_balance > new_balance:\r\n                difference = ideal_balance - new_balance\r\n            else:\r\n                difference = new_balance - ideal_balance\r\n            xs: uint256 = old_balances[i] + new_balance\r\n            fees[i] = self._dynamic_fee(xs, ys, _fee, _feemul) * difference / FEE_DENOMINATOR\r\n            if _admin_fee != 0:\r\n                self.admin_balances[i] += fees[i] * _admin_fee / FEE_DENOMINATOR\r\n            new_balances[i] = new_balance - fees[i]\r\n        D2: uint256 = self.get_D_precisions(new_balances, amp)\r\n        mint_amount = token_supply * (D2 - D0) / D0\r\n    else:\r\n        mint_amount = D1  # Take the dust if there was any\r\n\r\n    assert mint_amount >= _min_mint_amount, \"Slippage screwed you\"\r\n\r\n    # Take coins from the sender\r\n    if _use_underlying:\r\n        aave_referral: bytes32 = convert(self.aave_referral, bytes32)\r\n\r\n        # Take coins from the sender\r\n        for i in range(N_COINS):\r\n            amount: uint256 = _amounts[i]\r\n            if amount != 0:\r\n                coin: address = self.underlying_coins[i]\r\n                # transfer underlying coin from msg.sender to self\r\n                _response: Bytes[32] = raw_call(\r\n                    coin,\r\n                    concat(\r\n                        method_id(\"transferFrom(address,address,uint256)\"),\r\n                        convert(msg.sender, bytes32),\r\n                        convert(self, bytes32),\r\n                        convert(amount, bytes32)\r\n                    ),\r\n                    max_outsize=32\r\n                )\r\n                if len(_response) != 0:\r\n                    assert convert(_response, bool)\r\n\r\n                # deposit to aave lending pool\r\n                raw_call(\r\n                    AAVE_LENDING_POOL,\r\n                    concat(\r\n                        method_id(\"deposit(address,uint256,address,uint16)\"),\r\n                        convert(coin, bytes32),\r\n                        convert(amount, bytes32),\r\n                        convert(self, bytes32),\r\n                        aave_referral,\r\n                    )\r\n                )\r\n    else:\r\n        for i in range(N_COINS):\r\n            amount: uint256 = _amounts[i]\r\n            if amount != 0:\r\n                assert ERC20(self.coins[i]).transferFrom(msg.sender, self, amount) # dev: failed transfer\r\n\r\n    # Mint pool tokens\r\n    CurveToken(lp_token).mint(msg.sender, mint_amount)\r\n\r\n    log AddLiquidity(msg.sender, _amounts, fees, D1, token_supply + mint_amount)\r\n\r\n    return mint_amount\r\n\r\n\r\n@view\r\n@internal\r\ndef get_y(i: int128, j: int128, x: uint256, xp: uint256[N_COINS]) -> uint256:\r\n    \"\"\"\r\n    Calculate x[j] if one makes x[i] = x\r\n\r\n    Done by solving quadratic equation iteratively.\r\n    x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n    x_1**2 + b*x_1 = c\r\n\r\n    x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n    \"\"\"\r\n    # x in the input is converted to the same price/precision\r\n\r\n    assert i != j       # dev: same coin\r\n    assert j >= 0       # dev: j below zero\r\n    assert j < N_COINS  # dev: j above N_COINS\r\n\r\n    # should be unreachable, but good for safety\r\n    assert i >= 0\r\n    assert i < N_COINS\r\n\r\n    amp: uint256 = self._A()\r\n    D: uint256 = self.get_D(xp, amp)\r\n    Ann: uint256 = amp * N_COINS\r\n    c: uint256 = D\r\n    S_: uint256 = 0\r\n    _x: uint256 = 0\r\n    y_prev: uint256 = 0\r\n\r\n    for _i in range(N_COINS):\r\n        if _i == i:\r\n            _x = x\r\n        elif _i != j:\r\n            _x = xp[_i]\r\n        else:\r\n            continue\r\n        S_ += _x\r\n        c = c * D / (_x * N_COINS)\r\n    c = c * D * A_PRECISION / (Ann * N_COINS)\r\n    b: uint256 = S_ + D * A_PRECISION / Ann  # - D\r\n    y: uint256 = D\r\n    for _i in range(255):\r\n        y_prev = y\r\n        y = (y*y + c) / (2 * y + b - D)\r\n        # Equality with the precision of 1\r\n        if y > y_prev:\r\n            if y - y_prev <= 1:\r\n                return y\r\n        else:\r\n            if y_prev - y <= 1:\r\n                return y\r\n    raise\r\n\r\n\r\n@view\r\n@internal\r\ndef _get_dy(i: int128, j: int128, dx: uint256) -> uint256:\r\n    xp: uint256[N_COINS] = self._balances()\r\n    precisions: uint256[N_COINS] = PRECISION_MUL\r\n    for k in range(N_COINS):\r\n        xp[k] *= precisions[k]\r\n\r\n    x: uint256 = xp[i] + dx * precisions[i]\r\n    y: uint256 = self.get_y(i, j, x, xp)\r\n    dy: uint256 = (xp[j] - y) / precisions[j]\r\n    _fee: uint256 = self._dynamic_fee(\r\n            (xp[i] + x) / 2, (xp[j] + y) / 2, self.fee, self.offpeg_fee_multiplier\r\n        ) * dy / FEE_DENOMINATOR\r\n    return dy - _fee\r\n\r\n\r\n@view\r\n@external\r\ndef get_dy(i: int128, j: int128, dx: uint256) -> uint256:\r\n    return self._get_dy(i, j, dx)\r\n\r\n\r\n@view\r\n@external\r\ndef get_dy_underlying(i: int128, j: int128, dx: uint256) -> uint256:\r\n    return self._get_dy(i, j, dx)\r\n\r\n\r\n@internal\r\ndef _exchange(i: int128, j: int128, dx: uint256) -> uint256:\r\n    assert not self.is_killed  # dev: is killed\r\n    # dx and dy are in aTokens\r\n\r\n    self._claim_rewards()\r\n    xp: uint256[N_COINS] = self._balances()\r\n    precisions: uint256[N_COINS] = PRECISION_MUL\r\n    for k in range(N_COINS):\r\n        xp[k] *= precisions[k]\r\n\r\n    x: uint256 = xp[i] + dx * precisions[i]\r\n    y: uint256 = self.get_y(i, j, x, xp)\r\n    dy: uint256 = xp[j] - y\r\n    dy_fee: uint256 = dy * self._dynamic_fee(\r\n            (xp[i] + x) / 2, (xp[j] + y) / 2, self.fee, self.offpeg_fee_multiplier\r\n        ) / FEE_DENOMINATOR\r\n\r\n    admin_fee: uint256 = self.admin_fee\r\n    if admin_fee != 0:\r\n        dy_admin_fee: uint256 = dy_fee * admin_fee / FEE_DENOMINATOR\r\n        if dy_admin_fee != 0:\r\n            self.admin_balances[j] += dy_admin_fee / precisions[j]\r\n\r\n    return (dy - dy_fee) / precisions[j]\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange(i: int128, j: int128, dx: uint256, min_dy: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange between two coins\r\n    @dev Index values can be found via the `coins` public getter method\r\n    @param i Index value for the coin to send\r\n    @param j Index valie of the coin to recieve\r\n    @param dx Amount of `i` being exchanged\r\n    @param min_dy Minimum amount of `j` to receive\r\n    @return Actual amount of `j` received\r\n    \"\"\"\r\n    dy: uint256 = self._exchange(i, j, dx)\r\n    assert dy >= min_dy, \"Exchange resulted in fewer coins than expected\"\r\n\r\n    assert ERC20(self.coins[i]).transferFrom(msg.sender, self, dx)\r\n    assert ERC20(self.coins[j]).transfer(msg.sender, dy)\r\n\r\n    log TokenExchange(msg.sender, i, dx, j, dy)\r\n\r\n    return dy\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Perform an exchange between two underlying coins\r\n    @dev Index values can be found via the `underlying_coins` public getter method\r\n    @param i Index value for the underlying coin to send\r\n    @param j Index valie of the underlying coin to recieve\r\n    @param dx Amount of `i` being exchanged\r\n    @param min_dy Minimum amount of `j` to receive\r\n    @return Actual amount of `j` received\r\n    \"\"\"\r\n    dy: uint256 = self._exchange(i, j, dx)\r\n    assert dy >= min_dy, \"Exchange resulted in fewer coins than expected\"\r\n\r\n    u_coin_i: address = self.underlying_coins[i]\r\n\r\n    # transfer underlying coin from msg.sender to self\r\n    _response: Bytes[32] = raw_call(\r\n        u_coin_i,\r\n        concat(\r\n            method_id(\"transferFrom(address,address,uint256)\"),\r\n            convert(msg.sender, bytes32),\r\n            convert(self, bytes32),\r\n            convert(dx, bytes32)\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(_response) != 0:\r\n        assert convert(_response, bool)\r\n\r\n    # deposit to aave lending pool\r\n    raw_call(\r\n        AAVE_LENDING_POOL,\r\n        concat(\r\n            method_id(\"deposit(address,uint256,address,uint16)\"),\r\n            convert(u_coin_i, bytes32),\r\n            convert(dx, bytes32),\r\n            convert(self, bytes32),\r\n            convert(self.aave_referral, bytes32),\r\n        )\r\n    )\r\n    # withdraw `j` underlying from lending pool and transfer to caller\r\n    LendingPool(AAVE_LENDING_POOL).withdraw(self.underlying_coins[j], dy, msg.sender)\r\n\r\n    log TokenExchangeUnderlying(msg.sender, i, dx, j, dy)\r\n\r\n    return dy\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity(\r\n    _amount: uint256,\r\n    _min_amounts: uint256[N_COINS],\r\n    _use_underlying: bool = False,\r\n) -> uint256[N_COINS]:\r\n    \"\"\"\r\n    @notice Withdraw coins from the pool\r\n    @dev Withdrawal amounts are based on current deposit ratios\r\n    @param _amount Quantity of LP tokens to burn in the withdrawal\r\n    @param _min_amounts Minimum amounts of underlying coins to receive\r\n    @param _use_underlying If True, withdraw underlying assets instead of aTokens\r\n    @return List of amounts of coins that were withdrawn\r\n    \"\"\"\r\n    if not self.is_killed:\r\n        self._claim_rewards()\r\n    amounts: uint256[N_COINS] = self._balances()\r\n    lp_token: address = self.lp_token\r\n    total_supply: uint256 = ERC20(lp_token).totalSupply()\r\n    CurveToken(lp_token).burnFrom(msg.sender, _amount)  # dev: insufficient funds\r\n\r\n    for i in range(N_COINS):\r\n        value: uint256 = amounts[i] * _amount / total_supply\r\n        assert value >= _min_amounts[i], \"Withdrawal resulted in fewer coins than expected\"\r\n        amounts[i] = value\r\n        if _use_underlying:\r\n            LendingPool(AAVE_LENDING_POOL).withdraw(self.underlying_coins[i], value, msg.sender)\r\n        else:\r\n            assert ERC20(self.coins[i]).transfer(msg.sender, value)\r\n\r\n    log RemoveLiquidity(msg.sender, amounts, empty(uint256[N_COINS]), total_supply - _amount)\r\n\r\n    return amounts\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_imbalance(\r\n    _amounts: uint256[N_COINS],\r\n    _max_burn_amount: uint256,\r\n    _use_underlying: bool = False\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw coins from the pool in an imbalanced amount\r\n    @param _amounts List of amounts of underlying coins to withdraw\r\n    @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal\r\n    @param _use_underlying If True, withdraw underlying assets instead of aTokens\r\n    @return Actual amount of the LP token burned in the withdrawal\r\n    \"\"\"\r\n    assert not self.is_killed  # dev: is killed\r\n\r\n    self._claim_rewards()\r\n    amp: uint256 = self._A()\r\n    old_balances: uint256[N_COINS] = self._balances()\r\n    D0: uint256 = self.get_D_precisions(old_balances, amp)\r\n    new_balances: uint256[N_COINS] = old_balances\r\n    for i in range(N_COINS):\r\n        new_balances[i] -= _amounts[i]\r\n    D1: uint256 = self.get_D_precisions(new_balances, amp)\r\n    ys: uint256 = (D0 + D1) / N_COINS\r\n\r\n    lp_token: address = self.lp_token\r\n    token_supply: uint256 = ERC20(lp_token).totalSupply()\r\n    assert token_supply != 0  # dev: zero total supply\r\n\r\n    _fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\r\n    _feemul: uint256 = self.offpeg_fee_multiplier\r\n    _admin_fee: uint256 = self.admin_fee\r\n    fees: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    for i in range(N_COINS):\r\n        ideal_balance: uint256 = D1 * old_balances[i] / D0\r\n        new_balance: uint256 = new_balances[i]\r\n        difference: uint256 = 0\r\n        if ideal_balance > new_balance:\r\n            difference = ideal_balance - new_balance\r\n        else:\r\n            difference = new_balance - ideal_balance\r\n        xs: uint256 = new_balance + old_balances[i]\r\n        fees[i] = self._dynamic_fee(xs, ys, _fee, _feemul) * difference / FEE_DENOMINATOR\r\n        if _admin_fee != 0:\r\n            self.admin_balances[i] += fees[i] * _admin_fee / FEE_DENOMINATOR\r\n        new_balances[i] -= fees[i]\r\n    D2: uint256 = self.get_D_precisions(new_balances, amp)\r\n\r\n    token_amount: uint256 = (D0 - D2) * token_supply / D0\r\n    assert token_amount != 0  # dev: zero tokens burned\r\n    assert token_amount <= _max_burn_amount, \"Slippage screwed you\"\r\n\r\n    CurveToken(lp_token).burnFrom(msg.sender, token_amount)  # dev: insufficient funds\r\n\r\n    for i in range(N_COINS):\r\n        amount: uint256 = _amounts[i]\r\n        if amount != 0:\r\n            if _use_underlying:\r\n                LendingPool(AAVE_LENDING_POOL).withdraw(self.underlying_coins[i], amount, msg.sender)\r\n            else:\r\n                assert ERC20(self.coins[i]).transfer(msg.sender, amount)\r\n\r\n    log RemoveLiquidityImbalance(msg.sender, _amounts, fees, D1, token_supply - token_amount)\r\n\r\n    return token_amount\r\n\r\n\r\n@pure\r\n@internal\r\ndef get_y_D(A_: uint256, i: int128, xp: uint256[N_COINS], D: uint256) -> uint256:\r\n    \"\"\"\r\n    Calculate x[i] if one reduces D from being calculated for xp to D\r\n\r\n    Done by solving quadratic equation iteratively.\r\n    x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n    x_1**2 + b*x_1 = c\r\n\r\n    x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n    \"\"\"\r\n    # x in the input is converted to the same price/precision\r\n\r\n    assert i >= 0       # dev: i below zero\r\n    assert i < N_COINS  # dev: i above N_COINS\r\n\r\n    Ann: uint256 = A_ * N_COINS\r\n    c: uint256 = D\r\n    S_: uint256 = 0\r\n    _x: uint256 = 0\r\n    y_prev: uint256 = 0\r\n\r\n    for _i in range(N_COINS):\r\n        if _i != i:\r\n            _x = xp[_i]\r\n        else:\r\n            continue\r\n        S_ += _x\r\n        c = c * D / (_x * N_COINS)\r\n    c = c * D * A_PRECISION / (Ann * N_COINS)\r\n    b: uint256 = S_ + D * A_PRECISION / Ann\r\n    y: uint256 = D\r\n\r\n    for _i in range(255):\r\n        y_prev = y\r\n        y = (y*y + c) / (2 * y + b - D)\r\n        # Equality with the precision of 1\r\n        if y > y_prev:\r\n            if y - y_prev <= 1:\r\n                return y\r\n        else:\r\n            if y_prev - y <= 1:\r\n                return y\r\n    raise\r\n\r\n\r\n@view\r\n@internal\r\ndef _calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256:\r\n    # First, need to calculate\r\n    # * Get current D\r\n    # * Solve Eqn against y_i for D - _token_amount\r\n    amp: uint256 = self._A()\r\n    xp: uint256[N_COINS] = self._balances()\r\n    precisions: uint256[N_COINS] = PRECISION_MUL\r\n\r\n    for j in range(N_COINS):\r\n        xp[j] *= precisions[j]\r\n\r\n    D0: uint256 = self.get_D(xp, amp)\r\n    D1: uint256 = D0 - _token_amount * D0 / ERC20(self.lp_token).totalSupply()\r\n    new_y: uint256 = self.get_y_D(amp, i, xp, D1)\r\n\r\n    xp_reduced: uint256[N_COINS] = xp\r\n    ys: uint256 = (D0 + D1) / (2 * N_COINS)\r\n\r\n    _fee: uint256 = self.fee * N_COINS / (4 * (N_COINS - 1))\r\n    feemul: uint256 = self.offpeg_fee_multiplier\r\n    for j in range(N_COINS):\r\n        dx_expected: uint256 = 0\r\n        xavg: uint256 = 0\r\n        if j == i:\r\n            dx_expected = xp[j] * D1 / D0 - new_y\r\n            xavg = (xp[j] + new_y) / 2\r\n        else:\r\n            dx_expected = xp[j] - xp[j] * D1 / D0\r\n            xavg = xp[j]\r\n        xp_reduced[j] -= self._dynamic_fee(xavg, ys, _fee, feemul) * dx_expected / FEE_DENOMINATOR\r\n\r\n    dy: uint256 = xp_reduced[i] - self.get_y_D(amp, i, xp_reduced, D1)\r\n\r\n    return (dy - 1) / precisions[i]\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount received when withdrawing a single coin\r\n    @dev Result is the same for underlying or wrapped asset withdrawals\r\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @return Amount of coin received\r\n    \"\"\"\r\n    return self._calc_withdraw_one_coin(_token_amount, i)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_one_coin(\r\n    _token_amount: uint256,\r\n    i: int128,\r\n    _min_amount: uint256,\r\n    _use_underlying: bool = False\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw a single coin from the pool\r\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @param _min_amount Minimum amount of coin to receive\r\n    @param _use_underlying If True, withdraw underlying assets instead of aTokens\r\n    @return Amount of coin received\r\n    \"\"\"\r\n    assert not self.is_killed  # dev: is killed\r\n\r\n    self._claim_rewards()\r\n    dy: uint256 = self._calc_withdraw_one_coin(_token_amount, i)\r\n    assert dy >= _min_amount, \"Not enough coins removed\"\r\n\r\n    CurveToken(self.lp_token).burnFrom(msg.sender, _token_amount)  # dev: insufficient funds\r\n\r\n    if _use_underlying:\r\n        LendingPool(AAVE_LENDING_POOL).withdraw(self.underlying_coins[i], dy, msg.sender)\r\n    else:\r\n        assert ERC20(self.coins[i]).transfer(msg.sender, dy)\r\n\r\n    log RemoveLiquidityOne(msg.sender, _token_amount, dy)\r\n\r\n    return dy\r\n\r\n\r\n### Admin functions ###\r\n\r\n@external\r\ndef ramp_A(_future_A: uint256, _future_time: uint256):\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert block.timestamp >= self.initial_A_time + MIN_RAMP_TIME\r\n    assert _future_time >= block.timestamp + MIN_RAMP_TIME  # dev: insufficient time\r\n\r\n    _initial_A: uint256 = self._A()\r\n    _future_A_p: uint256 = _future_A * A_PRECISION\r\n\r\n    assert _future_A > 0 and _future_A < MAX_A\r\n    if _future_A_p < _initial_A:\r\n        assert _future_A_p * MAX_A_CHANGE >= _initial_A\r\n    else:\r\n        assert _future_A_p <= _initial_A * MAX_A_CHANGE\r\n\r\n    self.initial_A = _initial_A\r\n    self.future_A = _future_A_p\r\n    self.initial_A_time = block.timestamp\r\n    self.future_A_time = _future_time\r\n\r\n    log RampA(_initial_A, _future_A_p, block.timestamp, _future_time)\r\n\r\n\r\n@external\r\ndef stop_ramp_A():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    current_A: uint256 = self._A()\r\n    self.initial_A = current_A\r\n    self.future_A = current_A\r\n    self.initial_A_time = block.timestamp\r\n    self.future_A_time = block.timestamp\r\n    # now (block.timestamp < t1) is always False, so we return saved A\r\n\r\n    log StopRampA(current_A, block.timestamp)\r\n\r\n\r\n@external\r\ndef commit_new_fee(new_fee: uint256, new_admin_fee: uint256, new_offpeg_fee_multiplier: uint256):\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert self.admin_actions_deadline == 0  # dev: active action\r\n    assert new_fee <= MAX_FEE  # dev: fee exceeds maximum\r\n    assert new_admin_fee <= MAX_ADMIN_FEE  # dev: admin fee exceeds maximum\r\n    assert new_offpeg_fee_multiplier * new_fee <= MAX_FEE * FEE_DENOMINATOR  # dev: offpeg multiplier exceeds maximum\r\n\r\n    _deadline: uint256 = block.timestamp + ADMIN_ACTIONS_DELAY\r\n    self.admin_actions_deadline = _deadline\r\n    self.future_fee = new_fee\r\n    self.future_admin_fee = new_admin_fee\r\n    self.future_offpeg_fee_multiplier = new_offpeg_fee_multiplier\r\n\r\n    log CommitNewFee(_deadline, new_fee, new_admin_fee, new_offpeg_fee_multiplier)\r\n\r\n\r\n@external\r\ndef apply_new_fee():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert block.timestamp >= self.admin_actions_deadline  # dev: insufficient time\r\n    assert self.admin_actions_deadline != 0  # dev: no active action\r\n\r\n    self.admin_actions_deadline = 0\r\n    _fee: uint256 = self.future_fee\r\n    _admin_fee: uint256 = self.future_admin_fee\r\n    _fml: uint256 = self.future_offpeg_fee_multiplier\r\n    self.fee = _fee\r\n    self.admin_fee = _admin_fee\r\n    self.offpeg_fee_multiplier = _fml\r\n\r\n    log NewFee(_fee, _admin_fee, _fml)\r\n\r\n\r\n@external\r\ndef revert_new_parameters():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.admin_actions_deadline = 0\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_owner: address):\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert self.transfer_ownership_deadline == 0  # dev: active transfer\r\n\r\n    _deadline: uint256 = block.timestamp + ADMIN_ACTIONS_DELAY\r\n    self.transfer_ownership_deadline = _deadline\r\n    self.future_owner = _owner\r\n\r\n    log CommitNewAdmin(_deadline, _owner)\r\n\r\n\r\n@external\r\ndef apply_transfer_ownership():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert block.timestamp >= self.transfer_ownership_deadline  # dev: insufficient time\r\n    assert self.transfer_ownership_deadline != 0  # dev: no active transfer\r\n\r\n    self.transfer_ownership_deadline = 0\r\n    _owner: address = self.future_owner\r\n    self.owner = _owner\r\n\r\n    log NewAdmin(_owner)\r\n\r\n\r\n@external\r\ndef revert_transfer_ownership():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.transfer_ownership_deadline = 0\r\n\r\n\r\n@external\r\ndef withdraw_admin_fees():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    for i in range(N_COINS):\r\n        value: uint256 = self.admin_balances[i]\r\n        if value != 0:\r\n            assert ERC20(self.coins[i]).transfer(self.admin_fee_receiver, value)\r\n            self.admin_balances[i] = 0\r\n\r\n\r\n@external\r\ndef donate_admin_fees():\r\n    \"\"\"\r\n    Just in case admin balances somehow become higher than total (rounding error?)\r\n    this can be used to fix the state, too\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    self.admin_balances = empty(uint256[N_COINS])\r\n\r\n\r\n@external\r\ndef kill_me():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert self.kill_deadline > block.timestamp  # dev: deadline has passed\r\n    self.is_killed = True\r\n\r\n\r\n@external\r\ndef unkill_me():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    self.is_killed = False\r\n\r\n\r\n@external\r\ndef set_aave_referral(referral_code: uint256):\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert referral_code < 2 ** 16  # dev: uint16 overflow\r\n    self.aave_referral = referral_code\r\n\r\n\r\n@external\r\ndef set_reward_receiver(_reward_receiver: address):\r\n    assert msg.sender == self.owner\r\n    self.reward_receiver = _reward_receiver\r\n\r\n\r\n@external\r\ndef set_admin_fee_receiver(_admin_fee_receiver: address):\r\n    assert msg.sender == self.owner\r\n    self.admin_fee_receiver = _admin_fee_receiver", "ABI": "[{\"name\":\"TokenExchange\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sold_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"bought_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenExchangeUnderlying\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sold_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"bought_id\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"tokens_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[3]\",\"indexed\":false},{\"name\":\"fees\",\"type\":\"uint256[3]\",\"indexed\":false},{\"name\":\"invariant\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[3]\",\"indexed\":false},{\"name\":\"fees\",\"type\":\"uint256[3]\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityOne\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"coin_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityImbalance\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[3]\",\"indexed\":false},{\"name\":\"fees\",\"type\":\"uint256[3]\",\"indexed\":false},{\"name\":\"invariant\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitNewAdmin\",\"inputs\":[{\"name\":\"deadline\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"admin\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitNewFee\",\"inputs\":[{\"name\":\"deadline\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"admin_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"offpeg_fee_multiplier\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewFee\",\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"admin_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"offpeg_fee_multiplier\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RampA\",\"inputs\":[{\"name\":\"old_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StopRampA\",\"inputs\":[{\"name\":\"A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"t\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_coins\",\"type\":\"address[3]\"},{\"name\":\"_underlying_coins\",\"type\":\"address[3]\"},{\"name\":\"_pool_token\",\"type\":\"address\"},{\"name\":\"_A\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_admin_fee\",\"type\":\"uint256\"},{\"name\":\"_offpeg_fee_multiplier\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":10374},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"A_precise\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":10336},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"dynamic_fee\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":22113},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balances\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":7358},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_virtual_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2702067},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"is_deposit\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":5368162},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"_use_underlying\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":6289374},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":6289404},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":6465508},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"j\",\"type\":\"int128\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":6484358},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[3]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_use_underlying\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_use_underlying\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4491030},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"},{\"name\":\"_use_underlying\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"ramp_A\",\"inputs\":[{\"name\":\"_future_A\",\"type\":\"uint256\"},{\"name\":\"_future_time\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":159459},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stop_ramp_A\",\"inputs\":[],\"outputs\":[],\"gas\":154920},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_new_fee\",\"inputs\":[{\"name\":\"new_fee\",\"type\":\"uint256\"},{\"name\":\"new_admin_fee\",\"type\":\"uint256\"},{\"name\":\"new_offpeg_fee_multiplier\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":148809},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_new_fee\",\"inputs\":[],\"outputs\":[],\"gas\":141271},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revert_new_parameters\",\"inputs\":[],\"outputs\":[],\"gas\":23012},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"outputs\":[],\"gas\":77050},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_transfer_ownership\",\"inputs\":[],\"outputs\":[],\"gas\":65727},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revert_transfer_ownership\",\"inputs\":[],\"outputs\":[],\"gas\":23102},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw_admin_fees\",\"inputs\":[],\"outputs\":[],\"gas\":90981},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"donate_admin_fees\",\"inputs\":[],\"outputs\":[],\"gas\":63303},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"kill_me\",\"inputs\":[],\"outputs\":[],\"gas\":40385},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"unkill_me\",\"inputs\":[],\"outputs\":[],\"gas\":23222},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_aave_referral\",\"inputs\":[{\"name\":\"referral_code\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":38352},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_reward_receiver\",\"inputs\":[{\"name\":\"_reward_receiver\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38385},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_admin_fee_receiver\",\"inputs\":[{\"name\":\"_admin_fee_receiver\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38415},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coins\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3397},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"underlying_coins\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3427},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3457},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3378},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"offpeg_fee_multiplier\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3408},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3438},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3468},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lp_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3498},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3528},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3558},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3588},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3618},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_actions_deadline\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3648},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"transfer_ownership_deadline\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3678},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3708},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3738},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_offpeg_fee_multiplier\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3768},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3798},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_receiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3828},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_fee_receiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3858}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.2.12", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000027f8d03b3a2196956ed754badc28d73be8830a6e0000000000000000000000001a13f4ca1d028320a707d99520abfefca3998b7f00000000000000000000000060d55f02a771d515e077c9c2403a1ef324885cec0000000000000000000000008f3cf7ad23cd3cadbd9735aff958023239c6a0630000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f000000000000000000000000e7a24ef0c5e95ffb0f6684b813a78f2a3ad7d17100000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000003d0900000000000000000000000000000000000000000000000000000000012a05f20000000000000000000000000000000000000000000000000000000004a817c800", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}