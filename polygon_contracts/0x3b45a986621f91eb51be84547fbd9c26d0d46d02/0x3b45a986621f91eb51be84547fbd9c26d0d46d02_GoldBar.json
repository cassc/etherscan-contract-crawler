{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GoldBar.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at BscScan.com on 2021-06-06\\n */\\n\\npragma solidity ^0.4.24;\\n\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n}\\n\\ncontract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n}\\n\\ncontract Pausable is Ownable {\\n    event Pause();\\n    event Unpause();\\n\\n    bool public paused = false;\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused);\\n        _;\\n    }\\n\\n    /**\\n     * @dev called by the owner to pause, triggers stopped state\\n     */\\n    function pause() public onlyOwner whenNotPaused {\\n        paused = true;\\n        emit Pause();\\n    }\\n\\n    /**\\n     * @dev called by the owner to unpause, returns to normal state\\n     */\\n    function unpause() public onlyOwner whenPaused {\\n        paused = false;\\n        emit Unpause();\\n    }\\n}\\n\\ncontract ERC20Basic {\\n    uint256 public totalSupply;\\n\\n    function balanceOf(address who) public view returns (uint256);\\n\\n    function transfer(address to, uint256 value) public returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\ncontract ERC20 is ERC20Basic {\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        returns (uint256);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public returns (bool);\\n\\n    function approve(address spender, uint256 value) public returns (bool);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ncontract StandardToken is ERC20 {\\n    using SafeMath for uint256;\\n    uint256 public txFee;\\n    uint256 public burnFee;\\n    address public FeeAddress;\\n\\n    mapping(address => mapping(address => uint256)) internal allowed;\\n    mapping(address => bool) tokenBlacklist;\\n    event Blacklist(address indexed blackListed, bool value);\\n\\n    mapping(address => uint256) balances;\\n    mapping(address => bool) _isExcludedFromTaxFee;\\n    mapping(address => bool) _isExcludedFromBurnFee;\\n\\n    function transfer(address _to, uint256 _value) public returns (bool) {\\n        require(tokenBlacklist[msg.sender] == false);\\n        require(_to != address(0));\\n        require(_value <= balances[msg.sender]);\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        uint256 tempValue = _value;\\n        if (!_isExcludedFromTaxFee[msg.sender]) {\\n            if (txFee > 0 && msg.sender != FeeAddress) {\\n                uint256 DenverDeflaionaryDecay = tempValue.div(\\n                    uint256(100 / txFee)\\n                );\\n                balances[FeeAddress] = balances[FeeAddress].add(\\n                    DenverDeflaionaryDecay\\n                );\\n                emit Transfer(msg.sender, FeeAddress, DenverDeflaionaryDecay);\\n                _value = _value.sub(DenverDeflaionaryDecay);\\n            }\\n        }\\n        if (!_isExcludedFromBurnFee[msg.sender]) {\\n            if (burnFee > 0 && msg.sender != FeeAddress) {\\n                uint256 Burnvalue = tempValue.div(uint256(100 / burnFee));\\n                totalSupply = totalSupply.sub(Burnvalue);\\n                emit Transfer(msg.sender, address(0), Burnvalue);\\n                _value = _value.sub(Burnvalue);\\n            }\\n        }\\n\\n        // SafeMath.sub will throw if there is not enough balance.\\n\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\n        return balances[_owner];\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) public returns (bool) {\\n        require(tokenBlacklist[msg.sender] == false);\\n        require(_to != address(0));\\n        require(_value <= balances[_from]);\\n        require(_value <= allowed[_from][msg.sender]);\\n        balances[_from] = balances[_from].sub(_value);\\n        uint256 tempValue = _value;\\n        if (!_isExcludedFromTaxFee[_from]) {\\n            if (txFee > 0 && _from != FeeAddress) {\\n                uint256 DenverDeflaionaryDecay = tempValue.div(\\n                    uint256(100 / txFee)\\n                );\\n                balances[FeeAddress] = balances[FeeAddress].add(\\n                    DenverDeflaionaryDecay\\n                );\\n                emit Transfer(_from, FeeAddress, DenverDeflaionaryDecay);\\n                _value = _value.sub(DenverDeflaionaryDecay);\\n            }\\n        }\\n        if (!_isExcludedFromBurnFee[_from]) {\\n            if (burnFee > 0 && _from != FeeAddress) {\\n                uint256 Burnvalue = tempValue.div(uint256(100 / burnFee));\\n                totalSupply = totalSupply.sub(Burnvalue);\\n                emit Transfer(_from, address(0), Burnvalue);\\n                _value = _value.sub(Burnvalue);\\n            }\\n        }\\n        balances[_to] = balances[_to].add(_value);\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value) public returns (bool) {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address _spender)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n\\n    function increaseApproval(address _spender, uint256 _addedValue)\\n        public\\n        returns (bool)\\n    {\\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(\\n            _addedValue\\n        );\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address _spender, uint256 _subtractedValue)\\n        public\\n        returns (bool)\\n    {\\n        uint256 oldValue = allowed[msg.sender][_spender];\\n        if (_subtractedValue > oldValue) {\\n            allowed[msg.sender][_spender] = 0;\\n        } else {\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n        }\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n        return true;\\n    }\\n\\n    function _blackList(address _address, bool _isBlackListed)\\n        internal\\n        returns (bool)\\n    {\\n        require(tokenBlacklist[_address] != _isBlackListed);\\n        tokenBlacklist[_address] = _isBlackListed;\\n        emit Blacklist(_address, _isBlackListed);\\n        return true;\\n    }\\n}\\n\\ncontract PausableToken is StandardToken, Pausable {\\n    function transfer(address _to, uint256 _value)\\n        public\\n        whenNotPaused\\n        returns (bool)\\n    {\\n        return super.transfer(_to, _value);\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) public whenNotPaused returns (bool) {\\n        return super.transferFrom(_from, _to, _value);\\n    }\\n\\n    function approve(address _spender, uint256 _value)\\n        public\\n        whenNotPaused\\n        returns (bool)\\n    {\\n        return super.approve(_spender, _value);\\n    }\\n\\n    function increaseApproval(address _spender, uint256 _addedValue)\\n        public\\n        whenNotPaused\\n        returns (bool success)\\n    {\\n        return super.increaseApproval(_spender, _addedValue);\\n    }\\n\\n    function decreaseApproval(address _spender, uint256 _subtractedValue)\\n        public\\n        whenNotPaused\\n        returns (bool success)\\n    {\\n        return super.decreaseApproval(_spender, _subtractedValue);\\n    }\\n\\n    function blackListAddress(address listAddress, bool isBlackListed)\\n        public\\n        whenNotPaused\\n        onlyOwner\\n        returns (bool success)\\n    {\\n        return super._blackList(listAddress, isBlackListed);\\n    }\\n}\\n\\ncontract GoldBar is PausableToken {\\n    string public name;\\n    string public symbol;\\n    uint256 public decimals;\\n    event Mint(address indexed from, address indexed to, uint256 value);\\n    event Burn(address indexed burner, uint256 value);\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint256 _decimals,\\n        uint256 _supply,\\n        uint256 _txFee,\\n        uint256 _burnFee,\\n        address _FeeAddress,\\n        address tokenOwner\\n    ) public payable {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n        totalSupply = _supply * 10**_decimals;\\n        balances[tokenOwner] = totalSupply;\\n        owner = tokenOwner;\\n        txFee = _txFee;\\n        burnFee = _burnFee;\\n        FeeAddress = _FeeAddress;\\n        emit Transfer(address(0), tokenOwner, totalSupply);\\n    }\\n\\n    function burn(uint256 _value) public {\\n        _burn(msg.sender, _value);\\n    }\\n\\n    function updateFee(\\n        uint256 _txFee,\\n        uint256 _burnFee,\\n        address _FeeAddress\\n    ) public onlyOwner {\\n        txFee = _txFee;\\n        burnFee = _burnFee;\\n        FeeAddress = _FeeAddress;\\n    }\\n\\n    enum FeeType {\\n        TxFee,\\n        BurnFee,\\n        Both\\n    }\\n\\n    function excludeFromFees(\\n        FeeType _feeType,\\n        address _addressToExclude,\\n        bool _value\\n    ) public onlyOwner {\\n        if (_feeType == FeeType.TxFee) {\\n            _isExcludedFromTaxFee[_addressToExclude] = _value;\\n        } else if (_feeType == FeeType.BurnFee) {\\n            _isExcludedFromBurnFee[_addressToExclude] = _value;\\n        } else {\\n            _isExcludedFromTaxFee[_addressToExclude] = _value;\\n            _isExcludedFromBurnFee[_addressToExclude] = _value;\\n        }\\n    }\\n\\n    function isExcludedFromTaxFee(address _address) public view returns (bool) {\\n        return _isExcludedFromTaxFee[_address];\\n    }\\n\\n    function isExcludedFromBurnFee(address _address)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _isExcludedFromBurnFee[_address];\\n    }\\n\\n    function _burn(address _who, uint256 _value) internal {\\n        require(_value <= balances[_who]);\\n        balances[_who] = balances[_who].sub(_value);\\n        totalSupply = totalSupply.sub(_value);\\n        emit Burn(_who, _value);\\n        emit Transfer(_who, address(0), _value);\\n    }\\n\\n    function mint(address account, uint256 amount) public onlyOwner {\\n        totalSupply = totalSupply.add(amount);\\n        balances[account] = balances[account].add(amount);\\n        emit Mint(address(0), account, amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listAddress\",\"type\":\"address\"},{\"name\":\"isBlackListed\",\"type\":\"bool\"}],\"name\":\"blackListAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FeeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_txFee\",\"type\":\"uint256\"},{\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"name\":\"_FeeAddress\",\"type\":\"address\"}],\"name\":\"updateFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeType\",\"type\":\"uint8\"},{\"name\":\"_addressToExclude\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isExcludedFromTaxFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"txFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isExcludedFromBurnFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint256\"},{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_txFee\",\"type\":\"uint256\"},{\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"name\":\"_FeeAddress\",\"type\":\"address\"},{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blackListed\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"Blacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "GoldBar", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000170cdc1e00000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000050000000000000000000000007affff9d4c801101147fb497d0ab788cebbe75d80000000000000000000000004b311bdb7544b5729d43279c6cadeb6fa438242d0000000000000000000000000000000000000000000000000000000000000011476f6c64204261722043757272656e637900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034758420000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}