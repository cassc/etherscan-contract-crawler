{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"TNS.sol\": {\r\n      \"content\": \"/// raffy.eth\\n// SPDX-License-Identifier: MIT\\n\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n// \u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n//    \u2588\u2588\u2551   \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n//    \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\\n//    \u2588\u2588\u2551   \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n//    \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d                           \\n//      Token Name Service\\n\\npragma solidity ^0.8.23;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts@4.8.2/access/Ownable.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts@4.8.2/utils/introspection/IERC165.sol\\\";\\nimport {ENS} from \\\"@ensdomains/ens-contracts/contracts/registry/ENS.sol\\\";\\nimport {IExtendedResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\\\";\\nimport {IAddressResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\\\";\\nimport {ITextResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\\\";\\nimport {IContentHashResolver} from \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol\\\";\\nimport {BytesUtils} from \\\"@ensdomains/ens-contracts/contracts/wrapper/BytesUtils.sol\\\";\\n\\ninterface ViewMulticall {\\n\\tfunction multicall(bytes[] memory data) external view returns (bytes[] memory results);\\n}\\n\\nerror OffchainLookup(address sender, string[] urls, bytes callData, bytes4 callbackFunction, bytes extraData);\\n\\ncontract TNS is Ownable, IERC165 {\\n\\tusing BytesUtils for bytes;\\n\\n\\tfunction supportsInterface(bytes4 x) external pure returns (bool) {\\n\\t\\treturn x == type(IERC165).interfaceId;\\n\\t}\\n\\n\\taddress constant ENS_REGISTRY = 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e;\\n\\n\\tbytes public basename = hex\\\"03746b6e0365746800\\\";\\n\\n\\tmapping (uint256 => bytes) _fields;\\n\\tuint256 _fieldCount;\\n\\t\\n\\tstruct KV {\\n\\t\\tstring k;\\n\\t\\tstring v;\\n\\t}\\n\\n\\tevent FieldsChanged();\\n\\tevent BasenameChanged(bytes indexed dnsname);\\n\\n\\tuint8 constant KIND_TEXT = 1;\\n\\tuint8 constant KIND_ADDR = 2;\\n\\n\\t// Read about the TKN dataset here: https://docs.tkn.xyz/developers/querying-the-tns-dataset\\n\\n\\t// addTexts([\\n\\t//   \\\"name\\\",\\n\\t//   \\\"symbol\\\",\\n\\t//   \\\"description\\\",\\n\\t//   \\\"avatar\\\",\\n\\t//   \\\"url\\\",\\n\\t//   \\\"notice\\\",\\n\\t//   \\\"decimals\\\",\\n\\t//   \\\"twitter\\\",\\n\\t//   \\\"github\\\",\\n\\t//   \\\"chainID\\\",\\n\\t//   \\\"coinType\\\",\\n\\t//   \\\"version\\\",\\n\\t//   \\\"tokenSupply\\\",\\n\\t//   \\\"circulatingSupply\\\",\\n\\t//   \\\"discord\\\",\\n\\t//   \\\"forum\\\",\\n\\t//   \\\"governance\\\",\\n\\t//   \\\"snapshot\\\",\\n\\t//   \\\"git\\\"\\n\\t// ]);\\n\\n\\t// addCoins(\\n\\t//   [\\n\\t//     \\\".eth\\\",     // Ethereum - \\t\\t\\t\\tChainID: 1\\n\\t//     \\\".op\\\",      // Optimism - \\t\\t\\t\\tChainID: 10\\n\\t//     \\\".arb\\\",     // Arbitrum - \\t\\t\\t\\tChainID: 42161\\n\\t//     \\\".avax\\\",    // Avalanche C-Chain - \\t\\tChainID: 43114\\n\\t//     \\\".bnb\\\",     // BNB Chain (AKA BSC) - \\tChainID: 56\\n\\t//     \\\".base\\\",    // Base (By Coinbase) - \\t\\tChainID: 8453\\n\\t//     \\\".cro\\\",     // Crypto.org Chain - \\t\\tChainID: 25\\n\\t//     \\\".ftm\\\",     // Fantom - \\t\\t\\t\\t\\tChainID: 250\\n\\t//     \\\".gno\\\",     // Gnosis (formerly xDai)\\tChainID: 100\\n\\t//     \\\".matic\\\",   // Polygon (MATIC) - \\t\\tChainID: 137\\n\\t//     \\\".celo\\\",    // Celo - \\t\\t\\t\\t\\tChainID: 42220\\n\\t//     \\\".goerli\\\",  // Goerli Testnet - \\t\\t\\tChainID: 5\\n\\t//     \\\".sepolia\\\", // Sepolia Testnet - \\t\\tChainID: 111551\\n\\t//     \\\".holesky\\\", // Holesky Testnet - \\t\\tChainID: 17000\\n\\t//     \\\".near\\\",    // NEAR - \\t\\t\\t\\t\\tCoinType: 397\\n\\t//     \\\".sol\\\",     // Solana - \\t\\t\\t\\t\\tCoinType: 501\\n\\t//     \\\".trx\\\",     // TRON - \\t\\t\\t\\t\\tCoinType: 195\\n\\t//     \\\".zil\\\"      // Zilliqa - \\t\\t\\t\\tCoinType: 119\\n\\t//   ],\\n\\t//   [\\n\\t//     60,            // ChainID for Ethereum\\n\\t//     2147483658,    // ChainID for Optimism\\n\\t//     2147525809,    // ChainID for Arbitrum\\n\\t//     2147526762,    // ChainID for Avalanche C-Chain\\n\\t//     2147483704,    // ChainID for BNB Chain (AKA BSC)\\n\\t//     2147492101,    // ChainID for Base (By Coinbase)\\n\\t//     2147483673,    // ChainID for Crypto.org Chain (CRO)\\n\\t//     2147483898,    // ChainID for Fantom\\n\\t//     2147483748,    // ChainID for Gnosis (formerly xDai)\\n\\t//     2147483785,    // ChainID for Polygon (MATIC)\\n\\t//     2147525868,    // ChainID for Celo\\n\\t//     2147483643,    // ChainID for Goerli Testnet\\n\\t//     2136328537,    // ChainID for Sepolia Testnet\\n\\t//     2147500648,    // ChainID for Holesky Testnet\\n\\t//     397,           // CoinType for NEAR\\n\\t//     501,           // CoinType for Solana\\n\\t//     195,           // CoinType for TRON\\n\\t//     119            // CoinType for Zilliqa\\n\\t//   ]\\n\\t// )\\n\\n\\tfunction setBasename(bytes calldata dnsname) onlyOwner external {\\n\\t\\tbasename = dnsname;\\n\\t\\temit BasenameChanged(dnsname);\\n\\t}\\n\\tfunction addText(string[] calldata names) onlyOwner external {\\n\\t\\tunchecked {\\n\\t\\t\\tfor (uint256 i; i < names.length; i += 1) {\\n\\t\\t\\t\\taddField(keccak256(bytes(names[i])), abi.encodePacked(KIND_TEXT, names[i]));\\n\\t\\t\\t}\\n\\t\\t\\temit FieldsChanged();\\n\\t\\t}\\n\\t}\\n\\tfunction addCoins(string[] calldata names, uint64[] calldata coinTypes) onlyOwner external {\\n\\t\\tunchecked {\\n\\t\\t\\trequire(names.length == coinTypes.length);\\n\\t\\t\\tfor (uint256 i; i < names.length; i += 1) {\\n\\t\\t\\t\\tbytes memory v = abi.encodePacked(KIND_ADDR, coinTypes[i]);\\n\\t\\t\\t\\taddField(keccak256(v), abi.encodePacked(v, names[i]));\\n\\t\\t\\t}\\n\\t\\t\\temit FieldsChanged();\\n\\t\\t}\\n\\t}\\n\\tfunction addField(bytes32 hash, bytes memory field) internal {\\n\\t\\tunchecked { \\n\\t\\t\\tuint248 key = uint224(uint256(hash));\\n\\t\\t\\tif (_fields[key].length == 0) {\\n\\t\\t\\t\\tuint256 last = _fieldCount;\\n\\t\\t\\t\\t_fieldCount = last + 1;\\n\\t\\t\\t\\t_fields[last] = abi.encodePacked(key);\\n\\t\\t\\t}\\n\\t\\t\\t_fields[key] = field;\\n\\t\\t}\\n\\t}\\n\\tfunction removeFieldAt(uint256 i) onlyOwner external {\\n\\t\\tuint256 last = _fieldCount - 1; // checked\\n\\t\\t_fieldCount = last;\\n\\t\\t_fields[i] = _fields[last];\\n\\t\\temit FieldsChanged();\\n\\t}\\n\\tfunction fieldNames() public view returns (string[] memory names) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 n = _fieldCount;\\n\\t\\t\\tnames = new string[](n + 1);\\n\\t\\t\\tfor (uint256 i; i < n; i += 1) {\\n\\t\\t\\t\\tbytes memory v = _fields[uint256(bytes32(_fields[i])) >> 8];\\n\\t\\t\\t\\tif (uint8(v[0]) == KIND_TEXT) {\\n\\t\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\t\\tmstore(add(v, 1), sub(mload(v), 1))\\n\\t\\t\\t\\t\\t\\tv := add(v, 1)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnames[i] = string(v);\\n\\t\\t\\t\\t} else { //if (uint8(v[0]) == KIND_ADDR) {\\n\\t\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\t\\tmstore(add(v, 9), sub(mload(v), 9))\\n\\t\\t\\t\\t\\t\\tv := add(v, 9)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnames[i] = string(v);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnames[n] = \\\"#contenthash\\\";\\n\\t\\t}\\n\\t}\\n\\tfunction makeCalls(bytes32 node) external view returns (bytes[] memory fs) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 n = _fieldCount;\\n\\t\\t\\tfs = new bytes[](n + 1);\\n\\t\\t\\tfor (uint256 i; i < n; i += 1) {\\n\\t\\t\\t\\tbytes memory v = _fields[uint256(bytes32(_fields[i])) >> 8];\\n\\t\\t\\t\\tif (uint8(v[0]) == KIND_TEXT) {\\n\\t\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\t\\tmstore(add(v, 1), sub(mload(v), 1))\\n\\t\\t\\t\\t\\t\\tv := add(v, 1)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfs[i] = abi.encodeCall(ITextResolver.text, (node, string(v)));\\n\\t\\t\\t\\t} else { //if (uint8(v[0]) == KIND_ADDR) {\\n\\t\\t\\t\\t\\tuint256 coinType;\\n\\t\\t\\t\\t\\tassembly { coinType := mload(add(v, 9)) }\\n\\t\\t\\t\\t\\tfs[i] = abi.encodeCall(IAddressResolver.addr, (node, uint64(coinType)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfs[n] = abi.encodeCall(IContentHashResolver.contenthash, (node));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction lookup(string calldata tick) external view returns (KV[] memory) {\\n\\t\\trequire(bytes(tick).length < 256, \\\"length\\\");\\n\\t\\tbytes32 node0 = basename.namehash(0);\\n\\t\\tbytes32 node = keccak256(abi.encodePacked(node0, keccak256(bytes(tick))));\\n\\t\\taddress resolver = ENS(ENS_REGISTRY).resolver(node);\\n\\t\\tif (resolver != address(0)) return fancy(ViewMulticall(resolver).multicall(this.makeCalls(node)));\\n\\t\\tresolver = ENS(ENS_REGISTRY).resolver(node0);\\n\\t\\t(bool ok, bytes memory v) = resolver.staticcall(abi.encodeCall(IExtendedResolver.resolve, (\\n\\t\\t\\tabi.encodePacked(uint8(bytes(tick).length), tick, basename), \\n\\t\\t\\tabi.encodeCall(ViewMulticall.multicall, (this.makeCalls(node)))\\n\\t\\t)));\\n\\t\\tif (ok) return fancy(abi.decode(v, (bytes[]))); \\n\\t\\tif (bytes4(v) != OffchainLookup.selector) assembly { revert(add(v, 32), mload(v)) }\\n\\t\\tassembly {\\n\\t\\t\\tmstore(add(v, 4), sub(mload(v), 4)) \\n\\t\\t\\tv := add(v, 4)\\n\\t\\t}\\n\\t\\t(, string[] memory urls, bytes memory callData, bytes4 callbackFunction, bytes memory extraData) = abi.decode(v, (address, string[], bytes, bytes4, bytes));\\n\\t\\trevert OffchainLookup(address(this), urls, callData, this.lookupCallback.selector, abi.encode(resolver, callbackFunction, extraData));\\n\\t}\\n\\tfunction lookupCallback(bytes calldata response, bytes calldata wrappedData) external view returns (KV[] memory) {\\n\\t\\t(address resolver, bytes4 callbackFunction, bytes memory extraData) = abi.decode(wrappedData, (address, bytes4, bytes));\\n\\t\\t(bool ok, bytes memory v) = resolver.staticcall(abi.encodeWithSelector(callbackFunction, response, extraData));\\n\\t\\tif (!ok) assembly { revert(add(v, 32), mload(v)) }\\n\\t\\treturn fancy(abi.decode(abi.decode(v, (bytes)), (bytes[])));\\n\\t}\\n\\n\\tfunction fancy(bytes[] memory values) internal view returns (KV[] memory kv) {\\n\\t\\tunchecked {\\n\\t\\t\\tstring[] memory names = fieldNames();\\n\\t\\t\\trequire(values.length == names.length, \\\"mod\\\");\\n\\t\\t\\tuint256 n;\\n\\t\\t\\tkv = new KV[](values.length);\\n\\t\\t\\tfor (uint256 i; i < values.length; i += 1) {\\n\\t\\t\\t\\tbytes memory v = abi.decode(values[i], (bytes));\\n\\t\\t\\t\\tif (v.length == 0) continue;\\n\\t\\t\\t\\tbytes memory f = _fields[uint256(bytes32(_fields[i])) >> 8];\\n\\t\\t\\t\\tkv[n] = KV(names[i], uint8(f[0]) == KIND_TEXT ? string(v) : toHex(v));\\n\\t\\t\\t\\tn += 1;\\n\\t\\t\\t}\\n\\t\\t\\tassembly { mstore(kv, n) } \\n\\t\\t}\\n\\t}\\n\\n\\tbytes32 constant RADIX = 0x3031323334353637383961626364656600000000000000000000000000000000;\\n\\tfunction toHex(bytes memory v) internal pure returns (string memory) {\\n\\t\\tunchecked {\\n\\t\\t\\tbytes memory u = new bytes((v.length + 1) << 1);\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tmstore8(add(u, 32), 0x30) // 0\\n\\t\\t\\t\\tmstore8(add(u, 33), 0x78) // x\\n\\t\\t\\t\\tlet i := v\\n\\t\\t\\t\\tlet e := add(i, mload(v))\\n\\t\\t\\t\\tlet j := add(u, 34)\\n\\t\\t\\t\\tfor {} lt(i, e) {} {\\n\\t\\t\\t\\t\\ti := add(i, 1) \\n\\t\\t\\t\\t\\tlet b := mload(i)\\n\\t\\t\\t\\t\\tmstore8(j, byte(and(shr(4, b), 15), RADIX))\\n\\t\\t\\t\\t\\tj := add(j, 1)\\n\\t\\t\\t\\t\\tmstore8(j, byte(and(b, 15), RADIX))\\n\\t\\t\\t\\t\\tj := add(j, 1)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn string(u);\\n\\t\\t}\\n\\t}\\n\\n}\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/wrapper/BytesUtils.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ~0.8.17;\\n\\nlibrary BytesUtils {\\n    /*\\n     * @dev Returns the keccak-256 hash of a byte range.\\n     * @param self The byte string to hash.\\n     * @param offset The position to start hashing at.\\n     * @param len The number of bytes to hash.\\n     * @return The hash of the byte range.\\n     */\\n    function keccak(\\n        bytes memory self,\\n        uint256 offset,\\n        uint256 len\\n    ) internal pure returns (bytes32 ret) {\\n        require(offset + len <= self.length);\\n        assembly {\\n            ret := keccak256(add(add(self, 32), offset), len)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the ENS namehash of a DNS-encoded name.\\n     * @param self The DNS-encoded name to hash.\\n     * @param offset The offset at which to start hashing.\\n     * @return The namehash of the name.\\n     */\\n    function namehash(\\n        bytes memory self,\\n        uint256 offset\\n    ) internal pure returns (bytes32) {\\n        (bytes32 labelhash, uint256 newOffset) = readLabel(self, offset);\\n        if (labelhash == bytes32(0)) {\\n            require(offset == self.length - 1, \\\"namehash: Junk at end of name\\\");\\n            return bytes32(0);\\n        }\\n        return\\n            keccak256(abi.encodePacked(namehash(self, newOffset), labelhash));\\n    }\\n\\n    /**\\n     * @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.\\n     * @param self The byte string to read a label from.\\n     * @param idx The index to read a label at.\\n     * @return labelhash The hash of the label at the specified index, or 0 if it is the last label.\\n     * @return newIdx The index of the start of the next label.\\n     */\\n    function readLabel(\\n        bytes memory self,\\n        uint256 idx\\n    ) internal pure returns (bytes32 labelhash, uint256 newIdx) {\\n        require(idx < self.length, \\\"readLabel: Index out of bounds\\\");\\n        uint256 len = uint256(uint8(self[idx]));\\n        if (len > 0) {\\n            labelhash = keccak(self, idx + 1, len);\\n        } else {\\n            labelhash = bytes32(0);\\n        }\\n        newIdx = idx + len + 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IContentHashResolver {\\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\\n\\n    /**\\n     * Returns the contenthash associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function contenthash(bytes32 node) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ITextResolver {\\n    event TextChanged(\\n        bytes32 indexed node,\\n        string indexed indexedKey,\\n        string key,\\n        string value\\n    );\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(\\n        bytes32 node,\\n        string calldata key\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/**\\n * Interface for the new (multicoin) addr function.\\n */\\ninterface IAddressResolver {\\n    event AddressChanged(\\n        bytes32 indexed node,\\n        uint256 coinType,\\n        bytes newAddress\\n    );\\n\\n    function addr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data\\n    ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.4;\\n\\ninterface ENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.8.2/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.8.2/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.8.2/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"urls\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunction\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"OffchainLookup\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"dnsname\",\"type\":\"bytes\"}],\"name\":\"BasenameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FieldsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"},{\"internalType\":\"uint64[]\",\"name\":\"coinTypes\",\"type\":\"uint64[]\"}],\"name\":\"addCoins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"name\":\"addText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basename\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fieldNames\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"}],\"name\":\"lookup\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"k\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"v\",\"type\":\"string\"}],\"internalType\":\"struct TNS.KV[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"wrappedData\",\"type\":\"bytes\"}],\"name\":\"lookupCallback\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"k\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"v\",\"type\":\"string\"}],\"internalType\":\"struct TNS.KV[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"makeCalls\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"fs\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"removeFieldAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"dnsname\",\"type\":\"bytes\"}],\"name\":\"setBasename\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"x\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TNS", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}