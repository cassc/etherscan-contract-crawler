{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lib/Checkpoints.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/* *\\n * Copyright 2021-2023 LI LI @ JINGTIAN & GONGCHENG.\\n * All Rights Reserved.\\n * */\\n\\npragma solidity ^0.8.8;\\n\\nlibrary Checkpoints {\\n\\n    struct Checkpoint {\\n        uint48 timestamp;\\n        uint16 votingWeight;\\n        uint64 paid;\\n        uint64 par;\\n        uint64 cleanPaid;\\n    }\\n\\n    struct History {\\n        // checkpoints[0].timestamp : counter\\n        mapping (uint256 => Checkpoint) checkpoints;\\n    }\\n\\n    //##################\\n    //##  Write I/O  ##\\n    //##################\\n\\n    function push(\\n        History storage self,\\n        uint weight,\\n        uint paid,\\n        uint par,\\n        uint cleanPaid\\n    ) public {\\n\\n        uint256 pos = counterOfPoints(self);\\n\\n        uint48 timestamp = uint48 (block.timestamp);\\n\\n        Checkpoint memory point = Checkpoint({\\n            timestamp: timestamp,\\n            votingWeight: uint16(weight),\\n            paid: uint64(paid),\\n            par: uint64(par),\\n            cleanPaid: uint64(cleanPaid)\\n        });\\n\\n        if (self.checkpoints[pos].timestamp == timestamp) {\\n            self.checkpoints[pos] = point;\\n        } else {\\n            self.checkpoints[pos+1] = point;\\n            _increaseCounter(self);\\n        }\\n    }\\n\\n    function _increaseCounter(History storage self)\\n        public\\n    {\\n        self.checkpoints[0].timestamp++;\\n    }\\n\\n    //##################\\n    //##    \u8bfb\u63a5\u53e3    ##\\n    //##################\\n\\n    function counterOfPoints(History storage self)\\n        public view returns (uint256)\\n    {\\n        return self.checkpoints[0].timestamp;\\n    }\\n\\n    function latest(History storage self)\\n        public view returns (Checkpoint memory point)\\n    {\\n        point = self.checkpoints[counterOfPoints(self)];\\n    }\\n\\n    function _average(uint256 a, uint256 b) private pure returns (uint256) {\\n        return (a & b) + ((a ^ b) >> 1);\\n    }\\n\\n    function getAtDate(History storage self, uint256 timestamp)\\n        public view returns (Checkpoint memory point)\\n    {\\n        require(\\n            timestamp <= block.timestamp,\\n            \\\"Checkpoints: block not yet mined\\\"\\n        );\\n\\n        uint256 high = counterOfPoints(self) + 1;\\n        uint256 low = 1;\\n        while (low < high) {\\n            uint256 mid = _average(low, high);\\n            if (self.checkpoints[mid].timestamp > timestamp) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        if (high > 1) point = self.checkpoints[high - 1];\\n    }\\n\\n    function pointsOfHistory(History storage self)\\n        public view returns (Checkpoint[] memory) \\n    {\\n        uint256 len = counterOfPoints(self);\\n\\n        Checkpoint[] memory output = new Checkpoint[](len);\\n\\n        while (len > 0) {\\n            output[len-1] = self.checkpoints[len];\\n            len--;\\n        }\\n\\n        return output;\\n    }\\n    \\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[]", "ContractName": "Checkpoints", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}