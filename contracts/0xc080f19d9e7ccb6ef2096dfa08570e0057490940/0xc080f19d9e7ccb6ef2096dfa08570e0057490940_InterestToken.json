{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/InterestToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/ERC20Permit.sol\\\";\\nimport \\\"./libraries/DateString.sol\\\";\\n\\nimport \\\"./interfaces/IInterestToken.sol\\\";\\nimport \\\"./interfaces/ITranche.sol\\\";\\n\\ncontract InterestToken is ERC20Permit, IInterestToken {\\n    // The tranche address which controls the minting\\n    ITranche public immutable tranche;\\n\\n    /// @dev Initializes the ERC20 and writes the correct names\\n    /// @param _tranche The tranche contract address\\n    /// @param _strategySymbol The symbol of the associated WrappedPosition contract\\n    /// @param _timestamp The unlock time on the tranche\\n    /// @param _decimals The decimal encoding for this token\\n    constructor(\\n        address _tranche,\\n        string memory _strategySymbol,\\n        uint256 _timestamp,\\n        uint8 _decimals\\n    )\\n        ERC20Permit(\\n            _processName(\\\"Element Yield Token \\\", _strategySymbol, _timestamp),\\n            _processSymbol(\\\"eY\\\", _strategySymbol, _timestamp)\\n        )\\n    {\\n        tranche = ITranche(_tranche);\\n        _setupDecimals(_decimals);\\n    }\\n\\n    /// @notice We use this function to add the date to the name string\\n    /// @param _name start of the name\\n    /// @param _strategySymbol the strategy symbol\\n    /// @param _timestamp the unix second timestamp to be encoded and added to the end of the string\\n    function _processName(\\n        string memory _name,\\n        string memory _strategySymbol,\\n        uint256 _timestamp\\n    ) internal returns (string memory) {\\n        // Set the name in the super\\n        name = _name;\\n        // Use the library to write the rest\\n        DateString._encodeAndWriteTimestamp(_strategySymbol, _timestamp, name);\\n        // load and return the name\\n        return name;\\n    }\\n\\n    /// @notice We use this function to add the date to the name string\\n    /// @param _symbol start of the symbol\\n    /// @param _strategySymbol the strategy symbol\\n    /// @param _timestamp the unix second timestamp to be encoded and added to the end of the string\\n    function _processSymbol(\\n        string memory _symbol,\\n        string memory _strategySymbol,\\n        uint256 _timestamp\\n    ) internal returns (string memory) {\\n        // Set the symbol in the super\\n        symbol = _symbol;\\n        // Use the library to write the rest\\n        DateString._encodeAndWriteTimestamp(\\n            _strategySymbol,\\n            _timestamp,\\n            symbol\\n        );\\n        // load and return the name\\n        return symbol;\\n    }\\n\\n    /// @dev Aliasing of the lookup method for the supply of yield tokens which\\n    ///      improves our ERC20 compatibility.\\n    /// @return The total supply of yield tokens\\n    function totalSupply() external view returns (uint256) {\\n        return uint256(tranche.interestSupply());\\n    }\\n\\n    /// @dev Prevents execution if the caller isn't the tranche\\n    modifier onlyMintAuthority() {\\n        require(\\n            msg.sender == address(tranche),\\n            \\\"caller is not an authorized minter\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @dev Mints tokens to an address\\n    /// @param _account The account to mint to\\n    /// @param _amount The amount to mint\\n    function mint(address _account, uint256 _amount)\\n        external\\n        override\\n        onlyMintAuthority\\n    {\\n        _mint(_account, _amount);\\n    }\\n\\n    /// @dev Burns tokens from an address\\n    /// @param _account The account to burn from\\n    /// @param _amount The amount of token to burn\\n    function burn(address _account, uint256 _amount)\\n        external\\n        override\\n        onlyMintAuthority\\n    {\\n        _burn(_account, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\n\\n// This default erc20 library is designed for max efficiency and security.\\n// WARNING: By default it does not include totalSupply which breaks the ERC20 standard\\n//          to use a fully standard compliant ERC20 use 'ERC20PermitWithSupply\\\"\\nabstract contract ERC20Permit is IERC20Permit {\\n    // --- ERC20 Data ---\\n    // The name of the erc20 token\\n    string public name;\\n    // The symbol of the erc20 token\\n    string public override symbol;\\n    // The decimals of the erc20 token, should default to 18 for new tokens\\n    uint8 public override decimals;\\n\\n    // A mapping which tracks user token balances\\n    mapping(address => uint256) public override balanceOf;\\n    // A mapping which tracks which addresses a user allows to move their tokens\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n    // A mapping which tracks the permit signature nonces for users\\n    mapping(address => uint256) public override nonces;\\n\\n    // --- EIP712 niceties ---\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 public override DOMAIN_SEPARATOR;\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32\\n        public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// @notice Initializes the erc20 contract\\n    /// @param name_ the value 'name' will be set to\\n    /// @param symbol_ the value 'symbol' will be set to\\n    /// @dev decimals default to 18 and must be reset by an inheriting contract for\\n    ///      non standard decimal values\\n    constructor(string memory name_, string memory symbol_) {\\n        // Set the state variables\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = 18;\\n\\n        // By setting these addresses to 0 attempting to execute a transfer to\\n        // either of them will revert. This is a gas efficient way to prevent\\n        // a common user mistake where they transfer to the token address.\\n        // These values are not considered 'real' tokens and so are not included\\n        // in 'total supply' which only contains minted tokens.\\n        balanceOf[address(0)] = type(uint256).max;\\n        balanceOf[address(this)] = type(uint256).max;\\n\\n        // Optional extra state manipulation\\n        _extraConstruction();\\n\\n        // Computes the EIP 712 domain separator which prevents user signed messages for\\n        // this contract to be replayed in other contracts.\\n        // https://eips.ethereum.org/EIPS/eip-712\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @notice An optional override function to execute and change state before immutable assignment\\n    function _extraConstruction() internal virtual {}\\n\\n    // --- Token ---\\n    /// @notice Allows a token owner to send tokens to another address\\n    /// @param recipient The address which will be credited with the tokens\\n    /// @param amount The amount user token to send\\n    /// @return returns true on success, reverts on failure so cannot return false.\\n    /// @dev transfers to this contract address or 0 will fail\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        // We forward this call to 'transferFrom'\\n        return transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n    /// @notice Transfers an amount of erc20 from a spender to a receipt\\n    /// @param spender The source of the ERC20 tokens\\n    /// @param recipient The destination of the ERC20 tokens\\n    /// @param amount the number of tokens to send\\n    /// @return returns true on success and reverts on failure\\n    /// @dev will fail transfers which send funds to this contract or 0\\n    function transferFrom(\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        // Load balance and allowance\\n        uint256 balance = balanceOf[spender];\\n        require(balance >= amount, \\\"ERC20: insufficient-balance\\\");\\n        // We potentially have to change allowances\\n        if (spender != msg.sender) {\\n            // Loading the allowance in the if block prevents vanilla transfers\\n            // from paying for the sload.\\n            uint256 allowed = allowance[spender][msg.sender];\\n            // If the allowance is max we do not reduce it\\n            // Note - This means that max allowances will be more gas efficient\\n            // by not requiring a sstore on 'transferFrom'\\n            if (allowed != type(uint256).max) {\\n                require(allowed >= amount, \\\"ERC20: insufficient-allowance\\\");\\n                allowance[spender][msg.sender] = allowed - amount;\\n            }\\n        }\\n        // Update the balances\\n        balanceOf[spender] = balance - amount;\\n        // Note - In the constructor we initialize the 'balanceOf' of address 0 and\\n        //        the token address to uint256.max and so in 8.0 transfers to those\\n        //        addresses revert on this step.\\n        balanceOf[recipient] = balanceOf[recipient] + amount;\\n        // Emit the needed event\\n        emit Transfer(spender, recipient, amount);\\n        // Return that this call succeeded\\n        return true;\\n    }\\n\\n    /// @notice This internal minting function allows inheriting contracts\\n    ///         to mint tokens in the way they wish.\\n    /// @param account the address which will receive the token.\\n    /// @param amount the amount of token which they will receive\\n    /// @dev This function is virtual so that it can be overridden, if you\\n    ///      are reviewing this contract for security you should ensure to\\n    ///      check for overrides\\n    function _mint(address account, uint256 amount) internal virtual {\\n        // Add tokens to the account\\n        balanceOf[account] = balanceOf[account] + amount;\\n        // Emit an event to track the minting\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /// @notice This internal burning function allows inheriting contracts to\\n    ///         burn tokens in the way they see fit.\\n    /// @param account the account to remove tokens from\\n    /// @param amount  the amount of tokens to remove\\n    /// @dev This function is virtual so that it can be overridden, if you\\n    ///      are reviewing this contract for security you should ensure to\\n    ///      check for overrides\\n    function _burn(address account, uint256 amount) internal virtual {\\n        // Reduce the balance of the account\\n        balanceOf[account] = balanceOf[account] - amount;\\n        // Emit an event tracking transfers\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /// @notice This function allows a user to approve an account which can transfer\\n    ///         tokens on their behalf.\\n    /// @param account The account which will be approve to transfer tokens\\n    /// @param amount The approval amount, if set to uint256.max the allowance does not go down on transfers.\\n    /// @return returns true for compatibility with the ERC20 standard\\n    function approve(address account, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        // Set the senders allowance for account to amount\\n        allowance[msg.sender][account] = amount;\\n        // Emit an event to track approvals\\n        emit Approval(msg.sender, account, amount);\\n        return true;\\n    }\\n\\n    /// @notice This function allows a caller who is not the owner of an account to execute the functionality of 'approve' with the owners signature.\\n    /// @param owner the owner of the account which is having the new approval set\\n    /// @param spender the address which will be allowed to spend owner's tokens\\n    /// @param value the new allowance value\\n    /// @param deadline the timestamp which the signature must be submitted by to be valid\\n    /// @param v Extra ECDSA data which allows public key recovery from signature assumed to be 27 or 28\\n    /// @param r The r component of the ECDSA signature\\n    /// @param s The s component of the ECDSA signature\\n    /// @dev The signature for this function follows EIP 712 standard and should be generated with the\\n    ///      eth_signTypedData JSON RPC call instead of the eth_sign JSON RPC call. If using out of date\\n    ///      parity signing libraries the v component may need to be adjusted. Also it is very rare but possible\\n    ///      for v to be other values, those values are not supported.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        // The EIP 712 digest for this function\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner],\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        // Require that the owner is not zero\\n        require(owner != address(0), \\\"ERC20: invalid-address-0\\\");\\n        // Require that we have a valid signature from the owner\\n        require(owner == ecrecover(digest, v, r, s), \\\"ERC20: invalid-permit\\\");\\n        // Require that the signature is not expired\\n        require(\\n            deadline == 0 || block.timestamp <= deadline,\\n            \\\"ERC20: permit-expired\\\"\\n        );\\n        // Format the signature to the default format\\n        require(\\n            uint256(s) <=\\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"ERC20: invalid signature 's' value\\\"\\n        );\\n        // Increment the signature nonce to prevent replay\\n        nonces[owner]++;\\n        // Set the allowance to the new value\\n        allowance[owner][spender] = value;\\n        // Emit an approval event to be able to track this happening\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /// @notice Internal function which allows inheriting contract to set custom decimals\\n    /// @param decimals_ the new decimal value\\n    function _setupDecimals(uint8 decimals_) internal {\\n        // Set the decimals\\n        decimals = decimals_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DateString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nlibrary DateString {\\n    uint256 public constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 public constant SECONDS_PER_HOUR = 60 * 60;\\n    uint256 public constant SECONDS_PER_MINUTE = 60;\\n    int256 public constant OFFSET19700101 = 2440588;\\n\\n    // This function was forked from https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    function _daysToDate(uint256 _days)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        int256 __days = int256(_days);\\n        // solhint-disable-next-line var-name-mixedcase\\n        int256 L = __days + 68569 + OFFSET19700101;\\n        // solhint-disable-next-line var-name-mixedcase\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n\\n    /// @dev Writes a prefix and an timestamp encoding to an output storage location\\n    ///      This function is designed to only work with ASCII encoded strings. No emojis please.\\n    /// @param _prefix The string to write before the timestamp\\n    /// @param _timestamp the timestamp to encode and store\\n    /// @param _output the storage location of the output string\\n    /// NOTE - Current cost ~90k if gas is problem revisit and use assembly to remove the extra\\n    ///        sstore s.\\n    function encodeAndWriteTimestamp(\\n        string memory _prefix,\\n        uint256 _timestamp,\\n        string storage _output\\n    ) external {\\n        _encodeAndWriteTimestamp(_prefix, _timestamp, _output);\\n    }\\n\\n    /// @dev Sn internal version of the above function 'encodeAndWriteTimestamp'\\n    // solhint-disable-next-line\\n    function _encodeAndWriteTimestamp(\\n        string memory _prefix,\\n        uint256 _timestamp,\\n        string storage _output\\n    ) internal {\\n        // Cast the prefix string to a byte array\\n        bytes memory bytePrefix = bytes(_prefix);\\n        // Cast the output string to a byte array\\n        bytes storage bytesOutput = bytes(_output);\\n        // Copy the bytes from the prefix onto the byte array\\n        // NOTE - IF PREFIX CONTAINS NON-ASCII CHARS THIS WILL CAUSE AN INCORRECT STRING LENGTH\\n        for (uint256 i = 0; i < bytePrefix.length; i++) {\\n            bytesOutput.push(bytePrefix[i]);\\n        }\\n        // Add a '-' to the string to separate the prefix from the the date\\n        bytesOutput.push(bytes1(\\\"-\\\"));\\n        // Add the date string\\n        timestampToDateString(_timestamp, _output);\\n    }\\n\\n    /// @dev Converts a unix second encoded timestamp to a date format (year, month, day)\\n    ///      then writes the string encoding of that to the output pointer.\\n    /// @param _timestamp the unix seconds timestamp\\n    /// @param _outputPointer the storage pointer to change.\\n    function timestampToDateString(\\n        uint256 _timestamp,\\n        string storage _outputPointer\\n    ) public {\\n        _timestampToDateString(_timestamp, _outputPointer);\\n    }\\n\\n    /// @dev Sn internal version of the above function 'timestampToDateString'\\n    // solhint-disable-next-line\\n    function _timestampToDateString(\\n        uint256 _timestamp,\\n        string storage _outputPointer\\n    ) internal {\\n        // We pretend the string is a 'bytes' only push UTF8 encodings to it\\n        bytes storage output = bytes(_outputPointer);\\n        // First we get the day month and year\\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\\n            _timestamp / SECONDS_PER_DAY\\n        );\\n        // First we add encoded day to the string\\n        {\\n            // Round out the second digit\\n            uint256 firstDigit = day / 10;\\n            // add it to the encoded byte for '0'\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(firstDigit)));\\n            // Extract the second digit\\n            uint256 secondDigit = day % 10;\\n            // add it to the string\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(secondDigit)));\\n        }\\n        // Next we encode the month string and add it\\n        if (month == 1) {\\n            stringPush(output, \\\"J\\\", \\\"A\\\", \\\"N\\\");\\n        } else if (month == 2) {\\n            stringPush(output, \\\"F\\\", \\\"E\\\", \\\"B\\\");\\n        } else if (month == 3) {\\n            stringPush(output, \\\"M\\\", \\\"A\\\", \\\"R\\\");\\n        } else if (month == 4) {\\n            stringPush(output, \\\"A\\\", \\\"P\\\", \\\"R\\\");\\n        } else if (month == 5) {\\n            stringPush(output, \\\"M\\\", \\\"A\\\", \\\"Y\\\");\\n        } else if (month == 6) {\\n            stringPush(output, \\\"J\\\", \\\"U\\\", \\\"N\\\");\\n        } else if (month == 7) {\\n            stringPush(output, \\\"J\\\", \\\"U\\\", \\\"L\\\");\\n        } else if (month == 8) {\\n            stringPush(output, \\\"A\\\", \\\"U\\\", \\\"G\\\");\\n        } else if (month == 9) {\\n            stringPush(output, \\\"S\\\", \\\"E\\\", \\\"P\\\");\\n        } else if (month == 10) {\\n            stringPush(output, \\\"O\\\", \\\"C\\\", \\\"T\\\");\\n        } else if (month == 11) {\\n            stringPush(output, \\\"N\\\", \\\"O\\\", \\\"V\\\");\\n        } else if (month == 12) {\\n            stringPush(output, \\\"D\\\", \\\"E\\\", \\\"C\\\");\\n        } else {\\n            revert(\\\"date decoding error\\\");\\n        }\\n        // We take the last two digits of the year\\n        // Hopefully that's enough\\n        {\\n            uint256 lastDigits = year % 100;\\n            // Round out the second digit\\n            uint256 firstDigit = lastDigits / 10;\\n            // add it to the encoded byte for '0'\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(firstDigit)));\\n            // Extract the second digit\\n            uint256 secondDigit = lastDigits % 10;\\n            // add it to the string\\n            output.push(bytes1(uint8(bytes1(\\\"0\\\")) + uint8(secondDigit)));\\n        }\\n    }\\n\\n    function stringPush(\\n        bytes storage output,\\n        bytes1 data1,\\n        bytes1 data2,\\n        bytes1 data3\\n    ) internal {\\n        output.push(data1);\\n        output.push(data2);\\n        output.push(data3);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterestToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\n\\ninterface IInterestToken is IERC20Permit {\\n    function mint(address _account, uint256 _amount) external;\\n\\n    function burn(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITranche.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"./IInterestToken.sol\\\";\\n\\ninterface ITranche is IERC20Permit {\\n    function deposit(uint256 _shares, address destination)\\n        external\\n        returns (uint256, uint256);\\n\\n    function prefundedDeposit(address _destination)\\n        external\\n        returns (uint256, uint256);\\n\\n    function withdrawPrincipal(uint256 _amount, address _destination)\\n        external\\n        returns (uint256);\\n\\n    function withdrawInterest(uint256 _amount, address _destination)\\n        external\\n        returns (uint256);\\n\\n    function interestToken() external view returns (IInterestToken);\\n\\n    function interestSupply() external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// Forked from openzepplin\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    function symbol() external view returns (string memory);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\\n    function decimals() external view returns (uint8);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 7500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tranche\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_strategySymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tranche\",\"outputs\":[{\"internalType\":\"contract ITranche\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "InterestToken", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "7500", "ConstructorArguments": "000000000000000000000000237535da7e2f0aba1b68262abcf7c4e60b42600c000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000611887bc0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000e797643727654726943727970746f000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}