{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/CometWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ERC4626} from \\\"solmate/mixins/ERC4626.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {CometInterface, TotalsBasic} from \\\"./vendor/CometInterface.sol\\\";\\nimport {CometHelpers} from \\\"./CometHelpers.sol\\\";\\nimport {ICometRewards} from \\\"./vendor/ICometRewards.sol\\\";\\n\\n/// @notice A vault contract that accepts deposits of a Comet token like cUSDCv3 as an asset\\n/// and mints shares which are the Wrapped Comet token.\\ncontract CometWrapper is ERC4626, CometHelpers {\\n    using SafeTransferLib for ERC20;\\n\\n    struct UserBasic {\\n        uint64 baseTrackingAccrued;\\n        uint64 baseTrackingIndex;\\n    }\\n\\n    mapping(address => UserBasic) public userBasic;\\n    mapping(address => uint256) public rewardsClaimed;\\n\\n    CometInterface public immutable comet;\\n    ICometRewards public immutable cometRewards;\\n    uint256 public immutable trackingIndexScale;\\n    uint256 internal immutable accrualDescaleFactor;\\n\\n    constructor(ERC20 _asset, ICometRewards _cometRewards, string memory _name, string memory _symbol)\\n        ERC4626(_asset, _name, _symbol)\\n    {\\n        if (address(_cometRewards) == address(0)) revert ZeroAddress();\\n        // minimal validation that contract is CometRewards\\n        _cometRewards.rewardConfig(address(_asset));\\n\\n        comet = CometInterface(address(_asset));\\n        cometRewards = _cometRewards;\\n        trackingIndexScale = comet.trackingIndexScale();\\n        accrualDescaleFactor = uint64(10 ** asset.decimals()) / BASE_ACCRUAL_SCALE;\\n    }\\n\\n    /// @notice Returns total assets managed by the vault\\n    /// @return total assets\\n    function totalAssets() public view override returns (uint256) {\\n        uint64 baseSupplyIndex_ = accruedSupplyIndex();\\n        uint256 supply = totalSupply;\\n        return supply > 0 ? presentValueSupply(baseSupplyIndex_, supply) : 0;\\n    }\\n\\n    /// @notice Deposits assets into the vault and gets shares (Wrapped Comet token) in return\\n    /// @param assets The amount of assets to be deposited by the caller\\n    /// @param receiver The recipient address of the minted shares\\n    /// @return shares The amount of shares that are minted to the receiver\\n    function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {\\n        if (assets == 0) revert ZeroAssets();\\n\\n        accrueInternal(receiver);\\n        int104 prevPrincipal = comet.userBasic(address(this)).principal;\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n        shares = unsigned256(comet.userBasic(address(this)).principal - prevPrincipal);\\n        if (shares == 0) revert ZeroShares();\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n    }\\n\\n    /// @notice Mints shares (Wrapped Comet) in exchange for Comet tokens\\n    /// @param shares The amount of shares to be minted for the receive\\n    /// @param receiver The recipient address of the minted shares\\n    /// @return assets The amount of assets that are deposited by the caller\\n    function mint(uint256 shares, address receiver) public override returns (uint256 assets) {\\n        if (shares == 0) revert ZeroShares();\\n        assets = convertToAssets(shares);\\n        if (assets == 0) revert ZeroAssets();\\n\\n        accrueInternal(receiver);\\n        int104 prevPrincipal = comet.userBasic(address(this)).principal;\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n        shares =  unsigned256(comet.userBasic(address(this)).principal - prevPrincipal);\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n    }\\n\\n    /// @notice Withdraws assets (Comet) from the vault and burns corresponding shares (Wrapped Comet).\\n    /// Caller can only withdraw assets from owner if they have been given allowance to.\\n    /// @param assets The amount of assets to be withdrawn by the caller\\n    /// @param receiver The recipient address of the withdrawn assets\\n    /// @param owner The owner of the assets to be withdrawn\\n    /// @return shares The amount of shares of the owner that are burned\\n    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {\\n        if (assets == 0) revert ZeroAssets();\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender];\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        accrueInternal(owner);\\n        int104 prevPrincipal = comet.userBasic(address(this)).principal;\\n        asset.safeTransfer(receiver, assets);\\n        shares =  unsigned256(prevPrincipal - comet.userBasic(address(this)).principal);\\n        if (shares == 0) revert ZeroShares();\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n    }\\n\\n    /// @notice Redeems shares (Wrapped Comet) in exchange for assets (Wrapped Comet).\\n    /// Caller can only withdraw assets from owner if they have been given allowance to.\\n    /// @param shares The amount of shares to be redeemed\\n    /// @param receiver The recipient address of the withdrawn assets\\n    /// @param owner The owner of the shares to be redeemed\\n    /// @return assets The amount of assets that is withdrawn and sent to the receiver\\n    function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {\\n        if (shares == 0) revert ZeroShares();\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n        // Asset transfers in Comet may lead to decrease of this contract's principal/shares by 1 more than the \\n        // `shares` argument. Taking into account this quirk in Comet's transfer logic, we always decrease `shares`\\n        // by 1 before converting to assets and doing the transfer. We then proceed to burn the actual `shares` amount\\n        // that was decreased during the Comet transfer. \\n        // In this way, any rounding error would be in favor of CometWrapper and CometWrapper will be protected\\n        // from insolvency due to lack of assets that can be withdrawn by users.\\n        assets = convertToAssets(shares-1);\\n        if (assets == 0) revert ZeroAssets();\\n\\n        accrueInternal(owner);\\n        int104 prevPrincipal = comet.userBasic(address(this)).principal;\\n        asset.safeTransfer(receiver, assets);\\n        shares =  unsigned256(prevPrincipal - comet.userBasic(address(this)).principal);\\n        if (shares == 0) revert ZeroShares();\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n    }\\n\\n    /// @notice Transfer shares from caller to the recipient\\n    /// @param to The receiver of the shares (Wrapped Comet) to be transferred\\n    /// @param amount The amount of shares to be transferred\\n    /// @return bool Indicates success of the transfer\\n    function transfer(address to, uint256 amount) public override returns (bool) {\\n        transferInternal(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @notice Transfer shares from a specified source to a recipient\\n    /// @param from The source of the shares to be transferred\\n    /// @param to The receiver of the shares (Wrapped Comet) to be transferred\\n    /// @param amount The amount of shares to be transferred\\n    /// @return bool Indicates success of the transfer\\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\\n        uint256 allowed = msg.sender == from ? type(uint256).max : allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed < amount) revert LackAllowance();\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        transferInternal(from, to, amount);\\n        return true;\\n    }\\n\\n    function transferInternal(address from, address to, uint256 amount) internal {\\n        // Accrue rewards before transferring assets\\n        comet.accrueAccount(address(this));\\n        updateTrackingIndex(from);\\n        updateTrackingIndex(to);\\n\\n        balanceOf[from] -= amount;\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /// @notice Total assets of an account that are managed by this vault\\n    /// @dev The asset balance is computed from an account's shares balance which mirrors how Comet\\n    /// computes token balances. This is done this way since balances are ever-increasing due to \\n    /// interest accrual.\\n    /// @param account The address to be queried\\n    /// @return The total amount of assets held by an account\\n    function underlyingBalance(address account) public view returns (uint256) {\\n        uint64 baseSupplyIndex_ = accruedSupplyIndex();\\n        uint256 principal = balanceOf[account];\\n        return principal > 0 ? presentValueSupply(baseSupplyIndex_, principal) : 0;\\n    }\\n\\n    /// @dev Updates an account's `baseTrackingAccrued` which keeps track of rewards accrued by the account.\\n    /// This uses the latest `trackingSupplyIndex` from Comet to compute for rewards accrual for accounts\\n    /// that supply the base asset to Comet.\\n    function updateTrackingIndex(address account) internal {\\n        UserBasic memory basic = userBasic[account];\\n        uint256 principal = balanceOf[account];\\n        (, uint64 trackingSupplyIndex,) = getSupplyIndices();\\n\\n        if (principal >= 0) {\\n            uint256 indexDelta = uint256(trackingSupplyIndex - basic.baseTrackingIndex);\\n            basic.baseTrackingAccrued +=\\n                safe64(principal * indexDelta / trackingIndexScale / accrualDescaleFactor);\\n        }\\n        basic.baseTrackingIndex = trackingSupplyIndex;\\n        userBasic[account] = basic;\\n    }\\n\\n    function accrueInternal(address account) internal {\\n        comet.accrueAccount(address(this));\\n        updateTrackingIndex(account);\\n    }\\n\\n    /// @notice Get the reward owed to an account\\n    /// @dev This is designed to exactly match computation of rewards in Comet\\n    /// and uses the same configuration as CometRewards. It is a combination of both\\n    /// [`getRewardOwed`](https://github.com/compound-finance/comet/blob/63e98e5d231ef50c755a9489eb346a561fc7663c/contracts/CometRewards.sol#L110) and [`getRewardAccrued`](https://github.com/compound-finance/comet/blob/63e98e5d231ef50c755a9489eb346a561fc7663c/contracts/CometRewards.sol#L171).\\n    /// @param account The address to be queried\\n    /// @return The total amount of rewards owed to an account\\n    function getRewardOwed(address account) external returns (uint256) {\\n        ICometRewards.RewardConfig memory config = cometRewards.rewardConfig(address(comet));\\n        return getRewardOwedInternal(config, account);\\n    }\\n\\n    function getRewardOwedInternal(ICometRewards.RewardConfig memory config, address account) internal returns (uint256) {\\n        UserBasic memory basic = accrueRewards(account);\\n        uint256 claimed = rewardsClaimed[account];\\n        uint256 accrued = basic.baseTrackingAccrued;\\n\\n        if (config.shouldUpscale) {\\n            accrued *= config.rescaleFactor;\\n        } else {\\n            accrued /= config.rescaleFactor;\\n        }\\n\\n        uint256 owed = accrued > claimed ? accrued - claimed : 0;\\n\\n        return owed;\\n    }\\n\\n    /// @notice Claims caller's rewards and sends them to recipient\\n    /// @dev Always calls CometRewards for updated configs\\n    /// @param to The address that will receive the rewards\\n    function claimTo(address to) external {\\n        address from = msg.sender;\\n        ICometRewards.RewardConfig memory config = cometRewards.rewardConfig(address(comet));\\n        uint256 owed = getRewardOwedInternal(config, from);\\n\\n        if (owed != 0) {\\n            rewardsClaimed[from] += owed;\\n            emit RewardClaimed(from, to, config.token, owed);\\n            cometRewards.claimTo(address(comet), address(this), address(this), true);\\n            ERC20(config.token).safeTransfer(to, owed);\\n        }\\n    }\\n\\n    /// @notice Accrues rewards for the account\\n    /// @dev Latest trackingSupplyIndex is fetched from Comet so we can compute accurate rewards.\\n    /// This mirrors the logic for rewards accrual in CometRewards so we properly account for users'\\n    /// rewards as if they had used Comet directly.\\n    /// @param account The address to whose rewards we want to accrue\\n    /// @return The UserBasic struct with updated baseTrackingIndex and/or baseTrackingAccrued fields\\n    function accrueRewards(address account) public returns (UserBasic memory) {\\n        UserBasic memory basic = userBasic[account];\\n        uint256 principal = balanceOf[account];\\n        comet.accrueAccount(address(this));\\n        (, uint64 trackingSupplyIndex,) = getSupplyIndices();\\n\\n        if (principal >= 0) {\\n            uint256 indexDelta = uint256(trackingSupplyIndex - basic.baseTrackingIndex);\\n            basic.baseTrackingAccrued +=\\n                safe64((principal * indexDelta) / trackingIndexScale / accrualDescaleFactor);\\n        }\\n        basic.baseTrackingIndex = trackingSupplyIndex;\\n        userBasic[account] = basic;\\n\\n        return basic;\\n    }\\n\\n    /// @dev This returns latest baseSupplyIndex regardless of whether comet.accrueAccount has been called for the\\n    /// current block. This works like `Comet.accruedInterestedIndices` at but not including computation of\\n    /// `baseBorrowIndex` since we do not need that index in CometWrapper:\\n    /// https://github.com/compound-finance/comet/blob/63e98e5d231ef50c755a9489eb346a561fc7663c/contracts/Comet.sol#L383-L394\\n    function accruedSupplyIndex() internal view returns (uint64) {\\n        (uint64 baseSupplyIndex_,,uint40 lastAccrualTime) = getSupplyIndices();\\n        uint256 timeElapsed = uint256(getNowInternal() - lastAccrualTime);\\n        if (timeElapsed > 0) {\\n            uint256 utilization = comet.getUtilization();\\n            uint256 supplyRate = comet.getSupplyRate(utilization);\\n            baseSupplyIndex_ += safe64(mulFactor(baseSupplyIndex_, supplyRate * timeElapsed));\\n        }\\n        return baseSupplyIndex_;\\n    }\\n\\n    /// @dev To maintain accuracy, we fetch `baseSupplyIndex` and `trackingSupplyIndex` directly from Comet.\\n    /// baseSupplyIndex is used on the principal to get the user's latest balance including interest accruals.\\n    /// trackingSupplyIndex is used to compute for rewards accruals.\\n    function getSupplyIndices() internal view returns (uint64 baseSupplyIndex_, uint64 trackingSupplyIndex_, uint40 lastAccrualTime_) {\\n        TotalsBasic memory totals = comet.totalsBasic();\\n        baseSupplyIndex_ = totals.baseSupplyIndex;\\n        trackingSupplyIndex_ = totals.trackingSupplyIndex;\\n        lastAccrualTime_ = totals.lastAccrualTime;\\n    }\\n\\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n    /// scenario where all the conditions are met.\\n    /// @dev Treats shares as principal and computes for assets by taking into account interest accrual. Relies on latest\\n    /// `baseSupplyIndex` from Comet which is the global index used for interest accrual the from supply rate. \\n    /// @param shares The amount of shares to be converted to assets\\n    /// @return The total amount of assets computed from the given shares\\n    function convertToAssets(uint256 shares) public view override returns (uint256) {\\n        uint64 baseSupplyIndex_ = accruedSupplyIndex();\\n        return shares > 0 ? presentValueSupply(baseSupplyIndex_, shares) : 0;\\n    }\\n\\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n    /// scenario where all the conditions are met.\\n    /// @dev Assets are converted to shares by computing for the principal using the latest `baseSupplyIndex` from Comet.\\n    /// @param assets The amount of assets to be converted to shares\\n    /// @return The total amount of shares computed from the given assets\\n    function convertToShares(uint256 assets) public view override returns (uint256) {\\n        uint64 baseSupplyIndex_ = accruedSupplyIndex();\\n        return assets > 0 ? principalValueSupply(baseSupplyIndex_, assets) : 0;\\n    }\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n    /// current on-chain conditions.\\n    /// @param shares The amount of shares to be converted to assets\\n    /// @return The total amount of assets required to mint the given shares\\n    function previewMint(uint256 shares) public view override returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n    /// given current on-chain conditions.\\n    /// @param assets The amount of assets to be converted to shares\\n    /// @return The total amount of shares required to withdraw the given assets\\n    function previewWithdraw(uint256 assets) public view override returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/mixins/ERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, from) // Append the \\\"from\\\" argument.\\n            mstore(36, to) // Append the \\\"to\\\" argument.\\n            mstore(68, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because that's the total length of our calldata (4 + 32 * 3)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 100, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/vendor/CometInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"./CometMainInterface.sol\\\";\\nimport \\\"./CometExtInterface.sol\\\";\\n\\n/**\\n * @title Compound's Comet Interface\\n * @notice An efficient monolithic money market protocol\\n * @author Compound\\n */\\nabstract contract CometInterface is CometMainInterface, CometExtInterface {\\n    struct UserBasic {\\n        int104 principal;\\n        uint64 baseTrackingIndex;\\n        uint64 baseTrackingAccrued;\\n        uint16 assetsIn;\\n        uint8 _reserved;\\n    }\\n\\n    function userBasic(address account) external view virtual returns (UserBasic memory);\\n\\n    struct TotalsCollateral {\\n        uint128 totalSupplyAsset;\\n        uint128 _reserved;\\n    }\\n\\n    function totalsCollateral(address) external virtual returns (TotalsCollateral memory);\\n}\\n\"\r\n    },\r\n    \"src/CometHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {CometMath} from \\\"./vendor/CometMath.sol\\\";\\n\\n/// @notice Includes helper functions ripped from different contracts in Comet instead\\n/// of copying whole contracts. Also includes error definitions, events, and constants.\\ncontract CometHelpers is CometMath {\\n    uint64 internal constant FACTOR_SCALE = 1e18;\\n    uint64 internal constant BASE_INDEX_SCALE = 1e15;\\n    uint64 internal constant BASE_ACCRUAL_SCALE = 1e6;\\n\\n    error LackAllowance();\\n    error ZeroShares();\\n    error ZeroAssets();\\n    error ZeroAddress();\\n    error TimestampTooLarge();\\n\\n    event RewardClaimed(address indexed src, address indexed recipient, address indexed token, uint256 amount);\\n\\n    /// @dev Multiply a number by a factor\\n    /// https://github.com/compound-finance/comet/blob/main/contracts/Comet.sol#L681-L683\\n    function mulFactor(uint256 n, uint256 factor) internal pure returns (uint256) {\\n        return n * factor / FACTOR_SCALE;\\n    }\\n\\n    /// @dev The principal amount projected forward by the supply index\\n    /// From https://github.com/compound-finance/comet/blob/main/contracts/CometCore.sol#L83-L85\\n    function presentValueSupply(uint64 baseSupplyIndex_, uint256 principalValue_) internal pure returns (uint256) {\\n        return principalValue_ * baseSupplyIndex_ / BASE_INDEX_SCALE;\\n    }\\n\\n    /// @dev The present value projected backward by the supply index (rounded down)\\n    /// Note: This will overflow (revert) at 2^104/1e18=~20 trillion principal for assets with 18 decimals.\\n    /// From https://github.com/compound-finance/comet/blob/main/contracts/CometCore.sol#L109-L111\\n    function principalValueSupply(uint64 baseSupplyIndex_, uint256 presentValue_) internal pure returns (uint104) {\\n        return safe104((presentValue_ * BASE_INDEX_SCALE) / baseSupplyIndex_);\\n    }\\n\\n    /// @dev The current timestamp\\n    /// From https://github.com/compound-finance/comet/blob/main/contracts/Comet.sol#L375-L378\\n    function getNowInternal() internal view virtual returns (uint40) {\\n        if (block.timestamp >= 2**40) revert TimestampTooLarge();\\n        return uint40(block.timestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/vendor/ICometRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\npragma solidity 0.8.17;\\n\\ninterface ICometRewards {\\n    struct RewardConfig {\\n        address token;\\n        uint64 rescaleFactor;\\n        bool shouldUpscale;\\n    }\\n\\n    struct RewardOwed {\\n        address token;\\n        uint256 owed;\\n    }\\n\\n    function rewardConfig(address) external view returns (RewardConfig memory);\\n\\n    function claim(address comet, address src, bool shouldAccrue) external;\\n\\n    function getRewardOwed(address comet, address account) external returns (RewardOwed memory);\\n\\n    function claimTo(address comet, address src, address to, bool shouldAccrue) external;\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\\n    }\\n\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return 0;\\n\\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n            if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5**18;\\n\\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            require(x > 0, \\\"UNDEFINED\\\");\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            int256 k = int256(log2(uint256(x))) - 96;\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // z will equal 0 if y is 0, unlike in Solidity where it will revert.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // z will equal 0 if y is 0, unlike in Solidity where it will revert.\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Will return 0 instead of reverting if y is zero.\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // Add 1 to x * y if x % y > 0.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/vendor/CometMainInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nstruct AssetInfo {\\n    uint8 offset;\\n    address asset;\\n    address priceFeed;\\n    uint64 scale;\\n    uint64 borrowCollateralFactor;\\n    uint64 liquidateCollateralFactor;\\n    uint64 liquidationFactor;\\n    uint128 supplyCap;\\n}\\n\\n/**\\n * @title Compound's Comet Main Interface (without Ext)\\n * @notice An efficient monolithic money market protocol\\n * @author Compound\\n */\\nabstract contract CometMainInterface {\\n    error Absurd();\\n    error AlreadyInitialized();\\n    error BadAsset();\\n    error BadDecimals();\\n    error BadDiscount();\\n    error BadMinimum();\\n    error BadPrice();\\n    error BorrowTooSmall();\\n    error BorrowCFTooLarge();\\n    error InsufficientReserves();\\n    error LiquidateCFTooLarge();\\n    error NoSelfTransfer();\\n    error NotCollateralized();\\n    error NotForSale();\\n    error NotLiquidatable();\\n    error Paused();\\n    error SupplyCapExceeded();\\n    error TimestampTooLarge();\\n    error TooManyAssets();\\n    error TooMuchSlippage();\\n    error TransferInFailed();\\n    error TransferOutFailed();\\n    error Unauthorized();\\n\\n    event Supply(address indexed from, address indexed dst, uint256 amount);\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Withdraw(address indexed src, address indexed to, uint256 amount);\\n\\n    event SupplyCollateral(address indexed from, address indexed dst, address indexed asset, uint256 amount);\\n    event TransferCollateral(address indexed from, address indexed to, address indexed asset, uint256 amount);\\n    event WithdrawCollateral(address indexed src, address indexed to, address indexed asset, uint256 amount);\\n\\n    /// @notice Event emitted when a borrow position is absorbed by the protocol\\n    event AbsorbDebt(address indexed absorber, address indexed borrower, uint256 basePaidOut, uint256 usdValue);\\n\\n    /// @notice Event emitted when a user's collateral is absorbed by the protocol\\n    event AbsorbCollateral(\\n        address indexed absorber,\\n        address indexed borrower,\\n        address indexed asset,\\n        uint256 collateralAbsorbed,\\n        uint256 usdValue\\n    );\\n\\n    /// @notice Event emitted when a collateral asset is purchased from the protocol\\n    event BuyCollateral(address indexed buyer, address indexed asset, uint256 baseAmount, uint256 collateralAmount);\\n\\n    /// @notice Event emitted when an action is paused/unpaused\\n    event PauseAction(bool supplyPaused, bool transferPaused, bool withdrawPaused, bool absorbPaused, bool buyPaused);\\n\\n    /// @notice Event emitted when reserves are withdrawn by the governor\\n    event WithdrawReserves(address indexed to, uint256 amount);\\n\\n    function supply(address asset, uint256 amount) external virtual;\\n\\n    function supplyTo(address dst, address asset, uint256 amount) external virtual;\\n\\n    function supplyFrom(address from, address dst, address asset, uint256 amount) external virtual;\\n\\n    function transfer(address dst, uint256 amount) external virtual returns (bool);\\n\\n    function transferFrom(address src, address dst, uint256 amount) external virtual returns (bool);\\n\\n    function transferAsset(address dst, address asset, uint256 amount) external virtual;\\n\\n    function transferAssetFrom(address src, address dst, address asset, uint256 amount) external virtual;\\n\\n    function withdraw(address asset, uint256 amount) external virtual;\\n\\n    function withdrawTo(address to, address asset, uint256 amount) external virtual;\\n\\n    function withdrawFrom(address src, address to, address asset, uint256 amount) external virtual;\\n\\n    function approveThis(address manager, address asset, uint256 amount) external virtual;\\n\\n    function withdrawReserves(address to, uint256 amount) external virtual;\\n\\n    function absorb(address absorber, address[] calldata accounts) external virtual;\\n\\n    function buyCollateral(address asset, uint256 minAmount, uint256 baseAmount, address recipient) external virtual;\\n\\n    function quoteCollateral(address asset, uint256 baseAmount) public view virtual returns (uint256);\\n\\n    function getAssetInfo(uint8 i) public view virtual returns (AssetInfo memory);\\n\\n    function getAssetInfoByAddress(address asset) public view virtual returns (AssetInfo memory);\\n\\n    function getReserves() public view virtual returns (int256);\\n\\n    function getPrice(address priceFeed) public view virtual returns (uint256);\\n\\n    function isBorrowCollateralized(address account) public view virtual returns (bool);\\n\\n    function isLiquidatable(address account) public view virtual returns (bool);\\n\\n    function totalSupply() external view virtual returns (uint256);\\n\\n    function totalBorrow() external view virtual returns (uint256);\\n\\n    function balanceOf(address owner) public view virtual returns (uint256);\\n\\n    function borrowBalanceOf(address account) public view virtual returns (uint256);\\n\\n    function pause(bool supplyPaused, bool transferPaused, bool withdrawPaused, bool absorbPaused, bool buyPaused)\\n        external\\n        virtual;\\n\\n    function isSupplyPaused() public view virtual returns (bool);\\n\\n    function isTransferPaused() public view virtual returns (bool);\\n\\n    function isWithdrawPaused() public view virtual returns (bool);\\n\\n    function isAbsorbPaused() public view virtual returns (bool);\\n\\n    function isBuyPaused() public view virtual returns (bool);\\n\\n    function accrueAccount(address account) external virtual;\\n\\n    function getSupplyRate(uint256 utilization) public view virtual returns (uint64);\\n\\n    function getBorrowRate(uint256 utilization) public view virtual returns (uint64);\\n\\n    function getUtilization() public view virtual returns (uint256);\\n\\n    function governor() external view virtual returns (address);\\n\\n    function pauseGuardian() external view virtual returns (address);\\n\\n    function baseToken() external view virtual returns (address);\\n\\n    function baseTokenPriceFeed() external view virtual returns (address);\\n\\n    function extensionDelegate() external view virtual returns (address);\\n\\n    /// @dev uint64\\n    function supplyKink() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateSlopeLow() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateSlopeHigh() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateBase() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function borrowKink() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateSlopeLow() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateSlopeHigh() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateBase() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function storeFrontPriceFactor() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function baseScale() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function trackingIndexScale() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function baseTrackingSupplySpeed() external view virtual returns (uint256);\\n\\n    /// @dev uint64\\n    function baseTrackingBorrowSpeed() external view virtual returns (uint256);\\n\\n    /// @dev uint104\\n    function baseMinForRewards() external view virtual returns (uint256);\\n\\n    /// @dev uint104\\n    function baseBorrowMin() external view virtual returns (uint256);\\n\\n    /// @dev uint104\\n    function targetReserves() external view virtual returns (uint256);\\n\\n    function numAssets() external view virtual returns (uint8);\\n\\n    function decimals() external view virtual returns (uint8);\\n\\n    function initializeStorage() external virtual;\\n}\\n\"\r\n    },\r\n    \"src/vendor/CometExtInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nstruct TotalsBasic {\\n    uint64 baseSupplyIndex;\\n    uint64 baseBorrowIndex;\\n    uint64 trackingSupplyIndex;\\n    uint64 trackingBorrowIndex;\\n    uint104 totalSupplyBase;\\n    uint104 totalBorrowBase;\\n    uint40 lastAccrualTime;\\n    uint8 pauseFlags;\\n}\\n\\n/**\\n * @title Compound's Comet Ext Interface\\n * @notice An efficient monolithic money market protocol\\n * @author Compound\\n */\\nabstract contract CometExtInterface {\\n    error BadAmount();\\n    error BadNonce();\\n    error BadSignatory();\\n    error InvalidValueS();\\n    error InvalidValueV();\\n    error SignatureExpired();\\n\\n    function allow(address manager, bool isAllowed) external virtual;\\n\\n    function allowBySig(\\n        address owner,\\n        address manager,\\n        bool isAllowed,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual;\\n\\n    function collateralBalanceOf(address account, address asset) external view virtual returns (uint128);\\n\\n    function baseTrackingAccrued(address account) external view virtual returns (uint64);\\n\\n    function baseAccrualScale() external view virtual returns (uint64);\\n\\n    function baseIndexScale() external view virtual returns (uint64);\\n\\n    function factorScale() external view virtual returns (uint64);\\n\\n    function priceScale() external view virtual returns (uint64);\\n\\n    function maxAssets() external view virtual returns (uint8);\\n\\n    function totalsBasic() external view virtual returns (TotalsBasic memory);\\n\\n    function version() external view virtual returns (string memory);\\n\\n    /**\\n     * ===== ERC20 interfaces =====\\n     * Does not include the following functions/events, which are defined in `CometMainInterface` instead:\\n     * - function decimals() virtual external view returns (uint8)\\n     * - function totalSupply() virtual external view returns (uint256)\\n     * - function transfer(address dst, uint amount) virtual external returns (bool)\\n     * - function transferFrom(address src, address dst, uint amount) virtual external returns (bool)\\n     * - function balanceOf(address owner) virtual external view returns (uint256)\\n     * - event Transfer(address indexed from, address indexed to, uint256 amount)\\n     */\\n    function name() external view virtual returns (string memory);\\n\\n    function symbol() external view virtual returns (string memory);\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) external virtual returns (bool);\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\n     */\\n    function allowance(address owner, address spender) external view virtual returns (uint256);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"src/vendor/CometMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @title Compound's Comet Math Contract\\n * @dev Pure math functions\\n * @author Compound\\n */\\ncontract CometMath {\\n    /**\\n     * Custom errors *\\n     */\\n\\n    error InvalidUInt64();\\n    error InvalidUInt104();\\n    error InvalidUInt128();\\n    error InvalidInt104();\\n    error InvalidInt256();\\n    error NegativeNumber();\\n\\n    function safe64(uint256 n) internal pure returns (uint64) {\\n        if (n > type(uint64).max) revert InvalidUInt64();\\n        return uint64(n);\\n    }\\n\\n    function safe104(uint256 n) internal pure returns (uint104) {\\n        if (n > type(uint104).max) revert InvalidUInt104();\\n        return uint104(n);\\n    }\\n\\n    function safe128(uint256 n) internal pure returns (uint128) {\\n        if (n > type(uint128).max) revert InvalidUInt128();\\n        return uint128(n);\\n    }\\n\\n    function signed104(uint104 n) internal pure returns (int104) {\\n        if (n > uint104(type(int104).max)) revert InvalidInt104();\\n        return int104(n);\\n    }\\n\\n    function signed256(uint256 n) internal pure returns (int256) {\\n        if (n > uint256(type(int256).max)) revert InvalidInt256();\\n        return int256(n);\\n    }\\n\\n    function unsigned104(int104 n) internal pure returns (uint104) {\\n        if (n < 0) revert NegativeNumber();\\n        return uint104(n);\\n    }\\n\\n    function unsigned256(int256 n) internal pure returns (uint256) {\\n        if (n < 0) revert NegativeNumber();\\n        return uint256(n);\\n    }\\n\\n    function toUInt8(bool x) internal pure returns (uint8) {\\n        return x ? 1 : 0;\\n    }\\n\\n    function toBool(uint8 x) internal pure returns (bool) {\\n        return x != 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/solmate:ds-test/=lib/solmate/lib/ds-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"contract ICometRewards\",\"name\":\"_cometRewards\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidInt104\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInt256\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUInt104\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUInt128\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUInt64\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LackAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NegativeNumber\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TimestampTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAssets\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroShares\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accrueRewards\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"baseTrackingAccrued\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"baseTrackingIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct CometWrapper.UserBasic\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"comet\",\"outputs\":[{\"internalType\":\"contract CometInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cometRewards\",\"outputs\":[{\"internalType\":\"contract ICometRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRewardOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardsClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trackingIndexScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"underlyingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBasic\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"baseTrackingAccrued\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"baseTrackingIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CometWrapper", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c3d688b66703497daa19211eedff47f25384cdc30000000000000000000000001b0e765f6224c21223aea2af16c1c46e38885a40000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000125772617070656420436f6d65742055534443000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000085763555344437633000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}