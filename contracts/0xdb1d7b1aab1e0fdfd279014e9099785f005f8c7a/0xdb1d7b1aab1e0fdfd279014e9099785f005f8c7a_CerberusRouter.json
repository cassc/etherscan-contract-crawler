{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CerberusRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity ^0.8.19;\\n\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport {SafeTransfer} from \\\"./lib/SafeTransfer.sol\\\";\\nimport {IWETH} from \\\"./interfaces/IWETH.sol\\\";\\n\\ninterface IUniswapV2Pair {\\n    function getReserves()\\n        external\\n        view\\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function swap(\\n        uint amount0Out,\\n        uint amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n}\\n\\n\\ncontract CerberusRouter {\\n    using SafeTransfer for IERC20;\\n    using SafeTransfer for IWETH;\\n\\n    address internal immutable owner;\\n\\n    address internal constant WETH9 =\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    receive() external payable {}\\n\\n    function withdrawFees(address wallet) public {\\n        require(msg.sender == owner, \\\"You are not the owner\\\");\\n        SafeTransfer.safeTransferETH(wallet, address(this).balance);\\n\\n    }\\n    fallback(bytes calldata input) external payable returns (bytes memory output) {\\n        \\n        address tokenIn;\\n        address tokenOut;\\n        address pair;\\n        uint256 minAmountOut;\\n        uint16 cerbFeeFactor;\\n        uint256 amountIn;\\n        address referrer;\\n        uint16 referrerFeeFactor;\\n\\n        (tokenIn, tokenOut, pair,  minAmountOut, cerbFeeFactor, amountIn, referrer, referrerFeeFactor) = abi.decode(input, (address, address, address, uint256, uint16, uint256, address, uint16));\\n\\n        address receiver = address(this);\\n\\n        if (address(tokenIn) == WETH9) {\\n\\n            require(msg.value > 0, \\\"No msg value provided\\\");\\n\\n            uint cerbFee = (msg.value * cerbFeeFactor) / 10000;\\n            uint referrerFee = (msg.value * referrerFeeFactor) / 10000;\\n\\n            amountIn = msg.value - cerbFee - referrerFee;\\n\\n            IWETH weth = IWETH(WETH9);\\n            weth.deposit{value: amountIn}();\\n            weth.safeTransfer(pair, amountIn);\\n\\n            if (referrerFee > 0) {\\n                SafeTransfer.safeTransferETH(referrer, referrerFee);\\n            }\\n\\n        } else {\\n  \\n            IERC20(tokenIn).safeTransferFrom(msg.sender, pair, amountIn);\\n        }\\n\\n        uint reserveIn;\\n        uint reserveOut;\\n\\n        {\\n            (uint reserve0, uint reserve1, ) = IUniswapV2Pair(pair).getReserves();\\n\\n            if (tokenIn < tokenOut) {\\n                reserveIn = reserve0;\\n                reserveOut = reserve1;\\n            } else {\\n                reserveIn = reserve1;\\n                reserveOut = reserve0;\\n            }\\n        }\\n\\n\\n        uint amountOut = getAmountOut(amountIn, reserveIn, reserveOut);\\n\\n        (uint amount0Out, uint amount1Out) = tokenIn < tokenOut\\n            ? (uint(0), amountOut)\\n            : (amountOut, uint(0));\\n\\n        uint balBefore = IERC20(tokenOut).balanceOf(address(receiver));\\n\\n        IUniswapV2Pair(pair).swap(\\n            amount0Out,\\n            amount1Out,\\n            receiver,\\n            new bytes(0)\\n        );\\n\\n        uint actualAmountOut = IERC20(tokenOut).balanceOf(address(receiver)) - balBefore;\\n\\n        require(actualAmountOut >= minAmountOut, \\\"Too little received\\\");\\n\\n        if (tokenOut == WETH9) {\\n            IWETH(WETH9).withdraw(actualAmountOut);\\n\\n            uint cerbFee = (actualAmountOut * cerbFeeFactor) / 10000;\\n            uint referrerFee = (actualAmountOut * referrerFeeFactor) / 10000;\\n\\n            SafeTransfer.safeTransferETH(msg.sender, actualAmountOut - cerbFee - referrerFee);\\n\\n            if (referrerFee > 0) {\\n                SafeTransfer.safeTransferETH(referrer, referrerFee);\\n            }\\n            \\n        } else {\\n\\n            IERC20(tokenOut).safeTransfer(msg.sender, actualAmountOut);\\n        }\\n\\n        return input;\\n    }\\n\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n        require(amountIn > 0, \\\"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\\\");\\n        require(reserveIn > 0 && reserveOut > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\n        uint amountInWithFee = amountIn * 997;\\n        uint numerator = amountInWithFee * reserveOut;\\n        uint denominator = (reserveIn * 1000) + amountInWithFee;\\n        amountOut = numerator / denominator;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    event Approval(address, address, uint256);\\n    event Transfer(address, address, uint256);\\n\\n    function name() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function transferFrom(address, address, uint256) external returns (bool);\\n\\n    function allowance(address, address) external view returns (uint256);\\n\\n    function approve(address, uint256) external returns (bool);\\n\\n    function transfer(address, uint256) external returns (bool);\\n\\n    function balanceOf(address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function withdraw(uint256 amount) external;\\n\\n    function deposit() external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SafeTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary SafeTransfer {\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool s, ) = address(token).call(\\n            abi.encodeWithSelector(\\n                IERC20.transferFrom.selector,\\n                from,\\n                to,\\n                value\\n            )\\n        );\\n        require(s, \\\"safeTransferFrom failed\\\");\\n    }\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        (bool s, ) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\\n        );\\n        require(s, \\\"safeTransfer failed\\\");\\n    }\\n\\n    function safeApprove(IERC20 token, address to, uint256 value) internal {\\n        (bool s, ) = address(token).call(\\n            abi.encodeWithSelector(IERC20.approve.selector, to, value)\\n        );\\n        require(s, \\\"safeApprove failed\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CerberusRouter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}