{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/governance/GearStakingV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2023.\\npragma solidity ^0.8.17;\\n\\nimport {SafeERC20} from \\\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport {AP_GEAR_TOKEN, IAddressProviderV3, NO_VERSION_CONTROL} from \\\"../interfaces/IAddressProviderV3.sol\\\";\\nimport {IVotingContractV3} from \\\"../interfaces/IVotingContractV3.sol\\\";\\nimport {\\n    IGearStakingV3,\\n    UserVoteLockData,\\n    WithdrawalData,\\n    MultiVote,\\n    VotingContractStatus,\\n    EPOCHS_TO_WITHDRAW,\\n    EPOCH_LENGTH\\n} from \\\"../interfaces/IGearStakingV3.sol\\\";\\n\\nimport {ACLNonReentrantTrait} from \\\"../traits/ACLNonReentrantTrait.sol\\\";\\n\\n// EXCEPTIONS\\nimport \\\"../interfaces/IExceptions.sol\\\";\\n\\n/// @title Gear staking V3\\ncontract GearStakingV3 is ACLNonReentrantTrait, IGearStakingV3 {\\n    using SafeERC20 for IERC20;\\n    using SafeCast for uint256;\\n\\n    /// @notice Contract version\\n    uint256 public constant override version = 3_00;\\n\\n    /// @notice Address of the GEAR token\\n    address public immutable override gear;\\n\\n    /// @notice Timestamp of the first epoch of voting\\n    uint256 public immutable override firstEpochTimestamp;\\n\\n    /// @dev Mapping from user to their stake amount and tokens available for voting\\n    mapping(address => UserVoteLockData) internal voteLockData;\\n\\n    /// @dev Mapping from user to their future withdrawal amounts\\n    mapping(address => WithdrawalData) internal withdrawalData;\\n\\n    /// @notice Mapping from address to its status as allowed voting contract\\n    mapping(address => VotingContractStatus) public allowedVotingContract;\\n\\n    /// @notice Address of a new staking contract that can be migrated to\\n    address public override successor;\\n\\n    /// @notice Address of the previous staking contract that is migrated from\\n    address public override migrator;\\n\\n    constructor(address _addressProvider, uint256 _firstEpochTimestamp) ACLNonReentrantTrait(_addressProvider) {\\n        gear = IAddressProviderV3(_addressProvider).getAddressOrRevert(AP_GEAR_TOKEN, NO_VERSION_CONTROL); // U:[GS-01]\\n        firstEpochTimestamp = _firstEpochTimestamp; // U:[GS-01]\\n    }\\n\\n    /// @dev Ensures that function is called by migrator\\n    modifier migratorOnly() {\\n        if (msg.sender != migrator) revert CallerNotMigratorException();\\n        _;\\n    }\\n\\n    /// @notice Stakes given amount of GEAR, and, optionally, performs a sequence of votes\\n    /// @param amount Amount of GEAR to stake\\n    /// @param votes Sequence of votes to perform, see `MultiVote`\\n    /// @dev Requires approval from `msg.sender` for GEAR to this contract\\n    function deposit(uint96 amount, MultiVote[] calldata votes) external override nonReentrant {\\n        _deposit(amount, msg.sender, votes); // U: [GS-02]\\n    }\\n\\n    /// @notice Same as `deposit` but uses signed EIP-2612 permit message\\n    /// @param amount Amount of GEAR to stake\\n    /// @param votes Sequence of votes to perform, see `MultiVote`\\n    /// @param deadline Permit deadline\\n    /// @dev `v`, `r`, `s` must be a valid signature of the permit message from `msg.sender` for GEAR to this contract\\n    function depositWithPermit(\\n        uint96 amount,\\n        MultiVote[] calldata votes,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override nonReentrant {\\n        try IERC20Permit(gear).permit(msg.sender, address(this), amount, deadline, v, r, s) {} catch {} // U:[GS-02]\\n        _deposit(amount, msg.sender, votes); // U:[GS-02]\\n    }\\n\\n    /// @dev Implementation of `deposit`\\n    function _deposit(uint96 amount, address to, MultiVote[] calldata votes) internal {\\n        IERC20(gear).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        UserVoteLockData storage vld = voteLockData[to];\\n\\n        vld.totalStaked += amount;\\n        vld.available += amount;\\n\\n        emit DepositGear(to, amount);\\n\\n        _multivote(to, votes);\\n    }\\n\\n    /// @notice Performs a sequence of votes\\n    /// @param votes Sequence of votes to perform, see `MultiVote`\\n    function multivote(MultiVote[] calldata votes) external override nonReentrant {\\n        _multivote(msg.sender, votes); // U: [GS-04]\\n    }\\n\\n    /// @notice Unstakes GEAR and schedules withdrawal which can be claimed in 4 epochs, claims available withdrawals,\\n    ///         and, optionally, performs a sequence of votes.\\n    /// @param amount Amount of GEAR to unstake\\n    /// @param to Address to send claimable GEAR, if any\\n    /// @param votes Sequence of votes to perform, see `MultiVote`\\n    function withdraw(uint96 amount, address to, MultiVote[] calldata votes) external override nonReentrant {\\n        _multivote(msg.sender, votes); // U: [GS-03]\\n\\n        _processPendingWithdrawals(msg.sender, to);\\n\\n        UserVoteLockData storage vld = voteLockData[msg.sender];\\n\\n        if (vld.available < amount) revert InsufficientBalanceException();\\n        unchecked {\\n            vld.available -= amount; // U: [GS-03]\\n        }\\n\\n        withdrawalData[msg.sender].withdrawalsPerEpoch[EPOCHS_TO_WITHDRAW - 1] += amount; // U: [GS-03]\\n\\n        emit ScheduleGearWithdrawal(msg.sender, amount); // U: [GS-03]\\n    }\\n\\n    /// @notice Claims all caller's mature withdrawals\\n    /// @param to Address to send claimable GEAR, if any\\n    function claimWithdrawals(address to) external override nonReentrant {\\n        _processPendingWithdrawals(msg.sender, to); // U: [GS-05]\\n    }\\n\\n    /// @notice Migrates the user's staked GEAR to a successor staking contract, bypassing the withdrawal delay\\n    /// @param amount Amount of staked GEAR to migrate\\n    /// @param votesBefore Votes to apply before sending GEAR to the successor contract\\n    /// @param votesBefore Sequence of votes to perform in this contract before sending GEAR to the successor\\n    /// @param votesAfter Sequence of votes to perform in the successor contract after sending GEAR\\n    function migrate(uint96 amount, MultiVote[] calldata votesBefore, MultiVote[] calldata votesAfter)\\n        external\\n        override\\n        nonReentrant\\n        nonZeroAddress(successor) // U: [GS-07]\\n    {\\n        _multivote(msg.sender, votesBefore); // U: [GS-07]\\n\\n        UserVoteLockData storage vld = voteLockData[msg.sender];\\n\\n        if (vld.available < amount) revert InsufficientBalanceException();\\n        unchecked {\\n            vld.available -= amount; // U: [GS-07]\\n            vld.totalStaked -= amount; // U: [GS-07]\\n        }\\n\\n        IERC20(gear).approve(successor, uint256(amount));\\n        IGearStakingV3(successor).depositOnMigration(amount, msg.sender, votesAfter); // U: [GS-07]\\n\\n        emit MigrateGear(msg.sender, successor, amount); // U: [GS-07]\\n    }\\n\\n    /// @notice Performs a deposit on user's behalf from the migrator (usually the previous staking contract)\\n    /// @param amount Amount of GEAR to deposit\\n    /// @param onBehalfOf User on whose behalf to deposit\\n    /// @param votes Sequence of votes to perform after migration, see `MultiVote`\\n    function depositOnMigration(uint96 amount, address onBehalfOf, MultiVote[] calldata votes)\\n        external\\n        override\\n        nonReentrant\\n        migratorOnly // U: [GS-07]\\n    {\\n        _deposit(amount, onBehalfOf, votes); // U: [GS-07]\\n    }\\n\\n    /// @dev Refreshes the user's withdrawal struct, shifting the withdrawal amounts based on the number of epochs\\n    ///      that passed since the last update. If there are any mature withdrawals, sends them to the user.\\n    function _processPendingWithdrawals(address user, address to) internal {\\n        uint16 epochNow = getCurrentEpoch();\\n\\n        if (epochNow > withdrawalData[user].epochLastUpdate) {\\n            WithdrawalData memory wd = withdrawalData[user];\\n\\n            uint16 epochDiff = epochNow - wd.epochLastUpdate;\\n            uint256 totalClaimable;\\n\\n            // Epochs one, two, three and four in the struct are always relative to epochLastUpdate, so the amounts\\n            // are \\\"shifted\\\" by the number of epochs that passed since then. If some amount shifts beyond epoch one,\\n            // it becomes mature and the GEAR is sent to the user.\\n            unchecked {\\n                for (uint256 i = 0; i < EPOCHS_TO_WITHDRAW; ++i) {\\n                    if (i < epochDiff) {\\n                        totalClaimable += wd.withdrawalsPerEpoch[i];\\n                    }\\n\\n                    wd.withdrawalsPerEpoch[i] =\\n                        (i + epochDiff < EPOCHS_TO_WITHDRAW) ? wd.withdrawalsPerEpoch[i + epochDiff] : 0;\\n                }\\n            }\\n\\n            if (totalClaimable != 0) {\\n                IERC20(gear).safeTransfer(to, totalClaimable);\\n\\n                voteLockData[user].totalStaked -= totalClaimable.toUint96();\\n\\n                emit ClaimGearWithdrawal(user, to, totalClaimable);\\n            }\\n\\n            wd.epochLastUpdate = epochNow;\\n            withdrawalData[user] = wd;\\n        }\\n    }\\n\\n    /// @dev Implementation of `multivote`\\n    function _multivote(address user, MultiVote[] calldata votes) internal {\\n        uint256 len = votes.length;\\n        if (len == 0) return;\\n\\n        UserVoteLockData storage vld = voteLockData[user];\\n\\n        for (uint256 i = 0; i < len;) {\\n            MultiVote calldata currentVote = votes[i];\\n\\n            if (currentVote.isIncrease) {\\n                if (allowedVotingContract[currentVote.votingContract] != VotingContractStatus.ALLOWED) {\\n                    revert VotingContractNotAllowedException(); // U: [GS-04A]\\n                }\\n\\n                if (vld.available < currentVote.voteAmount) revert InsufficientBalanceException();\\n                unchecked {\\n                    vld.available -= currentVote.voteAmount;\\n                }\\n\\n                IVotingContractV3(currentVote.votingContract).vote(user, currentVote.voteAmount, currentVote.extraData);\\n            } else {\\n                if (allowedVotingContract[currentVote.votingContract] == VotingContractStatus.NOT_ALLOWED) {\\n                    revert VotingContractNotAllowedException(); // U: [GS-04A]\\n                }\\n\\n                IVotingContractV3(currentVote.votingContract).unvote(\\n                    user, currentVote.voteAmount, currentVote.extraData\\n                );\\n                vld.available += currentVote.voteAmount;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns the current global voting epoch\\n    function getCurrentEpoch() public view override returns (uint16) {\\n        if (block.timestamp < firstEpochTimestamp) return 0; // U:[GS-01]\\n        unchecked {\\n            return uint16((block.timestamp - firstEpochTimestamp) / EPOCH_LENGTH) + 1; // U:[GS-01]\\n        }\\n    }\\n\\n    /// @notice Returns the total amount of user's staked GEAR\\n    function balanceOf(address user) external view override returns (uint256) {\\n        return voteLockData[user].totalStaked;\\n    }\\n\\n    /// @notice Returns user's balance available for voting or unstaking\\n    function availableBalance(address user) external view override returns (uint256) {\\n        return voteLockData[user].available;\\n    }\\n\\n    /// @notice Returns user's amounts withdrawable now and over the next 4 epochs\\n    function getWithdrawableAmounts(address user)\\n        external\\n        view\\n        override\\n        returns (uint256 withdrawableNow, uint256[EPOCHS_TO_WITHDRAW] memory withdrawableInEpochs)\\n    {\\n        WithdrawalData storage wd = withdrawalData[user];\\n\\n        uint16 epochDiff = getCurrentEpoch() - wd.epochLastUpdate;\\n        unchecked {\\n            for (uint256 i = 0; i < EPOCHS_TO_WITHDRAW; ++i) {\\n                if (i < epochDiff) {\\n                    withdrawableNow += wd.withdrawalsPerEpoch[i];\\n                }\\n\\n                withdrawableInEpochs[i] =\\n                    (i + epochDiff < EPOCHS_TO_WITHDRAW) ? wd.withdrawalsPerEpoch[i + epochDiff] : 0;\\n            }\\n        }\\n    }\\n\\n    // ------------- //\\n    // CONFIGURATION //\\n    // ------------- //\\n\\n    /// @notice Sets the status of contract as an allowed voting contract\\n    /// @param votingContract Address to set the status for\\n    /// @param status The new status of the contract, see `VotingContractStatus`\\n    function setVotingContractStatus(address votingContract, VotingContractStatus status)\\n        external\\n        override\\n        configuratorOnly\\n    {\\n        if (status == allowedVotingContract[votingContract]) return;\\n        allowedVotingContract[votingContract] = status; // U: [GS-06]\\n\\n        emit SetVotingContractStatus(votingContract, status); // U: [GS-06]\\n    }\\n\\n    /// @notice Sets a new successor contract\\n    /// @dev Successor is a new staking contract where staked GEAR can be migrated, bypassing the withdrawal delay.\\n    ///      This is used to upgrade staking contracts when new functionality is added.\\n    ///      It must already have this contract set as migrator.\\n    /// @param newSuccessor Address of the new successor contract\\n    function setSuccessor(address newSuccessor) external override configuratorOnly {\\n        if (successor != newSuccessor) {\\n            if (IGearStakingV3(newSuccessor).migrator() != address(this)) {\\n                revert IncompatibleSuccessorException(); // U: [GS-08]\\n            }\\n            successor = newSuccessor; // U: [GS-08]\\n\\n            emit SetSuccessor(newSuccessor); // U: [GS-08]\\n        }\\n    }\\n\\n    /// @notice Sets a new migrator contract\\n    /// @dev Migrator is a contract (usually the previous staking contract) that can deposit GEAR on behalf of users\\n    ///      during migration in order for them to move their staked GEAR, bypassing the withdrawal delay.\\n    /// @param newMigrator Address of the new migrator contract\\n    function setMigrator(address newMigrator) external override configuratorOnly {\\n        if (migrator != newMigrator) {\\n            migrator = newMigrator; // U: [GS-09]\\n\\n            emit SetMigrator(newMigrator); // U: [GS-09]\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../interfaces/IDaiLikePermit.sol\\\";\\nimport \\\"../interfaces/IPermit2.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../libraries/RevertReasonForwarder.sol\\\";\\n\\n/// @title Implements efficient safe methods for ERC20 interface.\\nlibrary SafeERC20 {\\n    error SafeTransferFailed();\\n    error SafeTransferFromFailed();\\n    error ForceApproveFailed();\\n    error SafeIncreaseAllowanceFailed();\\n    error SafeDecreaseAllowanceFailed();\\n    error SafePermitBadLength();\\n    error Permit2TransferAmountTooHigh();\\n\\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\\n\\n    function safeBalanceOf(\\n        IERC20 token,\\n        address account\\n    ) internal view returns(uint256 tokenBalance) {\\n        bytes4 selector = IERC20.balanceOf.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            mstore(0x00, selector)\\n            mstore(0x04, account)\\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\\n            tokenBalance := mload(0)\\n\\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /// @dev Ensures method do not revert or return boolean `true`, admits call to non-smart-contract.\\n    function safeTransferFromUniversal(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bool permit2\\n    ) internal {\\n        if (permit2) {\\n            safeTransferFromPermit2(token, from, to, amount);\\n        } else {\\n            safeTransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Ensures method do not revert or return boolean `true`, admits call to non-smart-contract.\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bytes4 selector = token.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /// @dev Permit2 version of safeTransferFrom above.\\n    function safeTransferFromPermit2(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\\n        bytes4 selector = IPermit2.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            mstore(add(data, 0x64), token)\\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\\n            if success {\\n                success := gt(extcodesize(_PERMIT2), 0)\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /// @dev Ensures method do not revert or return boolean `true`, admits call to non-smart-contract.\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\\n            revert SafeTransferFailed();\\n        }\\n    }\\n\\n    /// @dev If `approve(from, to, amount)` fails, try to `approve(from, to, 0)` before retry.\\n    function forceApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\\n            if (\\n                !_makeCall(token, token.approve.selector, spender, 0) ||\\n                !_makeCall(token, token.approve.selector, spender, value)\\n            ) {\\n                revert ForceApproveFailed();\\n            }\\n        }\\n    }\\n\\n    /// @dev Allowance increase with safe math check.\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance + value);\\n    }\\n\\n    /// @dev Allowance decrease with safe math check.\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance - value);\\n    }\\n\\n    function safePermit(IERC20 token, bytes calldata permit) internal {\\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\\n        return tryPermit(token, msg.sender, address(this), permit);\\n    }\\n\\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\\n        bytes4 permitSelector = IERC20Permit.permit.selector;\\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\\n        bytes4 permit2Selector = IPermit2.permit.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            switch permit.length\\n            case 100 {\\n                mstore(ptr, permitSelector)\\n                mstore(add(ptr, 0x04), owner)\\n                mstore(add(ptr, 0x24), spender)\\n\\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20)))\\n                    let vs := calldataload(add(permit.offset, 0x44))\\n\\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20) // value\\n                    mstore(add(ptr, 0x64), sub(deadline, 1))\\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))\\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // r\\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))\\n                }\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            case 72 {\\n                mstore(ptr, daiPermitSelector)\\n                mstore(add(ptr, 0x04), owner)\\n                mstore(add(ptr, 0x24), spender)\\n\\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04)))\\n                    let vs := calldataload(add(permit.offset, 0x28))\\n\\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset)))\\n                    mstore(add(ptr, 0x64), sub(expiry, 1))\\n                    mstore(add(ptr, 0x84), true)\\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))\\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20) // r\\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))\\n                }\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            case 224 {\\n                mstore(ptr, permitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length)\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            case 256 {\\n                mstore(ptr, daiPermitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length)\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            case 96 {\\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\\n                mstore(ptr, permit2Selector)\\n                mstore(add(ptr, 0x04), owner)\\n                mstore(add(ptr, 0x24), token)\\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14) // amount\\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // expiration\\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // nonce\\n                mstore(add(ptr, 0xa4), spender)\\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // sigDeadline\\n                mstore(add(ptr, 0xe4), 0x100)\\n                mstore(add(ptr, 0x104), 0x40)\\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // r\\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // vs\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\\n            }\\n            case 352 {\\n                mstore(ptr, permit2Selector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length)\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\\n            }\\n            default {\\n                mstore(ptr, _PERMIT_LENGTH_ERROR)\\n                revert(ptr, 4)\\n            }\\n        }\\n    }\\n\\n    function _makeCall(\\n        IERC20 token,\\n        bytes4 selector,\\n        address to,\\n        uint256 amount\\n    ) private returns (bool success) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), to)\\n            mstore(add(data, 0x24), amount)\\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n    }\\n\\n    function safeDeposit(IWETH weth, uint256 amount) internal {\\n        if (amount > 0) {\\n            bytes4 selector = IWETH.deposit.selector;\\n            assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n                mstore(0, selector)\\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\\n                    returndatacopy(0, 0, returndatasize())\\n                    revert(0, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\\n        bytes4 selector = IWETH.withdraw.selector;\\n        assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n            mstore(0, selector)\\n            mstore(4, amount)\\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\\n        safeWithdraw(weth, amount);\\n        if (to != address(this)) {\\n            assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n                if iszero(call(_RAW_CALL_GAS_LIMIT, to, amount, 0, 0, 0, 0)) {\\n                    let ptr := mload(0x40)\\n                    returndatacopy(ptr, 0, returndatasize())\\n                    revert(ptr, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/interfaces/IAddressProviderV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2023.\\npragma solidity ^0.8.17;\\n\\nimport {IVersion} from \\\"@gearbox-protocol/core-v2/contracts/interfaces/IVersion.sol\\\";\\n\\nuint256 constant NO_VERSION_CONTROL = 0;\\n\\nbytes32 constant AP_CONTRACTS_REGISTER = \\\"CONTRACTS_REGISTER\\\";\\nbytes32 constant AP_ACL = \\\"ACL\\\";\\nbytes32 constant AP_PRICE_ORACLE = \\\"PRICE_ORACLE\\\";\\nbytes32 constant AP_ACCOUNT_FACTORY = \\\"ACCOUNT_FACTORY\\\";\\nbytes32 constant AP_DATA_COMPRESSOR = \\\"DATA_COMPRESSOR\\\";\\nbytes32 constant AP_TREASURY = \\\"TREASURY\\\";\\nbytes32 constant AP_GEAR_TOKEN = \\\"GEAR_TOKEN\\\";\\nbytes32 constant AP_WETH_TOKEN = \\\"WETH_TOKEN\\\";\\nbytes32 constant AP_WETH_GATEWAY = \\\"WETH_GATEWAY\\\";\\nbytes32 constant AP_ROUTER = \\\"ROUTER\\\";\\nbytes32 constant AP_BOT_LIST = \\\"BOT_LIST\\\";\\nbytes32 constant AP_GEAR_STAKING = \\\"GEAR_STAKING\\\";\\nbytes32 constant AP_ZAPPER_REGISTER = \\\"ZAPPER_REGISTER\\\";\\n\\ninterface IAddressProviderV3Events {\\n    /// @notice Emitted when an address is set for a contract key\\n    event SetAddress(bytes32 indexed key, address indexed value, uint256 indexed version);\\n}\\n\\n/// @title Address provider V3 interface\\ninterface IAddressProviderV3 is IAddressProviderV3Events, IVersion {\\n    function addresses(bytes32 key, uint256 _version) external view returns (address);\\n\\n    function getAddressOrRevert(bytes32 key, uint256 _version) external view returns (address result);\\n\\n    function setAddress(bytes32 key, address value, bool saveVersion) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/interfaces/IVotingContractV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2023.\\npragma solidity ^0.8.17;\\n\\ninterface IVotingContractV3 {\\n    function vote(address user, uint96 votes, bytes calldata extraData) external;\\n    function unvote(address user, uint96 votes, bytes calldata extraData) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/interfaces/IGearStakingV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2023.\\npragma solidity ^0.8.17;\\n\\nimport {IVersion} from \\\"@gearbox-protocol/core-v2/contracts/interfaces/IVersion.sol\\\";\\n\\nuint256 constant EPOCH_LENGTH = 7 days;\\n\\nuint256 constant EPOCHS_TO_WITHDRAW = 4;\\n\\n/// @notice Voting contract status\\n///         * NOT_ALLOWED - cannot vote or unvote\\n///         * ALLOWED - can both vote and unvote\\n///         * UNVOTE_ONLY - can only unvote\\nenum VotingContractStatus {\\n    NOT_ALLOWED,\\n    ALLOWED,\\n    UNVOTE_ONLY\\n}\\n\\nstruct UserVoteLockData {\\n    uint96 totalStaked;\\n    uint96 available;\\n}\\n\\nstruct WithdrawalData {\\n    uint96[EPOCHS_TO_WITHDRAW] withdrawalsPerEpoch;\\n    uint16 epochLastUpdate;\\n}\\n\\n/// @notice Multi vote\\n/// @param votingContract Contract to submit a vote to\\n/// @param voteAmount Amount of staked GEAR to vote with\\n/// @param isIncrease Whether to add or remove votes\\n/// @param extraData Data to pass to the voting contract\\nstruct MultiVote {\\n    address votingContract;\\n    uint96 voteAmount;\\n    bool isIncrease;\\n    bytes extraData;\\n}\\n\\ninterface IGearStakingV3Events {\\n    /// @notice Emitted when the user deposits GEAR into staked GEAR\\n    event DepositGear(address indexed user, uint256 amount);\\n\\n    /// @notice Emitted Emits when the user migrates GEAR into a successor contract\\n    event MigrateGear(address indexed user, address indexed successor, uint256 amount);\\n\\n    /// @notice Emitted Emits when the user starts a withdrawal from staked GEAR\\n    event ScheduleGearWithdrawal(address indexed user, uint256 amount);\\n\\n    /// @notice Emitted Emits when the user claims a mature withdrawal from staked GEAR\\n    event ClaimGearWithdrawal(address indexed user, address to, uint256 amount);\\n\\n    /// @notice Emitted Emits when the configurator adds or removes a voting contract\\n    event SetVotingContractStatus(address indexed votingContract, VotingContractStatus status);\\n\\n    /// @notice Emitted Emits when the new successor contract is set\\n    event SetSuccessor(address indexed successor);\\n\\n    /// @notice Emitted Emits when the new migrator contract is set\\n    event SetMigrator(address indexed migrator);\\n}\\n\\n/// @title Gear staking V3 interface\\ninterface IGearStakingV3 is IGearStakingV3Events, IVersion {\\n    function gear() external view returns (address);\\n\\n    function firstEpochTimestamp() external view returns (uint256);\\n\\n    function getCurrentEpoch() external view returns (uint16);\\n\\n    function balanceOf(address user) external view returns (uint256);\\n\\n    function availableBalance(address user) external view returns (uint256);\\n\\n    function getWithdrawableAmounts(address user)\\n        external\\n        view\\n        returns (uint256 withdrawableNow, uint256[EPOCHS_TO_WITHDRAW] memory withdrawableInEpochs);\\n\\n    function deposit(uint96 amount, MultiVote[] calldata votes) external;\\n\\n    function depositWithPermit(\\n        uint96 amount,\\n        MultiVote[] calldata votes,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function multivote(MultiVote[] calldata votes) external;\\n\\n    function withdraw(uint96 amount, address to, MultiVote[] calldata votes) external;\\n\\n    function claimWithdrawals(address to) external;\\n\\n    function migrate(uint96 amount, MultiVote[] calldata votesBefore, MultiVote[] calldata votesAfter) external;\\n\\n    function depositOnMigration(uint96 amount, address onBehalfOf, MultiVote[] calldata votes) external;\\n\\n    // ------------- //\\n    // CONFIGURATION //\\n    // ------------- //\\n\\n    function allowedVotingContract(address) external view returns (VotingContractStatus);\\n\\n    function setVotingContractStatus(address votingContract, VotingContractStatus status) external;\\n\\n    function successor() external view returns (address);\\n\\n    function setSuccessor(address newSuccessor) external;\\n\\n    function migrator() external view returns (address);\\n\\n    function setMigrator(address newMigrator) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/traits/ACLNonReentrantTrait.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2023.\\npragma solidity ^0.8.17;\\n\\nimport {Pausable} from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\nimport {IACL} from \\\"@gearbox-protocol/core-v2/contracts/interfaces/IACL.sol\\\";\\nimport {\\n    CallerNotControllerException,\\n    CallerNotPausableAdminException,\\n    CallerNotUnpausableAdminException\\n} from \\\"../interfaces/IExceptions.sol\\\";\\n\\nimport {ACLTrait} from \\\"./ACLTrait.sol\\\";\\nimport {ReentrancyGuardTrait} from \\\"./ReentrancyGuardTrait.sol\\\";\\n\\n/// @title ACL non-reentrant trait\\n/// @notice Extended version of `ACLTrait` that implements pausable functionality,\\n///         reentrancy protection and external controller role\\nabstract contract ACLNonReentrantTrait is ACLTrait, Pausable, ReentrancyGuardTrait {\\n    /// @notice Emitted when new external controller is set\\n    event NewController(address indexed newController);\\n\\n    /// @notice External controller address\\n    address public controller;\\n\\n    /// @dev Ensures that function caller is external controller or configurator\\n    modifier controllerOnly() {\\n        _ensureCallerIsControllerOrConfigurator();\\n        _;\\n    }\\n\\n    /// @dev Reverts if the caller is not controller or configurator\\n    /// @dev Used to cut contract size on modifiers\\n    function _ensureCallerIsControllerOrConfigurator() internal view {\\n        if (msg.sender != controller && !_isConfigurator({account: msg.sender})) {\\n            revert CallerNotControllerException();\\n        }\\n    }\\n\\n    /// @dev Ensures that function caller has pausable admin role\\n    modifier pausableAdminsOnly() {\\n        _ensureCallerIsPausableAdmin();\\n        _;\\n    }\\n\\n    /// @dev Reverts if the caller is not pausable admin\\n    /// @dev Used to cut contract size on modifiers\\n    function _ensureCallerIsPausableAdmin() internal view {\\n        if (!_isPausableAdmin({account: msg.sender})) {\\n            revert CallerNotPausableAdminException();\\n        }\\n    }\\n\\n    /// @dev Ensures that function caller has unpausable admin role\\n    modifier unpausableAdminsOnly() {\\n        _ensureCallerIsUnpausableAdmin();\\n        _;\\n    }\\n\\n    /// @dev Reverts if the caller is not unpausable admin\\n    /// @dev Used to cut contract size on modifiers\\n    function _ensureCallerIsUnpausableAdmin() internal view {\\n        if (!_isUnpausableAdmin({account: msg.sender})) {\\n            revert CallerNotUnpausableAdminException();\\n        }\\n    }\\n\\n    /// @notice Constructor\\n    /// @param addressProvider Address provider contract address\\n    constructor(address addressProvider) ACLTrait(addressProvider) {\\n        controller = IACL(acl).owner();\\n    }\\n\\n    /// @notice Pauses contract, can only be called by an account with pausable admin role\\n    function pause() external virtual pausableAdminsOnly {\\n        _pause();\\n    }\\n\\n    /// @notice Unpauses contract, can only be called by an account with unpausable admin role\\n    function unpause() external virtual unpausableAdminsOnly {\\n        _unpause();\\n    }\\n\\n    /// @notice Sets new external controller, can only be called by configurator\\n    function setController(address newController) external configuratorOnly {\\n        if (controller == newController) return;\\n        controller = newController;\\n        emit NewController(newController);\\n    }\\n\\n    /// @dev Checks whether given account has pausable admin role\\n    function _isPausableAdmin(address account) internal view returns (bool) {\\n        return IACL(acl).isPausableAdmin(account);\\n    }\\n\\n    /// @dev Checks whether given account has unpausable admin role\\n    function _isUnpausableAdmin(address account) internal view returns (bool) {\\n        return IACL(acl).isUnpausableAdmin(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2023.\\npragma solidity ^0.8.17;\\n\\n// ------- //\\n// GENERAL //\\n// ------- //\\n\\n/// @notice Thrown on attempting to set an important address to zero address\\nerror ZeroAddressException();\\n\\n/// @notice Thrown when attempting to pass a zero amount to a funding-related operation\\nerror AmountCantBeZeroException();\\n\\n/// @notice Thrown on incorrect input parameter\\nerror IncorrectParameterException();\\n\\n/// @notice Thrown when balance is insufficient to perform an operation\\nerror InsufficientBalanceException();\\n\\n/// @notice Thrown if parameter is out of range\\nerror ValueOutOfRangeException();\\n\\n/// @notice Thrown when trying to send ETH to a contract that is not allowed to receive ETH directly\\nerror ReceiveIsNotAllowedException();\\n\\n/// @notice Thrown on attempting to set an EOA as an important contract in the system\\nerror AddressIsNotContractException(address);\\n\\n/// @notice Thrown on attempting to receive a token that is not a collateral token or was forbidden\\nerror TokenNotAllowedException();\\n\\n/// @notice Thrown on attempting to add a token that is already in a collateral list\\nerror TokenAlreadyAddedException();\\n\\n/// @notice Thrown when attempting to use quota-related logic for a token that is not quoted in quota keeper\\nerror TokenIsNotQuotedException();\\n\\n/// @notice Thrown on attempting to interact with an address that is not a valid target contract\\nerror TargetContractNotAllowedException();\\n\\n/// @notice Thrown if function is not implemented\\nerror NotImplementedException();\\n\\n// ------------------ //\\n// CONTRACTS REGISTER //\\n// ------------------ //\\n\\n/// @notice Thrown when an address is expected to be a registered credit manager, but is not\\nerror RegisteredCreditManagerOnlyException();\\n\\n/// @notice Thrown when an address is expected to be a registered pool, but is not\\nerror RegisteredPoolOnlyException();\\n\\n// ---------------- //\\n// ADDRESS PROVIDER //\\n// ---------------- //\\n\\n/// @notice Reverts if address key isn't found in address provider\\nerror AddressNotFoundException();\\n\\n// ----------------- //\\n// POOL, PQK, GAUGES //\\n// ----------------- //\\n\\n/// @notice Thrown by pool-adjacent contracts when a credit manager being connected has a wrong pool address\\nerror IncompatibleCreditManagerException();\\n\\n/// @notice Thrown when attempting to set an incompatible successor staking contract\\nerror IncompatibleSuccessorException();\\n\\n/// @notice Thrown when attempting to vote in a non-approved contract\\nerror VotingContractNotAllowedException();\\n\\n/// @notice Thrown when attempting to unvote more votes than there are\\nerror InsufficientVotesException();\\n\\n/// @notice Thrown when attempting to borrow more than the second point on a two-point curve\\nerror BorrowingMoreThanU2ForbiddenException();\\n\\n/// @notice Thrown when a credit manager attempts to borrow more than its limit in the current block, or in general\\nerror CreditManagerCantBorrowException();\\n\\n/// @notice Thrown when attempting to connect a quota keeper to an incompatible pool\\nerror IncompatiblePoolQuotaKeeperException();\\n\\n/// @notice Thrown when the quota is outside of min/max bounds\\nerror QuotaIsOutOfBoundsException();\\n\\n// -------------- //\\n// CREDIT MANAGER //\\n// -------------- //\\n\\n/// @notice Thrown on failing a full collateral check after multicall\\nerror NotEnoughCollateralException();\\n\\n/// @notice Thrown if an attempt to approve a collateral token to adapter's target contract fails\\nerror AllowanceFailedException();\\n\\n/// @notice Thrown on attempting to perform an action for a credit account that does not exist\\nerror CreditAccountDoesNotExistException();\\n\\n/// @notice Thrown on configurator attempting to add more than 255 collateral tokens\\nerror TooManyTokensException();\\n\\n/// @notice Thrown if more than the maximum number of tokens were enabled on a credit account\\nerror TooManyEnabledTokensException();\\n\\n/// @notice Thrown when attempting to execute a protocol interaction without active credit account set\\nerror ActiveCreditAccountNotSetException();\\n\\n/// @notice Thrown when trying to update credit account's debt more than once in the same block\\nerror DebtUpdatedTwiceInOneBlockException();\\n\\n/// @notice Thrown when trying to repay all debt while having active quotas\\nerror DebtToZeroWithActiveQuotasException();\\n\\n/// @notice Thrown when a zero-debt account attempts to update quota\\nerror UpdateQuotaOnZeroDebtAccountException();\\n\\n/// @notice Thrown when attempting to close an account with non-zero debt\\nerror CloseAccountWithNonZeroDebtException();\\n\\n/// @notice Thrown when value of funds remaining on the account after liquidation is insufficient\\nerror InsufficientRemainingFundsException();\\n\\n/// @notice Thrown when Credit Facade tries to write over a non-zero active Credit Account\\nerror ActiveCreditAccountOverridenException();\\n\\n// ------------------- //\\n// CREDIT CONFIGURATOR //\\n// ------------------- //\\n\\n/// @notice Thrown on attempting to use a non-ERC20 contract or an EOA as a token\\nerror IncorrectTokenContractException();\\n\\n/// @notice Thrown if the newly set LT if zero or greater than the underlying's LT\\nerror IncorrectLiquidationThresholdException();\\n\\n/// @notice Thrown if borrowing limits are incorrect: minLimit > maxLimit or maxLimit > blockLimit\\nerror IncorrectLimitsException();\\n\\n/// @notice Thrown if the new expiration date is less than the current expiration date or current timestamp\\nerror IncorrectExpirationDateException();\\n\\n/// @notice Thrown if a contract returns a wrong credit manager or reverts when trying to retrieve it\\nerror IncompatibleContractException();\\n\\n/// @notice Thrown if attempting to forbid an adapter that is not registered in the credit manager\\nerror AdapterIsNotRegisteredException();\\n\\n/// @notice Thrown when trying to manually set total debt parameters in a credit facade that doesn't track them\\nerror TotalDebtNotTrackedException();\\n\\n// ------------- //\\n// CREDIT FACADE //\\n// ------------- //\\n\\n/// @notice Thrown when attempting to perform an action that is forbidden in whitelisted mode\\nerror ForbiddenInWhitelistedModeException();\\n\\n/// @notice Thrown if credit facade is not expirable, and attempted aciton requires expirability\\nerror NotAllowedWhenNotExpirableException();\\n\\n/// @notice Thrown if a selector that doesn't match any allowed function is passed to the credit facade in a multicall\\nerror UnknownMethodException();\\n\\n/// @notice Thrown when trying to close an account with enabled tokens\\nerror CloseAccountWithEnabledTokensException();\\n\\n/// @notice Thrown if a liquidator tries to liquidate an account with a health factor above 1\\nerror CreditAccountNotLiquidatableException();\\n\\n/// @notice Thrown if too much new debt was taken within a single block\\nerror BorrowedBlockLimitException();\\n\\n/// @notice Thrown if the new debt principal for a credit account falls outside of borrowing limits\\nerror BorrowAmountOutOfLimitsException();\\n\\n/// @notice Thrown if a user attempts to open an account via an expired credit facade\\nerror NotAllowedAfterExpirationException();\\n\\n/// @notice Thrown if expected balances are attempted to be set twice without performing a slippage check\\nerror ExpectedBalancesAlreadySetException();\\n\\n/// @notice Thrown if attempting to perform a slippage check when excepted balances are not set\\nerror ExpectedBalancesNotSetException();\\n\\n/// @notice Thrown if balance of at least one token is less than expected during a slippage check\\nerror BalanceLessThanExpectedException();\\n\\n/// @notice Thrown when trying to perform an action that is forbidden when credit account has enabled forbidden tokens\\nerror ForbiddenTokensException();\\n\\n/// @notice Thrown when new forbidden tokens are enabled during the multicall\\nerror ForbiddenTokenEnabledException();\\n\\n/// @notice Thrown when enabled forbidden token balance is increased during the multicall\\nerror ForbiddenTokenBalanceIncreasedException();\\n\\n/// @notice Thrown when the remaining token balance is increased during the liquidation\\nerror RemainingTokenBalanceIncreasedException();\\n\\n/// @notice Thrown if `botMulticall` is called by an address that is not approved by account owner or is forbidden\\nerror NotApprovedBotException();\\n\\n/// @notice Thrown when attempting to perform a multicall action with no permission for it\\nerror NoPermissionException(uint256 permission);\\n\\n/// @notice Thrown when attempting to give a bot unexpected permissions\\nerror UnexpectedPermissionsException();\\n\\n/// @notice Thrown when a custom HF parameter lower than 10000 is passed into the full collateral check\\nerror CustomHealthFactorTooLowException();\\n\\n/// @notice Thrown when submitted collateral hint is not a valid token mask\\nerror InvalidCollateralHintException();\\n\\n// ------ //\\n// ACCESS //\\n// ------ //\\n\\n/// @notice Thrown on attempting to call an access restricted function not as credit account owner\\nerror CallerNotCreditAccountOwnerException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as configurator\\nerror CallerNotConfiguratorException();\\n\\n/// @notice Thrown on attempting to call an access-restructed function not as account factory\\nerror CallerNotAccountFactoryException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as credit manager\\nerror CallerNotCreditManagerException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as credit facade\\nerror CallerNotCreditFacadeException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as controller or configurator\\nerror CallerNotControllerException();\\n\\n/// @notice Thrown on attempting to pause a contract without pausable admin rights\\nerror CallerNotPausableAdminException();\\n\\n/// @notice Thrown on attempting to unpause a contract without unpausable admin rights\\nerror CallerNotUnpausableAdminException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as gauge\\nerror CallerNotGaugeException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as quota keeper\\nerror CallerNotPoolQuotaKeeperException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as voter\\nerror CallerNotVoterException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as allowed adapter\\nerror CallerNotAdapterException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as migrator\\nerror CallerNotMigratorException();\\n\\n/// @notice Thrown when an address that is not the designated executor attempts to execute a transaction\\nerror CallerNotExecutorException();\\n\\n/// @notice Thrown on attempting to call an access restricted function not as veto admin\\nerror CallerNotVetoAdminException();\\n\\n// ------------------- //\\n// CONTROLLER TIMELOCK //\\n// ------------------- //\\n\\n/// @notice Thrown when the new parameter values do not satisfy required conditions\\nerror ParameterChecksFailedException();\\n\\n/// @notice Thrown when attempting to execute a non-queued transaction\\nerror TxNotQueuedException();\\n\\n/// @notice Thrown when attempting to execute a transaction that is either immature or stale\\nerror TxExecutedOutsideTimeWindowException();\\n\\n/// @notice Thrown when execution of a transaction fails\\nerror TxExecutionRevertedException();\\n\\n/// @notice Thrown when the value of a parameter on execution is different from the value on queue\\nerror ParameterChangedAfterQueuedTxException();\\n\\n// -------- //\\n// BOT LIST //\\n// -------- //\\n\\n/// @notice Thrown when attempting to set non-zero permissions for a forbidden or special bot\\nerror InvalidBotException();\\n\\n// --------------- //\\n// ACCOUNT FACTORY //\\n// --------------- //\\n\\n/// @notice Thrown when trying to deploy second master credit account for a credit manager\\nerror MasterCreditAccountAlreadyDeployedException();\\n\\n/// @notice Thrown when trying to rescue funds from a credit account that is currently in use\\nerror CreditAccountIsInUseException();\\n\\n// ------------ //\\n// PRICE ORACLE //\\n// ------------ //\\n\\n/// @notice Thrown on attempting to set a token price feed to an address that is not a correct price feed\\nerror IncorrectPriceFeedException();\\n\\n/// @notice Thrown on attempting to interact with a price feed for a token not added to the price oracle\\nerror PriceFeedDoesNotExistException();\\n\\n/// @notice Thrown when price feed returns incorrect price for a token\\nerror IncorrectPriceException();\\n\\n/// @notice Thrown when token's price feed becomes stale\\nerror StalePriceException();\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\\n\\nimport \\\"./IERC20Permit.sol\\\";\\n\"\r\n    },\r\n    \"node_modules/@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IDaiLikePermit {\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@1inch/solidity-utils/contracts/interfaces/IPermit2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPermit2 {\\n    struct PermitDetails {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount allowed to spend\\n        uint160 amount;\\n        // timestamp at which a spender's token allowances become invalid\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n    /// @notice The permit message signed for a single token allownce\\n    struct PermitSingle {\\n        // the permit data for a single token alownce\\n        PermitDetails details;\\n        // address permissioned on the allowed tokens\\n        address spender;\\n        // deadline on the permit signature\\n        uint256 sigDeadline;\\n    }\\n    /// @notice Packed allowance\\n    struct PackedAllowance {\\n        // amount allowed\\n        uint160 amount;\\n        // permission expiry\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n\\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\\n\\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\\n\\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\\n}\\n\"\r\n    },\r\n    \"node_modules/@1inch/solidity-utils/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Revert reason forwarder.\\nlibrary RevertReasonForwarder {\\n    /// @dev Forwards latest externall call revert.\\n    function reRevert() internal pure {\\n        // bubble up revert reason from latest external call\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, returndatasize())\\n            revert(ptr, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v2/contracts/interfaces/IVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\n\\n/// @title Version interface\\n/// @notice Defines contract version\\ninterface IVersion {\\n    /// @notice Contract version\\n    function version() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v2/contracts/interfaces/IACL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2022\\npragma solidity ^0.8.10;\\nimport { IVersion } from \\\"./IVersion.sol\\\";\\n\\ninterface IACLExceptions {\\n    /// @dev Thrown when attempting to delete an address from a set that is not a pausable admin\\n    error AddressNotPausableAdminException(address addr);\\n\\n    /// @dev Thrown when attempting to delete an address from a set that is not a unpausable admin\\n    error AddressNotUnpausableAdminException(address addr);\\n}\\n\\ninterface IACLEvents {\\n    /// @dev Emits when a new admin is added that can pause contracts\\n    event PausableAdminAdded(address indexed newAdmin);\\n\\n    /// @dev Emits when a Pausable admin is removed\\n    event PausableAdminRemoved(address indexed admin);\\n\\n    /// @dev Emits when a new admin is added that can unpause contracts\\n    event UnpausableAdminAdded(address indexed newAdmin);\\n\\n    /// @dev Emits when an Unpausable admin is removed\\n    event UnpausableAdminRemoved(address indexed admin);\\n}\\n\\n/// @title ACL interface\\ninterface IACL is IACLEvents, IACLExceptions, IVersion {\\n    /// @dev Returns true if the address is a pausable admin and false if not\\n    /// @param addr Address to check\\n    function isPausableAdmin(address addr) external view returns (bool);\\n\\n    /// @dev Returns true if the address is unpausable admin and false if not\\n    /// @param addr Address to check\\n    function isUnpausableAdmin(address addr) external view returns (bool);\\n\\n    /// @dev Returns true if an address has configurator rights\\n    /// @param account Address to check\\n    function isConfigurator(address account) external view returns (bool);\\n\\n    /// @dev Returns address of configurator\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/traits/ACLTrait.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2023.\\npragma solidity ^0.8.17;\\n\\nimport {IACL} from \\\"@gearbox-protocol/core-v2/contracts/interfaces/IACL.sol\\\";\\n\\nimport {AP_ACL, IAddressProviderV3, NO_VERSION_CONTROL} from \\\"../interfaces/IAddressProviderV3.sol\\\";\\nimport {CallerNotConfiguratorException} from \\\"../interfaces/IExceptions.sol\\\";\\n\\nimport {SanityCheckTrait} from \\\"./SanityCheckTrait.sol\\\";\\n\\n/// @title ACL trait\\n/// @notice Utility class for ACL (access-control list) consumers\\nabstract contract ACLTrait is SanityCheckTrait {\\n    /// @notice ACL contract address\\n    address public immutable acl;\\n\\n    /// @notice Constructor\\n    /// @param addressProvider Address provider contract address\\n    constructor(address addressProvider) nonZeroAddress(addressProvider) {\\n        acl = IAddressProviderV3(addressProvider).getAddressOrRevert(AP_ACL, NO_VERSION_CONTROL);\\n    }\\n\\n    /// @dev Ensures that function caller has configurator role\\n    modifier configuratorOnly() {\\n        _ensureCallerIsConfigurator();\\n        _;\\n    }\\n\\n    /// @dev Reverts if the caller is not the configurator\\n    /// @dev Used to cut contract size on modifiers\\n    function _ensureCallerIsConfigurator() internal view {\\n        if (!_isConfigurator({account: msg.sender})) {\\n            revert CallerNotConfiguratorException();\\n        }\\n    }\\n\\n    /// @dev Checks whether given account has configurator role\\n    function _isConfigurator(address account) internal view returns (bool) {\\n        return IACL(acl).isConfigurator(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2023.\\npragma solidity ^0.8.17;\\n\\nuint8 constant NOT_ENTERED = 1;\\nuint8 constant ENTERED = 2;\\n\\n/// @title Reentrancy guard trait\\n/// @notice Same as OpenZeppelin's `ReentrancyGuard` but only uses 1 byte of storage instead of 32\\nabstract contract ReentrancyGuardTrait {\\n    uint8 internal _reentrancyStatus = NOT_ENTERED;\\n\\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\\n    /// Calling a `nonReentrant` function from another `nonReentrant`\\n    /// function is not supported. It is possible to prevent this from happening\\n    /// by making the `nonReentrant` function external, and making it call a\\n    /// `private` function that does the actual work.\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        _ensureNotEntered();\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _reentrancyStatus = ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _reentrancyStatus = NOT_ENTERED;\\n    }\\n\\n    /// @dev Reverts if the contract is currently entered\\n    /// @dev Used to cut contract size on modifiers\\n    function _ensureNotEntered() internal view {\\n        require(_reentrancyStatus != ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@gearbox-protocol/core-v3/contracts/traits/SanityCheckTrait.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Foundation, 2023.\\npragma solidity ^0.8.17;\\n\\nimport {ZeroAddressException} from \\\"../interfaces/IExceptions.sol\\\";\\n\\n/// @title Sanity check trait\\nabstract contract SanityCheckTrait {\\n    /// @dev Ensures that passed address is non-zero\\n    modifier nonZeroAddress(address addr) {\\n        _revertIfZeroAddress(addr);\\n        _;\\n    }\\n\\n    /// @dev Reverts if address is zero\\n    function _revertIfZeroAddress(address addr) private pure {\\n        if (addr == address(0)) revert ZeroAddressException();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@1inch/=node_modules/@1inch/\",\r\n      \"@chainlink/=node_modules/@chainlink/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"@gearbox-protocol/=node_modules/@gearbox-protocol/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@redstone-finance/=node_modules/@redstone-finance/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_firstEpochTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CallerNotConfiguratorException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotMigratorException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotPausableAdminException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotUnpausableAdminException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncompatibleSuccessorException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalanceException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFromFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VotingContractNotAllowedException\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressException\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimGearWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositGear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"successor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MigrateGear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"NewController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ScheduleGearWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"migrator\",\"type\":\"address\"}],\"name\":\"SetMigrator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"successor\",\"type\":\"address\"}],\"name\":\"SetSuccessor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"votingContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum VotingContractStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"SetVotingContractStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedVotingContract\",\"outputs\":[{\"internalType\":\"enum VotingContractStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"availableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimWithdrawals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"votingContract\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"voteAmount\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"isIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVote[]\",\"name\":\"votes\",\"type\":\"tuple[]\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"votingContract\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"voteAmount\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"isIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVote[]\",\"name\":\"votes\",\"type\":\"tuple[]\"}],\"name\":\"depositOnMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"votingContract\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"voteAmount\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"isIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVote[]\",\"name\":\"votes\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstEpochTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gear\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getWithdrawableAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawableNow\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"withdrawableInEpochs\",\"type\":\"uint256[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"votingContract\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"voteAmount\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"isIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVote[]\",\"name\":\"votesBefore\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"votingContract\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"voteAmount\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"isIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVote[]\",\"name\":\"votesAfter\",\"type\":\"tuple[]\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"votingContract\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"voteAmount\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"isIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVote[]\",\"name\":\"votes\",\"type\":\"tuple[]\"}],\"name\":\"multivote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMigrator\",\"type\":\"address\"}],\"name\":\"setMigrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSuccessor\",\"type\":\"address\"}],\"name\":\"setSuccessor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"votingContract\",\"type\":\"address\"},{\"internalType\":\"enum VotingContractStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"setVotingContractStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"successor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"votingContract\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"voteAmount\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"isIncrease\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiVote[]\",\"name\":\"votes\",\"type\":\"tuple[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GearStakingV3", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000009ea7b04da02a5373317d745c1571c84aad03321d0000000000000000000000000000000000000000000000000000000065803440", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}