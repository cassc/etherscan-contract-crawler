{"SourceCode": "//SPDX-License-Identifier: No\r\n\r\npragma solidity ^0.8.17;\r\n\r\n//--- Context ---//\r\nabstract contract Context {\r\n    constructor() {\r\n    }\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n//--- Pausable ---//\r\nabstract contract Pausable is Context {\r\n\r\n    event Paused(address account);\r\n\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n//--- Ownable ---//\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    address private _multiSig;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event MultiSigTransferred(address indexed oldMultiSig, address indexed newMultiSig);\r\n\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n        _setMultiSig(_msgSender());\r\n    }\r\n\r\n    function multisig() public view virtual returns (address) {\r\n        return _multiSig;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender() || multisig() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMultiSignature() {\r\n        require(multisig() == _msgSender(), \"Ownable: caller is not the multisig\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function transferMultiSig(address newMultiSig) public virtual onlyMultiSignature {\r\n        require(newMultiSig != address(0), \"Ownable: new owner is the zero address\");\r\n        _setMultiSig(newMultiSig);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    function _setMultiSig(address newMultiSig) private {\r\n        address oldMultiSig = _multiSig;\r\n        _multiSig = newMultiSig;\r\n        emit MultiSigTransferred(oldMultiSig, newMultiSig);\r\n    }\r\n}\r\n\r\n\r\n//--- Interface for ERC20 ---//\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract bloxchainstaking is Context, Pausable, Ownable {\r\n\r\n    event staking(uint256 amount); \r\n    event WithdrawFromStaking(uint256 amount);\r\n    event ClaimRewards(uint256 amount);\r\n    mapping (address => uint) public stakeTimestamps;\r\n    uint256 public TokenDedicatiAlloStaking; // Modalit\u00e0 1: Fixed amount of tokens staked.\r\n    uint256 public safeSeconds = 15;\r\n    uint256 public totalSupply; // amount of all token staked\r\n    bool public isStakingLive = false;\r\n    uint256 private dayzero;\r\n    uint256 private preApproval;\r\n    bool public Initalized = false;\r\n    mapping(address => uint256) private rewardsGiaPagati;\r\n    mapping(address => uint256) private rewards;\r\n    mapping(address => uint256) private quandoStake;\r\n    mapping(address => uint256) private quandoWithdraw;\r\n    mapping(address => uint256) private lastTimeStaked;\r\n    mapping(address => uint256) private holdingXstaking;\r\n    mapping(address => uint256) private lastClaimRewards;\r\n\r\n    mapping(address => bool) private AlreadyStaked;\r\n    mapping(address => bool) private FeesExcluded;\r\n    uint256 private interestperDay;\r\n\r\n    constructor (\r\n\r\n    ) {\r\n        FeesExcluded[msg.sender] = true;\r\n    }\r\n    \r\n    IERC20 public Token;\r\n\r\n    function setToken(address _token) external onlyMultiSignature {\r\n        require(!Initalized);\r\n        Token = IERC20(_token);\r\n        Initalized = true;\r\n    }\r\n\r\n    function unPause() external onlyMultiSignature {\r\n        _unpause();\r\n    }\r\n\r\n    function ExcludeFromFees(address holder, bool yesno) external onlyOwner {\r\n        FeesExcluded[holder] = yesno;\r\n    }\r\n\r\n    function setTokenDedicatiAlloStaking(uint256 amount) external onlyOwner {\r\n        uint256 tempBalance = Token.balanceOf(msg.sender); // \r\n        require(tempBalance >= amount,\"Not enough tokens\"); // \r\n        Token.transferFrom(msg.sender, address(this), amount); // make sure to give enough allowance\r\n        TokenDedicatiAlloStaking += amount;\r\n    }\r\n\r\n    function setStakingLive() external onlyOwner {\r\n        require(!isStakingLive,\"Staking is already live\");\r\n        isStakingLive = true;\r\n    }\r\n    // function withdrawAll() external payable onlyOwner {\r\n    //     uint256 balance = Token.balanceOf(address(this));\r\n    //     Token.transferFrom(address(this),msg.sender,  balance);\r\n    //     // ( bool transferOne, ) = payable(msg.sender).call{value: balance}(\"\");\r\n    //     // require(transferOne,\"Transfer failed.\");\r\n    // }\r\n\r\n\r\n    function reset() external onlyMultiSignature {\r\n        uint256 tempBalance = Token.balanceOf(address(this));\r\n        if(tempBalance > 0) {\r\n            Token.transfer(msg.sender, tempBalance);\r\n        }\r\n        interestperDay = 0;\r\n        TokenDedicatiAlloStaking = 0;\r\n        isStakingLive = false;\r\n        _pause();\r\n    }\r\n\r\n    function stakeprivate(uint256 amount) private {\r\n        uint256 tempBalance = Token.balanceOf(msg.sender);\r\n        require(isStakingLive,\"Staking is not live\");\r\n        require(tempBalance >= amount,\"Not enough tokens\");\r\n        Token.transferFrom(msg.sender, address(this), amount);\r\n        holdingXstaking[msg.sender] += amount;\r\n        totalSupply += amount;\r\n        quandoStake[msg.sender] = block.timestamp; // Quando stake in secondi. https://www.site24x7.com/tools/time-stamp-converter.html\r\n        AlreadyStaked[msg.sender] = true;\r\n    }\r\n\r\n    function stake(uint256 amount) external whenNotPaused {\r\n        require(msg.sender != address(0));\r\n        require(isStakingLive,\"Staking is not live yet.\");\r\n\r\n        bool YesNoStaked = AlreadyStaked[msg.sender] == true;\r\n        if(YesNoStaked) {\r\n            if(pend(msg.sender) >= holdingXstaking[msg.sender] / 1000) { revert(\"Claim Rewards, you have at least 0.1% rewards to claim\"); }\r\n        } else {\r\n        }\r\n\r\n        stakeprivate(amount);\r\n        stakeTimestamps[msg.sender] = block.timestamp;\r\n\r\n    emit staking(amount);\r\n\r\n    }\r\n    \r\n    function feesNo() internal view returns(bool) {\r\n        bool FeesNo = FeesExcluded[msg.sender] == true;\r\n\r\n        return FeesNo;\r\n    }\r\n\r\n    function withdraw(uint256 amount) external whenNotPaused {\r\n        require(msg.sender != address(0));\r\n        require(block.timestamp >= stakeTimestamps[msg.sender] + 2 days, \"Withdrawal not yet available\");\r\n        require(amount > 0, \"Amunt should be greater than 0\");\r\n        require(holdingXstaking[msg.sender] >= amount,\"Not enough tokens\");\r\n        if(pend(msg.sender) >= holdingXstaking[msg.sender] / 1000) { revert(\"Claim Rewards, you have at least 0.1% rewards to claim\"); }\r\n        safe();\r\n\r\n            holdingXstaking[msg.sender] -= amount; \r\n            totalSupply -= amount;\r\n            Token.transfer(msg.sender, amount);\r\n\r\n\r\n        quandoWithdraw[msg.sender] = block.timestamp;\r\n        bool goingtozero = holdingXstaking[msg.sender] == 0;\r\n        if(goingtozero) {\r\n        resetUser(); }\r\n\r\n        emit WithdrawFromStaking(amount);\r\n    }\r\n\r\n\r\n\r\n    function resetUser() private {\r\n            AlreadyStaked[msg.sender] = false;\r\n            rewards[msg.sender] = 0;\r\n            rewardsGiaPagati[msg.sender] = 0;\r\n            lastClaimRewards[msg.sender] = 0;\r\n            quandoStake[msg.sender] = 0;\r\n            holdingXstaking[msg.sender] = 0;\r\n            stakeTimestamps[msg.sender] = 0;\r\n    }\r\n\r\n    \r\n    function calculateRewards() private {\r\n        interestperDay = 13698630133; uint256 interestPerSecond = interestperDay / 86400; uint256 interest =\r\n        (block.timestamp - quandoStake[msg.sender]) * interestPerSecond;\r\n        rewards[msg.sender] = (holdingXstaking[msg.sender] * interest);\r\n        rewards[msg.sender] = checkZeroMath(msg.sender, rewards[msg.sender]);\r\n    }\r\n    \r\n    function safe() private view whenNotPaused {\r\n        require(block.timestamp > lastClaimRewards[msg.sender] + safeSeconds, \"Cannot claim in the sameblock\");\r\n    }\r\n\r\n    function staked() private view {\r\n\r\n        bool YesNoStaked = AlreadyStaked[msg.sender] == true;\r\n        if(YesNoStaked) {\r\n        } else {\r\n            safe();\r\n        }\r\n\r\n    }\r\n\r\n    function claimReward() public whenNotPaused {\r\n        require(msg.sender != address(0));\r\n        calculateRewards();\r\n        staked();\r\n\r\n        require(rewards[msg.sender] > 0, \"Can't claim less than zero tokens\");\r\n\r\n        uint256 yourrewards = rewards[msg.sender];\r\n\r\n        Token.transfer(msg.sender, yourrewards);\r\n        rewardsGiaPagati[msg.sender] += yourrewards;\r\n        lastClaimRewards[msg.sender] = block.timestamp;\r\n        require(TokenDedicatiAlloStaking > yourrewards,\"Token Holders need to be able to get back 100% of the tokens allocated\");\r\n        TokenDedicatiAlloStaking -= yourrewards;\r\n\r\n        emit ClaimRewards(yourrewards);\r\n    }\r\n\r\n    function amountStaked(address holder) external view returns (uint256) {\r\n        return holdingXstaking[holder];\r\n    }\r\n\r\n    function rewardsPaid(address holder) external view returns (uint256) {\r\n        return rewardsGiaPagati[holder];\r\n    }\r\n\r\n    function whenStaking(address holder) external view returns (uint256) {\r\n        return quandoStake[holder];\r\n    }\r\n\r\n    function lastTimeClaim(address holder) external view returns (uint256) {\r\n        return lastClaimRewards[holder];\r\n    }\r\n\r\n    function isFeeExcluded(address holder) external view returns (bool) {\r\n        return FeesExcluded[holder];\r\n    }\r\n\r\n    function _alreadyStaked(address holder) external view returns (bool) {\r\n        return AlreadyStaked[holder];\r\n    }\r\n\r\n    function pend(address account) private view returns (uint256) {\r\n        uint256 interestDailyView = 13698630133; uint256 interestPerSecond = interestDailyView / 86400; uint256 interest =\r\n        \r\n        (block.timestamp - quandoStake[account]) * interestPerSecond;\r\n        uint256 preRewards;\r\n        preRewards = (holdingXstaking[account] * interest);\r\n        preRewards = checkZeroMath(account, preRewards);\r\n\r\n\r\n        return preRewards;\r\n    }\r\n\r\n    function checkZeroMath(address account, uint256 a) internal view returns(uint256) {\r\n        uint256 _return;\r\n        if(((a / 100000000000)) / 100 >= rewardsGiaPagati[account]) {\r\n            _return = ((a / 100000000000)) / 100 - rewardsGiaPagati[account];\r\n        } else {\r\n            _return = 0;\r\n        }\r\n        return _return;\r\n    }\r\n \r\n    function pendingRewards(address account) external view returns(uint256) {\r\n        return pend(account);\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldMultiSig\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMultiSig\",\"type\":\"address\"}],\"name\":\"MultiSigTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFromStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"staking\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"yesno\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Initalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokenDedicatiAlloStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"_alreadyStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"amountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"isFeeExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStakingLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"lastTimeClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"rewardsPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setStakingLive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setTokenDedicatiAlloStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMultiSig\",\"type\":\"address\"}],\"name\":\"transferMultiSig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"whenStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "bloxchainstaking", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7fa069c5db2b668eda0c964f302a115d94ca9dd0898727150f9dcea6045481af"}