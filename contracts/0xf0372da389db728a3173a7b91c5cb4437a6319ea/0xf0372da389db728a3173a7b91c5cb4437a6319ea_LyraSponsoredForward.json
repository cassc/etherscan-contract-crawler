{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/gelato/LyraSponsoredForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {ERC2771Context} from \\\"../../lib/relay-context-contracts/contracts/vendor/ERC2771Context.sol\\\";\\nimport {LyraForwarderBase} from \\\"./LyraForwarderBase.sol\\\";\\nimport {IL1StandardBridge} from \\\"../interfaces/IL1StandardBridge.sol\\\";\\nimport {ISocketVault} from \\\"../interfaces/ISocketVault.sol\\\";\\nimport {IERC3009} from \\\"../interfaces/IERC3009.sol\\\";\\n\\n/**\\n * @title   LyraForwarder\\n * @notice  Use this contract when we want to sponsor gas for users\\n * @dev     Someone need to fund this contract with ETH to use Socket Bridge\\n * @dev     All functions are public, EOAs can also use this contract to use receiveWithAuthorization to deposit USDC\\n */\\ncontract LyraSponsoredForwarder is LyraForwarderBase, ERC2771Context {\\n    /**\\n     * @dev GelatoRelay1BalanceERC2771 forwarder (0xd8253782c45a12053594b9deB72d8e8aB2Fca54c) is used for all non-zkSync-EVM\\n     */\\n    constructor(\\n        address _usdcLocal,\\n        address _socketVault\\n    )\\n        payable\\n        LyraForwarderBase(_usdcLocal, _socketVault)\\n        ERC2771Context(0xd8253782c45a12053594b9deB72d8e8aB2Fca54c)\\n    {}\\n\\n    /**\\n     * @notice  Deposit user USDC to L2 through Socket fast bridge\\n     * @dev     Users never have to approve USDC to this contract, we use receiveWithAuthorization to save gas\\n     *\\n     * @param isScwWallet   True if user wants to deposit to default LightAccount on L2\\n     * @param minGasLimit   Minimum gas limit for the L2 execution\\n     * @param connector     Socket Connector\\n     * @param authData      Data and signatures for receiveWithAuthorization\\n     */\\n    function depositUSDCSocketBridge(bool isScwWallet, uint32 minGasLimit, address connector, ReceiveWithAuthData calldata authData)\\n        external\\n    {\\n        address msgSender = _msgSender();\\n\\n        IERC3009(usdcLocal).receiveWithAuthorization(\\n            msgSender,\\n            address(this),\\n            authData.value,\\n            authData.validAfter,\\n            authData.validBefore,\\n            authData.nonce,\\n            authData.v,\\n            authData.r,\\n            authData.s\\n        );\\n\\n        uint256 feeInWei = ISocketVault(socketVault).getMinFees(connector, minGasLimit);\\n\\n        ISocketVault(socketVault).depositToAppChain{value: feeInWei}(\\n            _getL2Receiver(msgSender, isScwWallet), authData.value, minGasLimit, connector\\n        );\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"lib/relay-context-contracts/contracts/vendor/ERC2771Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\n// based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol\\nabstract contract ERC2771Context {\\n    address private immutable _trustedForwarder;\\n\\n    constructor(address trustedForwarder) {\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder)\\n        public\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual returns (address sender) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return msg.data;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/gelato/LyraForwarderBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IERC20} from \\\"../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {ILightAccountFactory} from \\\"../interfaces/ILightAccountFactory.sol\\\";\\n\\n/**\\n * @title  LyraForwarderBase\\n * @notice Shared logic for both self-paying and sponsored forwarder\\n */\\nabstract contract LyraForwarderBase {\\n    // keccak256(\\\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\n    bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH =\\n        0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\\n\\n    ///@dev L1 USDC address.\\n    address public immutable usdcLocal;\\n\\n    ///@dev SocketVault address.\\n    address public immutable socketVault;\\n\\n    ///@dev Light Account factory address.\\n    ///     See this script for more info https://github.com/alchemyplatform/light-account/blob/main/script/Deploy_LightAccountFactory.s.sol\\n    address public constant lightAccountFactory = 0x000000893A26168158fbeaDD9335Be5bC96592E2;\\n\\n    struct ReceiveWithAuthData {\\n        uint256 value;\\n        uint256 validAfter;\\n        uint256 validBefore;\\n        bytes32 nonce;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    constructor(\\n        address _usdcLocal,\\n        address _socketVault\\n    ) {\\n        usdcLocal = _usdcLocal;\\n        socketVault = _socketVault;\\n        \\n        IERC20(_usdcLocal).approve(_socketVault, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Get the recipient address based on isSCW flag\\n     * @param sender The real sender of the transaction\\n     * @param isSCW  True if the sender wants to deposit to smart contract wallet\\n     */\\n    function _getL2Receiver(address sender, bool isSCW) internal view returns (address) {\\n        if (isSCW) {\\n            return ILightAccountFactory(lightAccountFactory).getAddress(sender, 0);\\n        } else {\\n            return sender;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IL1StandardBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.9;\\n\\ninterface IL1StandardBridge {\\n    /**\\n     * @custom:legacy\\n     * @notice Deposits some amount of ETH into a target account on L2.\\n     *         Note that if ETH is sent to a contract on L2 and the call fails, then that ETH will\\n     *         be locked in the L2StandardBridge. ETH may be recoverable if the call can be\\n     *         successfully replayed by increasing the amount of gas supplied to the call. If the\\n     *         call will fail for any amount of gas, then the ETH will be locked permanently.\\n     *\\n     * @param _to          Address of the recipient on L2.\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\\n     *                     execute any code on L2 and is only emitted as extra data for the\\n     *                     convenience of off-chain tooling.\\n     */\\n    function depositETHTo(address _to, uint32 _minGasLimit, bytes calldata _extraData) external;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Deposits some amount of ERC20 tokens into the sender's account on L2.\\n     *\\n     * @param _l1Token     Address of the L1 token being deposited.\\n     * @param _l2Token     Address of the corresponding token on L2.\\n     * @param _amount      Amount of the ERC20 to deposit.\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\\n     *                     execute any code on L2 and is only emitted as extra data for the\\n     *                     convenience of off-chain tooling.\\n     */\\n    function depositERC20(\\n        address _l1Token,\\n        address _l2Token,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) external;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Deposits some amount of ERC20 tokens into a target account on L2.\\n     *\\n     * @param _l1Token     Address of the L1 token being deposited.\\n     * @param _l2Token     Address of the corresponding token on L2.\\n     * @param _to          Address of the recipient on L2.\\n     * @param _amount      Amount of the ERC20 to deposit.\\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\\n     *                     execute any code on L2 and is only emitted as extra data for the\\n     *                     convenience of off-chain tooling.\\n     */\\n    function depositERC20To(\\n        address _l1Token,\\n        address _l2Token,\\n        address _to,\\n        uint256 _amount,\\n        uint32 _minGasLimit,\\n        bytes calldata _extraData\\n    ) external;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Finalizes a withdrawal of ETH from L2.\\n     *\\n     * @param _from      Address of the withdrawer on L2.\\n     * @param _to        Address of the recipient on L1.\\n     * @param _amount    Amount of ETH to withdraw.\\n     * @param _extraData Optional data forwarded from L2.\\n     */\\n    function finalizeETHWithdrawal(address _from, address _to, uint256 _amount, bytes calldata _extraData)\\n        external\\n        payable;\\n\\n    /**\\n     * @custom:legacy\\n     * @notice Finalizes a withdrawal of ERC20 tokens from L2.\\n     *\\n     * @param _l1Token   Address of the token on L1.\\n     * @param _l2Token   Address of the corresponding token on L2.\\n     * @param _from      Address of the withdrawer on L2.\\n     * @param _to        Address of the recipient on L1.\\n     * @param _amount    Amount of the ERC20 to withdraw.\\n     * @param _extraData Optional data forwarded from L2.\\n     */\\n    function finalizeERC20Withdrawal(\\n        address _l1Token,\\n        address _l2Token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _extraData\\n    ) external;\\n\\n    /**\\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\\n     *         ERC20 token on the other chain does not recognize the local token as the correct\\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\\n     *         this chain.\\n     *\\n     * @param localToken  Address of the ERC20 on this chain.\\n     * @param remoteToken Address of the corresponding token on the remote chain.\\n     * @param to          Address of the receiver.\\n     * @param amount      Amount of local tokens to deposit.\\n     * @param minGasLimit Minimum amount of gas that the bridge can be relayed with.\\n     * @param extraData   Extra data to be sent with the transaction. Note that the recipient will\\n     *                     not be triggered with this data, but it will be emitted and can be used\\n     *                     to identify the transaction.\\n     */\\n    function bridgeERC20To(\\n        address localToken,\\n        address remoteToken,\\n        address to,\\n        uint256 amount,\\n        uint32 minGasLimit,\\n        bytes calldata extraData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISocketVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.9;\\n\\ninterface ISocketVault {\\n    function depositToAppChain(address receiver_, uint256 amount_, uint256 msgGasLimit_, address connector_)\\n        external\\n        payable;\\n\\n    function __token() external view returns (address);\\n\\n    function getMinFees(address connector, uint256 minGasLimit) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC3009.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\ninterface IERC3009 {\\n    /**\\n     * @notice Execute a transfer with a signed authorization\\n     * @param from          Payer's address (Authorizer)\\n     * @param to            Payee's address\\n     * @param value         Amount to be transferred\\n     * @param validAfter    The time after which this is valid (unix time)\\n     * @param validBefore   The time before which this is valid (unix time)\\n     * @param nonce         Unique nonce\\n     * @param v             v of the signature\\n     * @param r             r of the signature\\n     * @param s             s of the signature\\n     */\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @notice Receive a transfer with a signed authorization from the payer\\n     * @dev This has an additional check to ensure that the payee's address matches\\n     * the caller of this function to prevent front-running attacks. (See security\\n     * considerations)\\n     * @param from          Payer's address (Authorizer)\\n     * @param to            Payee's address\\n     * @param value         Amount to be transferred\\n     * @param validAfter    The time after which this is valid (unix time)\\n     * @param validBefore   The time before which this is valid (unix time)\\n     * @param nonce         Unique nonce\\n     * @param v             v of the signature\\n     * @param r             r of the signature\\n     * @param s             s of the signature\\n     */\\n    function receiveWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILightAccountFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\ninterface ILightAccountFactory {\\n    /**\\n     * @notice Create an account, and return its address.\\n     * Returns the address even if the account is already deployed.\\n     * @dev During UserOperation execution, this method is called only if the account is not deployed.\\n     * This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation.\\n     * @param owner The owner of the account to be created\\n     * @param salt A salt, which can be changed to create multiple accounts with the same owner\\n     * @return ret The address of either the newly deployed account or an existing account with this owner and salt\\n     */\\n    function createAccount(address owner, uint256 salt) external returns (address ret);\\n\\n    /**\\n     * @notice Calculate the counterfactual address of this account as it would be returned by createAccount()\\n     * @param owner The owner of the account to be created\\n     * @param salt A salt, which can be changed to create multiple accounts with the same owner\\n     * @return The address of the account that would be created with createAccount()\\n     */\\n    function getAddress(address owner, uint256 salt) external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"account-abstraction/=lib/account-abstraction/contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"account-abstraction/=lib/account-abstraction/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"relay-context-contracts/=lib/relay-context-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdcLocal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_socketVault\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"RECEIVE_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isScwWallet\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"minGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct LyraForwarderBase.ReceiveWithAuthData\",\"name\":\"authData\",\"type\":\"tuple\"}],\"name\":\"depositUSDCSocketBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lightAccountFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"socketVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdcLocal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LyraSponsoredForwarder", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000006d303cee7959f814042d31e0624fb88ec6fbcc1d", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://985cf73a34e016bd3e5a983636d6d5222164277af4b3db33fa02291503c2707c"}