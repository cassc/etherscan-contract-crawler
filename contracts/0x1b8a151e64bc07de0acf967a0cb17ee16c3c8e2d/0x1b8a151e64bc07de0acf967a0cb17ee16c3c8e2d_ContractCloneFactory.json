{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/deployer/v1/factory/BaseProxyDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {IProxyDeployer} from \\\"../interfaces/IProxyDeployer.sol\\\";\\n\\nabstract contract BaseProxyDeployer is IProxyDeployer, Context {\\n\\n    /**\\n     * @dev Salted deterministic deployment of proxy contracts.\\n     *      Using the same implementation, salt, msgSender() multiple time will not deploy a new clone.\\n     * @param _implementation contract to be cloned\\n     * @param _initializingData calldata of the deployed contract's initializer function\\n     * @param _salt extra salt that's used to deterministically deploy the clone\\n     */\\n    function deployProxy(address _implementation, bytes memory _initializingData, bytes32 _salt)\\n    public override returns (address deployedContract) {\\n        if (_implementation.code.length == 0) {\\n            revert InvalidImplementation(_implementation);\\n        }\\n        (address addr, bytes32 mixedSalt) = getProxyAddress(_implementation, _initializingData, _salt);\\n        if (addr.code.length > 0) {\\n            return addr;\\n        }\\n        deployedContract = _deployProxy(_implementation, _initializingData, mixedSalt);\\n        emit ProxyDeployed(_implementation, deployedContract, mixedSalt);\\n    }\\n\\n    /**\\n     * @dev Pre-compute the counterfactual address prior to deployment of proxy contracts.\\n     * @param _implementation contract to be cloned\\n     * @param _initializingData calldata of the deployed contract's initializer function\\n     * @param _salt extra salt that's used to deterministically deploy the clone\\n     */\\n    function getProxyAddress(address _implementation, bytes memory _initializingData, bytes32 _salt)\\n    public override view returns (address calculatedContract, bytes32 mixedSalt) {\\n        mixedSalt = getMixedSalt(_initializingData, _salt);\\n        calculatedContract = _getProxyAddress(_implementation, _initializingData, mixedSalt);\\n    }\\n\\n    /**\\n     * @dev Helper method to get mixed salt that alleviates the front-running.\\n     * @param _initializingData calldata of the deployed contract's initializer function\\n     * @param _salt extra salt that's used to create the new contract at a deterministic address, e.g. 0x0\\n     */\\n    function getMixedSalt(bytes memory _initializingData, bytes32 _salt) public view returns (bytes32) {\\n        return keccak256(abi.encodePacked(keccak256(_initializingData), _salt, _msgSender()));\\n    }\\n\\n    function _deployProxy(address _implementation, bytes memory _initializingData, bytes32 _salt)\\n    internal virtual returns (address deployedContract);\\n\\n    function _getProxyAddress(address _implementation, bytes memory _initializingData, bytes32 _salt)\\n    internal virtual view returns (address calculatedContract);\\n}\\n\"\r\n    },\r\n    \"src/deployer/v1/factory/ContractCloneFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport {Clones} from \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport {ExecutionUtils} from \\\"../../../utils/ExecutionUtils.sol\\\";\\nimport {BaseProxyDeployer} from \\\"./BaseProxyDeployer.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n * A minimal proxy needs to do:\\n * 1. calldatacopy into memory\\n * 2. delegatecall into an implementation contract\\n * 3. returndatacopy into memory\\n * 4, return data to the caller or revert\\n * The exact runtime code of the standard clone contract is this:\\n * 363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\\n * wherein the bytes at indices 10 - 29 (inclusive) are replaced with the 20 byte address of the master functionality/implementation contract.\\n * The creation code, which includes the runtime code, is this:\\n * 3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\\n * 3d602d80600a3d3981f3 copies the runtime into memory.\\n * A reference implementation of this can be found at the optionality/clone-factory github repo.\\n */\\ncontract ContractCloneFactory is BaseProxyDeployer {\\n\\n    /**\\n     * @dev Salted deterministic deployment of minimal proxy contracts that mimics the behavior of implementation.\\n     *      Using the same implementation, salt, msgSender() multiple time will not deploy a new clone.\\n     * @param _implementation contract to be cloned\\n     * @param _initializingData calldata of the deployed contract's initializer function\\n     * @param _salt extra salt that's used to deterministically deploy the clone\\n     */\\n    function _deployProxy(address _implementation, bytes memory _initializingData, bytes32 _salt)\\n    internal override returns (address deployedContract) {\\n        deployedContract = Clones.cloneDeterministic(_implementation, _salt);\\n        if (_initializingData.length > 0) {\\n            ExecutionUtils.callAndRevert(deployedContract, 0, _initializingData);\\n        }\\n    }\\n\\n    /**\\n     * @dev Pre-compute the counterfactual address prior to deployment of minimal proxy contracts that mimics the behavior of implementation.\\n     * @param _implementation contract to be cloned\\n     * @param _initializingData calldata of the deployed contract's initializer function\\n     * @param _salt extra salt that's used to deterministically deploy the clone\\n     */\\n    function _getProxyAddress(address _implementation, bytes memory _initializingData, bytes32 _salt)\\n    internal override view returns (address calculatedContract) {\\n        (_initializingData);\\n        calculatedContract = Clones.predictDeterministicAddress(_implementation, _salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/deployer/v1/interfaces/IProxyDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\ninterface IProxyDeployer {\\n\\n    event ProxyDeployed(address indexed implementation, address proxy, bytes32 salt);\\n\\n    error InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev Salted deterministic deployment of proxy contracts.\\n     *      Using the same implementation, salt, msgSender() multiple time will not deploy a new clone.\\n     * @param _implementation contract to be cloned\\n     * @param _initializingData calldata of the deployed contract's initializer function\\n     * @param _salt extra salt that's used to deterministically deploy the clone\\n     */\\n    function deployProxy(address _implementation, bytes memory _initializingData, bytes32 _salt)\\n    external returns (address deployedContract);\\n\\n    /**\\n     * @dev Pre-compute the counterfactual address prior to deployment of proxy contracts.\\n     * @param _implementation contract to be cloned\\n     * @param _initializingData calldata of the deployed contract's initializer function\\n     * @param _salt extra salt that's used to deterministically deploy the clone\\n     */\\n    function getProxyAddress(address _implementation, bytes memory _initializingData, bytes32 _salt)\\n    external view returns (address calculatedContract, bytes32 mixedSalt);\\n}\\n\"\r\n    },\r\n    \"src/utils/ExecutionUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n// solhint-disable no-inline-assembly\\n\\n/**\\n * Utility functions helpful when making different kinds of contract calls in Solidity.\\n * For inline assembly, please refer to https://docs.soliditylang.org/en/latest/assembly.html\\n * For opcodes, please refer to https://ethereum.org/en/developers/docs/evm/opcodes/ and https://www.evm.codes/\\n */\\nlibrary ExecutionUtils {\\n\\n    function call(address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal returns (bool success, bytes memory returnData) {\\n        assembly {\\n            success := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\\n            let len := returndatasize()\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, add(len, 0x20)))\\n            mstore(ptr, len)\\n            returndatacopy(add(ptr, 0x20), 0, len)\\n            returnData := ptr\\n        }\\n    }\\n\\n    function revertWithData(bytes memory returnData) internal pure {\\n        assembly {\\n            revert(add(returnData, 32), mload(returnData))\\n        }\\n    }\\n\\n    function callAndRevert(address to,\\n        uint256 value,\\n        bytes memory data) internal {\\n        (bool success, bytes memory returnData) = call(to, value, data);\\n        if (!success) {\\n            revertWithData(returnData);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"remappings\": [\r\n      \"@account-abstraction/=lib/account-abstraction/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/\",\r\n      \"account-abstraction/=lib/account-abstraction/contracts/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\"\r\n    ],\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"InvalidImplementation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"ProxyDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_initializingData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"deployProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployedContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_initializingData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"getMixedSalt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_initializingData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"getProxyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"calculatedContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"mixedSalt\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ContractCloneFactory", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}