{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/UniswapV2Twap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// WARNING! This smart contract has not been audited.\\n// DO NOT USE THIS CONTRACT FOR PRODUCTION\\n// This is an example contract to demonstrate how to integrate an application with the audited production release of AxiomV1 and AxiomV1Query.\\npragma solidity 0.8.19;\\n\\nimport {Ownable} from \\\"openzeppelin-contracts/access/Ownable.sol\\\";\\nimport {IAxiomV1Query} from \\\"axiom-contracts/contracts/interfaces/IAxiomV1Query.sol\\\";\\nimport \\\"utils/RLPReader.sol\\\";\\nimport \\\"utils/UQ112x112.sol\\\";\\n\\ncontract UniswapV2Twap is Ownable {\\n    using RLPReader for RLPReader.RLPItem;\\n    using RLPReader for RLPReader.Iterator;\\n    using RLPReader for bytes;\\n    using UQ112x112 for uint224;\\n\\n    address public axiomQueryAddress;\\n    mapping(bytes28 => uint256) public twapPris;\\n\\n    event UniswapV2TwapProof(address pairAddress, uint32 startBlockNumber, uint32 endBlockNumber, uint256 twapPri);\\n\\n    event UpdateAxiomQueryAddress(address newAddress);\\n\\n    constructor(address _axiomQueryAddress) {\\n        axiomQueryAddress = _axiomQueryAddress;\\n        emit UpdateAxiomQueryAddress(_axiomQueryAddress);\\n    }\\n\\n    function updateAxiomQueryAddress(address _axiomQueryAddress) external onlyOwner {\\n        axiomQueryAddress = _axiomQueryAddress;\\n        emit UpdateAxiomQueryAddress(_axiomQueryAddress);\\n    }\\n\\n    function _getTimestampFromBlock(uint32 blockNumber, bytes32 blockHash, bytes memory rlpEncodedHeader)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(keccak256(rlpEncodedHeader) == blockHash, \\\"invalid blockhash\\\");\\n\\n        RLPReader.RLPItem[] memory ls = rlpEncodedHeader.toRlpItem().toList();\\n        require(blockNumber == ls[8].toUint(), \\\"invalid block number\\\");\\n        uint256 timestamp = ls[11].toUint();\\n        return timestamp;\\n    }\\n\\n    function _currentCumulativePrice(\\n        uint112 reserve0,\\n        uint112 reserve1,\\n        uint256 blockTimestamp,\\n        uint32 blockTimestampLast,\\n        uint256 price1CumulativeLast\\n    ) internal pure returns (uint256) {\\n        //overflow is desired\\n        unchecked {\\n            uint256 increment =\\n                uint256(UQ112x112.encode(reserve1).uqdiv(reserve0)) * (blockTimestamp - blockTimestampLast);\\n            return increment + price1CumulativeLast;\\n        }\\n    }\\n\\n    // slot is structured as follows:\\n    // blockTimestampLast (32) . reserves1 (112) . reserves0 (112)\\n    function _unpackReserveValues(uint256 slot) internal pure returns (uint112, uint112, uint32) {\\n        uint112 reserve0 = uint112(slot >> 144);\\n        uint112 reserve1 = uint112(slot >> 32);\\n        uint32 blockTimestampLast = uint32(slot);\\n        return (reserve0, reserve1, blockTimestampLast);\\n    }\\n\\n    /*  | Name                 | Type                                            | Slot | Offset | Bytes | Contract                                  |\\n        |----------------------|-------------------------------------------------|------|--------|-------|-------------------------------------------|\\n        | totalSupply          | uint256                                         | 0    | 0      | 32    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | balanceOf            | mapping(address => uint256)                     | 1    | 0      | 32    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | allowance            | mapping(address => mapping(address => uint256)) | 2    | 0      | 32    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | DOMAIN_SEPARATOR     | bytes32                                         | 3    | 0      | 32    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | nonces               | mapping(address => uint256)                     | 4    | 0      | 32    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | factory              | address                                         | 5    | 0      | 20    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | token0               | address                                         | 6    | 0      | 20    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | token1               | address                                         | 7    | 0      | 20    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | reserve0             | uint112                                         | 8    | 0      | 14    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | reserve1             | uint112                                         | 8    | 14     | 14    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | blockTimestampLast   | uint32                                          | 8    | 28     | 4     | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | price0CumulativeLast | uint256                                         | 9    | 0      | 32    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | price1CumulativeLast | uint256                                         | 10   | 0      | 32    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | kLast                | uint256                                         | 11   | 0      | 32    | contracts/UniswapV2Pair.sol:UniswapV2Pair |\\n        | unlocked             | uint256                                         | 12   | 0      | 32    | contracts/UniswapV2Pair.sol:UniswapV2Pair | \\n    */\\n\\n    function calculateUniswapV2Twap(\\n        IAxiomV1Query.StorageResponse[] calldata storageProofs,\\n        IAxiomV1Query.BlockResponse[] calldata blockProofs,\\n        bytes[2] calldata rlpEncodedHeaders,\\n        bytes32[3] calldata keccakResponses\\n    ) public returns (uint256) {\\n        require(storageProofs[0].slot == 8 && storageProofs[2].slot == 8, \\\"invalid reserve slot\\\");\\n        require(storageProofs[1].slot == 10 && storageProofs[3].slot == 10, \\\"invalid cumulative price slot\\\");\\n        require(\\n            storageProofs[0].blockNumber == storageProofs[1].blockNumber\\n                && storageProofs[0].blockNumber == blockProofs[0].blockNumber,\\n            \\\"inconsistent block number\\\"\\n        );\\n        require(\\n            storageProofs[2].blockNumber == storageProofs[3].blockNumber\\n                && storageProofs[2].blockNumber == blockProofs[1].blockNumber,\\n            \\\"inconsistent block number\\\"\\n        );\\n        require(\\n            storageProofs[0].addr == storageProofs[1].addr && storageProofs[0].addr == storageProofs[2].addr\\n                && storageProofs[0].addr == storageProofs[3].addr,\\n            \\\"inconsistent pair address\\\"\\n        );\\n        require(\\n            IAxiomV1Query(axiomQueryAddress).areResponsesValid(\\n                keccakResponses[0],\\n                keccakResponses[1],\\n                keccakResponses[2],\\n                blockProofs,\\n                new IAxiomV1Query.AccountResponse[](0),\\n                storageProofs\\n            ),\\n            \\\"invalid proofs\\\"\\n        );\\n\\n        uint256 blockTimestamp_k1 =\\n            _getTimestampFromBlock(blockProofs[0].blockNumber, blockProofs[0].blockHash, rlpEncodedHeaders[0]);\\n\\n        uint256 blockTimestamp_k2 =\\n            _getTimestampFromBlock(blockProofs[1].blockNumber, blockProofs[1].blockHash, rlpEncodedHeaders[1]);\\n\\n        (uint112 reserve0_k1, uint112 reserve1_k1, uint32 blockTimestampLast_k1) =\\n            _unpackReserveValues(storageProofs[0].value);\\n\\n        (uint112 reserve0_k2, uint112 reserve1_k2, uint32 blockTimestampLast_k2) =\\n            _unpackReserveValues(storageProofs[2].value);\\n\\n        uint256 currentCumulativePrice_k1 = _currentCumulativePrice(\\n            reserve0_k1, reserve1_k1, blockTimestamp_k1, blockTimestampLast_k1, storageProofs[1].value\\n        );\\n\\n        uint256 currentCumulativePrice_k2 = _currentCumulativePrice(\\n            reserve0_k2, reserve1_k2, blockTimestamp_k2, blockTimestampLast_k2, storageProofs[3].value\\n        );\\n\\n        uint256 twap = (currentCumulativePrice_k2 - currentCumulativePrice_k1) / (blockTimestamp_k2 - blockTimestamp_k1);\\n\\n        twapPris[bytes28(\\n            abi.encodePacked(storageProofs[0].addr, blockProofs[0].blockNumber, blockProofs[1].blockNumber)\\n        )] = twap;\\n\\n        emit UniswapV2TwapProof(storageProofs[0].addr, blockProofs[0].blockNumber, blockProofs[1].blockNumber, twap);\\n\\n        return twap;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/axiom-v1-contracts/contracts/interfaces/IAxiomV1Query.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"./core/IAxiomV1Verifier.sol\\\";\\n\\n// The depth of the Merkle root of queries in:\\n//   `keccakBlockResponse`, `keccakAccountResponse`, and `keccakStorageResponse`\\nuint32 constant QUERY_MERKLE_DEPTH = 6;\\n\\ninterface IAxiomV1Query {\\n    /// @notice States of an on-chain query\\n    /// @param  Inactive The query has not been made or was refunded.\\n    /// @param  Active The query has been requested, but not fulfilled.\\n    /// @param  Fulfilled The query was successfully fulfilled.\\n    enum AxiomQueryState {\\n        Inactive,\\n        Active,\\n        Fulfilled\\n    }\\n\\n    /// @notice Stores metadata about a query \\n    /// @param  payment The ETH payment received, in wei. \\n    /// @param  state The state of the query.\\n    /// @param  deadlineBlockNumber The deadline (in block number) after which a refund may be granted.\\n    /// @param  refundee The address funds should be returned to if the query is not fulfilled.\\n    struct AxiomQueryMetadata {\\n        uint256 payment;\\n        AxiomQueryState state; \\n        uint32 deadlineBlockNumber;\\n        address payable refundee;\\n    }\\n\\n    /// @notice Response values read from ZK proof for query.\\n    /// @param  poseidonBlockResponse Poseidon Merkle root of `poseidon(blockHash . blockNumber . poseidon_tree_root(block_header))`\\n    /// @param  keccakBlockResponse Keccak Merkle root of `keccak(blockHash . blockNumber)` \\n    /// @param  poseidonAccountResponse Poseidon Merkle root of `poseidon(poseidonBlockResponseRow . poseidon(stateRoot . addr . poseidon_tree_root(account_state)))`\\n    /// @param  keccakAccountResponse Keccak Merkle root of `keccak(blockNumber . addr . keccak(nonce . balance . storageRoot . codeHash))`\\n    /// @param  poseidonStorageResponse Poseidon Merkle root of `poseidon(poseidonBlockResponseRow . poseidonAccountResponseRow . poseidon(storageRoot . slot . value))`\\n    /// @param  keccakStorageResponse Keccak Merkle root of `keccak(blockNumber . addr . slot . value)`\\n    /// @param  historicalMMRKeccak `keccak256(abi.encodePacked(mmr[10:]))`\\n    /// @param  recentMMRKeccak `keccak256(abi.encodePacked(mmr[:10]))`\\n    //  Detailed documentation on format here: https://hackmd.io/@axiom/S17K2drf2\\n    //  ** `poseidonBlockResponseRow = poseidon(blockHash . blockNumber . poseidon_tree_root(block_header))`\\n    //  ** `poseidonAccountResponseRow = poseidon(stateRoot . addr . poseidon_tree_root(account_state)))`\\n    //  ** `mmr` is a variable length array of bytes32 containing the Merkle Mountain Range the ZK proof is proving into.\\n    //     `mmr[idx]` is either `bytes32(0)` or the Merkle root of `1 << idx` block hashes.\\n    //  ** `mmr` is guaranteed to have length at least `10` and at most `32`.\\n    struct AxiomMMRQueryResponse {\\n        bytes32 poseidonBlockResponse;\\n        bytes32 keccakBlockResponse;\\n        bytes32 poseidonAccountResponse; \\n        bytes32 keccakAccountResponse;\\n        bytes32 poseidonStorageResponse;\\n        bytes32 keccakStorageResponse;\\n        bytes32 historicalMMRKeccak;\\n        bytes32 recentMMRKeccak;\\n    }\\n\\n    /// @notice Stores witness data for checking MMRs\\n    /// @param  prevHash The `prevHash` as in `IAxiomV1State`.\\n    /// @param  root The `root` as in `IAxiomV1State`.\\n    /// @param  numFinal The `numFinal` as in `IAxiomV1State`.  \\n    /// @param  startBlockNumber The `startBlockNumber` as in `IAxiomV1State`.\\n    /// @param  recentMMRPeaks Peaks of the MMR committed to in the public input `recentMMRKeccak` of the ZK proof.\\n    /// @param  mmrComplementOrPeaks If `len(recentMMRPeaks) <= numFinal`, then this is a complementary MMR containing  \\n    ///         the complement of `recentMMRPeaks` which together with `recentMMRPeaks` forms `root`.  \\n    ///         If `len(recentMMRPeaks) > numFinal`, then this is the MMR peaks of the `numFinal` blockhashes commited\\n    ///         to in `root`.\\n    struct RecentMMRWitness {\\n        bytes32 prevHash;\\n        bytes32 root;\\n        uint32 numFinal;\\n        uint32 startBlockNumber;        \\n        bytes32[10] recentMMRPeaks;\\n        bytes32[10] mmrComplementOrPeaks;\\n    }\\n\\n    /// @notice Store a query result into a single block\\n    /// @param  blockNumber The block number.\\n    /// @param  blockHash The block hash.\\n    /// @param  leafIdx The position of this result in the Merkle tree committed to by `keccakBlockResponse`.\\n    /// @param  proof A Merkle proof into `keccakBlockResponse`.\\n    struct BlockResponse {\\n        uint32 blockNumber;\\n        bytes32 blockHash;\\n\\n        uint32 leafIdx;\\n        bytes32[QUERY_MERKLE_DEPTH] proof;\\n    }\\n\\n    /// @notice Store a query result into a single block\\n    /// @param  blockNumber The block number.\\n    /// @param  addr The address.\\n    /// @param  nonce The nonce.\\n    /// @param  balance The balance.\\n    /// @param  storageRoot The storage root.\\n    /// @param  codeHash The code hash.\\n    /// @param  leafIdx The position of this result in the Merkle tree committed to by `keccakAccountResponse`.\\n    /// @param  proof A Merkle proof into `keccakAccountResponse`.\\n    //  Note: Fields are zero-padded by prefixing with zero bytes to:\\n    //    * `nonce`: 8 bytes\\n    //    * `balance`: 12 bytes\\n    //    * `storageRoot`: 32 bytes\\n    //    * `codeHash`: 32 bytes    \\n    struct AccountResponse {\\n        uint32 blockNumber;        \\n        address addr;\\n        uint64 nonce;\\n        uint96 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n\\n        uint32 leafIdx;\\n        bytes32[QUERY_MERKLE_DEPTH] proof;\\n    }\\n\\n    /// @notice Store a query result into a single block\\n    /// @param  blockNumber The block number.\\n    /// @param  addr The address.\\n    /// @param  slot The storage slot index. \\n    /// @param  value The storage slot value.\\n    /// @param  leafIdx The position of this result in the Merkle tree committed to by `keccakStorageResponse`.\\n    /// @param  proof A Merkle proof into `keccakStorageResponse`.\\n    struct StorageResponse {\\n        uint32 blockNumber;\\n        address addr;\\n        uint256 slot;\\n        uint256 value;\\n\\n        uint32 leafIdx;\\n        bytes32[QUERY_MERKLE_DEPTH] proof;\\n    }    \\n\\n    /// @notice Read the set of verified query responses in Keccak form.\\n    /// @param  hash `verifiedKeccakResults(keccak256(keccakBlockResponse . keccakAccountResponse . keccakStorageResponse)) == true` \\n    ///         if and only if each of `keccakBlockResponse`, `keccakAccountResponse`, and `keccakStorageResponse` have been verified\\n    ///         on-chain by a ZK proof.\\n    function verifiedKeccakResults(bytes32 hash) external view returns (bool);\\n\\n    /// @notice Read the set of verified query responses in Poseidon form.\\n    /// @param  hash `verifiedPoseidonResults(keccak256(poseidonBlockResponse . poseidonAccountResponse . poseidonStorageResponse)) == true` \\n    ///         if and only if each of `poseidonBlockResponse`, `poseidonAccountResponse`, and `poseidonStorageResponse` have been\\n    ///         verified on-chain by a ZK proof.\\n    function verifiedPoseidonResults(bytes32 hash) external view returns (bool);\\n\\n    /// @notice Returns the metadata associated to a query\\n    /// @param  keccakQueryResponse The hash of the query response.\\n    function queries(bytes32 keccakQueryResponse) external view \\n        returns (\\n            uint256 payment,\\n            AxiomQueryState state,\\n            uint32 deadlineBlockNumber,\\n            address payable refundee\\n        );\\n\\n    /// @notice Emitted when the `AxiomV1Core` address is updated.\\n    /// @param  newAddress The updated address.\\n    event UpdateAxiomAddress(address newAddress);\\n\\n    /// @notice Emitted when the batch query verifier address is updated.\\n    /// @param  newAddress The updated address.\\n    event UpdateMMRVerifierAddress(address newAddress);\\n\\n    /// @notice Emitted when a Keccak result is recorded\\n    /// @param  keccakBlockResponse As documented in `AxiomMMRQueryResponse`.\\n    /// @param  keccakAccountResponse As documented in `AxiomMMRQueryResponse`.\\n    /// @param  keccakStorageResponse As documented in `AxiomMMRQueryResponse`.\\n    event KeccakResultEvent(bytes32 keccakBlockResponse, bytes32 keccakAccountResponse, bytes32 keccakStorageResponse);\\n\\n    /// @notice Emitted when a Poseidon result is recorded\\n    /// @param  poseidonBlockResponse As documented in `AxiomMMRQueryResponse`.\\n    /// @param  poseidonAccountResponse As documented in `AxiomMMRQueryResponse`.\\n    /// @param  poseidonStorageResponse As documented in `AxiomMMRQueryResponse`.\\n    event PoseidonResultEvent(bytes32 poseidonBlockResponse, bytes32 poseidonAccountResponse, bytes32 poseidonStorageResponse);\\n\\n    /// @notice Emitted when the `minQueryPrice` is updated.\\n    /// @param  minQueryPrice The new `minQueryPrice`.\\n    event UpdateMinQueryPrice(uint256 minQueryPrice);\\n\\n    /// @notice Emitted when the `maxQueryPrice` is updated.\\n    /// @param  maxQueryPrice The new `maxQueryPrice`.\\n    event UpdateMaxQueryPrice(uint256 maxQueryPrice);\\n\\n    /// @notice Emitted when the `queryDeadlineInterval` is updated.\\n    /// @param  queryDeadlineInterval The new `queryDeadlineInterval`.\\n    event UpdateQueryDeadlineInterval(uint32 queryDeadlineInterval);\\n\\n    /// @notice Emitted when a new query with off-chain data availability is requested.\\n    /// @param  keccakQueryResponse The hash of the claimed query response.\\n    /// @param  payment The ETH payment offered, in wei.\\n    /// @param  deadlineBlockNumber The deadline block number after which a refund is possible.\\n    /// @param  refundee The address of the refundee.\\n    /// @param  ipfsHash A content-addressed hash on IPFS where the query spec may be found.\\n    event QueryInitiatedOffchain(bytes32 keccakQueryResponse, uint256 payment, uint32 deadlineBlockNumber, address refundee, bytes32 ipfsHash);\\n\\n    /// @notice Emitted when a new query with on-chain data availability is requested.\\n    /// @param  keccakQueryResponse The hash of the claimed query response.\\n    /// @param  payment The ETH payment offered, in wei.\\n    /// @param  deadlineBlockNumber The deadline block number after which a refund is possible.\\n    /// @param  refundee The address of the refundee.\\n    /// @param  queryHash The hash of the on-chain query.    \\n    event QueryInitiatedOnchain(bytes32 keccakQueryResponse, uint256 payment, uint32 deadlineBlockNumber, address refundee, bytes32 queryHash);\\n\\n    /// @notice Emitted when a query is fulfilled.\\n    /// @param  keccakQueryResponse The hash of the query response.\\n    /// @param  payment The ETH payment collected, in wei.\\n    /// @param  prover The address of the prover collecting payment.\\n    event QueryFulfilled(bytes32 keccakQueryResponse, uint256 payment, address prover);\\n\\n    /// @notice Emitted when a query is refunded.\\n    /// @param  keccakQueryResponse The hash of the query response.\\n    /// @param  payment The ETH payment refunded minus gas, in wei.\\n    /// @param  refundee The address collecting the refund.    \\n    event QueryRefunded(bytes32 keccakQueryResponse, uint256 payment, uint32 deadlineBlockNumber, address refundee);\\n\\n    /// @notice Verify a query result on-chain.\\n    /// @param  mmrIdx The index of the cached MMR to verify against.\\n    /// @param  mmrWitness Witness data to reconcile `recentMMR` against `historicalRoots`.\\n    /// @param  proof The ZK proof data.\\n    function verifyResultVsMMR(\\n        uint32 mmrIdx, \\n        RecentMMRWitness calldata mmrWitness,                   \\n        bytes calldata proof\\n    ) external;                \\n\\n    /// @notice Request proof for query with on-chain query data availability.\\n    /// @param  keccakQueryResponse The Keccak-encoded query response.\\n    /// @param  refundee The address refunds should be sent to.\\n    /// @param  query The serialized query.\\n    function sendQuery(bytes32 keccakQueryResponse, address payable refundee, bytes calldata query) external payable;\\n\\n    /// @notice Request proof for query with off-chain query data availability.\\n    /// @param  keccakQueryResponse The Keccak-encoded query response.\\n    /// @param  refundee The address refunds should be sent to.\\n    /// @param  ipfsHash The IPFS hash the query should optionally be posted to.\\n    function sendOffchainQuery(bytes32 keccakQueryResponse, address payable refundee, bytes32 ipfsHash) external payable;\\n\\n    /// @notice Fulfill a query request on-chain.\\n    /// @param  keccakQueryResponse The hashed query response.\\n    /// @param  payee The address to send payment to.\\n    /// @param  mmrIdx The index of the cached MMR to verify against.\\n    /// @param  mmrWitness Witness data to reconcile `recentMMR` against `historicalRoots`.\\n    /// @param  proof The ZK proof data.\\n    function fulfillQueryVsMMR(\\n        bytes32 keccakQueryResponse, \\n        address payable payee, \\n        uint32 mmrIdx, \\n        RecentMMRWitness calldata mmrWitness,          \\n        bytes calldata proof\\n    ) external;\\n\\n    /// @notice Trigger refund collection for a query after the deadline has expired.\\n    /// @param keccakQueryResponse THe hashed query response.\\n    function collectRefund(bytes32 keccakQueryResponse) external;\\n\\n    /// @notice Checks whether an unpacked query response has already been verified.\\n    /// @param  keccakBlockResponse As documented in `AxiomMMRQueryResponse`.\\n    /// @param  keccakAccountResponse As documented in `AxiomMMRQueryResponse`.\\n    /// @param  keccakStorageResponse As documented in `AxiomMMRQueryResponse`.\\n    function isKeccakResultValid(bytes32 keccakBlockResponse, bytes32 keccakAccountResponse, bytes32 keccakStorageResponse)\\n        external\\n        view\\n        returns (bool);\\n\\n    /// @notice Checks whether an unpacked query response has already been verified.\\n    /// @param  poseidonBlockResponse As documented in `AxiomMMRQueryResponse`.\\n    /// @param  poseidonAccountResponse As documented in `AxiomMMRQueryResponse`.\\n    /// @param  poseidonStorageResponse As documented in `AxiomMMRQueryResponse`.\\n    function isPoseidonResultValid(bytes32 poseidonBlockResponse, bytes32 poseidonAccountResponse, bytes32 poseidonStorageResponse)\\n        external\\n        view\\n        returns (bool);        \\n\\n    /// @notice Verify block, account, and storage data against responses which have already been proven.\\n    /// @param  keccakBlockResponse As documented in `AxiomMMRQueryResponse`.\\n    /// @param  keccakAccountResponse As documented in `AxiomMMRQueryResponse`.\\n    /// @param  keccakStorageResponse As documented in `AxiomMMRQueryResponse`.\\n    /// @param  blockResponses The list of block results.\\n    /// @param  accountResponses The list of account results.\\n    /// @param  storageResponses The list of storage results.\\n    // block_response = keccak(blockHash . blockNumber)\\n    // account_response = hash(blockNumber . address . hash_tree_root(account_state))\\n    // storage_response = hash(blockNumber . address . slot . value)\\n    function areResponsesValid(\\n        bytes32 keccakBlockResponse,\\n        bytes32 keccakAccountResponse,\\n        bytes32 keccakStorageResponse,\\n        BlockResponse[] calldata blockResponses,\\n        AccountResponse[] calldata accountResponses,\\n        StorageResponse[] calldata storageResponses\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/utils/RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n// Original source @ https://github.com/hamdiallam/Solidity-RLP.\\n\\n/**\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity ^0.8.16;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * RLPItem conversions into data types *\\n     */\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shfit to the correct location if neccesary\\n            if lt(len, 32) { result := div(result, exp(256, sub(32, len))) }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256 ** (WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\"\r\n    },\r\n    \"lib/utils/UQ112x112.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/axiom-v1-contracts/contracts/interfaces/core/IAxiomV1Verifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {BLOCK_BATCH_DEPTH} from \\\"../../libraries/configuration/AxiomV1Configuration.sol\\\";\\n\\ninterface IAxiomV1Verifier {\\n    /// @notice A merkle proof to verify a block against the verified blocks cached by Axiom\\n    /// @dev    `BLOCK_BATCH_DEPTH = 10`\\n    struct BlockHashWitness {\\n        uint32 blockNumber;\\n        bytes32 claimedBlockHash;\\n        bytes32 prevHash;\\n        uint32 numFinal;\\n        bytes32[BLOCK_BATCH_DEPTH] merkleProof;\\n    }\\n\\n    /// @notice Verify the blockhash of block blockNumber equals claimedBlockHash. Assumes that blockNumber is within the last 256 most recent blocks.\\n    /// @param  blockNumber The block number to verify\\n    /// @param  claimedBlockHash The claimed blockhash of block blockNumber\\n    function isRecentBlockHashValid(uint32 blockNumber, bytes32 claimedBlockHash) external view returns (bool);\\n\\n    /// @notice Verify the blockhash of block witness.blockNumber equals witness.claimedBlockHash by checking against Axiom's cache of #historicalRoots.\\n    /// @dev    For block numbers within the last 256, use #isRecentBlockHashValid instead.\\n    /// @param  witness The block hash to verify and the Merkle proof to verify it\\n    ///         witness.blockNumber is the block number to verify\\n    ///         witness.claimedBlockHash is the claimed blockhash of block witness.blockNumber\\n    ///         witness.prevHash is the prevHash stored in #historicalRoots(witness.blockNumber - witness.blockNumber % 1024)\\n    ///         witness.numFinal is the numFinal stored in #historicalRoots(witness.blockNumber - witness.blockNumber % 1024)\\n    ///         witness.merkleProof is the Merkle inclusion proof of witness.claimedBlockHash to the root stored in #historicalRoots(witness.blockNumber - witness.blockNumber % 1024)\\n    ///         witness.merkleProof[i] is the sibling of the Merkle node at depth 10 - i, for i = 0, ..., 10\\n    function isBlockHashValid(BlockHashWitness calldata witness) external view returns (bool);\\n\\n    /// @notice Verify the blockhash of block blockNumber equals claimedBlockHash by checking against Axiom's cache of historical Merkle mountain ranges in #mmrRingBuffer.\\n    /// @dev    Use event logs to determine the correct bufferId and get the MMR at that index in the ring buffer.\\n    /// @param  mmr The Merkle mountain range commited to in #mmrRingBuffer(bufferId), must be correct length\\n    /// @param  bufferId The index in the ring buffer of #mmrRingBuffer\\n    /// @param  blockNumber The block number to verify\\n    /// @param  claimedBlockHash The claimed blockhash of block blockNumber\\n    /// @param  merkleProof The Merkle inclusion proof of claimedBlockHash to the corresponding peak in mmr. The correct peak is calculated from mmr.length and blockNumber.\\n    function mmrVerifyBlockHash(\\n        bytes32[] calldata mmr,\\n        uint8 bufferId,\\n        uint32 blockNumber,\\n        bytes32 claimedBlockHash,\\n        bytes32[] calldata merkleProof\\n    ) external view;\\n}\\n\"\r\n    },\r\n    \"lib/axiom-v1-contracts/contracts/libraries/configuration/AxiomV1Configuration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n// Constants and free functions to be inlined into by AxiomV1Core\\n\\n// ZK circuit constants:\\n\\n// AxiomV1 caches blockhashes in batches, stored as Merkle roots of binary Merkle trees\\nuint32 constant BLOCK_BATCH_SIZE = 1024;\\nuint32 constant BLOCK_BATCH_DEPTH = 10;\\n\\n// constants for batch import of historical block hashes\\n// historical uploads a bigger batch of block hashes, stored as Merkle roots of binary Merkle trees\\nuint32 constant HISTORICAL_BLOCK_BATCH_SIZE = 131072; // 2 ** 17\\nuint32 constant HISTORICAL_BLOCK_BATCH_DEPTH = 17;\\n// we will consider the historical Merkle tree of blocks as a Merkle tree of the block batch roots\\nuint32 constant HISTORICAL_NUM_ROOTS = 128; // HISTORICAL_BATCH_SIZE / BLOCK_BATCH_SIZE\\n\\n// The first 4 * 3 * 32 bytes of proof calldata are reserved for two BN254 G1 points for a pairing check\\n// It will then be followed by (7 + BLOCK_BATCH_DEPTH * 2) * 32 bytes of public inputs/outputs\\nuint32 constant AUX_PEAKS_START_IDX = 608; // PUBLIC_BYTES_START_IDX + 7 * 32\\n\\n// Historical MMR Ring Buffer constants\\nuint32 constant MMR_RING_BUFFER_SIZE = 8;\\n\\n/// @dev proofData stores bytes32 and uint256 values in hi-lo format as two uint128 values because the BN254 scalar field is 254 bits\\n/// @dev The first 12 * 32 bytes of proofData are reserved for ZK proof verification data\\n// Extract public instances from proof\\n// The public instances are laid out in the proof calldata as follows:\\n// First 4 * 3 * 32 = 384 bytes are reserved for proof verification data used with the pairing precompile\\n// 384..384 + 32 * 2: prevHash (32 bytes) as two uint128 cast to uint256, because zk proof uses 254 bit field and cannot fit uint256 into a single element\\n// 384 + 32 * 2..384 + 32 * 4: endHash (32 bytes) as two uint128 cast to uint256\\n// 384 + 32 * 4..384 + 32 * 5: startBlockNumber (uint32: 4 bytes) and endBlockNumber (uint32: 4 bytes) are concatenated as `startBlockNumber . endBlockNumber` (8 bytes) and then cast to uint256\\n// 384 + 32 * 5..384 + 32 * 7: root (32 bytes) as two uint128 cast to uint256, this is the highest peak of the MMR if endBlockNumber - startBlockNumber == 1023, otherwise 0\\nfunction getBoundaryBlockData(bytes calldata proofData)\\n    pure\\n    returns (bytes32 prevHash, bytes32 endHash, uint32 startBlockNumber, uint32 endBlockNumber, bytes32 root)\\n{\\n    prevHash = bytes32(uint256(bytes32(proofData[384:416])) << 128 | uint256(bytes32(proofData[416:448])));\\n    endHash = bytes32(uint256(bytes32(proofData[448:480])) << 128 | uint256(bytes32(proofData[480:512])));\\n    startBlockNumber = uint32(bytes4(proofData[536:540]));\\n    endBlockNumber = uint32(bytes4(proofData[540:544]));\\n    root = bytes32(uint256(bytes32(proofData[544:576])) << 128 | uint256(bytes32(proofData[576:608])));\\n}\\n\\n// We have a Merkle mountain range of max depth BLOCK_BATCH_DEPTH (so length BLOCK_BATCH_DEPTH + 1 total) ordered in **decreasing** order of peak size, so:\\n// `root` from `getBoundaryBlockData` is the peak for depth BLOCK_BATCH_DEPTH\\n// `getAuxMmrPeak(proofData, i)` is the peaks for depth BLOCK_BATCH_DEPTH - 1 - i\\n// 384 + 32 * 7 + 32 * 2 * i .. 384 + 32 * 7 + 32 * 2 * (i + 1): (32 bytes) as two uint128 cast to uint256, same as blockHash\\n// Note that the decreasing ordering is *different* than the convention in library MerkleMountainRange\\nfunction getAuxMmrPeak(bytes calldata proofData, uint256 i) pure returns (bytes32) {\\n    return bytes32(\\n        uint256(bytes32(proofData[AUX_PEAKS_START_IDX + i * 64:AUX_PEAKS_START_IDX + i * 64 + 32])) << 128\\n            | uint256(bytes32(proofData[AUX_PEAKS_START_IDX + i * 64 + 32:AUX_PEAKS_START_IDX + (i + 1) * 64]))\\n    );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=lib/axiom-v1-contracts/lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/axiom-v1-contracts/lib/openzeppelin-contracts/contracts/\",\r\n      \"axiom-contracts/=lib/axiom-v1-contracts/\",\r\n      \"axiom-v1-contracts/=lib/axiom-v1-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/axiom-v1-contracts/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"utils/=lib/utils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_axiomQueryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pairAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startBlockNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"endBlockNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"twapPri\",\"type\":\"uint256\"}],\"name\":\"UniswapV2TwapProof\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UpdateAxiomQueryAddress\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"axiomQueryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"leafIdx\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[6]\",\"name\":\"proof\",\"type\":\"bytes32[6]\"}],\"internalType\":\"struct IAxiomV1Query.StorageResponse[]\",\"name\":\"storageProofs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"leafIdx\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[6]\",\"name\":\"proof\",\"type\":\"bytes32[6]\"}],\"internalType\":\"struct IAxiomV1Query.BlockResponse[]\",\"name\":\"blockProofs\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[2]\",\"name\":\"rlpEncodedHeaders\",\"type\":\"bytes[2]\"},{\"internalType\":\"bytes32[3]\",\"name\":\"keccakResponses\",\"type\":\"bytes32[3]\"}],\"name\":\"calculateUniswapV2Twap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes28\",\"name\":\"\",\"type\":\"bytes28\"}],\"name\":\"twapPris\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_axiomQueryAddress\",\"type\":\"address\"}],\"name\":\"updateAxiomQueryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UniswapV2Twap", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d617ab7f787adf64c2b5b920c251ea10cd35a952", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}