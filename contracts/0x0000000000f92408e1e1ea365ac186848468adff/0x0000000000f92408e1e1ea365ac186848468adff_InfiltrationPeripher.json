{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/InfiltrationPeriphery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {IERC20} from \\\"@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\\\";\\nimport {LowLevelWETH} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\\\";\\nimport {ITransferManager} from \\\"@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\\\";\\nimport {IInfiltration} from \\\"./interfaces/IInfiltration.sol\\\";\\nimport {IV3SwapRouter} from \\\"./interfaces/IV3SwapRouter.sol\\\";\\nimport {IQuoterV2} from \\\"./interfaces/IQuoterV2.sol\\\";\\n\\ncontract InfiltrationPeriphery is LowLevelWETH {\\n    ITransferManager public immutable TRANSFER_MANAGER;\\n    IInfiltration public immutable INFILTRATION;\\n    IV3SwapRouter public immutable SWAP_ROUTER;\\n    IQuoterV2 public immutable QUOTER;\\n    address public immutable WETH;\\n    address public immutable LOOKS;\\n\\n    uint24 private constant POOL_FEE = 3_000;\\n\\n    constructor(\\n        address _transferManager,\\n        address _infiltration,\\n        address _uniswapRouter,\\n        address _uniswapQuoter,\\n        address _weth,\\n        address _looks\\n    ) {\\n        TRANSFER_MANAGER = ITransferManager(_transferManager);\\n        INFILTRATION = IInfiltration(_infiltration);\\n        SWAP_ROUTER = IV3SwapRouter(_uniswapRouter);\\n        QUOTER = IQuoterV2(_uniswapQuoter);\\n        WETH = _weth;\\n        LOOKS = _looks;\\n\\n        address[] memory operators = new address[](1);\\n        operators[0] = address(INFILTRATION);\\n        TRANSFER_MANAGER.grantApprovals(operators);\\n    }\\n\\n    /**\\n     * @notice Submits a heal request for the specified agent IDs.\\n     * @param agentIds The agent IDs to heal.\\n     */\\n    function heal(uint256[] calldata agentIds) external payable {\\n        uint256 costToHealInLOOKS = INFILTRATION.costToHeal(agentIds);\\n\\n        IV3SwapRouter.ExactOutputSingleParams memory params = IV3SwapRouter.ExactOutputSingleParams({\\n            tokenIn: WETH,\\n            tokenOut: LOOKS,\\n            fee: POOL_FEE,\\n            recipient: address(this),\\n            amountOut: costToHealInLOOKS,\\n            amountInMaximum: msg.value,\\n            sqrtPriceLimitX96: 0\\n        });\\n\\n        uint256 amountIn = SWAP_ROUTER.exactOutputSingle{value: msg.value}(params);\\n\\n        IERC20(LOOKS).approve(address(TRANSFER_MANAGER), costToHealInLOOKS);\\n\\n        INFILTRATION.heal(agentIds);\\n\\n        if (msg.value > amountIn) {\\n            SWAP_ROUTER.refundETH();\\n            unchecked {\\n                _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, msg.value - amountIn, gasleft());\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the cost to heal the specified agents in ETH\\n     * @dev The cost doubles for each time the agent is healed.\\n     * @param agentIds The agent IDs to heal.\\n     * @return costToHealInETH The cost to heal the specified agents.\\n     */\\n    function costToHeal(uint256[] calldata agentIds) external returns (uint256 costToHealInETH) {\\n        uint256 costToHealInLOOKS = INFILTRATION.costToHeal(agentIds);\\n\\n        IQuoterV2.QuoteExactOutputSingleParams memory params = IQuoterV2.QuoteExactOutputSingleParams({\\n            tokenIn: WETH,\\n            tokenOut: LOOKS,\\n            amount: costToHealInLOOKS,\\n            fee: POOL_FEE,\\n            sqrtPriceLimitX96: uint160(0)\\n        });\\n\\n        (costToHealInETH, , , ) = QUOTER.quoteExactOutputSingle(params);\\n    }\\n\\n    /**\\n     * @notice This function is used to receive ETH from the swap router.\\n     */\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IWETH} from \\\"../interfaces/generic/IWETH.sol\\\";\\n\\n/**\\n * @title LowLevelWETH\\n * @notice This contract contains a function to transfer ETH with an option to wrap to WETH.\\n *         If the ETH transfer fails within a gas limit, the amount in ETH is wrapped to WETH and then transferred.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelWETH {\\n    /**\\n     * @notice It transfers ETH to a recipient with a specified gas limit.\\n     *         If the original transfers fails, it wraps to WETH and transfers the WETH to recipient.\\n     * @param _WETH WETH address\\n     * @param _to Recipient address\\n     * @param _amount Amount to transfer\\n     * @param _gasLimit Gas limit to perform the ETH transfer\\n     */\\n    function _transferETHAndWrapIfFailWithGasLimit(\\n        address _WETH,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _gasLimit\\n    ) internal {\\n        bool status;\\n\\n        assembly {\\n            status := call(_gasLimit, _to, _amount, 0, 0, 0, 0)\\n        }\\n\\n        if (!status) {\\n            IWETH(_WETH).deposit{value: _amount}();\\n            IWETH(_WETH).transfer(_to, _amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n// Enums\\nimport {TokenType} from \\\"../enums/TokenType.sol\\\";\\n\\n/**\\n * @title ITransferManager\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface ITransferManager {\\n    /**\\n     * @notice This struct is only used for transferBatchItemsAcrossCollections.\\n     * @param tokenAddress Token address\\n     * @param tokenType 0 for ERC721, 1 for ERC1155\\n     * @param itemIds Array of item ids to transfer\\n     * @param amounts Array of amounts to transfer\\n     */\\n    struct BatchTransferItem {\\n        address tokenAddress;\\n        TokenType tokenType;\\n        uint256[] itemIds;\\n        uint256[] amounts;\\n    }\\n\\n    /**\\n     * @notice It is emitted if operators' approvals to transfer NFTs are granted by a user.\\n     * @param user Address of the user\\n     * @param operators Array of operator addresses\\n     */\\n    event ApprovalsGranted(address user, address[] operators);\\n\\n    /**\\n     * @notice It is emitted if operators' approvals to transfer NFTs are revoked by a user.\\n     * @param user Address of the user\\n     * @param operators Array of operator addresses\\n     */\\n    event ApprovalsRemoved(address user, address[] operators);\\n\\n    /**\\n     * @notice It is emitted if a new operator is added to the global allowlist.\\n     * @param operator Operator address\\n     */\\n    event OperatorAllowed(address operator);\\n\\n    /**\\n     * @notice It is emitted if an operator is removed from the global allowlist.\\n     * @param operator Operator address\\n     */\\n    event OperatorRemoved(address operator);\\n\\n    /**\\n     * @notice It is returned if the operator to approve has already been approved by the user.\\n     */\\n    error OperatorAlreadyApprovedByUser();\\n\\n    /**\\n     * @notice It is returned if the operator to revoke has not been previously approved by the user.\\n     */\\n    error OperatorNotApprovedByUser();\\n\\n    /**\\n     * @notice It is returned if the transfer caller is already allowed by the owner.\\n     * @dev This error can only be returned for owner operations.\\n     */\\n    error OperatorAlreadyAllowed();\\n\\n    /**\\n     * @notice It is returned if the operator to approve is not in the global allowlist defined by the owner.\\n     * @dev This error can be returned if the user tries to grant approval to an operator address not in the\\n     *      allowlist or if the owner tries to remove the operator from the global allowlist.\\n     */\\n    error OperatorNotAllowed();\\n\\n    /**\\n     * @notice It is returned if the transfer caller is invalid.\\n     *         For a transfer called to be valid, the operator must be in the global allowlist and\\n     *         approved by the 'from' user.\\n     */\\n    error TransferCallerInvalid();\\n\\n    /**\\n     * @notice This function transfers ERC20 tokens.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param amount amount\\n     */\\n    function transferERC20(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers a single item for a single ERC721 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemId Item ID\\n     */\\n    function transferItemERC721(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 itemId\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers items for a single ERC721 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     */\\n    function transferItemsERC721(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256[] calldata itemIds,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers a single item for a single ERC1155 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemId Item ID\\n     * @param amount Amount\\n     */\\n    function transferItemERC1155(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 itemId,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers items for a single ERC1155 collection.\\n     * @param tokenAddress Token address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     * @dev It does not allow batch transferring if from = msg.sender since native function should be used.\\n     */\\n    function transferItemsERC1155(\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256[] calldata itemIds,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    /**\\n     * @notice This function transfers items across an array of tokens that can be ERC20, ERC721 and ERC1155.\\n     * @param items Array of BatchTransferItem\\n     * @param from Sender address\\n     * @param to Recipient address\\n     */\\n    function transferBatchItemsAcrossCollections(\\n        BatchTransferItem[] calldata items,\\n        address from,\\n        address to\\n    ) external;\\n\\n    /**\\n     * @notice This function allows a user to grant approvals for an array of operators.\\n     *         Users cannot grant approvals if the operator is not allowed by this contract's owner.\\n     * @param operators Array of operator addresses\\n     * @dev Each operator address must be globally allowed to be approved.\\n     */\\n    function grantApprovals(address[] calldata operators) external;\\n\\n    /**\\n     * @notice This function allows a user to revoke existing approvals for an array of operators.\\n     * @param operators Array of operator addresses\\n     * @dev Each operator address must be approved at the user level to be revoked.\\n     */\\n    function revokeApprovals(address[] calldata operators) external;\\n\\n    /**\\n     * @notice This function allows an operator to be added for the shared transfer system.\\n     *         Once the operator is allowed, users can grant NFT approvals to this operator.\\n     * @param operator Operator address to allow\\n     * @dev Only callable by owner.\\n     */\\n    function allowOperator(address operator) external;\\n\\n    /**\\n     * @notice This function allows the user to remove an operator for the shared transfer system.\\n     * @param operator Operator address to remove\\n     * @dev Only callable by owner.\\n     */\\n    function removeOperator(address operator) external;\\n\\n    /**\\n     * @notice This returns whether the user has approved the operator address.\\n     * The first address is the user and the second address is the operator.\\n     */\\n    function hasUserApprovedOperator(address user, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInfiltration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IInfiltration {\\n    /**\\n     * @notice Agent statuses.\\n     *         1. Active: The agent is active.\\n     *         2. Wounded: The agent is wounded. The agent can be healed for a number of blocks.\\n     *         3. Healing: The agent is healing. The outcome of the healing is not yet known.\\n     *         4. Escaped: The agent escaped from the game and took some rewards with him.\\n     *         5. Dead: The agent is dead. It can be due to the agent being wounded for too long or a failed healing.\\n     */\\n    enum AgentStatus {\\n        Active,\\n        Wounded,\\n        Healing,\\n        Escaped,\\n        Dead\\n    }\\n\\n    /**\\n     * @notice Heal outcomes. The agent can either be healed or killed.\\n     */\\n    enum HealOutcome {\\n        Healed,\\n        Killed\\n    }\\n\\n    /**\\n     * @notice Randomness request statuses.\\n     */\\n    enum RandomnessRequestStatus {\\n        None,\\n        Requested,\\n        Fulfilled\\n    }\\n\\n    /**\\n     * @notice An agent.\\n     * @dev The storage layout of an agent is as follows:\\n     * |---------------------------------------------------------------------------------------------------|\\n     * | empty (176 bits) | healCount (16 bits) | woundedAt (40 bits) | status (8 bits) | agentId (16 bits)|\\n     * |---------------------------------------------------------------------------------------------------|\\n     * @param agentId The ID of the agent.\\n     * @param status The status of the agent.\\n     * @param woundedAt The round number when the agent was wounded.\\n     * @param healCount The number of times the agent has been successfully healed.\\n     */\\n    struct Agent {\\n        uint16 agentId;\\n        AgentStatus status;\\n        uint40 woundedAt;\\n        uint16 healCount;\\n    }\\n\\n    /**\\n     * @notice The constructor calldata.\\n     * @param owner The owner of the contract.\\n     * @param name The name of the collection.\\n     * @param symbol The symbol of the collection.\\n     * @param price The mint price.\\n     * @param maxSupply The maximum supply of the collection.\\n     * @param maxMintPerAddress The maximum number of agents that can be minted per address.\\n     * @param blocksPerRound The number of blocks per round.\\n     * @param agentsToWoundPerRoundInBasisPoints The number of agents to wound per round in basis points.\\n     * @param roundsToBeWoundedBeforeDead The number of rounds for an agent to be wounded before getting killed.\\n     * @param looks The LOOKS token address.\\n     * @param vrfCoordinator The VRF coordinator address.\\n     * @param keyHash The VRF key hash.\\n     * @param subscriptionId The VRF subscription ID.\\n     * @param transferManager The transfer manager address.\\n     * @param healBaseCost The base cost to heal an agent.\\n     * @param protocolFeeRecipient The protocol fee recipient.\\n     * @param protocolFeeBp The protocol fee basis points.\\n     * @param weth The WETH address.\\n     * @param baseURI The base URI of the collection.\\n     */\\n    struct ConstructorCalldata {\\n        address owner;\\n        string name;\\n        string symbol;\\n        uint256 price;\\n        uint256 maxSupply;\\n        uint256 maxMintPerAddress;\\n        uint256 blocksPerRound;\\n        uint256 agentsToWoundPerRoundInBasisPoints;\\n        uint256 roundsToBeWoundedBeforeDead;\\n        address looks;\\n        address vrfCoordinator;\\n        bytes32 keyHash;\\n        uint64 subscriptionId;\\n        address transferManager;\\n        uint256 healBaseCost;\\n        address protocolFeeRecipient;\\n        uint16 protocolFeeBp;\\n        address weth;\\n        string baseURI;\\n    }\\n\\n    /**\\n     * @notice Game info.\\n     * @dev The storage layout of game info is as follows:\\n     * |-------------------------------------------------------------------------------------------------------------------------------|\\n     * | empty (56 bits) | randomnessLastRequestedAt (40 bits) | currentRoundBlockNumber (40 bits) | currentRoundId (40 bits)          |\\n     * | escapedAgents (16 bits) | deadAgents (16 bits) | healingAgents (16 bits) | woundedAgents (16 bits) | activeAgents (16 bits)   |\\n     * |-------------------------------------------------------------------------------------------------------------------------------|\\n     * | prizePool (256 bits)                                                                                                          |\\n     * |-------------------------------------------------------------------------------------------------------------------------------|\\n     * | secondaryPrizePool (256 bits)                                                                                                 |\\n     * |-------------------------------------------------------------------------------------------------------------------------------|\\n     * | secondaryLooksPrizePool (256 bits)                                                                                            |\\n     * |-------------------------------------------------------------------------------------------------------------------------------|\\n     * @param activeAgents The number of active agents.\\n     * @param woundedAgents The number of wounded agents.\\n     * @param healingAgents The number of healing agents.\\n     * @param deadAgents The number of dead agents.\\n     * @param escapedAgents The number of escaped agents.\\n     * @param currentRoundId The current round ID.\\n     * @param currentRoundBlockNumber The current round block number.\\n     * @param randomnessLastRequestedAt The timestamp when the randomness was last requested.\\n     * @param prizePool The ETH prize pool for the final winner.\\n     * @param secondaryPrizePool The secondary ETH prize pool for the top X winners.\\n     * @param secondaryLooksPrizePool The secondary LOOKS prize pool for the top X winners.\\n     */\\n    struct GameInfo {\\n        uint16 activeAgents;\\n        uint16 woundedAgents;\\n        uint16 healingAgents;\\n        uint16 deadAgents;\\n        uint16 escapedAgents;\\n        uint40 currentRoundId;\\n        uint40 currentRoundBlockNumber;\\n        uint40 randomnessLastRequestedAt;\\n        uint256 prizePool;\\n        uint256 secondaryPrizePool;\\n        uint256 secondaryLooksPrizePool;\\n    }\\n\\n    /**\\n     * @notice A Chainlink randomness request.\\n     * @param status The status of the randomness request.\\n     * @param roundId The round ID when the randomness request occurred.\\n     * @param randomWord The returned random word.\\n     */\\n    struct RandomnessRequest {\\n        RandomnessRequestStatus status;\\n        uint40 roundId;\\n        uint256 randomWord;\\n    }\\n\\n    /**\\n     * @notice A heal result that is used to emit events.\\n     * @param agentId The agent ID.\\n     * @param outcome The outcome of the healing.\\n     */\\n    struct HealResult {\\n        uint256 agentId;\\n        HealOutcome outcome;\\n    }\\n\\n    event EmergencyWithdrawal(uint256 ethAmount, uint256 looksAmount);\\n    event MintPeriodUpdated(uint256 mintStart, uint256 mintEnd);\\n    event HealRequestSubmitted(uint256 roundId, uint256[] agentIds, uint256[] costs);\\n    event HealRequestFulfilled(uint256 roundId, HealResult[] healResults);\\n    event RandomnessRequested(uint256 roundId, uint256 requestId);\\n    event RandomnessFulfilled(uint256 roundId, uint256 requestId);\\n    event InvalidRandomnessFulfillment(uint256 requestId, uint256 randomnessRequestRoundId, uint256 currentRoundId);\\n    event RoundStarted(uint256 roundId);\\n    event Escaped(uint256 roundId, uint256[] agentIds, uint256[] rewards);\\n    event PrizeClaimed(uint256 agentId, address currency, uint256 amount);\\n    event Wounded(uint256 roundId, uint256[] agentIds);\\n    event Killed(uint256 roundId, uint256[] agentIds);\\n    event Won(uint256 roundId, uint256 agentId);\\n\\n    error ExceededTotalSupply();\\n    error FrontrunLockIsOn();\\n    error GameAlreadyBegun();\\n    error GameNotYetBegun();\\n    error GameIsStillRunning();\\n    error GameOver();\\n    error HealingDisabled();\\n    error InexactNativeTokensSupplied();\\n    error InvalidAgentStatus(uint256 agentId, AgentStatus expectedStatus);\\n    error InvalidHealingRoundsDelay();\\n    error InvalidMaxSupply();\\n    error InvalidMintPeriod();\\n    error InvalidPlacement();\\n    error MaximumHealingRequestPerRoundExceeded();\\n    error MintAlreadyStarted();\\n    error MintCanOnlyBeExtended();\\n    error MintStartIsInThePast();\\n    error NoAgentsLeft();\\n    error NoAgentsProvided();\\n    error NotEnoughMinted();\\n    error NothingToClaim();\\n    error NotInMintPeriod();\\n    error NotAgentOwner();\\n    error Immutable();\\n    error RandomnessRequestAlreadyExists();\\n    error InvalidRandomnessRequestId();\\n    error RoundsToBeWoundedBeforeDeadTooLow();\\n    error StillMinting();\\n    error TooEarlyToStartNewRound();\\n    error TooEarlyToRetryRandomnessRequest();\\n    error TooManyMinted();\\n    error WoundedAgentIdsPerRoundExceeded();\\n\\n    /**\\n     * @notice Sets the mint period.\\n     * @dev If _mintStart is 0, the function call is just a mint end extension.\\n     * @param _mintStart The starting timestamp of the mint period.\\n     * @param _mintEnd The ending timestamp of the mint period.\\n     */\\n    function setMintPeriod(uint40 _mintStart, uint40 _mintEnd) external;\\n\\n    /**\\n     * @notice Mints a number of agents.\\n     * @param to The recipient\\n     * @param quantity The number of agents to mint.\\n     */\\n    function premint(address to, uint256 quantity) external payable;\\n\\n    /**\\n     * @notice Mints a number of agents.\\n     * @param quantity The number of agents to mint.\\n     */\\n    function mint(uint256 quantity) external payable;\\n\\n    /**\\n     * @notice This function is here in case the game's invariant condition does not hold or the game is stuck.\\n     *         Only callable by the contract owner.\\n     */\\n    function emergencyWithdraw() external;\\n\\n    /**\\n     * @notice Starts the game.\\n     * @dev Starting the game sets the current round ID to 1.\\n     */\\n    function startGame() external;\\n\\n    /**\\n     * @notice Starts a new round.\\n     */\\n    function startNewRound() external;\\n\\n    /**\\n     * @notice Close a round after randomness is fullfilled by Chainlink.\\n     * @param requestId The Chainlink request ID.\\n     */\\n    function closeRound(uint256 requestId) external;\\n\\n    /**\\n     * @notice Claims the grand prize. Only callable by the winner.\\n     */\\n    function claimGrandPrize() external;\\n\\n    /**\\n     * @notice Claims the secondary prizes. Only callable by top 50 agents.\\n     * @param agentId The agent ID.\\n     */\\n    function claimSecondaryPrizes(uint256 agentId) external;\\n\\n    /**\\n     * @notice Escape from the game and take some rewards. 80% of the prize pool is distributed to\\n     *         the escaped agents and the rest to the secondary prize pool.\\n     * @param agentIds The agent IDs to escape.\\n     */\\n    function escape(uint256[] calldata agentIds) external;\\n\\n    /**\\n     * @notice Submits a heal request for the specified agent IDs.\\n     * @param agentIds The agent IDs to heal.\\n     */\\n    function heal(uint256[] calldata agentIds) external;\\n\\n    /**\\n     * @notice Get the agent at the specified index.\\n     * @return agent The agent at the specified index.\\n     */\\n    function getAgent(uint256 index) external view returns (Agent memory agent);\\n\\n    /**\\n     * @notice Returns the cost to heal the specified agents\\n     * @dev The cost doubles for each time the agent is healed.\\n     * @param agentIds The agent IDs to heal.\\n     * @return cost The cost to heal the specified agents.\\n     */\\n    function costToHeal(uint256[] calldata agentIds) external view returns (uint256 cost);\\n\\n    /**\\n     * @notice Returns the reward for escaping the game.\\n     * @param agentIds The agent IDs to escape.\\n     * @return reward The reward for escaping the game.\\n     */\\n    function escapeReward(uint256[] calldata agentIds) external view returns (uint256 reward);\\n\\n    /**\\n     * @notice Returns the total number of agents alive.\\n     */\\n    function agentsAlive() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the index of a specific agent ID inside the agents mapping.\\n     * @param agentId The agent ID.\\n     * @return index The index of the agent ID.\\n     */\\n    function agentIndex(uint256 agentId) external view returns (uint256 index);\\n\\n    /**\\n     * @notice Returns a specific round's information.\\n     * @param roundId The round ID.\\n     * @return woundedAgentIds The agent IDs of the wounded agents in the specified round.\\n     * @return healingAgentIds The agent IDs of the healing agents in the specified round.\\n     */\\n    function getRoundInfo(\\n        uint256 roundId\\n    ) external view returns (uint256[] memory woundedAgentIds, uint256[] memory healingAgentIds);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IV3SwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface IV3SwapRouter {\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// that may remain in the router after the swap.\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\\n    /// that use ether for the input amount\\n    function refundETH() external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQuoterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n/// @title QuoterV2 Interface\\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.\\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\\ninterface IQuoterV2 {\\n    struct QuoteExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amount;\\n        uint24 fee;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n    /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\\n    /// tokenIn The token being swapped in\\n    /// tokenOut The token being swapped out\\n    /// fee The fee of the token pool to consider for the pair\\n    /// amountOut The desired output amount\\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\\n    /// @return gasEstimate The estimate of the gas that the swap consumes\\n    function quoteExactOutputSingle(\\n        QuoteExactOutputSingleParams memory params\\n    )\\n        external\\n        returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate);\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-transfer-manager/contracts/enums/TokenType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nenum TokenType {\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@chainlink/=node_modules/@chainlink/\",\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"@looksrare/=node_modules/@looksrare/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc721a/=node_modules/erc721a/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 888888\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transferManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_infiltration\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapQuoter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_looks\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"INFILTRATION\",\"outputs\":[{\"internalType\":\"contract IInfiltration\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOOKS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUOTER\",\"outputs\":[{\"internalType\":\"contract IQuoterV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_ROUTER\",\"outputs\":[{\"internalType\":\"contract IV3SwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_MANAGER\",\"outputs\":[{\"internalType\":\"contract ITransferManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"agentIds\",\"type\":\"uint256[]\"}],\"name\":\"costToHeal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"costToHealInETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"agentIds\",\"type\":\"uint256[]\"}],\"name\":\"heal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InfiltrationPeriphery", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "888888", "ConstructorArguments": "00000000000000000000000000000000000ea4af05656c17b90f4d64add29e1d00000000000000000000000000000000005316fe469550d85f2e5ae85b7db71900000000000000000000000068b3465833fb72a70ecdf485e0e4c7bd8665fc4500000000000000000000000061ffe014ba17989e743c5f6cb21bf9697530b21e000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000f4d2888d29d722226fafa5d9b24f9164c092421e", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}