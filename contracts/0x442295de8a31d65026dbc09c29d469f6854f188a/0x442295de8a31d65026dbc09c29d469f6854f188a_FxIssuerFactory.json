{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/factories/FxIssuerFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport {LibClone} from \\\"solady/src/utils/LibClone.sol\\\";\\nimport {Ownable} from \\\"solady/src/auth/Ownable.sol\\\";\\nimport {Pausable} from \\\"openzeppelin-contracts/contracts/security/Pausable.sol\\\";\\n\\nimport {IAccessControl} from \\\"openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IFxGenArt721, InitInfo, MetadataInfo, MintInfo, ProjectInfo} from \\\"src/interfaces/IFxGenArt721.sol\\\";\\nimport {IFxIssuerFactory} from \\\"src/interfaces/IFxIssuerFactory.sol\\\";\\nimport {IFxTicketFactory} from \\\"src/interfaces/IFxTicketFactory.sol\\\";\\n\\n/**\\n * @title FxIssuerFactory\\n * @author fx(hash)\\n * @dev See the documentation in {IFxIssuerFactory}\\n */\\ncontract FxIssuerFactory is IFxIssuerFactory, Ownable, Pausable {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    STORAGE\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    address public immutable roleRegistry;\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    address public implementation;\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    uint96 public projectId;\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    mapping(address => uint256) public nonces;\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    mapping(uint96 => address) public projects;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Initializes factory owner, FxRoleRegistry and FxGenArt721 implementation\\n     */\\n    constructor(address _admin, address _roleRegistry, address _implementation) {\\n        _pause();\\n        roleRegistry = _roleRegistry;\\n        _initializeOwner(_admin);\\n        _setImplementation(_implementation);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                EXTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    function createProjectWithTicket(\\n        bytes calldata _projectCreationInfo,\\n        bytes calldata _ticketCreationInfo,\\n        address _ticketFactory\\n    ) external whenNotPaused returns (address genArtToken, address mintTicket) {\\n        genArtToken = createProject(_projectCreationInfo);\\n        mintTicket = IFxTicketFactory(_ticketFactory).createTicket(_ticketCreationInfo);\\n    }\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    function setImplementation(address _implementation) external onlyOwner {\\n        _setImplementation(_implementation);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                PUBLIC FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    function createProject(bytes memory _creationInfo) public returns (address genArt721) {\\n        (\\n            address _owner,\\n            InitInfo memory _initInfo,\\n            ProjectInfo memory _projectInfo,\\n            MetadataInfo memory _metadataInfo,\\n            MintInfo[] memory _mintInfo,\\n            address[] memory _royaltyReceivers,\\n            uint32[] memory _allocations,\\n            uint96 _basisPoints\\n        ) = abi.decode(\\n                _creationInfo,\\n                (address, InitInfo, ProjectInfo, MetadataInfo, MintInfo[], address[], uint32[], uint96)\\n            );\\n\\n        genArt721 = createProjectWithParams(\\n            _owner,\\n            _initInfo,\\n            _projectInfo,\\n            _metadataInfo,\\n            _mintInfo,\\n            _royaltyReceivers,\\n            _allocations,\\n            _basisPoints\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    function createProjectWithParams(\\n        address _owner,\\n        InitInfo memory _initInfo,\\n        ProjectInfo memory _projectInfo,\\n        MetadataInfo memory _metadataInfo,\\n        MintInfo[] memory _mintInfo,\\n        address[] memory _royaltyReceivers,\\n        uint32[] memory _allocations,\\n        uint96 _basisPoints\\n    ) public whenNotPaused returns (address genArtToken) {\\n        if (_owner == address(0)) revert InvalidOwner();\\n\\n        bytes32 salt = keccak256(abi.encode(msg.sender, nonces[msg.sender]));\\n        genArtToken = LibClone.cloneDeterministic(implementation, salt);\\n        nonces[msg.sender]++;\\n        projects[++projectId] = genArtToken;\\n\\n        emit ProjectCreated(projectId, genArtToken, _owner);\\n\\n        IFxGenArt721(genArtToken).initialize(\\n            _owner,\\n            _initInfo,\\n            _projectInfo,\\n            _metadataInfo,\\n            _mintInfo,\\n            _royaltyReceivers,\\n            _allocations,\\n            _basisPoints\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                VIEW FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @inheritdoc IFxIssuerFactory\\n     */\\n    function getTokenAddress(address _sender) external view returns (address) {\\n        bytes32 salt = keccak256(abi.encode(_sender, nonces[_sender]));\\n        return LibClone.predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Sets the FxGenArt721 implementation contract\\n     */\\n    function _setImplementation(address _implementation) internal {\\n        implementation = _implementation;\\n        emit ImplementationUpdated(msg.sender, _implementation);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibClone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Minimal proxy library.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\\n/// @author Minimal proxy by 0age (https://github.com/0age)\\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\n///\\n/// @dev Minimal proxy:\\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\\n///\\n/// @dev Minimal proxy (PUSH0 variant):\\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \\\"_PUSH0\\\" as\\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\\n/// Please use with caution.\\n///\\n/// @dev Clones with immutable args (CWIA):\\n/// The implementation of CWIA here implements a `receive()` method that emits the\\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\\n/// composability. The minimal proxy implementation does not offer this feature.\\nlibrary LibClone {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Unable to deploy the clone.\\n    error DeploymentFailed();\\n\\n    /// @dev The salt must start with either the zero address or the caller.\\n    error SaltDoesNotStartWithCaller();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  MINIMAL PROXY OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (44 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | 0                      |                       |\\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create(0, 0x0c, 0x35)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    function cloneDeterministic(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create2(0, 0x0c, 0x35, salt)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            hash := keccak256(0x0c, 0x35)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        bytes32 hash = initCodeHash(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    function clone_PUSH0(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 5f         | PUSH0             | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (45 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5f      | PUSH0          | 0                      |                       |\\n             * 5f      | PUSH0          | 0 0                    |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create(0, 0x0e, 0x36)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x24, 0)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create2(0, 0x0e, 0x36, salt)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x24, 0)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            hash := keccak256(0x0e, 0x36)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x24, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    function predictDeterministicAddress_PUSH0(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash_PUSH0(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a minimal proxy with `implementation`,\\n    /// using immutable arguments encoded in `data`.\\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n            // The `creationSize` is `extraLength + 108`\\n            // The `runSize` is `creationSize - 10`.\\n\\n            /**\\n             * ---------------------------------------------------------------------------------------------------+\\n             * CREATION (10 bytes)                                                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\\n             * 81         | DUP2              | r 0 r     |                                                       |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * RUNTIME (98 bytes + extraLength)                                                                   |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\\n             * ---------------------------------------------------------------------------------------------------|\\n             *                                                                                                    |\\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\\n             * 57       | JUMPI          |                          |                                             |\\n             * 34       | CALLVALUE      | cv                       |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\\n             * 5b       | JUMPDEST       |                          |                                             |\\n             *                                                                                                    |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\\n             * ---------------------------------------------------------------------------------------------------+\\n             */\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Create the instance.\\n            instance := create(0, sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`,\\n    /// using immutable arguments encoded in `data`, with `salt`.\\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Create the instance.\\n            instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)\\n\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Compute and store the bytecode hash.\\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of\\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash(implementation, data);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      OTHER OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the address when a contract with initialization code hash,\\n    /// `hash`, is deployed with `salt`, by `deployer`.\\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x35, 0)\\n        }\\n    }\\n\\n    /// @dev Reverts if `salt` does not start with either the zero address or the caller.\\n    function checkStartsWithCaller(bytes32 salt) internal view {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the salt does not start with the zero address or the caller.\\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\\n                // Store the function selector of `SaltDoesNotStartWithCaller()`.\\n                mstore(0x00, 0x2f634836)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFxGenArt721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport {GenArtInfo, InitInfo, IssuerInfo, MetadataInfo, MintInfo, ProjectInfo, ReserveInfo} from \\\"src/lib/Structs.sol\\\";\\nimport {ISeedConsumer} from \\\"src/interfaces/ISeedConsumer.sol\\\";\\nimport {IToken} from \\\"src/interfaces/IToken.sol\\\";\\n\\n/**\\n * @title IFxGenArt721\\n * @author fx(hash)\\n * @notice ERC-721 token for generative art projects created on fxhash\\n */\\ninterface IFxGenArt721 is ISeedConsumer, IToken {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Event emitted when the base URI is updated\\n     * @param _uri Decoded content identifier of metadata pointer\\n     */\\n    event BaseURIUpdated(bytes _uri);\\n\\n    /**\\n     * @notice Event emitted when public burn is enabled or disabled\\n     * @param _flag Status of burn\\n     */\\n    event BurnEnabled(bool indexed _flag);\\n\\n    /**\\n     * @notice Event emitted when public mint is enabled or disabled\\n     * @param _flag Status of mint\\n     */\\n    event MintEnabled(bool indexed _flag);\\n\\n    /**\\n     * @notice Event emitted when project is deleted only once supply is set to zero\\n     */\\n    event ProjectDeleted();\\n\\n    /**\\n     * @notice Event emitted when new project is initialized\\n     * @param _primaryReceiver Address of splitter contract receiving primary sales\\n     * @param _projectInfo Project information\\n     * @param _metadataInfo Metadata information of token\\n     * @param _mintInfo Array of authorized minter contracts and their reserves\\n     */\\n    event ProjectInitialized(\\n        address indexed _primaryReceiver,\\n        ProjectInfo _projectInfo,\\n        MetadataInfo _metadataInfo,\\n        MintInfo[] _mintInfo\\n    );\\n\\n    /**\\n     * @notice Event emitted when the primary receiver address is updated\\n     * @param _receiver The split address receiving funds on behalf of the users\\n     * @param _receivers Array of addresses receiving a portion of the funds in a split\\n     * @param _allocations Array of allocation shares for the split\\n     */\\n    event PrimaryReceiverUpdated(address indexed _receiver, address[] _receivers, uint32[] _allocations);\\n\\n    /**\\n     * @notice Event emitted when project tags are set\\n     * @param _tagIds Array of tag IDs describing the project\\n     */\\n    event ProjectTags(uint256[] indexed _tagIds);\\n\\n    /**\\n     * @notice Event emitted when Randomizer contract is updated\\n     * @param _randomizer Address of new Randomizer contract\\n     */\\n    event RandomizerUpdated(address indexed _randomizer);\\n\\n    /**\\n     * @notice Event emitted when Renderer contract is updated\\n     * @param _renderer Address of new Renderer contract\\n     */\\n    event RendererUpdated(address indexed _renderer);\\n\\n    /**\\n     * @notice Event emitted when onchain data of project is updated\\n     * @param _pointer SSTORE2 pointer to the onchain data\\n     */\\n    event OnchainPointerUpdated(address _pointer);\\n\\n    /**\\n     * @notice Event emitted when maximum supply is reduced\\n     * @param _prevSupply Amount of previous supply\\n     * @param _newSupply Amount of new supply\\n     */\\n    event SupplyReduced(uint120 indexed _prevSupply, uint120 indexed _newSupply);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Error thrown when total minter allocation exceeds maximum supply\\n     */\\n    error AllocationExceeded();\\n\\n    /**\\n     *  @notice Error thrown when burning is inactive\\n     */\\n    error BurnInactive();\\n\\n    /**\\n     * @notice Error thrown when the fee receiver address is not included in the receiver allocations\\n     */\\n    error FeeReceiverMissing();\\n\\n    /**\\n     * @notice Error thrown when remaining supply is zero\\n     */\\n    error InsufficientSupply();\\n\\n    /**\\n     * @notice Error thrown when max supply amount is invalid\\n     */\\n    error InvalidAmount();\\n\\n    /**\\n     * @notice Error thrown when input size does not match actual byte size of params data\\n     */\\n    error InvalidInputSize();\\n\\n    /**\\n     * @notice Error thrown when reserve start time is invalid\\n     */\\n    error InvalidStartTime();\\n\\n    /**\\n     * @notice Error thrown when reserve end time is invalid\\n     */\\n    error InvalidEndTime();\\n\\n    /**\\n     * @notice Error thrown when the configured fee receiver is not valid\\n     */\\n    error InvalidFeeReceiver();\\n\\n    /**\\n     * @notice Error thrown when minting is active\\n     */\\n    error MintActive();\\n\\n    /**\\n     *  @notice Error thrown when minting is inactive\\n     */\\n    error MintInactive();\\n\\n    /**\\n     * @notice Error thrown when caller is not authorized to execute transaction\\n     */\\n    error NotAuthorized();\\n\\n    /**\\n     * @notice Error thrown when signer is not the owner\\n     */\\n    error NotOwner();\\n\\n    /**\\n     * @notice Error thrown when supply is remaining\\n     */\\n    error SupplyRemaining();\\n\\n    /**\\n     * @notice Error thrown when caller does not have the specified role\\n     */\\n    error UnauthorizedAccount();\\n\\n    /**\\n     * @notice Error thrown when caller does not have minter role\\n     */\\n    error UnauthorizedMinter();\\n\\n    /**\\n     * @notice Error thrown when minter is not registered on token contract\\n     */\\n    error UnregisteredMinter();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /*\\n     * @notice Returns the list of minter contracts currently active on the token\\n     */\\n    function activeMinters() external view returns (address[] memory);\\n\\n    /**\\n     * @notice Burns token ID from the circulating supply\\n     * @param _tokenId ID of the token\\n     */\\n    function burn(uint256 _tokenId) external;\\n\\n    /**\\n     * @notice Returns address of the FxContractRegistry contract\\n     */\\n    function contractRegistry() external view returns (address);\\n\\n    /**\\n     * @notice Returns contract-level metadata for storefront marketplaces\\n     */\\n    function contractURI() external view returns (string memory);\\n\\n    /**\\n     * @inheritdoc ISeedConsumer\\n     */\\n    function fulfillSeedRequest(uint256 _tokenId, bytes32 _seed) external;\\n\\n    /**\\n     * @notice Mapping of token ID to GenArtInfo struct (minter, seed, fxParams)\\n     */\\n    function genArtInfo(uint256 _tokenId) external view returns (address, bytes32, bytes memory);\\n\\n    /**\\n     * @notice Generates typed data hash for setting project metadata onchain\\n     * @param _data Bytes-encoded onchain data\\n     * @return Typed data hash\\n     */\\n    function generateOnchainPointerHash(bytes calldata _data) external view returns (bytes32);\\n\\n    /**\\n     * @notice Generates typed data hash for setting the primary receiver address\\n     * @param _renderer Address of the new renderer contract\\n     * @return Typed data hash\\n     */\\n    function generateRendererHash(address _renderer) external view returns (bytes32);\\n\\n    /**\\n     * @notice Initializes new generative art project\\n     * @param _owner Address of token proxy owner\\n     * @param _initInfo Initialization information set on project creation\\n     * @param _projectInfo Project information\\n     * @param _metadataInfo Metadata information\\n     * @param _mintInfo Array of authorized minter contracts and their reserves\\n     * @param _royaltyReceivers Array of addresses receiving royalties\\n     * @param _allocations Array of allocation amounts for calculating royalty shares\\n     * @param _basisPoints Total allocation scalar for calculating royalty shares\\n     */\\n    function initialize(\\n        address _owner,\\n        InitInfo calldata _initInfo,\\n        ProjectInfo calldata _projectInfo,\\n        MetadataInfo calldata _metadataInfo,\\n        MintInfo[] calldata _mintInfo,\\n        address[] calldata _royaltyReceivers,\\n        uint32[] calldata _allocations,\\n        uint96 _basisPoints\\n    ) external;\\n\\n    /**\\n     * @notice Gets the authorization status for the given minter contract\\n     * @param _minter Address of the minter contract\\n     * @return Authorization status\\n     */\\n    function isMinter(address _minter) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the issuer information of the project (primaryReceiver, ProjectInfo)\\n     */\\n    function issuerInfo() external view returns (address, ProjectInfo memory);\\n\\n    /**\\n     * @notice Returns the metadata information of the project (baseURI, onchainPointer)\\n     */\\n    function metadataInfo() external view returns (bytes memory, address);\\n\\n    /**\\n     * @inheritdoc IToken\\n     */\\n    function mint(address _to, uint256 _amount, uint256 _payment) external;\\n\\n    /**\\n     * @notice Mints single fxParams token\\n     * @dev Only callable by registered minter contracts\\n     * @param _to Address receiving minted token\\n     * @param _fxParams Random sequence of fixed-length bytes used as input\\n     */\\n    function mintParams(address _to, bytes calldata _fxParams) external;\\n\\n    /**\\n     * @notice Current nonce for admin signatures\\n     */\\n    function nonce() external returns (uint96);\\n\\n    /**\\n     * @notice Mints single token with randomly generated seed\\n     * @dev Only callable by contract owner\\n     * @param _to Address receiving token\\n     */\\n    function ownerMint(address _to) external;\\n\\n    /**\\n     * @notice Mints single fxParams token\\n     * @dev Only callable by contract owner\\n     * @param _to Address receiving minted token\\n     * @param _fxParams Random sequence of fixed-length bytes used as input\\n     */\\n    function ownerMintParams(address _to, bytes calldata _fxParams) external;\\n\\n    /**\\n     * @notice Pauses all function executions where modifier is applied\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @inheritdoc IToken\\n     */\\n    function primaryReceiver() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the randomizer contract\\n     */\\n    function randomizer() external view returns (address);\\n\\n    /**\\n     * @notice Reduces maximum supply of collection\\n     * @param _supply Maximum supply amount\\n     */\\n    function reduceSupply(uint120 _supply) external;\\n\\n    /**\\n     * @notice Registers minter contracts with resereve info\\n     * @param _mintInfo Mint information of token reserves\\n     */\\n    function registerMinters(MintInfo[] memory _mintInfo) external;\\n\\n    /**\\n     * @notice Returns the remaining supply of tokens left to mint\\n     */\\n    function remainingSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the address of the Renderer contract\\n     */\\n    function renderer() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the FxRoleRegistry contract\\n     */\\n    function roleRegistry() external view returns (address);\\n\\n    /**\\n     * @notice Sets the base royalties for all secondary token sales\\n     * @param _receivers Array of addresses receiving royalties\\n     * @param _allocations Array of allocations used to calculate royalty payments\\n     * @param _basisPoints basis points used to calculate royalty payments\\n     */\\n    function setBaseRoyalties(\\n        address[] calldata _receivers,\\n        uint32[] calldata _allocations,\\n        uint96 _basisPoints\\n    ) external;\\n\\n    /**\\n     * @notice Sets the new URI of the token metadata\\n     * @param _uri Decoded content identifier of metadata pointer\\n     */\\n    function setBaseURI(bytes calldata _uri) external;\\n\\n    /**\\n     * @notice Sets flag status of public burn to enabled or disabled\\n     * @param _flag Status of burn\\n     */\\n    function setBurnEnabled(bool _flag) external;\\n\\n    /**\\n     * @notice Sets flag status of public mint to enabled or disabled\\n     * @param _flag Status of mint\\n     */\\n    function setMintEnabled(bool _flag) external;\\n\\n    /**\\n     * @notice Sets the onchain pointer for reconstructing project metadata onchain\\n     * @param _onchainData Bytes-encoded metadata\\n     * @param _signature Signature of creator used to verify metadata update\\n     */\\n    function setOnchainPointer(bytes calldata _onchainData, bytes calldata _signature) external;\\n\\n    /**\\n     * @notice Sets the primary receiver address for primary sale proceeds\\n     * @param _receivers Array of addresses receiving shares from primary sales\\n     * @param _allocations Array of allocation amounts for calculating primary sales shares\\n     */\\n    function setPrimaryReceivers(address[] calldata _receivers, uint32[] calldata _allocations) external;\\n\\n    /**\\n     * @notice Sets the new randomizer contract\\n     * @param _randomizer Address of the randomizer contract\\n     */\\n    function setRandomizer(address _randomizer) external;\\n\\n    /**\\n     * @notice Sets the new renderer contract\\n     * @param _renderer Address of the renderer contract\\n     * @param _signature Signature of creator used to verify renderer update\\n     */\\n    function setRenderer(address _renderer, bytes calldata _signature) external;\\n\\n    /**\\n     * @notice Emits an event for setting tag descriptions for the project\\n     * @param _tagIds Array of tag IDs describing the project\\n     */\\n    function setTags(uint256[] calldata _tagIds) external;\\n\\n    /**\\n     * @notice Returns the current circulating supply of tokens\\n     */\\n    function totalSupply() external view returns (uint96);\\n\\n    /**\\n     * @notice Unpauses all function executions where modifier is applied\\n     */\\n    function unpause() external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFxIssuerFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport {InitInfo, MetadataInfo, MintInfo, ProjectInfo} from \\\"src/lib/Structs.sol\\\";\\n\\n/**\\n * @title IFxIssuerFactory\\n * @author fx(hash)\\n * @notice Factory for managing newly deployed FxGenArt721 tokens\\n */\\ninterface IFxIssuerFactory {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Event emitted when the FxGenArt721 implementation contract is updated\\n     * @param _owner Address of the factory owner\\n     * @param _implementation Address of the new FxGenArt721 implementation contract\\n     */\\n    event ImplementationUpdated(address indexed _owner, address indexed _implementation);\\n\\n    /**\\n     * @notice Event emitted when a new generative art project is created\\n     * @param _projectId ID of the project\\n     * @param _genArtToken Address of newly deployed FxGenArt721 token contract\\n     * @param _owner Address of project owner\\n     */\\n    event ProjectCreated(uint96 indexed _projectId, address indexed _genArtToken, address indexed _owner);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Error thrown when owner is zero address\\n     */\\n    error InvalidOwner();\\n\\n    /**\\n     * @notice Error thrown when primary receiver is zero address\\n     */\\n    error InvalidPrimaryReceiver();\\n\\n    /**\\n     * @notice Error thrown when caller is not authorized to execute transaction\\n     */\\n    error NotAuthorized();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Creates new generative art project\\n     * @param _owner Address of project owner\\n     * @param _initInfo Initialization information\\n     * @param _projectInfo Project information\\n     * @param _metadataInfo Metadata information\\n     * @param _mintInfo Array of authorized minter contracts and their reserves\\n     * @param _royaltyReceivers Array of addresses receiving royalties\\n     * @param _allocations Array of allocation amounts for calculating royalty shares\\n     * @param _basisPoints Total allocation scalar for calculating royalty shares\\n     * @return genArtToken Address of newly created FxGenArt721 proxy\\n     */\\n    function createProjectWithParams(\\n        address _owner,\\n        InitInfo memory _initInfo,\\n        ProjectInfo memory _projectInfo,\\n        MetadataInfo memory _metadataInfo,\\n        MintInfo[] memory _mintInfo,\\n        address[] memory _royaltyReceivers,\\n        uint32[] memory _allocations,\\n        uint96 _basisPoints\\n    ) external returns (address);\\n\\n    /**\\n     * @notice Creates new generative art project with single parameter\\n     * @param _creationInfo Bytes-encoded data for project creation\\n     * @return genArtToken Address of newly created FxGenArt721 proxy\\n     */\\n    function createProject(bytes memory _creationInfo) external returns (address);\\n\\n    /**\\n     * @notice Creates new generative art project with new mint ticket in single transaction\\n     * @param _projectCreationInfo Bytes-encoded data for project creation\\n     * @param _ticketCreationInfo Bytes-encoded data for ticket creation\\n     * @param _tickeFactory Address of FxTicketFactory contract\\n     * @return genArtToken Address of newly created FxGenArt721 proxy\\n     * @return mintTicket Address of newly created FxMintTicket721 proxy\\n     */\\n    function createProjectWithTicket(\\n        bytes calldata _projectCreationInfo,\\n        bytes calldata _ticketCreationInfo,\\n        address _tickeFactory\\n    ) external returns (address, address);\\n\\n    /**\\n     * @notice Calculates the CREATE2 address of a new FxGenArt721 proxy\\n     */\\n    function getTokenAddress(address _sender) external view returns (address);\\n\\n    /**\\n     * @notice Returns address of current FxGenArt721 implementation contract\\n     */\\n    function implementation() external view returns (address);\\n\\n    /**\\n     * @notice Mapping of deployer address to nonce value for precomputing token address\\n     */\\n    function nonces(address _deployer) external view returns (uint256);\\n\\n    /**\\n     * @notice Stops new FxGenArt721 tokens from being created\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @notice Returns counter of latest project ID\\n     */\\n    function projectId() external view returns (uint96);\\n\\n    /**\\n     * @notice Mapping of project ID to address of FxGenArt721 token contract\\n     */\\n    function projects(uint96) external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the FxRoleRegistry contract\\n     */\\n    function roleRegistry() external view returns (address);\\n\\n    /**\\n     * @notice Sets new FxGenArt721 implementation contract\\n     * @param _implementation Address of the implementation contract\\n     */\\n    function setImplementation(address _implementation) external;\\n\\n    /**\\n     * @notice Enables new FxGenArt721 tokens from being created\\n     */\\n    function unpause() external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFxTicketFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport {MintInfo} from \\\"src/lib/Structs.sol\\\";\\n\\n/**\\n * @title IFxTicketFactory\\n * @author fx(hash)\\n * @notice Factory for managing newly deployed FxMintTicket721 tokens\\n */\\ninterface IFxTicketFactory {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Event emitted when the minimum grace period is updated\\n     * @param _owner Address of the factory owner\\n     * @param _gracePeriod Time duration of the new grace period\\n     */\\n    event GracePeriodUpdated(address indexed _owner, uint48 indexed _gracePeriod);\\n\\n    /**\\n     * @notice Event emitted when the FxMintTicket721 implementation contract is updated\\n     * @param _owner Address of the factory owner\\n     * @param _implementation Address of the new FxMintTicket721 implementation contract\\n     */\\n    event ImplementationUpdated(address indexed _owner, address indexed _implementation);\\n\\n    /**\\n     * @notice Event emitted when new FxMintTicket721 is created\\n     * @param _ticketId ID of the ticket contract\\n     * @param _mintTicket Address of newly deployed FxMintTicket721 token contract\\n     * @param _owner Address of ticket owner\\n     */\\n    event TicketCreated(uint96 indexed _ticketId, address indexed _mintTicket, address indexed _owner);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  ERRORS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Error thrown when grace period is less than minimum requirement of one day\\n     */\\n    error InvalidGracePeriod();\\n\\n    /**\\n     * @notice Error thrown when owner is zero address\\n     */\\n    error InvalidOwner();\\n\\n    /**\\n     * @notice Error thrown when redeemer contract is zero address\\n     */\\n    error InvalidRedeemer();\\n\\n    /**\\n     * @notice Error thrown when renderer contract is zero address\\n     */\\n    error InvalidRenderer();\\n\\n    /**\\n     * @notice Error thrown when token contract is zero address\\n     */\\n    error InvalidToken();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Creates new mint ticket\\n     * @param _owner Address of project owner\\n     * @param _genArt721 Address of GenArt721 token contract\\n     * @param _redeemer Address of TicketRedeemer minter contract\\n     * @param _redeemer Address of renderer contract\\n     * @param _gracePeriod Duration of time before token enters harberger taxation\\n     * @param _mintInfo Array of authorized minter contracts and their reserves\\n     */\\n    function createTicket(\\n        address _owner,\\n        address _genArt721,\\n        address _redeemer,\\n        address _renderer,\\n        uint48 _gracePeriod,\\n        MintInfo[] memory _mintInfo\\n    ) external returns (address);\\n\\n    /**\\n     * @notice Creates new mint ticket for new generative art project in single transaction\\n     * @param _creationInfo Bytes-encoded data for ticket creation\\n     * @return mintTicket Address of newly created FxMintTicket721 proxy\\n     */\\n    function createTicket(bytes calldata _creationInfo) external returns (address);\\n\\n    /**\\n     * @notice Calculates the CREATE2 address of a new FxMintTicket721 proxy\\n     */\\n    function getTicketAddress(address _sender) external view returns (address);\\n\\n    /**\\n     * @notice Returns address of current FxMintTicket721 implementation contract\\n     */\\n    function implementation() external view returns (address);\\n\\n    /**\\n     * @notice Returns the minimum duration of time before a ticket enters harberger taxation\\n     */\\n    function minGracePeriod() external view returns (uint48);\\n\\n    /**\\n     * @notice Mapping of deployer address to nonce value for precomputing ticket address\\n     */\\n    function nonces(address _deployer) external view returns (uint256);\\n\\n    /**\\n     * @notice Sets the new minimum grace period\\n     * @param _gracePeriod Minimum time duration before a ticket enters harberger taxation\\n     */\\n    function setMinGracePeriod(uint48 _gracePeriod) external;\\n\\n    /**\\n     * @notice Sets new FxMintTicket721 implementation contract\\n     * @param _implementation Address of the implementation contract\\n     */\\n    function setImplementation(address _implementation) external;\\n\\n    /**\\n     * @notice Returns counter of latest token ID\\n     */\\n    function ticketId() external view returns (uint48);\\n\\n    /**\\n     * @notice Mapping of token ID to address of FxMintTicket721 token contract\\n     */\\n    function tickets(uint48 _ticketId) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                  STRUCTS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/**\\n * @notice Struct of dutch auction information\\n * - `refunded` Flag indicating if refunds are enabled\\n * - `stepLength` Duration (in seconds) of each auction step\\n * - `prices` Array of prices for each step of the auction\\n */\\nstruct AuctionInfo {\\n    bool refunded;\\n    uint248 stepLength;\\n    uint256[] prices;\\n}\\n\\n/**\\n * @notice Struct of system config information\\n * - `feeReceiver` Address receiving platform fees\\n * - `primaryFeeAllocation` Amount of basis points allocated to calculate platform fees on primary sale proceeds\\n * - `secondaryFeeAllocation` Amount of basis points allocated to calculate platform fees on royalty payments\\n * - `lockTime` Locked time duration added to mint start time for unverified creators\\n * - `referrerShare` Share amount distributed to accounts referring tokens\\n * - `defaultMetadataURI` Default base URI of token metadata\\n * - `externalURI` External URI for displaying tokens\\n */\\nstruct ConfigInfo {\\n    address feeReceiver;\\n    uint32 primaryFeeAllocation;\\n    uint32 secondaryFeeAllocation;\\n    uint32 lockTime;\\n    uint64 referrerShare;\\n    string defaultMetadataURI;\\n    string externalURI;\\n}\\n\\n/**\\n * @notice Struct of generative art information\\n * - `minter` Address of initial token owner\\n * - `seed` Hash of randomly generated seed\\n * - `fxParams` Random sequence of fixed-length bytes used as token input\\n */\\nstruct GenArtInfo {\\n    address minter;\\n    bytes32 seed;\\n    bytes fxParams;\\n}\\n\\n/**\\n * @notice Struct of initialization information used on project creation\\n * - `name` Name of project\\n * - `symbol` Symbol of project\\n * - `primaryReceiver` Address of splitter contract receiving primary sales\\n * - `randomizer` Address of Randomizer contract\\n * - `renderer` Address of Renderer contract\\n * - `tagIds` Array of tag IDs describing the project\\n * - 'onchainData' Onchain data to be stored using SSTORE2 and available to renderers\\n */\\nstruct InitInfo {\\n    string name;\\n    string symbol;\\n    address[] primaryReceivers;\\n    uint32[] allocations;\\n    address randomizer;\\n    address renderer;\\n    uint256[] tagIds;\\n    bytes onchainData;\\n}\\n\\n/**\\n * @notice Struct of issuer information\\n * - `primaryReceiver` Address of splitter contract receiving primary sales\\n * - `projectInfo` Project information\\n * - `activeMinters` Array of authorized minter contracts used for enumeration\\n * - `minters` Mapping of minter contract to authorization status\\n */\\nstruct IssuerInfo {\\n    address primaryReceiver;\\n    ProjectInfo projectInfo;\\n    address[] activeMinters;\\n    mapping(address => uint8) minters;\\n}\\n\\n/**\\n * @notice Struct of metadata information\\n * - `baseURI` Decoded URI of content identifier\\n * - `onchainPointer` Address of bytes-encoded data rendered onchain\\n */\\nstruct MetadataInfo {\\n    bytes baseURI;\\n    address onchainPointer;\\n}\\n\\n/**\\n * @notice Struct of mint information\\n * - `minter` Address of the minter contract\\n * - `reserveInfo` Reserve information\\n * - `params` Optional bytes data decoded inside minter\\n */\\nstruct MintInfo {\\n    address minter;\\n    ReserveInfo reserveInfo;\\n    bytes params;\\n}\\n\\n/**\\n * @notice Struct of minter information\\n * - `totalMints` Total number of mints executed by the minter\\n * - `totalPaid` Total amount paid by the minter\\n */\\nstruct MinterInfo {\\n    uint128 totalMints;\\n    uint128 totalPaid;\\n}\\n\\n/**\\n * @notice Struct of project information\\n * - `mintEnabled` Flag inidicating if minting is enabled\\n * - `burnEnabled` Flag inidicating if burning is enabled\\n * - `maxSupply` Maximum supply of tokens\\n * - `inputSize` Maximum input size of fxParams bytes data\\n * - `earliestStartTime` Earliest possible start time for registering minters\\n */\\nstruct ProjectInfo {\\n    bool mintEnabled;\\n    bool burnEnabled;\\n    uint120 maxSupply;\\n    uint88 inputSize;\\n    uint32 earliestStartTime;\\n}\\n\\n/**\\n * @notice Struct of refund information\\n * - `lastPrice` Price of last sale before selling out\\n * - `minterInfo` Mapping of minter address to struct of minter information\\n */\\nstruct RefundInfo {\\n    uint256 lastPrice;\\n    mapping(address minter => MinterInfo) minterInfo;\\n}\\n\\n/**\\n * @notice Struct of reserve information\\n * - `startTime` Start timestamp of minter\\n * - `endTime` End timestamp of minter\\n * - `allocation` Allocation amount for minter\\n */\\nstruct ReserveInfo {\\n    uint64 startTime;\\n    uint64 endTime;\\n    uint128 allocation;\\n}\\n\\n/**\\n * @notice Struct of royalty information\\n * - `receiver` Address receiving royalties\\n * - `basisPoints` Points used to calculate the royalty payment (0.01%)\\n */\\nstruct RoyaltyInfo {\\n    address receiver;\\n    uint96 basisPoints;\\n}\\n\\n/**\\n * @notice Struct of tax information\\n * - `startTime` Timestamp of when harberger taxation begins\\n * - `foreclosureTime` Timestamp of token foreclosure\\n * - `currentPrice` Current listing price of token\\n * - `depositAmount` Total amount of taxes deposited\\n */\\nstruct TaxInfo {\\n    uint48 startTime;\\n    uint48 foreclosureTime;\\n    uint80 currentPrice;\\n    uint80 depositAmount;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISeedConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n/**\\n * @title ISeedConsumer\\n * @author fx(hash)\\n * @notice Interface for randomizers to interact with FxGenArt721 tokens\\n */\\ninterface ISeedConsumer {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Event emitted when a seed request is fulfilled for a specific token\\n     * @param _randomizer Address of the randomizer contract\\n     * @param _tokenId ID of the token\\n     * @param _seed Hash of the random seed\\n     */\\n    event SeedFulfilled(address indexed _randomizer, uint256 indexed _tokenId, bytes32 _seed);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Fullfills the random seed request on the FxGenArt721 token contract\\n     * @param _tokenId ID of the token\\n     * @param _seed Hash of the random seed\\n     */\\n    function fulfillSeedRequest(uint256 _tokenId, bytes32 _seed) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\n/**\\n * @title IToken\\n * @author fx(hash)\\n * @notice Interface for minters to interact with tokens\\n */\\ninterface IToken {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Mints arbitrary number of tokens\\n     * @dev Only callable by registered minter contracts\\n     * @param _to Address receiving tokens\\n     * @param _amount Number of tokens being minted\\n     * @param _payment Total payment amount of the transaction\\n     */\\n    function mint(address _to, uint256 _amount, uint256 _payment) external;\\n\\n    /**\\n     * @notice Returns address of primary receiver for token sales\\n     */\\n    function primaryReceiver() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"scripty.sol/=lib/scripty.sol/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solmate/=lib/solmate/\",\r\n      \"sstore2/=lib/sstore2/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_roleRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrimaryReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"ImplementationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint96\",\"name\":\"_projectId\",\"type\":\"uint96\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_genArtToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ProjectCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_creationInfo\",\"type\":\"bytes\"}],\"name\":\"createProject\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"genArt721\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"primaryReceivers\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"allocations\",\"type\":\"uint32[]\"},{\"internalType\":\"address\",\"name\":\"randomizer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"renderer\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tagIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"onchainData\",\"type\":\"bytes\"}],\"internalType\":\"struct InitInfo\",\"name\":\"_initInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"mintEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"burnEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint120\",\"name\":\"maxSupply\",\"type\":\"uint120\"},{\"internalType\":\"uint88\",\"name\":\"inputSize\",\"type\":\"uint88\"},{\"internalType\":\"uint32\",\"name\":\"earliestStartTime\",\"type\":\"uint32\"}],\"internalType\":\"struct ProjectInfo\",\"name\":\"_projectInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"baseURI\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"onchainPointer\",\"type\":\"address\"}],\"internalType\":\"struct MetadataInfo\",\"name\":\"_metadataInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"allocation\",\"type\":\"uint128\"}],\"internalType\":\"struct ReserveInfo\",\"name\":\"reserveInfo\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"internalType\":\"struct MintInfo[]\",\"name\":\"_mintInfo\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"_royaltyReceivers\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_allocations\",\"type\":\"uint32[]\"},{\"internalType\":\"uint96\",\"name\":\"_basisPoints\",\"type\":\"uint96\"}],\"name\":\"createProjectWithParams\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"genArtToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_projectCreationInfo\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_ticketCreationInfo\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_ticketFactory\",\"type\":\"address\"}],\"name\":\"createProjectWithTicket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"genArtToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mintTicket\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectId\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"name\":\"projects\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roleRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FxIssuerFactory", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "2", "ConstructorArguments": "0000000000000000000000000e7de56cbf04719f5910e845885eb925a1cc39e00000000000000000000000009b87de9261c499e32fa9476a6d706abd3ee2c152000000000000000000000000fed4c55c532ff206f0359636b82c1153381642d4", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}