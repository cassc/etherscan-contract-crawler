{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AelinUpFrontDeal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./AelinERC20.sol\\\";\\nimport \\\"./MinimalProxyFactory.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport {AelinDeal} from \\\"./AelinDeal.sol\\\";\\nimport {AelinPool} from \\\"./AelinPool.sol\\\";\\nimport {AelinFeeEscrow} from \\\"./AelinFeeEscrow.sol\\\";\\nimport {IAelinUpFrontDeal} from \\\"./interfaces/IAelinUpFrontDeal.sol\\\";\\nimport \\\"./libraries/AelinNftGating.sol\\\";\\nimport \\\"./libraries/AelinAllowList.sol\\\";\\nimport \\\"./libraries/MerkleTree.sol\\\";\\n\\ncontract AelinUpFrontDeal is AelinERC20, MinimalProxyFactory, IAelinUpFrontDeal {\\n    using SafeERC20 for IERC20;\\n\\n    uint256 constant BASE = 100 * 10**18;\\n    uint256 constant MAX_SPONSOR_FEE = 15 * 10**18;\\n    uint256 constant AELIN_FEE = 2 * 10**18;\\n\\n    UpFrontDealData public dealData;\\n    UpFrontDealConfig public dealConfig;\\n\\n    address public aelinTreasuryAddress;\\n    address public aelinEscrowLogicAddress;\\n    AelinFeeEscrow public aelinFeeEscrow;\\n    address public dealFactory;\\n\\n    MerkleTree.TrackClaimed private trackClaimed;\\n    AelinAllowList.AllowList public allowList;\\n    AelinNftGating.NftGatingData public nftGating;\\n    mapping(address => uint256) public purchaseTokensPerUser;\\n    mapping(address => uint256) public poolSharesPerUser;\\n    mapping(address => uint256) public amountVested;\\n\\n    uint256 public totalPurchasingAccepted;\\n    uint256 public totalPoolShares;\\n    uint256 public totalUnderlyingClaimed;\\n\\n    bool private underlyingDepositComplete;\\n    bool private sponsorClaimed;\\n    bool private holderClaimed;\\n    bool private feeEscrowClaimed;\\n\\n    bool private calledInitialize;\\n    address public futureHolder;\\n\\n    uint256 public dealStart;\\n    uint256 public purchaseExpiry;\\n    uint256 public vestingCliffExpiry;\\n    uint256 public vestingExpiry;\\n\\n    /**\\n     * @dev initializes the contract configuration, called from the factory contract when creating a new Up Front Deal\\n     */\\n    function initialize(\\n        UpFrontDealData calldata _dealData,\\n        UpFrontDealConfig calldata _dealConfig,\\n        AelinNftGating.NftCollectionRules[] calldata _nftCollectionRules,\\n        AelinAllowList.InitData calldata _allowListInit,\\n        address _aelinTreasuryAddress,\\n        address _aelinEscrowLogicAddress\\n    ) external initOnce {\\n        // pool initialization checks\\n        require(_dealData.purchaseToken != _dealData.underlyingDealToken, \\\"purchase & underlying the same\\\");\\n        require(_dealData.purchaseToken != address(0), \\\"cant pass null purchase address\\\");\\n        require(_dealData.underlyingDealToken != address(0), \\\"cant pass null underlying address\\\");\\n        require(_dealData.holder != address(0), \\\"cant pass null holder address\\\");\\n\\n        require(_dealConfig.purchaseDuration >= 30 minutes && _dealConfig.purchaseDuration <= 30 days, \\\"not within limit\\\");\\n        require(_dealData.sponsorFee <= MAX_SPONSOR_FEE, \\\"exceeds max sponsor fee\\\");\\n\\n        uint8 purchaseTokenDecimals = IERC20Decimals(_dealData.purchaseToken).decimals();\\n\\n        require(1825 days >= _dealConfig.vestingCliffPeriod, \\\"max 5 year cliff\\\");\\n        require(1825 days >= _dealConfig.vestingPeriod, \\\"max 5 year vesting\\\");\\n\\n        require(_dealConfig.underlyingDealTokenTotal > 0, \\\"must have nonzero deal tokens\\\");\\n        require(_dealConfig.purchaseTokenPerDealToken > 0, \\\"invalid deal price\\\");\\n\\n        uint8 underlyingTokenDecimals = IERC20Decimals(_dealData.underlyingDealToken).decimals();\\n        require(purchaseTokenDecimals <= underlyingTokenDecimals, \\\"purchase token not compatible\\\");\\n        if (_dealConfig.purchaseRaiseMinimum > 0) {\\n            uint256 _totalIntendedRaise = (_dealConfig.purchaseTokenPerDealToken * _dealConfig.underlyingDealTokenTotal) /\\n                10**underlyingTokenDecimals;\\n            require(_totalIntendedRaise > 0, \\\"intended raise too small\\\");\\n            require(_dealConfig.purchaseRaiseMinimum <= _totalIntendedRaise, \\\"raise min > deal total\\\");\\n        }\\n\\n        // store pool and deal details as state variables\\n        dealData = _dealData;\\n        dealConfig = _dealConfig;\\n\\n        dealStart = block.timestamp;\\n\\n        dealFactory = msg.sender;\\n\\n        // the deal token has the same amount of decimals as the underlying deal token,\\n        // eventually making them 1:1 redeemable\\n        _setNameSymbolAndDecimals(\\n            string(abi.encodePacked(\\\"aeUpFrontDeal-\\\", _dealData.name)),\\n            string(abi.encodePacked(\\\"aeUD-\\\", _dealData.symbol)),\\n            underlyingTokenDecimals\\n        );\\n\\n        aelinEscrowLogicAddress = _aelinEscrowLogicAddress;\\n        aelinTreasuryAddress = _aelinTreasuryAddress;\\n\\n        // Allow list logic\\n        // check if there's allowlist and amounts,\\n        // if yes, store it to `allowList` and emit a single event with the addresses and amounts\\n        AelinAllowList.initialize(_allowListInit, allowList);\\n\\n        // NftCollection logic\\n        // check if the deal is nft gated\\n        // if yes, store it in `nftCollectionDetails` and `nftId` and emit respective events for 721 and 1155\\n        AelinNftGating.initialize(_nftCollectionRules, nftGating);\\n\\n        require(!(allowList.hasAllowList && nftGating.hasNftList), \\\"cant have allow list & nft\\\");\\n        require(!(allowList.hasAllowList && dealData.merkleRoot != 0), \\\"cant have allow list & merkle\\\");\\n        require(!(nftGating.hasNftList && dealData.merkleRoot != 0), \\\"cant have nft & merkle\\\");\\n        require(!(bytes(dealData.ipfsHash).length == 0 && dealData.merkleRoot != 0), \\\"merkle needs ipfs hash\\\");\\n    }\\n\\n    function _startPurchasingPeriod(\\n        uint256 _purchaseDuration,\\n        uint256 _vestingCliffPeriod,\\n        uint256 _vestingPeriod\\n    ) internal {\\n        underlyingDepositComplete = true;\\n        purchaseExpiry = block.timestamp + _purchaseDuration;\\n        vestingCliffExpiry = purchaseExpiry + _vestingCliffPeriod;\\n        vestingExpiry = vestingCliffExpiry + _vestingPeriod;\\n        emit DealFullyFunded(address(this), block.timestamp, purchaseExpiry, vestingCliffExpiry, vestingExpiry);\\n    }\\n\\n    modifier initOnce() {\\n        require(!calledInitialize, \\\"can only init once\\\");\\n        calledInitialize = true;\\n        _;\\n    }\\n\\n    /**\\n     * @dev method for holder to deposit underlying deal tokens\\n     * all underlying deal tokens must be deposited for the purchasing period to start\\n     * if tokens were deposited directly, this method must still be called to start the purchasing period\\n     * @param _depositUnderlyingAmount how many underlying tokens the holder will transfer to the contract\\n     */\\n    function depositUnderlyingTokens(uint256 _depositUnderlyingAmount) public onlyHolder {\\n        address _underlyingDealToken = dealData.underlyingDealToken;\\n\\n        require(IERC20(_underlyingDealToken).balanceOf(msg.sender) >= _depositUnderlyingAmount, \\\"not enough balance\\\");\\n        require(!underlyingDepositComplete, \\\"already deposited the total\\\");\\n\\n        uint256 balanceBeforeTransfer = IERC20(_underlyingDealToken).balanceOf(address(this));\\n        IERC20(_underlyingDealToken).safeTransferFrom(msg.sender, address(this), _depositUnderlyingAmount);\\n        uint256 balanceAfterTransfer = IERC20(_underlyingDealToken).balanceOf(address(this));\\n        uint256 underlyingDealTokenAmount = balanceAfterTransfer - balanceBeforeTransfer;\\n\\n        if (balanceAfterTransfer >= dealConfig.underlyingDealTokenTotal) {\\n            _startPurchasingPeriod(dealConfig.purchaseDuration, dealConfig.vestingCliffPeriod, dealConfig.vestingPeriod);\\n        }\\n\\n        emit DepositDealToken(_underlyingDealToken, msg.sender, underlyingDealTokenAmount);\\n    }\\n\\n    /**\\n     * @dev allows holder to withdraw any excess underlying deal tokens deposited to the contract\\n     */\\n    function withdrawExcess() external onlyHolder {\\n        address _underlyingDealToken = dealData.underlyingDealToken;\\n        uint256 _underlyingDealTokenTotal = dealConfig.underlyingDealTokenTotal;\\n        uint256 currentBalance = IERC20(_underlyingDealToken).balanceOf(address(this));\\n        require(currentBalance > _underlyingDealTokenTotal, \\\"no excess to withdraw\\\");\\n\\n        uint256 excessAmount = currentBalance - _underlyingDealTokenTotal;\\n        IERC20(_underlyingDealToken).safeTransfer(msg.sender, excessAmount);\\n\\n        emit WithdrewExcess(address(this), excessAmount);\\n    }\\n\\n    /**\\n     * @dev accept deal by depositing purchasing tokens which is converted to a mapping which stores the amount of\\n     * underlying purchased. pool shares have the same decimals as the underlying deal token\\n     * @param _nftPurchaseList NFTs to use for accepting the deal if deal is NFT gated\\n     * @param _merkleData Merkle Proof data to prove investors allocation\\n     * @param _purchaseTokenAmount how many purchase tokens will be used to purchase deal token shares\\n     */\\n    function acceptDeal(\\n        AelinNftGating.NftPurchaseList[] calldata _nftPurchaseList,\\n        MerkleTree.UpFrontMerkleData calldata _merkleData,\\n        uint256 _purchaseTokenAmount\\n    ) external lock {\\n        require(underlyingDepositComplete, \\\"deal token not deposited\\\");\\n        require(block.timestamp < purchaseExpiry, \\\"not in purchase window\\\");\\n\\n        address _purchaseToken = dealData.purchaseToken;\\n        uint256 _underlyingDealTokenTotal = dealConfig.underlyingDealTokenTotal;\\n        uint256 _purchaseTokenPerDealToken = dealConfig.purchaseTokenPerDealToken;\\n        require(IERC20(_purchaseToken).balanceOf(msg.sender) >= _purchaseTokenAmount, \\\"not enough purchaseToken\\\");\\n\\n        if (nftGating.hasNftList || _nftPurchaseList.length > 0) {\\n            AelinNftGating.purchaseDealTokensWithNft(_nftPurchaseList, nftGating, _purchaseTokenAmount);\\n        } else if (allowList.hasAllowList) {\\n            require(_purchaseTokenAmount <= allowList.amountPerAddress[msg.sender], \\\"more than allocation\\\");\\n            allowList.amountPerAddress[msg.sender] -= _purchaseTokenAmount;\\n        } else if (dealData.merkleRoot != 0) {\\n            MerkleTree.purchaseMerkleAmount(_merkleData, trackClaimed, _purchaseTokenAmount, dealData.merkleRoot);\\n        }\\n\\n        uint256 balanceBeforeTransfer = IERC20(_purchaseToken).balanceOf(address(this));\\n        IERC20(_purchaseToken).safeTransferFrom(msg.sender, address(this), _purchaseTokenAmount);\\n        uint256 balanceAfterTransfer = IERC20(_purchaseToken).balanceOf(address(this));\\n        uint256 purchaseTokenAmount = balanceAfterTransfer - balanceBeforeTransfer;\\n\\n        totalPurchasingAccepted += purchaseTokenAmount;\\n        purchaseTokensPerUser[msg.sender] += purchaseTokenAmount;\\n\\n        uint8 underlyingTokenDecimals = IERC20Decimals(dealData.underlyingDealToken).decimals();\\n        uint256 poolSharesAmount;\\n\\n        // this takes into account the decimal conversion between purchasing token and underlying deal token\\n        // pool shares having the same amount of decimals as underlying deal tokens\\n        poolSharesAmount = (purchaseTokenAmount * 10**underlyingTokenDecimals) / _purchaseTokenPerDealToken;\\n        require(poolSharesAmount > 0, \\\"purchase amount too small\\\");\\n\\n        // pool shares directly correspond to the amount of deal tokens that can be minted\\n        // pool shares held = deal tokens minted as long as no deallocation takes place\\n        totalPoolShares += poolSharesAmount;\\n        poolSharesPerUser[msg.sender] += poolSharesAmount;\\n\\n        if (!dealConfig.allowDeallocation) {\\n            require(totalPoolShares <= _underlyingDealTokenTotal, \\\"purchased amount > total\\\");\\n        }\\n\\n        emit AcceptDeal(\\n            msg.sender,\\n            purchaseTokenAmount,\\n            purchaseTokensPerUser[msg.sender],\\n            poolSharesAmount,\\n            poolSharesPerUser[msg.sender]\\n        );\\n    }\\n\\n    /**\\n     * @dev purchaser calls to claim their deal tokens or refund if the minimum raise does not pass\\n     */\\n    function purchaserClaim() public lock purchasingOver {\\n        require(poolSharesPerUser[msg.sender] > 0, \\\"no pool shares to claim with\\\");\\n\\n        address _purchaseToken = dealData.purchaseToken;\\n        uint256 _purchaseRaiseMinimum = dealConfig.purchaseRaiseMinimum;\\n\\n        if (_purchaseRaiseMinimum == 0 || totalPurchasingAccepted > _purchaseRaiseMinimum) {\\n            uint256 _underlyingDealTokenTotal = dealConfig.underlyingDealTokenTotal;\\n            // Claim Deal Tokens\\n            bool deallocate = totalPoolShares > _underlyingDealTokenTotal;\\n\\n            if (deallocate) {\\n                // adjust for deallocation and mint deal tokens\\n                uint256 adjustedDealTokensForUser = (((poolSharesPerUser[msg.sender] * _underlyingDealTokenTotal) /\\n                    totalPoolShares) * (BASE - AELIN_FEE - dealData.sponsorFee)) / BASE;\\n                poolSharesPerUser[msg.sender] = 0;\\n\\n                // refund any purchase tokens that got deallocated\\n                uint256 purchasingRefund = purchaseTokensPerUser[msg.sender] -\\n                    ((purchaseTokensPerUser[msg.sender] * _underlyingDealTokenTotal) / totalPoolShares);\\n                purchaseTokensPerUser[msg.sender] = 0;\\n\\n                uint256 precisionAdjustedRefund = purchasingRefund > IERC20(_purchaseToken).balanceOf(address(this))\\n                    ? IERC20(_purchaseToken).balanceOf(address(this))\\n                    : purchasingRefund;\\n\\n                // mint deal tokens and transfer purchase token refund\\n                _mint(msg.sender, adjustedDealTokensForUser);\\n                IERC20(_purchaseToken).safeTransfer(msg.sender, precisionAdjustedRefund);\\n\\n                emit ClaimDealTokens(msg.sender, adjustedDealTokensForUser, precisionAdjustedRefund);\\n            } else {\\n                // mint deal tokens when there is no deallocation\\n                uint256 adjustedDealTokensForUser = ((BASE - AELIN_FEE - dealData.sponsorFee) *\\n                    poolSharesPerUser[msg.sender]) / BASE;\\n                poolSharesPerUser[msg.sender] = 0;\\n                purchaseTokensPerUser[msg.sender] = 0;\\n                _mint(msg.sender, adjustedDealTokensForUser);\\n                emit ClaimDealTokens(msg.sender, adjustedDealTokensForUser, 0);\\n            }\\n        } else {\\n            // Claim Refund\\n            uint256 currentBalance = purchaseTokensPerUser[msg.sender];\\n            purchaseTokensPerUser[msg.sender] = 0;\\n            poolSharesPerUser[msg.sender] = 0;\\n            IERC20(_purchaseToken).safeTransfer(msg.sender, currentBalance);\\n            emit ClaimDealTokens(msg.sender, 0, currentBalance);\\n        }\\n    }\\n\\n    /**\\n     * @dev sponsor calls once the purchasing period is over if the minimum raise has passed to claim\\n     * their share of deal tokens\\n     * NOTE also calls the claim for the protocol fee\\n     */\\n    function sponsorClaim() public lock purchasingOver passMinimumRaise onlySponsor {\\n        require(!sponsorClaimed, \\\"sponsor already claimed\\\");\\n        sponsorClaimed = true;\\n\\n        address _sponsor = dealData.sponsor;\\n        uint256 _underlyingDealTokenTotal = dealConfig.underlyingDealTokenTotal;\\n\\n        uint256 totalSold = totalPoolShares > _underlyingDealTokenTotal ? _underlyingDealTokenTotal : totalPoolShares;\\n        uint256 _sponsorFeeAmt = (totalSold * dealData.sponsorFee) / BASE;\\n        _mint(_sponsor, _sponsorFeeAmt);\\n        emit SponsorClaim(_sponsor, _sponsorFeeAmt);\\n\\n        if (!feeEscrowClaimed) {\\n            feeEscrowClaim();\\n        }\\n    }\\n\\n    /**\\n     * @dev holder calls once purchasing period is over to claim their raise or\\n     * underlying deal tokens if the minimum raise has not passed\\n     * NOTE also calls the claim for the protocol fee\\n     */\\n    function holderClaim() public lock purchasingOver onlyHolder {\\n        require(!holderClaimed, \\\"holder already claimed\\\");\\n        holderClaimed = true;\\n\\n        address _holder = dealData.holder;\\n        address _underlyingDealToken = dealData.underlyingDealToken;\\n        address _purchaseToken = dealData.purchaseToken;\\n        uint256 _purchaseRaiseMinimum = dealConfig.purchaseRaiseMinimum;\\n\\n        if (_purchaseRaiseMinimum == 0 || totalPurchasingAccepted > _purchaseRaiseMinimum) {\\n            uint256 _underlyingDealTokenTotal = dealConfig.underlyingDealTokenTotal;\\n\\n            bool deallocate = totalPoolShares > _underlyingDealTokenTotal;\\n            if (deallocate) {\\n                uint256 _underlyingTokenDecimals = IERC20Decimals(_underlyingDealToken).decimals();\\n                uint256 _totalIntendedRaise = (dealConfig.purchaseTokenPerDealToken * _underlyingDealTokenTotal) /\\n                    10**_underlyingTokenDecimals;\\n\\n                uint256 precisionAdjustedRaise = _totalIntendedRaise > IERC20(_purchaseToken).balanceOf(address(this))\\n                    ? IERC20(_purchaseToken).balanceOf(address(this))\\n                    : _totalIntendedRaise;\\n\\n                IERC20(_purchaseToken).safeTransfer(_holder, precisionAdjustedRaise);\\n                emit HolderClaim(_holder, _purchaseToken, precisionAdjustedRaise, _underlyingDealToken, 0, block.timestamp);\\n            } else {\\n                // holder receives raise\\n                uint256 _currentBalance = IERC20(_purchaseToken).balanceOf(address(this));\\n                IERC20(_purchaseToken).safeTransfer(_holder, _currentBalance);\\n                // holder receives any leftover underlying deal tokens\\n                uint256 _underlyingRefund = _underlyingDealTokenTotal - totalPoolShares;\\n                IERC20(_underlyingDealToken).safeTransfer(_holder, _underlyingRefund);\\n                emit HolderClaim(\\n                    _holder,\\n                    _purchaseToken,\\n                    _currentBalance,\\n                    _underlyingDealToken,\\n                    _underlyingRefund,\\n                    block.timestamp\\n                );\\n            }\\n            if (!feeEscrowClaimed) {\\n                feeEscrowClaim();\\n            }\\n        } else {\\n            uint256 _currentBalance = IERC20(_underlyingDealToken).balanceOf(address(this));\\n            IERC20(_underlyingDealToken).safeTransfer(_holder, _currentBalance);\\n            emit HolderClaim(_holder, _purchaseToken, 0, _underlyingDealToken, _currentBalance, block.timestamp);\\n        }\\n    }\\n\\n    /**\\n     * @dev transfers protocol fee of underlying deal tokens to the treasury escrow contract\\n     */\\n    function feeEscrowClaim() public purchasingOver {\\n        if (!feeEscrowClaimed) {\\n            feeEscrowClaimed = true;\\n            address _underlyingDealToken = dealData.underlyingDealToken;\\n            uint256 _underlyingDealTokenTotal = dealConfig.underlyingDealTokenTotal;\\n\\n            address aelinEscrowStorageProxy = _cloneAsMinimalProxy(aelinEscrowLogicAddress, \\\"Could not create new escrow\\\");\\n            aelinFeeEscrow = AelinFeeEscrow(aelinEscrowStorageProxy);\\n            aelinFeeEscrow.initialize(aelinTreasuryAddress, _underlyingDealToken);\\n\\n            uint256 totalSold;\\n            if (totalPoolShares > _underlyingDealTokenTotal) {\\n                totalSold = _underlyingDealTokenTotal;\\n            } else {\\n                totalSold = totalPoolShares;\\n            }\\n            uint256 aelinFeeAmt = (totalSold * AELIN_FEE) / BASE;\\n            IERC20(_underlyingDealToken).safeTransfer(address(aelinFeeEscrow), aelinFeeAmt);\\n\\n            emit FeeEscrowClaim(aelinEscrowStorageProxy, _underlyingDealToken, aelinFeeAmt);\\n        }\\n    }\\n\\n    /**\\n     * @dev purchaser calls after the purchasing period to claim underlying deal tokens\\n     * amount based on the vesting schedule\\n     */\\n    function claimUnderlying() external lock purchasingOver passMinimumRaise {\\n        uint256 underlyingDealTokensClaimed = claimableUnderlyingTokens(msg.sender);\\n        require(underlyingDealTokensClaimed > 0, \\\"no underlying ready to claim\\\");\\n        address _underlyingDealToken = dealData.underlyingDealToken;\\n        amountVested[msg.sender] += underlyingDealTokensClaimed;\\n        _burn(msg.sender, underlyingDealTokensClaimed);\\n        totalUnderlyingClaimed += underlyingDealTokensClaimed;\\n        IERC20(_underlyingDealToken).safeTransfer(msg.sender, underlyingDealTokensClaimed);\\n        emit ClaimedUnderlyingDealToken(msg.sender, _underlyingDealToken, underlyingDealTokensClaimed);\\n    }\\n\\n    /**\\n     * @dev a view showing the amount of the underlying deal token a purchaser can claim\\n     * @param _purchaser address to check the quantity of claimable underlying tokens\\n     */\\n    function claimableUnderlyingTokens(address _purchaser) public view purchasingOver returns (uint256) {\\n        uint256 _vestingPeriod = dealConfig.vestingPeriod;\\n        uint256 precisionAdjustedUnderlyingClaimable;\\n\\n        uint256 maxTime = block.timestamp > vestingExpiry ? vestingExpiry : block.timestamp;\\n        if (\\n            balanceOf(_purchaser) > 0 &&\\n            (maxTime > vestingCliffExpiry || (maxTime == vestingCliffExpiry && _vestingPeriod == 0))\\n        ) {\\n            uint256 timeElapsed = maxTime - vestingCliffExpiry;\\n\\n            uint256 underlyingClaimable = _vestingPeriod == 0\\n                ? balanceOf(_purchaser)\\n                : ((balanceOf(_purchaser) + amountVested[_purchaser]) * timeElapsed) /\\n                    _vestingPeriod -\\n                    amountVested[_purchaser];\\n            // This could potentially be the case where the last user claims a slightly smaller amount if there is some precision loss\\n            // although it will generally never happen as solidity rounds down so there should always be a little bit left\\n            address _underlyingDealToken = dealData.underlyingDealToken;\\n            precisionAdjustedUnderlyingClaimable = underlyingClaimable >\\n                IERC20(_underlyingDealToken).balanceOf(address(this))\\n                ? IERC20(_underlyingDealToken).balanceOf(address(this))\\n                : underlyingClaimable;\\n        }\\n\\n        return (precisionAdjustedUnderlyingClaimable);\\n    }\\n\\n    /**\\n     * @dev the holder may change their address\\n     * @param _holder address to swap the holder role\\n     */\\n    function setHolder(address _holder) external onlyHolder {\\n        futureHolder = _holder;\\n    }\\n\\n    /**\\n     * @dev futurHolder can call to accept the role of holder\\n     */\\n    function acceptHolder() external {\\n        require(msg.sender == futureHolder, \\\"only future holder can access\\\");\\n        dealData.holder = futureHolder;\\n        emit SetHolder(futureHolder);\\n    }\\n\\n    /**\\n     * @dev a function that any Ethereum address can call to vouch for a pool's legitimacy\\n     */\\n    function vouch() external {\\n        emit Vouch(msg.sender);\\n    }\\n\\n    /**\\n     * @dev a function that any Ethereum address can call to disavow for a pool's legitimacy\\n     */\\n    function disavow() external {\\n        emit Disavow(msg.sender);\\n    }\\n\\n    /**\\n     * @dev returns allow list information\\n     * @param _userAddress address to use in returning the amountPerAddress\\n     * @return address[] returns array of addresses included in the allow list\\n     * @return uint256[] returns array of allow list amounts for the address matching the index of allowListAddresses\\n     * @return uint256 allow list amount for _userAddress input\\n     * @return bool true if this deal has an allow list\\n     */\\n    function getAllowList(address _userAddress)\\n        public\\n        view\\n        returns (\\n            address[] memory,\\n            uint256[] memory,\\n            uint256,\\n            bool\\n        )\\n    {\\n        return (\\n            allowList.allowListAddresses,\\n            allowList.allowListAmounts,\\n            allowList.amountPerAddress[_userAddress],\\n            allowList.hasAllowList\\n        );\\n    }\\n\\n    /**\\n     * @dev returns NFT collection details for the input collection address\\n     * @param _collection NFT collection address to get the collection details for\\n     * @return uint256 purchase amount, if 0 then unlimited purchase\\n     * @return address collection address used for configuration\\n     * @return bool if true then purchase amount is per token, if false then purchase amount is per user\\n     * @return uint256[] for ERC1155, included token IDs for this collection\\n     * @return uint256[] for ERC1155, min number of tokens required for participating\\n     */\\n    function getNftCollectionDetails(address _collection)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            address,\\n            bool,\\n            uint256[] memory,\\n            uint256[] memory\\n        )\\n    {\\n        return (\\n            nftGating.nftCollectionDetails[_collection].purchaseAmount,\\n            nftGating.nftCollectionDetails[_collection].collectionAddress,\\n            nftGating.nftCollectionDetails[_collection].purchaseAmountPerToken,\\n            nftGating.nftCollectionDetails[_collection].tokenIds,\\n            nftGating.nftCollectionDetails[_collection].minTokensEligible\\n        );\\n    }\\n\\n    /**\\n     * @dev returns various details about the NFT gating storage\\n     * @param _collection NFT collection address to check\\n     * @param _wallet user address to check\\n     * @param _nftId if _collection is ERC721 or CryptoPunks check if this ID has been used, if ERC1155 check if this ID is included\\n     * @return bool true if the _wallet has already been used to claim this _collection\\n     * @return bool if _collection is ERC721 or CryptoPunks true if this ID has been used, if ERC1155 true if this ID is included\\n     * @return bool returns hasNftList, true if this deal has a valid NFT gating list\\n     */\\n    function getNftGatingDetails(\\n        address _collection,\\n        address _wallet,\\n        uint256 _nftId\\n    )\\n        public\\n        view\\n        returns (\\n            bool,\\n            bool,\\n            bool\\n        )\\n    {\\n        return (\\n            nftGating.nftWalletUsedForPurchase[_collection][_wallet],\\n            nftGating.nftId[_collection][_nftId],\\n            nftGating.hasNftList\\n        );\\n    }\\n\\n    /**\\n     * @dev getPurchaseTokensPerUser\\n     * @param _address address to check\\n     */\\n    function getPurchaseTokensPerUser(address _address) public view returns (uint256) {\\n        return (purchaseTokensPerUser[_address]);\\n    }\\n\\n    /**\\n     * @dev getPoolSharesPerUser\\n     * @param _address address to check\\n     */\\n    function getPoolSharesPerUser(address _address) public view returns (uint256) {\\n        return (poolSharesPerUser[_address]);\\n    }\\n\\n    /**\\n     * @dev getAmountVested\\n     * @param _address address to check\\n     */\\n    function getAmountVested(address _address) public view returns (uint256) {\\n        return (amountVested[_address]);\\n    }\\n\\n    /**\\n     * @dev hasPurchasedMerkle\\n     * @param _index index of leaf node/ address to check\\n     */\\n    function hasPurchasedMerkle(uint256 _index) public view returns (bool) {\\n        return MerkleTree.hasPurchasedMerkle(trackClaimed, _index);\\n    }\\n\\n    modifier onlyHolder() {\\n        require(msg.sender == dealData.holder, \\\"must be holder\\\");\\n        _;\\n    }\\n\\n    modifier onlySponsor() {\\n        require(msg.sender == dealData.sponsor, \\\"must be sponsor\\\");\\n        _;\\n    }\\n\\n    modifier purchasingOver() {\\n        require(underlyingDepositComplete, \\\"underlying deposit incomplete\\\");\\n        require(block.timestamp > purchaseExpiry, \\\"purchase period not over\\\");\\n        _;\\n    }\\n\\n    modifier passMinimumRaise() {\\n        require(\\n            dealConfig.purchaseRaiseMinimum == 0 || totalPurchasingAccepted > dealConfig.purchaseRaiseMinimum,\\n            \\\"does not pass min raise\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier blockTransfer() {\\n        require(false, \\\"cant transfer deal tokens\\\");\\n        _;\\n    }\\n\\n    function transfer(address _dst, uint256 _amount) public virtual override blockTransfer returns (bool) {\\n        return super.transfer(_dst, _amount);\\n    }\\n\\n    function transferFrom(\\n        address _src,\\n        address _dst,\\n        uint256 _amount\\n    ) public virtual override blockTransfer returns (bool) {\\n        return super.transferFrom(_src, _dst, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AelinERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport {ERC20, IERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ninterface IERC20Decimals {\\n    function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @dev a standard ERC20 contract that is extended with a few methods\\n * described in detail below\\n */\\ncontract AelinERC20 is ERC20 {\\n    bool setInfo;\\n    /**\\n     * @dev Due to the constructor being empty for the MinimalProxy architecture we need\\n     * to set the name and symbol in the initializer which requires these custom variables\\n     */\\n    string private _custom_name;\\n    string private _custom_symbol;\\n    uint8 private _custom_decimals;\\n    bool private locked;\\n    uint8 constant DEAL_TOKEN_DECIMALS = 18;\\n\\n    constructor() ERC20(\\\"\\\", \\\"\\\") {}\\n\\n    modifier initInfoOnce() {\\n        require(!setInfo, \\\"can only initialize once\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Due to the constructor being empty for the MinimalProxy architecture we need\\n     * to set the name, symbol, and decimals in the initializer which requires this\\n     * custom logic for name(), symbol(), decimals(), and _setNameSymbolAndDecimals()\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _custom_name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _custom_symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return _custom_decimals;\\n    }\\n\\n    function _setNameSymbolAndDecimals(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) internal initInfoOnce returns (bool) {\\n        _custom_name = _name;\\n        _custom_symbol = _symbol;\\n        _custom_decimals = _decimals;\\n        setInfo = true;\\n        emit AelinToken(_name, _symbol, _decimals);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Add this to prevent reentrancy attacks on purchasePoolTokens and depositUnderlying\\n     * source: https://quantstamp.com/blog/how-the-dforce-hacker-used-reentrancy-to-steal-25-million\\n     * uniswap implementation: https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L31-L36\\n     */\\n    modifier lock() {\\n        require(!locked, \\\"AelinV1: LOCKED\\\");\\n        locked = true;\\n        _;\\n        locked = false;\\n    }\\n\\n    event AelinToken(string name, string symbol, uint8 decimals);\\n}\\n\"\r\n    },\r\n    \"contracts/MinimalProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.7;\\n\\n// https://docs.synthetix.io/contracts/source/contracts/minimalproxyfactory\\n// https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\\ncontract MinimalProxyFactory {\\n    function _cloneAsMinimalProxy(address _base, string memory _revertMsg) internal returns (address clone) {\\n        bytes memory createData = _generateMinimalProxyCreateData(_base);\\n\\n        assembly {\\n            clone := create(\\n                0, // no value\\n                add(createData, 0x20), // data\\n                55 // data is always 55 bytes (10 constructor + 45 code)\\n            )\\n        }\\n\\n        // If CREATE fails for some reason, address(0) is returned\\n        require(clone != address(0), _revertMsg);\\n    }\\n\\n    function _generateMinimalProxyCreateData(address _base) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                //---- constructor -----\\n                bytes10(0x3d602d80600a3d3981f3),\\n                //---- proxy code -----\\n                bytes10(0x363d3d373d3d3d363d73),\\n                _base,\\n                bytes15(0x5af43d82803e903d91602b57fd5bf3)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\\n     * consuming from one or the other at each step according to the instructions given by\\n     * `proofFlags`.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AelinDeal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./AelinERC20.sol\\\";\\nimport \\\"./interfaces/IAelinDeal.sol\\\";\\nimport \\\"./MinimalProxyFactory.sol\\\";\\nimport \\\"./AelinFeeEscrow.sol\\\";\\n\\ncontract AelinDeal is AelinERC20, MinimalProxyFactory, IAelinDeal {\\n    using SafeERC20 for IERC20;\\n    uint256 public maxTotalSupply;\\n\\n    address public underlyingDealToken;\\n    uint256 public underlyingDealTokenTotal;\\n    uint256 public totalUnderlyingClaimed;\\n    address public holder;\\n    address public futureHolder;\\n    address public aelinTreasuryAddress;\\n\\n    uint256 public underlyingPerDealExchangeRate;\\n\\n    address public aelinPool;\\n    uint256 public vestingCliffExpiry;\\n    uint256 public vestingCliffPeriod;\\n    uint256 public vestingPeriod;\\n    uint256 public vestingExpiry;\\n    uint256 public holderFundingExpiry;\\n\\n    bool private calledInitialize;\\n    address public aelinEscrowAddress;\\n    AelinFeeEscrow public aelinFeeEscrow;\\n\\n    bool public depositComplete;\\n    mapping(address => uint256) public amountVested;\\n\\n    Timeline public openRedemption;\\n    Timeline public proRataRedemption;\\n\\n    /**\\n     * @dev the constructor will always be blank due to the MinimalProxyFactory pattern\\n     * this allows the underlying logic of this contract to only be deployed once\\n     * and each new deal created is simply a storage wrapper\\n     */\\n    constructor() {}\\n\\n    /**\\n     * @dev the initialize method replaces the constructor setup and can only be called once\\n     * NOTE the deal tokens wrapping the underlying are always 18 decimals\\n     */\\n    function initialize(\\n        string calldata _poolName,\\n        string calldata _poolSymbol,\\n        DealData calldata _dealData,\\n        address _aelinTreasuryAddress,\\n        address _aelinEscrowAddress\\n    ) external initOnce {\\n        _setNameSymbolAndDecimals(\\n            string(abi.encodePacked(\\\"aeDeal-\\\", _poolName)),\\n            string(abi.encodePacked(\\\"aeD-\\\", _poolSymbol)),\\n            DEAL_TOKEN_DECIMALS\\n        );\\n\\n        holder = _dealData.holder;\\n        underlyingDealToken = _dealData.underlyingDealToken;\\n        underlyingDealTokenTotal = _dealData.underlyingDealTokenTotal;\\n        maxTotalSupply = _dealData.maxDealTotalSupply;\\n\\n        aelinPool = msg.sender;\\n        vestingCliffPeriod = _dealData.vestingCliffPeriod;\\n        vestingPeriod = _dealData.vestingPeriod;\\n        proRataRedemption.period = _dealData.proRataRedemptionPeriod;\\n        openRedemption.period = _dealData.openRedemptionPeriod;\\n        holderFundingExpiry = _dealData.holderFundingDuration;\\n        aelinTreasuryAddress = _aelinTreasuryAddress;\\n        aelinEscrowAddress = _aelinEscrowAddress;\\n\\n        depositComplete = false;\\n\\n        /**\\n         * calculates the amount of underlying deal tokens you get per wrapped deal token accepted\\n         */\\n        underlyingPerDealExchangeRate = (_dealData.underlyingDealTokenTotal * 1e18) / maxTotalSupply;\\n        emit SetHolder(_dealData.holder);\\n    }\\n\\n    modifier initOnce() {\\n        require(!calledInitialize, \\\"can only initialize once\\\");\\n        calledInitialize = true;\\n        _;\\n    }\\n\\n    modifier finalizeDeposit() {\\n        require(block.timestamp < holderFundingExpiry, \\\"deposit past deadline\\\");\\n        require(!depositComplete, \\\"deposit already complete\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev the holder may change their address\\n     */\\n    function setHolder(address _holder) external onlyHolder {\\n        require(_holder != address(0));\\n        futureHolder = _holder;\\n    }\\n\\n    function acceptHolder() external {\\n        require(msg.sender == futureHolder, \\\"only future holder can access\\\");\\n        holder = futureHolder;\\n        emit SetHolder(futureHolder);\\n    }\\n\\n    /**\\n     * @dev the holder finalizes the deal for the pool created by the\\n     * sponsor by depositing funds using this method.\\n     *\\n     * NOTE if the deposit was completed with a transfer instead of this method\\n     * the deposit still needs to be finalized by calling this method with\\n     * _underlyingDealTokenAmount set to 0\\n     */\\n    function depositUnderlying(uint256 _underlyingDealTokenAmount) external finalizeDeposit lock returns (bool) {\\n        if (_underlyingDealTokenAmount > 0) {\\n            uint256 currentBalance = IERC20(underlyingDealToken).balanceOf(address(this));\\n            IERC20(underlyingDealToken).safeTransferFrom(msg.sender, address(this), _underlyingDealTokenAmount);\\n            uint256 balanceAfterTransfer = IERC20(underlyingDealToken).balanceOf(address(this));\\n            uint256 underlyingDealTokenAmount = balanceAfterTransfer - currentBalance;\\n\\n            emit DepositDealToken(underlyingDealToken, msg.sender, underlyingDealTokenAmount);\\n        }\\n\\n        if (IERC20(underlyingDealToken).balanceOf(address(this)) >= underlyingDealTokenTotal) {\\n            depositComplete = true;\\n            proRataRedemption.start = block.timestamp;\\n            proRataRedemption.expiry = block.timestamp + proRataRedemption.period;\\n            vestingCliffExpiry = block.timestamp + proRataRedemption.period + openRedemption.period + vestingCliffPeriod;\\n            vestingExpiry = vestingCliffExpiry + vestingPeriod;\\n\\n            if (openRedemption.period > 0) {\\n                openRedemption.start = proRataRedemption.expiry;\\n                openRedemption.expiry = proRataRedemption.expiry + openRedemption.period;\\n            }\\n\\n            address aelinEscrowStorageProxy = _cloneAsMinimalProxy(aelinEscrowAddress, \\\"Could not create new escrow\\\");\\n            aelinFeeEscrow = AelinFeeEscrow(aelinEscrowStorageProxy);\\n            aelinFeeEscrow.initialize(aelinTreasuryAddress, underlyingDealToken);\\n\\n            emit DealFullyFunded(\\n                aelinPool,\\n                proRataRedemption.start,\\n                proRataRedemption.expiry,\\n                openRedemption.start,\\n                openRedemption.expiry\\n            );\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @dev the holder can withdraw any amount accidentally deposited over\\n     * the amount needed to fulfill the deal or all amount if deposit was not completed\\n     */\\n    function withdraw() external onlyHolder {\\n        uint256 withdrawAmount;\\n        if (!depositComplete && block.timestamp >= holderFundingExpiry) {\\n            withdrawAmount = IERC20(underlyingDealToken).balanceOf(address(this));\\n        } else {\\n            withdrawAmount =\\n                IERC20(underlyingDealToken).balanceOf(address(this)) -\\n                (underlyingDealTokenTotal - totalUnderlyingClaimed);\\n        }\\n        IERC20(underlyingDealToken).safeTransfer(holder, withdrawAmount);\\n        emit WithdrawUnderlyingDealToken(underlyingDealToken, holder, withdrawAmount);\\n    }\\n\\n    /**\\n     * @dev after the redemption period has ended the holder can withdraw\\n     * the excess funds remaining from purchasers who did not accept the deal\\n     *\\n     * Requirements:\\n     * - both the pro rata and open redemption windows are no longer active\\n     */\\n    function withdrawExpiry() external onlyHolder {\\n        require(proRataRedemption.expiry > 0, \\\"redemption period not started\\\");\\n        require(\\n            openRedemption.expiry > 0\\n                ? block.timestamp >= openRedemption.expiry\\n                : block.timestamp >= proRataRedemption.expiry,\\n            \\\"redeem window still active\\\"\\n        );\\n        uint256 withdrawAmount = IERC20(underlyingDealToken).balanceOf(address(this)) -\\n            ((underlyingPerDealExchangeRate * totalSupply()) / 1e18);\\n        IERC20(underlyingDealToken).safeTransfer(holder, withdrawAmount);\\n        emit WithdrawUnderlyingDealToken(underlyingDealToken, holder, withdrawAmount);\\n    }\\n\\n    modifier onlyHolder() {\\n        require(msg.sender == holder, \\\"only holder can access\\\");\\n        _;\\n    }\\n\\n    modifier onlyPool() {\\n        require(msg.sender == aelinPool, \\\"only AelinPool can access\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev a view showing the number of claimable deal tokens and the\\n     * amount of the underlying deal token a purchser gets in return\\n     */\\n    function claimableTokens(address purchaser)\\n        public\\n        view\\n        returns (uint256 underlyingClaimable, uint256 dealTokensClaimable)\\n    {\\n        underlyingClaimable = 0;\\n        dealTokensClaimable = 0;\\n\\n        uint256 maxTime = block.timestamp > vestingExpiry ? vestingExpiry : block.timestamp;\\n        if (\\n            balanceOf(purchaser) > 0 &&\\n            (maxTime > vestingCliffExpiry || (maxTime == vestingCliffExpiry && vestingPeriod == 0))\\n        ) {\\n            uint256 timeElapsed = maxTime - vestingCliffExpiry;\\n\\n            dealTokensClaimable = vestingPeriod == 0\\n                ? balanceOf(purchaser)\\n                : ((balanceOf(purchaser) + amountVested[purchaser]) * timeElapsed) / vestingPeriod - amountVested[purchaser];\\n            underlyingClaimable = (underlyingPerDealExchangeRate * dealTokensClaimable) / 1e18;\\n        }\\n    }\\n\\n    /**\\n     * @dev allows a user to claim their underlying deal tokens or a partial amount\\n     * of their underlying tokens once they have vested according to the schedule\\n     * created by the sponsor\\n     */\\n    function claim() external returns (uint256) {\\n        return _claim(msg.sender);\\n    }\\n\\n    function _claim(address recipient) internal returns (uint256) {\\n        (uint256 underlyingDealTokensClaimed, uint256 dealTokensClaimed) = claimableTokens(recipient);\\n        if (dealTokensClaimed > 0) {\\n            amountVested[recipient] += dealTokensClaimed;\\n            totalUnderlyingClaimed += underlyingDealTokensClaimed;\\n            _burn(recipient, dealTokensClaimed);\\n            IERC20(underlyingDealToken).safeTransfer(recipient, underlyingDealTokensClaimed);\\n            emit ClaimedUnderlyingDealToken(underlyingDealToken, recipient, underlyingDealTokensClaimed);\\n        }\\n        return dealTokensClaimed;\\n    }\\n\\n    /**\\n     * @dev allows the purchaser to mint deal tokens. this method is also used\\n     * to send deal tokens to the sponsor. It may only be called from the pool\\n     * contract that created this deal\\n     */\\n    function mint(address dst, uint256 dealTokenAmount) external onlyPool {\\n        require(depositComplete, \\\"deposit not complete\\\");\\n        _mint(dst, dealTokenAmount);\\n    }\\n\\n    /**\\n     * @dev allows the protocol to handle protocol fees coming in deal tokens.\\n     * It may only be called from the pool contract that created this deal\\n     */\\n    function protocolMint(uint256 dealTokenAmount) external onlyPool {\\n        require(depositComplete, \\\"deposit not complete\\\");\\n        uint256 underlyingProtocolFees = (underlyingPerDealExchangeRate * dealTokenAmount) / 1e18;\\n        IERC20(underlyingDealToken).safeTransfer(address(aelinFeeEscrow), underlyingProtocolFees);\\n    }\\n\\n    modifier blockTransfer() {\\n        require(msg.sender == aelinTreasuryAddress, \\\"cannot transfer deal tokens\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev a function only the treasury can use so they can send both the all\\n     * unvested deal tokens as well as all the vested underlying deal tokens in a\\n     * single transaction for distribution to $AELIN stakers.\\n     */\\n    function treasuryTransfer(address recipient) external returns (bool) {\\n        require(msg.sender == aelinTreasuryAddress, \\\"only Rewards address can access\\\");\\n        (uint256 underlyingClaimable, uint256 claimableDealTokens) = claimableTokens(msg.sender);\\n        transfer(recipient, balanceOf(msg.sender) - claimableDealTokens);\\n        IERC20(underlyingDealToken).safeTransferFrom(msg.sender, recipient, underlyingClaimable);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev below are helpers for transferring deal tokens. NOTE the token holder transferring\\n     * the deal tokens must pay the gas to claim their vested tokens first, which will burn their vested deal\\n     * tokens. They must also pay for the receivers claim and burn any of their vested tokens in order to ensure\\n     * the claim calculation is always accurate for all parties in the system\\n     */\\n    function transferMax(address recipient) external blockTransfer returns (bool) {\\n        (, uint256 claimableDealTokens) = claimableTokens(msg.sender);\\n        return transfer(recipient, balanceOf(msg.sender) - claimableDealTokens);\\n    }\\n\\n    function transferFromMax(address sender, address recipient) external blockTransfer returns (bool) {\\n        (, uint256 claimableDealTokens) = claimableTokens(sender);\\n        return transferFrom(sender, recipient, balanceOf(sender) - claimableDealTokens);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override blockTransfer returns (bool) {\\n        _claim(msg.sender);\\n        _claim(recipient);\\n        return super.transfer(recipient, amount);\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override blockTransfer returns (bool) {\\n        _claim(sender);\\n        _claim(recipient);\\n        return super.transferFrom(sender, recipient, amount);\\n    }\\n\\n    event SetHolder(address indexed holder);\\n    event DealFullyFunded(\\n        address indexed poolAddress,\\n        uint256 proRataRedemptionStart,\\n        uint256 proRataRedemptionExpiry,\\n        uint256 openRedemptionStart,\\n        uint256 openRedemptionExpiry\\n    );\\n    event DepositDealToken(\\n        address indexed underlyingDealTokenAddress,\\n        address indexed depositor,\\n        uint256 underlyingDealTokenAmount\\n    );\\n    event WithdrawUnderlyingDealToken(\\n        address indexed underlyingDealTokenAddress,\\n        address indexed depositor,\\n        uint256 underlyingDealTokenAmount\\n    );\\n    event ClaimedUnderlyingDealToken(\\n        address indexed underlyingDealTokenAddress,\\n        address indexed recipient,\\n        uint256 underlyingDealTokensClaimed\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/AelinPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./AelinDeal.sol\\\";\\nimport \\\"./interfaces/IAelinPool.sol\\\";\\nimport \\\"./interfaces/ICryptoPunks.sol\\\";\\nimport \\\"./libraries/NftCheck.sol\\\";\\n\\ncontract AelinPool is AelinERC20, MinimalProxyFactory, IAelinPool {\\n    using SafeERC20 for IERC20;\\n    address constant CRYPTO_PUNKS = address(0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB);\\n    uint256 constant BASE = 100 * 10**18;\\n    uint256 constant MAX_SPONSOR_FEE = 15 * 10**18;\\n    uint256 constant AELIN_FEE = 2 * 10**18;\\n    uint8 constant MAX_DEALS = 5;\\n\\n    uint8 public numberOfDeals;\\n    uint8 public purchaseTokenDecimals;\\n    address public purchaseToken;\\n    uint256 public purchaseTokenCap;\\n    uint256 public proRataConversion;\\n\\n    uint256 public sponsorFee;\\n    address public sponsor;\\n    address public futureSponsor;\\n    address public poolFactory;\\n\\n    uint256 public purchaseExpiry;\\n    uint256 public poolExpiry;\\n    uint256 public holderFundingExpiry;\\n    uint256 public totalAmountAccepted;\\n    uint256 public totalAmountWithdrawn;\\n    uint256 public purchaseTokenTotalForDeal;\\n\\n    bool private calledInitialize;\\n\\n    address public aelinTreasuryAddress;\\n    address public aelinDealLogicAddress;\\n    address public aelinEscrowLogicAddress;\\n    AelinDeal public aelinDeal;\\n    address public holder;\\n\\n    mapping(address => uint256) public amountAccepted;\\n    mapping(address => uint256) public amountWithdrawn;\\n    mapping(address => bool) public openPeriodEligible;\\n    mapping(address => uint256) public allowList;\\n    // collectionAddress -> NftCollectionRules struct\\n    mapping(address => NftCollectionRules) public nftCollectionDetails;\\n    // collectionAddress -> walletAddress -> bool\\n    mapping(address => mapping(address => bool)) public nftWalletUsedForPurchase;\\n    // collectionAddress -> tokenId -> bool\\n    /**\\n     * @dev For 721, it is used for blacklisting the tokenId of a collection\\n     * and for 1155, it is used for identifying the eligible tokenIds for\\n     * participating in the pool\\n     */\\n    mapping(address => mapping(uint256 => bool)) public nftId;\\n    bool public hasNftList;\\n    bool public hasAllowList;\\n\\n    string private storedName;\\n    string private storedSymbol;\\n\\n    /**\\n     * @dev the constructor will always be blank due to the MinimalProxyFactory pattern\\n     * this allows the underlying logic of this contract to only be deployed once\\n     * and each new pool created is simply a storage wrapper\\n     */\\n    constructor() {}\\n\\n    /**\\n     * @dev the initialize method replaces the constructor setup and can only be called once\\n     *\\n     * Requirements:\\n     * - max 1 year duration\\n     * - purchase expiry can be set from 30 minutes to 30 days\\n     * - max sponsor fee is 15000 representing 15%\\n     */\\n    function initialize(\\n        PoolData calldata _poolData,\\n        address _sponsor,\\n        address _aelinDealLogicAddress,\\n        address _aelinTreasuryAddress,\\n        address _aelinEscrowLogicAddress\\n    ) external initOnce {\\n        require(\\n            30 minutes <= _poolData.purchaseDuration && 30 days >= _poolData.purchaseDuration,\\n            \\\"outside purchase expiry window\\\"\\n        );\\n        require(365 days >= _poolData.duration, \\\"max 1 year duration\\\");\\n        require(_poolData.sponsorFee <= MAX_SPONSOR_FEE, \\\"exceeds max sponsor fee\\\");\\n        purchaseTokenDecimals = IERC20Decimals(_poolData.purchaseToken).decimals();\\n        require(purchaseTokenDecimals <= DEAL_TOKEN_DECIMALS, \\\"too many token decimals\\\");\\n        storedName = _poolData.name;\\n        storedSymbol = _poolData.symbol;\\n        poolFactory = msg.sender;\\n\\n        _setNameSymbolAndDecimals(\\n            string(abi.encodePacked(\\\"aePool-\\\", _poolData.name)),\\n            string(abi.encodePacked(\\\"aeP-\\\", _poolData.symbol)),\\n            purchaseTokenDecimals\\n        );\\n\\n        purchaseTokenCap = _poolData.purchaseTokenCap;\\n        purchaseToken = _poolData.purchaseToken;\\n        purchaseExpiry = block.timestamp + _poolData.purchaseDuration;\\n        poolExpiry = purchaseExpiry + _poolData.duration;\\n        sponsorFee = _poolData.sponsorFee;\\n        sponsor = _sponsor;\\n        aelinEscrowLogicAddress = _aelinEscrowLogicAddress;\\n        aelinDealLogicAddress = _aelinDealLogicAddress;\\n        aelinTreasuryAddress = _aelinTreasuryAddress;\\n\\n        address[] memory allowListAddresses = _poolData.allowListAddresses;\\n        uint256[] memory allowListAmounts = _poolData.allowListAmounts;\\n\\n        if (allowListAddresses.length > 0 || allowListAmounts.length > 0) {\\n            require(\\n                allowListAddresses.length == allowListAmounts.length,\\n                \\\"allowListAddresses and allowListAmounts arrays should have the same length\\\"\\n            );\\n            for (uint256 i; i < allowListAddresses.length; ++i) {\\n                allowList[allowListAddresses[i]] = allowListAmounts[i];\\n                emit AllowlistAddress(allowListAddresses[i], allowListAmounts[i]);\\n            }\\n            hasAllowList = true;\\n        }\\n\\n        NftCollectionRules[] memory nftCollectionRules = _poolData.nftCollectionRules;\\n\\n        if (nftCollectionRules.length > 0) {\\n            // if the first address supports punks or 721, the entire pool only supports 721 or punks\\n            if (\\n                nftCollectionRules[0].collectionAddress == CRYPTO_PUNKS ||\\n                NftCheck.supports721(nftCollectionRules[0].collectionAddress)\\n            ) {\\n                for (uint256 i; i < nftCollectionRules.length; ++i) {\\n                    require(\\n                        nftCollectionRules[i].collectionAddress == CRYPTO_PUNKS ||\\n                            NftCheck.supports721(nftCollectionRules[i].collectionAddress),\\n                        \\\"can only contain 721\\\"\\n                    );\\n                    nftCollectionDetails[nftCollectionRules[i].collectionAddress] = nftCollectionRules[i];\\n                    emit PoolWith721(\\n                        nftCollectionRules[i].collectionAddress,\\n                        nftCollectionRules[i].purchaseAmount,\\n                        nftCollectionRules[i].purchaseAmountPerToken\\n                    );\\n                }\\n                hasNftList = true;\\n            }\\n            // if the first address supports 1155, the entire pool only supports 1155\\n            else if (NftCheck.supports1155(nftCollectionRules[0].collectionAddress)) {\\n                for (uint256 i; i < nftCollectionRules.length; ++i) {\\n                    require(NftCheck.supports1155(nftCollectionRules[i].collectionAddress), \\\"can only contain 1155\\\");\\n                    nftCollectionDetails[nftCollectionRules[i].collectionAddress] = nftCollectionRules[i];\\n\\n                    for (uint256 j; j < nftCollectionRules[i].tokenIds.length; ++j) {\\n                        nftId[nftCollectionRules[i].collectionAddress][nftCollectionRules[i].tokenIds[j]] = true;\\n                    }\\n                    emit PoolWith1155(\\n                        nftCollectionRules[i].collectionAddress,\\n                        nftCollectionRules[i].purchaseAmount,\\n                        nftCollectionRules[i].purchaseAmountPerToken,\\n                        nftCollectionRules[i].tokenIds,\\n                        nftCollectionRules[i].minTokensEligible\\n                    );\\n                }\\n                hasNftList = true;\\n            } else {\\n                revert(\\\"collection is not compatible\\\");\\n            }\\n        }\\n\\n        emit SetSponsor(_sponsor);\\n    }\\n\\n    modifier dealReady() {\\n        if (holderFundingExpiry > 0) {\\n            require(!aelinDeal.depositComplete() && block.timestamp >= holderFundingExpiry, \\\"cant create new deal\\\");\\n        }\\n        _;\\n    }\\n\\n    modifier initOnce() {\\n        require(!calledInitialize, \\\"can only initialize once\\\");\\n        calledInitialize = true;\\n        _;\\n    }\\n\\n    modifier onlySponsor() {\\n        require(msg.sender == sponsor, \\\"only sponsor can access\\\");\\n        _;\\n    }\\n\\n    modifier dealFunded() {\\n        require(holderFundingExpiry > 0 && aelinDeal.depositComplete(), \\\"deal not yet funded\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev the sponsor may change addresses\\n     */\\n    function setSponsor(address _sponsor) external onlySponsor {\\n        require(_sponsor != address(0));\\n        futureSponsor = _sponsor;\\n    }\\n\\n    function acceptSponsor() external {\\n        require(msg.sender == futureSponsor, \\\"only future sponsor can access\\\");\\n        sponsor = futureSponsor;\\n        emit SetSponsor(futureSponsor);\\n    }\\n\\n    /**\\n     * @dev only the sponsor can create a deal. The deal must be funded by the holder\\n     * of the underlying deal token before a purchaser may accept the deal. If the\\n     * holder does not fund the deal before the expiry period is over then the sponsor\\n     * can create a new deal for the pool of capital by calling this method again.\\n     *\\n     * Requirements:\\n     * - The purchase expiry period must be over\\n     * - the holder funding expiry period must be from 30 minutes to 30 days\\n     * - the pro rata redemption period must be from 30 minutes to 30 days\\n     * - the purchase token total for the deal that may be accepted must be <= the funds in the pool\\n     * - if the pro rata conversion ratio (purchase token total for the deal:funds in pool)\\n     *   is 1:1 then the open redemption period must be 0,\\n     *   otherwise the open period is from 30 minutes to 30 days\\n     */\\n    function createDeal(\\n        address _underlyingDealToken,\\n        uint256 _purchaseTokenTotalForDeal,\\n        uint256 _underlyingDealTokenTotal,\\n        uint256 _vestingPeriod,\\n        uint256 _vestingCliffPeriod,\\n        uint256 _proRataRedemptionPeriod,\\n        uint256 _openRedemptionPeriod,\\n        address _holder,\\n        uint256 _holderFundingDuration\\n    ) external onlySponsor dealReady returns (address) {\\n        require(numberOfDeals < MAX_DEALS, \\\"too many deals\\\");\\n        require(_holder != address(0), \\\"cant pass null holder address\\\");\\n        require(_underlyingDealToken != address(0), \\\"cant pass null token address\\\");\\n        require(block.timestamp >= purchaseExpiry, \\\"pool still in purchase mode\\\");\\n        require(\\n            30 minutes <= _proRataRedemptionPeriod && 30 days >= _proRataRedemptionPeriod,\\n            \\\"30 mins - 30 days for prorata\\\"\\n        );\\n        require(1825 days >= _vestingCliffPeriod, \\\"max 5 year cliff\\\");\\n        require(1825 days >= _vestingPeriod, \\\"max 5 year vesting\\\");\\n        require(30 minutes <= _holderFundingDuration && 30 days >= _holderFundingDuration, \\\"30 mins - 30 days for holder\\\");\\n        require(_purchaseTokenTotalForDeal <= totalSupply(), \\\"not enough funds available\\\");\\n        proRataConversion = (_purchaseTokenTotalForDeal * 1e18) / totalSupply();\\n        if (proRataConversion == 1e18) {\\n            require(0 minutes == _openRedemptionPeriod, \\\"deal is 1:1, set open to 0\\\");\\n        } else {\\n            require(30 minutes <= _openRedemptionPeriod && 30 days >= _openRedemptionPeriod, \\\"30 mins - 30 days for open\\\");\\n        }\\n\\n        numberOfDeals += 1;\\n        poolExpiry = block.timestamp;\\n        holder = _holder;\\n        holderFundingExpiry = block.timestamp + _holderFundingDuration;\\n        purchaseTokenTotalForDeal = _purchaseTokenTotalForDeal;\\n        uint256 maxDealTotalSupply = _convertPoolToDeal(_purchaseTokenTotalForDeal, purchaseTokenDecimals);\\n\\n        address aelinDealStorageProxy = _cloneAsMinimalProxy(aelinDealLogicAddress, \\\"Could not create new deal\\\");\\n        aelinDeal = AelinDeal(aelinDealStorageProxy);\\n        IAelinDeal.DealData memory dealData = IAelinDeal.DealData(\\n            _underlyingDealToken,\\n            _underlyingDealTokenTotal,\\n            _vestingPeriod,\\n            _vestingCliffPeriod,\\n            _proRataRedemptionPeriod,\\n            _openRedemptionPeriod,\\n            _holder,\\n            maxDealTotalSupply,\\n            holderFundingExpiry\\n        );\\n\\n        aelinDeal.initialize(storedName, storedSymbol, dealData, aelinTreasuryAddress, aelinEscrowLogicAddress);\\n\\n        emit CreateDeal(\\n            string(abi.encodePacked(\\\"aeDeal-\\\", storedName)),\\n            string(abi.encodePacked(\\\"aeD-\\\", storedSymbol)),\\n            sponsor,\\n            aelinDealStorageProxy\\n        );\\n\\n        emit DealDetail(\\n            aelinDealStorageProxy,\\n            _underlyingDealToken,\\n            _purchaseTokenTotalForDeal,\\n            _underlyingDealTokenTotal,\\n            _vestingPeriod,\\n            _vestingCliffPeriod,\\n            _proRataRedemptionPeriod,\\n            _openRedemptionPeriod,\\n            _holder,\\n            _holderFundingDuration\\n        );\\n\\n        return aelinDealStorageProxy;\\n    }\\n\\n    /**\\n     * @dev the 2 methods allow a purchaser to exchange accept all or a\\n     * portion of their pool tokens for deal tokens\\n     *\\n     * Requirements:\\n     * - the redemption period is either in the pro rata or open windows\\n     * - the purchaser cannot accept more than their share for a period\\n     * - if participating in the open period, a purchaser must have maxxed their\\n     *   contribution in the pro rata phase\\n     */\\n    function acceptMaxDealTokens() external {\\n        _acceptDealTokens(msg.sender, 0, true);\\n    }\\n\\n    function acceptDealTokens(uint256 _poolTokenAmount) external {\\n        _acceptDealTokens(msg.sender, _poolTokenAmount, false);\\n    }\\n\\n    /**\\n     * @dev the if statement says if you have no balance or if the deal is not funded\\n     * or if the pro rata period is not active, then you have 0 available for this period\\n     */\\n    function maxProRataAmount(address _purchaser) public view returns (uint256) {\\n        (, uint256 proRataRedemptionStart, uint256 proRataRedemptionExpiry) = aelinDeal.proRataRedemption();\\n\\n        if (\\n            (balanceOf(_purchaser) == 0 && amountAccepted[_purchaser] == 0 && amountWithdrawn[_purchaser] == 0) ||\\n            holderFundingExpiry == 0 ||\\n            proRataRedemptionStart == 0 ||\\n            block.timestamp >= proRataRedemptionExpiry\\n        ) {\\n            return 0;\\n        }\\n        return\\n            (proRataConversion * (balanceOf(_purchaser) + amountAccepted[_purchaser] + amountWithdrawn[_purchaser])) /\\n            1e18 -\\n            amountAccepted[_purchaser];\\n    }\\n\\n    function _maxOpenAvail(address _purchaser) internal view returns (uint256) {\\n        return\\n            balanceOf(_purchaser) + totalAmountAccepted <= purchaseTokenTotalForDeal\\n                ? balanceOf(_purchaser)\\n                : purchaseTokenTotalForDeal - totalAmountAccepted;\\n    }\\n\\n    function _acceptDealTokens(\\n        address _recipient,\\n        uint256 _poolTokenAmount,\\n        bool _useMax\\n    ) internal dealFunded lock {\\n        (, uint256 proRataRedemptionStart, uint256 proRataRedemptionExpiry) = aelinDeal.proRataRedemption();\\n        (, uint256 openRedemptionStart, uint256 openRedemptionExpiry) = aelinDeal.openRedemption();\\n\\n        if (block.timestamp >= proRataRedemptionStart && block.timestamp < proRataRedemptionExpiry) {\\n            _acceptDealTokensProRata(_recipient, _poolTokenAmount, _useMax);\\n        } else if (openRedemptionStart > 0 && block.timestamp < openRedemptionExpiry) {\\n            _acceptDealTokensOpen(_recipient, _poolTokenAmount, _useMax);\\n        } else {\\n            revert(\\\"outside of redeem window\\\");\\n        }\\n    }\\n\\n    function _acceptDealTokensProRata(\\n        address _recipient,\\n        uint256 _poolTokenAmount,\\n        bool _useMax\\n    ) internal {\\n        uint256 maxProRata = maxProRataAmount(_recipient);\\n        uint256 maxAccept = maxProRata > balanceOf(_recipient) ? balanceOf(_recipient) : maxProRata;\\n        if (!_useMax) {\\n            require(\\n                _poolTokenAmount <= maxProRata && balanceOf(_recipient) >= _poolTokenAmount,\\n                \\\"accepting more than share\\\"\\n            );\\n        }\\n        uint256 acceptAmount = _useMax ? maxAccept : _poolTokenAmount;\\n        amountAccepted[_recipient] += acceptAmount;\\n        totalAmountAccepted += acceptAmount;\\n        _mintDealTokens(_recipient, acceptAmount);\\n        if (proRataConversion != 1e18 && maxProRataAmount(_recipient) == 0) {\\n            openPeriodEligible[_recipient] = true;\\n        }\\n    }\\n\\n    function _acceptDealTokensOpen(\\n        address _recipient,\\n        uint256 _poolTokenAmount,\\n        bool _useMax\\n    ) internal {\\n        require(openPeriodEligible[_recipient], \\\"ineligible: didn't max pro rata\\\");\\n        uint256 maxOpen = _maxOpenAvail(_recipient);\\n        require(maxOpen > 0, \\\"nothing left to accept\\\");\\n        uint256 acceptAmount = _useMax ? maxOpen : _poolTokenAmount;\\n        if (!_useMax) {\\n            require(acceptAmount <= maxOpen, \\\"accepting more than share\\\");\\n        }\\n        totalAmountAccepted += acceptAmount;\\n        amountAccepted[_recipient] += acceptAmount;\\n        _mintDealTokens(_recipient, acceptAmount);\\n    }\\n\\n    /**\\n     * @dev the holder will receive less purchase tokens than the amount\\n     * transferred if the purchase token burns or takes a fee during transfer\\n     */\\n    function _mintDealTokens(address _recipient, uint256 _poolTokenAmount) internal {\\n        _burn(_recipient, _poolTokenAmount);\\n        uint256 poolTokenDealFormatted = _convertPoolToDeal(_poolTokenAmount, purchaseTokenDecimals);\\n        uint256 aelinFeeAmt = (poolTokenDealFormatted * AELIN_FEE) / BASE;\\n        uint256 sponsorFeeAmt = (poolTokenDealFormatted * sponsorFee) / BASE;\\n\\n        aelinDeal.mint(sponsor, sponsorFeeAmt);\\n        aelinDeal.protocolMint(aelinFeeAmt);\\n        aelinDeal.mint(_recipient, poolTokenDealFormatted - (sponsorFeeAmt + aelinFeeAmt));\\n        IERC20(purchaseToken).safeTransfer(holder, _poolTokenAmount);\\n        emit AcceptDeal(_recipient, address(aelinDeal), _poolTokenAmount, sponsorFeeAmt, aelinFeeAmt);\\n    }\\n\\n    /**\\n     * @dev allows anyone to become a purchaser by sending purchase tokens\\n     * in exchange for pool tokens\\n     *\\n     * Requirements:\\n     * - the deal is in the purchase expiry window\\n     * - the cap has not been exceeded\\n     */\\n    function purchasePoolTokens(uint256 _purchaseTokenAmount) external lock {\\n        require(block.timestamp < purchaseExpiry, \\\"not in purchase window\\\");\\n        require(!hasNftList, \\\"has NFT list\\\");\\n        if (hasAllowList) {\\n            require(_purchaseTokenAmount <= allowList[msg.sender], \\\"more than allocation\\\");\\n            allowList[msg.sender] -= _purchaseTokenAmount;\\n        }\\n        uint256 currentBalance = IERC20(purchaseToken).balanceOf(address(this));\\n        IERC20(purchaseToken).safeTransferFrom(msg.sender, address(this), _purchaseTokenAmount);\\n        uint256 balanceAfterTransfer = IERC20(purchaseToken).balanceOf(address(this));\\n        uint256 purchaseTokenAmount = balanceAfterTransfer - currentBalance;\\n        if (purchaseTokenCap > 0) {\\n            uint256 totalPoolAfter = totalSupply() + purchaseTokenAmount;\\n            require(totalPoolAfter <= purchaseTokenCap, \\\"cap has been exceeded\\\");\\n            if (totalPoolAfter == purchaseTokenCap) {\\n                purchaseExpiry = block.timestamp;\\n            }\\n        }\\n\\n        _mint(msg.sender, purchaseTokenAmount);\\n        emit PurchasePoolToken(msg.sender, purchaseTokenAmount);\\n    }\\n\\n    /**\\n     * @dev allows anyone to become a purchaser with a qualified erc721\\n     * nft in the pool depending on the scenarios\\n     *\\n     * Scenarios:\\n     * 1. each wallet holding a qualified NFT to deposit an unlimited amount of purchase tokens\\n     * 2. certain amount of purchase tokens per wallet regardless of the number of qualified NFTs held\\n     * 3. certain amount of Investment tokens per qualified NFT held\\n     */\\n\\n    function purchasePoolTokensWithNft(NftPurchaseList[] calldata _nftPurchaseList, uint256 _purchaseTokenAmount)\\n        external\\n        lock\\n    {\\n        require(hasNftList, \\\"pool does not have an NFT list\\\");\\n        require(block.timestamp < purchaseExpiry, \\\"not in purchase window\\\");\\n\\n        uint256 maxPurchaseTokenAmount;\\n\\n        for (uint256 i; i < _nftPurchaseList.length; ++i) {\\n            NftPurchaseList memory nftPurchaseList = _nftPurchaseList[i];\\n            address collectionAddress = nftPurchaseList.collectionAddress;\\n            uint256[] memory tokenIds = nftPurchaseList.tokenIds;\\n\\n            NftCollectionRules memory nftCollectionRules = nftCollectionDetails[collectionAddress];\\n            require(nftCollectionRules.collectionAddress == collectionAddress, \\\"collection not in the pool\\\");\\n\\n            if (nftCollectionRules.purchaseAmountPerToken) {\\n                maxPurchaseTokenAmount += nftCollectionRules.purchaseAmount * tokenIds.length;\\n            }\\n\\n            if (!nftCollectionRules.purchaseAmountPerToken && nftCollectionRules.purchaseAmount > 0) {\\n                require(!nftWalletUsedForPurchase[collectionAddress][msg.sender], \\\"wallet already used for nft set\\\");\\n                nftWalletUsedForPurchase[collectionAddress][msg.sender] = true;\\n                maxPurchaseTokenAmount += nftCollectionRules.purchaseAmount;\\n            }\\n\\n            if (nftCollectionRules.purchaseAmount == 0) {\\n                maxPurchaseTokenAmount = _purchaseTokenAmount;\\n            }\\n\\n            if (NftCheck.supports721(collectionAddress)) {\\n                _blackListCheck721(collectionAddress, tokenIds);\\n            }\\n            if (NftCheck.supports1155(collectionAddress)) {\\n                _eligibilityCheck1155(collectionAddress, tokenIds, nftCollectionRules);\\n            }\\n            if (collectionAddress == CRYPTO_PUNKS) {\\n                _blackListCheckPunks(collectionAddress, tokenIds);\\n            }\\n        }\\n\\n        require(_purchaseTokenAmount <= maxPurchaseTokenAmount, \\\"purchase amount should be less the max allocation\\\");\\n\\n        uint256 amountBefore = IERC20(purchaseToken).balanceOf(address(this));\\n        IERC20(purchaseToken).safeTransferFrom(msg.sender, address(this), _purchaseTokenAmount);\\n        uint256 amountAfter = IERC20(purchaseToken).balanceOf(address(this));\\n        uint256 purchaseTokenAmount = amountAfter - amountBefore;\\n\\n        if (purchaseTokenCap > 0) {\\n            uint256 totalPoolAfter = totalSupply() + purchaseTokenAmount;\\n            require(totalPoolAfter <= purchaseTokenCap, \\\"cap has been exceeded\\\");\\n            if (totalPoolAfter == purchaseTokenCap) {\\n                purchaseExpiry = block.timestamp;\\n            }\\n        }\\n\\n        _mint(msg.sender, purchaseTokenAmount);\\n        emit PurchasePoolToken(msg.sender, purchaseTokenAmount);\\n    }\\n\\n    function _blackListCheck721(address _collectionAddress, uint256[] memory _tokenIds) internal {\\n        for (uint256 i; i < _tokenIds.length; ++i) {\\n            require(IERC721(_collectionAddress).ownerOf(_tokenIds[i]) == msg.sender, \\\"has to be the token owner\\\");\\n            require(!nftId[_collectionAddress][_tokenIds[i]], \\\"tokenId already used\\\");\\n            nftId[_collectionAddress][_tokenIds[i]] = true;\\n            emit BlacklistNFT(_collectionAddress, _tokenIds[i]);\\n        }\\n    }\\n\\n    function _eligibilityCheck1155(\\n        address _collectionAddress,\\n        uint256[] memory _tokenIds,\\n        NftCollectionRules memory _nftCollectionRules\\n    ) internal view {\\n        for (uint256 i; i < _tokenIds.length; ++i) {\\n            require(nftId[_collectionAddress][_tokenIds[i]], \\\"tokenId not in the pool\\\");\\n            require(\\n                IERC1155(_collectionAddress).balanceOf(msg.sender, _tokenIds[i]) >= _nftCollectionRules.minTokensEligible[i],\\n                \\\"erc1155 balance too low\\\"\\n            );\\n        }\\n    }\\n\\n    function _blackListCheckPunks(address _punksAddress, uint256[] memory _tokenIds) internal {\\n        for (uint256 i; i < _tokenIds.length; ++i) {\\n            require(ICryptoPunks(_punksAddress).punkIndexToAddress(_tokenIds[i]) == msg.sender, \\\"not the owner\\\");\\n            require(!nftId[_punksAddress][_tokenIds[i]], \\\"tokenId already used\\\");\\n            nftId[_punksAddress][_tokenIds[i]] = true;\\n            emit BlacklistNFT(_punksAddress, _tokenIds[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev the withdraw and partial withdraw methods allow a purchaser to take their\\n     * purchase tokens back in exchange for pool tokens if they do not accept a deal\\n     *\\n     * Requirements:\\n     * - the pool has expired either due to the creation of a deal or the end of the duration\\n     */\\n    function withdrawMaxFromPool() external {\\n        _withdraw(balanceOf(msg.sender));\\n    }\\n\\n    function withdrawFromPool(uint256 _purchaseTokenAmount) external {\\n        _withdraw(_purchaseTokenAmount);\\n    }\\n\\n    /**\\n     * @dev purchasers can withdraw at the end of the pool expiry period if\\n     * no deal was presented or they can withdraw after the holder funding period\\n     * if they do not like a deal\\n     */\\n    function _withdraw(uint256 _purchaseTokenAmount) internal {\\n        require(_purchaseTokenAmount <= balanceOf(msg.sender), \\\"input larger than balance\\\");\\n        require(block.timestamp >= poolExpiry, \\\"not yet withdraw period\\\");\\n        if (holderFundingExpiry > 0) {\\n            require(block.timestamp > holderFundingExpiry || aelinDeal.depositComplete(), \\\"cant withdraw in funding period\\\");\\n        }\\n        amountWithdrawn[msg.sender] += _purchaseTokenAmount;\\n        totalAmountWithdrawn += _purchaseTokenAmount;\\n        _burn(msg.sender, _purchaseTokenAmount);\\n        IERC20(purchaseToken).safeTransfer(msg.sender, _purchaseTokenAmount);\\n        emit WithdrawFromPool(msg.sender, _purchaseTokenAmount);\\n    }\\n\\n    /**\\n     * @dev view to see how much of the deal a purchaser can accept.\\n     */\\n    function maxDealAccept(address _purchaser) external view returns (uint256) {\\n        /**\\n         * The if statement is checking to see if the holder has not funded the deal\\n         * or if the period is outside of a redemption window so nothing is available.\\n         * It then checks if you are in the pro rata period and open period eligibility\\n         */\\n\\n        (, uint256 proRataRedemptionStart, uint256 proRataRedemptionExpiry) = aelinDeal.proRataRedemption();\\n        (, uint256 openRedemptionStart, uint256 openRedemptionExpiry) = aelinDeal.openRedemption();\\n\\n        if (\\n            holderFundingExpiry == 0 ||\\n            proRataRedemptionStart == 0 ||\\n            (block.timestamp >= proRataRedemptionExpiry && openRedemptionStart == 0) ||\\n            (block.timestamp >= openRedemptionExpiry && openRedemptionStart != 0)\\n        ) {\\n            return 0;\\n        } else if (block.timestamp < proRataRedemptionExpiry) {\\n            uint256 maxProRata = maxProRataAmount(_purchaser);\\n            return maxProRata > balanceOf(_purchaser) ? balanceOf(_purchaser) : maxProRata;\\n        } else if (!openPeriodEligible[_purchaser]) {\\n            return 0;\\n        } else {\\n            return _maxOpenAvail(_purchaser);\\n        }\\n    }\\n\\n    modifier transferWindow() {\\n        (, uint256 proRataRedemptionStart, uint256 proRataRedemptionExpiry) = aelinDeal.proRataRedemption();\\n        (, uint256 openRedemptionStart, uint256 openRedemptionExpiry) = aelinDeal.openRedemption();\\n\\n        require(\\n            proRataRedemptionStart == 0 ||\\n                (block.timestamp >= proRataRedemptionExpiry && openRedemptionStart == 0) ||\\n                (block.timestamp >= openRedemptionExpiry && openRedemptionStart != 0),\\n            \\\"no transfers in redeem window\\\"\\n        );\\n        _;\\n    }\\n\\n    function transfer(address _dst, uint256 _amount) public virtual override transferWindow returns (bool) {\\n        return super.transfer(_dst, _amount);\\n    }\\n\\n    function transferFrom(\\n        address _src,\\n        address _dst,\\n        uint256 _amount\\n    ) public virtual override transferWindow returns (bool) {\\n        return super.transferFrom(_src, _dst, _amount);\\n    }\\n\\n    /**\\n     * @dev convert pool with varying decimals to deal tokens of 18 decimals\\n     * NOTE that a purchase token must not be greater than 18 decimals\\n     */\\n    function _convertPoolToDeal(uint256 _poolTokenAmount, uint256 _poolTokenDecimals) internal pure returns (uint256) {\\n        return _poolTokenAmount * 10**(18 - _poolTokenDecimals);\\n    }\\n\\n    /**\\n     * @dev a function that any Ethereum address can call to vouch for a pool's legitimacy\\n     */\\n    function vouch() external {\\n        emit Vouch(msg.sender);\\n    }\\n\\n    /**\\n     * @dev a function that any Ethereum address can call to disavow for a pool's legitimacy\\n     */\\n    function disavow() external {\\n        emit Disavow(msg.sender);\\n    }\\n\\n    event SetSponsor(address indexed sponsor);\\n    event PurchasePoolToken(address indexed purchaser, uint256 purchaseTokenAmount);\\n    event WithdrawFromPool(address indexed purchaser, uint256 purchaseTokenAmount);\\n    event AcceptDeal(\\n        address indexed purchaser,\\n        address indexed dealAddress,\\n        uint256 poolTokenAmount,\\n        uint256 sponsorFee,\\n        uint256 aelinFee\\n    );\\n    event CreateDeal(string name, string symbol, address indexed sponsor, address indexed dealContract);\\n    event DealDetail(\\n        address indexed dealContract,\\n        address indexed underlyingDealToken,\\n        uint256 purchaseTokenTotalForDeal,\\n        uint256 underlyingDealTokenTotal,\\n        uint256 vestingPeriod,\\n        uint256 vestingCliff,\\n        uint256 proRataRedemptionPeriod,\\n        uint256 openRedemptionPeriod,\\n        address indexed holder,\\n        uint256 holderFundingDuration\\n    );\\n    event AllowlistAddress(address indexed purchaser, uint256 allowlistAmount);\\n    event PoolWith721(address indexed collectionAddress, uint256 purchaseAmount, bool purchaseAmountPerToken);\\n    event PoolWith1155(\\n        address indexed collectionAddress,\\n        uint256 purchaseAmount,\\n        bool purchaseAmountPerToken,\\n        uint256[] tokenIds,\\n        uint256[] minTokensEligible\\n    );\\n    event Vouch(address indexed voucher);\\n    event Disavow(address indexed voucher);\\n    event BlacklistNFT(address indexed collection, uint256 nftID);\\n}\\n\"\r\n    },\r\n    \"contracts/AelinFeeEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ncontract AelinFeeEscrow {\\n    using SafeERC20 for IERC20;\\n    uint256 public vestingExpiry;\\n    address public treasury;\\n    address public futureTreasury;\\n    address public escrowedToken;\\n\\n    bool private calledInitialize;\\n\\n    /**\\n     * @dev the constructor will always be blank due to the MinimalProxyFactory pattern\\n     * this allows the underlying logic of this contract to only be deployed once\\n     * and each new escrow created is simply a storage wrapper\\n     */\\n    constructor() {}\\n\\n    /**\\n     * @dev the treasury may change their address\\n     */\\n    function setTreasury(address _treasury) external onlyTreasury {\\n        require(_treasury != address(0));\\n        futureTreasury = _treasury;\\n    }\\n\\n    function acceptTreasury() external {\\n        require(msg.sender == futureTreasury, \\\"only future treasury can access\\\");\\n        treasury = futureTreasury;\\n        emit SetTreasury(futureTreasury);\\n    }\\n\\n    function initialize(address _treasury, address _escrowedToken) external initOnce {\\n        treasury = _treasury;\\n        vestingExpiry = block.timestamp + 180 days;\\n        escrowedToken = _escrowedToken;\\n        emit InitializeEscrow(msg.sender, _treasury, vestingExpiry, escrowedToken);\\n    }\\n\\n    modifier initOnce() {\\n        require(!calledInitialize, \\\"can only initialize once\\\");\\n        calledInitialize = true;\\n        _;\\n    }\\n\\n    modifier onlyTreasury() {\\n        require(msg.sender == treasury, \\\"only treasury can access\\\");\\n        _;\\n    }\\n\\n    function delayEscrow() external onlyTreasury {\\n        require(vestingExpiry < block.timestamp + 90 days, \\\"can only extend by 90 days\\\");\\n        vestingExpiry = block.timestamp + 90 days;\\n        emit DelayEscrow(vestingExpiry);\\n    }\\n\\n    /**\\n     * @dev transfer all the escrow tokens to the treasury\\n     */\\n    function withdrawToken() external onlyTreasury {\\n        require(block.timestamp > vestingExpiry, \\\"cannot access funds yet\\\");\\n        uint256 balance = IERC20(escrowedToken).balanceOf(address(this));\\n        IERC20(escrowedToken).safeTransfer(treasury, balance);\\n    }\\n\\n    event SetTreasury(address indexed treasury);\\n    event InitializeEscrow(\\n        address indexed dealAddress,\\n        address indexed treasury,\\n        uint256 vestingExpiry,\\n        address indexed escrowedToken\\n    );\\n    event DelayEscrow(uint256 vestingExpiry);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAelinUpFrontDeal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport {IAelinPool} from \\\"./IAelinPool.sol\\\";\\n\\ninterface IAelinUpFrontDeal {\\n    struct UpFrontDealData {\\n        string name;\\n        string symbol;\\n        address purchaseToken;\\n        address underlyingDealToken;\\n        address holder;\\n        address sponsor;\\n        uint256 sponsorFee;\\n        bytes32 merkleRoot;\\n        string ipfsHash;\\n    }\\n\\n    struct UpFrontDealConfig {\\n        uint256 underlyingDealTokenTotal;\\n        uint256 purchaseTokenPerDealToken;\\n        uint256 purchaseRaiseMinimum;\\n        uint256 purchaseDuration;\\n        uint256 vestingPeriod;\\n        uint256 vestingCliffPeriod;\\n        bool allowDeallocation;\\n    }\\n\\n    event CreateUpFrontDeal(\\n        address indexed dealAddress,\\n        string name,\\n        string symbol,\\n        address purchaseToken,\\n        address underlyingDealToken,\\n        address indexed holder,\\n        address indexed sponsor,\\n        uint256 sponsorFee,\\n        bytes32 merkleRoot,\\n        string ipfsHash\\n    );\\n\\n    event CreateUpFrontDealConfig(\\n        address indexed dealAddress,\\n        uint256 underlyingDealTokenTotal,\\n        uint256 purchaseTokenPerDealToken,\\n        uint256 purchaseRaiseMinimum,\\n        uint256 purchaseDuration,\\n        uint256 vestingPeriod,\\n        uint256 vestingCliffPeriod,\\n        bool allowDeallocation\\n    );\\n\\n    event DepositDealToken(\\n        address indexed underlyingDealTokenAddress,\\n        address indexed depositor,\\n        uint256 underlyingDealTokenAmount\\n    );\\n\\n    event DealFullyFunded(\\n        address upFrontDealAddress,\\n        uint256 timestamp,\\n        uint256 purchaseExpiryTimestamp,\\n        uint256 vestingCliffExpiryTimestamp,\\n        uint256 vestingExpiryTimestamp\\n    );\\n\\n    event WithdrewExcess(address UpFrontDealAddress, uint256 amountWithdrawn);\\n\\n    event AcceptDeal(\\n        address indexed user,\\n        uint256 amountPurchased,\\n        uint256 totalPurchased,\\n        uint256 amountDealTokens,\\n        uint256 totalDealTokens\\n    );\\n\\n    event ClaimDealTokens(address indexed user, uint256 amountMinted, uint256 amountPurchasingReturned);\\n\\n    event SponsorClaim(address indexed sponsor, uint256 amountMinted);\\n\\n    event HolderClaim(\\n        address indexed holder,\\n        address purchaseToken,\\n        uint256 amountClaimed,\\n        address underlyingToken,\\n        uint256 underlyingRefund,\\n        uint256 timestamp\\n    );\\n\\n    event FeeEscrowClaim(address indexed aelinFeeEscrow, address indexed underlyingTokenAddress, uint256 amount);\\n\\n    event ClaimedUnderlyingDealToken(address indexed user, address underlyingToken, uint256 amountClaimed);\\n\\n    event PoolWith721(address indexed collectionAddress, uint256 purchaseAmount, bool purchaseAmountPerToken);\\n\\n    event PoolWith1155(\\n        address indexed collectionAddress,\\n        uint256 purchaseAmount,\\n        bool purchaseAmountPerToken,\\n        uint256[] tokenIds,\\n        uint256[] minTokensEligible\\n    );\\n\\n    event SetHolder(address indexed holder);\\n\\n    event Vouch(address indexed voucher);\\n\\n    event Disavow(address indexed voucher);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AelinNftGating.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./NftCheck.sol\\\";\\nimport \\\"../interfaces/ICryptoPunks.sol\\\";\\n\\nlibrary AelinNftGating {\\n    address constant CRYPTO_PUNKS = address(0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB);\\n\\n    // collectionAddress should be unique, otherwise will override\\n    struct NftCollectionRules {\\n        // if 0, then unlimited purchase\\n        uint256 purchaseAmount;\\n        address collectionAddress;\\n        // if true, then `purchaseAmount` is per token\\n        // else `purchaseAmount` is per account regardless of the NFTs held\\n        bool purchaseAmountPerToken;\\n        // both variables below are only applicable for 1155\\n        uint256[] tokenIds;\\n        // min number of tokens required for participating\\n        uint256[] minTokensEligible;\\n    }\\n\\n    struct NftGatingData {\\n        mapping(address => NftCollectionRules) nftCollectionDetails;\\n        mapping(address => mapping(address => bool)) nftWalletUsedForPurchase;\\n        mapping(address => mapping(uint256 => bool)) nftId;\\n        bool hasNftList;\\n    }\\n\\n    struct NftPurchaseList {\\n        address collectionAddress;\\n        uint256[] tokenIds;\\n    }\\n\\n    /**\\n     * @dev check if deal is nft gated, sets hasNftList\\n     * if yes, move collection rule array input to mapping in the data storage\\n     * @param _nftCollectionRules array of all nft collection rule data\\n     * @param _data contract storage data passed by reference\\n     */\\n    function initialize(NftCollectionRules[] calldata _nftCollectionRules, NftGatingData storage _data) external {\\n        if (_nftCollectionRules.length > 0) {\\n            // if the first address supports punks or 721, the entire pool only supports 721 or punks\\n            if (\\n                _nftCollectionRules[0].collectionAddress == CRYPTO_PUNKS ||\\n                NftCheck.supports721(_nftCollectionRules[0].collectionAddress)\\n            ) {\\n                for (uint256 i; i < _nftCollectionRules.length; ++i) {\\n                    require(\\n                        _nftCollectionRules[i].collectionAddress == CRYPTO_PUNKS ||\\n                            NftCheck.supports721(_nftCollectionRules[i].collectionAddress),\\n                        \\\"can only contain 721\\\"\\n                    );\\n                    _data.nftCollectionDetails[_nftCollectionRules[i].collectionAddress] = _nftCollectionRules[i];\\n                    emit PoolWith721(\\n                        _nftCollectionRules[i].collectionAddress,\\n                        _nftCollectionRules[i].purchaseAmount,\\n                        _nftCollectionRules[i].purchaseAmountPerToken\\n                    );\\n                }\\n                _data.hasNftList = true;\\n            }\\n            // if the first address supports 1155, the entire pool only supports 1155\\n            else if (NftCheck.supports1155(_nftCollectionRules[0].collectionAddress)) {\\n                for (uint256 i; i < _nftCollectionRules.length; ++i) {\\n                    require(NftCheck.supports1155(_nftCollectionRules[i].collectionAddress), \\\"can only contain 1155\\\");\\n                    _data.nftCollectionDetails[_nftCollectionRules[i].collectionAddress] = _nftCollectionRules[i];\\n\\n                    for (uint256 j; j < _nftCollectionRules[i].tokenIds.length; ++j) {\\n                        _data.nftId[_nftCollectionRules[i].collectionAddress][_nftCollectionRules[i].tokenIds[j]] = true;\\n                    }\\n                    emit PoolWith1155(\\n                        _nftCollectionRules[i].collectionAddress,\\n                        _nftCollectionRules[i].purchaseAmount,\\n                        _nftCollectionRules[i].purchaseAmountPerToken,\\n                        _nftCollectionRules[i].tokenIds,\\n                        _nftCollectionRules[i].minTokensEligible\\n                    );\\n                }\\n                _data.hasNftList = true;\\n            } else {\\n                require(false, \\\"collection is not compatible\\\");\\n            }\\n        } else {\\n            _data.hasNftList = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev allows anyone to become a purchaser with a qualified erc721\\n     * nft in the pool depending on the scenarios\\n     *\\n     * Scenarios:\\n     * 1. each wallet holding a qualified NFT to deposit an unlimited amount of purchase tokens\\n     * 2. certain amount of purchase tokens per wallet regardless of the number of qualified NFTs held\\n     * 3. certain amount of Investment tokens per qualified NFT held\\n     * @param _nftPurchaseList nft collection address and token ids to use for purchase\\n     * @param _data contract storage data for nft gating passed by reference\\n     * @param _purchaseTokenAmount amount to purchase with, must not exceed max allowable from collection rules\\n     * @return uint256 max purchase token amount allowable\\n     */\\n    function purchaseDealTokensWithNft(\\n        NftPurchaseList[] calldata _nftPurchaseList,\\n        NftGatingData storage _data,\\n        uint256 _purchaseTokenAmount\\n    ) external returns (uint256) {\\n        require(_data.hasNftList, \\\"pool does not have an NFT list\\\");\\n        require(_nftPurchaseList.length > 0, \\\"must provide purchase list\\\");\\n\\n        uint256 maxPurchaseTokenAmount;\\n\\n        for (uint256 i; i < _nftPurchaseList.length; ++i) {\\n            NftPurchaseList memory nftPurchaseList = _nftPurchaseList[i];\\n            address _collectionAddress = nftPurchaseList.collectionAddress;\\n            uint256[] memory _tokenIds = nftPurchaseList.tokenIds;\\n\\n            NftCollectionRules memory nftCollectionRules = _data.nftCollectionDetails[_collectionAddress];\\n            require(nftCollectionRules.collectionAddress == _collectionAddress, \\\"collection not in the pool\\\");\\n\\n            if (nftCollectionRules.purchaseAmountPerToken && nftCollectionRules.purchaseAmount > 0) {\\n                if (NftCheck.supports1155(_collectionAddress)) {\\n                    for (uint256 j; j < _tokenIds.length; ++j) {\\n                        unchecked {\\n                            uint256 collectionAllowance = nftCollectionRules.purchaseAmount *\\n                                IERC1155(_collectionAddress).balanceOf(msg.sender, _tokenIds[j]);\\n                            // if there is an overflow of the pervious calculation, allow the max purchase token amount\\n                            if (\\n                                collectionAllowance / nftCollectionRules.purchaseAmount !=\\n                                IERC1155(_collectionAddress).balanceOf(msg.sender, _tokenIds[j])\\n                            ) {\\n                                maxPurchaseTokenAmount = type(uint256).max;\\n                            } else {\\n                                maxPurchaseTokenAmount += collectionAllowance;\\n                                if (maxPurchaseTokenAmount < collectionAllowance) {\\n                                    maxPurchaseTokenAmount = type(uint256).max;\\n                                }\\n                            }\\n                        }\\n                    }\\n                } else {\\n                    unchecked {\\n                        uint256 collectionAllowance = nftCollectionRules.purchaseAmount * _tokenIds.length;\\n                        // if there is an overflow of the pervious calculation, allow the max purchase token amount\\n                        if (collectionAllowance / nftCollectionRules.purchaseAmount != _tokenIds.length) {\\n                            maxPurchaseTokenAmount = type(uint256).max;\\n                        } else {\\n                            maxPurchaseTokenAmount += collectionAllowance;\\n                            if (maxPurchaseTokenAmount < collectionAllowance) {\\n                                maxPurchaseTokenAmount = type(uint256).max;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            if (!nftCollectionRules.purchaseAmountPerToken && nftCollectionRules.purchaseAmount > 0) {\\n                require(!_data.nftWalletUsedForPurchase[_collectionAddress][msg.sender], \\\"wallet already used for nft set\\\");\\n                _data.nftWalletUsedForPurchase[_collectionAddress][msg.sender] = true;\\n                unchecked {\\n                    maxPurchaseTokenAmount += nftCollectionRules.purchaseAmount;\\n                    // if addition causes overflow the max allowance is max value of uint256\\n                    if (maxPurchaseTokenAmount < nftCollectionRules.purchaseAmount) {\\n                        maxPurchaseTokenAmount = type(uint256).max;\\n                    }\\n                }\\n            }\\n\\n            if (nftCollectionRules.purchaseAmount == 0) {\\n                maxPurchaseTokenAmount = type(uint256).max;\\n            }\\n\\n            if (NftCheck.supports721(_collectionAddress)) {\\n                for (uint256 j; j < _tokenIds.length; ++j) {\\n                    require(IERC721(_collectionAddress).ownerOf(_tokenIds[j]) == msg.sender, \\\"has to be the token owner\\\");\\n                    require(!_data.nftId[_collectionAddress][_tokenIds[j]], \\\"tokenId already used\\\");\\n                    _data.nftId[_collectionAddress][_tokenIds[j]] = true;\\n                    emit BlacklistNFT(_collectionAddress, _tokenIds[j]);\\n                }\\n            }\\n            if (NftCheck.supports1155(_collectionAddress)) {\\n                for (uint256 j; j < _tokenIds.length; ++j) {\\n                    require(_data.nftId[_collectionAddress][_tokenIds[j]], \\\"tokenId not in the pool\\\");\\n                    require(\\n                        IERC1155(_collectionAddress).balanceOf(msg.sender, _tokenIds[j]) >=\\n                            nftCollectionRules.minTokensEligible[j],\\n                        \\\"erc1155 balance too low\\\"\\n                    );\\n                }\\n            }\\n            if (_collectionAddress == CRYPTO_PUNKS) {\\n                for (uint256 j; j < _tokenIds.length; ++j) {\\n                    require(\\n                        ICryptoPunks(_collectionAddress).punkIndexToAddress(_tokenIds[j]) == msg.sender,\\n                        \\\"not the owner\\\"\\n                    );\\n                    require(!_data.nftId[_collectionAddress][_tokenIds[j]], \\\"tokenId already used\\\");\\n                    _data.nftId[_collectionAddress][_tokenIds[j]] = true;\\n                    emit BlacklistNFT(_collectionAddress, _tokenIds[j]);\\n                }\\n            }\\n        }\\n\\n        require(_purchaseTokenAmount <= maxPurchaseTokenAmount, \\\"purchase amount greater than max allocation\\\");\\n\\n        return (maxPurchaseTokenAmount);\\n    }\\n\\n    event PoolWith721(address indexed collectionAddress, uint256 purchaseAmount, bool purchaseAmountPerToken);\\n\\n    event PoolWith1155(\\n        address indexed collectionAddress,\\n        uint256 purchaseAmount,\\n        bool purchaseAmountPerToken,\\n        uint256[] tokenIds,\\n        uint256[] minTokensEligible\\n    );\\n    event BlacklistNFT(address indexed collection, uint256 nftID);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AelinAllowList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nlibrary AelinAllowList {\\n    struct InitData {\\n        address[] allowListAddresses;\\n        uint256[] allowListAmounts;\\n    }\\n\\n    struct AllowList {\\n        address[] allowListAddresses;\\n        uint256[] allowListAmounts;\\n        mapping(address => uint256) amountPerAddress;\\n        bool hasAllowList;\\n    }\\n\\n    function initialize(InitData calldata _init, AllowList storage _self) external {\\n        if (_init.allowListAddresses.length > 0 || _init.allowListAmounts.length > 0) {\\n            require(\\n                _init.allowListAddresses.length == _init.allowListAmounts.length,\\n                \\\"allowListAddresses and allowListAmounts arrays should have the same length\\\"\\n            );\\n            _self.allowListAddresses = _init.allowListAddresses;\\n            _self.allowListAmounts = _init.allowListAmounts;\\n            for (uint256 i; i < _init.allowListAddresses.length; ++i) {\\n                _self.amountPerAddress[_init.allowListAddresses[i]] = _init.allowListAmounts[i];\\n            }\\n            _self.hasAllowList = true;\\n            emit AllowlistAddress(_init.allowListAddresses, _init.allowListAmounts);\\n        }\\n    }\\n\\n    event AllowlistAddress(address[] indexed allowListAddresses, uint256[] allowlistAmounts);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MerkleTree.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\nlibrary MerkleTree {\\n    struct UpFrontMerkleData {\\n        uint256 index;\\n        address account;\\n        uint256 amount;\\n        bytes32[] merkleProof;\\n    }\\n\\n    struct TrackClaimed {\\n        mapping(uint256 => uint256) claimedBitMap;\\n    }\\n\\n    /**\\n     * @dev a function that checks if the index leaf node is valid and if the user has purchased.\\n     * will set the index node to purchased if approved\\n     */\\n    function purchaseMerkleAmount(\\n        UpFrontMerkleData calldata merkleData,\\n        TrackClaimed storage self,\\n        uint256 _purchaseTokenAmount,\\n        bytes32 merkleRoot\\n    ) external {\\n        require(!hasPurchasedMerkle(self, merkleData.index), \\\"Already purchased tokens\\\");\\n        require(msg.sender == merkleData.account, \\\"cant purchase others tokens\\\");\\n        require(merkleData.amount >= _purchaseTokenAmount, \\\"purchasing more than allowance\\\");\\n\\n        // Verify the merkle proof.\\n        bytes32 node = keccak256(abi.encodePacked(merkleData.index, merkleData.account, merkleData.amount));\\n        require(MerkleProof.verify(merkleData.merkleProof, merkleRoot, node), \\\"MerkleTree.sol: Invalid proof.\\\");\\n\\n        // Mark it claimed and send the token.\\n        _setPurchased(self, merkleData.index);\\n    }\\n\\n    /**\\n     * @dev sets the claimedBitMap to true for that index\\n     */\\n    function _setPurchased(TrackClaimed storage self, uint256 _index) private {\\n        uint256 claimedWordIndex = _index / 256;\\n        uint256 claimedBitIndex = _index % 256;\\n        self.claimedBitMap[claimedWordIndex] = self.claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\\n    }\\n\\n    /**\\n     * @dev returns if address has purchased merkle\\n     * @return bool index of the leaf node has purchased or not\\n     */\\n    function hasPurchasedMerkle(TrackClaimed storage self, uint256 _index) public view returns (bool) {\\n        uint256 claimedWordIndex = _index / 256;\\n        uint256 claimedBitIndex = _index % 256;\\n        uint256 claimedWord = self.claimedBitMap[claimedWordIndex];\\n        uint256 mask = (1 << claimedBitIndex);\\n        return claimedWord & mask == mask;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAelinDeal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\ninterface IAelinDeal {\\n    struct DealData {\\n        address underlyingDealToken;\\n        uint256 underlyingDealTokenTotal;\\n        uint256 vestingPeriod;\\n        uint256 vestingCliffPeriod;\\n        uint256 proRataRedemptionPeriod;\\n        uint256 openRedemptionPeriod;\\n        address holder;\\n        uint256 maxDealTotalSupply;\\n        uint256 holderFundingDuration;\\n    }\\n\\n    struct Timeline {\\n        uint256 period;\\n        uint256 start;\\n        uint256 expiry;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAelinPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\ninterface IAelinPool {\\n    struct PoolData {\\n        string name;\\n        string symbol;\\n        uint256 purchaseTokenCap;\\n        address purchaseToken;\\n        uint256 duration;\\n        uint256 sponsorFee;\\n        uint256 purchaseDuration;\\n        address[] allowListAddresses;\\n        uint256[] allowListAmounts;\\n        NftCollectionRules[] nftCollectionRules;\\n    }\\n\\n    // collectionAddress should be unique, otherwise will override\\n    struct NftCollectionRules {\\n        // if 0, then unlimited purchase\\n        uint256 purchaseAmount;\\n        address collectionAddress;\\n        // if true, then `purchaseAmount` is per token\\n        // else `purchaseAmount` is per account regardless of the NFTs held\\n        bool purchaseAmountPerToken;\\n        // both variables below are only applicable for 1155\\n        uint256[] tokenIds;\\n        // min number of tokens required for participating\\n        uint256[] minTokensEligible;\\n    }\\n\\n    struct NftPurchaseList {\\n        address collectionAddress;\\n        uint256[] tokenIds;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICryptoPunks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.6;\\n\\ninterface ICryptoPunks {\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function punkIndexToAddress(uint256) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/NftCheck.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nlibrary NftCheck {\\n    bytes4 public constant IERC165_ID = type(IERC165).interfaceId;\\n    bytes4 public constant IERC1155_ID = type(IERC1155).interfaceId;\\n    bytes4 public constant IERC721_ID = type(IERC721).interfaceId;\\n\\n    function supports721(address collectionAddress) internal view returns (bool) {\\n        return _supportsInterface(collectionAddress, IERC721_ID);\\n    }\\n\\n    function supports1155(address collectionAddress) internal view returns (bool) {\\n        return _supportsInterface(collectionAddress, IERC1155_ID);\\n    }\\n\\n    function _supportsInterface(address account, bytes4 interfaceId) private view returns (bool) {\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\\n        if (result.length < 32) return false;\\n        return success && abi.decode(result, (bool));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/AelinAllowList.sol\": {\r\n        \"AelinAllowList\": \"0x011829226a32e992a4def3efe225978136dd5cce\"\r\n      },\r\n      \"contracts/libraries/AelinNftGating.sol\": {\r\n        \"AelinNftGating\": \"0xe98dc0da44994f5546644e3384026bb2b5efb153\"\r\n      },\r\n      \"contracts/libraries/MerkleTree.sol\": {\r\n        \"MerkleTree\": \"0x15545f77783c8b47e7d9af53cd9a91ae612b3bac\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPurchased\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPurchased\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDealTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDealTokens\",\"type\":\"uint256\"}],\"name\":\"AcceptDeal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"AelinToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPurchasingReturned\",\"type\":\"uint256\"}],\"name\":\"ClaimDealTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"}],\"name\":\"ClaimedUnderlyingDealToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dealAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"purchaseToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlyingDealToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sponsorFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"}],\"name\":\"CreateUpFrontDeal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dealAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingDealTokenTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchaseTokenPerDealToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchaseRaiseMinimum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchaseDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingCliffPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowDeallocation\",\"type\":\"bool\"}],\"name\":\"CreateUpFrontDealConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"upFrontDealAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchaseExpiryTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingCliffExpiryTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingExpiryTimestamp\",\"type\":\"uint256\"}],\"name\":\"DealFullyFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingDealTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingDealTokenAmount\",\"type\":\"uint256\"}],\"name\":\"DepositDealToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voucher\",\"type\":\"address\"}],\"name\":\"Disavow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"aelinFeeEscrow\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeEscrowClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"purchaseToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingRefund\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"HolderClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchaseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"purchaseAmountPerToken\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"minTokensEligible\",\"type\":\"uint256[]\"}],\"name\":\"PoolWith1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchaseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"purchaseAmountPerToken\",\"type\":\"bool\"}],\"name\":\"PoolWith721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"SetHolder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountMinted\",\"type\":\"uint256\"}],\"name\":\"SponsorClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voucher\",\"type\":\"address\"}],\"name\":\"Vouch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"UpFrontDealAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"}],\"name\":\"WithdrewExcess\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct AelinNftGating.NftPurchaseList[]\",\"name\":\"_nftPurchaseList\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct MerkleTree.UpFrontMerkleData\",\"name\":\"_merkleData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_purchaseTokenAmount\",\"type\":\"uint256\"}],\"name\":\"acceptDeal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aelinEscrowLogicAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aelinFeeEscrow\",\"outputs\":[{\"internalType\":\"contract AelinFeeEscrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aelinTreasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasAllowList\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_purchaser\",\"type\":\"address\"}],\"name\":\"claimableUnderlyingTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dealConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingDealTokenTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseTokenPerDealToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseRaiseMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingCliffPeriod\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowDeallocation\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dealData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"purchaseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingDealToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sponsorFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dealFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dealStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositUnderlyingAmount\",\"type\":\"uint256\"}],\"name\":\"depositUnderlyingTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disavow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeEscrowClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"futureHolder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getAllowList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAmountVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"}],\"name\":\"getNftCollectionDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getNftGatingDetails\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPoolSharesPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPurchaseTokensPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"hasPurchasedMerkle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holderClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"purchaseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingDealToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sponsorFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"}],\"internalType\":\"struct IAelinUpFrontDeal.UpFrontDealData\",\"name\":\"_dealData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"underlyingDealTokenTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseTokenPerDealToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseRaiseMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingCliffPeriod\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowDeallocation\",\"type\":\"bool\"}],\"internalType\":\"struct IAelinUpFrontDeal.UpFrontDealConfig\",\"name\":\"_dealConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"purchaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"purchaseAmountPerToken\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minTokensEligible\",\"type\":\"uint256[]\"}],\"internalType\":\"struct AelinNftGating.NftCollectionRules[]\",\"name\":\"_nftCollectionRules\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"allowListAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"allowListAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct AelinAllowList.InitData\",\"name\":\"_allowListInit\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_aelinTreasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_aelinEscrowLogicAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftGating\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasNftList\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolSharesPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchaseExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"purchaseTokensPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchaserClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"setHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sponsorClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPoolShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPurchasingAccepted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUnderlyingClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingCliffExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vouch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawExcess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AelinUpFrontDeal", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}