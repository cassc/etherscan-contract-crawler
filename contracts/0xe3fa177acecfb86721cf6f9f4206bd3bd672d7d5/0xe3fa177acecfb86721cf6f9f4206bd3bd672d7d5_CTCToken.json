{"SourceCode": "pragma solidity ^0.4.11;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /** \r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner. \r\n   */\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to. \r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n      owner = newOwner;\r\n  }\r\n \r\n}\r\n  \r\ncontract ERC20 {\r\n\r\n    function totalSupply() constant returns (uint256);\r\n    function balanceOf(address who) constant returns (uint256);\r\n    function transfer(address to, uint256 value);\r\n    function transferFrom(address from, address to, uint256 value);\r\n    function approve(address spender, uint256 value);\r\n    function allowance(address owner, address spender) constant returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}\r\n\r\ncontract CTCToken is Ownable, ERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Token properties\r\n    string public name = \"ChainTrade Coin\";\r\n    string public symbol = \"CTC\";\r\n    uint256 public decimals = 18;\r\n    uint256 public numberDecimal18= 1000000000000000000;\r\n\r\n    uint256 public initialPrice = 1000;\r\n    uint256 public _totalSupply = 225000000e18;\r\n    uint256 public _icoSupply = 200000000e18;\r\n\r\n    // Balances for each account\r\n    mapping (address => uint256) balances;\r\n    \r\n    \r\n    //Balances for waiting KYC approving\r\n    mapping (address => uint256) balancesWaitingKYC;\r\n\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping (address => mapping(address => uint256)) allowed;\r\n    \r\n    // start and end timestamps where investments are allowed (both inclusive)\r\n    uint256 public startTime = 1507334400; \r\n    uint256 public endTime = 1514764799; \r\n\r\n    // Wallet Address of Token\r\n    address public multisig;\r\n\r\n    // how many token units a buyer gets per wei\r\n    uint256 public RATE;\r\n\r\n    uint256 public minContribAmount = 0.01 ether;\r\n    uint256 public kycLevel = 15 ether;\r\n    uint256 minCapBonus = 200 ether;\r\n\r\n    uint256 public hardCap = 200000000e18;\r\n    \r\n    //number of total tokens sold \r\n    uint256 public totalNumberTokenSold=0;\r\n\r\n    bool public mintingFinished = false;\r\n\r\n    bool public tradable = true;\r\n\r\n    bool public active = true;\r\n\r\n    event MintFinished();\r\n    event StartTradable();\r\n    event PauseTradable();\r\n    event HaltTokenAllOperation();\r\n    event ResumeTokenAllOperation();\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n\r\n    modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n\r\n    modifier canTradable() {\r\n        require(tradable);\r\n        _;\r\n    }\r\n\r\n    modifier isActive() {\r\n        require(active);\r\n        _;\r\n    }\r\n    \r\n    modifier saleIsOpen(){\r\n        require(startTime <= getNow() && getNow() <=endTime);\r\n        _;\r\n    }\r\n\r\n    // Constructor\r\n    // @notice CTCToken Contract\r\n    // @return the transaction address\r\n    function CTCToken(address _multisig) {\r\n        require(_multisig != 0x0);\r\n        multisig = _multisig;\r\n        RATE = initialPrice;\r\n\r\n        balances[multisig] = _totalSupply;\r\n\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Payable method\r\n    // @notice Anyone can buy the tokens on tokensale by paying ether\r\n    function () external payable {\r\n        \r\n        if (!validPurchase()){\r\n            refundFunds(msg.sender);\r\n        }\r\n        \r\n        tokensale(msg.sender);\r\n    }\r\n\r\n    // @notice tokensale\r\n    // @param recipient The address of the recipient\r\n    // @return the transaction address and send the event as Transfer\r\n        function tokensale(address recipient) canMint isActive saleIsOpen payable {\r\n        require(recipient != 0x0);\r\n        \r\n        uint256 weiAmount = msg.value;\r\n        uint256 nbTokens = weiAmount.mul(RATE).div(1 ether);\r\n        uint256 numberCtcToken = nbTokens.mul(numberDecimal18);\r\n        \r\n        require(_icoSupply >= numberCtcToken);\r\n        \r\n        bool percentageBonusApplicable = weiAmount >= minCapBonus;\r\n        if (percentageBonusApplicable) {\r\n            numberCtcToken = numberCtcToken.mul(11).div(10);\r\n        }\r\n        \r\n        totalNumberTokenSold=totalNumberTokenSold.add(numberCtcToken);\r\n\r\n        _icoSupply = _icoSupply.sub(numberCtcToken);\r\n\r\n        TokenPurchase(msg.sender, recipient, weiAmount, numberCtcToken);\r\n\r\n         if(weiAmount< kycLevel) {\r\n            updateBalances(recipient, numberCtcToken);\r\n            forwardFunds();  \r\n         } else {\r\n            balancesWaitingKYC[recipient] = balancesWaitingKYC[recipient].add(numberCtcToken); \r\n            forwardFunds();  \r\n         }\r\n         \r\n        \r\n    }\r\n    \r\n    function updateBalances(address receiver, uint256 tokens) internal {\r\n        balances[multisig] = balances[multisig].sub(tokens);\r\n        balances[receiver] = balances[receiver].add(tokens);\r\n    }\r\n    \r\n    //refund back if not KYC approved\r\n     function refundFunds(address origin) internal {\r\n        origin.transfer(msg.value);\r\n    }\r\n\r\n    // send ether to the fund collection wallet\r\n    // override to create custom fund forwarding mechanisms\r\n    function forwardFunds() internal {\r\n        multisig.transfer(msg.value);\r\n    }\r\n\r\n    // @return true if the transaction can buy tokens\r\n    function validPurchase() internal constant returns (bool) {\r\n        bool withinPeriod = getNow() >= startTime && getNow() <= endTime;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        bool minContribution = minContribAmount <= msg.value;\r\n        bool notReachedHardCap = hardCap >= totalNumberTokenSold;\r\n        return withinPeriod && nonZeroPurchase && minContribution && notReachedHardCap;\r\n    }\r\n\r\n    // @return true if crowdsale current lot event has ended\r\n    function hasEnded() public constant returns (bool) {\r\n        return getNow() > endTime;\r\n    }\r\n\r\n    function getNow() public constant returns (uint) {\r\n        return now;\r\n    }\r\n\r\n    // Set/change Multi-signature wallet address\r\n    function changeMultiSignatureWallet (address _multisig) onlyOwner isActive {\r\n        multisig = _multisig;\r\n    }\r\n\r\n    // Change ETH/Token exchange rate\r\n    function changeTokenRate(uint _tokenPrice) onlyOwner isActive {\r\n        RATE = _tokenPrice;\r\n    }\r\n\r\n    // Set Finish Minting.\r\n    function finishMinting() onlyOwner isActive {\r\n        mintingFinished = true;\r\n        MintFinished();\r\n    }\r\n\r\n    // Start or pause tradable to Transfer token\r\n    function startTradable(bool _tradable) onlyOwner isActive {\r\n        tradable = _tradable;\r\n        if (tradable)\r\n            StartTradable();\r\n        else\r\n            PauseTradable();\r\n    }\r\n\r\n    //UpdateICODateTime(uint256 _startTime,)\r\n    function updateICODate(uint256 _startTime, uint256 _endTime) public onlyOwner {\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n    \r\n    //Change startTime to start ICO manually\r\n    function changeStartTime(uint256 _startTime) onlyOwner {\r\n        startTime = _startTime;\r\n    }\r\n\r\n    //Change endTime to end ICO manually\r\n    function changeEndTime(uint256 _endTime) onlyOwner {\r\n        endTime = _endTime;\r\n    }\r\n\r\n    // @return total tokens supplied\r\n    function totalSupply() constant returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    // @return total tokens supplied\r\n    function totalNumberTokenSold() constant returns (uint256) {\r\n        return totalNumberTokenSold;\r\n    }\r\n\r\n\r\n    //Change total supply\r\n    function changeTotalSupply(uint256 totalSupply) onlyOwner {\r\n        _totalSupply = totalSupply;\r\n    }\r\n\r\n\r\n    // What is the balance of a particular account?\r\n    // @param who The address of the particular account\r\n    // @return the balanace the particular account\r\n    function balanceOf(address who) constant returns (uint256) {\r\n        return balances[who];\r\n    }\r\n\r\n    // What is the balance of a particular account?\r\n    // @param who The address of the particular account\r\n    // @return the balance of KYC waiting to be approved\r\n    function balanceOfKyCToBeApproved(address who) constant returns (uint256) {\r\n        return balancesWaitingKYC[who];\r\n    }\r\n    \r\n\r\n    function approveBalancesWaitingKYC(address[] listAddresses) onlyOwner {\r\n         for (uint256 i = 0; i < listAddresses.length; i++) {\r\n             address client = listAddresses[i];\r\n             balances[multisig] = balances[multisig].sub(balancesWaitingKYC[client]);\r\n             balances[client] = balances[client].add(balancesWaitingKYC[client]);\r\n             totalNumberTokenSold=totalNumberTokenSold.add(balancesWaitingKYC[client]);\r\n             _icoSupply = _icoSupply.sub(balancesWaitingKYC[client]);\r\n             balancesWaitingKYC[client] = 0;\r\n        }\r\n    }\r\n\r\n    function addBonusForOneHolder(address holder, uint256 bonusToken) onlyOwner{\r\n         require(holder != 0x0); \r\n         balances[multisig] = balances[multisig].sub(bonusToken);\r\n         balances[holder] = balances[holder].add(bonusToken);\r\n         totalNumberTokenSold=totalNumberTokenSold.add(bonusToken);\r\n         _icoSupply = _icoSupply.sub(bonusToken);\r\n    }\r\n\r\n    \r\n    function addBonusForMultipleHolders(address[] listAddresses, uint256[] bonus) onlyOwner {\r\n        require(listAddresses.length == bonus.length); \r\n         for (uint256 i = 0; i < listAddresses.length; i++) {\r\n                require(listAddresses[i] != 0x0); \r\n                balances[listAddresses[i]] = balances[listAddresses[i]].add(bonus[i]);\r\n                balances[multisig] = balances[multisig].sub(bonus[i]);\r\n                totalNumberTokenSold=totalNumberTokenSold.add(bonus[i]);\r\n                _icoSupply = _icoSupply.sub(bonus[i]);\r\n         }\r\n    }\r\n    \r\n   \r\n    \r\n    function modifyCurrentHardCap(uint256 _hardCap) onlyOwner isActive {\r\n        hardCap = _hardCap;\r\n    }\r\n\r\n    // @notice send `value` token to `to` from `msg.sender`\r\n    // @param to The address of the recipient\r\n    // @param value The amount of token to be transferred\r\n    // @return the transaction address and send the event as Transfer\r\n    function transfer(address to, uint256 value) canTradable isActive {\r\n        require (\r\n            balances[msg.sender] >= value && value > 0\r\n        );\r\n        balances[msg.sender] = balances[msg.sender].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        Transfer(msg.sender, to, value);\r\n    }\r\n\r\n    // @notice send `value` token to `to` from `from`\r\n    // @param from The address of the sender\r\n    // @param to The address of the recipient\r\n    // @param value The amount of token to be transferred\r\n    // @return the transaction address and send the event as Transfer\r\n    function transferFrom(address from, address to, uint256 value) canTradable isActive {\r\n        require (\r\n            allowed[from][msg.sender] >= value && balances[from] >= value && value > 0\r\n        );\r\n        balances[from] = balances[from].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\r\n        Transfer(from, to, value);\r\n    }\r\n\r\n    // Allow spender to withdraw from your account, multiple times, up to the value amount.\r\n    // If this function is called again it overwrites the current allowance with value.\r\n    // @param spender The address of the sender\r\n    // @param value The amount to be approved\r\n    // @return the transaction address and send the event as Approval\r\n    function approve(address spender, uint256 value) isActive {\r\n        require (\r\n            balances[msg.sender] >= value && value > 0\r\n        );\r\n        allowed[msg.sender][spender] = value;\r\n        Approval(msg.sender, spender, value);\r\n    }\r\n\r\n    // Check the allowed value for the spender to withdraw from owner\r\n    // @param owner The address of the owner\r\n    // @param spender The address of the spender\r\n    // @return the amount which spender is still allowed to withdraw from owner\r\n    function allowance(address _owner, address spender) constant returns (uint256) {\r\n        return allowed[_owner][spender];\r\n    }\r\n\r\n    // Get current price of a Token\r\n    // @return the price or token value for a ether\r\n    function getRate() constant returns (uint256 result) {\r\n      return RATE;\r\n    }\r\n    \r\n    function getTokenDetail() public constant returns (string, string, uint256, uint256, uint256, uint256, uint256) {\r\n        return (name, symbol, startTime, endTime, _totalSupply, _icoSupply, totalNumberTokenSold);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"updateICODate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalNumberTokenSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenDetail\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"changeEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_icoSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listAddresses\",\"type\":\"address[]\"}],\"name\":\"approveBalancesWaitingKYC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenPrice\",\"type\":\"uint256\"}],\"name\":\"changeTokenRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"changeTotalSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"bonusToken\",\"type\":\"uint256\"}],\"name\":\"addBonusForOneHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hardCap\",\"type\":\"uint256\"}],\"name\":\"modifyCurrentHardCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_multisig\",\"type\":\"address\"}],\"name\":\"changeMultiSignatureWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"changeStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOfKyCToBeApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradable\",\"type\":\"bool\"}],\"name\":\"startTradable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kycLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"tokensale\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listAddresses\",\"type\":\"address[]\"},{\"name\":\"bonus\",\"type\":\"uint256[]\"}],\"name\":\"addBonusForMultipleHolders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberDecimal18\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_multisig\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StartTradable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseTradable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"HaltTokenAllOperation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ResumeTokenAllOperation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "CTCToken", "CompilerVersion": "v0.4.17+commit.bdeb9e52", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fb3065f71973987704e76aa5b1d0851c7c0fd583", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://df7713e75d742a175e545485ddb80ca4ae9eeac9a26b38c17f64b69155158a9c"}