{"SourceCode": "// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n// File: contracts/TestPresale.sol\r\n\r\n//SPDX-License-Identifier: No\r\n\r\npragma solidity ^0.8.17;\r\n\r\n//--- Context ---//\r\nabstract contract Context {\r\n    constructor() {}\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n//--- Pausable ---//\r\nabstract contract Pausable is Context {\r\n    event Paused(address account);\r\n\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n//--- Ownable ---//\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    address private _multiSig;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n    event MultiSigTransferred(\r\n        address indexed oldMultiSig,\r\n        address indexed newMultiSig\r\n    );\r\n\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n        _setMultiSig(_msgSender());\r\n    }\r\n\r\n    function multisig() public view virtual returns (address) {\r\n        return _multiSig;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            owner() == _msgSender() || multisig() == _msgSender(),\r\n            \"Ownable: caller is not the owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyMultiSignature() {\r\n        require(\r\n            multisig() == _msgSender(),\r\n            \"Ownable: caller is not the multisig\"\r\n        );\r\n        _;\r\n    }\r\n  \r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function transferMultiSig(\r\n        address newMultiSig\r\n    ) public virtual onlyMultiSignature {\r\n        require(\r\n            newMultiSig != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _setMultiSig(newMultiSig);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    function _setMultiSig(address newMultiSig) private {\r\n        address oldMultiSig = _multiSig;\r\n        _multiSig = newMultiSig;\r\n        emit MultiSigTransferred(oldMultiSig, newMultiSig);\r\n    }\r\n}\r\n\r\n//--- Interface for ERC20 ---//\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract VaultStaking2 is Context, Pausable, Ownable, ReentrancyGuard {\r\n    event staking(uint256 amount);\r\n    event WithdrawFromStaking(uint256 amount);\r\n    event ClaimRewards(uint256 amount);\r\n    mapping(address => uint256) public stakeTimestamps;\r\n    uint256 public TokenDedicatiAlloStaking; // Modalit\u00e0 1: Fixed amount of tokens staked.\r\n    uint256 public safeSeconds = 15;\r\n    uint256 public totalSupply; // amount of all token staked\r\n    bool public isStakingLive = false;\r\n    uint256 private dayzero;\r\n    uint256 private preApproval;\r\n    bool public Initalized = false;\r\n    mapping(address => uint256) private rewardsGiaPagati;\r\n    mapping(address => uint256) public rewards;\r\n    mapping(address => uint256) private quandoStake;\r\n    mapping(address => uint256) private quandoWithdraw;\r\n    mapping(address => uint256) private lastTimeStaked;\r\n    mapping(address => uint256) private holdingXstaking;\r\n    mapping(address => uint256) private lastClaimRewards;\r\n\r\n    mapping(address => bool) private AlreadyStaked;\r\n\r\n    uint256 public interestperDay = 1_3000000000;\r\n    uint256 public withdrawalLockDuration = 60 days;\r\n\r\n    IERC20 public Token;\r\n\r\n    function setToken(address _token) external onlyMultiSignature {\r\n        require(!Initalized);\r\n        Token = IERC20(_token);\r\n        Initalized = true;\r\n    }\r\n\r\n\r\n      function manageToken(uint256 amount, address tokenAddress) public onlyOwner nonReentrant {\r\n          uint256 contractBalance = IERC20(tokenAddress).balanceOf(address(this));\r\n          require(contractBalance >= amount, \"Ownable: contract does not have enough tokens\");\r\n          IERC20(tokenAddress).transfer(_msgSender(), amount);\r\n      }\r\n\r\n    function stakeForWallets(\r\n        address[] memory _wallets,\r\n        uint256[] memory _amounts\r\n    ) external onlyOwner nonReentrant {\r\n        require(_wallets.length == _amounts.length, \"INSYNC\");\r\n        uint256 _totalAmount;\r\n        for (uint256 _i; _i < _wallets.length; _i++) {\r\n            _totalAmount += _amounts[_i];\r\n            _setShare(_wallets[_i], _amounts[_i]);\r\n            \r\n        }\r\n        IERC20(Token).transferFrom(_msgSender(), address(this), _totalAmount);\r\n    }\r\n\r\n    function _setShare(address wallet, uint256 balanceUpdate) internal {\r\n        stakeprivate(wallet, balanceUpdate);\r\n    }\r\n\r\nfunction setInterestperDay(\r\n    uint256 _interestperDay\r\n) external onlyMultiSignature {\r\n    require(_interestperDay > 0, \"Interest per day must be greater than 0\");\r\n    interestperDay = _interestperDay;\r\n}\r\n    function unPause() external onlyMultiSignature {\r\n        _unpause();\r\n    }\r\n\r\n    function setTokenDedicatiAlloStaking(uint256 amount) external onlyOwner {\r\n        uint256 tempBalance = Token.balanceOf(msg.sender); //\r\n        require(tempBalance >= amount, \"Not enough tokens\"); //\r\n        Token.transferFrom(msg.sender, address(this), amount); // make sure to give enough allowance\r\n        TokenDedicatiAlloStaking += amount;\r\n    }\r\n\r\n    function setStakingLive() external onlyOwner {\r\n        require(!isStakingLive, \"Staking is already live\");\r\n        isStakingLive = true;\r\n    }\r\n\r\n    function stakeprivate(address wallet, uint256 amount) private {\r\n        bool YesNoStaked = AlreadyStaked[wallet] == true;\r\n        if (YesNoStaked) {\r\n            if (pend(msg.sender) >= holdingXstaking[msg.sender] / 1000) {\r\n                revert(\r\n                    \"Claim Rewards, you have at least 0.1% rewards to claim\"\r\n                );\r\n            }\r\n        } else {\r\n            stakeTimestamps[wallet] = block.timestamp;\r\n        }\r\n\r\n        uint256 tempBalance = Token.balanceOf(msg.sender);\r\n        require(isStakingLive, \"Staking is not live\");\r\n        require(tempBalance >= amount, \"Not enough tokens\");\r\n        Token.transferFrom(msg.sender, address(this), amount);\r\n        holdingXstaking[wallet] += amount;\r\n        totalSupply += amount;\r\n        quandoStake[wallet] = block.timestamp; // Quando stake in secondi. https://www.site24x7.com/tools/time-stamp-converter.html\r\n        AlreadyStaked[wallet] = true;\r\n    }\r\n\r\n    function stake(uint256 amount) external nonReentrant whenNotPaused {\r\n        require(msg.sender != address(0));\r\n        require(isStakingLive, \"Staking is not live yet.\");\r\n        stakeprivate(msg.sender, amount);\r\n        emit staking(amount);\r\n    }\r\n\r\n    function withdraw(uint256 amount) external nonReentrant whenNotPaused {\r\n        require(msg.sender != address(0));\r\n        require(amount > 0, \"Amount should be greater than 0\");\r\n        require(holdingXstaking[msg.sender] >= amount, \"Not enough tokens\");\r\n\r\n        uint256 lockDuration = block.timestamp - stakeTimestamps[msg.sender];\r\n        require(\r\n            lockDuration >= withdrawalLockDuration,\r\n            \"Cant withdraw until lock\"\r\n        );\r\n\r\n        holdingXstaking[msg.sender] -= amount;\r\n        totalSupply -= amount;\r\n\r\n        // Transfer the full amount to the user's wallet\r\n        Token.transfer(msg.sender, amount);\r\n\r\n        quandoWithdraw[msg.sender] = block.timestamp;\r\n        bool goingToZero = holdingXstaking[msg.sender] == 0;\r\n        if (goingToZero) {\r\n            resetUser();\r\n        }\r\n\r\n        emit WithdrawFromStaking(amount);\r\n    }\r\n  \r\n\r\n    function resetUser() private {\r\n        AlreadyStaked[msg.sender] = false;\r\n        rewards[msg.sender] = 0;\r\n        rewardsGiaPagati[msg.sender] = 0;\r\n        lastClaimRewards[msg.sender] = 0;\r\n        quandoStake[msg.sender] = 0;\r\n        holdingXstaking[msg.sender] = 0;\r\n        stakeTimestamps[msg.sender] = 0;\r\n    }\r\n\r\n    function calculateRewards() private {\r\n        uint256 interestPerSecond = interestperDay / 86400;\r\n        uint256 interest = (block.timestamp - quandoStake[msg.sender]) *\r\n            interestPerSecond;\r\n        rewards[msg.sender] = (holdingXstaking[msg.sender] * interest);\r\n        rewards[msg.sender] = checkZeroMath(msg.sender, rewards[msg.sender]);\r\n    }\r\n\r\n    function safe() private view whenNotPaused {\r\n        require(\r\n            block.timestamp > lastClaimRewards[msg.sender] + safeSeconds,\r\n            \"Cannot claim in the sameblock\"\r\n        );\r\n    }\r\n\r\n    function staked() private view {\r\n        bool YesNoStaked = AlreadyStaked[msg.sender] == true;\r\n        if (YesNoStaked) {} else {\r\n            safe();\r\n        }\r\n    }\r\n\r\n    function claimReward() external nonReentrant whenNotPaused {\r\n        require(msg.sender != address(0));\r\n        calculateRewards();\r\n        staked();\r\n\r\n        require(rewards[msg.sender] > 0, \"Can't claim less than zero tokens\");\r\n\r\n        uint256 yourrewards = rewards[msg.sender];\r\n\r\n        Token.transfer(msg.sender, yourrewards);\r\n        rewardsGiaPagati[msg.sender] += yourrewards;\r\n        lastClaimRewards[msg.sender] = block.timestamp;\r\n        require(\r\n            TokenDedicatiAlloStaking > yourrewards,\r\n            \"Token Holders need to be able to get back 100% of the tokens allocated\"\r\n        );\r\n        TokenDedicatiAlloStaking -= yourrewards;\r\n\r\n        emit ClaimRewards(yourrewards);\r\n    }\r\n\r\n    function amountStaked(address holder) external view returns (uint256) {\r\n        return holdingXstaking[holder];\r\n    }\r\n\r\n    function rewardsPaid(address holder) external view returns (uint256) {\r\n        return rewardsGiaPagati[holder];\r\n    }\r\n\r\n    function whenStaking(address holder) external view returns (uint256) {\r\n        return quandoStake[holder];\r\n    }\r\n\r\n    function lastTimeClaim(address holder) external view returns (uint256) {\r\n        return lastClaimRewards[holder];\r\n    }\r\n\r\n    function _alreadyStaked(address holder) external view returns (bool) {\r\n        return AlreadyStaked[holder];\r\n    }\r\n\r\n    function pend(address account) private view returns (uint256) {\r\n        uint256 interestPerSecond = interestperDay / 86400;\r\n        uint256 interest = (block.timestamp - quandoStake[account]) *\r\n            interestPerSecond;\r\n        uint256 preRewards;\r\n        preRewards = (holdingXstaking[account] * interest);\r\n        preRewards = checkZeroMath(account, preRewards);\r\n        return preRewards;\r\n    }\r\n\r\n    function checkZeroMath(\r\n        address account,\r\n        uint256 a\r\n    ) internal view returns (uint256) {\r\n        uint256 _return;\r\n        if (((a / 100000000000)) / 100 >= rewardsGiaPagati[account]) {\r\n            _return = ((a / 100000000000)) / 100 - rewardsGiaPagati[account];\r\n        } else {\r\n            _return = 0;\r\n        }\r\n        return _return;\r\n    }\r\n\r\n    function pendingRewards(address account) external view returns (uint256) {\r\n        return pend(account);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldMultiSig\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMultiSig\",\"type\":\"address\"}],\"name\":\"MultiSigTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFromStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"staking\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Initalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokenDedicatiAlloStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"_alreadyStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"amountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestperDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStakingLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"lastTimeClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"manageToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"rewardsPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interestperDay\",\"type\":\"uint256\"}],\"name\":\"setInterestperDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setStakingLive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setTokenDedicatiAlloStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"stakeForWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMultiSig\",\"type\":\"address\"}],\"name\":\"transferMultiSig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"whenStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalLockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VaultStaking2", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d859510f428bc92454d27f216b19ef3d1597d57061d95f5576314aca7a792307"}