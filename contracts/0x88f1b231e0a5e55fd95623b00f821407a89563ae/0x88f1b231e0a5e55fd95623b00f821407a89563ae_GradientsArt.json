{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IHoneycombs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IHoneycombs {\\n    /// @dev The minimal honeycomb data stored on-chain, the rest is generated.\\n    struct StoredHoneycomb {\\n        uint32 epoch; // Each honeycomb is revealed in an epoch\\n        uint24 day; // The days since token was created\\n        uint16 seed; // A unique identifier (this is the token ID since it is pre-reveal)\\n    }\\n\\n    struct Honeycomb {\\n        StoredHoneycomb stored; // We carry over the honeycomb from storage\\n        bool isRevealed; // Whether the honeycomb is revealed\\n        uint256 seed; // The instantiated seed for pseudo-randomisation (post-reveal)\\n        bytes svg; // final svg for the honeycomb\\n        Canvas canvas; // all data relevant to the canvas\\n        BaseHexagon baseHexagon; // all data relevant to the base hexagon\\n        Grid grid; // all data relevant to the grid\\n        Gradients gradients; // all data relevant to the gradients\\n    }\\n\\n    struct Honeycombs {\\n        mapping(uint256 => StoredHoneycomb) all; // All honeycombs\\n        uint32 maxSupply; // The maximum number of honeycombs that can be minted\\n        uint32 minted; // The number of honeycombs that have been minted\\n        uint32 burned; // The number of honeycombs that have been burned\\n        uint32 day0; // Marks the start of this journey\\n        mapping(uint256 => Epoch) epochs; // All epochs\\n        uint256 epoch; // The current epoch index\\n    }\\n\\n    struct Canvas {\\n        string color; // background color of canvas\\n        uint16 size; // size or length of canvas in user units (pixels)\\n        uint16 hexagonSize; // size or length of hexagon in user units (pixels)\\n        uint16 maxHexagonsPerLine; // max number of hexagons per line\\n    }\\n\\n    struct BaseHexagon {\\n        string path; // path of base hexagon\\n        string fillColor; // fill color of base hexagon\\n        uint8 strokeWidth; // stroke width size in user units (pixels)\\n        uint8 hexagonType; // type of base hexagon, i.e. flat or pointy\\n    }\\n\\n    struct Grid {\\n        bytes hexagonsSvg; // final svg for all hexagons\\n        bytes svg; // final svg for the grid\\n        uint16 gridX; // x coordinate of the grid\\n        uint16 gridY; // y coordinate of the grid\\n        uint16 rowDistance; // distance between rows in user units (pixels)\\n        uint16 columnDistance; // distance between columns in user units (pixels)\\n        uint16 rotation; // rotation of entire shape in degrees\\n        uint8 shape; // shape of the grid, i.e. triangle, diamond, hexagon, random\\n        uint8 totalGradients; // number of gradients required based on the grid size and shape\\n        uint8 rows; // number of rows in the grid\\n        uint8 longestRowCount; // largest row size in the grid for centering purposes\\n    }\\n\\n    struct Gradients {\\n        bytes svg; // final svg for the gradients\\n        uint16 duration; // duration of animation in seconds\\n        uint8 direction; // direction of animation, i.e. forward or backward\\n        uint8 chrome; // max number of colors in all the gradients, aka chrome\\n    }\\n\\n    struct Epoch {\\n        uint128 randomness; // The source of randomness for tokens from this epoch\\n        uint64 revealBlock; // The block at which this epoch was / is revealed\\n        bool committed; // Whether the epoch has been instantiated\\n        bool revealed; // Whether the epoch has been revealed\\n    }\\n\\n    event NewEpoch(uint256 indexed epoch, uint64 indexed revealBlock);\\n\\n    error NotAllowed();\\n    error MaxSupplyReached();\\n    error NotExactEth();\\n    error MaxMintPerAddressReached();\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Colors.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n@title  Colors\\n@notice The colors of honeycombs.\\n*/\\nlibrary Colors {\\n    /// @dev These are sorted in a gradient.\\n    function COLORS() public pure returns (string[46] memory) {\\n        return [\\n            \\\"FF005D\\\",\\n            \\\"FF0040\\\",\\n            \\\"FF0011\\\",\\n            \\\"FF0D00\\\",\\n            \\\"FF3300\\\",\\n            \\\"FF4C00\\\",\\n            \\\"FF6600\\\",\\n            \\\"FF7700\\\",\\n            \\\"FF8800\\\",\\n            \\\"FF9900\\\",\\n            \\\"FFB300\\\",\\n            \\\"FFCC00\\\",\\n            \\\"FFE600\\\",\\n            \\\"FFF700\\\",\\n            \\\"FFFF00\\\",\\n            \\\"F6FF00\\\",\\n            \\\"EEFF00\\\",\\n            \\\"D4FF00\\\",\\n            \\\"B3FF00\\\",\\n            \\\"99FF00\\\",\\n            \\\"80FF00\\\",\\n            \\\"62FF00\\\",\\n            \\\"00FF11\\\",\\n            \\\"00FF80\\\",\\n            \\\"00FFBF\\\",\\n            \\\"00FFEE\\\",\\n            \\\"00F7FF\\\",\\n            \\\"00E6FF\\\",\\n            \\\"00C3FF\\\",\\n            \\\"0099FF\\\",\\n            \\\"0077FF\\\",\\n            \\\"0055FF\\\",\\n            \\\"0033FF\\\",\\n            \\\"3300FF\\\",\\n            \\\"5500FF\\\",\\n            \\\"6600FF\\\",\\n            \\\"7B00FF\\\",\\n            \\\"9000FF\\\",\\n            \\\"AA00FF\\\",\\n            \\\"BB00FF\\\",\\n            \\\"D400FF\\\",\\n            \\\"EE00FF\\\",\\n            \\\"FB00FF\\\",\\n            \\\"FF00EA\\\",\\n            \\\"FF00CC\\\",\\n            \\\"FF00A2\\\"\\n        ];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/GradientsArt.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"../interfaces/IHoneycombs.sol\\\";\\nimport \\\"./Utilities.sol\\\";\\nimport \\\"./Colors.sol\\\";\\n\\n/**\\n@title  GradientsArt\\n@notice Generates the gradients for a given Honeycomb.\\n*/\\nlibrary GradientsArt {\\n    enum HEXAGON_TYPE { FLAT, POINTY } // prettier-ignore\\n    enum SHAPE { TRIANGLE, DIAMOND, HEXAGON, RANDOM } // prettier-ignore\\n\\n        /// @dev Get from different chromes or max primary colors. Corresponds to chrome trait in HoneycombsMetadata.sol.\\n    function getChrome(uint8 index) public pure returns (uint8) {\\n        return uint8([1, 2, 3, 4, 5, 6, Colors.COLORS().length][index]);\\n    }\\n\\n    /// @dev Get from different animation durations in seconds. Corresponds to duration trait in HoneycombsMetadata.sol.\\n    function getDuration(uint16 index) public pure returns (uint16) {\\n        return uint16([10, 40, 80, 240][index]);\\n    }\\n\\n    /// @dev Get the linear gradient's svg.\\n    /// @param data The gradient data.\\n    function getLinearGradientSvg(GradientData memory data) public pure returns (bytes memory) {\\n        // prettier-ignore\\n        bytes memory svg = abi.encodePacked(\\n            '<linearGradient id=\\\"gradient', Utilities.uint2str(data.gradientId), '\\\" x1=\\\"0%\\\" x2=\\\"0%\\\" y1=\\\"', \\n                    Utilities.uint2str(data.y1), '%\\\" y2=\\\"', Utilities.uint2str(data.y2), '%\\\">',\\n                '<stop stop-color=\\\"', data.stop1.color, '\\\">',\\n                    '<animate attributeName=\\\"stop-color\\\" values=\\\"', data.stop1.animationColorValues, '\\\" dur=\\\"', \\n                        Utilities.uint2str(data.duration), 's\\\" begin=\\\"animation.begin\\\" repeatCount=\\\"indefinite\\\" />',\\n                '</stop>',\\n                '<stop offset=\\\"0.', Utilities.uint2str(data.offset), '\\\" stop-color=\\\"', data.stop2.color, '\\\">',\\n                    '<animate attributeName=\\\"stop-color\\\" values=\\\"', data.stop2.animationColorValues, '\\\" dur=\\\"', \\n                        Utilities.uint2str(data.duration), 's\\\" begin=\\\"animation.begin\\\" repeatCount=\\\"indefinite\\\" />',\\n                '</stop>',\\n            '</linearGradient>'\\n        );\\n\\n        return svg;\\n    }\\n\\n    /// @dev Get the stop for a linear gradient.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    /// @param stopCount The current stop count - used for seeding the random number generator.\\n    function getLinearGradientStopSvg(\\n        IHoneycombs.Honeycomb memory honeycomb,\\n        uint8 stopCount\\n    ) public pure returns (GradientStop memory) {\\n        GradientStop memory stop;\\n        string[46] memory allColors = Colors.COLORS();\\n\\n        // Get random stop color.\\n        uint256 currentIndex = Utilities.random(\\n            honeycomb.seed,\\n            abi.encodePacked(\\\"linearGradientStop\\\", Utilities.uint2str(stopCount)),\\n            allColors.length\\n        );\\n        stop.color = abi.encodePacked(\\\"#\\\", allColors[currentIndex]);\\n\\n        bytes memory values;\\n        // Add the initial color.\\n        values = abi.encodePacked(values, stop.color, \\\";\\\");\\n\\n        // Get all animation values based on the direction.\\n        bool forwardDirection = honeycomb.gradients.direction == 0;\\n\\n        // We pick 14 more different colors for the gradient.\\n        uint8 count = 14;\\n        for (uint256 i = 0; i <= (count * 2) - 2; ) {\\n            bool isFirstHalf = i < count;\\n\\n            // For the first half, follow the direction. For the second half, reverse the direction.\\n            if (isFirstHalf == forwardDirection) {\\n                currentIndex = (currentIndex + 2) % allColors.length;\\n            } else {\\n                currentIndex = (currentIndex + allColors.length - 2) % allColors.length;\\n            }\\n\\n            values = abi.encodePacked(values, \\\"#\\\", allColors[currentIndex], \\\";\\\");\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Add the last color.\\n        stop.animationColorValues = abi.encodePacked(values, stop.color);\\n        return stop;\\n    }\\n\\n    /// @dev Get all gradients data, particularly the svg.\\n    /// @param honeycomb The honeycomb data used for rendering.\\n    function generateGradientsSvg(IHoneycombs.Honeycomb memory honeycomb) public pure returns (bytes memory) {\\n        bytes memory svg;\\n\\n        // Initialize array of stops (id => svgString) for reuse once we reach the max color count.\\n        GradientStop[] memory stops = new GradientStop[](honeycomb.grid.totalGradients + 1);\\n\\n        uint8 stopCount;\\n        GradientStop memory prevStop = getLinearGradientStopSvg(honeycomb, stopCount);\\n        stops[stopCount] = prevStop;\\n        ++stopCount;\\n\\n        // Loop through all gradients and generate the svg.\\n        for (uint256 i; i < honeycomb.grid.totalGradients; ) {\\n            GradientStop memory stop;\\n\\n            // Get next stop.\\n            if (stopCount < honeycomb.gradients.chrome) {\\n                stop = getLinearGradientStopSvg(honeycomb, stopCount);\\n                stops[stopCount] = stop;\\n                unchecked {\\n                    ++stopCount;\\n                }\\n            } else {\\n                // Randomly select a stop from existing ones.\\n                stop = stops[\\n                    Utilities.random(honeycomb.seed, abi.encodePacked(\\\"stop\\\", Utilities.uint2str(i)), stopCount)\\n                ];\\n            }\\n\\n            // Get gradients svg based on the base hexagon type.\\n            if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.POINTY)) {\\n                GradientData memory gradientData;\\n                gradientData.stop1 = prevStop;\\n                gradientData.stop2 = stop;\\n                gradientData.duration = honeycomb.gradients.duration;\\n                gradientData.gradientId = uint8(i + 1);\\n                gradientData.y1 = 25;\\n                gradientData.y2 = 81;\\n                gradientData.offset = 72;\\n                bytes memory gradientSvg = getLinearGradientSvg(gradientData);\\n\\n                // Append gradient to svg, update previous stop, and increment index.\\n                svg = abi.encodePacked(svg, gradientSvg);\\n                prevStop = stop;\\n                unchecked {\\n                    ++i;\\n                }\\n            } else if (honeycomb.baseHexagon.hexagonType == uint8(HEXAGON_TYPE.FLAT)) {\\n                // Flat tops require two gradients.\\n                GradientData memory gradientData1;\\n                gradientData1.stop1 = prevStop;\\n                gradientData1.stop2 = stop;\\n                gradientData1.duration = honeycomb.gradients.duration;\\n                gradientData1.gradientId = uint8(i + 1);\\n                gradientData1.y1 = 50;\\n                gradientData1.y2 = 100;\\n                gradientData1.offset = 72;\\n                bytes memory gradient1Svg = getLinearGradientSvg(gradientData1);\\n\\n                if (i == honeycomb.grid.totalGradients - 1) {\\n                    // If this is the last gradient, we don't need to generate the second gradient.\\n                    svg = abi.encodePacked(svg, gradient1Svg);\\n                    break;\\n                }\\n\\n                GradientData memory gradientData2;\\n                gradientData2.stop1 = prevStop;\\n                gradientData2.stop2 = stop;\\n                gradientData2.duration = honeycomb.gradients.duration;\\n                gradientData2.gradientId = uint8(i + 2);\\n                gradientData2.y1 = 4;\\n                gradientData2.y2 = 100;\\n                gradientData2.offset = 30;\\n                bytes memory gradient2Svg = getLinearGradientSvg(gradientData2);\\n\\n                // Append both gradients to svg, update previous stop, and increment index.\\n                svg = abi.encodePacked(svg, gradient1Svg, gradient2Svg);\\n                prevStop = stop;\\n                unchecked {\\n                    i += 2;\\n                }\\n            }\\n        }\\n\\n        return svg;\\n    }\\n}\\n\\n/// @dev All internal data relevant to a gradient stop.\\nstruct GradientStop {\\n    bytes color; // color of the gradient stop\\n    bytes animationColorValues; // color values for the animation\\n}\\n\\n/// @dev All additional internal data for rendering a gradient svg string.\\nstruct GradientData {\\n    GradientStop stop1; // first gradient stop\\n    GradientStop stop2; // second gradient stop\\n    uint16 duration; // duration of the animation\\n    uint8 gradientId; // id of the gradient\\n    uint8 y1; // y1 of the gradient\\n    uint8 y2; // y2 of the gradient\\n    uint8 offset; // offset of the gradient\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Utilities.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nlibrary Utilities {\\n    /// @dev Zero-index based pseudorandom number based on one input and max bound\\n    function random(uint256 input, uint256 _max) internal pure returns (uint256) {\\n        return (uint256(keccak256(abi.encodePacked(input))) % _max);\\n    }\\n\\n    /// @dev Zero-index based salted pseudorandom number based on two inputs and max bound\\n    function random(uint256 input, bytes memory salt, uint256 _max) internal pure returns (uint256) {\\n        return (uint256(keccak256(abi.encodePacked(input, salt))) % _max);\\n    }\\n\\n    /// @dev Convert an integer to a string\\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            ++len;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (_i != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    /// @dev Get the larger number\\n    function max(uint8 one, uint8 two) internal pure returns (uint8) {\\n        return one > two ? one : two;\\n    }\\n\\n    /// @dev Get the absolute difference between two numbers\\n    function absDiff(uint8 one, uint8 two) internal pure returns (uint8) {\\n        return one > two ? one - two : two - one;\\n    }\\n\\n    /// @dev Swap two numbers\\n    function swap(uint16 one, uint16 two) internal pure returns (uint16, uint16) {\\n        return (two, one);\\n    }\\n\\n    /// @dev Get the days since another date (input is seconds)\\n    function day(uint256 from, uint256 to) internal pure returns (uint24) {\\n        return uint24((to - from) / 24 hours + 1);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/Colors.sol\": {\r\n        \"Colors\": \"0x7bece1efdf64401d7ad130862dd7003f00f381a4\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"day\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.StoredHoneycomb\",\"name\":\"stored\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isRevealed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"color\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"hexagonSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxHexagonsPerLine\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.Canvas\",\"name\":\"canvas\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"path\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillColor\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"strokeWidth\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hexagonType\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.BaseHexagon\",\"name\":\"baseHexagon\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"grid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"duration\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"chrome\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Gradients\",\"name\":\"gradients\",\"type\":\"tuple\"}],\"internalType\":\"struct IHoneycombs.Honeycomb\",\"name\":\"honeycomb\",\"type\":\"tuple\"}],\"name\":\"generateGradientsSvg\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getChrome\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"getDuration\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"day\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.StoredHoneycomb\",\"name\":\"stored\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isRevealed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"color\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"size\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"hexagonSize\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxHexagonsPerLine\",\"type\":\"uint16\"}],\"internalType\":\"struct IHoneycombs.Canvas\",\"name\":\"canvas\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"path\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"fillColor\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"strokeWidth\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hexagonType\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.BaseHexagon\",\"name\":\"baseHexagon\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"hexagonsSvg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"gridX\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"gridY\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rowDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"columnDistance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"rotation\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalGradients\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rows\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"longestRowCount\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Grid\",\"name\":\"grid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"duration\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"chrome\",\"type\":\"uint8\"}],\"internalType\":\"struct IHoneycombs.Gradients\",\"name\":\"gradients\",\"type\":\"tuple\"}],\"internalType\":\"struct IHoneycombs.Honeycomb\",\"name\":\"honeycomb\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"stopCount\",\"type\":\"uint8\"}],\"name\":\"getLinearGradientStopSvg\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"color\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"animationColorValues\",\"type\":\"bytes\"}],\"internalType\":\"struct GradientStop\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"color\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"animationColorValues\",\"type\":\"bytes\"}],\"internalType\":\"struct GradientStop\",\"name\":\"stop1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"color\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"animationColorValues\",\"type\":\"bytes\"}],\"internalType\":\"struct GradientStop\",\"name\":\"stop2\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"duration\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"gradientId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"y1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"y2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offset\",\"type\":\"uint8\"}],\"internalType\":\"struct GradientData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"getLinearGradientSvg\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "GradientsArt", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}