{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/lib/rain.metadata/src/IMetaV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// Thrown when hashed metadata does NOT match the expected hash.\\n/// @param expectedHash The hash expected by the `IMetaV1` contract.\\n/// @param actualHash The hash of the metadata seen by the `IMetaV1` contract.\\nerror UnexpectedMetaHash(bytes32 expectedHash, bytes32 actualHash);\\n\\n/// Thrown when some bytes are expected to be rain meta and are not.\\n/// @param unmeta the bytes that are not meta.\\nerror NotRainMetaV1(bytes unmeta);\\n\\n/// @dev Randomly generated magic number with first bytes oned out.\\n/// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\nuint64 constant META_MAGIC_NUMBER_V1 = 0xff0a89c674ee7874;\\n\\n/// @title IMetaV1\\ninterface IMetaV1 {\\n    /// An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender\\n    /// to the metadata so that tooling can easily drop/ignore data from unknown\\n    /// sources. As metadata is about something, the subject MUST be provided.\\n    /// @param sender The msg.sender.\\n    /// @param subject The entity that the metadata is about. MAY be the address\\n    /// of the emitting contract (as `uint256`) OR anything else. The\\n    /// interpretation of the subject is context specific, so will often be a\\n    /// hash of some data/thing that this metadata is about.\\n    /// @param meta Rain metadata V1 compliant metadata bytes.\\n    /// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\n    event MetaV1(address sender, uint256 subject, bytes meta);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/lib/rain.metadata/src/LibMeta.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IMetaV1.sol\\\";\\n\\n/// @title LibMeta\\n/// @notice Need a place to put data that can be handled offchain like ABIs that\\n/// IS NOT etherscan.\\nlibrary LibMeta {\\n    /// Returns true if the metadata bytes are prefixed by the Rain meta magic\\n    /// number. DOES NOT attempt to validate the body of the metadata as offchain\\n    /// tooling will be required for this.\\n    /// @param meta_ The data that may be rain metadata.\\n    /// @return True if `meta_` is metadata, false otherwise.\\n    function isRainMetaV1(bytes memory meta_) internal pure returns (bool) {\\n        if (meta_.length < 8) return false;\\n        uint256 mask_ = type(uint64).max;\\n        uint256 magicNumber_ = META_MAGIC_NUMBER_V1;\\n        assembly (\\\"memory-safe\\\") {\\n            magicNumber_ := and(mload(add(meta_, 8)), mask_)\\n        }\\n        return magicNumber_ == META_MAGIC_NUMBER_V1;\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1`.\\n    /// @param meta_ The metadata bytes to check.\\n    function checkMetaUnhashed(bytes memory meta_) internal pure {\\n        if (!isRainMetaV1(meta_)) {\\n            revert NotRainMetaV1(meta_);\\n        }\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1` OR it does not match the expected hash of its data.\\n    /// @param meta_ The metadata to check.\\n    function checkMetaHashed(bytes32 expectedHash_, bytes memory meta_) internal pure {\\n        bytes32 actualHash_ = keccak256(meta_);\\n        if (expectedHash_ != actualHash_) {\\n            revert UnexpectedMetaHash(expectedHash_, actualHash_);\\n        }\\n        checkMetaUnhashed(meta_);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/abstract/DeployerDiscoverableMetaV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"rain.metadata/IMetaV1.sol\\\";\\nimport \\\"rain.metadata/LibMeta.sol\\\";\\nimport \\\"../lib/caller/LibDeployerDiscoverable.sol\\\";\\n\\n/// Construction config for `DeployerDiscoverableMetaV1`.\\n/// @param deployer Deployer the calling contract will be discoverable under.\\n/// @param meta MetaV1 data to emit before touching the deployer.\\nstruct DeployerDiscoverableMetaV1ConstructionConfig {\\n    address deployer;\\n    bytes meta;\\n}\\n\\n/// @title DeployerDiscoverableMetaV1\\n/// @notice Upon construction, checks metadata against a known hash, emits it\\n/// then touches the deployer (deploy an empty expression). This allows indexers\\n/// to discover the metadata of the `DeployerDiscoverableMetaV1` contract by\\n/// indexing the deployer. In this way the deployer acts as a pseudo-registry by\\n/// virtue of it being a natural hub for interactions with calling contracts.\\nabstract contract DeployerDiscoverableMetaV1 is IMetaV1 {\\n    constructor(bytes32 metaHash, DeployerDiscoverableMetaV1ConstructionConfig memory config) {\\n        LibMeta.checkMetaHashed(metaHash, config.meta);\\n        emit MetaV1(msg.sender, uint256(uint160(address(this))), config.meta);\\n        LibDeployerDiscoverable.touchDeployerV1(config.deployer);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\nstring constant IERC1820_NAME_IEXPRESSION_DEPLOYER_V1 = \\\"IExpressionDeployerV1\\\";\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// This is the literal InterpreterOpMeta bytes to be used offchain to make\\n    /// sense of the opcodes in this interpreter deployment, as a human. For\\n    /// formats like json that make heavy use of boilerplate, repetition and\\n    /// whitespace, some kind of compression is recommended.\\n    /// @param sender The `msg.sender` providing the op meta.\\n    /// @param opMeta The raw binary data of the op meta. Maybe compressed data\\n    /// etc. and is intended for offchain consumption.\\n    event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);\\n\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as\\n    /// libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract\\n    ///   data\\n    /// - Expressions need to be immutable between their deploy time integrity\\n    ///   check and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter\\n    ///   is cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like\\n    ///   SSTORE2 are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source\\n    /// code before it puts the expression onchain at a known address. The\\n    /// integrity check MUST at a minimum (it is free to do additional static\\n    /// analysis) calculate the memory required to be allocated for the stack in\\n    /// total, and that no out of bounds memory reads/writes occur within this\\n    /// stack. A simple example of an invalid source would be one that pushes one\\n    /// value to the stack then attempts to pops two values, clearly we cannot\\n    /// remove more values than we added. The `IExpressionDeployerV1` MUST revert\\n    /// in the case of any integrity failure, all integrity checks MUST pass in\\n    /// order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do\\n    /// any additional processing required by its paired interpreter.\\n    /// For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\\n    /// opcodes in the `ExpressionConfig` sources with real function pointers\\n    /// from the corresponding interpreter.\\n    ///\\n    /// @param sources Sources verbatim. These sources MUST be provided in their\\n    /// sequential/index opcode form as the deployment process will need to index\\n    /// into BOTH the integrity check and the final runtime function pointers.\\n    /// This will be emitted in an event for offchain processing to use the\\n    /// indexed opcode sources. The first N sources are considered entrypoints\\n    /// and will be integrity checked by the expression deployer against a\\n    /// starting stack height of 0. Non-entrypoint sources MAY be provided for\\n    /// internal use such as the `call` opcode but will NOT be integrity checked\\n    /// UNLESS entered by an opcode in an entrypoint.\\n    /// @param constants Constants verbatim. Constants are provided alongside\\n    /// sources rather than inline as it allows us to avoid variable length\\n    /// opcodes and can be more memory efficient if the same constant is\\n    /// referenced several times from the sources.\\n    /// @param minOutputs The first N sources on the state config are entrypoints\\n    /// to the expression where N is the length of the `minOutputs` array. Each\\n    /// item in the `minOutputs` array specifies the number of outputs that MUST\\n    /// be present on the final stack for an evaluation of each entrypoint. The\\n    /// minimum output for some entrypoint MAY be zero if the expectation is that\\n    /// the expression only applies checks and error logic. Non-entrypoint\\n    /// sources MUST NOT have a minimum outputs length specified.\\n    /// @return interpreter The interpreter the deployer believes it is qualified\\n    /// to perform integrity checks on behalf of.\\n    /// @return store The interpreter store the deployer believes is compatible\\n    /// with the interpreter.\\n    /// @return expression The address of the deployed onchain expression. MUST\\n    /// be valid according to all integrity checks the deployer is aware of.\\n    function deployExpression(bytes[] memory sources, uint256[] memory constants, uint256[] memory minOutputs)\\n        external\\n        returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/IInterpreterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/lib/caller/LibDeployerDiscoverable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../../interface/IExpressionDeployerV1.sol\\\";\\n\\nlibrary LibDeployerDiscoverable {\\n    /// Hack so that some deployer will emit an event with the sender as the\\n    /// caller of `touchDeployer`. This MAY be needed by indexers such as\\n    /// subgraph that can only index events from the first moment they are aware\\n    /// of some contract. The deployer MUST be registered in ERC1820 registry\\n    /// before it is touched, THEN the caller meta MUST be emitted after the\\n    /// deployer is touched. This allows indexers such as subgraph to index the\\n    /// deployer, then see the caller, then see the caller's meta emitted in the\\n    /// same transaction.\\n    /// This is NOT required if ANY other expression is deployed in the same\\n    /// transaction as the caller meta, there only needs to be one expression on\\n    /// ANY deployer known to ERC1820.\\n    function touchDeployerV1(address deployer) internal {\\n        (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression) =\\n            IExpressionDeployerV1(deployer).deployExpression(new bytes[](0), new uint256[](0), new uint256[](0));\\n        (interpreter);\\n        (store);\\n        (expression);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/concrete/CloneFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.19;\\n\\nimport \\\"../interface/ICloneableV2.sol\\\";\\nimport \\\"../interface/ICloneableFactoryV2.sol\\\";\\nimport \\\"rain.interpreter/abstract/DeployerDiscoverableMetaV1.sol\\\";\\nimport {Clones} from \\\"openzeppelin-contracts/contracts/proxy/Clones.sol\\\";\\n\\n/// Thrown when an implementation has zero code size which is always a mistake.\\nerror ZeroImplementationCodeSize();\\n\\n/// Thrown when initialization fails.\\nerror InitializationFailed();\\n\\n/// @dev Expected hash of the clone factory rain metadata.\\nbytes32 constant CLONE_FACTORY_META_HASH = bytes32(0x1efc6b18f7f4aa4266a7801e1b611be09f1977d4e1a6c3c5c17ac27abf81027e);\\n\\n/// @title CloneFactory\\n/// @notice A fairly minimal implementation of `ICloneableFactoryV2` and\\n/// `DeployerDiscoverableMetaV1` that uses Open Zeppelin `Clones` to create\\n/// EIP1167 clones of a reference bytecode. The reference bytecode MUST implement\\n/// `ICloneableV2`.\\ncontract CloneFactory is ICloneableFactoryV2, DeployerDiscoverableMetaV1 {\\n    constructor(DeployerDiscoverableMetaV1ConstructionConfig memory config)\\n        DeployerDiscoverableMetaV1(CLONE_FACTORY_META_HASH, config)\\n    {}\\n\\n    /// @inheritdoc ICloneableFactoryV2\\n    function clone(address implementation, bytes calldata data) external returns (address) {\\n        // Explicitly check that the implementation has code. This is a common\\n        // mistake that will cause the clone to fail. Notably this catches the\\n        // case of address(0). This check is not strictly necessary as a zero\\n        // sized implementation will fail to initialize the child, but it gives\\n        // a better error message.\\n        if (implementation.code.length == 0) {\\n            revert ZeroImplementationCodeSize();\\n        }\\n        // Standard Open Zeppelin clone here.\\n        address child = Clones.clone(implementation);\\n        // NewClone does NOT include the data passed to initialize.\\n        // The implementation is responsible for emitting an event if it wants.\\n        emit NewClone(msg.sender, implementation, child);\\n        // Checking the return value of initialize is mandatory as per\\n        // ICloneableFactoryV2.\\n        if (ICloneableV2(child).initialize(data) != ICLONEABLE_V2_SUCCESS) {\\n            revert InitializationFailed();\\n        }\\n        return child;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/ICloneableFactoryV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @title ICloneableFactoryV2\\n/// @notice A minimal interface to create proxy clones of a reference bytecode\\n/// and emit events so that indexers can discover it. `ICloneableFactoryV2` knows\\n/// nothing about the contracts that it clones, instead relying only on the\\n/// minimal `ICloneableV2` interface being implemented on the reference bytecode.\\ninterface ICloneableFactoryV2 {\\n    /// Emitted upon each `clone`.\\n    /// @param sender The `msg.sender` that called `clone`.\\n    /// @param implementation The reference bytecode to clone as a proxy.\\n    /// @param clone The address of the new proxy contract.\\n    event NewClone(address sender, address implementation, address clone);\\n\\n    /// Clones an implementation using a proxy. EIP1167 proxy is recommended but\\n    /// the exact cloning procedure is not specified by this interface.\\n    ///\\n    /// The factory MUST call `ICloneableV2.initialize` atomically with the\\n    /// cloning process and MUST NOT call any other functions on the cloned proxy\\n    /// before `initialize` completes successfully. The factory MUST ONLY\\n    /// consider the clone to be successfully created if `initialize` returns the\\n    /// keccak256 hash of the string \\\"ICloneableV2.initialize\\\".\\n    ///\\n    /// MUST emit `NewClone` with the implementation and clone address.\\n    ///\\n    /// @param implementation The contract to clone.\\n    /// @param data As per `ICloneableV2`.\\n    /// @return New child contract address.\\n    function clone(address implementation, bytes calldata data) external returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interface/ICloneableV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @dev This hash MUST be returned when an `ICloneableV2` is successfully\\n/// initialized.\\nbytes32 constant ICLONEABLE_V2_SUCCESS = keccak256(\\\"ICloneableV2.initialize\\\");\\n\\n/// @title ICloneableV2\\n/// @notice Interface for cloneable contracts that support initialization.\\ninterface ICloneableV2 {\\n    /// Overloaded initialize function MUST revert with this error.\\n    error InitializeSignatureFn();\\n\\n    /// Initialize is intended to work like constructors but for cloneable\\n    /// proxies. The `ICloneableV2` contract MUST ensure that initialize can NOT\\n    /// be called more than once. The `ICloneableV2` contract is designed to be\\n    /// deployed by an `ICloneableFactoryV2` but MUST NOT assume that it will be.\\n    /// It is possible for someone to directly deploy an `ICloneableV2` and fail\\n    /// to call initialize before other functions are called, and end users MAY\\n    /// NOT realise or know how to confirm a safe deployment state. The\\n    /// `ICloneableV2` MUST take appropriate measures to ensure that functions\\n    /// called before initialize are safe to do so, or revert.\\n    ///\\n    /// To be fully generic, `initilize` accepts `bytes` and so MUST ABI decode\\n    /// within the initialize function. This allows a single factory to service\\n    /// arbitrary cloneable proxies but also erases the type of the\\n    /// initialization config from the ABI. As tooling will inevitably require\\n    /// the ABI to be known, it is RECOMMENDED that the `ICloneableV2` contract\\n    /// implements a typed `initialize` function that overloads the generic\\n    /// `initialize(bytes)` function. This overloaded function MUST revert with\\n    /// `InitializeSignatureFn` always, so that it is NEVER accidentally called.\\n    /// This avoids complex and expensive delegate call style patterns where a\\n    /// typed overload has to call back to itself and preserve the sender,\\n    /// instead we force the caller to know the correct signature and call the\\n    /// correct function directly with encoded bytes.\\n    ///\\n    /// If initialization is successful the `ICloneableV2` MUST return the\\n    /// keccak256 hash of the string \\\"ICloneableV2.initialize\\\". This avoids false\\n    /// positives where a contract building a proxy, such as an\\n    /// `ICloneableFactoryV2`, may incorrectly believe that the clone has been\\n    /// initialized but the implementation doesn't support `ICloneableV2`.\\n    ///\\n    /// @dev The `ICloneableV2` interface is identical to `ICloneableV1` except\\n    /// that it returns a `bytes32` success hash.\\n    /// @param data The initialization data.\\n    /// @return success keccak256(\\\"ICloneableV2.initialize\\\") if successful.\\n    function initialize(bytes calldata data) external returns (bytes32 success);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"caller/=lib/rain.interpreter/src/lib/caller/\",\r\n      \"compile/=lib/rain.interpreter/src/lib/compile/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"eval/=lib/rain.interpreter/src/lib/eval/\",\r\n      \"extern/=lib/rain.interpreter/src/lib/extern/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"integrity/=lib/rain.interpreter/src/lib/integrity/\",\r\n      \"ns/=lib/rain.interpreter/src/lib/ns/\",\r\n      \"op/=lib/rain.interpreter/src/lib/op/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"parse/=lib/rain.interpreter/src/lib/parse/\",\r\n      \"rain.datacontract/=lib/rain.interpreter/lib/rain.datacontract/src/\",\r\n      \"rain.extrospection/=lib/rain.extrospection/\",\r\n      \"rain.interpreter/=lib/rain.interpreter/src/\",\r\n      \"rain.metadata/=lib/rain.interpreter/lib/rain.metadata/src/\",\r\n      \"rain.solmem/=lib/rain.extrospection/lib/rain.solmem/src/\",\r\n      \"state/=lib/rain.interpreter/src/lib/state/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"internalType\":\"struct DeployerDiscoverableMetaV1ConstructionConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InitializationFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"unmeta\",\"type\":\"bytes\"}],\"name\":\"NotRainMetaV1\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"expectedHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"actualHash\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedMetaHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroImplementationCodeSize\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subject\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"name\":\"MetaV1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"name\":\"NewClone\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CloneFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000db2e78cbbe7ffb38908acbdf5273b6c6c8b82f0e000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001b5ff0a89c674ee7874a50059017fcd543d4fc33010fd2b2873164030746d85e85006be0650874b720523c78eec73698afadfb934094eda244415039b3feebd7777efecd7af40a8cc910d26bc8c759a6985aada0a456814c8c73cc36012409218b4360803056971906026758e864fa81db20b8fd0514ed8c0a648e071e5e56e191ea22c1917d3d9ac529a091beb351a88242e98e1f97caa551923b4e2f54abc798db8de572ae432897b154b40b8700491908272be535a659017bc3e3eaeb9b5a92aaa3ab5fc91982b4102a4d84291c00d0889892740630ea1bff5c5a9bece5401779aee41a8b2fa13a42e2fbc186e328c09935bb0ef07921cd6676293016272207bf03ee927554b1579b7c33b32f7c017347a9eb26d294f25942627f820b6d84500ec629e6ac71c2b9016c3763312dcb03bfe6a78ba2d32a077b607b91cef2faeae1b5c2efae0f23d591d31826ce4c3a9ae8fe662cd8dfb57cd39e2122d7fff863396fc8f755035de117e4edb41be55fd4fe8c4e4870c4d60d0d0ba12ed687452dd858ffbf4564eed3f53867c03011bffe5ffb4a3ff2cde02706170706c69636174696f6e2f6a736f6e03676465666c6174650462656e0000000000000000000000", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}