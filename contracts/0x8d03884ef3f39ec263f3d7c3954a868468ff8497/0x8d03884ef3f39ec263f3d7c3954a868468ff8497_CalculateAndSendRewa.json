{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/FeeRewardsManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache License 2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\n\\n// We use a library for the `calculateRewards` function because the less code in\\n// `RewardsCollector` the less expensive it is to deploy the collector contract.\\n// We can call the library instead of deploying the library's code again and\\n// again.\\nlibrary CalculateAndSendRewards {\\n    // Fee denominator, if `feeNominator = 500`,\\n    // the tax is 500/10000 = 5/100 = 5%.\\n    uint32 public constant FEE_DENOMINATOR = 10_000;\\n    event CollectedReward(\\n        address withdrawalCredential,\\n        uint256 withdrawnAmount,\\n        address feeRewardsManager,\\n        uint256 fee\\n    );\\n\\n    function calculateAndSendRewards(\\n        uint32 feeNominator,\\n        address feeRewardsManager,\\n        address withdrawalCredential\\n    ) public {\\n        require(address(this).balance != 0, \\\"Nothing to distribute\\\");\\n\\n        uint256 feeAmount = (address(this).balance * feeNominator) /\\n            FEE_DENOMINATOR;\\n        uint256 withdrawAmount = address(this).balance - feeAmount;\\n        emit CollectedReward(\\n            withdrawalCredential,\\n            withdrawAmount,\\n            feeRewardsManager,\\n            feeAmount\\n        );\\n        // This can be used to call this contract again (reentrancy) but since\\n        // all funds from this contract are used for the feeRewardsManager.\\n        (bool feeRewardsManagerSent, ) = payable(feeRewardsManager).call{\\n            value: feeAmount\\n        }(\\\"\\\");\\n        require(\\n            feeRewardsManagerSent,\\n            \\\"Failed to send Ether back to owner contract\\\"\\n        );\\n        (bool sent, ) = payable(withdrawalCredential).call{\\n            value: withdrawAmount\\n        }(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether back to withdrawal credential\\\");\\n    }\\n}\\n\\ncontract RewardsCollector {\\n    // 1 - fee % will go to the user in this address.\\n    address public immutable withdrawalCredential;\\n\\n    // Fee's numerator.\\n    uint32 public feeNumerator;\\n\\n    // This is the contract that created the `RewardsCollector`.\\n    // Do not use owner here because this contract is going to be\\n    // created multiple times for each `withdrawal credential` and\\n    // we don't need any function for the ownership except when changing\\n    // the fee.\\n    address public immutable parentContract;\\n\\n    // Allow receiving MEV and other rewards.\\n    receive() external payable {}\\n\\n    function collectRewards() public payable {\\n        CalculateAndSendRewards.calculateAndSendRewards(\\n            feeNumerator,\\n            parentContract,\\n            withdrawalCredential\\n        );\\n    }\\n\\n    constructor(address _withdrawalCredential) {\\n        withdrawalCredential = _withdrawalCredential;\\n        parentContract = msg.sender;\\n    }\\n\\n    function changeFeeNumerator(uint32 _newFeeNumerator) public {\\n        require(\\n            msg.sender == parentContract,\\n            \\\"ChangeFee not called from parent contract\\\"\\n        );\\n        // Do not let fee be > 1 (with 10_000 denominator).\\n        require(_newFeeNumerator <= 10_000, \\\"Invalid fee numerator\\\");\\n        feeNumerator = _newFeeNumerator;\\n    }\\n}\\n\\ncontract FeeRewardsManager is Ownable2Step {\\n    uint32 public defaultFeeNumerator;\\n\\n    constructor(uint32 _defaultFeeNumerator) Ownable(msg.sender) {\\n        // Do not let fee be > 1 (with 10_000 denominator).\\n        require(_defaultFeeNumerator <= 10_000, \\\"Invalid fee numerator\\\");\\n        defaultFeeNumerator = _defaultFeeNumerator;\\n    }\\n\\n    event ContractDeployed(address contractAddress, uint32 feeNumerator);\\n\\n    function changeDefaultFee(uint32 _newFeeNumerator) public onlyOwner {\\n        // Do not let fee be > 1 (with 10_000 denominator).\\n        require(_newFeeNumerator <= 10_000, \\\"Invalid fee numerator\\\");\\n        defaultFeeNumerator = _newFeeNumerator;\\n    }\\n\\n    function createFeeContract(\\n        address _withdrawalCredential\\n    ) public returns (address payable) {\\n        bytes32 withdrawalCredentialBytes = bytes32(\\n            uint256(uint160(_withdrawalCredential))\\n        );\\n        // Uses CREATE2 opcode.\\n        RewardsCollector rewardsCollector = new RewardsCollector{\\n            salt: withdrawalCredentialBytes\\n        }(_withdrawalCredential);\\n        rewardsCollector.changeFeeNumerator(defaultFeeNumerator);\\n        emit ContractDeployed(address(rewardsCollector), defaultFeeNumerator);\\n        return payable(address(rewardsCollector));\\n    }\\n\\n    // Predicts the address of a new contract that will be a `fee_recipient` of\\n    // an Ethereum validator.\\n    // Given the `_withdrawalCredential` we can instantiate a contract that will\\n    // be deployed at a deterministic address, calculated given the\\n    // `_withdrawalCredential`, the current contract address and the current\\n    // contract's bytecode.\\n    function predictFeeContractAddress(\\n        address _withdrawalCredential\\n    ) public view returns (address) {\\n        bytes memory bytecode = type(RewardsCollector).creationCode;\\n        bytecode = abi.encodePacked(\\n            bytecode,\\n            abi.encode(_withdrawalCredential)\\n        );\\n        bytes32 withdrawalCredentialBytes = bytes32(\\n            uint256(uint160(_withdrawalCredential))\\n        );\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                bytes1(0xff),\\n                address(this),\\n                withdrawalCredentialBytes,\\n                keccak256(bytecode)\\n            )\\n        );\\n        return address(uint160(uint(hash)));\\n    }\\n\\n    function changeFeeNumerator(\\n        address payable _feeContract,\\n        uint32 _newFee\\n    ) public onlyOwner {\\n        RewardsCollector(_feeContract).changeFeeNumerator(_newFee);\\n    }\\n\\n    function batchCollectRewards(\\n        address payable[] calldata feeAddresses\\n    ) public {\\n        for (uint32 i = 0; i < feeAddresses.length; ++i) {\\n            RewardsCollector(feeAddresses[i]).collectRewards();\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    // Withdraws Eth from the manager contract.\\n    function getEth(address addr) external onlyOwner {\\n        (bool sent, ) = payable(addr).call{value: address(this).balance}(\\\"\\\");\\n        require(sent, \\\"Failed to get Eth from contract\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\\n * old one. This can help prevent common mistakes, such as transfers of ownership to\\n * incorrect accounts, or to contracts that are unable to interact with the\\n * permission system.\\n *\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        if (pendingOwner() != sender) {\\n            revert OwnableUnauthorizedAccount(sender);\\n        }\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": false,\r\n    \"libraries\": {\r\n      \"src/FeeRewardsManager.sol\": {\r\n        \"CalculateAndSendRewards\": \"0x8D03884EF3F39ec263F3D7c3954A868468ff8497\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawalCredential\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeRewardsManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"CollectedReward\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CalculateAndSendRewards", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}