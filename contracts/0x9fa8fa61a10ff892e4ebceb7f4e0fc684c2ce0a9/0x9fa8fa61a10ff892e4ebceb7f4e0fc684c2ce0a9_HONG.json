{"SourceCode": "/* Verified by 3esmit\r\n \r\n- Bytecode Verification performed was compared on second iteration -\r\n\r\nThis file is part of the HONG.\r\n\r\nThe HONG is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU lesser General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThe HONG is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU lesser General Public License for more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the HONG.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/*\r\n * Parent contract that contains all of the configurable parameters of the main contract.\r\n */\r\ncontract HongConfiguration {\r\n    uint public closingTime;\r\n    uint public weiPerInitialHONG = 10**16;\r\n    string public name = \"HONG\";\r\n    string public symbol = \"\u0126\";\r\n    uint8 public decimals = 0;\r\n    uint public maxBountyTokens = 2 * (10**6);\r\n    uint public closingTimeExtensionPeriod = 30 days;\r\n    uint public minTokensToCreate = 100 * (10**6);\r\n    uint public maxTokensToCreate = 250 * (10**6);\r\n    uint public tokensPerTier = 50 * (10**6);\r\n    uint public lastKickoffDateBuffer = 304 days;\r\n\r\n    uint public mgmtRewardPercentage = 20;\r\n    uint public mgmtFeePercentage = 8;\r\n\r\n    uint public harvestQuorumPercent = 20;\r\n    uint public freezeQuorumPercent = 50;\r\n    uint public kickoffQuorumPercent = 20;\r\n}\r\n\r\ncontract ErrorHandler {\r\n    bool public isInTestMode = false;\r\n    event evRecord(address msg_sender, uint msg_value, string message);\r\n    function doThrow(string message) internal {\r\n        evRecord(msg.sender, msg.value, message);\r\n        if(!isInTestMode){\r\n            throw;\r\n        }\r\n    }\r\n}\r\n\r\ncontract TokenInterface is ErrorHandler {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public tokensCreated;\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _amount) returns (bool success);\r\n\r\n    event evTransfer(address msg_sender, uint msg_value, address indexed _from, address indexed _to, uint256 _amount);\r\n\r\n    // Modifier that allows only token holders to trigger\r\n    modifier onlyTokenHolders {\r\n        if (balanceOf(msg.sender) == 0) doThrow(\"onlyTokenHolders\"); else {_}\r\n    }\r\n}\r\n\r\ncontract Token is TokenInterface {\r\n    // Protects users by preventing the execution of method calls that\r\n    // inadvertently also transferred ether\r\n    modifier noEther() {if (msg.value > 0) doThrow(\"noEther\"); else{_}}\r\n    modifier hasEther() {if (msg.value <= 0) doThrow(\"hasEther\"); else{_}}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\r\n        if (_amount <= 0) return false;\r\n        if (balances[msg.sender] < _amount) return false;\r\n        if (balances[_to] + _amount < balances[_to]) return false;\r\n\r\n        balances[msg.sender] -= _amount;\r\n        balances[_to] += _amount;\r\n\r\n        evTransfer(msg.sender, msg.value, msg.sender, _to, _amount);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract OwnedAccount is ErrorHandler {\r\n    address public owner;\r\n    bool acceptDeposits = true;\r\n\r\n    event evPayOut(address msg_sender, uint msg_value, address indexed _recipient, uint _amount);\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) doThrow(\"onlyOwner\");\r\n        else {_}\r\n    }\r\n\r\n    modifier noEther() {\r\n        if (msg.value > 0) doThrow(\"noEther\");\r\n        else {_}\r\n    }\r\n\r\n    function OwnedAccount(address _owner) {\r\n        owner = _owner;\r\n    }\r\n\r\n    function payOutPercentage(address _recipient, uint _percent) internal onlyOwner noEther {\r\n        payOutAmount(_recipient, (this.balance * _percent) / 100);\r\n    }\r\n\r\n    function payOutAmount(address _recipient, uint _amount) internal onlyOwner noEther {\r\n        // send does not forward enough gas to see that this is a managed account call\r\n        if (!_recipient.call.value(_amount)())\r\n            doThrow(\"payOut:sendFailed\");\r\n        else\r\n            evPayOut(msg.sender, msg.value, _recipient, _amount);\r\n    }\r\n\r\n    function () returns (bool success) {\r\n        if (!acceptDeposits) throw;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ReturnWallet is OwnedAccount {\r\n    address public mgmtBodyWalletAddress;\r\n\r\n    bool public inDistributionMode;\r\n    uint public amountToDistribute;\r\n    uint public totalTokens;\r\n    uint public weiPerToken;\r\n\r\n    function ReturnWallet(address _mgmtBodyWalletAddress) OwnedAccount(msg.sender) {\r\n        mgmtBodyWalletAddress = _mgmtBodyWalletAddress;\r\n    }\r\n\r\n    function payManagementBodyPercent(uint _percent) {\r\n        payOutPercentage(mgmtBodyWalletAddress, _percent);\r\n    }\r\n\r\n    function switchToDistributionMode(uint _totalTokens) onlyOwner {\r\n        inDistributionMode = true;\r\n        acceptDeposits = false;\r\n        totalTokens = _totalTokens;\r\n        amountToDistribute = this.balance;\r\n        weiPerToken = amountToDistribute / totalTokens;\r\n    }\r\n\r\n    function payTokenHolderBasedOnTokenCount(address _tokenHolderAddress, uint _tokens) onlyOwner {\r\n        payOutAmount(_tokenHolderAddress, weiPerToken * _tokens);\r\n    }\r\n}\r\n\r\ncontract ExtraBalanceWallet is OwnedAccount {\r\n    address returnWalletAddress;\r\n    function ExtraBalanceWallet(address _returnWalletAddress) OwnedAccount(msg.sender) {\r\n        returnWalletAddress = _returnWalletAddress;\r\n    }\r\n\r\n    function returnBalanceToMainAccount() {\r\n        acceptDeposits = false;\r\n        payOutAmount(owner, this.balance);\r\n    }\r\n\r\n    function returnAmountToMainAccount(uint _amount) {\r\n        payOutAmount(owner, _amount);\r\n    }\r\n\r\n    function payBalanceToReturnWallet() {\r\n        acceptDeposits = false;\r\n        payOutAmount(returnWalletAddress, this.balance);\r\n    }\r\n\r\n}\r\n\r\ncontract RewardWallet is OwnedAccount {\r\n    address public returnWalletAddress;\r\n    function RewardWallet(address _returnWalletAddress) OwnedAccount(msg.sender) {\r\n        returnWalletAddress = _returnWalletAddress;\r\n    }\r\n\r\n    function payBalanceToReturnWallet() {\r\n        acceptDeposits = false;\r\n        payOutAmount(returnWalletAddress, this.balance);\r\n    }\r\n}\r\n\r\ncontract ManagementFeeWallet is OwnedAccount {\r\n    address public mgmtBodyAddress;\r\n    address public returnWalletAddress;\r\n    function ManagementFeeWallet(address _mgmtBodyAddress, address _returnWalletAddress) OwnedAccount(msg.sender) {\r\n        mgmtBodyAddress = _mgmtBodyAddress;\r\n        returnWalletAddress  = _returnWalletAddress;\r\n    }\r\n\r\n    function payManagementBodyAmount(uint _amount) {\r\n        payOutAmount(mgmtBodyAddress, _amount);\r\n    }\r\n\r\n    function payBalanceToReturnWallet() {\r\n        acceptDeposits = false;\r\n        payOutAmount(returnWalletAddress, this.balance);\r\n    }\r\n}\r\n\r\n/*\r\n * Token Creation contract, similar to other organization,for issuing tokens and initialize\r\n * its ether fund.\r\n*/\r\ncontract TokenCreationInterface is HongConfiguration {\r\n\r\n    address public managementBodyAddress;\r\n\r\n    ExtraBalanceWallet public extraBalanceWallet;\r\n    mapping (address => uint256) weiGiven;\r\n    mapping (address => uint256) public taxPaid;\r\n\r\n    function createTokenProxy(address _tokenHolder) internal returns (bool success);\r\n    function refundMyIcoInvestment();\r\n    function divisor() constant returns (uint divisor);\r\n\r\n    event evMinTokensReached(address msg_sender, uint msg_value, uint value);\r\n    event evCreatedToken(address msg_sender, uint msg_value, address indexed to, uint amount);\r\n    event evRefund(address msg_sender, uint msg_value, address indexed to, uint value, bool result);\r\n}\r\n\r\ncontract GovernanceInterface is ErrorHandler, HongConfiguration {\r\n\r\n    // The variable indicating whether the fund has achieved the inital goal or not.\r\n    // This value is automatically set, and CANNOT be reversed.\r\n    bool public isFundLocked;\r\n    bool public isFundReleased;\r\n\r\n    modifier notLocked() {if (isFundLocked) doThrow(\"notLocked\"); else {_}}\r\n    modifier onlyLocked() {if (!isFundLocked) doThrow(\"onlyLocked\"); else {_}}\r\n    modifier notReleased() {if (isFundReleased) doThrow(\"notReleased\"); else {_}}\r\n    modifier onlyHarvestEnabled() {if (!isHarvestEnabled) doThrow(\"onlyHarvestEnabled\"); else {_}}\r\n    modifier onlyDistributionNotInProgress() {if (isDistributionInProgress) doThrow(\"onlyDistributionNotInProgress\"); else {_}}\r\n    modifier onlyDistributionNotReady() {if (isDistributionReady) doThrow(\"onlyDistributionNotReady\"); else {_}}\r\n    modifier onlyDistributionReady() {if (!isDistributionReady) doThrow(\"onlyDistributionReady\"); else {_}}\r\n    modifier onlyCanIssueBountyToken(uint _amount) {\r\n        if (bountyTokensCreated + _amount > maxBountyTokens){\r\n            doThrow(\"hitMaxBounty\");\r\n        }\r\n        else {_}\r\n    }\r\n    modifier onlyFinalFiscalYear() {\r\n        // Only call harvest() in the final fiscal year\r\n        if (currentFiscalYear < 4) doThrow(\"currentFiscalYear<4\"); else {_}\r\n    }\r\n    modifier notFinalFiscalYear() {\r\n        // Token holders cannot freeze fund at the 4th Fiscal Year after passing `kickoff(4)` voting\r\n        if (currentFiscalYear >= 4) doThrow(\"currentFiscalYear>=4\"); else {_}\r\n    }\r\n    modifier onlyNotFrozen() {\r\n        if (isFreezeEnabled) doThrow(\"onlyNotFrozen\"); else {_}\r\n    }\r\n\r\n    bool public isDayThirtyChecked;\r\n    bool public isDaySixtyChecked;\r\n\r\n    uint256 public bountyTokensCreated;\r\n    uint public currentFiscalYear;\r\n    uint public lastKickoffDate;\r\n    mapping (uint => bool) public isKickoffEnabled;\r\n    bool public isFreezeEnabled;\r\n    bool public isHarvestEnabled;\r\n    bool public isDistributionInProgress;\r\n    bool public isDistributionReady;\r\n\r\n    ReturnWallet public returnWallet;\r\n    RewardWallet public rewardWallet;\r\n    ManagementFeeWallet public managementFeeWallet;\r\n\r\n    // define the governance of this organization and critical functions\r\n    function mgmtIssueBountyToken(address _recipientAddress, uint _amount) returns (bool);\r\n    function mgmtDistribute();\r\n\r\n    function mgmtInvestProject(\r\n        address _projectWallet,\r\n        uint _amount\r\n    ) returns (bool);\r\n\r\n    event evIssueManagementFee(address msg_sender, uint msg_value, uint _amount, bool _success);\r\n    event evMgmtIssueBountyToken(address msg_sender, uint msg_value, address _recipientAddress, uint _amount, bool _success);\r\n    event evMgmtDistributed(address msg_sender, uint msg_value, uint256 _amount, bool _success);\r\n    event evMgmtInvestProject(address msg_sender, uint msg_value, address _projectWallet, uint _amount, bool result);\r\n    event evLockFund(address msg_sender, uint msg_value);\r\n    event evReleaseFund(address msg_sender, uint msg_value);\r\n}\r\n\r\n\r\ncontract TokenCreation is TokenCreationInterface, Token, GovernanceInterface {\r\n    modifier onlyManagementBody {\r\n        if(msg.sender != address(managementBodyAddress)) {doThrow(\"onlyManagementBody\");} else {_}\r\n    }\r\n\r\n    function TokenCreation(\r\n        address _managementBodyAddress,\r\n        uint _closingTime) {\r\n\r\n        managementBodyAddress = _managementBodyAddress;\r\n        closingTime = _closingTime;\r\n    }\r\n\r\n    function createTokenProxy(address _tokenHolder) internal notLocked notReleased hasEther returns (bool success) {\r\n\r\n        // Business logic (but no state changes)\r\n        // setup transaction details\r\n        uint tokensSupplied = 0;\r\n        uint weiAccepted = 0;\r\n        bool wasMinTokensReached = isMinTokensReached();\r\n\r\n        var weiPerLatestHONG = weiPerInitialHONG * divisor() / 100;\r\n        uint remainingWei = msg.value;\r\n        uint tokensAvailable = tokensAvailableAtCurrentTier();\r\n        if (tokensAvailable == 0) {\r\n            doThrow(\"noTokensToSell\");\r\n            return false;\r\n        }\r\n\r\n        // Sell tokens in batches based on the current price.\r\n        while (remainingWei >= weiPerLatestHONG) {\r\n            uint tokensRequested = remainingWei / weiPerLatestHONG;\r\n            uint tokensToSellInBatch = min(tokensAvailable, tokensRequested);\r\n\r\n            // special case.  Allow the last purchase to go over the max\r\n            if (tokensAvailable == 0 && tokensCreated == maxTokensToCreate) {\r\n                tokensToSellInBatch = tokensRequested;\r\n            }\r\n\r\n            uint priceForBatch = tokensToSellInBatch * weiPerLatestHONG;\r\n\r\n            // track to total wei accepted and total tokens supplied\r\n            weiAccepted += priceForBatch;\r\n            tokensSupplied += tokensToSellInBatch;\r\n\r\n            // update state\r\n            balances[_tokenHolder] += tokensToSellInBatch;\r\n            tokensCreated += tokensToSellInBatch;\r\n            weiGiven[_tokenHolder] += priceForBatch;\r\n\r\n            // update dependent values (state has changed)\r\n            weiPerLatestHONG = weiPerInitialHONG * divisor() / 100;\r\n            remainingWei = msg.value - weiAccepted;\r\n            tokensAvailable = tokensAvailableAtCurrentTier();\r\n        }\r\n\r\n        // the caller will still pay this amount, even though it didn't buy any tokens.\r\n        weiGiven[_tokenHolder] += remainingWei;\r\n\r\n        // when the caller is paying more than 10**16 wei (0.01 Ether) per token, the extra is basically a tax.\r\n        uint256 totalTaxLevied = weiAccepted - tokensSupplied * weiPerInitialHONG;\r\n        taxPaid[_tokenHolder] += totalTaxLevied;\r\n\r\n        // State Changes (no external calls)\r\n        tryToLockFund();\r\n\r\n        // External calls\r\n        if (totalTaxLevied > 0) {\r\n            if (!extraBalanceWallet.send(totalTaxLevied)){\r\n                doThrow(\"extraBalance:sendFail\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Events.  Safe to publish these now that we know it all worked\r\n        evCreatedToken(msg.sender, msg.value, _tokenHolder, tokensSupplied);\r\n        if (!wasMinTokensReached && isMinTokensReached()) evMinTokensReached(msg.sender, msg.value, tokensCreated);\r\n        if (isFundLocked) evLockFund(msg.sender, msg.value);\r\n        if (isFundReleased) evReleaseFund(msg.sender, msg.value);\r\n        return true;\r\n    }\r\n\r\n    function refundMyIcoInvestment() noEther notLocked onlyTokenHolders {\r\n        // 1: Preconditions\r\n        if (weiGiven[msg.sender] == 0) {\r\n            doThrow(\"noWeiGiven\");\r\n            return;\r\n        }\r\n        if (balances[msg.sender] > tokensCreated) {\r\n            doThrow(\"invalidTokenCount\");\r\n            return;\r\n         }\r\n\r\n        // 2: Business logic\r\n        bool wasMinTokensReached = isMinTokensReached();\r\n        var tmpWeiGiven = weiGiven[msg.sender];\r\n        var tmpTaxPaidBySender = taxPaid[msg.sender];\r\n        var tmpSenderBalance = balances[msg.sender];\r\n\r\n        var amountToRefund = tmpWeiGiven;\r\n\r\n        // 3: state changes.\r\n        balances[msg.sender] = 0;\r\n        weiGiven[msg.sender] = 0;\r\n        taxPaid[msg.sender] = 0;\r\n        tokensCreated -= tmpSenderBalance;\r\n\r\n        // 4: external calls\r\n        // Pull taxes paid back into this contract (they would have been paid into the extraBalance account)\r\n        extraBalanceWallet.returnAmountToMainAccount(tmpTaxPaidBySender);\r\n\r\n        // If that works, then do a refund\r\n        if (!msg.sender.send(amountToRefund)) {\r\n            evRefund(msg.sender, msg.value, msg.sender, amountToRefund, false);\r\n            doThrow(\"refund:SendFailed\");\r\n            return;\r\n        }\r\n\r\n        evRefund(msg.sender, msg.value, msg.sender, amountToRefund, true);\r\n        if (!wasMinTokensReached && isMinTokensReached()) evMinTokensReached(msg.sender, msg.value, tokensCreated);\r\n    }\r\n\r\n    // Using a function rather than a state variable, as it reduces the risk of inconsistent state\r\n    function isMinTokensReached() constant returns (bool) {\r\n        return tokensCreated >= minTokensToCreate;\r\n    }\r\n\r\n    function isMaxTokensReached() constant returns (bool) {\r\n        return tokensCreated >= maxTokensToCreate;\r\n    }\r\n\r\n    function mgmtIssueBountyToken(\r\n        address _recipientAddress,\r\n        uint _amount\r\n    ) noEther onlyManagementBody onlyCanIssueBountyToken(_amount) returns (bool){\r\n        // send token to the specified address\r\n        balances[_recipientAddress] += _amount;\r\n        bountyTokensCreated += _amount;\r\n\r\n        // event\r\n        evMgmtIssueBountyToken(msg.sender, msg.value, _recipientAddress, _amount, true);\r\n\r\n    }\r\n\r\n    function mgmtDistribute() onlyManagementBody hasEther onlyHarvestEnabled onlyDistributionNotReady {\r\n        distributeDownstream(mgmtRewardPercentage);\r\n    }\r\n\r\n    function distributeDownstream(uint _mgmtPercentage) internal onlyDistributionNotInProgress {\r\n\r\n        // transfer all balance from the following accounts\r\n        // (1) HONG main account,\r\n        // (2) managementFeeWallet,\r\n        // (3) rewardWallet\r\n        // (4) extraBalanceWallet\r\n        // to returnWallet\r\n\r\n        // And allocate _mgmtPercentage of the fund to ManagementBody\r\n\r\n        // State changes first (even though it feels backwards)\r\n        isDistributionInProgress = true;\r\n        isDistributionReady = true;\r\n\r\n        payBalanceToReturnWallet();\r\n        managementFeeWallet.payBalanceToReturnWallet();\r\n        rewardWallet.payBalanceToReturnWallet();\r\n        extraBalanceWallet.payBalanceToReturnWallet();\r\n\r\n        // transfer _mgmtPercentage of returns to mgmt Wallet\r\n        if (_mgmtPercentage > 0) returnWallet.payManagementBodyPercent(_mgmtPercentage);\r\n        returnWallet.switchToDistributionMode(tokensCreated + bountyTokensCreated);\r\n\r\n        // Token holder can claim the remaining fund (the total amount harvested/ to be distributed) starting from here\r\n        evMgmtDistributed(msg.sender, msg.value, returnWallet.balance, true);\r\n        isDistributionInProgress = false;\r\n    }\r\n\r\n    function payBalanceToReturnWallet() internal {\r\n        if (!returnWallet.send(this.balance))\r\n            doThrow(\"payBalanceToReturnWallet:sendFailed\");\r\n            return;\r\n    }\r\n\r\n    function min(uint a, uint b) constant internal returns (uint) {\r\n        return (a < b) ? a : b;\r\n    }\r\n\r\n    function tryToLockFund() internal {\r\n        // ICO Diagram: https://github.com/hongcoin/DO/wiki/ICO-Period-and-Target\r\n\r\n        if (isFundReleased) {\r\n            // Do not change the state anymore\r\n            return;\r\n        }\r\n\r\n        // Case A\r\n        isFundLocked = isMaxTokensReached();\r\n\r\n        // if we've reached the 30 day mark, try to lock the fund\r\n        if (!isFundLocked && !isDayThirtyChecked && (now >= closingTime)) {\r\n            if (isMinTokensReached()) {\r\n                // Case B\r\n                isFundLocked = true;\r\n            }\r\n            isDayThirtyChecked = true;\r\n        }\r\n\r\n        // if we've reached the 60 day mark, try to lock the fund\r\n        if (!isFundLocked && !isDaySixtyChecked && (now >= (closingTime + closingTimeExtensionPeriod))) {\r\n            if (isMinTokensReached()) {\r\n                // Case C\r\n                isFundLocked = true;\r\n            }\r\n            isDaySixtyChecked = true;\r\n        }\r\n\r\n        if (isDaySixtyChecked && !isMinTokensReached()) {\r\n            // Case D\r\n            // Mark the release state. No fund should be accepted anymore\r\n            isFundReleased = true;\r\n        }\r\n    }\r\n\r\n    function tokensAvailableAtTierInternal(uint8 _currentTier, uint _tokensPerTier, uint _tokensCreated) constant returns (uint) {\r\n        uint tierThreshold = (_currentTier+1) * _tokensPerTier;\r\n\r\n        // never go above maxTokensToCreate, which could happen if the max is not a multiple of _tokensPerTier\r\n        if (tierThreshold > maxTokensToCreate) {\r\n            tierThreshold = maxTokensToCreate;\r\n        }\r\n\r\n        // this can happen on the final purchase in the last tier\r\n        if (_tokensCreated > tierThreshold) {\r\n            return 0;\r\n        }\r\n\r\n        return tierThreshold - _tokensCreated;\r\n    }\r\n\r\n    function tokensAvailableAtCurrentTier() constant returns (uint) {\r\n        return tokensAvailableAtTierInternal(getCurrentTier(), tokensPerTier, tokensCreated);\r\n    }\r\n\r\n    function getCurrentTier() constant returns (uint8) {\r\n        uint8 tier = (uint8) (tokensCreated / tokensPerTier);\r\n        return (tier > 4) ? 4 : tier;\r\n    }\r\n\r\n    function pricePerTokenAtCurrentTier() constant returns (uint) {\r\n        return weiPerInitialHONG * divisor() / 100;\r\n    }\r\n\r\n    function divisor() constant returns (uint divisor) {\r\n\r\n        // Quantity divisor model: based on total quantity of coins issued\r\n        // Price ranged from 1.0 to 1.20 Ether for all HONG Tokens with a 0.05 ETH increase for each tier\r\n\r\n        // The number of (base unit) tokens per wei is calculated\r\n        // as `msg.value` * 100 / `divisor`\r\n\r\n        return 100 + getCurrentTier() * 5;\r\n    }\r\n}\r\n\r\n\r\ncontract HONGInterface is ErrorHandler, HongConfiguration {\r\n\r\n    // we do not have grace period. Once the goal is reached, the fund is secured\r\n\r\n    address public managementBodyAddress;\r\n\r\n    // 3 most important votings in blockchain\r\n    mapping (uint => mapping (address => uint)) public votedKickoff;\r\n    mapping (address => uint) public votedFreeze;\r\n    mapping (address => uint) public votedHarvest;\r\n    mapping (uint => uint256) public supportKickoffQuorum;\r\n    uint256 public supportFreezeQuorum;\r\n    uint256 public supportHarvestQuorum;\r\n    uint public totalInitialBalance;\r\n    uint public annualManagementFee;\r\n\r\n    function voteToKickoffNewFiscalYear();\r\n    function voteToFreezeFund();\r\n    function recallVoteToFreezeFund();\r\n    function voteToHarvestFund();\r\n\r\n    function collectMyReturn();\r\n\r\n    // Trigger the following events when the voting result is available\r\n    event evKickoff(address msg_sender, uint msg_value, uint _fiscal);\r\n    event evFreeze(address msg_sender, uint msg_value);\r\n    event evHarvest(address msg_sender, uint msg_value);\r\n}\r\n\r\n\r\n\r\n// The HONG contract itself\r\ncontract HONG is HONGInterface, Token, TokenCreation {\r\n\r\n    function HONG(\r\n        address _managementBodyAddress,\r\n        uint _closingTime,\r\n        uint _closingTimeExtensionPeriod,\r\n        uint _lastKickoffDateBuffer,\r\n        uint _minTokensToCreate,\r\n        uint _maxTokensToCreate,\r\n        uint _tokensPerTier,\r\n        bool _isInTestMode\r\n    ) TokenCreation(_managementBodyAddress, _closingTime) {\r\n\r\n        managementBodyAddress = _managementBodyAddress;\r\n        closingTimeExtensionPeriod = _closingTimeExtensionPeriod;\r\n        lastKickoffDateBuffer = _lastKickoffDateBuffer;\r\n\r\n        minTokensToCreate = _minTokensToCreate;\r\n        maxTokensToCreate = _maxTokensToCreate;\r\n        tokensPerTier = _tokensPerTier;\r\n        isInTestMode = _isInTestMode;\r\n\r\n        returnWallet = new ReturnWallet(managementBodyAddress);\r\n        rewardWallet = new RewardWallet(address(returnWallet));\r\n        managementFeeWallet = new ManagementFeeWallet(managementBodyAddress, address(returnWallet));\r\n        extraBalanceWallet = new ExtraBalanceWallet(address(returnWallet));\r\n\r\n        if (address(extraBalanceWallet) == 0)\r\n            doThrow(\"extraBalanceWallet:0\");\r\n        if (address(returnWallet) == 0)\r\n            doThrow(\"returnWallet:0\");\r\n        if (address(rewardWallet) == 0)\r\n            doThrow(\"rewardWallet:0\");\r\n        if (address(managementFeeWallet) == 0)\r\n            doThrow(\"managementFeeWallet:0\");\r\n    }\r\n\r\n    function () returns (bool success) {\r\n        if (!isFromManagedAccount()) {\r\n            // We do not accept donation here. Any extra amount sent to us after fund locking process, will be refunded\r\n            return createTokenProxy(msg.sender);\r\n        }\r\n        else {\r\n            evRecord(msg.sender, msg.value, \"Recevied ether from ManagedAccount\");\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function isFromManagedAccount() internal returns (bool) {\r\n        return msg.sender == address(extraBalanceWallet)\r\n            || msg.sender == address(returnWallet)\r\n            || msg.sender == address(rewardWallet)\r\n            || msg.sender == address(managementFeeWallet);\r\n    }\r\n\r\n    /*\r\n     * Voting for some critical steps, on blockchain\r\n     */\r\n    function voteToKickoffNewFiscalYear() onlyTokenHolders noEther onlyLocked {\r\n        // this is the only valid fiscal year parameter, so there's no point in letting the caller pass it in.\r\n        // Best case is they get it wrong and we throw, worst case is the get it wrong and there's some exploit\r\n        uint _fiscal = currentFiscalYear + 1;\r\n\r\n        if(!isKickoffEnabled[1]){  // if the first fiscal year is not kicked off yet\r\n            // accept voting\r\n\r\n        }else if(currentFiscalYear <= 3){  // if there was any kickoff() enabled before already\r\n\r\n            if(lastKickoffDate + lastKickoffDateBuffer < now){ // 2 months from the end of the fiscal year\r\n                // accept voting\r\n            }else{\r\n                // we do not accept early kickoff\r\n                doThrow(\"kickOff:tooEarly\");\r\n                return;\r\n            }\r\n        }else{\r\n            // do not accept kickoff anymore after the 4th year\r\n            doThrow(\"kickOff:4thYear\");\r\n            return;\r\n        }\r\n\r\n\r\n        supportKickoffQuorum[_fiscal] -= votedKickoff[_fiscal][msg.sender];\r\n        supportKickoffQuorum[_fiscal] += balances[msg.sender];\r\n        votedKickoff[_fiscal][msg.sender] = balances[msg.sender];\r\n\r\n\r\n        uint threshold = (kickoffQuorumPercent*(tokensCreated + bountyTokensCreated)) / 100;\r\n        if(supportKickoffQuorum[_fiscal] > threshold) {\r\n            if(_fiscal == 1){\r\n                // transfer fund in extraBalance to main account\r\n                extraBalanceWallet.returnBalanceToMainAccount();\r\n\r\n                // reserve mgmtFeePercentage of whole fund to ManagementFeePoolWallet\r\n                totalInitialBalance = this.balance;\r\n                uint fundToReserve = (totalInitialBalance * mgmtFeePercentage) / 100;\r\n                annualManagementFee = fundToReserve / 4;\r\n                if(!managementFeeWallet.send(fundToReserve)){\r\n                    doThrow(\"kickoff:ManagementFeePoolWalletFail\");\r\n                    return;\r\n                }\r\n\r\n            }\r\n            isKickoffEnabled[_fiscal] = true;\r\n            currentFiscalYear = _fiscal;\r\n            lastKickoffDate = now;\r\n\r\n            // transfer annual management fee from reservedWallet to mgmtWallet (external)\r\n            managementFeeWallet.payManagementBodyAmount(annualManagementFee);\r\n\r\n            evKickoff(msg.sender, msg.value, _fiscal);\r\n            evIssueManagementFee(msg.sender, msg.value, annualManagementFee, true);\r\n        }\r\n    }\r\n\r\n    function voteToFreezeFund() onlyTokenHolders noEther onlyLocked notFinalFiscalYear onlyDistributionNotInProgress {\r\n\r\n        supportFreezeQuorum -= votedFreeze[msg.sender];\r\n        supportFreezeQuorum += balances[msg.sender];\r\n        votedFreeze[msg.sender] = balances[msg.sender];\r\n\r\n        uint threshold = ((tokensCreated + bountyTokensCreated) * freezeQuorumPercent) / 100;\r\n        if(supportFreezeQuorum > threshold){\r\n            isFreezeEnabled = true;\r\n            distributeDownstream(0);\r\n            evFreeze(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    function recallVoteToFreezeFund() onlyTokenHolders onlyNotFrozen noEther {\r\n        supportFreezeQuorum -= votedFreeze[msg.sender];\r\n        votedFreeze[msg.sender] = 0;\r\n    }\r\n\r\n    function voteToHarvestFund() onlyTokenHolders noEther onlyLocked onlyFinalFiscalYear {\r\n\r\n        supportHarvestQuorum -= votedHarvest[msg.sender];\r\n        supportHarvestQuorum += balances[msg.sender];\r\n        votedHarvest[msg.sender] = balances[msg.sender];\r\n\r\n        uint threshold = ((tokensCreated + bountyTokensCreated) * harvestQuorumPercent) / 100;\r\n        if(supportHarvestQuorum > threshold) {\r\n            isHarvestEnabled = true;\r\n            evHarvest(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    function collectMyReturn() onlyTokenHolders noEther onlyDistributionReady {\r\n        uint tokens = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        returnWallet.payTokenHolderBasedOnTokenCount(msg.sender, tokens);\r\n    }\r\n\r\n    function mgmtInvestProject(\r\n        address _projectWallet,\r\n        uint _amount\r\n    ) onlyManagementBody hasEther returns (bool _success) {\r\n\r\n        if(!isKickoffEnabled[currentFiscalYear] || isFreezeEnabled || isHarvestEnabled){\r\n            evMgmtInvestProject(msg.sender, msg.value, _projectWallet, _amount, false);\r\n            return;\r\n        }\r\n\r\n        if(_amount >= this.balance){\r\n            doThrow(\"failed:mgmtInvestProject: amount >= actualBalance\");\r\n            return;\r\n        }\r\n\r\n        // send the balance (_amount) to _projectWallet\r\n        if (!_projectWallet.call.value(_amount)()) {\r\n            doThrow(\"failed:mgmtInvestProject: cannot send to _projectWallet\");\r\n            return;\r\n        }\r\n\r\n        evMgmtInvestProject(msg.sender, msg.value, _projectWallet, _amount, true);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n\r\n        // Update kickoff voting record for the next fiscal year for an address, and the total quorum\r\n        if(currentFiscalYear < 4){\r\n            if(votedKickoff[currentFiscalYear+1][msg.sender] > _value){\r\n                votedKickoff[currentFiscalYear+1][msg.sender] -= _value;\r\n                supportKickoffQuorum[currentFiscalYear+1] -= _value;\r\n            }else{\r\n                supportKickoffQuorum[currentFiscalYear+1] -= votedKickoff[currentFiscalYear+1][msg.sender];\r\n                votedKickoff[currentFiscalYear+1][msg.sender] = 0;\r\n            }\r\n        }\r\n\r\n        // Update Freeze and Harvest voting records for an address, and the total quorum\r\n        if(votedFreeze[msg.sender] > _value){\r\n            votedFreeze[msg.sender] -= _value;\r\n            supportFreezeQuorum -= _value;\r\n        }else{\r\n            supportFreezeQuorum -= votedFreeze[msg.sender];\r\n            votedFreeze[msg.sender] = 0;\r\n        }\r\n\r\n        if(votedHarvest[msg.sender] > _value){\r\n            votedHarvest[msg.sender] -= _value;\r\n            supportHarvestQuorum -= _value;\r\n        }else{\r\n            supportHarvestQuorum -= votedHarvest[msg.sender];\r\n            votedHarvest[msg.sender] = 0;\r\n        }\r\n\r\n        if (isFundLocked && super.transfer(_to, _value)) {\r\n            return true;\r\n        } else {\r\n            if(!isFundLocked){\r\n                doThrow(\"failed:transfer: isFundLocked is false\");\r\n            }else{\r\n                doThrow(\"failed:transfer: cannot send send to _projectWallet\");\r\n            }\r\n            return;\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"isFundReleased\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mgmtDistribute\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiPerInitialHONG\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"votedHarvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTokensToCreate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supportHarvestQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraBalanceWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInitialBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divisor\",\"outputs\":[{\"name\":\"divisor\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"voteToHarvestFund\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricePerTokenAtCurrentTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mgmtFeePercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensCreated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDistributionReady\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTimeExtensionPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"votedKickoff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastKickoffDateBuffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDayThirtyChecked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFreezeEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectMyReturn\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMinTokensReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDistributionInProgress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastKickoffDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managementFeeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supportFreezeQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAvailableAtCurrentTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFundLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"votedFreeze\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kickoffQuorumPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMaxTokensReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freezeQuorumPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokensToCreate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_projectWallet\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mgmtInvestProject\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isHarvestEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"taxPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBountyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"voteToKickoffNewFiscalYear\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"supportKickoffQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInTestMode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managementBodyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"harvestQuorumPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isKickoffEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mgmtRewardPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recallVoteToFreezeFund\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyTokensCreated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"annualManagementFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_currentTier\",\"type\":\"uint8\"},{\"name\":\"_tokensPerTier\",\"type\":\"uint256\"},{\"name\":\"_tokensCreated\",\"type\":\"uint256\"}],\"name\":\"tokensAvailableAtTierInternal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDaySixtyChecked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"voteToFreezeFund\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundMyIcoInvestment\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipientAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mgmtIssueBountyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentFiscalYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"_managementBodyAddress\",\"type\":\"address\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_closingTimeExtensionPeriod\",\"type\":\"uint256\"},{\"name\":\"_lastKickoffDateBuffer\",\"type\":\"uint256\"},{\"name\":\"_minTokensToCreate\",\"type\":\"uint256\"},{\"name\":\"_maxTokensToCreate\",\"type\":\"uint256\"},{\"name\":\"_tokensPerTier\",\"type\":\"uint256\"},{\"name\":\"_isInTestMode\",\"type\":\"bool\"}],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_success\",\"type\":\"bool\"}],\"name\":\"evIssueManagementFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_recipientAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_success\",\"type\":\"bool\"}],\"name\":\"evMgmtIssueBountyToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_success\",\"type\":\"bool\"}],\"name\":\"evMgmtDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_projectWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"evMgmtInvestProject\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"}],\"name\":\"evLockFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"}],\"name\":\"evReleaseFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"evTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"evMinTokensReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"evCreatedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"evRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_fiscal\",\"type\":\"uint256\"}],\"name\":\"evKickoff\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"}],\"name\":\"evFreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"}],\"name\":\"evHarvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"msg_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"evRecord\",\"type\":\"event\"}]", "ContractName": "HONG", "CompilerVersion": "v0.3.5+commit.5f97274", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b79ab5993cef2e0b714a66f3eda73b55de812d310000000000000000000000000000000000000000000000000000000057ebbed00000000000000000000000000000000000000000000000000000000000278d00000000000000000000000000000000000000000000000000000000000190c8000000000000000000000000000000000000000000000000000000000008f0d180000000000000000000000000000000000000000000000000000000000ee6b2800000000000000000000000000000000000000000000000000000000002faf0800000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}