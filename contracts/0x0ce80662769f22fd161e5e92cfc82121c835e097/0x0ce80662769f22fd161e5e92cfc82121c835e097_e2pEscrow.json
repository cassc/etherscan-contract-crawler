{"SourceCode": "pragma solidity 0.4.23;\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n */\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal pure returns (uint256) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal pure returns (uint256) {\r\n    uint c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal pure returns (uint256) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Stoppable\r\n * @dev Base contract which allows children to implement final irreversible stop mechanism.\r\n */\r\ncontract Stoppable is Pausable {\r\n  event Stop();\r\n\r\n  bool public stopped = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not stopped.\r\n   */\r\n  modifier whenNotStopped() {\r\n    require(!stopped);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is stopped.\r\n   */\r\n  modifier whenStopped() {\r\n    require(stopped);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function stop() public onlyOwner whenNotStopped {\r\n    stopped = true;\r\n    emit Stop();\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Eth2Phone Escrow Contract\r\n * @dev Contract allows to send ether through verifier (owner of contract).\r\n * \r\n * Only verifier can initiate withdrawal to recipient's address. \r\n * Verifier cannot choose recipient's address without \r\n * transit private key generated by sender. \r\n * \r\n * Sender is responsible to provide transit private key\r\n * to recipient off-chain.\r\n * \r\n * Recepient signs address to receive with transit private key and \r\n * provides signed address to verification server. \r\n * (See VerifyTransferSignature method for details.)\r\n * \r\n * Verifier verifies off-chain the recipient in accordance with verification \r\n * conditions (e.g., phone ownership via SMS authentication) and initiates\r\n * withdrawal to the address provided by recipient.\r\n * (See withdraw method for details.)\r\n * \r\n * Verifier charges commission for it's services.\r\n * \r\n * Sender is able to cancel transfer if it's not yet cancelled or withdrawn\r\n * by recipient.\r\n * (See cancelTransfer method for details.)\r\n */\r\ncontract e2pEscrow is Stoppable, SafeMath {\r\n\r\n  // fixed amount of wei accrued to verifier with each transfer\r\n  uint public commissionFee;\r\n\r\n  // verifier can withdraw this amount from smart-contract\r\n  uint public commissionToWithdraw; // in wei\r\n\r\n  // verifier's address\r\n  address public verifier;\r\n    \r\n  /*\r\n   * EVENTS\r\n   */\r\n  event LogDeposit(\r\n\t\t   address indexed sender,\r\n\t\t   address indexed transitAddress,\r\n\t\t   uint amount,\r\n\t\t      uint commission\r\n\t\t   );\r\n\r\n  event LogCancel(\r\n\t\t  address indexed sender,\r\n\t\t  address indexed transitAddress\r\n\t\t  );\r\n\r\n  event LogWithdraw(\r\n\t\t    address indexed sender,\r\n\t\t    address indexed transitAddress,\r\n\t\t    address indexed recipient,\r\n\t\t    uint amount\r\n\t\t    );\r\n\r\n  event LogWithdrawCommission(uint commissionAmount);\r\n\r\n  event LogChangeFixedCommissionFee(\r\n\t\t\t\t    uint oldCommissionFee,\r\n\t\t\t\t    uint newCommissionFee\r\n\t\t\t\t    );\r\n  \r\n  event LogChangeVerifier(\r\n\t\t\t  address oldVerifier,\r\n\t\t\t  address newVerifier\r\n\t\t\t  );  \r\n  \r\n  struct Transfer {\r\n    address from;\r\n    uint amount; // in wei\r\n  }\r\n\r\n  // Mappings of transitAddress => Transfer Struct\r\n  mapping (address => Transfer) transferDct;\r\n\r\n\r\n  /**\r\n   * @dev Contructor that sets msg.sender as owner (verifier) in Ownable\r\n   * and sets verifier's fixed commission fee.\r\n   * @param _commissionFee uint Verifier's fixed commission for each transfer\r\n   */\r\n  constructor(uint _commissionFee, address _verifier) public {\r\n    commissionFee = _commissionFee;\r\n    verifier = _verifier;\r\n  }\r\n\r\n\r\n  modifier onlyVerifier() {\r\n    require(msg.sender == verifier);\r\n    _;\r\n  }\r\n  \r\n  /**\r\n   * @dev Deposit ether to smart-contract and create transfer.\r\n   * Transit address is assigned to transfer by sender. \r\n   * Recipient should sign withrawal address with the transit private key \r\n   * \r\n   * @param _transitAddress transit address assigned to transfer.\r\n   * @return True if success.\r\n   */\r\n  function deposit(address _transitAddress)\r\n                            public\r\n                            whenNotPaused\r\n                            whenNotStopped\r\n                            payable\r\n    returns(bool)\r\n  {\r\n    // can not override existing transfer\r\n    require(transferDct[_transitAddress].amount == 0);\r\n\r\n    require(msg.value > commissionFee);\r\n\r\n    // saving transfer details\r\n    transferDct[_transitAddress] = Transfer(\r\n\t\t\t\t\t    msg.sender,\r\n\t\t\t\t\t    safeSub(msg.value, commissionFee)//amount = msg.value - comission\r\n\t\t\t\t\t    );\r\n\r\n    // accrue verifier's commission\r\n    commissionToWithdraw = safeAdd(commissionToWithdraw, commissionFee);\r\n\r\n    // log deposit event\r\n    emit LogDeposit(msg.sender, _transitAddress, msg.value, commissionFee);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Change verifier's fixed commission fee.\r\n   * Only owner can change commision fee.\r\n   * \r\n   * @param _newCommissionFee uint New verifier's fixed commission\r\n   * @return True if success.\r\n   */\r\n  function changeFixedCommissionFee(uint _newCommissionFee)\r\n                          public\r\n                          whenNotPaused\r\n                          whenNotStopped\r\n                          onlyOwner\r\n    returns(bool success)\r\n  {\r\n    uint oldCommissionFee = commissionFee;\r\n    commissionFee = _newCommissionFee;\r\n    emit LogChangeFixedCommissionFee(oldCommissionFee, commissionFee);\r\n    return true;\r\n  }\r\n\r\n  \r\n  /**\r\n   * @dev Change verifier's address.\r\n   * Only owner can change verifier's address.\r\n   * \r\n   * @param _newVerifier address New verifier's address\r\n   * @return True if success.\r\n   */\r\n  function changeVerifier(address _newVerifier)\r\n                          public\r\n                          whenNotPaused\r\n                          whenNotStopped\r\n                          onlyOwner\r\n    returns(bool success)\r\n  {\r\n    address oldVerifier = verifier;\r\n    verifier = _newVerifier;\r\n    emit LogChangeVerifier(oldVerifier, verifier);\r\n    return true;\r\n  }\r\n\r\n  \r\n  /**\r\n   * @dev Transfer accrued commission to verifier's address.\r\n   * @return True if success.\r\n   */\r\n  function withdrawCommission()\r\n                        public\r\n                        whenNotPaused\r\n    returns(bool success)\r\n  {\r\n    uint commissionToTransfer = commissionToWithdraw;\r\n    commissionToWithdraw = 0;\r\n    owner.transfer(commissionToTransfer); // owner is verifier\r\n\r\n    emit LogWithdrawCommission(commissionToTransfer);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Get transfer details.\r\n   * @param _transitAddress transit address assigned to transfer\r\n   * @return Transfer details (id, sender, amount)\r\n   */\r\n  function getTransfer(address _transitAddress)\r\n            public\r\n            constant\r\n    returns (\r\n\t     address id,\r\n\t     address from, // transfer sender\r\n\t     uint amount) // in wei\r\n  {\r\n    Transfer memory transfer = transferDct[_transitAddress];\r\n    return (\r\n\t    _transitAddress,\r\n\t    transfer.from,\r\n\t        transfer.amount\r\n\t    );\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Cancel transfer and get sent ether back. Only transfer sender can\r\n   * cancel transfer.\r\n   * @param _transitAddress transit address assigned to transfer\r\n   * @return True if success.\r\n   */\r\n  function cancelTransfer(address _transitAddress) public returns (bool success) {\r\n    Transfer memory transferOrder = transferDct[_transitAddress];\r\n\r\n    // only sender can cancel transfer;\r\n    require(msg.sender == transferOrder.from);\r\n\r\n    delete transferDct[_transitAddress];\r\n    \r\n    // transfer ether to recipient's address\r\n    msg.sender.transfer(transferOrder.amount);\r\n\r\n    // log cancel event\r\n    emit LogCancel(msg.sender, _transitAddress);\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Verify that address is signed with correct verification private key.\r\n   * @param _transitAddress transit address assigned to transfer\r\n   * @param _recipient address Signed address.\r\n   * @param _v ECDSA signature parameter v.\r\n   * @param _r ECDSA signature parameters r.\r\n   * @param _s ECDSA signature parameters s.\r\n   * @return True if signature is correct.\r\n   */\r\n  function verifySignature(\r\n\t\t\t   address _transitAddress,\r\n\t\t\t   address _recipient,\r\n\t\t\t   uint8 _v,\r\n\t\t\t   bytes32 _r,\r\n\t\t\t   bytes32 _s)\r\n    public pure returns(bool success)\r\n  {\r\n    bytes32 prefixedHash = keccak256(\"\\x19Ethereum Signed Message:\\n32\", _recipient);\r\n    address retAddr = ecrecover(prefixedHash, _v, _r, _s);\r\n    return retAddr == _transitAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev Verify that address is signed with correct private key for\r\n   * verification public key assigned to transfer.\r\n   * @param _transitAddress transit address assigned to transfer\r\n   * @param _recipient address Signed address.\r\n   * @param _v ECDSA signature parameter v.\r\n   * @param _r ECDSA signature parameters r.\r\n   * @param _s ECDSA signature parameters s.\r\n   * @return True if signature is correct.\r\n   */\r\n  function verifyTransferSignature(\r\n\t\t\t\t   address _transitAddress,\r\n\t\t\t\t   address _recipient,\r\n\t\t\t\t   uint8 _v,\r\n\t\t\t\t   bytes32 _r,\r\n\t\t\t\t   bytes32 _s)\r\n    public pure returns(bool success)\r\n  {\r\n    return (verifySignature(_transitAddress,\r\n\t\t\t    _recipient, _v, _r, _s));\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw transfer to recipient's address if it is correctly signed\r\n   * with private key for verification public key assigned to transfer.\r\n   * \r\n   * @param _transitAddress transit address assigned to transfer\r\n   * @param _recipient address Signed address.\r\n   * @param _v ECDSA signature parameter v.\r\n   * @param _r ECDSA signature parameters r.\r\n   * @param _s ECDSA signature parameters s.\r\n   * @return True if success.\r\n   */\r\n  function withdraw(\r\n\t\t    address _transitAddress,\r\n\t\t    address _recipient,\r\n\t\t    uint8 _v,\r\n\t\t    bytes32 _r,\r\n\t\t    bytes32 _s\r\n\t\t    )\r\n    public\r\n    onlyVerifier // only through verifier can withdraw transfer;\r\n    whenNotPaused\r\n    whenNotStopped\r\n    returns (bool success)\r\n  {\r\n    Transfer memory transferOrder = transferDct[_transitAddress];\r\n\r\n    // verifying signature\r\n    require(verifySignature(_transitAddress,\r\n\t\t     _recipient, _v, _r, _s ));\r\n\r\n    delete transferDct[_transitAddress];\r\n\r\n    // transfer ether to recipient's address\r\n    _recipient.transfer(transferOrder.amount);\r\n\r\n    // log withdraw event\r\n    emit LogWithdraw(transferOrder.from, _transitAddress, _recipient, transferOrder.amount);\r\n\r\n    return true;\r\n  }\r\n\r\n  // fallback function - do not receive ether by default\r\n  function() public payable {\r\n    revert();\r\n  }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionToWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transitAddress\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"verifySignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawCommission\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transitAddress\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"verifyTransferSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCommissionFee\",\"type\":\"uint256\"}],\"name\":\"changeFixedCommissionFee\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transitAddress\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transitAddress\",\"type\":\"address\"}],\"name\":\"cancelTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVerifier\",\"type\":\"address\"}],\"name\":\"changeVerifier\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transitAddress\",\"type\":\"address\"}],\"name\":\"getTransfer\",\"outputs\":[{\"name\":\"id\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transitAddress\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_commissionFee\",\"type\":\"uint256\"},{\"name\":\"_verifier\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transitAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"commission\",\"type\":\"uint256\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transitAddress\",\"type\":\"address\"}],\"name\":\"LogCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transitAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"commissionAmount\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawCommission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldCommissionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newCommissionFee\",\"type\":\"uint256\"}],\"name\":\"LogChangeFixedCommissionFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldVerifier\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newVerifier\",\"type\":\"address\"}],\"name\":\"LogChangeVerifier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Stop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]", "ContractName": "e2pEscrow", "CompilerVersion": "v0.4.23+commit.124ca40d", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000002386f26fc100000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b09d845a1ccae545a3d2818772a714c6c0412e02e25a6b1003658ab8369970f6"}