{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/bill/TBillSimple.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {DTBT} from './DTBT.sol';\\nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\\nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol';\\nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol';\\n\\ninterface IETF is IERC20Detailed {\\n  enum Etypes {\\n    OPENED,\\n    CLOSED\\n  }\\n\\n  function execute(\\n    address _target,\\n    uint _value,\\n    bytes calldata _data,\\n    bool isUnderlying\\n  ) external returns (bytes memory _returnValue);\\n\\n  function isCompletedCollect() external view returns (bool);\\n\\n  function etype() external view returns (Etypes);\\n\\n  function adminList(address) external view returns (bool);\\n\\n  function getController() external view returns (address);\\n\\n  function etfStatus()\\n    external\\n    view\\n    returns (\\n      uint256 collectPeriod,\\n      uint256 collectEndTime,\\n      uint256 closurePeriod,\\n      uint256 closureEndTime,\\n      uint256 upperCap,\\n      uint256 floorCap,\\n      uint256 managerFee,\\n      uint256 redeemFee,\\n      uint256 issueFee,\\n      uint256 perfermanceFee,\\n      uint256 startClaimFeeTime\\n    );\\n\\n  function bPool() external view virtual returns (LiquidityPoolActions);\\n}\\n\\ninterface LiquidityPoolActions {\\n  function getCurrentTokens() external view virtual returns (address[] memory);\\n\\n  function isBound(address t) external view returns (bool);\\n}\\n\\ninterface IFactory {\\n  function isPaused() external view returns (bool);\\n}\\n\\ncontract TBillSimple is Ownable {\\n  using SafeERC20 for IERC20Detailed;\\n\\n  address public stableCoinReceiver = 0x5a47DF2aaec5ad2F95A6a353c906559075f94186; // return stbt\\n  address public sTBTReceiver = 0xDEE9Ed3B19d104ADBbE255B6bEFC680b4eaAAda3; // return usdc\\n\\n  IETF public etf;\\n  IFactory public factory;\\n\\n  DTBT public dtbt;\\n  IERC20Detailed stbt = IERC20Detailed(0x530824DA86689C9C17CdC2871Ff29B058345b44a);\\n  IERC20Detailed stableCoin = IERC20Detailed(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\\n\\n  event SendStaleCoin(address caller, address etf, address sendToken, uint sendAmount);\\n  event SendSTBT(address caller, address etf, address snedToken, uint sendAmount);\\n  event UpdateDTBTAmount(address caller, address etf, address dtbt, uint newAmount);\\n\\n  event UpdateETFAddr(address caller, address oldValue, address newValue);\\n  event UpdateStbtAddr(address caller, address oldValue, address newValue);\\n  event UpdateStableCoinAddr(address caller, address oldValue, address newValue);\\n  event UpdateStableCoinReceiverAddr(address caller, address oldValue, address newValue);\\n  event UpdateStbtReceiverAddr(address caller, address oldValue, address newValue);\\n\\n  constructor(IETF etf_, IFactory factory_, address dtbt_) public {\\n    require(etf_.etype() == IETF.Etypes.CLOSED, 'ERR_ONLY_SUPPORT_CLOSED_ETF');\\n    require(\\n      address(etf_) != address(0) && address(factory_) != address(0) && dtbt_ != address(0),\\n      'ERR_ZERO_ADDRESS'\\n    );\\n    factory = factory_;\\n    etf = etf_;\\n    dtbt = DTBT(dtbt_);\\n  }\\n\\n  enum CurrentPeriod {\\n    WaitSendStableCoin,\\n    WaitSendSTBT\\n  }\\n\\n  CurrentPeriod public currentPeriod = CurrentPeriod.WaitSendStableCoin;\\n\\n  // only entry to make stable coin and stbt swap\\n  function swap() external {\\n    if (currentPeriod == CurrentPeriod.WaitSendStableCoin) {\\n      (, uint256 collectEndTime, , uint256 closureEndTime, , , , , , , ) = etf.etfStatus();\\n      require(collectEndTime < block.timestamp && closureEndTime > block.timestamp, 'ERR_PERIOD');\\n      _sendStableCoin();\\n      currentPeriod = CurrentPeriod.WaitSendSTBT;\\n    } else {\\n      _sendSTBT();\\n      currentPeriod = CurrentPeriod.WaitSendStableCoin;\\n    }\\n  }\\n\\n  // update stable coin on etf and burn dtbt\\n  function rebalance() external _checkTx {\\n    require(currentPeriod == CurrentPeriod.WaitSendStableCoin, 'ERR_NOT_WAIT_SEND_STABLECOIN');\\n    (, , , uint256 closureEndTime, , , , , , , ) = etf.etfStatus();\\n    require(closureEndTime < block.timestamp, 'ERR_ETF_HAS_NOT_CLOSURE');\\n\\n    uint bal = stableCoin.balanceOf(address(etf.bPool()));\\n    require(bal > 0, 'ERR_STABLECOIN_AMOUNT_IS_ZERO');\\n    _updateDtbtAmount(0);\\n    _invokeRebind(address(stableCoin), bal, 50e18);\\n  }\\n\\n  // send stable coin to swap stbt coin\\n  function _sendStableCoin() internal _checkTx {\\n    uint bal = stableCoin.balanceOf(address(etf.bPool()));\\n    require(bal > 0, 'ERR_STABLECOIN_AMOUNT_IS_ZERO');\\n\\n    bytes memory callData = abi.encodeWithSignature(\\n      'transfer(address,uint256)',\\n      stableCoinReceiver,\\n      bal\\n    );\\n    etf.execute(address(stableCoin), 0, callData, true);\\n\\n    uint decimalsDtbt = dtbt.decimals();\\n    uint decimalsStableCoin = stableCoin.decimals();\\n    uint tbtNewBal = _decimalsHandle(bal, decimalsStableCoin, decimalsDtbt);\\n\\n    _updateDtbtAmount(tbtNewBal);\\n    _invokeUnbind(etf, address(stableCoin));\\n    _invokeRebind(address(stbt), tbtNewBal, 50e18);\\n\\n    emit SendStaleCoin(msg.sender, address(etf), address(stableCoin), bal);\\n  }\\n\\n  // send stbt coin to swap stable coin\\n  function _sendSTBT() internal _checkTx {\\n    uint bal = stbt.balanceOf(address(etf.bPool()));\\n    require(bal > 0, 'ERR_STBT_AMOUNT_IS_ZERO');\\n\\n    bytes memory callData = abi.encodeWithSignature('transfer(address,uint256)', sTBTReceiver, bal);\\n    etf.execute(address(stbt), 0, callData, true);\\n\\n    uint decimalsStbt = stbt.decimals();\\n    uint decimalsStableCoin = stableCoin.decimals();\\n    uint stableCoinNewBal = _decimalsHandle(bal, decimalsStbt, decimalsStableCoin);\\n\\n    _updateDtbtAmount(0);\\n    _invokeUnbind(etf, address(stbt));\\n    _invokeRebind(address(stableCoin), stableCoinNewBal, 50e18);\\n\\n    emit SendSTBT(msg.sender, address(etf), address(stbt), bal);\\n  }\\n\\n  function _updateDtbtAmount(uint amount) internal {\\n    address bpool = address(etf.bPool());\\n    uint balDtbt = dtbt.balanceOf(bpool);\\n\\n    if (balDtbt > 0) dtbt.burn(bpool, balDtbt);\\n    if (amount > 0) dtbt.mint(bpool, amount);\\n\\n    emit UpdateDTBTAmount(msg.sender, address(etf), address(dtbt), amount);\\n  }\\n\\n  // convert token amount based on decimals\\n  function _decimalsHandle(\\n    uint256 currentValue,\\n    uint currentDecimals,\\n    uint targetDecimals\\n  ) internal pure returns (uint256) {\\n    if (currentDecimals >= targetDecimals)\\n      return currentValue / 10 ** (currentDecimals - targetDecimals);\\n    if (currentDecimals < targetDecimals)\\n      return currentValue * 10 ** (targetDecimals - currentDecimals);\\n  }\\n\\n  function _invokeRebind(address _token, uint256 _balance, uint256 _weight) internal {\\n    bool isBound = etf.bPool().isBound(_token);\\n    bytes memory callData = abi.encodeWithSignature(\\n      'rebindPure(address,uint256,uint256,bool)',\\n      _token,\\n      _balance,\\n      _weight,\\n      isBound\\n    );\\n\\n    etf.execute(address(etf.bPool()), 0, callData, false);\\n  }\\n\\n  function _invokeUnbind(IETF _etf, address _token) internal {\\n    bool isBound = etf.bPool().isBound(_token);\\n    if (isBound) {\\n      bytes memory callData = abi.encodeWithSignature('unbindPure(address)', _token);\\n      _etf.execute(address(_etf.bPool()), 0, callData, false);\\n    }\\n  }\\n\\n  // config: ETF coin address\\n  function updateETFaddr(IETF etf_) external onlyOwner _config_ {\\n    require(address(etf_) != address(0), 'ERR_ZERO_ADDRESS');\\n    emit UpdateETFAddr(msg.sender, address(etf), address(etf_));\\n    etf = etf_;\\n  }\\n\\n  // config: stbt coin address\\n  function updateStbtAddr(IERC20Detailed stbt_) external onlyOwner _config_ {\\n    require(address(stbt_) != address(0), 'ERR_ZERO_ADDRESS');\\n    emit UpdateStbtAddr(msg.sender, address(stbt), address(stbt_));\\n    stbt = stbt_;\\n    dtbt.updateDecimals(stbt.decimals());\\n  }\\n\\n  // config: stable coin address\\n  function updateStableCoinAddr(IERC20Detailed stableCoin_) external onlyOwner _config_ {\\n    require(address(stableCoin_) != address(0), 'ERR_ZERO_ADDRESS');\\n    emit UpdateStableCoinAddr(msg.sender, address(stableCoin), address(stableCoin_));\\n    stableCoin = stableCoin_;\\n  }\\n\\n  // config: stable coin receiver address\\n  function updateStableCoinReceiverAddr(address stableCoinReceiver_) external onlyOwner _config_ {\\n    require(stableCoinReceiver_ != address(0), 'ERR_ZERO_ADDRESS');\\n    emit UpdateStableCoinReceiverAddr(msg.sender, stableCoinReceiver, stableCoinReceiver_);\\n    stableCoinReceiver = stableCoinReceiver_;\\n  }\\n\\n  // config: stbt coin receiver address\\n  function updateStbtReceiverAddr(address sTBTReceiver_) external onlyOwner _config_ {\\n    require(sTBTReceiver_ != address(0), 'ERR_ZERO_ADDRESS');\\n    emit UpdateStbtReceiverAddr(msg.sender, sTBTReceiver, sTBTReceiver_);\\n    sTBTReceiver = sTBTReceiver_;\\n  }\\n\\n  modifier _checkTx() {\\n    require(!factory.isPaused(), 'PAUSED');\\n    require(etf.isCompletedCollect(), 'COLLECTION_FAILED');\\n    require(etf.adminList(msg.sender) || msg.sender == etf.getController(), 'NOT_CONTROLLER');\\n    _;\\n  }\\n\\n  modifier _config_() {\\n    (, uint256 collectEndTime, , , , , , , , , ) = etf.etfStatus();\\n    require(block.timestamp < collectEndTime, 'ERR_ETF_HAS_BEEN_CREATE');\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/bill/DTBT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n// Core contract; can't be changed. So disable solhint (reminder for v2)\\n\\n/* solhint-disable private-vars-leading-underscore */\\n/* solhint-disable reason-string */\\n/* solhint-disable func-order */\\ncontract DTBT {\\n  string private constant _name = 'DTBT';\\n  string private constant _symbol = 'DTBT';\\n  uint8 private _decimals = 18;\\n\\n  address private _owner = msg.sender;\\n\\n  uint internal _totalSupply;\\n\\n  mapping(address => uint) private _balance;\\n  mapping(address => mapping(address => uint)) private _allowance;\\n  mapping(address => bool) _tbills;\\n\\n  modifier _onlyOwner_() {\\n    require(msg.sender == _owner || _tbills[msg.sender], 'ERR_NOT_OWNER');\\n    _;\\n  }\\n\\n  event Approval(address indexed src, address indexed dst, uint amt);\\n  event Transfer(address indexed src, address indexed dst, uint amt);\\n  event UpdateDecimals(uint8 oldDecmals, uint8 newDecmals);\\n  event AdminsUpdate(address indexed caller, address newAdmin);\\n  event AdminRemoved(address indexed caller, address newAdmin);\\n\\n  // tbill modules\\n  function addAdmin(address tbill) public returns (bool) {\\n    require(msg.sender == _owner, 'ERR_NOT_OWNER');\\n    _tbills[tbill] = true;\\n    emit AdminsUpdate(msg.sender, tbill);\\n    return true;\\n  }\\n\\n  function removeAdmin(address tbill) public returns (bool) {\\n    require(msg.sender == _owner, 'ERR_NOT_OWNER');\\n    require(_tbills[tbill], 'NOT_APPROVED');\\n    _tbills[tbill] = false;\\n    emit AdminRemoved(msg.sender, tbill);\\n    return true;\\n  }\\n\\n  // Math\\n  function add(uint a, uint b) internal pure returns (uint c) {\\n    require((c = a + b) >= a, 'SafeMath: addition overflow');\\n  }\\n\\n  function sub(uint a, uint b) internal pure returns (uint c) {\\n    require((c = a - b) <= a, 'SafeMath: subtraction overflow');\\n  }\\n\\n  function name() public view returns (string memory) {\\n    return _name;\\n  }\\n\\n  function symbol() public view returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  function decimals() public view returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  function _move(address src, address dst, uint amt) internal {\\n    require(_balance[src] >= amt, 'ERR_INSUFFICIENT_BAL');\\n    _balance[src] = sub(_balance[src], amt);\\n    _balance[dst] = add(_balance[dst], amt);\\n    emit Transfer(src, dst, amt);\\n  }\\n\\n  function _mint(address dst, uint amt) internal {\\n    _balance[dst] = add(_balance[dst], amt);\\n    _totalSupply = add(_totalSupply, amt);\\n    emit Transfer(address(0), dst, amt);\\n  }\\n\\n  function updateDecimals(uint8 newDecimals) public _onlyOwner_ {\\n    emit UpdateDecimals(_decimals, newDecimals);\\n    _decimals = newDecimals;\\n  }\\n\\n  function allowance(address src, address dst) external view returns (uint) {\\n    return _allowance[src][dst];\\n  }\\n\\n  function balanceOf(address whom) external view returns (uint) {\\n    return _balance[whom];\\n  }\\n\\n  function totalSupply() public view returns (uint) {\\n    return _totalSupply;\\n  }\\n\\n  function approve(address dst, uint amt) external returns (bool) {\\n    _allowance[msg.sender][dst] = amt;\\n    emit Approval(msg.sender, dst, amt);\\n    return true;\\n  }\\n\\n  function mint(address dst, uint amt) public _onlyOwner_ returns (bool) {\\n    _mint(dst, amt);\\n    return true;\\n  }\\n\\n  function burn(address dst, uint amt) public _onlyOwner_ returns (bool) {\\n    require(_balance[dst] >= amt, 'ERR_INSUFFICIENT_BAL');\\n    _balance[dst] = sub(_balance[dst], amt);\\n    _totalSupply = sub(_totalSupply, amt);\\n    emit Transfer(dst, address(0), amt);\\n    return true;\\n  }\\n\\n  function transfer(address dst, uint amt) external returns (bool) {\\n    _move(msg.sender, dst, amt);\\n    return true;\\n  }\\n\\n  function transferFrom(address src, address dst, uint amt) external returns (bool) {\\n    require(msg.sender == src || amt <= _allowance[src][msg.sender], 'ERR_BTOKEN_BAD_CALLER');\\n    _move(src, dst, amt);\\n    if (msg.sender != src && _allowance[src][msg.sender] != uint(-1)) {\\n      _allowance[src][msg.sender] = sub(_allowance[src][msg.sender], amt);\\n      emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n    }\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/IERC20Detailed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\nimport {IERC20} from './IERC20.sol';\\n\\ninterface IERC20Detailed is IERC20 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport './Context.sol';\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() internal {\\n    address msgSender = _msgSender();\\n    _owner = msgSender;\\n    emit OwnershipTransferred(address(0), msgSender);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport {IERC20} from './IERC20.sol';\\nimport {SafeMath} from './SafeMath.sol';\\nimport {Address} from './Address.sol';\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    require(success, 'SafeERC20: low-level call failed');\\n\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain`call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, 'Address: low-level call failed');\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, 'Address: insufficient balance for call');\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IETF\",\"name\":\"etf_\",\"type\":\"address\"},{\"internalType\":\"contract IFactory\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dtbt_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"etf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"snedToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sendAmount\",\"type\":\"uint256\"}],\"name\":\"SendSTBT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"etf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sendAmount\",\"type\":\"uint256\"}],\"name\":\"SendStaleCoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"etf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dtbt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdateDTBTAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"UpdateETFAddr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"UpdateStableCoinAddr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"UpdateStableCoinReceiverAddr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"UpdateStbtAddr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"UpdateStbtReceiverAddr\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"currentPeriod\",\"outputs\":[{\"internalType\":\"enum TBillSimple.CurrentPeriod\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dtbt\",\"outputs\":[{\"internalType\":\"contract DTBT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etf\",\"outputs\":[{\"internalType\":\"contract IETF\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sTBTReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stableCoinReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IETF\",\"name\":\"etf_\",\"type\":\"address\"}],\"name\":\"updateETFaddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Detailed\",\"name\":\"stableCoin_\",\"type\":\"address\"}],\"name\":\"updateStableCoinAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stableCoinReceiver_\",\"type\":\"address\"}],\"name\":\"updateStableCoinReceiverAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Detailed\",\"name\":\"stbt_\",\"type\":\"address\"}],\"name\":\"updateStbtAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sTBTReceiver_\",\"type\":\"address\"}],\"name\":\"updateStbtReceiverAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TBillSimple", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005b54fa836a7ba94c8b8a18feb9622216e1452ff000000000000000000000000001a38b39beddcd6bfeedba14057e053cbf529cd2000000000000000000000000cf7190732ca52167a51debf2cef62f8492a23a3d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}