{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"src/Errors/GenericErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nerror AlreadyInitialized();\\r\\nerror CannotAuthoriseSelf();\\r\\nerror CannotBridgeToSameNetwork();\\r\\nerror ContractCallNotAllowed();\\r\\nerror CumulativeSlippageTooHigh(uint256 minAmount, uint256 receivedAmount);\\r\\nerror ExternalCallFailed();\\r\\nerror InformationMismatch();\\r\\nerror InsufficientBalance(uint256 required, uint256 balance);\\r\\nerror InvalidAmount();\\r\\nerror InvalidCallData();\\r\\nerror InvalidConfig();\\r\\nerror InvalidContract();\\r\\nerror InvalidDestinationChain();\\r\\nerror InvalidFallbackAddress();\\r\\nerror InvalidReceiver();\\r\\nerror InvalidSendingToken();\\r\\nerror NativeAssetNotSupported();\\r\\nerror NativeAssetTransferFailed();\\r\\nerror NoSwapDataProvided();\\r\\nerror NoSwapFromZeroBalance();\\r\\nerror NotAContract();\\r\\nerror NotInitialized();\\r\\nerror NoTransferToNullAddress();\\r\\nerror NullAddrIsNotAnERC20Token();\\r\\nerror NullAddrIsNotAValidSpender();\\r\\nerror OnlyContractOwner();\\r\\nerror RecoveryAddressCannotBeZero();\\r\\nerror ReentrancyError();\\r\\nerror TokenNotSupported();\\r\\nerror UnAuthorized();\\r\\nerror UnsupportedChainId(uint256 chainId);\\r\\nerror ZeroAmount();\\r\\nerror TokenAddressIsZero();\\r\\nerror ZeroPostSwapBalance();\\r\\nerror NativeValueWithERC();\\r\\nerror InvalidBridgeConfigLength();\\r\\nerror InvalidCaller();\\r\\nerror CannotDepositNativeToken();\\r\\nerror NotEnoughBalance(uint256 requested, uint256 available);\\r\\nerror IsNotOwner();\\r\\n\"\r\n    },\r\n    \"src/Interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IDiamondCut {\\r\\n\\tenum FacetCutAction {\\r\\n\\t\\tAdd,\\r\\n\\t\\tReplace,\\r\\n\\t\\tRemove\\r\\n\\t}\\r\\n\\t// Add=0, Replace=1, Remove=2\\r\\n\\r\\n\\tstruct FacetCut {\\r\\n\\t\\taddress facetAddress;\\r\\n\\t\\tFacetCutAction action;\\r\\n\\t\\tbytes4[] functionSelectors;\\r\\n\\t}\\r\\n\\r\\n\\t/// @notice Add/replace/remove any number of functions and optionally execute\\r\\n\\t///         a function with delegatecall\\r\\n\\t/// @param _diamondCut Contains the facet addresses and function selectors\\r\\n\\t/// @param _init The address of the contract or facet to execute _calldata\\r\\n\\t/// @param _calldata A function call, including function selector and arguments\\r\\n\\t///                  _calldata is executed with delegatecall on _init\\r\\n\\tfunction diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\r\\n\\r\\n\\tevent DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/KanaDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport {LibDiamond} from \\\"./Libraries/LibDiamond.sol\\\";\\r\\nimport {IDiamondCut} from \\\"./Interfaces/IDiamondCut.sol\\\";\\r\\nimport {LibUtil} from \\\"./Libraries/LibUtil.sol\\\";\\r\\n\\r\\ncontract KanaDiamond {\\r\\n\\tconstructor(address _contractOwner, address _diamondCutFacet) payable {\\r\\n\\t\\tLibDiamond.setContractOwner(_contractOwner);\\r\\n\\r\\n\\t\\t// Add the diamondCut external function from the diamondCutFacet\\r\\n\\t\\tIDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\\r\\n\\t\\tbytes4[] memory functionSelectors = new bytes4[](1);\\r\\n\\t\\tfunctionSelectors[0] = IDiamondCut.diamondCut.selector;\\r\\n\\t\\tcut[0] = IDiamondCut.FacetCut({\\r\\n\\t\\t\\tfacetAddress: _diamondCutFacet,\\r\\n\\t\\t\\taction: IDiamondCut.FacetCutAction.Add,\\r\\n\\t\\t\\tfunctionSelectors: functionSelectors\\r\\n\\t\\t});\\r\\n\\t\\tLibDiamond.diamondCut(cut, address(0), \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\t// Find facet for function that is called and execute the\\r\\n\\t// function if a facet is found and return any value.\\r\\n\\t// solhint-disable-next-line no-complex-fallback\\r\\n\\tfallback() external payable {\\r\\n\\t\\tLibDiamond.DiamondStorage storage ds;\\r\\n\\t\\tbytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\r\\n\\r\\n\\t\\t// get diamond storage\\r\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tds.slot := position\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// get facet from function selector\\r\\n\\t\\taddress facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\r\\n\\r\\n\\t\\tif (facet == address(0)) {\\r\\n\\t\\t\\trevert LibDiamond.FunctionDoesNotExist();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Execute external function from facet using delegatecall and return any value.\\r\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\t// copy function selector and any arguments\\r\\n\\t\\t\\tcalldatacopy(0, 0, calldatasize())\\r\\n\\t\\t\\t// execute function call using the facet\\r\\n\\t\\t\\tlet result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\r\\n\\t\\t\\t// get any return value\\r\\n\\t\\t\\treturndatacopy(0, 0, returndatasize())\\r\\n\\t\\t\\t// return any return value or error back to the caller\\r\\n\\t\\t\\tswitch result\\r\\n\\t\\t\\tcase 0 {\\r\\n\\t\\t\\t\\trevert(0, returndatasize())\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdefault {\\r\\n\\t\\t\\t\\treturn(0, returndatasize())\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// Able to receive ether\\r\\n\\t// solhint-disable-next-line no-empty-blocks\\r\\n\\treceive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Libraries/LibBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nlibrary LibBytes {\\r\\n\\t// solhint-disable no-inline-assembly\\r\\n\\r\\n\\t// LibBytes specific errors\\r\\n\\terror SliceOverflow();\\r\\n\\terror SliceOutOfBounds();\\r\\n\\terror AddressOutOfBounds();\\r\\n\\terror UintOutOfBounds();\\r\\n\\r\\n\\t// -------------------------\\r\\n\\r\\n\\tfunction concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\\r\\n\\t\\tbytes memory tempBytes;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\t// Get a location of some free memory and store it in tempBytes as\\r\\n\\t\\t\\t// Solidity does for memory variables.\\r\\n\\t\\t\\ttempBytes := mload(0x40)\\r\\n\\r\\n\\t\\t\\t// Store the length of the first bytes array at the beginning of\\r\\n\\t\\t\\t// the memory for tempBytes.\\r\\n\\t\\t\\tlet length := mload(_preBytes)\\r\\n\\t\\t\\tmstore(tempBytes, length)\\r\\n\\r\\n\\t\\t\\t// Maintain a memory counter for the current write location in the\\r\\n\\t\\t\\t// temp bytes array by adding the 32 bytes for the array length to\\r\\n\\t\\t\\t// the starting location.\\r\\n\\t\\t\\tlet mc := add(tempBytes, 0x20)\\r\\n\\t\\t\\t// Stop copying when the memory counter reaches the length of the\\r\\n\\t\\t\\t// first bytes array.\\r\\n\\t\\t\\tlet end := add(mc, length)\\r\\n\\r\\n\\t\\t\\tfor {\\r\\n\\t\\t\\t\\t// Initialize a copy counter to the start of the _preBytes data,\\r\\n\\t\\t\\t\\t// 32 bytes into its memory.\\r\\n\\t\\t\\t\\tlet cc := add(_preBytes, 0x20)\\r\\n\\t\\t\\t} lt(mc, end) {\\r\\n\\t\\t\\t\\t// Increase both counters by 32 bytes each iteration.\\r\\n\\t\\t\\t\\tmc := add(mc, 0x20)\\r\\n\\t\\t\\t\\tcc := add(cc, 0x20)\\r\\n\\t\\t\\t} {\\r\\n\\t\\t\\t\\t// Write the _preBytes data into the tempBytes memory 32 bytes\\r\\n\\t\\t\\t\\t// at a time.\\r\\n\\t\\t\\t\\tmstore(mc, mload(cc))\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Add the length of _postBytes to the current length of tempBytes\\r\\n\\t\\t\\t// and store it as the new length in the first 32 bytes of the\\r\\n\\t\\t\\t// tempBytes memory.\\r\\n\\t\\t\\tlength := mload(_postBytes)\\r\\n\\t\\t\\tmstore(tempBytes, add(length, mload(tempBytes)))\\r\\n\\r\\n\\t\\t\\t// Move the memory counter back from a multiple of 0x20 to the\\r\\n\\t\\t\\t// actual end of the _preBytes data.\\r\\n\\t\\t\\tmc := end\\r\\n\\t\\t\\t// Stop copying when the memory counter reaches the new combined\\r\\n\\t\\t\\t// length of the arrays.\\r\\n\\t\\t\\tend := add(mc, length)\\r\\n\\r\\n\\t\\t\\tfor {\\r\\n\\t\\t\\t\\tlet cc := add(_postBytes, 0x20)\\r\\n\\t\\t\\t} lt(mc, end) {\\r\\n\\t\\t\\t\\tmc := add(mc, 0x20)\\r\\n\\t\\t\\t\\tcc := add(cc, 0x20)\\r\\n\\t\\t\\t} {\\r\\n\\t\\t\\t\\tmstore(mc, mload(cc))\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Update the free-memory pointer by padding our last write location\\r\\n\\t\\t\\t// to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\r\\n\\t\\t\\t// next 32 byte block, then round down to the nearest multiple of\\r\\n\\t\\t\\t// 32. If the sum of the length of the two arrays is zero then add\\r\\n\\t\\t\\t// one before rounding down to leave a blank 32 bytes (the length block with 0).\\r\\n\\t\\t\\tmstore(\\r\\n\\t\\t\\t\\t0x40,\\r\\n\\t\\t\\t\\tand(\\r\\n\\t\\t\\t\\t\\tadd(add(end, iszero(add(length, mload(_preBytes)))), 31),\\r\\n\\t\\t\\t\\t\\tnot(31) // Round down to the nearest 32 bytes.\\r\\n\\t\\t\\t\\t)\\r\\n\\t\\t\\t)\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn tempBytes;\\r\\n\\t}\\r\\n\\r\\n\\tfunction concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\t// Read the first 32 bytes of _preBytes storage, which is the length\\r\\n\\t\\t\\t// of the array. (We don't need to use the offset into the slot\\r\\n\\t\\t\\t// because arrays use the entire slot.)\\r\\n\\t\\t\\tlet fslot := sload(_preBytes.slot)\\r\\n\\t\\t\\t// Arrays of 31 bytes or less have an even value in their slot,\\r\\n\\t\\t\\t// while longer arrays have an odd value. The actual length is\\r\\n\\t\\t\\t// the slot divided by two for odd values, and the lowest order\\r\\n\\t\\t\\t// byte divided by two for even values.\\r\\n\\t\\t\\t// If the slot is even, bitwise and the slot with 255 and divide by\\r\\n\\t\\t\\t// two to get the length. If the slot is odd, bitwise and the slot\\r\\n\\t\\t\\t// with -1 and divide by two.\\r\\n\\t\\t\\tlet slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\r\\n\\t\\t\\tlet mlength := mload(_postBytes)\\r\\n\\t\\t\\tlet newlength := add(slength, mlength)\\r\\n\\t\\t\\t// slength can contain both the length and contents of the array\\r\\n\\t\\t\\t// if length < 32 bytes so let's prepare for that\\r\\n\\t\\t\\t// v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\r\\n\\t\\t\\tswitch add(lt(slength, 32), lt(newlength, 32))\\r\\n\\t\\t\\tcase 2 {\\r\\n\\t\\t\\t\\t// Since the new array still fits in the slot, we just need to\\r\\n\\t\\t\\t\\t// update the contents of the slot.\\r\\n\\t\\t\\t\\t// uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\r\\n\\t\\t\\t\\tsstore(\\r\\n\\t\\t\\t\\t\\t_preBytes.slot,\\r\\n\\t\\t\\t\\t\\t// all the modifications to the slot are inside this\\r\\n\\t\\t\\t\\t\\t// next block\\r\\n\\t\\t\\t\\t\\tadd(\\r\\n\\t\\t\\t\\t\\t\\t// we can just add to the slot contents because the\\r\\n\\t\\t\\t\\t\\t\\t// bytes we want to change are the LSBs\\r\\n\\t\\t\\t\\t\\t\\tfslot,\\r\\n\\t\\t\\t\\t\\t\\tadd(\\r\\n\\t\\t\\t\\t\\t\\t\\tmul(\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tdiv(\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// load the bytes from memory\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmload(add(_postBytes, 0x20)),\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// zero all bytes to the right\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\texp(0x100, sub(32, mlength))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t),\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// and now shift left the number of bytes to\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// leave space for the length in the slot\\r\\n\\t\\t\\t\\t\\t\\t\\t\\texp(0x100, sub(32, newlength))\\r\\n\\t\\t\\t\\t\\t\\t\\t),\\r\\n\\t\\t\\t\\t\\t\\t\\t// increase length by the double of the memory\\r\\n\\t\\t\\t\\t\\t\\t\\t// bytes length\\r\\n\\t\\t\\t\\t\\t\\t\\tmul(mlength, 2)\\r\\n\\t\\t\\t\\t\\t\\t)\\r\\n\\t\\t\\t\\t\\t)\\r\\n\\t\\t\\t\\t)\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcase 1 {\\r\\n\\t\\t\\t\\t// The stored value fits in the slot, but the combined value\\r\\n\\t\\t\\t\\t// will exceed it.\\r\\n\\t\\t\\t\\t// get the keccak hash to get the contents of the array\\r\\n\\t\\t\\t\\tmstore(0x0, _preBytes.slot)\\r\\n\\t\\t\\t\\tlet sc := add(keccak256(0x0, 0x20), div(slength, 32))\\r\\n\\r\\n\\t\\t\\t\\t// save new length\\r\\n\\t\\t\\t\\tsstore(_preBytes.slot, add(mul(newlength, 2), 1))\\r\\n\\r\\n\\t\\t\\t\\t// The contents of the _postBytes array start 32 bytes into\\r\\n\\t\\t\\t\\t// the structure. Our first read should obtain the `submod`\\r\\n\\t\\t\\t\\t// bytes that can fit into the unused space in the last word\\r\\n\\t\\t\\t\\t// of the stored array. To get this, we read 32 bytes starting\\r\\n\\t\\t\\t\\t// from `submod`, so the data we read overlaps with the array\\r\\n\\t\\t\\t\\t// contents by `submod` bytes. Masking the lowest-order\\r\\n\\t\\t\\t\\t// `submod` bytes allows us to add that value directly to the\\r\\n\\t\\t\\t\\t// stored value.\\r\\n\\r\\n\\t\\t\\t\\tlet submod := sub(32, slength)\\r\\n\\t\\t\\t\\tlet mc := add(_postBytes, submod)\\r\\n\\t\\t\\t\\tlet end := add(_postBytes, mlength)\\r\\n\\t\\t\\t\\tlet mask := sub(exp(0x100, submod), 1)\\r\\n\\r\\n\\t\\t\\t\\tsstore(\\r\\n\\t\\t\\t\\t\\tsc,\\r\\n\\t\\t\\t\\t\\tadd(\\r\\n\\t\\t\\t\\t\\t\\tand(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\\r\\n\\t\\t\\t\\t\\t\\tand(mload(mc), mask)\\r\\n\\t\\t\\t\\t\\t)\\r\\n\\t\\t\\t\\t)\\r\\n\\r\\n\\t\\t\\t\\tfor {\\r\\n\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\r\\n\\t\\t\\t\\t\\tsc := add(sc, 1)\\r\\n\\t\\t\\t\\t} lt(mc, end) {\\r\\n\\t\\t\\t\\t\\tsc := add(sc, 1)\\r\\n\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\r\\n\\t\\t\\t\\t} {\\r\\n\\t\\t\\t\\t\\tsstore(sc, mload(mc))\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tmask := exp(0x100, sub(mc, end))\\r\\n\\r\\n\\t\\t\\t\\tsstore(sc, mul(div(mload(mc), mask), mask))\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdefault {\\r\\n\\t\\t\\t\\t// get the keccak hash to get the contents of the array\\r\\n\\t\\t\\t\\tmstore(0x0, _preBytes.slot)\\r\\n\\t\\t\\t\\t// Start copying to the last used word of the stored array.\\r\\n\\t\\t\\t\\tlet sc := add(keccak256(0x0, 0x20), div(slength, 32))\\r\\n\\r\\n\\t\\t\\t\\t// save new length\\r\\n\\t\\t\\t\\tsstore(_preBytes.slot, add(mul(newlength, 2), 1))\\r\\n\\r\\n\\t\\t\\t\\t// Copy over the first `submod` bytes of the new data as in\\r\\n\\t\\t\\t\\t// case 1 above.\\r\\n\\t\\t\\t\\tlet slengthmod := mod(slength, 32)\\r\\n\\t\\t\\t\\tlet submod := sub(32, slengthmod)\\r\\n\\t\\t\\t\\tlet mc := add(_postBytes, submod)\\r\\n\\t\\t\\t\\tlet end := add(_postBytes, mlength)\\r\\n\\t\\t\\t\\tlet mask := sub(exp(0x100, submod), 1)\\r\\n\\r\\n\\t\\t\\t\\tsstore(sc, add(sload(sc), and(mload(mc), mask)))\\r\\n\\r\\n\\t\\t\\t\\tfor {\\r\\n\\t\\t\\t\\t\\tsc := add(sc, 1)\\r\\n\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\r\\n\\t\\t\\t\\t} lt(mc, end) {\\r\\n\\t\\t\\t\\t\\tsc := add(sc, 1)\\r\\n\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\r\\n\\t\\t\\t\\t} {\\r\\n\\t\\t\\t\\t\\tsstore(sc, mload(mc))\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tmask := exp(0x100, sub(mc, end))\\r\\n\\r\\n\\t\\t\\t\\tsstore(sc, mul(div(mload(mc), mask), mask))\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\r\\n\\t\\tif (_length + 31 < _length) revert SliceOverflow();\\r\\n\\t\\tif (_bytes.length < _start + _length) revert SliceOutOfBounds();\\r\\n\\r\\n\\t\\tbytes memory tempBytes;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tswitch iszero(_length)\\r\\n\\t\\t\\tcase 0 {\\r\\n\\t\\t\\t\\t// Get a location of some free memory and store it in tempBytes as\\r\\n\\t\\t\\t\\t// Solidity does for memory variables.\\r\\n\\t\\t\\t\\ttempBytes := mload(0x40)\\r\\n\\r\\n\\t\\t\\t\\t// The first word of the slice result is potentially a partial\\r\\n\\t\\t\\t\\t// word read from the original array. To read it, we calculate\\r\\n\\t\\t\\t\\t// the length of that partial word and start copying that many\\r\\n\\t\\t\\t\\t// bytes into the array. The first word we copy will start with\\r\\n\\t\\t\\t\\t// data we don't care about, but the last `lengthmod` bytes will\\r\\n\\t\\t\\t\\t// land at the beginning of the contents of the new array. When\\r\\n\\t\\t\\t\\t// we're done copying, we overwrite the full first word with\\r\\n\\t\\t\\t\\t// the actual length of the slice.\\r\\n\\t\\t\\t\\tlet lengthmod := and(_length, 31)\\r\\n\\r\\n\\t\\t\\t\\t// The multiplication in the next line is necessary\\r\\n\\t\\t\\t\\t// because when slicing multiples of 32 bytes (lengthmod == 0)\\r\\n\\t\\t\\t\\t// the following copy loop was copying the origin's length\\r\\n\\t\\t\\t\\t// and then ending prematurely not copying everything it should.\\r\\n\\t\\t\\t\\tlet mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\r\\n\\t\\t\\t\\tlet end := add(mc, _length)\\r\\n\\r\\n\\t\\t\\t\\tfor {\\r\\n\\t\\t\\t\\t\\t// The multiplication in the next line has the same exact purpose\\r\\n\\t\\t\\t\\t\\t// as the one above.\\r\\n\\t\\t\\t\\t\\tlet cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\r\\n\\t\\t\\t\\t} lt(mc, end) {\\r\\n\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\r\\n\\t\\t\\t\\t\\tcc := add(cc, 0x20)\\r\\n\\t\\t\\t\\t} {\\r\\n\\t\\t\\t\\t\\tmstore(mc, mload(cc))\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tmstore(tempBytes, _length)\\r\\n\\r\\n\\t\\t\\t\\t//update free-memory pointer\\r\\n\\t\\t\\t\\t//allocating the array padded to 32 bytes like the compiler does now\\r\\n\\t\\t\\t\\tmstore(0x40, and(add(mc, 31), not(31)))\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t//if we want a zero-length slice let's just return a zero-length array\\r\\n\\t\\t\\tdefault {\\r\\n\\t\\t\\t\\ttempBytes := mload(0x40)\\r\\n\\t\\t\\t\\t//zero out the 32 bytes slice we are about to return\\r\\n\\t\\t\\t\\t//we need to do it because Solidity does not garbage collect\\r\\n\\t\\t\\t\\tmstore(tempBytes, 0)\\r\\n\\r\\n\\t\\t\\t\\tmstore(0x40, add(tempBytes, 0x20))\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn tempBytes;\\r\\n\\t}\\r\\n\\r\\n\\tfunction toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\r\\n\\t\\tif (_bytes.length < _start + 20) {\\r\\n\\t\\t\\trevert AddressOutOfBounds();\\r\\n\\t\\t}\\r\\n\\t\\taddress tempAddress;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\ttempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn tempAddress;\\r\\n\\t}\\r\\n\\r\\n\\tfunction toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\r\\n\\t\\tif (_bytes.length < _start + 1) {\\r\\n\\t\\t\\trevert UintOutOfBounds();\\r\\n\\t\\t}\\r\\n\\t\\tuint8 tempUint;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x1), _start))\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn tempUint;\\r\\n\\t}\\r\\n\\r\\n\\tfunction toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\r\\n\\t\\tif (_bytes.length < _start + 2) {\\r\\n\\t\\t\\trevert UintOutOfBounds();\\r\\n\\t\\t}\\r\\n\\t\\tuint16 tempUint;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x2), _start))\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn tempUint;\\r\\n\\t}\\r\\n\\r\\n\\tfunction toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\r\\n\\t\\tif (_bytes.length < _start + 4) {\\r\\n\\t\\t\\trevert UintOutOfBounds();\\r\\n\\t\\t}\\r\\n\\t\\tuint32 tempUint;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x4), _start))\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn tempUint;\\r\\n\\t}\\r\\n\\r\\n\\tfunction toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\r\\n\\t\\tif (_bytes.length < _start + 8) {\\r\\n\\t\\t\\trevert UintOutOfBounds();\\r\\n\\t\\t}\\r\\n\\t\\tuint64 tempUint;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x8), _start))\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn tempUint;\\r\\n\\t}\\r\\n\\r\\n\\tfunction toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\r\\n\\t\\tif (_bytes.length < _start + 12) {\\r\\n\\t\\t\\trevert UintOutOfBounds();\\r\\n\\t\\t}\\r\\n\\t\\tuint96 tempUint;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0xc), _start))\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn tempUint;\\r\\n\\t}\\r\\n\\r\\n\\tfunction toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\r\\n\\t\\tif (_bytes.length < _start + 16) {\\r\\n\\t\\t\\trevert UintOutOfBounds();\\r\\n\\t\\t}\\r\\n\\t\\tuint128 tempUint;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x10), _start))\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn tempUint;\\r\\n\\t}\\r\\n\\r\\n\\tfunction toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\r\\n\\t\\tif (_bytes.length < _start + 32) {\\r\\n\\t\\t\\trevert UintOutOfBounds();\\r\\n\\t\\t}\\r\\n\\t\\tuint256 tempUint;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\ttempUint := mload(add(add(_bytes, 0x20), _start))\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn tempUint;\\r\\n\\t}\\r\\n\\r\\n\\tfunction toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\r\\n\\t\\tif (_bytes.length < _start + 32) {\\r\\n\\t\\t\\trevert UintOutOfBounds();\\r\\n\\t\\t}\\r\\n\\t\\tbytes32 tempBytes32;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\ttempBytes32 := mload(add(add(_bytes, 0x20), _start))\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn tempBytes32;\\r\\n\\t}\\r\\n\\r\\n\\tfunction equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\r\\n\\t\\tbool success = true;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlet length := mload(_preBytes)\\r\\n\\r\\n\\t\\t\\t// if lengths don't match the arrays are not equal\\r\\n\\t\\t\\tswitch eq(length, mload(_postBytes))\\r\\n\\t\\t\\tcase 1 {\\r\\n\\t\\t\\t\\t// cb is a circuit breaker in the for loop since there's\\r\\n\\t\\t\\t\\t//  no said feature for inline assembly loops\\r\\n\\t\\t\\t\\t// cb = 1 - don't breaker\\r\\n\\t\\t\\t\\t// cb = 0 - break\\r\\n\\t\\t\\t\\tlet cb := 1\\r\\n\\r\\n\\t\\t\\t\\tlet mc := add(_preBytes, 0x20)\\r\\n\\t\\t\\t\\tlet end := add(mc, length)\\r\\n\\r\\n\\t\\t\\t\\tfor {\\r\\n\\t\\t\\t\\t\\tlet cc := add(_postBytes, 0x20)\\r\\n\\t\\t\\t\\t\\t// the next line is the loop condition:\\r\\n\\t\\t\\t\\t\\t// while(uint256(mc < end) + cb == 2)\\r\\n\\t\\t\\t\\t} eq(add(lt(mc, end), cb), 2) {\\r\\n\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\r\\n\\t\\t\\t\\t\\tcc := add(cc, 0x20)\\r\\n\\t\\t\\t\\t} {\\r\\n\\t\\t\\t\\t\\t// if any of these checks fails then arrays are not equal\\r\\n\\t\\t\\t\\t\\tif iszero(eq(mload(mc), mload(cc))) {\\r\\n\\t\\t\\t\\t\\t\\t// unsuccess:\\r\\n\\t\\t\\t\\t\\t\\tsuccess := 0\\r\\n\\t\\t\\t\\t\\t\\tcb := 0\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdefault {\\r\\n\\t\\t\\t\\t// unsuccess:\\r\\n\\t\\t\\t\\tsuccess := 0\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn success;\\r\\n\\t}\\r\\n\\r\\n\\tfunction equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\\r\\n\\t\\tbool success = true;\\r\\n\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\t// we know _preBytes_offset is 0\\r\\n\\t\\t\\tlet fslot := sload(_preBytes.slot)\\r\\n\\t\\t\\t// Decode the length of the stored array like in concatStorage().\\r\\n\\t\\t\\tlet slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\r\\n\\t\\t\\tlet mlength := mload(_postBytes)\\r\\n\\r\\n\\t\\t\\t// if lengths don't match the arrays are not equal\\r\\n\\t\\t\\tswitch eq(slength, mlength)\\r\\n\\t\\t\\tcase 1 {\\r\\n\\t\\t\\t\\t// slength can contain both the length and contents of the array\\r\\n\\t\\t\\t\\t// if length < 32 bytes so let's prepare for that\\r\\n\\t\\t\\t\\t// v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\r\\n\\t\\t\\t\\tif iszero(iszero(slength)) {\\r\\n\\t\\t\\t\\t\\tswitch lt(slength, 32)\\r\\n\\t\\t\\t\\t\\tcase 1 {\\r\\n\\t\\t\\t\\t\\t\\t// blank the last byte which is the length\\r\\n\\t\\t\\t\\t\\t\\tfslot := mul(div(fslot, 0x100), 0x100)\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tif iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\r\\n\\t\\t\\t\\t\\t\\t\\t// unsuccess:\\r\\n\\t\\t\\t\\t\\t\\t\\tsuccess := 0\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tdefault {\\r\\n\\t\\t\\t\\t\\t\\t// cb is a circuit breaker in the for loop since there's\\r\\n\\t\\t\\t\\t\\t\\t//  no said feature for inline assembly loops\\r\\n\\t\\t\\t\\t\\t\\t// cb = 1 - don't breaker\\r\\n\\t\\t\\t\\t\\t\\t// cb = 0 - break\\r\\n\\t\\t\\t\\t\\t\\tlet cb := 1\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// get the keccak hash to get the contents of the array\\r\\n\\t\\t\\t\\t\\t\\tmstore(0x0, _preBytes.slot)\\r\\n\\t\\t\\t\\t\\t\\tlet sc := keccak256(0x0, 0x20)\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tlet mc := add(_postBytes, 0x20)\\r\\n\\t\\t\\t\\t\\t\\tlet end := add(mc, mlength)\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// the next line is the loop condition:\\r\\n\\t\\t\\t\\t\\t\\t// while(uint256(mc < end) + cb == 2)\\r\\n\\t\\t\\t\\t\\t\\t// solhint-disable-next-line no-empty-blocks\\r\\n\\t\\t\\t\\t\\t\\tfor {\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t} eq(add(lt(mc, end), cb), 2) {\\r\\n\\t\\t\\t\\t\\t\\t\\tsc := add(sc, 1)\\r\\n\\t\\t\\t\\t\\t\\t\\tmc := add(mc, 0x20)\\r\\n\\t\\t\\t\\t\\t\\t} {\\r\\n\\t\\t\\t\\t\\t\\t\\tif iszero(eq(sload(sc), mload(mc))) {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// unsuccess:\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tsuccess := 0\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tcb := 0\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdefault {\\r\\n\\t\\t\\t\\t// unsuccess:\\r\\n\\t\\t\\t\\tsuccess := 0\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn success;\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport {IDiamondCut} from \\\"../Interfaces/IDiamondCut.sol\\\";\\r\\nimport {LibUtil} from \\\"../Libraries/LibUtil.sol\\\";\\r\\nimport {OnlyContractOwner} from \\\"../Errors/GenericErrors.sol\\\";\\r\\n\\r\\n/// Implementation of EIP-2535 Diamond Standard\\r\\n/// https://eips.ethereum.org/EIPS/eip-2535\\r\\nlibrary LibDiamond {\\r\\n\\tbytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\r\\n\\r\\n\\t// Diamond specific errors\\r\\n\\terror IncorrectFacetCutAction();\\r\\n\\terror NoSelectorsInFace();\\r\\n\\terror FunctionAlreadyExists();\\r\\n\\terror FacetAddressIsZero();\\r\\n\\terror FacetAddressIsNotZero();\\r\\n\\terror FacetContainsNoCode();\\r\\n\\terror FunctionDoesNotExist();\\r\\n\\terror FunctionIsImmutable();\\r\\n\\terror InitZeroButCalldataNotEmpty();\\r\\n\\terror CalldataEmptyButInitNotZero();\\r\\n\\terror InitReverted();\\r\\n\\t// ----------------\\r\\n\\r\\n\\tstruct FacetAddressAndPosition {\\r\\n\\t\\taddress facetAddress;\\r\\n\\t\\tuint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\r\\n\\t}\\r\\n\\r\\n\\tstruct FacetFunctionSelectors {\\r\\n\\t\\tbytes4[] functionSelectors;\\r\\n\\t\\tuint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\r\\n\\t}\\r\\n\\r\\n\\tstruct DiamondStorage {\\r\\n\\t\\t// maps function selector to the facet address and\\r\\n\\t\\t// the position of the selector in the facetFunctionSelectors.selectors array\\r\\n\\t\\tmapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\r\\n\\t\\t// maps facet addresses to function selectors\\r\\n\\t\\tmapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\r\\n\\t\\t// facet addresses\\r\\n\\t\\taddress[] facetAddresses;\\r\\n\\t\\t// Used to query if a contract implements an interface.\\r\\n\\t\\t// Used to implement ERC-165.\\r\\n\\t\\tmapping(bytes4 => bool) supportedInterfaces;\\r\\n\\t\\t// owner of the contract\\r\\n\\t\\taddress contractOwner;\\r\\n\\t}\\r\\n\\r\\n\\tfunction diamondStorage() internal pure returns (DiamondStorage storage ds) {\\r\\n\\t\\tbytes32 position = DIAMOND_STORAGE_POSITION;\\r\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tds.slot := position\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\tfunction setContractOwner(address _newOwner) internal {\\r\\n\\t\\tDiamondStorage storage ds = diamondStorage();\\r\\n\\t\\taddress previousOwner = ds.contractOwner;\\r\\n\\t\\tds.contractOwner = _newOwner;\\r\\n\\t\\temit OwnershipTransferred(previousOwner, _newOwner);\\r\\n\\t}\\r\\n\\r\\n\\tfunction contractOwner() internal view returns (address contractOwner_) {\\r\\n\\t\\tcontractOwner_ = diamondStorage().contractOwner;\\r\\n\\t}\\r\\n\\r\\n\\tfunction enforceIsContractOwner() internal view {\\r\\n\\t\\tif (msg.sender != diamondStorage().contractOwner) revert OnlyContractOwner();\\r\\n\\t}\\r\\n\\r\\n\\tevent DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n\\r\\n\\t// Internal function version of diamondCut\\r\\n\\tfunction diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\\r\\n\\t\\tfor (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\r\\n\\t\\t\\tIDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\r\\n\\t\\t\\tif (action == IDiamondCut.FacetCutAction.Add) {\\r\\n\\t\\t\\t\\taddFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\r\\n\\t\\t\\t} else if (action == IDiamondCut.FacetCutAction.Replace) {\\r\\n\\t\\t\\t\\treplaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\r\\n\\t\\t\\t} else if (action == IDiamondCut.FacetCutAction.Remove) {\\r\\n\\t\\t\\t\\tremoveFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\trevert IncorrectFacetCutAction();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\t++facetIndex;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\temit DiamondCut(_diamondCut, _init, _calldata);\\r\\n\\t\\tinitializeDiamondCut(_init, _calldata);\\r\\n\\t}\\r\\n\\r\\n\\tfunction addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n\\t\\tif (_functionSelectors.length == 0) {\\r\\n\\t\\t\\trevert NoSelectorsInFace();\\r\\n\\t\\t}\\r\\n\\t\\tDiamondStorage storage ds = diamondStorage();\\r\\n\\t\\tif (LibUtil.isZeroAddress(_facetAddress)) {\\r\\n\\t\\t\\trevert FacetAddressIsZero();\\r\\n\\t\\t}\\r\\n\\t\\tuint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\r\\n\\t\\t// add new facet address if it does not exist\\r\\n\\t\\tif (selectorPosition == 0) {\\r\\n\\t\\t\\taddFacet(ds, _facetAddress);\\r\\n\\t\\t}\\r\\n\\t\\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; ) {\\r\\n\\t\\t\\tbytes4 selector = _functionSelectors[selectorIndex];\\r\\n\\t\\t\\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\r\\n\\t\\t\\tif (!LibUtil.isZeroAddress(oldFacetAddress)) {\\r\\n\\t\\t\\t\\trevert FunctionAlreadyExists();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\taddFunction(ds, selector, selectorPosition, _facetAddress);\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\t++selectorPosition;\\r\\n\\t\\t\\t\\t++selectorIndex;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n\\t\\tif (_functionSelectors.length == 0) {\\r\\n\\t\\t\\trevert NoSelectorsInFace();\\r\\n\\t\\t}\\r\\n\\t\\tDiamondStorage storage ds = diamondStorage();\\r\\n\\t\\tif (LibUtil.isZeroAddress(_facetAddress)) {\\r\\n\\t\\t\\trevert FacetAddressIsZero();\\r\\n\\t\\t}\\r\\n\\t\\tuint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\r\\n\\t\\t// add new facet address if it does not exist\\r\\n\\t\\tif (selectorPosition == 0) {\\r\\n\\t\\t\\taddFacet(ds, _facetAddress);\\r\\n\\t\\t}\\r\\n\\t\\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; ) {\\r\\n\\t\\t\\tbytes4 selector = _functionSelectors[selectorIndex];\\r\\n\\t\\t\\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\r\\n\\t\\t\\tif (oldFacetAddress == _facetAddress) {\\r\\n\\t\\t\\t\\trevert FunctionAlreadyExists();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tremoveFunction(ds, oldFacetAddress, selector);\\r\\n\\t\\t\\taddFunction(ds, selector, selectorPosition, _facetAddress);\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\t++selectorPosition;\\r\\n\\t\\t\\t\\t++selectorIndex;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n\\t\\tif (_functionSelectors.length == 0) {\\r\\n\\t\\t\\trevert NoSelectorsInFace();\\r\\n\\t\\t}\\r\\n\\t\\tDiamondStorage storage ds = diamondStorage();\\r\\n\\t\\t// if function does not exist then do nothing and return\\r\\n\\t\\tif (!LibUtil.isZeroAddress(_facetAddress)) {\\r\\n\\t\\t\\trevert FacetAddressIsNotZero();\\r\\n\\t\\t}\\r\\n\\t\\tfor (uint256 selectorIndex; selectorIndex < _functionSelectors.length; ) {\\r\\n\\t\\t\\tbytes4 selector = _functionSelectors[selectorIndex];\\r\\n\\t\\t\\taddress oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\r\\n\\t\\t\\tremoveFunction(ds, oldFacetAddress, selector);\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\t++selectorIndex;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\r\\n\\t\\tenforceHasContractCode(_facetAddress);\\r\\n\\t\\tds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\r\\n\\t\\tds.facetAddresses.push(_facetAddress);\\r\\n\\t}\\r\\n\\r\\n\\tfunction addFunction(\\r\\n\\t\\tDiamondStorage storage ds,\\r\\n\\t\\tbytes4 _selector,\\r\\n\\t\\tuint96 _selectorPosition,\\r\\n\\t\\taddress _facetAddress\\r\\n\\t) internal {\\r\\n\\t\\tds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\r\\n\\t\\tds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\r\\n\\t\\tds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\r\\n\\t}\\r\\n\\r\\n\\tfunction removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\\r\\n\\t\\tif (LibUtil.isZeroAddress(_facetAddress)) {\\r\\n\\t\\t\\trevert FunctionDoesNotExist();\\r\\n\\t\\t}\\r\\n\\t\\t// an immutable function is a function defined directly in a diamond\\r\\n\\t\\tif (_facetAddress == address(this)) {\\r\\n\\t\\t\\trevert FunctionIsImmutable();\\r\\n\\t\\t}\\r\\n\\t\\t// replace selector with last selector, then delete last selector\\r\\n\\t\\tuint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\r\\n\\t\\tuint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\r\\n\\t\\t// if not the same then replace _selector with lastSelector\\r\\n\\t\\tif (selectorPosition != lastSelectorPosition) {\\r\\n\\t\\t\\tbytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\r\\n\\t\\t\\tds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\r\\n\\t\\t\\tds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\r\\n\\t\\t}\\r\\n\\t\\t// delete the last selector\\r\\n\\t\\tds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\r\\n\\t\\tdelete ds.selectorToFacetAndPosition[_selector];\\r\\n\\r\\n\\t\\t// if no more selectors for facet address then delete the facet address\\r\\n\\t\\tif (lastSelectorPosition == 0) {\\r\\n\\t\\t\\t// replace facet address with last facet address and delete last facet address\\r\\n\\t\\t\\tuint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\r\\n\\t\\t\\tuint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\r\\n\\t\\t\\tif (facetAddressPosition != lastFacetAddressPosition) {\\r\\n\\t\\t\\t\\taddress lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\r\\n\\t\\t\\t\\tds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\r\\n\\t\\t\\t\\tds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tds.facetAddresses.pop();\\r\\n\\t\\t\\tdelete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction initializeDiamondCut(address _init, bytes memory _calldata) internal {\\r\\n\\t\\tif (LibUtil.isZeroAddress(_init)) {\\r\\n\\t\\t\\tif (_calldata.length != 0) {\\r\\n\\t\\t\\t\\trevert InitZeroButCalldataNotEmpty();\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (_calldata.length == 0) {\\r\\n\\t\\t\\t\\trevert CalldataEmptyButInitNotZero();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (_init != address(this)) {\\r\\n\\t\\t\\t\\tenforceHasContractCode(_init);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// solhint-disable-next-line avoid-low-level-calls\\r\\n\\t\\t\\t(bool success, bytes memory error) = _init.delegatecall(_calldata);\\r\\n\\t\\t\\tif (!success) {\\r\\n\\t\\t\\t\\tif (error.length > 0) {\\r\\n\\t\\t\\t\\t\\t// bubble up the error\\r\\n\\t\\t\\t\\t\\trevert(string(error));\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\trevert InitReverted();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction enforceHasContractCode(address _contract) internal view {\\r\\n\\t\\tuint256 contractSize;\\r\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tcontractSize := extcodesize(_contract)\\r\\n\\t\\t}\\r\\n\\t\\tif (contractSize == 0) {\\r\\n\\t\\t\\trevert FacetContainsNoCode();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Libraries/LibUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./LibBytes.sol\\\";\\r\\n\\r\\nlibrary LibUtil {\\r\\n\\tusing LibBytes for bytes;\\r\\n\\r\\n\\tfunction getRevertMsg(bytes memory _res) internal pure returns (string memory) {\\r\\n\\t\\t// If the _res length is less than 68, then the transaction failed silently (without a revert message)\\r\\n\\t\\tif (_res.length < 68) return \\\"Transaction reverted silently\\\";\\r\\n\\t\\tbytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\\r\\n\\t\\treturn abi.decode(revertData, (string)); // All that remains is the revert string\\r\\n\\t}\\r\\n\\r\\n\\t/// @notice Determines whether the given address is the zero address\\r\\n\\t/// @param addr The address to verify\\r\\n\\t/// @return Boolean indicating if the address is the zero address\\r\\n\\tfunction isZeroAddress(address addr) internal pure returns (bool) {\\r\\n\\t\\treturn addr == address(0);\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CalldataEmptyButInitNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FacetAddressIsNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FacetAddressIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FacetContainsNoCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FunctionAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FunctionDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FunctionIsImmutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectFacetCutAction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitReverted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitZeroButCalldataNotEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSelectorsInFace\",\"type\":\"error\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "KanaDiamond", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "00000000000000000000000001e6c37a730be3557cff6079f59c6fcf9274b3ba000000000000000000000000c21da2dac6c8cd8d8920cf6751093cd48332575d", "EVMVersion": "london", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}