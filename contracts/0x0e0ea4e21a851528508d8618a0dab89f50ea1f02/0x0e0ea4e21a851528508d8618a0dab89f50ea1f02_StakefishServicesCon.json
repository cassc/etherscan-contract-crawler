{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StakefishServicesContract.sol\": {\r\n      \"content\": \"// Copyright (C) 2021 BITFISH LIMITED\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./interfaces/deposit_contract.sol\\\";\\nimport \\\"./interfaces/IStakefishServicesContract.sol\\\";\\nimport \\\"./libraries/Address.sol\\\";\\n\\ncontract StakefishServicesContract is IStakefishServicesContract {\\n    using Address for address payable;\\n\\n    uint256 private constant HOUR = 3600;\\n    uint256 private constant DAY = 24 * HOUR;\\n    uint256 private constant WEEK = 7 * DAY;\\n    uint256 private constant YEAR = 365 * DAY;\\n    uint256 private constant MAX_SECONDS_IN_EXIT_QUEUE = 1 * YEAR;\\n    uint256 private constant COMMISSION_RATE_SCALE = 1000000;\\n\\n    // Packed into a single slot\\n    uint24 private _commissionRate;\\n    address private _operatorAddress;\\n    uint64 private _exitDate;\\n    State private _state;\\n\\n    bytes32 private _operatorDataCommitment;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    mapping(address => mapping(address => uint256)) private _allowedWithdrawals;\\n    mapping(address => uint256) private _deposits;\\n    uint256 private _totalDeposits;\\n    uint256 private _operatorClaimable;\\n\\n    IDepositContract public constant depositContract =\\n        IDepositContract(0x00000000219ab540356cBB839Cbe05303d7705Fa);\\n\\n    modifier onlyOperator() {\\n        require(\\n            msg.sender == _operatorAddress,\\n            \\\"Caller is not the operator\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier initializer() {\\n        require(\\n            _state == State.NotInitialized,\\n            \\\"Contract is already initialized\\\"\\n        );\\n        _state = State.PreDeposit;\\n        _;\\n    }\\n\\n    function initialize(\\n        uint24 commissionRate,\\n        address operatorAddress,\\n        bytes32 operatorDataCommitment\\n    )\\n        external\\n        initializer\\n    {\\n        require(uint256(commissionRate) <= COMMISSION_RATE_SCALE, \\\"Commission rate exceeds scale\\\");\\n\\n        _commissionRate = commissionRate;\\n        _operatorAddress = operatorAddress;\\n        _operatorDataCommitment = operatorDataCommitment;\\n    }\\n\\n    receive() payable external {\\n        if (_state == State.PreDeposit) {\\n            revert(\\\"Plain Ether transfer not allowed\\\");\\n        }\\n    }\\n\\n    function updateExitDate(uint64 newExitDate)\\n        external\\n        override\\n        onlyOperator\\n    {\\n        require(\\n            _state == State.PostDeposit,\\n            \\\"Validator is not active\\\"\\n        );\\n\\n        require(\\n            newExitDate < _exitDate,\\n            \\\"Not earlier than the original value\\\"\\n        );\\n\\n        _exitDate = newExitDate;\\n    }\\n\\n    function createValidator(\\n        bytes calldata validatorPubKey, // 48 bytes\\n        bytes calldata depositSignature, // 96 bytes\\n        bytes32 depositDataRoot,\\n        uint64 exitDate\\n    )\\n        external\\n        override\\n        onlyOperator\\n    {\\n\\n        require(_state == State.PreDeposit, \\\"Validator has been created\\\");\\n        _state = State.PostDeposit;\\n\\n        require(validatorPubKey.length == 48, \\\"Invalid validator public key\\\");\\n        require(depositSignature.length == 96, \\\"Invalid deposit signature\\\");\\n        require(_operatorDataCommitment == keccak256(\\n            abi.encodePacked(\\n                address(this),\\n                validatorPubKey,\\n                depositSignature,\\n                depositDataRoot,\\n                exitDate\\n            )\\n        ), \\\"Data doesn't match commitment\\\");\\n\\n        _exitDate = exitDate;\\n\\n        depositContract.deposit{value: 32 ether}(\\n            validatorPubKey,\\n            abi.encodePacked(uint96(0x010000000000000000000000), address(this)),\\n            depositSignature,\\n            depositDataRoot\\n        );\\n\\n        emit ValidatorDeposited(validatorPubKey);\\n    }\\n\\n    function deposit()\\n        external\\n        payable\\n        override\\n        returns (uint256 surplus)\\n    {\\n        require(\\n            _state == State.PreDeposit,\\n            \\\"Validator already created\\\"\\n        );\\n\\n        return _handleDeposit(msg.sender);\\n    }\\n\\n    function depositOnBehalfOf(address depositor)\\n        external\\n        payable\\n        override\\n        returns (uint256 surplus)\\n    {\\n        require(\\n            _state == State.PreDeposit,\\n            \\\"Validator already created\\\"\\n        );\\n        return _handleDeposit(depositor);\\n    }\\n\\n    function endOperatorServices()\\n        external\\n        override\\n    {\\n        uint256 balance = address(this).balance;\\n        require(balance > 0, \\\"Can't end with 0 balance\\\");\\n        require(_state == State.PostDeposit, \\\"Not allowed in the current state\\\");\\n        require((msg.sender == _operatorAddress && block.timestamp > _exitDate) ||\\n                (_deposits[msg.sender] > 0 && block.timestamp > _exitDate + MAX_SECONDS_IN_EXIT_QUEUE), \\\"Not allowed at the current time\\\");\\n\\n        _state = State.Withdrawn;\\n\\n        if (balance > 32 ether) {\\n            uint256 profit = balance - 32 ether;\\n            uint256 finalCommission = profit * _commissionRate / COMMISSION_RATE_SCALE;\\n            _operatorClaimable += finalCommission;\\n        }\\n\\n        emit ServiceEnd();\\n    }\\n\\n    function operatorClaim()\\n        external\\n        override\\n        onlyOperator\\n        returns (uint256)\\n    {\\n        uint256 claimable = _operatorClaimable;\\n        if (claimable > 0) {\\n            _operatorClaimable = 0;\\n            payable(_operatorAddress).sendValue(claimable);\\n\\n            emit Claim(_operatorAddress, claimable);\\n        }\\n\\n        return claimable;\\n    }\\n\\n    string private constant WITHDRAWALS_NOT_ALLOWED =\\n        \\\"Not allowed when validator is active\\\";\\n\\n    function withdrawAll(uint256 minimumETHAmount)\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        require(_state != State.PostDeposit, WITHDRAWALS_NOT_ALLOWED);\\n        uint256 value = _executeWithdrawal(msg.sender, payable(msg.sender), _deposits[msg.sender]);\\n        require(value >= minimumETHAmount, \\\"Less than minimum amount\\\");\\n        return value;\\n    }\\n\\n    function withdraw(\\n        uint256 amount,\\n        uint256 minimumETHAmount\\n    )\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        require(_state != State.PostDeposit, WITHDRAWALS_NOT_ALLOWED);\\n        uint256 value = _executeWithdrawal(msg.sender, payable(msg.sender), amount);\\n        require(value >= minimumETHAmount, \\\"Less than minimum amount\\\");\\n        return value;\\n    }\\n\\n    function withdrawTo(\\n        uint256 amount,\\n        address payable beneficiary,\\n        uint256 minimumETHAmount\\n    )\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        require(_state != State.PostDeposit, WITHDRAWALS_NOT_ALLOWED);\\n        uint256 value = _executeWithdrawal(msg.sender, beneficiary, amount);\\n        require(value >= minimumETHAmount, \\\"Less than minimum amount\\\");\\n        return value;\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function increaseAllowance(\\n        address spender,\\n        uint256 addedValue\\n    )\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    )\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\\n        return true;\\n    }\\n\\n    function forceDecreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    )\\n        external\\n        override\\n        returns (bool)\\n    {\\n        uint256 currentAllowance = _allowances[msg.sender][spender];\\n        _approve(msg.sender, spender, currentAllowance - _min(subtractedValue, currentAllowance));\\n        return true;\\n    }\\n\\n    function approveWithdrawal(\\n        address spender,\\n        uint256 amount\\n    )\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approveWithdrawal(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function increaseWithdrawalAllowance(\\n        address spender,\\n        uint256 addedValue\\n    )\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approveWithdrawal(msg.sender, spender, _allowedWithdrawals[msg.sender][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseWithdrawalAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    )\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approveWithdrawal(msg.sender, spender, _allowedWithdrawals[msg.sender][spender] - subtractedValue);\\n        return true;\\n    }\\n\\n    function forceDecreaseWithdrawalAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    )\\n        external\\n        override\\n        returns (bool)\\n    {\\n        uint256 currentAllowance = _allowedWithdrawals[msg.sender][spender];\\n        _approveWithdrawal(msg.sender, spender, currentAllowance - _min(subtractedValue, currentAllowance));\\n        return true;\\n    }\\n\\n    function withdrawFrom(\\n        address depositor,\\n        address payable beneficiary,\\n        uint256 amount,\\n        uint256 minimumETHAmount\\n    )\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        require(_state != State.PostDeposit, WITHDRAWALS_NOT_ALLOWED);\\n        uint256 spenderAllowance = _allowedWithdrawals[depositor][msg.sender];\\n        uint256 newAllowance = spenderAllowance - amount;\\n        // Please note that there is no need to require(_deposit <= spenderAllowance)\\n        // here because modern versions of Solidity insert underflow checks\\n        _allowedWithdrawals[depositor][msg.sender] = newAllowance;\\n        emit WithdrawalApproval(depositor, msg.sender, newAllowance);\\n\\n        uint256 value = _executeWithdrawal(depositor, beneficiary, amount);\\n        require(value >= minimumETHAmount, \\\"Less than minimum amount\\\");\\n        return value; \\n    }\\n\\n    function transferDeposit(\\n        address to,\\n        uint256 amount\\n    )\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function transferDepositFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        external\\n        override\\n        returns (bool)\\n    {\\n        uint256 currentAllowance = _allowances[from][msg.sender];\\n\\n        _approve(from, msg.sender, currentAllowance - amount);\\n        _transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    function withdrawalAllowance(\\n        address depositor,\\n        address spender\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowedWithdrawals[depositor][spender];\\n    }\\n\\n    function getCommissionRate()\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _commissionRate;\\n    }\\n\\n    function getExitDate()\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _exitDate;\\n    }\\n\\n    function getState()\\n        external\\n        view\\n        override\\n        returns(State)\\n    {\\n        return _state;\\n    }\\n\\n    function getOperatorAddress()\\n        external\\n        view\\n        override\\n        returns (address)\\n    {\\n        return _operatorAddress;\\n    }\\n\\n    function getDeposit(address depositor)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _deposits[depositor];\\n    }\\n\\n    function getTotalDeposits()\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _totalDeposits;\\n    }\\n\\n    function getAllowance(\\n        address owner,\\n        address spender\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function getOperatorDataCommitment()\\n        external\\n        view\\n        override\\n        returns (bytes32)\\n    {\\n        return _operatorDataCommitment;\\n    }\\n\\n    function getOperatorClaimable()\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _operatorClaimable;\\n    }\\n\\n    function getWithdrawableAmount(address owner)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        if (_state == State.PostDeposit) {\\n            return 0;\\n        }\\n\\n        return _deposits[owner] * (address(this).balance - _operatorClaimable) / _totalDeposits;\\n    }\\n\\n    function _executeWithdrawal(\\n        address depositor,\\n        address payable beneficiary,\\n        uint256 amount\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        require(amount > 0, \\\"Amount shouldn't be zero\\\");\\n\\n        uint256 value = amount * (address(this).balance - _operatorClaimable) / _totalDeposits;\\n        // Modern versions of Solidity automatically add underflow checks,\\n        // so we don't need to `require(_deposits[_depositor] < _deposit` here:\\n        _deposits[depositor] -= amount;\\n        _totalDeposits -= amount;\\n        emit Withdrawal(depositor, beneficiary, amount, value);\\n        payable(beneficiary).sendValue(value);\\n\\n        return value;\\n    }\\n\\n    // NOTE: This throws (on underflow) if the contract's balance was more than\\n    // 32 ether before the call\\n    function _handleDeposit(address depositor)\\n        internal\\n        returns (uint256 surplus)\\n    {\\n        uint256 depositSize = msg.value;\\n        surplus = (address(this).balance > 32 ether) ?\\n            (address(this).balance - 32 ether) : 0;\\n\\n        uint256 acceptedDeposit = depositSize - surplus;\\n\\n        _deposits[depositor] += acceptedDeposit;\\n        _totalDeposits += acceptedDeposit;\\n\\n        emit Deposit(depositor, acceptedDeposit);\\n        \\n        if (surplus > 0) {\\n            payable(depositor).sendValue(surplus);\\n        }\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n    {\\n        require(to != address(0), \\\"Transfer to the zero address\\\");\\n\\n        _deposits[from] -= amount;\\n        _deposits[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    )\\n        internal\\n    {\\n        require(spender != address(0), \\\"Approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _approveWithdrawal(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    )\\n        internal\\n    {\\n        require(spender != address(0), \\\"Approve to the zero address\\\");\\n\\n        _allowedWithdrawals[owner][spender] = amount;\\n        emit WithdrawalApproval(owner, spender, amount);\\n    }\\n\\n    function _min(\\n        uint256 a,\\n        uint256 b\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return a < b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/deposit_contract.sol\": {\r\n      \"content\": \"// \u250f\u2501\u2501\u2501\u2513\u2501\u250f\u2513\u2501\u250f\u2513\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u2513\u2501\u2501\u2501\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u2513\u2501\\n// \u2503\u250f\u2501\u2501\u251b\u250f\u251b\u2517\u2513\u2503\u2503\u2501\u2501\u2503\u250f\u2501\u2513\u2503\u2501\u2501\u2503\u250f\u2501\u2513\u2503\u2501\u2501\u2501\u2501\u2517\u2513\u250f\u2513\u2503\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u2513\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2513\u2503\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u2513\\n// \u2503\u2517\u2501\u2501\u2513\u2517\u2513\u250f\u251b\u2503\u2517\u2501\u2513\u2517\u251b\u250f\u251b\u2503\u2501\u2501\u2503\u2503\u2501\u2503\u2503\u2501\u2501\u2501\u2501\u2501\u2503\u2503\u2503\u2503\u250f\u2501\u2501\u2513\u250f\u2501\u2501\u2513\u250f\u2501\u2501\u2513\u250f\u2501\u2501\u2513\u250f\u2513\u2517\u2513\u250f\u251b\u2501\u2501\u2501\u2501\u2503\u2503\u2501\u2517\u251b\u250f\u2501\u2501\u2513\u250f\u2501\u2513\u2501\u2517\u2513\u250f\u251b\u250f\u2501\u2513\u250f\u2501\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u2517\u2513\u250f\u251b\\n// \u2503\u250f\u2501\u2501\u251b\u2501\u2503\u2503\u2501\u2503\u250f\u2513\u2503\u250f\u2501\u251b\u250f\u251b\u2501\u2501\u2503\u2503\u2501\u2503\u2503\u2501\u2501\u2501\u2501\u2501\u2503\u2503\u2503\u2503\u2503\u250f\u2513\u2503\u2503\u250f\u2513\u2503\u2503\u250f\u2513\u2503\u2503\u2501\u2501\u252b\u2523\u252b\u2501\u2503\u2503\u2501\u2501\u2501\u2501\u2501\u2503\u2503\u2501\u250f\u2513\u2503\u250f\u2513\u2503\u2503\u250f\u2513\u2513\u2501\u2503\u2503\u2501\u2503\u250f\u251b\u2517\u2501\u2513\u2503\u2501\u2503\u250f\u2501\u251b\u2501\u2503\u2503\u2501\\n// \u2503\u2517\u2501\u2501\u2513\u2501\u2503\u2517\u2513\u2503\u2503\u2503\u2503\u2503\u2503\u2517\u2501\u2513\u250f\u2513\u2503\u2517\u2501\u251b\u2503\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u251b\u2503\u2503\u2503\u2501\u252b\u2503\u2517\u251b\u2503\u2503\u2517\u251b\u2503\u2523\u2501\u2501\u2503\u2503\u2503\u2501\u2503\u2517\u2513\u2501\u2501\u2501\u2501\u2503\u2517\u2501\u251b\u2503\u2503\u2517\u251b\u2503\u2503\u2503\u2503\u2503\u2501\u2503\u2517\u2513\u2503\u2503\u2501\u2503\u2517\u251b\u2517\u2513\u2503\u2517\u2501\u2513\u2501\u2503\u2517\u2513\\n// \u2517\u2501\u2501\u2501\u251b\u2501\u2517\u2501\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u2501\u251b\u2517\u251b\u2517\u2501\u2501\u2501\u251b\u2501\u2501\u2501\u2501\u2517\u2501\u2501\u2501\u251b\u2517\u2501\u2501\u251b\u2503\u250f\u2501\u251b\u2517\u2501\u2501\u251b\u2517\u2501\u2501\u251b\u2517\u251b\u2501\u2517\u2501\u251b\u2501\u2501\u2501\u2501\u2517\u2501\u2501\u2501\u251b\u2517\u2501\u2501\u251b\u2517\u251b\u2517\u251b\u2501\u2517\u2501\u251b\u2517\u251b\u2501\u2517\u2501\u2501\u2501\u251b\u2517\u2501\u2501\u251b\u2501\u2517\u2501\u251b\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2503\u2503\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2517\u251b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n\\n// SPDX-License-Identifier: CC0-1.0\\n\\npragma solidity 0.8.4;\\n\\n// This interface is designed to be compatible with the Vyper version.\\n/// @notice This is the Ethereum 2.0 deposit contract interface.\\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\\ninterface IDepositContract {\\n    /// @notice A processed deposit event.\\n    event DepositEvent(\\n        bytes pubkey,\\n        bytes withdrawal_credentials,\\n        bytes amount,\\n        bytes signature,\\n        bytes index\\n    );\\n\\n    /// @notice Submit a Phase 0 DepositData object.\\n    /// @param pubkey A BLS12-381 public key.\\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\\n    /// @param signature A BLS12-381 signature.\\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n    /// Used as a protection against malformed input.\\n    function deposit(\\n        bytes calldata pubkey,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signature,\\n        bytes32 deposit_data_root\\n    ) external payable;\\n\\n    /// @notice Query the current deposit root hash.\\n    /// @return The deposit root hash.\\n    function get_deposit_root() external view returns (bytes32);\\n\\n    /// @notice Query the current deposit count.\\n    /// @return The deposit count encoded as a little endian 64-bit number.\\n    function get_deposit_count() external view returns (bytes memory);\\n}\\n\\n// Based on official specification in https://eips.ethereum.org/EIPS/eip-165\\ninterface ERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceId` and\\n    ///  `interfaceId` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\\n}\\n\\n// This is a rewrite of the Vyper Eth2.0 deposit contract in Solidity.\\n// It tries to stay as close as possible to the original source code.\\n/// @notice This is the Ethereum 2.0 deposit contract interface.\\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\\ncontract DepositContract is IDepositContract, ERC165 {\\n    uint constant DEPOSIT_CONTRACT_TREE_DEPTH = 32;\\n    // NOTE: this also ensures `deposit_count` will fit into 64-bits\\n    uint constant MAX_DEPOSIT_COUNT = 2**DEPOSIT_CONTRACT_TREE_DEPTH - 1;\\n\\n    bytes32[DEPOSIT_CONTRACT_TREE_DEPTH] branch;\\n    uint256 deposit_count;\\n\\n    bytes32[DEPOSIT_CONTRACT_TREE_DEPTH] zero_hashes;\\n\\n    constructor() {\\n        // Compute hashes in empty sparse Merkle tree\\n        for (uint height = 0; height < DEPOSIT_CONTRACT_TREE_DEPTH - 1; height++)\\n            zero_hashes[height + 1] = sha256(abi.encodePacked(zero_hashes[height], zero_hashes[height]));\\n    }\\n\\n    function get_deposit_root() override external view returns (bytes32) {\\n        bytes32 node;\\n        uint size = deposit_count;\\n        for (uint height = 0; height < DEPOSIT_CONTRACT_TREE_DEPTH; height++) {\\n            if ((size & 1) == 1)\\n                node = sha256(abi.encodePacked(branch[height], node));\\n            else\\n                node = sha256(abi.encodePacked(node, zero_hashes[height]));\\n            size /= 2;\\n        }\\n        return sha256(abi.encodePacked(\\n            node,\\n            to_little_endian_64(uint64(deposit_count)),\\n            bytes24(0)\\n        ));\\n    }\\n\\n    function get_deposit_count() override external view returns (bytes memory) {\\n        return to_little_endian_64(uint64(deposit_count));\\n    }\\n\\n    function deposit(\\n        bytes calldata pubkey,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signature,\\n        bytes32 deposit_data_root\\n    ) override external payable {\\n        // Extended ABI length checks since dynamic types are used.\\n        require(pubkey.length == 48, \\\"DepositContract: invalid pubkey length\\\");\\n        require(withdrawal_credentials.length == 32, \\\"DepositContract: invalid withdrawal_credentials length\\\");\\n        require(signature.length == 96, \\\"DepositContract: invalid signature length\\\");\\n\\n        // Check deposit amount\\n        require(msg.value >= 1 ether, \\\"DepositContract: deposit value too low\\\");\\n        require(msg.value % 1 gwei == 0, \\\"DepositContract: deposit value not multiple of gwei\\\");\\n        uint deposit_amount = msg.value / 1 gwei;\\n        require(deposit_amount <= type(uint64).max, \\\"DepositContract: deposit value too high\\\");\\n\\n        // Emit `DepositEvent` log\\n        bytes memory amount = to_little_endian_64(uint64(deposit_amount));\\n        emit DepositEvent(\\n            pubkey,\\n            withdrawal_credentials,\\n            amount,\\n            signature,\\n            to_little_endian_64(uint64(deposit_count))\\n        );\\n\\n        // Compute deposit data root (`DepositData` hash tree root)\\n        bytes32 pubkey_root = sha256(abi.encodePacked(pubkey, bytes16(0)));\\n        bytes32 signature_root = sha256(abi.encodePacked(\\n            sha256(abi.encodePacked(signature[:64])),\\n            sha256(abi.encodePacked(signature[64:], bytes32(0)))\\n        ));\\n        bytes32 node = sha256(abi.encodePacked(\\n            sha256(abi.encodePacked(pubkey_root, withdrawal_credentials)),\\n            sha256(abi.encodePacked(amount, bytes24(0), signature_root))\\n        ));\\n\\n        // Verify computed and expected deposit data roots match\\n        require(node == deposit_data_root, \\\"DepositContract: reconstructed DepositData does not match supplied deposit_data_root\\\");\\n\\n        // Avoid overflowing the Merkle tree (and prevent edge case in computing `branch`)\\n        require(deposit_count < MAX_DEPOSIT_COUNT, \\\"DepositContract: merkle tree full\\\");\\n\\n        // Add deposit data root to Merkle tree (update a single `branch` node)\\n        deposit_count += 1;\\n        uint size = deposit_count;\\n        for (uint height = 0; height < DEPOSIT_CONTRACT_TREE_DEPTH; height++) {\\n            if ((size & 1) == 1) {\\n                branch[height] = node;\\n                return;\\n            }\\n            node = sha256(abi.encodePacked(branch[height], node));\\n            size /= 2;\\n        }\\n        // As the loop should always end prematurely with the `return` statement,\\n        // this code should be unreachable. We assert `false` just to be safe.\\n        assert(false);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) override external pure returns (bool) {\\n        return interfaceId == type(ERC165).interfaceId || interfaceId == type(IDepositContract).interfaceId;\\n    }\\n\\n    function to_little_endian_64(uint64 value) internal pure returns (bytes memory ret) {\\n        ret = new bytes(8);\\n        bytes8 bytesValue = bytes8(value);\\n        // Byteswapping during copying to bytes.\\n        ret[0] = bytesValue[7];\\n        ret[1] = bytesValue[6];\\n        ret[2] = bytesValue[5];\\n        ret[3] = bytesValue[4];\\n        ret[4] = bytesValue[3];\\n        ret[5] = bytesValue[2];\\n        ret[6] = bytesValue[1];\\n        ret[7] = bytesValue[0];\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakefishServicesContract.sol\": {\r\n      \"content\": \"// Copyright (C) 2021 BITFISH LIMITED\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-3.0-only\\n\\n\\npragma solidity ^0.8.0;\\n\\n/// @notice Governs the life cycle of a single Eth2 validator with ETH provided by multiple stakers.\\ninterface IStakefishServicesContract {\\n    /// @notice The life cycle of a services contract.\\n    enum State {\\n        NotInitialized,\\n        PreDeposit,\\n        PostDeposit,\\n        Withdrawn\\n    }\\n\\n    /// @notice Emitted when a `spender` is set to allow the transfer of an `owner`'s deposit stake amount.\\n    /// `amount` is the new allownace.\\n    /// @dev Also emitted when {transferDepositFrom} is called.\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n\\n    /// @notice Emitted when deposit stake amount is transferred.\\n    /// @param from The address of deposit stake owner.\\n    /// @param to The address of deposit stake beneficiary.\\n    /// @param amount The amount of transferred deposit stake.\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount\\n    );\\n\\n    /// @notice Emitted when a `spender` is set to allow withdrawal on behalf of a `owner`.\\n    /// `amount` is the new allowance.\\n    /// @dev Also emitted when {WithdrawFrom} is called.\\n    event WithdrawalApproval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n\\n    /// @notice Emitted when `owner`'s ETH are withdrawan to `to`.\\n    /// @param owner The address of deposit stake owner.\\n    /// @param to The address of ETH beneficiary.\\n    /// @param amount The amount of deposit stake to be converted to ETH.\\n    /// @param value The amount of withdrawn ETH.\\n    event Withdrawal(\\n        address indexed owner,\\n        address indexed to,\\n        uint256 amount,\\n        uint256 value\\n    );\\n\\n    /// @notice Emitted when 32 ETH is transferred to the eth2 deposit contract.\\n    /// @param pubkey A BLS12-381 public key.\\n    event ValidatorDeposited(\\n        bytes pubkey // 48 bytes\\n    );\\n\\n    /// @notice Emitted when a validator exits and the operator settles the commission.\\n    event ServiceEnd();\\n\\n    /// @notice Emitted when deposit to the services contract.\\n    /// @param from The address of the deposit stake owner.\\n    /// @param amount The accepted amount of ETH deposited into the services contract.\\n    event Deposit(\\n        address from,\\n        uint256 amount\\n    );\\n\\n    /// @notice Emitted when operaotr claims commission fee.\\n    /// @param receiver The address of the operator.\\n    /// @param amount The amount of ETH sent to the operator address.\\n    event Claim(\\n        address receiver,\\n        uint256 amount\\n    );\\n\\n    /// @notice Updates the exit date of the validator.\\n    /// @dev The exit date should be in the range of uint64.\\n    /// @param newExitDate The new exit date should come before the previously specified exit date.\\n    function updateExitDate(uint64 newExitDate) external;\\n\\n    /// @notice Submits a Phase 0 DepositData to the eth2 deposit contract.\\n    /// @dev The Keccak hash of the contract address and all submitted data should match the `_operatorDataCommitment`.\\n    /// Emits a {ValidatorDeposited} event.\\n    /// @param validatorPubKey A BLS12-381 public key.\\n    /// @param depositSignature A BLS12-381 signature.\\n    /// @param depositDataRoot The SHA-256 hash of the SSZ-encoded DepositData object.\\n    /// @param exitDate The expected exit date of the created validator\\n    function createValidator(\\n        bytes calldata validatorPubKey, // 48 bytes\\n        bytes calldata depositSignature, // 96 bytes\\n        bytes32 depositDataRoot,\\n        uint64 exitDate\\n    ) external;\\n\\n    /// @notice Deposits `msg.value` of ETH.\\n    /// @dev If the balance of the contract exceeds 32 ETH, the excess will be sent\\n    /// back to `msg.sender`.\\n    /// Emits a {Deposit} event.\\n    function deposit() external payable returns (uint256 surplus);\\n\\n\\n    /// @notice Deposits `msg.value` of ETH on behalf of `depositor`.\\n    /// @dev If the balance of the contract exceeds 32 ETH, the excess will be sent\\n    /// back to `depositor`.\\n    /// Emits a {Deposit} event.\\n    function depositOnBehalfOf(address depositor) external payable returns (uint256 surplus);\\n\\n    /// @notice Settles operator service commission and enable withdrawal.\\n    /// @dev It can be called by operator if the time has passed `_exitDate`.\\n    /// It can be called by any address if the time has passed `_exitDate + MAX_SECONDS_IN_EXIT_QUEUE`.\\n    /// Emits a {ServiceEnd} event.\\n    function endOperatorServices() external;\\n\\n    /// @notice Withdraws all the ETH of `msg.sender`.\\n    /// @dev It can only be called when the contract state is not `PostDeposit`.\\n    /// Emits a {Withdrawal} event.\\n    /// @param minimumETHAmount The minimum amount of ETH that must be received for the transaction not to revert.\\n    function withdrawAll(uint256 minimumETHAmount) external returns (uint256);\\n\\n    /// @notice Withdraws the ETH of `msg.sender` which is corresponding to the `amount` of deposit stake.\\n    /// @dev It can only be called when the contract state is not `PostDeposit`.\\n    /// Emits a {Withdrawal} event.\\n    /// @param amount The amount of deposit stake to be converted to ETH.\\n    /// @param minimumETHAmount The minimum amount of ETH that must be received for the transaction not to revert.\\n    function withdraw(uint256 amount, uint256 minimumETHAmount) external returns (uint256);\\n\\n    /// @notice Withdraws the ETH of `msg.sender` which is corresponding to the `amount` of deposit stake to a specified address.\\n    /// @dev It can only be called when the contract state is not `PostDeposit`.\\n    /// Emits a {Withdrawal} event.\\n    /// @param amount The amount of deposit stake to be converted to ETH.\\n    /// @param beneficiary The address of ETH receiver.\\n    /// @param minimumETHAmount The minimum amount of ETH that must be received for the transaction not to revert.\\n    function withdrawTo(\\n        uint256 amount,\\n        address payable beneficiary,\\n        uint256 minimumETHAmount\\n    ) external returns (uint256);\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's deposit stake.\\n    /// @dev Emits an {Approval} event.\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Increases the allowance granted to `spender` by the caller.\\n    /// @dev Emits an {Approval} event indicating the upated allowances;\\n    function increaseAllowance(address spender, uint256 addValue) external returns (bool);\\n\\n    /// @notice Decreases the allowance granted to `spender` by the caller.\\n    /// @dev Emits an {Approval} event indicating the upated allowances;\\n    /// It reverts if current allowance is less than `subtractedValue`.\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /// @notice Decreases the allowance granted to `spender` by the caller.\\n    /// @dev Emits an {Approval} event indicating the upated allowances;\\n    /// It sets allowance to zero if current allowance is less than `subtractedValue`.\\n    function forceDecreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's deposit amount that can be withdrawn.\\n    /// @dev Emits an {WithdrawalApproval} event.\\n    function approveWithdrawal(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Increases the allowance of withdrawal granted to `spender` by the caller.\\n    /// @dev Emits an {WithdrawalApproval} event indicating the upated allowances;\\n    function increaseWithdrawalAllowance(address spender, uint256 addValue) external returns (bool);\\n\\n    /// @notice Decreases the allowance of withdrawal granted to `spender` by the caller.\\n    /// @dev Emits an {WithdrawwalApproval} event indicating the upated allowances;\\n    /// It reverts if current allowance is less than `subtractedValue`.\\n    function decreaseWithdrawalAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /// @notice Decreases the allowance of withdrawal granted to `spender` by the caller.\\n    /// @dev Emits an {WithdrawwalApproval} event indicating the upated allowances;\\n    /// It reverts if current allowance is less than `subtractedValue`.\\n    function forceDecreaseWithdrawalAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /// @notice Withdraws the ETH of `depositor` which is corresponding to the `amount` of deposit stake to a specified address.\\n    /// @dev Emits a {Withdrawal} event.\\n    /// Emits a {WithdrawalApproval} event indicating the updated allowance.\\n    /// @param depositor The address of deposit stake holder.\\n    /// @param beneficiary The address of ETH receiver.\\n    /// @param amount The amount of deposit stake to be converted to ETH.\\n    /// @param minimumETHAmount The minimum amount of ETH that must be received for the transaction not to revert.\\n    function withdrawFrom(\\n        address depositor,\\n        address payable beneficiary,\\n        uint256 amount,\\n        uint256 minimumETHAmount\\n    ) external returns (uint256);\\n\\n    /// @notice Transfers `amount` deposit stake from caller to `to`.\\n    /// @dev Emits a {Transfer} event.\\n    function transferDeposit(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` deposit stake from `from` to `to`.\\n    /// @dev Emits a {Transfer} event.\\n    /// Emits an {Approval} event indicating the updated allowance.\\n    function transferDepositFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /// @notice Transfers operator claimable commission fee to the operator address.\\n    /// @dev Emits a {Claim} event.\\n    function operatorClaim() external returns (uint256);\\n\\n    /// @notice Returns the remaining number of deposit stake that `spender` will be allowed to withdraw\\n    /// on behalf of `depositor` through {withdrawFrom}.\\n    function withdrawalAllowance(address depositor, address spender) external view returns (uint256);\\n\\n    /// @notice Returns the operator service commission rate.\\n    function getCommissionRate() external view returns (uint256);\\n\\n    /// @notice Returns operator claimable commission fee.\\n    function getOperatorClaimable() external view returns (uint256);\\n\\n    /// @notice Returns the exit date of the validator.\\n    function getExitDate() external view returns (uint256);\\n\\n    /// @notice Returns the state of the contract.\\n    function getState() external view returns (State);\\n\\n    /// @notice Returns the address of operator.\\n    function getOperatorAddress() external view returns (address);\\n\\n    /// @notice Returns the amount of deposit stake owned by `depositor`.\\n    function getDeposit(address depositor) external view returns (uint256);\\n\\n    /// @notice Returns the total amount of deposit stake.\\n    function getTotalDeposits() external view returns (uint256);\\n\\n    /// @notice Returns the remaining number of deposit stake that `spender` will be allowed to transfer\\n    /// on behalf of `depositor` through {transferDepositFrom}.\\n    function getAllowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Returns the commitment which is the hash of the contract address and all inputs to the `createValidator` function.\\n    function getOperatorDataCommitment() external view returns (bytes32);\\n\\n    /// @notice Returns the amount of ETH that is withdrawable by `owner`.\\n    function getWithdrawableAmount(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4d0f8c1da8654a478f046ea7cf83d2166e1025af/contracts/utils/Address.sol\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ServiceEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"}],\"name\":\"ValidatorDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawalApproval\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveWithdrawal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"validatorPubKey\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"depositSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"depositDataRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"exitDate\",\"type\":\"uint64\"}],\"name\":\"createValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseWithdrawalAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"surplus\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositContract\",\"outputs\":[{\"internalType\":\"contract IDepositContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"depositOnBehalfOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"surplus\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endOperatorServices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"forceDecreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"forceDecreaseWithdrawalAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"getAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCommissionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExitDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperatorClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperatorDataCommitment\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"internalType\":\"enum IStakefishServicesContract.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getWithdrawableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseWithdrawalAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"commissionRate\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"operatorAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"operatorDataCommitment\",\"type\":\"bytes32\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferDepositFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"newExitDate\",\"type\":\"uint64\"}],\"name\":\"updateExitDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumETHAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumETHAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumETHAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumETHAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"withdrawalAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StakefishServicesContract", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}