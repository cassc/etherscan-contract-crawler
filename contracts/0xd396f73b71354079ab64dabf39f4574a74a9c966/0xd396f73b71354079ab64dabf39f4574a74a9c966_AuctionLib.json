{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary Constants {\\n    /// @notice Flooring protocol\\n    /// @dev floor token amount of 1 NFT (with 18 decimals)\\n    uint256 public constant FLOOR_TOKEN_AMOUNT = 1_000_000 ether;\\n    /// @dev The minimum vip level required to use `proxy collection`\\n    uint8 public constant PROXY_COLLECTION_VIP_THRESHOLD = 3;\\n\\n    /// @notice Rolling Bucket Constant Conf\\n    uint256 public constant BUCKET_SPAN_1 = 259199 seconds; // BUCKET_SPAN minus 1, used for rounding up\\n    uint256 public constant BUCKET_SPAN = 3 days;\\n    uint256 public constant MAX_LOCKING_BUCKET = 240;\\n    uint256 public constant MAX_LOCKING_PERIOD = 720 days; // MAX LOCKING BUCKET * BUCKET_SPAN\\n\\n    /// @notice Auction Config\\n    uint256 public constant FREE_AUCTION_PERIOD = 24 hours;\\n    uint256 public constant AUCTION_INITIAL_PERIODS = 24 hours;\\n    uint256 public constant AUCTION_COMPLETE_GRACE_PERIODS = 2 days;\\n    /// @dev minimum bid per NFT when someone starts aution on expired safebox\\n    uint256 public constant AUCTION_ON_EXPIRED_MINIMUM_BID = 1000 ether;\\n    /// @dev admin fee charged per NFT when someone starts aution on expired safebox\\n    uint256 public constant AUCTION_ON_EXPIRED_SAFEBOX_COST = 2000 ether;\\n    /// @dev admin fee charged per NFT when owner starts aution on himself safebox\\n    uint256 public constant AUCTION_COST = 2000 ether;\\n\\n    /// @notice Raffle Config\\n    uint256 public constant RAFFLE_COST = 5000 ether;\\n    uint256 public constant RAFFLE_COMPLETE_GRACE_PERIODS = 2 days;\\n\\n    /// @notice Private offer Config\\n    uint256 public constant PRIVATE_OFFER_DURATION = 24 hours;\\n    uint256 public constant PRIVATE_OFFER_COMPLETE_GRACE_DURATION = 2 days;\\n    uint256 public constant PRIVATE_OFFER_COST = 0;\\n\\n    uint256 public constant ADD_FREE_NFT_REWARD = 0;\\n\\n    /// @notice Lock/Unlock config\\n    uint256 public constant LOCKING_RAMP_UP_THRESHOLD = 20;\\n\\n    uint256 public constant LOCKING_PCT_TO_SAFEBOX_MAINT_MIN = 6000 ether;\\n    uint256 public constant LOCKING_PCT_TO_SAFEBOX_MAINT_MAX = 1728000 ether;\\n\\n    /// @notice Activities Fee Rate\\n\\n    /// @notice Fee rate used to distribute funds that collected from Auctions on expired safeboxes.\\n    /// these auction would be settled using credit token\\n    uint256 public constant FREE_AUCTION_FEE_RATE_BIPS = 2000; // 20%\\n    /// @notice Fee rate settled with credit token\\n    uint256 public constant CREDIT_FEE_RATE_BIPS = 150; // 2%\\n    /// @notice Fee rate settled with specified token\\n    uint256 public constant SPEC_FEE_RATE_BIPS = 300; // 3%\\n    /// @notice Fee rate settled with all other tokens\\n    uint256 public constant COMMON_FEE_RATE_BIPS = 500; // 5%\\n\\n    uint256 public constant VIP_LEVEL_COUNT = 8;\\n\\n    struct AuctionBidOption {\\n        uint256 extendDurationSecs;\\n        uint256 minimumRaisePct;\\n        uint256 vipLevel;\\n    }\\n\\n    function getVipLockingBuckets(uint256 vipLevel) internal pure returns (uint256 buckets) {\\n        require(vipLevel < VIP_LEVEL_COUNT);\\n        assembly {\\n            switch vipLevel\\n            case 1 { buckets := 1 }\\n            case 2 { buckets := 5 }\\n            case 3 { buckets := 20 }\\n            case 4 { buckets := 60 }\\n            case 5 { buckets := 120 }\\n            case 6 { buckets := 240 }\\n            case 7 { buckets := MAX_LOCKING_BUCKET }\\n        }\\n    }\\n\\n    function getVipLevel(uint256 totalCredit) internal pure returns (uint8) {\\n        if (totalCredit < 50_000 ether) {\\n            return 0;\\n        } else if (totalCredit < 200_000 ether) {\\n            return 1;\\n        } else if (totalCredit < 500_000 ether) {\\n            return 2;\\n        } else if (totalCredit < 2_000_000 ether) {\\n            return 3;\\n        } else if (totalCredit < 5_000_000 ether) {\\n            return 4;\\n        } else if (totalCredit < 20_000_000 ether) {\\n            return 5;\\n        } else if (totalCredit < 50_000_000 ether) {\\n            return 6;\\n        } else {\\n            return 7;\\n        }\\n    }\\n\\n    function getVipBalanceRequirements(uint256 vipLevel) internal pure returns (uint256 required) {\\n        require(vipLevel < VIP_LEVEL_COUNT);\\n\\n        assembly {\\n            switch vipLevel\\n            case 1 { required := 50000 }\\n            case 2 { required := 200000 }\\n            case 3 { required := 500000 }\\n            case 4 { required := 2000000 }\\n            case 5 { required := 5000000 }\\n            case 6 { required := 20000000 }\\n            case 7 { required := 50000000 }\\n        }\\n\\n        /// credit token should be scaled with 18 decimals(1 ether == 10**18)\\n        unchecked {\\n            return required * 1 ether;\\n        }\\n    }\\n\\n    function getBidOption(uint256 idx) internal pure returns (AuctionBidOption memory) {\\n        require(idx < 4);\\n        AuctionBidOption[4] memory bidOptions = [\\n            AuctionBidOption({extendDurationSecs: 5 minutes, minimumRaisePct: 1, vipLevel: 0}),\\n            AuctionBidOption({extendDurationSecs: 8 hours, minimumRaisePct: 10, vipLevel: 3}),\\n            AuctionBidOption({extendDurationSecs: 16 hours, minimumRaisePct: 20, vipLevel: 5}),\\n            AuctionBidOption({extendDurationSecs: 24 hours, minimumRaisePct: 40, vipLevel: 7})\\n        ];\\n        return bidOptions[idx];\\n    }\\n\\n    function raffleDurations(uint256 idx) internal pure returns (uint256 vipLevel, uint256 duration) {\\n        require(idx < 6);\\n\\n        vipLevel = idx;\\n        assembly {\\n            switch idx\\n            case 1 { duration := 1 }\\n            case 2 { duration := 2 }\\n            case 3 { duration := 3 }\\n            case 4 { duration := 5 }\\n            case 5 { duration := 7 }\\n        }\\n        unchecked {\\n            duration *= 1 days;\\n        }\\n    }\\n\\n    function getVipRequiredStakingWithDiscount(uint256 requiredStaking, uint8 vipLevel)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (vipLevel < 3) {\\n            return requiredStaking;\\n        }\\n        unchecked {\\n            /// the higher vip level, more discount for staking\\n            ///  discount range: 10% - 50%\\n            return requiredStaking * (100 - (vipLevel - 2) * 10) / 100;\\n        }\\n    }\\n\\n    function getRequiredStakingForLockRatio(uint256 locked, uint256 totalManaged) internal pure returns (uint256) {\\n        if (totalManaged < Constants.LOCKING_RAMP_UP_THRESHOLD) {\\n            return 6000 ether;\\n        }\\n\\n        unchecked {\\n            uint256 lockingRatioPct = locked * 100 / totalManaged;\\n            if (lockingRatioPct <= 40) {\\n                return 6000 ether;\\n            } else if (lockingRatioPct < 60) {\\n                return 6600 ether + ((lockingRatioPct - 40) >> 1) * 600 ether;\\n            } else if (lockingRatioPct < 70) {\\n                return 13200 ether + ((lockingRatioPct - 60) >> 1) * 1200 ether;\\n            } else if (lockingRatioPct < 80) {\\n                return 20400 ether + ((lockingRatioPct - 70) >> 1) * 2400 ether;\\n            } else if (lockingRatioPct < 90) {\\n                return 34800 ether + ((lockingRatioPct - 80) >> 1) * 4800 ether;\\n            } else if (lockingRatioPct < 100) {\\n                /// 108000 * 2^x\\n                return 108000 ether << ((lockingRatioPct - 90) >> 1);\\n            } else {\\n                return 1728000 ether;\\n            }\\n        }\\n    }\\n\\n    function getVipClaimCostWithDiscount(uint256 cost, uint8 vipLevel) internal pure returns (uint256) {\\n        if (vipLevel < 3) {\\n            return cost;\\n        }\\n\\n        unchecked {\\n            uint256 discount = 4000 ether << (vipLevel - 3);\\n            if (cost < discount) {\\n                return 0;\\n            } else {\\n                return cost - discount;\\n            }\\n        }\\n    }\\n\\n    function getClaimExpiredCost(uint256 locked, uint256 totalManaged, uint8 vipLevel)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 realCost = getClaimCost(locked, totalManaged);\\n        return getVipClaimCostWithDiscount(realCost, vipLevel);\\n    }\\n\\n    function getClaimRandomCost(uint256 locked, uint256 totalManaged, uint8 vipLevel) internal pure returns (uint256) {\\n        uint256 realCost = getClaimCost(locked, totalManaged);\\n        return getVipClaimCostWithDiscount(realCost, vipLevel);\\n    }\\n\\n    function getClaimCost(uint256 locked, uint256 totalManaged) private pure returns (uint256) {\\n        if (totalManaged < Constants.LOCKING_RAMP_UP_THRESHOLD) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            uint256 lockingRatioPct = locked * 100 / totalManaged;\\n\\n            if (lockingRatioPct <= 60) {\\n                return 0;\\n            } else if (lockingRatioPct < 100) {\\n                uint256 cost = 1 ether;\\n                assembly {\\n                    switch shr(1, sub(lockingRatioPct, 60))\\n                    case 0 { cost := mul(cost, 400) }\\n                    case 1 { cost := mul(cost, 600) }\\n                    case 2 { cost := mul(cost, 800) }\\n                    case 3 { cost := mul(cost, 1200) }\\n                    case 4 { cost := mul(cost, 1600) }\\n                    case 5 { cost := mul(cost, 2400) }\\n                    case 6 { cost := mul(cost, 3200) }\\n                    case 7 { cost := mul(cost, 4800) }\\n                    case 8 { cost := mul(cost, 6400) }\\n                    case 9 { cost := mul(cost, 9600) }\\n                    case 10 { cost := mul(cost, 12800) }\\n                    case 11 { cost := mul(cost, 19200) }\\n                    case 12 { cost := mul(cost, 25600) }\\n                    case 13 { cost := mul(cost, 38400) }\\n                    case 14 { cost := mul(cost, 51200) }\\n                    case 15 { cost := mul(cost, 76800) }\\n                    case 16 { cost := mul(cost, 102400) }\\n                    case 17 { cost := mul(cost, 153600) }\\n                    case 18 { cost := mul(cost, 204800) }\\n                    case 19 { cost := mul(cost, 307200) }\\n                }\\n                return cost;\\n            } else {\\n                return 307200 ether;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary Errors {\\n    /// @notice Safe Box error\\n    error SafeBoxHasExpire();\\n    error SafeBoxNotExist();\\n    error SafeBoxHasNotExpire();\\n    error SafeBoxAlreadyExist();\\n    error NoMatchingSafeBoxKey();\\n    error SafeBoxKeyAlreadyExist();\\n\\n    /// @notice Auction error\\n    error AuctionHasNotCompleted();\\n    error AuctionHasExpire();\\n    error AuctionBidIsNotHighEnough();\\n    error AuctionBidTokenMismatch();\\n    error AuctionSelfBid();\\n    error AuctionInvalidBidAmount();\\n    error AuctionNotExist();\\n    error SafeBoxAuctionWindowHasPassed();\\n\\n    /// @notice Activity common error\\n    error NftHasActiveActivities();\\n    error ActivityHasNotCompleted();\\n    error ActivityHasExpired();\\n    error ActivityNotExist();\\n\\n    /// @notice User account error\\n    error InsufficientCredit();\\n    error InsufficientBalanceForVipLevel();\\n    error NoPrivilege();\\n\\n    /// @notice Parameter error\\n    error InvalidParam();\\n    error NftCollectionNotSupported();\\n    error NftCollectionAlreadySupported();\\n    error ClaimableNftInsufficient();\\n    error TokenNotSupported();\\n}\\n\"\r\n    },\r\n    \"src/interface/IFlooring.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"./IMulticall.sol\\\";\\n\\ninterface IFlooring is IERC721Receiver, IMulticall {\\n    /// Admin Operations\\n\\n    /// @notice Add new collection for Flooring Protocol\\n    function supportNewCollection(address _originalNFT, address fragmentToken) external;\\n\\n    /// @notice Add new token which will be used as settlement token in Flooring Protocol\\n    /// @param addOrRemove `true` means add token, `false` means remove token\\n    function supportNewToken(address _tokenAddress, bool addOrRemove) external;\\n\\n    /// @notice set proxy collection config\\n    /// Note. the `tokenId`s of the proxy collection and underlying collection must be correspond one by one\\n    /// eg. Paraspace Derivative Token BAYC(nBAYC) -> BAYC\\n    function setCollectionProxy(address proxyCollection, address underlyingCollection) external;\\n\\n    /// @notice withdraw platform fee accumulated.\\n    /// Note. withdraw from `address(this)`'s account.\\n    function withdrawPlatformFee(address token, uint256 amount) external;\\n\\n    /// @notice Deposit and lock credit token on behalf of receiver\\n    /// user can not withdraw these tokens until `unlockCredit` is called.\\n    function addAndLockCredit(address receiver, uint256 amount) external;\\n\\n    /// @notice Unlock user credit token to allow withdraw\\n    /// used to release investors' funds as time goes\\n    /// Note. locked credit can be used to operate safeboxes(lock/unlock...)\\n    function unlockCredit(address receiver, uint256 amount) external;\\n\\n    /// User Operations\\n\\n    /// @notice User deposits token to the Floor Contract\\n    /// @param onBehalfOf deposit token into `onBehalfOf`'s account.(note. the tokens of msg.sender will be transfered)\\n    function addTokens(address onBehalfOf, address token, uint256 amount) external payable;\\n\\n    /// @notice User removes token from Floor Contract\\n    /// @param receiver who will receive the funds.(note. the token of msg.sender will be transfered)\\n    function removeTokens(address token, uint256 amount, address receiver) external;\\n\\n    /// @notice Lock specified `nftIds` into Flooring Safeboxes and receive corresponding Fragment Tokens of the `collection`\\n    /// @param expiryTs when the safeboxes expired, `0` means infinite lock without expiry\\n    /// @param vipLevel vip tier required in this lock operation\\n    /// @param maxCredit maximum credit can be locked in this operation, if real cost exceeds this limit, the tx will fail\\n    /// @param onBehalfOf who will receive the safebox and fragment tokens.(note. the NFTs of the msg.sender will be transfered)\\n    function lockNFTs(\\n        address collection,\\n        uint256[] memory nftIds,\\n        uint256 expiryTs,\\n        uint256 vipLevel,\\n        uint256 maxCredit,\\n        address onBehalfOf\\n    ) external returns (uint256);\\n\\n    /// @notice Extend the exist safeboxes with longer lock duration with more credit token staked\\n    /// @param expiryTs new expiry timestamp, should bigger than previous expiry\\n    function extendKeys(\\n        address collection,\\n        uint256[] memory nftIds,\\n        uint256 expiryTs,\\n        uint256 vipLevel,\\n        uint256 maxCredit\\n    ) external returns (uint256);\\n\\n    /// @notice Unlock specified `nftIds` which had been locked previously\\n    ///         sender's wallet should have enough Fragment Tokens of the `collection` which will be burned to redeem the NFTs\\n    /// @param expiryTs the latest nft's expiry, we need this to clear locking records\\n    ///                 if the value smaller than the latest nft's expiry, the tx will fail\\n    ///                 if part of `nftIds` were locked infinitely, just skip these expiry\\n    /// @param receiver who will receive the NFTs.\\n    ///                 note. - The safeboxes of the msg.sender will be removed.\\n    ///                       - The Fragment Tokens of the msg.sender will be burned.\\n    function unlockNFTs(address collection, uint256 expiryTs, uint256[] memory nftIds, address receiver) external;\\n\\n    /// @notice Fragment specified `nftIds` into Floor Vault and receive Fragment Tokens without any locking\\n    ///         after fragmented, any one has enough Fragment Tokens can redeem there `nftIds`\\n    /// @param onBehalfOf who will receive the fragment tokens.(note. the NFTs of the msg.sender will be transfered)\\n    function fragmentNFTs(address collection, uint256[] memory nftIds, address onBehalfOf) external;\\n\\n    /// @notice Claim `nftIds` which had been locked and had expired\\n    ///         sender's wallet should have enough Fragment Tokens of the `collection` which will be burned to redeem the NFTs\\n    /// @param maxCredit maximum credit can be costed in this operation, if real cost exceeds this limit, the tx will fail\\n    /// @param receiver who will receive the NFTs.\\n    ///                 note. - the msg.sender will pay the redemption cost.\\n    ///                       - The Fragment Tokens of the msg.sender will be burned.\\n    function claimExpiredNfts(address collection, uint256[] memory nftIds, uint256 maxCredit, address receiver)\\n        external\\n        returns (uint256);\\n\\n    /// @notice Randomly claim `claimCnt` NFTs from Floor Vault\\n    ///         sender's wallet should have enough Fragment Tokens of the `collection` which will be burned to redeem the NFTs\\n    /// @param maxCredit maximum credit can be costed in this operation, if real cost exceeds this limit, the tx will fail\\n    /// @param receiver who will receive the NFTs.\\n    ///                 note. - the msg.sender will pay the redemption cost.\\n    ///                       - The Fragment Tokens of the msg.sender will be burned.\\n    function claimRandomNFT(address collection, uint256 claimCnt, uint256 maxCredit, address receiver)\\n        external\\n        returns (uint256);\\n\\n    /// @notice Start auctions on specified `nftIds` with an initial bid price(`bidAmount`)\\n    ///         This kind of auctions will be settled with Floor Credit Token\\n    /// @param bidAmount initial bid price\\n    function initAuctionOnExpiredSafeBoxes(address collection, uint256[] memory nftIds, uint256 bidAmount) external;\\n\\n    /// @notice Owner starts auctions on his locked Safeboxes\\n    /// @param maxExpiry the latest nft's expiry, we need this to clear locking records\\n    /// @param token which token should be used to settle auctions(bid, settle)\\n    /// @param minimumBid minimum bid price when someone place a bid on the auction\\n    function ownerInitAuctions(\\n        address collection,\\n        uint256[] memory nftIds,\\n        uint256 maxExpiry,\\n        address token,\\n        uint256 minimumBid\\n    ) external;\\n\\n    /// @notice Place a bid on specified `nftId`'s action\\n    /// @param bidAmount bid price\\n    /// @param bidOptionIdx which option used to extend auction expiry and bid price\\n    function placeBidOnAuction(address collection, uint256 nftId, uint256 bidAmount, uint256 bidOptionIdx) external;\\n\\n    /// @notice Place a bid on specified `nftId`'s action\\n    /// @param token which token should be transfered to the Flooring for bidding. `0x0` means ETH(native)\\n    /// @param amountToTransfer how many `token` should to transfered\\n    function placeBidOnAuction(\\n        address collection,\\n        uint256 nftId,\\n        uint256 bidAmount,\\n        uint256 bidOptionIdx,\\n        address token,\\n        uint256 amountToTransfer\\n    ) external payable;\\n\\n    /// @notice Settle auctions of `nftIds`\\n    function settleAuctions(address collection, uint256[] memory nftIds) external;\\n\\n    struct RaffleInitParam {\\n        address collection;\\n        uint256[] nftIds;\\n        /// @notice which token used to buy and settle raffle\\n        address ticketToken;\\n        /// @notice price per ticket\\n        uint96 ticketPrice;\\n        /// @notice max tickets amount can be sold\\n        uint32 maxTickets;\\n        /// @notice durationIdx used to get how long does raffles last\\n        uint256 duration;\\n        /// @notice the largest epxiry of nfts, we need this to clear locking records\\n        uint256 maxExpiry;\\n    }\\n\\n    /// @notice Owner start raffles on locked `nftIds`\\n    function ownerInitRaffles(RaffleInitParam memory param) external;\\n\\n    /// @notice Buy `nftId`'s raffle tickets\\n    /// @param ticketCnt how many tickets should be bought in this operation\\n    function buyRaffleTickets(address collectionId, uint256 nftId, uint256 ticketCnt) external;\\n\\n    /// @notice Buy `nftId`'s raffle tickets\\n    /// @param token which token should be transfered to the Flooring for buying. `0x0` means ETH(native)\\n    /// @param amountToTransfer how many `token` should to transfered\\n    function buyRaffleTickets(\\n        address collectionId,\\n        uint256 nftId,\\n        uint256 ticketCnt,\\n        address token,\\n        uint256 amountToTransfer\\n    ) external payable;\\n\\n    /// @notice Settle raffles of `nftIds`\\n    function settleRaffles(address collectionId, uint256[] memory nftIds) external;\\n\\n    struct PrivateOfferInitParam {\\n        address collection;\\n        uint256[] nftIds;\\n        /// @notice the largest epxiry of nfts, we need this to clear locking records\\n        uint256 maxExpiry;\\n        /// @notice who will receive the otc offers\\n        address receiver;\\n        /// @notice which token used to settle offers\\n        address token;\\n        /// @notice price of the offers\\n        uint96 price;\\n    }\\n\\n    /// @notice Owner start private offers(otc) on locked `nftIds`\\n    function ownerInitPrivateOffers(PrivateOfferInitParam memory param) external;\\n\\n    /// @notice Owner or Receiver cancel the private offers of `nftIds`\\n    function cancelPrivateOffers(address collectionId, uint256[] memory nftIds) external;\\n\\n    /// @notice Receiver accept the private offers of `nftIds`\\n    function buyerAcceptPrivateOffers(address collectionId, uint256[] memory nftIds) external;\\n\\n    /// @notice Receiver accept the private offers of `nftIds`\\n    /// @param token which token should be transfered to the Flooring for buying. `0x0` means ETH(native)\\n    /// @param amountToTransfer how many `token` should to transfered\\n    function buyerAcceptPrivateOffers(\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        address token,\\n        uint256 amountToTransfer\\n    ) external payable;\\n\\n    /// @notice Clear expired or mismatching safeboxes of `nftIds` in user account\\n    /// @param onBehalfOf whose account will be recalculated\\n    /// @return credit amount has been released\\n    function removeExpiredKeyAndRestoreCredit(address collection, uint256[] memory nftIds, address onBehalfOf)\\n        external\\n        returns (uint256);\\n\\n    /// @notice Update user's staking credit status by iterating all active collections in user account\\n    /// @param onBehalfOf whose account will be recalculated\\n    /// @return availableCredit how many credit available to use after this opeartion\\n    function recalculateAvailableCredit(address onBehalfOf) external returns (uint256 availableCredit);\\n\\n    /// Util operations\\n\\n    /// @notice Called by external contracts to access granular pool state\\n    /// @param slot Key of slot to sload\\n    /// @return value The value of the slot as bytes32\\n    function extsload(bytes32 slot) external view returns (bytes32 value);\\n\\n    /// @notice Called by external contracts to access granular pool state\\n    /// @param slot Key of slot to start sloading from\\n    /// @param nSlots Number of slots to load into return value\\n    /// @return value The value of the sload-ed slots concatenated as dynamic bytes\\n    function extsload(bytes32 slot, uint256 nSlots) external view returns (bytes memory value);\\n\\n    function creditToken() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interface/IFragmentToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\ninterface IFragmentToken {\\n    error CallerIsNotTrustedContract();\\n\\n    function mint(address account, uint256 amount) external;\\n\\n    function burn(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interface/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n/// @title Multicall interface\\n/// @notice Enables calling multiple methods in a single call to the contract\\ninterface IMulticall {\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedMulticall();\\n\\n    struct CallData {\\n        address target;\\n        bytes callData;\\n    }\\n\\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n    /// @param data The encoded function data for each of the calls to make to this contract\\n    /// @return results The results from each of the calls passed in via data\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\\n\\n    /// @notice Allow trusted caller to call specified addresses through the Contract\\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\\n    /// @param calls The encoded function data and target for each of the calls to make to this contract\\n    /// @return results The results from each of the calls passed in via calls\\n    function extMulticall(CallData[] calldata calls) external returns (bytes[] memory);\\n}\\n\"\r\n    },\r\n    \"src/library/ERC721Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary ERC721Transfer {\\n    /// @notice Thrown when an ERC721 transfer fails\\n    error ERC721TransferFailed();\\n\\n    function safeTransferFrom(address collection, address from, address to, uint256 tokenId) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x42842e0e00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, from) // Append and mask the \\\"from\\\" argument.\\n            mstore(36, to) // Append and mask the \\\"to\\\" argument.\\n            // Append the \\\"tokenId\\\" argument. Masking not required as it's a full 32 byte type.\\n            mstore(68, tokenId)\\n\\n            success :=\\n                and(\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                    // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                    // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                    // Counterintuitively, this call must be positioned second to the or() call in the\\n                    // surrounding and() call or else returndatasize() will be zero during the computation.\\n                    call(gas(), collection, 0, 0, 100, 0, 32)\\n                )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        if (!success) revert ERC721TransferFailed();\\n    }\\n\\n    function safeBatchTransferFrom(address collection, address from, address to, uint256[] memory tokenIds) internal {\\n        unchecked {\\n            uint256 len = tokenIds.length;\\n            for (uint256 i; i < len; ++i) {\\n                safeTransferFrom(collection, from, to, tokenIds[i]);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/library/RollingBuckets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"../Constants.sol\\\";\\n\\nlibrary RollingBuckets {\\n    error BucketValueExceedsLimit();\\n    error BucketLengthExceedsLimit();\\n\\n    /// @dev `MAX_BUCKET_SIZE` must be a multiple of `WORD_ELEMENT_SIZE`,\\n    /// otherwise some words may be incomplete which may lead to incorrect bit positioning.\\n    uint256 constant MAX_BUCKET_SIZE = Constants.MAX_LOCKING_BUCKET;\\n    /// @dev each `ELEMENT_BIT_SIZE` bits stores an element\\n    uint256 constant ELEMENT_BIT_SIZE = 24;\\n    /// @dev `ELEMENT_BIT_SIZE` bits mask\\n    uint256 constant MASK = 0xFFFFFF;\\n    /// @dev one word(256 bits) can store (256 // ELEMENT_BIT_SIZE) elements\\n    uint256 constant WORD_ELEMENT_SIZE = 10;\\n\\n    function position(uint256 tick) private pure returns (uint256 wordPos, uint256 bitPos) {\\n        unchecked {\\n            wordPos = tick / WORD_ELEMENT_SIZE;\\n            bitPos = tick % WORD_ELEMENT_SIZE;\\n        }\\n    }\\n\\n    function get(mapping(uint256 => uint256) storage buckets, uint256 bucketStamp) internal view returns (uint256) {\\n        unchecked {\\n            (uint256 wordPos, uint256 bitPos) = position(bucketStamp % MAX_BUCKET_SIZE);\\n            return (buckets[wordPos] >> (bitPos * ELEMENT_BIT_SIZE)) & MASK;\\n        }\\n    }\\n\\n    /// [first, last)\\n    function batchGet(mapping(uint256 => uint256) storage buckets, uint256 firstStamp, uint256 lastStamp)\\n        internal\\n        view\\n        returns (uint256[] memory)\\n    {\\n        if (firstStamp > lastStamp) revert BucketLengthExceedsLimit();\\n\\n        uint256 len;\\n        unchecked {\\n            len = lastStamp - firstStamp;\\n        }\\n\\n        if (len > MAX_BUCKET_SIZE) {\\n            revert BucketLengthExceedsLimit();\\n        }\\n\\n        uint256[] memory result = new uint256[](len);\\n        uint256 resultIndex;\\n\\n        unchecked {\\n            (uint256 wordPos, uint256 bitPos) = position(firstStamp % MAX_BUCKET_SIZE);\\n\\n            uint256 wordVal = buckets[wordPos];\\n            uint256 mask = MASK << (bitPos * ELEMENT_BIT_SIZE);\\n\\n            for (uint256 i = firstStamp; i < lastStamp;) {\\n                assembly {\\n                    /// increase idx firstly to skip `array length`\\n                    resultIndex := add(resultIndex, 0x20)\\n                    /// wordVal store order starts from lowest bit\\n                    /// result[i] = ((wordVal & mask) >> (bitPos * ELEMENT_BIT_SIZE))\\n                    mstore(add(result, resultIndex), shr(mul(bitPos, ELEMENT_BIT_SIZE), and(wordVal, mask)))\\n                    mask := shl(ELEMENT_BIT_SIZE, mask)\\n                    bitPos := add(bitPos, 1)\\n                    i := add(i, 1)\\n                }\\n\\n                if (bitPos == WORD_ELEMENT_SIZE) {\\n                    (wordPos, bitPos) = position(i % MAX_BUCKET_SIZE);\\n\\n                    wordVal = buckets[wordPos];\\n                    mask = MASK;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function set(mapping(uint256 => uint256) storage buckets, uint256 bucketStamp, uint256 value) internal {\\n        if (value > MASK) revert BucketValueExceedsLimit();\\n\\n        unchecked {\\n            (uint256 wordPos, uint256 bitPos) = position(bucketStamp % MAX_BUCKET_SIZE);\\n\\n            uint256 wordValue = buckets[wordPos];\\n            uint256 newValue = value << (bitPos * ELEMENT_BIT_SIZE);\\n\\n            uint256 newWord = (wordValue & ~(MASK << (bitPos * ELEMENT_BIT_SIZE))) | newValue;\\n            buckets[wordPos] = newWord;\\n        }\\n    }\\n\\n    function batchSet(mapping(uint256 => uint256) storage buckets, uint256 firstStamp, uint256[] memory values)\\n        internal\\n    {\\n        uint256 valLength = values.length;\\n        if (valLength > MAX_BUCKET_SIZE) revert BucketLengthExceedsLimit();\\n        if (firstStamp > (type(uint256).max - valLength)) {\\n            revert BucketLengthExceedsLimit();\\n        }\\n\\n        unchecked {\\n            (uint256 wordPos, uint256 bitPos) = position(firstStamp % MAX_BUCKET_SIZE);\\n\\n            uint256 wordValue = buckets[wordPos];\\n            uint256 mask = ~(MASK << (bitPos * ELEMENT_BIT_SIZE));\\n\\n            /// reuse val length as End Postion\\n            valLength = (valLength + 1) * 0x20;\\n            /// start from first element offset\\n            for (uint256 i = 0x20; i < valLength; i += 0x20) {\\n                uint256 val;\\n                assembly {\\n                    val := mload(add(values, i))\\n                }\\n                if (val > MASK) revert BucketValueExceedsLimit();\\n\\n                assembly {\\n                    /// newVal = val << (bitPos * BIT_SIZE)\\n                    let newVal := shl(mul(bitPos, ELEMENT_BIT_SIZE), val)\\n                    /// save newVal to wordVal, clear corresponding bits and set them as newVal\\n                    /// wordValue = (wordVal & mask) | newVal\\n                    wordValue := or(and(wordValue, mask), newVal)\\n                    /// goto next number idx in current word\\n                    bitPos := add(bitPos, 1)\\n                    /// mask = ~(MASK << (bitPos, BIT_SIZE))\\n                    mask := not(shl(mul(bitPos, ELEMENT_BIT_SIZE), MASK))\\n                }\\n\\n                if (bitPos == WORD_ELEMENT_SIZE) {\\n                    /// store hole word\\n                    buckets[wordPos] = wordValue;\\n\\n                    /// get next word' position\\n                    (wordPos, bitPos) = position((firstStamp + (i / 0x20)) % MAX_BUCKET_SIZE);\\n                    wordValue = buckets[wordPos];\\n                    /// restore mask to make it start from lowest bits\\n                    mask = ~MASK;\\n                }\\n            }\\n            /// store last word which may incomplete\\n            buckets[wordPos] = wordValue;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/logic/Auction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport {SafeBox, CollectionState, AuctionInfo} from \\\"./Structs.sol\\\";\\nimport \\\"./User.sol\\\";\\nimport \\\"./Collection.sol\\\";\\nimport \\\"./Helper.sol\\\";\\nimport \\\"../Errors.sol\\\";\\nimport \\\"../Constants.sol\\\";\\nimport \\\"../interface/IFlooring.sol\\\";\\nimport {SafeBoxLib} from \\\"./SafeBox.sol\\\";\\nimport \\\"../library/RollingBuckets.sol\\\";\\n\\nlibrary AuctionLib {\\n    using SafeCast for uint256;\\n    using CollectionLib for CollectionState;\\n    using SafeBoxLib for SafeBox;\\n    using RollingBuckets for mapping(uint256 => uint256);\\n    using UserLib for UserFloorAccount;\\n    using UserLib for CollectionAccount;\\n    using Helper for CollectionState;\\n\\n    event AuctionStarted(\\n        address indexed trigger,\\n        address indexed collection,\\n        uint64[] activityIds,\\n        uint256[] tokenIds,\\n        address settleToken,\\n        uint256 minimumBid,\\n        uint256 feeRateBips,\\n        uint256 auctionEndTime,\\n        uint256 safeBoxExpiryTs,\\n        bool selfTriggered,\\n        uint256 adminFee\\n    );\\n\\n    event NewTopBidOnAuction(\\n        address indexed bidder,\\n        address indexed collection,\\n        uint64 activityId,\\n        uint256 tokenId,\\n        uint256 bidAmount,\\n        uint256 auctionEndTime,\\n        uint256 safeBoxExpiryTs\\n    );\\n\\n    event AuctionEnded(\\n        address indexed winner,\\n        address indexed collection,\\n        uint64 activityId,\\n        uint256 tokenId,\\n        uint256 safeBoxKeyId,\\n        uint256 collectedFunds\\n    );\\n\\n    function ownerInitAuctions(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address creditToken,\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        uint256 maxExpiry,\\n        address token,\\n        uint256 minimumBid\\n    ) public {\\n        UserFloorAccount storage userAccount = userAccounts[msg.sender];\\n        uint256 adminFee = Constants.AUCTION_COST * nftIds.length;\\n        /// transfer fee to contract account\\n        userAccount.transferToken(userAccounts[address(this)], creditToken, adminFee, true);\\n\\n        AuctionInfo memory auctionTemplate;\\n        auctionTemplate.endTime = uint96(block.timestamp + Constants.AUCTION_INITIAL_PERIODS);\\n        auctionTemplate.bidTokenAddress = token;\\n        auctionTemplate.minimumBid = minimumBid.toUint96();\\n        auctionTemplate.triggerAddress = msg.sender;\\n        auctionTemplate.isSelfTriggered = true;\\n        auctionTemplate.feeRateBips =\\n            uint32(getAuctionFeeRate(true, creditToken, address(collection.floorToken), token));\\n        auctionTemplate.lastBidAmount = 0;\\n        auctionTemplate.lastBidder = address(0);\\n\\n        (uint64[] memory activityIds, uint192 newExpiryTs) =\\n            _ownerInitAuctions(collection, userAccount.getByKey(collectionId), nftIds, maxExpiry, auctionTemplate);\\n\\n        emit AuctionStarted(\\n            msg.sender,\\n            collectionId,\\n            activityIds,\\n            nftIds,\\n            token,\\n            minimumBid,\\n            auctionTemplate.feeRateBips,\\n            auctionTemplate.endTime,\\n            newExpiryTs,\\n            true,\\n            adminFee\\n        );\\n    }\\n\\n    function _ownerInitAuctions(\\n        CollectionState storage collectionState,\\n        CollectionAccount storage userAccount,\\n        uint256[] memory nftIds,\\n        uint256 maxExpiry,\\n        AuctionInfo memory auctionTemplate\\n    ) private returns (uint64[] memory activityIds, uint32 newExpiryTs) {\\n        newExpiryTs = uint32(auctionTemplate.endTime + Constants.AUCTION_COMPLETE_GRACE_PERIODS);\\n\\n        uint256 firstIdx = Helper.counterStamp(newExpiryTs) - Helper.counterStamp(block.timestamp);\\n\\n        uint256[] memory toUpdateBucket;\\n        /// if maxExpiryTs == 0, it means all nftIds in this batch being locked infinitely that we don't need to update countingBuckets\\n        if (maxExpiry > 0) {\\n            toUpdateBucket = collectionState.countingBuckets.batchGet(\\n                Helper.counterStamp(block.timestamp),\\n                Math.min(Helper.counterStamp(maxExpiry), collectionState.lastUpdatedBucket)\\n            );\\n        }\\n\\n        activityIds = new uint64[](nftIds.length);\\n        for (uint256 i = 0; i < nftIds.length;) {\\n            if (collectionState.hasActiveActivities(nftIds[i])) revert Errors.NftHasActiveActivities();\\n\\n            (SafeBox storage safeBox,) = collectionState.useSafeBoxAndKey(userAccount, nftIds[i]);\\n\\n            if (safeBox.isInfiniteSafeBox()) {\\n                --collectionState.infiniteCnt;\\n            } else {\\n                uint256 oldExpiryTs = safeBox.expiryTs;\\n                if (oldExpiryTs < newExpiryTs) {\\n                    revert Errors.InvalidParam();\\n                }\\n                uint256 lastIdx = Helper.counterStamp(oldExpiryTs) - Helper.counterStamp(block.timestamp);\\n                if (firstIdx > lastIdx || lastIdx > toUpdateBucket.length) revert Errors.InvalidParam();\\n                for (uint256 k = firstIdx; k < lastIdx;) {\\n                    --toUpdateBucket[k];\\n                    unchecked {\\n                        ++k;\\n                    }\\n                }\\n            }\\n\\n            safeBox.expiryTs = newExpiryTs;\\n\\n            activityIds[i] = collectionState.generateNextActivityId();\\n\\n            auctionTemplate.activityId = activityIds[i];\\n            collectionState.activeAuctions[nftIds[i]] = auctionTemplate;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (toUpdateBucket.length > 0) {\\n            collectionState.countingBuckets.batchSet(Helper.counterStamp(block.timestamp), toUpdateBucket);\\n        }\\n    }\\n\\n    function initAuctionOnExpiredSafeBoxes(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address creditToken,\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        uint256 bidAmount\\n    ) public {\\n        if (bidAmount < Constants.AUCTION_ON_EXPIRED_MINIMUM_BID) revert Errors.InvalidParam();\\n\\n        AuctionInfo memory auctionTemplate;\\n        auctionTemplate.endTime = uint96(block.timestamp + Constants.AUCTION_INITIAL_PERIODS);\\n        auctionTemplate.bidTokenAddress = creditToken;\\n        auctionTemplate.minimumBid = bidAmount.toUint96();\\n        auctionTemplate.triggerAddress = msg.sender;\\n        auctionTemplate.isSelfTriggered = false;\\n        auctionTemplate.feeRateBips =\\n            uint32(getAuctionFeeRate(false, creditToken, address(collection.floorToken), creditToken));\\n        auctionTemplate.lastBidAmount = bidAmount.toUint96();\\n        auctionTemplate.lastBidder = msg.sender;\\n\\n        (uint64[] memory activityIds, uint192 newExpiry) =\\n            _initAuctionOnExpiredSafeBoxes(collection, nftIds, auctionTemplate);\\n\\n        uint256 adminFee = Constants.AUCTION_ON_EXPIRED_SAFEBOX_COST * nftIds.length;\\n        userAccounts[msg.sender].transferToken(\\n            userAccounts[address(this)], creditToken, bidAmount * nftIds.length + adminFee, true\\n        );\\n\\n        emit AuctionStarted(\\n            msg.sender,\\n            collectionId,\\n            activityIds,\\n            nftIds,\\n            creditToken,\\n            bidAmount,\\n            auctionTemplate.feeRateBips,\\n            auctionTemplate.endTime,\\n            newExpiry,\\n            false,\\n            adminFee\\n        );\\n    }\\n\\n    function _initAuctionOnExpiredSafeBoxes(\\n        CollectionState storage collectionState,\\n        uint256[] memory nftIds,\\n        AuctionInfo memory auctionTemplate\\n    ) private returns (uint64[] memory activityIds, uint32 newExpiry) {\\n        newExpiry = uint32(auctionTemplate.endTime + Constants.AUCTION_COMPLETE_GRACE_PERIODS);\\n\\n        activityIds = new uint64[](nftIds.length);\\n        for (uint256 idx; idx < nftIds.length;) {\\n            uint256 nftId = nftIds[idx];\\n            if (collectionState.hasActiveActivities(nftId)) revert Errors.NftHasActiveActivities();\\n\\n            SafeBox storage safeBox = collectionState.useSafeBox(nftId);\\n            if (!safeBox.isSafeBoxExpired()) revert Errors.SafeBoxHasNotExpire();\\n            if (Helper.isAuctionPeriodOver(safeBox)) revert Errors.SafeBoxAuctionWindowHasPassed();\\n\\n            activityIds[idx] = collectionState.generateNextActivityId();\\n            auctionTemplate.activityId = activityIds[idx];\\n            collectionState.activeAuctions[nftId] = auctionTemplate;\\n\\n            /// We keep the owner of safebox unchanged, and it will be used to distribute auction funds\\n            safeBox.expiryTs = newExpiry;\\n            safeBox.keyId = SafeBoxLib.SAFEBOX_KEY_NOTATION;\\n\\n            unchecked {\\n                ++idx;\\n            }\\n        }\\n\\n        applyDiffToCounters(\\n            collectionState, Helper.counterStamp(block.timestamp), Helper.counterStamp(newExpiry), int256(nftIds.length)\\n        );\\n    }\\n\\n    struct BidParam {\\n        uint256 nftId;\\n        uint96 bidAmount;\\n        address bidder;\\n        uint256 extendDuration;\\n        uint256 minIncrPct;\\n    }\\n\\n    function placeBidOnAuction(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address creditToken,\\n        address collectionId,\\n        uint256 nftId,\\n        uint256 bidAmount,\\n        uint256 bidOptionIdx\\n    ) public {\\n        uint256 prevBidAmount;\\n        address prevBidder;\\n        {\\n            Constants.AuctionBidOption memory bidOption = Constants.getBidOption(bidOptionIdx);\\n            userAccounts[msg.sender].ensureVipCredit(uint8(bidOption.vipLevel), creditToken);\\n\\n            (prevBidAmount, prevBidder) = _placeBidOnAuction(\\n                collection,\\n                BidParam(\\n                    nftId, bidAmount.toUint96(), msg.sender, bidOption.extendDurationSecs, bidOption.minimumRaisePct\\n                )\\n            );\\n        }\\n\\n        AuctionInfo memory auction = collection.activeAuctions[nftId];\\n\\n        address bidToken = auction.bidTokenAddress;\\n        userAccounts[msg.sender].transferToken(\\n            userAccounts[address(this)], bidToken, bidAmount, bidToken == creditToken\\n        );\\n\\n        if (prevBidAmount > 0) {\\n            /// refund previous bid\\n            /// contract account no need to check credit requirements\\n            userAccounts[address(this)].transferToken(userAccounts[prevBidder], bidToken, prevBidAmount, false);\\n        }\\n\\n        SafeBox memory safebox = collection.safeBoxes[nftId];\\n        emit NewTopBidOnAuction(\\n            msg.sender, collectionId, auction.activityId, nftId, bidAmount, auction.endTime, safebox.expiryTs\\n        );\\n    }\\n\\n    function _placeBidOnAuction(CollectionState storage collectionState, BidParam memory param)\\n        private\\n        returns (uint128 prevBidAmount, address prevBidder)\\n    {\\n        AuctionInfo storage auctionInfo = collectionState.activeAuctions[param.nftId];\\n\\n        SafeBox storage safeBox = collectionState.useSafeBox(param.nftId);\\n        uint256 endTime = auctionInfo.endTime;\\n        {\\n            (prevBidAmount, prevBidder) = (auctionInfo.lastBidAmount, auctionInfo.lastBidder);\\n            // param check\\n            if (endTime == 0) revert Errors.AuctionNotExist();\\n            if (endTime <= block.timestamp) revert Errors.AuctionHasExpire();\\n            if (prevBidAmount >= param.bidAmount || auctionInfo.minimumBid > param.bidAmount) {\\n                revert Errors.AuctionBidIsNotHighEnough();\\n            }\\n            if (prevBidder == param.bidder) revert Errors.AuctionSelfBid();\\n            // owner starts auction, can not bid by himself\\n            if (auctionInfo.isSelfTriggered && param.bidder == safeBox.owner) revert Errors.AuctionSelfBid();\\n\\n            if (prevBidAmount > 0 && !isValidNewBid(param.bidAmount, prevBidAmount, param.minIncrPct)) {\\n                revert Errors.AuctionInvalidBidAmount();\\n            }\\n        }\\n\\n        /// Changing safebox key id which means the corresponding safebox key doesn't hold the safebox now\\n        safeBox.keyId = SafeBoxLib.SAFEBOX_KEY_NOTATION;\\n\\n        uint256 newAuctionEndTime = block.timestamp + param.extendDuration;\\n        if (newAuctionEndTime > endTime) {\\n            uint256 newSafeBoxExpiryTs = newAuctionEndTime + Constants.AUCTION_COMPLETE_GRACE_PERIODS;\\n            applyDiffToCounters(\\n                collectionState, Helper.counterStamp(safeBox.expiryTs), Helper.counterStamp(newSafeBoxExpiryTs), 1\\n            );\\n\\n            safeBox.expiryTs = uint32(newSafeBoxExpiryTs);\\n            auctionInfo.endTime = uint96(newAuctionEndTime);\\n        }\\n\\n        auctionInfo.lastBidAmount = param.bidAmount;\\n        auctionInfo.lastBidder = param.bidder;\\n    }\\n\\n    function settleAuctions(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address collectionId,\\n        uint256[] memory nftIds\\n    ) public {\\n        for (uint256 i; i < nftIds.length;) {\\n            uint256 nftId = nftIds[i];\\n            SafeBox storage safebox = Helper.useSafeBox(collection, nftId);\\n\\n            if (safebox.isSafeBoxExpired()) revert Errors.SafeBoxHasExpire();\\n\\n            AuctionInfo memory auctionInfo = collection.activeAuctions[nftId];\\n            if (auctionInfo.endTime == 0) revert Errors.AuctionNotExist();\\n            if (auctionInfo.endTime > block.timestamp) revert Errors.AuctionHasNotCompleted();\\n            /// noone bid on the aciton, can not be settled\\n            if (auctionInfo.lastBidder == address(0)) revert Errors.AuctionHasNotCompleted();\\n\\n            (uint256 earning,) = Helper.calculateActivityFee(auctionInfo.lastBidAmount, auctionInfo.feeRateBips);\\n            /// contract account no need to check credit requirements\\n            /// transfer earnings to old safebox owner\\n            userAccounts[address(this)].transferToken(\\n                userAccounts[safebox.owner], auctionInfo.bidTokenAddress, earning, false\\n            );\\n\\n            /// transfer safebox\\n            address winner = auctionInfo.lastBidder;\\n            SafeBoxKey memory key = SafeBoxKey({keyId: collection.generateNextKeyId(), lockingCredit: 0, vipLevel: 0});\\n\\n            safebox.keyId = key.keyId;\\n            safebox.owner = winner;\\n\\n            UserFloorAccount storage account = userAccounts[winner];\\n            CollectionAccount storage userCollectionAccount = account.getByKey(collectionId);\\n            userCollectionAccount.addSafeboxKey(nftId, key);\\n\\n            delete collection.activeAuctions[nftId];\\n\\n            emit AuctionEnded(winner, collectionId, auctionInfo.activityId, nftId, key.keyId, auctionInfo.lastBidAmount);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function isValidNewBid(uint256 newBid, uint256 previousBid, uint256 minRaisePct) private pure returns (bool) {\\n        uint256 minIncrement = previousBid * minRaisePct / 100;\\n        if (minIncrement < 1) {\\n            minIncrement = 1;\\n        }\\n\\n        if (newBid < previousBid + minIncrement) {\\n            return false;\\n        }\\n        // think: always thought this should be previousBid....\\n        uint256 newIncrementAmount = newBid / 100;\\n        if (newIncrementAmount < 1) {\\n            newIncrementAmount = 1;\\n        }\\n        return newBid % newIncrementAmount == 0;\\n    }\\n\\n    function applyDiffToCounters(\\n        CollectionState storage collectionState,\\n        uint256 startBucket,\\n        uint256 endBucket,\\n        int256 diff\\n    ) private {\\n        if (startBucket == endBucket) return;\\n        uint256[] memory buckets = Helper.prepareBucketUpdate(collectionState, startBucket, endBucket);\\n        unchecked {\\n            uint256 bucketLen = buckets.length;\\n            if (diff > 0) {\\n                uint256 tmp = uint256(diff);\\n                for (uint256 i; i < bucketLen; ++i) {\\n                    buckets[i] += tmp;\\n                }\\n            } else {\\n                uint256 tmp = uint256(-diff);\\n                for (uint256 i; i < bucketLen; ++i) {\\n                    buckets[i] -= tmp;\\n                }\\n            }\\n        }\\n        collectionState.countingBuckets.batchSet(startBucket, buckets);\\n        if (endBucket > collectionState.lastUpdatedBucket) {\\n            collectionState.lastUpdatedBucket = uint64(endBucket);\\n        }\\n    }\\n\\n    function getAuctionFeeRate(bool isSelfTriggered, address creditToken, address floorToken, address settleToken)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        if (isSelfTriggered) {\\n            /// owner self trigger the aution\\n            return Helper.getTokenFeeRateBips(creditToken, floorToken, settleToken);\\n        } else {\\n            return Constants.FREE_AUCTION_FEE_RATE_BIPS;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/logic/Collection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"../library/RollingBuckets.sol\\\";\\nimport \\\"../library/ERC721Transfer.sol\\\";\\n\\nimport \\\"../Errors.sol\\\";\\nimport \\\"../Constants.sol\\\";\\nimport \\\"./User.sol\\\";\\nimport \\\"./Helper.sol\\\";\\nimport {SafeBox, CollectionState, AuctionInfo, CollectionAccount, UserFloorAccount, LockParam} from \\\"./Structs.sol\\\";\\nimport {SafeBoxLib} from \\\"./SafeBox.sol\\\";\\n\\nimport \\\"../interface/IFlooring.sol\\\";\\n\\nlibrary CollectionLib {\\n    using SafeBoxLib for SafeBox;\\n    using SafeCast for uint256;\\n    using RollingBuckets for mapping(uint256 => uint256);\\n    using UserLib for CollectionAccount;\\n    using UserLib for UserFloorAccount;\\n\\n    event LockNft(\\n        address indexed sender,\\n        address indexed onBehalfOf,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256[] safeBoxKeys,\\n        uint256 safeBoxExpiryTs,\\n        uint256 minMaintCredit,\\n        address proxyCollection\\n    );\\n    event ExtendKey(\\n        address indexed operator,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256[] safeBoxKeys,\\n        uint256 safeBoxExpiryTs,\\n        uint256 minMaintCredit\\n    );\\n    event UnlockNft(\\n        address indexed operator,\\n        address indexed receiver,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        address proxyCollection\\n    );\\n    event RemoveExpiredKey(\\n        address indexed operator,\\n        address indexed onBehalfOf,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256[] safeBoxKeys\\n    );\\n    event ClaimExpiredNft(\\n        address indexed operator,\\n        address indexed receiver,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256 creditCost,\\n        address proxyCollection\\n    );\\n    event FragmentNft(\\n        address indexed operator, address indexed onBehalfOf, address indexed collection, uint256[] tokenIds\\n    );\\n    event ClaimRandomNft(\\n        address indexed operator,\\n        address indexed receiver,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256 creditCost\\n    );\\n\\n    function fragmentNFTs(\\n        CollectionState storage collectionState,\\n        address collection,\\n        uint256[] memory nftIds,\\n        address onBehalfOf\\n    ) public {\\n        uint256 nftLen = nftIds.length;\\n        unchecked {\\n            for (uint256 i; i < nftLen; ++i) {\\n                collectionState.freeTokenIds.push(nftIds[i]);\\n            }\\n        }\\n        collectionState.floorToken.mint(onBehalfOf, Constants.FLOOR_TOKEN_AMOUNT * nftLen);\\n        ERC721Transfer.safeBatchTransferFrom(collection, msg.sender, address(this), nftIds);\\n\\n        emit FragmentNft(msg.sender, onBehalfOf, collection, nftIds);\\n    }\\n\\n    struct LockInfo {\\n        bool isInfinite;\\n        uint256 currentBucket;\\n        uint256 newExpiryBucket;\\n        uint256 totalManaged;\\n        uint256 newRequireLockCredit;\\n        uint64 infiniteCnt;\\n    }\\n\\n    function lockNfts(\\n        CollectionState storage collection,\\n        UserFloorAccount storage account,\\n        LockParam memory param,\\n        address onBehalfOf\\n    ) public returns (uint256 totalCreditCost) {\\n        if (onBehalfOf == address(this)) revert Errors.InvalidParam();\\n\\n        uint8 vipLevel = uint8(param.vipLevel);\\n        uint256 totalCredit = account.ensureVipCredit(vipLevel, param.creditToken);\\n        Helper.ensureMaxLocking(vipLevel, param.expiryTs);\\n        Helper.ensureProxyVipLevel(Constants.getVipLevel(totalCredit), param.collection != param.proxyCollection);\\n\\n        /// cache value to avoid multi-reads\\n        uint256 minMaintCredit = account.minMaintCredit;\\n        uint256[] memory nftIds = param.nftIds;\\n        uint256[] memory newKeys;\\n        {\\n            CollectionAccount storage userCollectionAccount = account.getOrAddCollection(param.collection);\\n\\n            (totalCreditCost, newKeys) = _lockNfts(collection, userCollectionAccount, nftIds, param.expiryTs, vipLevel);\\n\\n            // compute max credit for locking cost\\n            uint96 totalLockingCredit = userCollectionAccount.totalLockingCredit;\\n            {\\n                uint256 creditBuffer;\\n                unchecked {\\n                    creditBuffer = totalCredit - totalLockingCredit;\\n                }\\n                if (totalCreditCost > creditBuffer || totalCreditCost > param.maxCreditCost) {\\n                    revert Errors.InsufficientCredit();\\n                }\\n            }\\n\\n            totalLockingCredit += totalCreditCost.toUint96();\\n            userCollectionAccount.totalLockingCredit = totalLockingCredit;\\n\\n            if (totalLockingCredit > minMaintCredit) {\\n                account.minMaintCredit = totalLockingCredit;\\n                minMaintCredit = totalLockingCredit;\\n            }\\n        }\\n\\n        account.updateVipKeyCount(vipLevel, int256(nftIds.length));\\n        /// mint for `onBehalfOf`, transfer from msg.sender\\n        collection.floorToken.mint(onBehalfOf, Constants.FLOOR_TOKEN_AMOUNT * nftIds.length);\\n        ERC721Transfer.safeBatchTransferFrom(param.proxyCollection, msg.sender, address(this), nftIds);\\n\\n        emit LockNft(\\n            msg.sender,\\n            onBehalfOf,\\n            param.collection,\\n            nftIds,\\n            newKeys,\\n            param.expiryTs,\\n            minMaintCredit,\\n            param.proxyCollection\\n        );\\n    }\\n\\n    function _lockNfts(\\n        CollectionState storage collectionState,\\n        CollectionAccount storage account,\\n        uint256[] memory nftIds,\\n        uint256 expiryTs, // treat 0 as infinite lock.\\n        uint8 vipLevel\\n    ) private returns (uint256, uint256[] memory) {\\n        LockInfo memory info = LockInfo({\\n            isInfinite: expiryTs == 0,\\n            currentBucket: Helper.counterStamp(block.timestamp),\\n            newExpiryBucket: Helper.counterStamp(expiryTs),\\n            totalManaged: collectionState.activeSafeBoxCnt + collectionState.freeTokenIds.length,\\n            newRequireLockCredit: 0,\\n            infiniteCnt: collectionState.infiniteCnt\\n        });\\n        if (info.isInfinite) {\\n            /// if it is infinite lock, we need load all buckets to calculate the staking cost\\n            info.newExpiryBucket = Helper.counterStamp(block.timestamp + Constants.MAX_LOCKING_PERIOD);\\n        }\\n\\n        uint256[] memory buckets = Helper.prepareBucketUpdate(collectionState, info.currentBucket, info.newExpiryBucket);\\n        /// @dev `keys` used to log info, we just compact its fields into one 256 bits number\\n        uint256[] memory keys = new uint256[](nftIds.length);\\n\\n        for (uint256 idx; idx < nftIds.length;) {\\n            uint256 lockedCredit = updateCountersAndGetSafeboxCredit(buckets, info, vipLevel);\\n\\n            if (info.isInfinite) ++info.infiniteCnt;\\n\\n            SafeBoxKey memory key = SafeBoxKey({\\n                keyId: Helper.generateNextKeyId(collectionState),\\n                lockingCredit: lockedCredit.toUint96(),\\n                vipLevel: vipLevel\\n            });\\n\\n            account.addSafeboxKey(nftIds[idx], key);\\n            addSafeBox(\\n                collectionState, nftIds[idx], SafeBox({keyId: key.keyId, expiryTs: uint32(expiryTs), owner: msg.sender})\\n            );\\n\\n            keys[idx] = SafeBoxLib.encodeSafeBoxKey(key);\\n\\n            info.newRequireLockCredit += lockedCredit;\\n            unchecked {\\n                ++info.totalManaged;\\n                ++idx;\\n            }\\n        }\\n\\n        if (info.isInfinite) {\\n            collectionState.infiniteCnt = info.infiniteCnt;\\n        } else {\\n            collectionState.countingBuckets.batchSet(info.currentBucket, buckets);\\n            if (info.newExpiryBucket > collectionState.lastUpdatedBucket) {\\n                collectionState.lastUpdatedBucket = uint64(info.newExpiryBucket);\\n            }\\n        }\\n\\n        return (info.newRequireLockCredit, keys);\\n    }\\n\\n    function unlockNfts(\\n        CollectionState storage collection,\\n        UserFloorAccount storage userAccount,\\n        address proxyCollection,\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        uint256 maxExpiryTs,\\n        address receiver\\n    ) public {\\n        CollectionAccount storage userCollectionAccount = userAccount.getByKey(collectionId);\\n        SafeBoxKey[] memory releasedKeys = _unlockNfts(collection, maxExpiryTs, nftIds, userCollectionAccount);\\n\\n        collection.floorToken.burn(msg.sender, Constants.FLOOR_TOKEN_AMOUNT * nftIds.length);\\n\\n        for (uint256 i = 0; i < releasedKeys.length;) {\\n            userAccount.updateVipKeyCount(releasedKeys[i].vipLevel, -1);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        ERC721Transfer.safeBatchTransferFrom(proxyCollection, address(this), receiver, nftIds);\\n\\n        emit UnlockNft(msg.sender, receiver, collectionId, nftIds, proxyCollection);\\n    }\\n\\n    function _unlockNfts(\\n        CollectionState storage collectionState,\\n        uint256 maxExpiryTs,\\n        uint256[] memory nftIds,\\n        CollectionAccount storage userCollectionAccount\\n    ) private returns (SafeBoxKey[] memory) {\\n        if (maxExpiryTs > 0 && maxExpiryTs < block.timestamp) revert Errors.SafeBoxHasExpire();\\n        SafeBoxKey[] memory expiredKeys = new SafeBoxKey[](nftIds.length);\\n        uint256 currentBucketTime = Helper.counterStamp(block.timestamp);\\n        uint256 creditToRelease = 0;\\n        uint256[] memory buckets;\\n\\n        /// if maxExpiryTs == 0, it means all nftIds in this batch being locked infinitely that we don't need to update countingBuckets\\n        if (maxExpiryTs > 0) {\\n            uint256 maxExpiryBucketTime = Math.min(Helper.counterStamp(maxExpiryTs), collectionState.lastUpdatedBucket);\\n            buckets = collectionState.countingBuckets.batchGet(currentBucketTime, maxExpiryBucketTime);\\n        }\\n\\n        for (uint256 i; i < nftIds.length;) {\\n            uint256 nftId = nftIds[i];\\n\\n            if (Helper.hasActiveActivities(collectionState, nftId)) revert Errors.NftHasActiveActivities();\\n\\n            (SafeBox storage safeBox, SafeBoxKey storage safeBoxKey) =\\n                Helper.useSafeBoxAndKey(collectionState, userCollectionAccount, nftId);\\n\\n            creditToRelease += safeBoxKey.lockingCredit;\\n            if (safeBox.isInfiniteSafeBox()) {\\n                --collectionState.infiniteCnt;\\n            } else {\\n                uint256 limit = Helper.counterStamp(safeBox.expiryTs) - currentBucketTime;\\n                if (limit > buckets.length) revert();\\n                for (uint256 idx; idx < limit;) {\\n                    --buckets[idx];\\n                    unchecked {\\n                        ++idx;\\n                    }\\n                }\\n            }\\n\\n            expiredKeys[i] = safeBoxKey;\\n\\n            removeSafeBox(collectionState, nftId);\\n            userCollectionAccount.removeSafeboxKey(nftId);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        userCollectionAccount.totalLockingCredit -= creditToRelease.toUint96();\\n        if (buckets.length > 0) {\\n            collectionState.countingBuckets.batchSet(currentBucketTime, buckets);\\n        }\\n\\n        return expiredKeys;\\n    }\\n\\n    function claimExpiredNfts(\\n        CollectionState storage collectionState,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address creditToken,\\n        address proxyCollection,\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        uint256 maxCreditCost,\\n        address receiver\\n    ) public returns (uint256 totalCreditCost) {\\n        for (uint256 i = 0; i < nftIds.length;) {\\n            SafeBox storage safeBox = Helper.useSafeBox(collectionState, nftIds[i]);\\n            if (!safeBox.isSafeBoxExpired()) revert Errors.SafeBoxHasNotExpire();\\n            if (!Helper.isAuctionPeriodOver(safeBox)) revert Errors.AuctionHasNotCompleted();\\n\\n            removeSafeBox(collectionState, nftIds[i]);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        uint256 currentlyLocked = getActiveSafeBoxes(collectionState, block.timestamp) + collectionState.infiniteCnt;\\n        UserFloorAccount storage userAccount = userAccounts[msg.sender];\\n\\n        totalCreditCost = nftIds.length\\n            * Constants.getClaimExpiredCost(\\n                currentlyLocked,\\n                collectionState.activeSafeBoxCnt + collectionState.freeTokenIds.length,\\n                Constants.getVipLevel(userAccount.tokenBalance(creditToken))\\n            );\\n        if (totalCreditCost > maxCreditCost) {\\n            revert Errors.InsufficientCredit();\\n        }\\n\\n        userAccount.transferToken(userAccounts[address(this)], creditToken, totalCreditCost, true);\\n        collectionState.floorToken.burn(msg.sender, Constants.FLOOR_TOKEN_AMOUNT * nftIds.length);\\n        ERC721Transfer.safeBatchTransferFrom(proxyCollection, address(this), receiver, nftIds);\\n\\n        emit ClaimExpiredNft(msg.sender, receiver, collectionId, nftIds, totalCreditCost, proxyCollection);\\n    }\\n\\n    function extendLockingForKeys(\\n        CollectionState storage collection,\\n        UserFloorAccount storage userAccount,\\n        LockParam memory param\\n    ) public returns (uint256 totalCreditCost) {\\n        uint8 newVipLevel = uint8(param.vipLevel);\\n        uint256 totalCredit = userAccount.ensureVipCredit(newVipLevel, param.creditToken);\\n        Helper.ensureMaxLocking(newVipLevel, param.expiryTs);\\n\\n        uint256 minMaintCredit = userAccount.minMaintCredit;\\n        uint256[] memory safeBoxKeys;\\n        {\\n            CollectionAccount storage collectionAccount = userAccount.getOrAddCollection(param.collection);\\n\\n            // extend lock duration\\n            int256[] memory vipLevelDiffs;\\n            (vipLevelDiffs, totalCreditCost, safeBoxKeys) =\\n                _extendLockingForKeys(collection, collectionAccount, param.nftIds, param.expiryTs, uint8(newVipLevel));\\n\\n            // compute max credit for locking cost\\n            uint96 totalLockingCredit = collectionAccount.totalLockingCredit;\\n            {\\n                uint256 creditBuffer;\\n                unchecked {\\n                    creditBuffer = totalCredit - totalLockingCredit;\\n                }\\n                if (totalCreditCost > creditBuffer || totalCreditCost > param.maxCreditCost) {\\n                    revert Errors.InsufficientCredit();\\n                }\\n            }\\n\\n            // update user vip key counts\\n            for (uint256 vipLevel = 0; vipLevel < vipLevelDiffs.length;) {\\n                userAccount.updateVipKeyCount(uint8(vipLevel), vipLevelDiffs[vipLevel]);\\n                unchecked {\\n                    ++vipLevel;\\n                }\\n            }\\n\\n            totalLockingCredit += totalCreditCost.toUint96();\\n            collectionAccount.totalLockingCredit = totalLockingCredit;\\n            if (totalLockingCredit > minMaintCredit) {\\n                userAccount.minMaintCredit = totalLockingCredit;\\n                minMaintCredit = totalLockingCredit;\\n            }\\n        }\\n\\n        emit ExtendKey(msg.sender, param.collection, param.nftIds, safeBoxKeys, param.expiryTs, minMaintCredit);\\n    }\\n\\n    function _extendLockingForKeys(\\n        CollectionState storage collectionState,\\n        CollectionAccount storage userCollectionAccount,\\n        uint256[] memory nftIds,\\n        uint256 newExpiryTs, // expiryTs of 0 is infinite.\\n        uint8 newVipLevel\\n    ) private returns (int256[] memory, uint256, uint256[] memory) {\\n        LockInfo memory info = LockInfo({\\n            isInfinite: newExpiryTs == 0,\\n            currentBucket: Helper.counterStamp(block.timestamp),\\n            newExpiryBucket: Helper.counterStamp(newExpiryTs),\\n            totalManaged: collectionState.activeSafeBoxCnt + collectionState.freeTokenIds.length,\\n            newRequireLockCredit: 0,\\n            infiniteCnt: collectionState.infiniteCnt\\n        });\\n        if (info.isInfinite) {\\n            info.newExpiryBucket = Helper.counterStamp(block.timestamp + Constants.MAX_LOCKING_PERIOD);\\n        }\\n\\n        uint256[] memory buckets = Helper.prepareBucketUpdate(collectionState, info.currentBucket, info.newExpiryBucket);\\n        int256[] memory vipLevelDiffs = new int256[](Constants.VIP_LEVEL_COUNT);\\n        /// @dev `keys` used to log info, we just compact its fields into one 256 bits number\\n        uint256[] memory keys = new uint256[](nftIds.length);\\n\\n        for (uint256 idx; idx < nftIds.length;) {\\n            if (Helper.hasActiveActivities(collectionState, nftIds[idx])) revert Errors.NftHasActiveActivities();\\n\\n            (SafeBox storage safeBox, SafeBoxKey storage safeBoxKey) =\\n                Helper.useSafeBoxAndKey(collectionState, userCollectionAccount, nftIds[idx]);\\n\\n            {\\n                uint256 extendOffset = Helper.counterStamp(safeBox.expiryTs) - info.currentBucket;\\n                unchecked {\\n                    for (uint256 i; i < extendOffset; ++i) {\\n                        if (buckets[i] == 0) revert Errors.InvalidParam();\\n                        --buckets[i];\\n                    }\\n                }\\n            }\\n\\n            uint256 safeboxQuote = updateCountersAndGetSafeboxCredit(buckets, info, newVipLevel);\\n\\n            if (safeboxQuote > safeBoxKey.lockingCredit) {\\n                info.newRequireLockCredit += (safeboxQuote - safeBoxKey.lockingCredit);\\n                safeBoxKey.lockingCredit = safeboxQuote.toUint96();\\n            }\\n\\n            uint8 oldVipLevel = safeBoxKey.vipLevel;\\n            if (newVipLevel > oldVipLevel) {\\n                safeBoxKey.vipLevel = newVipLevel;\\n                --vipLevelDiffs[oldVipLevel];\\n                ++vipLevelDiffs[newVipLevel];\\n            }\\n\\n            if (info.isInfinite) {\\n                safeBox.expiryTs = 0;\\n                ++info.infiniteCnt;\\n            } else {\\n                safeBox.expiryTs = uint32(newExpiryTs);\\n            }\\n\\n            keys[idx] = SafeBoxLib.encodeSafeBoxKey(safeBoxKey);\\n\\n            unchecked {\\n                ++idx;\\n            }\\n        }\\n\\n        if (info.isInfinite) {\\n            collectionState.infiniteCnt = info.infiniteCnt;\\n        } else {\\n            collectionState.countingBuckets.batchSet(info.currentBucket, buckets);\\n            if (info.newExpiryBucket > collectionState.lastUpdatedBucket) {\\n                collectionState.lastUpdatedBucket = uint64(info.newExpiryBucket);\\n            }\\n        }\\n        return (vipLevelDiffs, info.newRequireLockCredit, keys);\\n    }\\n\\n    function updateCountersAndGetSafeboxCredit(uint256[] memory counters, LockInfo memory lockInfo, uint8 vipLevel)\\n        private\\n        pure\\n        returns (uint256 result)\\n    {\\n        unchecked {\\n            uint256 infiniteCnt = lockInfo.infiniteCnt;\\n            uint256 totalManaged = lockInfo.totalManaged;\\n\\n            uint256 counterOffsetEnd = (counters.length + 1) * 0x20;\\n            uint256 tmpCount;\\n            if (lockInfo.isInfinite) {\\n                for (uint256 i = 0x20; i < counterOffsetEnd; i += 0x20) {\\n                    assembly {\\n                        tmpCount := mload(add(counters, i))\\n                    }\\n                    result += Constants.getRequiredStakingForLockRatio(infiniteCnt + tmpCount, totalManaged);\\n                }\\n                /// infinite lock need more staking\\n                result +=\\n                    Constants.getRequiredStakingForLockRatio(infiniteCnt, totalManaged) * Constants.MAX_LOCKING_BUCKET;\\n            } else {\\n                for (uint256 i = 0x20; i < counterOffsetEnd; i += 0x20) {\\n                    assembly {\\n                        tmpCount := mload(add(counters, i))\\n                    }\\n                    result += Constants.getRequiredStakingForLockRatio(infiniteCnt + tmpCount, totalManaged);\\n                    assembly {\\n                        /// increase counters[i]\\n                        mstore(add(counters, i), add(tmpCount, 1))\\n                    }\\n                }\\n            }\\n            result = Constants.getVipRequiredStakingWithDiscount(result, vipLevel);\\n        }\\n    }\\n\\n    function removeExpiredKeysAndRestoreCredits(\\n        CollectionState storage collectionState,\\n        UserFloorAccount storage userAccount,\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        address onBehalfOf\\n    ) public returns (uint256 releasedCredit) {\\n        CollectionAccount storage collectionAccount = userAccount.getByKey(collectionId);\\n\\n        uint256 removedCnt;\\n        uint256[] memory removedIds = new uint256[](nftIds.length);\\n        uint256[] memory removedKeys = new uint256[](nftIds.length);\\n        for (uint256 i = 0; i < nftIds.length;) {\\n            uint256 nftId = nftIds[i];\\n            SafeBoxKey memory safeBoxKey = collectionAccount.getByKey(nftId);\\n            SafeBox memory safeBox = collectionState.safeBoxes[nftId];\\n\\n            if (safeBoxKey.keyId == 0) {\\n                revert Errors.InvalidParam();\\n            }\\n\\n            if (safeBox._isSafeBoxExpired() || !safeBox._isKeyMatchingSafeBox(safeBoxKey)) {\\n                removedIds[removedCnt] = nftId;\\n                removedKeys[removedCnt] = SafeBoxLib.encodeSafeBoxKey(safeBoxKey);\\n\\n                unchecked {\\n                    ++removedCnt;\\n                    releasedCredit += safeBoxKey.lockingCredit;\\n                }\\n\\n                userAccount.updateVipKeyCount(safeBoxKey.vipLevel, -1);\\n                collectionAccount.removeSafeboxKey(nftId);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (releasedCredit > 0) {\\n            collectionAccount.totalLockingCredit -= releasedCredit.toUint96();\\n        }\\n\\n        emit RemoveExpiredKey(msg.sender, onBehalfOf, collectionId, removedIds, removedKeys);\\n    }\\n\\n    function claimRandomNFT(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address creditToken,\\n        address collectionId,\\n        uint256 claimCnt,\\n        uint256 maxCreditCost,\\n        address receiver\\n    ) public returns (uint256 totalCreditCost) {\\n        if (claimCnt == 0 || collection.freeTokenIds.length < claimCnt) revert Errors.ClaimableNftInsufficient();\\n\\n        uint256 currentlyLocked = getActiveSafeBoxes(collection, block.timestamp) + collection.infiniteCnt;\\n        uint256 totalManaged = collection.activeSafeBoxCnt + collection.freeTokenIds.length;\\n\\n        uint256[] memory selectedTokenIds = new uint256[](claimCnt);\\n\\n        UserFloorAccount storage userAccount = userAccounts[msg.sender];\\n        uint8 vipLevel = Constants.getVipLevel(userAccount.tokenBalance(creditToken));\\n        while (claimCnt > 0) {\\n            totalCreditCost += Constants.getClaimRandomCost(currentlyLocked, totalManaged, vipLevel);\\n\\n            /// just compute a deterministic random number\\n            uint256 chosenNftIdx = uint256(keccak256(abi.encodePacked(block.timestamp, block.prevrandao, totalManaged)))\\n                % collection.freeTokenIds.length;\\n\\n            unchecked {\\n                --claimCnt;\\n                --totalManaged;\\n            }\\n\\n            selectedTokenIds[claimCnt] = collection.freeTokenIds[chosenNftIdx];\\n\\n            collection.freeTokenIds[chosenNftIdx] = collection.freeTokenIds[collection.freeTokenIds.length - 1];\\n            collection.freeTokenIds.pop();\\n        }\\n\\n        if (totalCreditCost > maxCreditCost) {\\n            revert Errors.InsufficientCredit();\\n        }\\n\\n        userAccount.transferToken(userAccounts[address(this)], creditToken, totalCreditCost, true);\\n        collection.floorToken.burn(msg.sender, Constants.FLOOR_TOKEN_AMOUNT * selectedTokenIds.length);\\n        ERC721Transfer.safeBatchTransferFrom(collectionId, address(this), receiver, selectedTokenIds);\\n\\n        emit ClaimRandomNft(msg.sender, receiver, collectionId, selectedTokenIds, totalCreditCost);\\n    }\\n\\n    function getActiveSafeBoxes(CollectionState storage collectionState, uint256 timestamp)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 bucketStamp = Helper.counterStamp(timestamp);\\n        if (collectionState.lastUpdatedBucket < bucketStamp) {\\n            return 0;\\n        }\\n        return collectionState.countingBuckets.get(bucketStamp);\\n    }\\n\\n    function addSafeBox(CollectionState storage collectionState, uint256 nftId, SafeBox memory safebox) internal {\\n        if (collectionState.safeBoxes[nftId].keyId > 0) revert Errors.SafeBoxAlreadyExist();\\n        collectionState.safeBoxes[nftId] = safebox;\\n        ++collectionState.activeSafeBoxCnt;\\n    }\\n\\n    function removeSafeBox(CollectionState storage collectionState, uint256 nftId) internal {\\n        delete collectionState.safeBoxes[nftId];\\n        --collectionState.activeSafeBoxCnt;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/logic/Helper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"../Constants.sol\\\";\\nimport \\\"../Errors.sol\\\";\\nimport \\\"./SafeBox.sol\\\";\\nimport \\\"./User.sol\\\";\\nimport {SafeBox, CollectionState, AuctionInfo, CollectionAccount, SafeBoxKey} from \\\"./Structs.sol\\\";\\nimport \\\"../library/RollingBuckets.sol\\\";\\n\\nlibrary Helper {\\n    using SafeBoxLib for SafeBox;\\n    using UserLib for CollectionAccount;\\n    using RollingBuckets for mapping(uint256 => uint256);\\n\\n    function counterStamp(uint256 timestamp) internal pure returns (uint96) {\\n        unchecked {\\n            return uint96((timestamp + Constants.BUCKET_SPAN_1) / Constants.BUCKET_SPAN);\\n        }\\n    }\\n\\n    function ensureProxyVipLevel(uint8 vipLevel, bool proxy) internal pure {\\n        if (proxy && vipLevel < Constants.PROXY_COLLECTION_VIP_THRESHOLD) {\\n            revert Errors.InvalidParam();\\n        }\\n    }\\n\\n    function ensureMaxLocking(uint8 vipLevel, uint256 requireExpiryTs) internal view {\\n        /// vip level 0 can not use safebox utilities.\\n        if (vipLevel >= Constants.VIP_LEVEL_COUNT || vipLevel == 0) {\\n            revert Errors.InvalidParam();\\n        }\\n\\n        /// only check when it is not infinite lock\\n        if (requireExpiryTs > 0) {\\n            uint256 deltaBucket;\\n            unchecked {\\n                deltaBucket = counterStamp(requireExpiryTs) - counterStamp(block.timestamp);\\n            }\\n            if (deltaBucket == 0 || deltaBucket > Constants.getVipLockingBuckets(vipLevel)) {\\n                revert Errors.InvalidParam();\\n            }\\n        } else if (vipLevel < Constants.VIP_LEVEL_COUNT - 1) {\\n            revert Errors.InvalidParam();\\n        }\\n    }\\n\\n    function useSafeBoxAndKey(CollectionState storage collection, CollectionAccount storage userAccount, uint256 nftId)\\n        internal\\n        view\\n        returns (SafeBox storage safeBox, SafeBoxKey storage key)\\n    {\\n        safeBox = collection.safeBoxes[nftId];\\n        if (safeBox.keyId == 0) revert Errors.SafeBoxNotExist();\\n        if (safeBox.isSafeBoxExpired()) revert Errors.SafeBoxHasExpire();\\n\\n        key = userAccount.getByKey(nftId);\\n        if (!safeBox.isKeyMatchingSafeBox(key)) revert Errors.NoMatchingSafeBoxKey();\\n    }\\n\\n    function useSafeBox(CollectionState storage collection, uint256 nftId)\\n        internal\\n        view\\n        returns (SafeBox storage safeBox)\\n    {\\n        safeBox = collection.safeBoxes[nftId];\\n        if (safeBox.keyId == 0) revert Errors.SafeBoxNotExist();\\n    }\\n\\n    function generateNextKeyId(CollectionState storage collectionState) internal returns (uint64 nextKeyId) {\\n        nextKeyId = collectionState.nextKeyId;\\n        ++collectionState.nextKeyId;\\n    }\\n\\n    function generateNextActivityId(CollectionState storage collection) internal returns (uint64 nextActivityId) {\\n        nextActivityId = collection.nextActivityId;\\n        ++collection.nextActivityId;\\n    }\\n\\n    function isAuctionPeriodOver(SafeBox storage safeBox) internal view returns (bool) {\\n        return safeBox.expiryTs + Constants.FREE_AUCTION_PERIOD < block.timestamp;\\n    }\\n\\n    function hasActiveActivities(CollectionState storage collection, uint256 nftId) internal view returns (bool) {\\n        return hasActiveAuction(collection, nftId) || hasActiveRaffle(collection, nftId)\\n            || hasActivePrivateOffer(collection, nftId);\\n    }\\n\\n    function hasActiveAuction(CollectionState storage collection, uint256 nftId) internal view returns (bool) {\\n        return collection.activeAuctions[nftId].endTime >= block.timestamp;\\n    }\\n\\n    function hasActiveRaffle(CollectionState storage collection, uint256 nftId) internal view returns (bool) {\\n        return collection.activeRaffles[nftId].endTime >= block.timestamp;\\n    }\\n\\n    function hasActivePrivateOffer(CollectionState storage collection, uint256 nftId) internal view returns (bool) {\\n        return collection.activePrivateOffers[nftId].endTime >= block.timestamp;\\n    }\\n\\n    function getTokenFeeRateBips(address creditToken, address floorToken, address settleToken)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 feeRateBips = Constants.COMMON_FEE_RATE_BIPS;\\n        if (settleToken == creditToken) {\\n            feeRateBips = Constants.CREDIT_FEE_RATE_BIPS;\\n        } else if (settleToken == floorToken) {\\n            feeRateBips = Constants.SPEC_FEE_RATE_BIPS;\\n        }\\n\\n        return feeRateBips;\\n    }\\n\\n    function calculateActivityFee(uint256 settleAmount, uint256 feeRateBips)\\n        internal\\n        pure\\n        returns (uint256 afterFee, uint256 fee)\\n    {\\n        fee = settleAmount * feeRateBips / 10000;\\n        unchecked {\\n            afterFee = settleAmount - fee;\\n        }\\n    }\\n\\n    function prepareBucketUpdate(CollectionState storage collection, uint256 startBucket, uint256 endBucket)\\n        internal\\n        view\\n        returns (uint256[] memory buckets)\\n    {\\n        uint256 validEnd = collection.lastUpdatedBucket;\\n        uint256 padding;\\n        if (endBucket < validEnd) {\\n            validEnd = endBucket;\\n        } else {\\n            unchecked {\\n                padding = endBucket - validEnd;\\n            }\\n        }\\n\\n        if (startBucket < validEnd) {\\n            if (padding == 0) {\\n                buckets = collection.countingBuckets.batchGet(startBucket, validEnd);\\n            } else {\\n                uint256 validLen;\\n                unchecked {\\n                    validLen = validEnd - startBucket;\\n                }\\n                buckets = new uint256[](validLen + padding);\\n                uint256[] memory tmp = collection.countingBuckets.batchGet(startBucket, validEnd);\\n                for (uint256 i; i < validLen;) {\\n                    buckets[i] = tmp[i];\\n                    unchecked {\\n                        ++i;\\n                    }\\n                }\\n            }\\n        } else {\\n            buckets = new uint256[](endBucket - startBucket);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/logic/SafeBox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport {SafeBox, SafeBoxKey} from \\\"./Structs.sol\\\";\\n\\nlibrary SafeBoxLib {\\n    uint64 public constant SAFEBOX_KEY_NOTATION = type(uint64).max;\\n\\n    function isInfiniteSafeBox(SafeBox storage safeBox) internal view returns (bool) {\\n        return safeBox.expiryTs == 0;\\n    }\\n\\n    function isSafeBoxExpired(SafeBox storage safeBox) internal view returns (bool) {\\n        return safeBox.expiryTs != 0 && safeBox.expiryTs < block.timestamp;\\n    }\\n\\n    function _isSafeBoxExpired(SafeBox memory safeBox) internal view returns (bool) {\\n        return safeBox.expiryTs != 0 && safeBox.expiryTs < block.timestamp;\\n    }\\n\\n    function isKeyMatchingSafeBox(SafeBox storage safeBox, SafeBoxKey storage safeBoxKey)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return safeBox.keyId == safeBoxKey.keyId;\\n    }\\n\\n    function _isKeyMatchingSafeBox(SafeBox memory safeBox, SafeBoxKey memory safeBoxKey) internal pure returns (bool) {\\n        return safeBox.keyId == safeBoxKey.keyId;\\n    }\\n\\n    function encodeSafeBoxKey(SafeBoxKey memory key) internal pure returns (uint256) {\\n        uint256 val = key.lockingCredit;\\n        val |= (uint256(key.keyId) << 96);\\n        val |= (uint256(key.vipLevel) << 160);\\n        return val;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/logic/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"../interface/IFragmentToken.sol\\\";\\n\\nstruct SafeBox {\\n    /// Either matching a key OR Constants.SAFEBOX_KEY_NOTATION meaning temporarily\\n    /// held by a bidder in auction.\\n    uint64 keyId;\\n    /// The timestamp that the safe box expires.\\n    uint32 expiryTs;\\n    /// The owner of the safebox. It maybe outdated due to expiry\\n    address owner;\\n}\\n\\nstruct PrivateOffer {\\n    /// private offer end time\\n    uint96 endTime;\\n    /// which token used to accpet the offer\\n    address token;\\n    /// price of the offer\\n    uint96 price;\\n    address owner;\\n    /// who should receive the offer\\n    address buyer;\\n    uint64 activityId;\\n}\\n\\nstruct AuctionInfo {\\n    /// The end time for the auction.\\n    uint96 endTime;\\n    /// Bid token address.\\n    address bidTokenAddress;\\n    /// Minimum Bid.\\n    uint96 minimumBid;\\n    /// The person who trigger the auction at the beginning.\\n    address triggerAddress;\\n    uint96 lastBidAmount;\\n    address lastBidder;\\n    /// Whether the auction is triggered by the NFT owner itself\uff1f\\n    bool isSelfTriggered;\\n    uint64 activityId;\\n    uint32 feeRateBips;\\n}\\n\\nstruct TicketRecord {\\n    /// who buy the tickets\\n    address buyer;\\n    /// Start index of tickets\\n    /// [startIdx, endIdx)\\n    uint48 startIdx;\\n    /// End index of tickets\\n    uint48 endIdx;\\n}\\n\\nstruct RaffleInfo {\\n    /// raffle end time\\n    uint48 endTime;\\n    /// max tickets amount the raffle can sell\\n    uint48 maxTickets;\\n    /// which token used to buy the raffle tickets\\n    address token;\\n    /// price per ticket\\n    uint96 ticketPrice;\\n    /// total funds collected by selling tickets\\n    uint96 collectedFund;\\n    uint64 activityId;\\n    address owner;\\n    /// total sold tickets amount\\n    uint48 ticketSold;\\n    uint32 feeRateBips;\\n    /// whether the raffle is being settling\\n    bool isSettling;\\n    /// tickets sold records\\n    TicketRecord[] tickets;\\n}\\n\\nstruct CollectionState {\\n    /// The address of the Floor Token cooresponding to the NFTs.\\n    IFragmentToken floorToken;\\n    /// Records the active safe box in each time bucket.\\n    mapping(uint256 => uint256) countingBuckets;\\n    /// Stores all of the NFTs that has been fragmented but *without* locked up limit.\\n    uint256[] freeTokenIds;\\n    /// Huge map for all the `SafeBox`es in one collection.\\n    mapping(uint256 => SafeBox) safeBoxes;\\n    /// Stores all the ongoing auctions: nftId => `AuctionInfo`.\\n    mapping(uint256 => AuctionInfo) activeAuctions;\\n    /// Stores all the ongoing raffles: nftId => `RaffleInfo`.\\n    mapping(uint256 => RaffleInfo) activeRaffles;\\n    /// Stores all the ongoing private offers: nftId => `PrivateOffer`.\\n    mapping(uint256 => PrivateOffer) activePrivateOffers;\\n    /// The last bucket time the `countingBuckets` is updated.\\n    uint64 lastUpdatedBucket;\\n    /// Next Key Id. This should start from 1, we treat key id `SafeboxLib.SAFEBOX_KEY_NOTATION` as temporarily\\n    /// being used for activities(auction/raffle).\\n    uint64 nextKeyId;\\n    /// Active Safe Box Count.\\n    uint64 activeSafeBoxCnt;\\n    /// The number of infinite lock count.\\n    uint64 infiniteCnt;\\n    /// Next Activity Id. This should start from 1\\n    uint64 nextActivityId;\\n}\\n\\nstruct UserFloorAccount {\\n    /// @notice it should be maximum of the `totalLockingCredit` across all collections\\n    uint96 minMaintCredit;\\n    /// @notice used to iterate collection accounts\\n    /// packed with `minMaintCredit` to reduce storage slot access\\n    address firstCollection;\\n    /// @notice user vip level related info\\n    /// 0 - 239 bits: store SafeBoxKey Count per vip level, per level using 24 bits\\n    /// 240 - 247 bits: store minMaintVipLevel\\n    /// 248 - 255 bits: remaining\\n    uint256 vipInfo;\\n    /// @notice Locked Credit amount which cannot be withdrawn and will be released as time goes.\\n    uint256 lockedCredit;\\n    mapping(address => CollectionAccount) accounts;\\n    mapping(address => uint256) tokenAmounts;\\n}\\n\\nstruct SafeBoxKey {\\n    /// locked credit amount of this safebox\\n    uint96 lockingCredit;\\n    /// corresponding key id of the safebox\\n    uint64 keyId;\\n    /// which vip level the safebox locked\\n    uint8 vipLevel;\\n}\\n\\nstruct CollectionAccount {\\n    mapping(uint256 => SafeBoxKey) keys;\\n    /// total locking credit of all `keys` in this collection\\n    uint96 totalLockingCredit;\\n    /// track next collection as linked list\\n    address next;\\n}\\n\\n/// Internal Structure\\nstruct LockParam {\\n    address proxyCollection;\\n    address collection;\\n    uint256[] nftIds;\\n    uint256 expiryTs;\\n    uint256 vipLevel;\\n    uint256 maxCreditCost;\\n    address creditToken;\\n}\\n\"\r\n    },\r\n    \"src/logic/User.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"../Constants.sol\\\";\\nimport \\\"../Errors.sol\\\";\\nimport {UserFloorAccount, CollectionAccount, SafeBoxKey} from \\\"./Structs.sol\\\";\\n\\nlibrary UserLib {\\n    using SafeCast for uint256;\\n\\n    /// @notice update the account maintain credit on behalfOf `onBehalfOf`\\n    event UpdateMaintainCredit(address indexed onBehalfOf, uint256 minMaintCredit);\\n\\n    address internal constant LIST_GUARD = address(1);\\n\\n    function ensureVipCredit(UserFloorAccount storage account, uint8 requireVipLevel, address creditToken)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 totalCredit = tokenBalance(account, creditToken);\\n        if (Constants.getVipBalanceRequirements(requireVipLevel) > totalCredit) {\\n            revert Errors.InsufficientBalanceForVipLevel();\\n        }\\n        return totalCredit;\\n    }\\n\\n    function getMinMaintVipLevel(UserFloorAccount storage account) internal view returns (uint8) {\\n        unchecked {\\n            return uint8(account.vipInfo >> 240);\\n        }\\n    }\\n\\n    function getMinLevelAndVipKeyCounts(uint256 vipInfo)\\n        internal\\n        pure\\n        returns (uint8 minLevel, uint256[] memory counts)\\n    {\\n        unchecked {\\n            counts = new uint256[](Constants.VIP_LEVEL_COUNT);\\n            minLevel = uint8(vipInfo >> 240);\\n            for (uint256 i; i < Constants.VIP_LEVEL_COUNT; ++i) {\\n                counts[i] = (vipInfo >> (i * 24)) & 0xFFFFFF;\\n            }\\n        }\\n    }\\n\\n    function storeMinLevelAndVipKeyCounts(\\n        UserFloorAccount storage account,\\n        uint8 minMaintVipLevel,\\n        uint256[] memory keyCounts\\n    ) internal {\\n        unchecked {\\n            uint256 _data = (uint256(minMaintVipLevel) << 240);\\n            for (uint256 i; i < Constants.VIP_LEVEL_COUNT; ++i) {\\n                _data |= ((keyCounts[i] & 0xFFFFFF) << (i * 24));\\n            }\\n            account.vipInfo = _data;\\n        }\\n    }\\n\\n    function getOrAddCollection(UserFloorAccount storage user, address collection)\\n        internal\\n        returns (CollectionAccount storage)\\n    {\\n        CollectionAccount storage entry = user.accounts[collection];\\n        if (entry.next == address(0)) {\\n            if (user.firstCollection == address(0)) {\\n                user.firstCollection = collection;\\n                entry.next = LIST_GUARD;\\n            } else {\\n                entry.next = user.firstCollection;\\n                user.firstCollection = collection;\\n            }\\n        }\\n        return entry;\\n    }\\n\\n    function removeCollection(UserFloorAccount storage userAccount, address collection, address prev) internal {\\n        CollectionAccount storage cur = userAccount.accounts[collection];\\n        if (cur.next == address(0)) revert Errors.InvalidParam();\\n\\n        if (collection == userAccount.firstCollection) {\\n            if (cur.next == LIST_GUARD) {\\n                userAccount.firstCollection = address(0);\\n            } else {\\n                userAccount.firstCollection = cur.next;\\n            }\\n        } else {\\n            CollectionAccount storage prevAccount = userAccount.accounts[prev];\\n            if (prevAccount.next != collection) revert Errors.InvalidParam();\\n            prevAccount.next = cur.next;\\n        }\\n\\n        delete userAccount.accounts[collection];\\n    }\\n\\n    function getByKey(UserFloorAccount storage userAccount, address collection)\\n        internal\\n        view\\n        returns (CollectionAccount storage)\\n    {\\n        return userAccount.accounts[collection];\\n    }\\n\\n    function addSafeboxKey(CollectionAccount storage account, uint256 nftId, SafeBoxKey memory key) internal {\\n        if (account.keys[nftId].keyId > 0) {\\n            revert Errors.SafeBoxKeyAlreadyExist();\\n        }\\n\\n        account.keys[nftId] = key;\\n    }\\n\\n    function removeSafeboxKey(CollectionAccount storage account, uint256 nftId) internal {\\n        delete account.keys[nftId];\\n    }\\n\\n    function getByKey(CollectionAccount storage account, uint256 nftId) internal view returns (SafeBoxKey storage) {\\n        return account.keys[nftId];\\n    }\\n\\n    function tokenBalance(UserFloorAccount storage account, address token) internal view returns (uint256) {\\n        return account.tokenAmounts[token];\\n    }\\n\\n    function lockCredit(UserFloorAccount storage account, uint256 amount) internal {\\n        unchecked {\\n            account.lockedCredit += amount;\\n        }\\n    }\\n\\n    function unlockCredit(UserFloorAccount storage account, uint256 amount) internal {\\n        unchecked {\\n            account.lockedCredit -= amount;\\n        }\\n    }\\n\\n    function depositToken(UserFloorAccount storage account, address token, uint256 amount) internal {\\n        account.tokenAmounts[token] += amount;\\n    }\\n\\n    function withdrawToken(UserFloorAccount storage account, address token, uint256 amount, bool isCreditToken)\\n        internal\\n    {\\n        uint256 balance = account.tokenAmounts[token];\\n        if (balance < amount) {\\n            revert Errors.InsufficientCredit();\\n        }\\n\\n        if (isCreditToken) {\\n            uint256 avaiableBuf;\\n            unchecked {\\n                avaiableBuf = balance - amount;\\n            }\\n            if (\\n                avaiableBuf < Constants.getVipBalanceRequirements(getMinMaintVipLevel(account))\\n                    || avaiableBuf < account.minMaintCredit || avaiableBuf < account.lockedCredit\\n            ) {\\n                revert Errors.InsufficientCredit();\\n            }\\n\\n            account.tokenAmounts[token] = avaiableBuf;\\n        } else {\\n            unchecked {\\n                account.tokenAmounts[token] = balance - amount;\\n            }\\n        }\\n    }\\n\\n    function transferToken(\\n        UserFloorAccount storage from,\\n        UserFloorAccount storage to,\\n        address token,\\n        uint256 amount,\\n        bool isCreditToken\\n    ) internal {\\n        withdrawToken(from, token, amount, isCreditToken);\\n        depositToken(to, token, amount);\\n    }\\n\\n    function updateVipKeyCount(UserFloorAccount storage account, uint8 vipLevel, int256 diff) internal {\\n        if (vipLevel > 0 && diff != 0) {\\n            (uint8 minMaintVipLevel, uint256[] memory keyCounts) = getMinLevelAndVipKeyCounts(account.vipInfo);\\n\\n            if (diff < 0) {\\n                keyCounts[vipLevel] -= uint256(-diff);\\n                if (vipLevel == minMaintVipLevel && keyCounts[vipLevel] == 0) {\\n                    uint8 newVipLevel = vipLevel;\\n                    do {\\n                        unchecked {\\n                            --newVipLevel;\\n                        }\\n                    } while (newVipLevel > 0 && keyCounts[newVipLevel] == 0);\\n\\n                    minMaintVipLevel = newVipLevel;\\n                }\\n            } else {\\n                keyCounts[vipLevel] += uint256(diff);\\n                if (vipLevel > minMaintVipLevel) {\\n                    minMaintVipLevel = vipLevel;\\n                }\\n            }\\n            storeMinLevelAndVipKeyCounts(account, minMaintVipLevel, keyCounts);\\n        }\\n    }\\n\\n    function recalculateMinMaintCredit(UserFloorAccount storage account, address onBehalfOf)\\n        public\\n        returns (uint256 maxLocking)\\n    {\\n        address prev = account.firstCollection;\\n        for (address collection = account.firstCollection; collection != LIST_GUARD && collection != address(0);) {\\n            (uint256 locking, address next) =\\n                (getByKey(account, collection).totalLockingCredit, getByKey(account, collection).next);\\n            if (locking == 0) {\\n                removeCollection(account, collection, prev);\\n                collection = next;\\n            } else {\\n                if (locking > maxLocking) {\\n                    maxLocking = locking;\\n                }\\n                prev = collection;\\n                collection = next;\\n            }\\n        }\\n\\n        account.minMaintCredit = uint96(maxLocking);\\n\\n        emit UpdateMaintainCredit(onBehalfOf, maxLocking);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AuctionBidIsNotHighEnough\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionHasExpire\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionHasNotCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionInvalidBidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionSelfBid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BucketLengthExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BucketValueExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalanceForVipLevel\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientCredit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParam\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NftHasActiveActivities\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoMatchingSafeBoxKey\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeBoxAuctionWindowHasPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeBoxHasExpire\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeBoxHasNotExpire\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeBoxKeyAlreadyExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeBoxNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"bits\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeCastOverflowedUintDowncast\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"activityId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeBoxKeyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collectedFunds\",\"type\":\"uint256\"}],\"name\":\"AuctionEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trigger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"activityIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"settleToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumBid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeRateBips\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionEndTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeBoxExpiryTs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"selfTriggered\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adminFee\",\"type\":\"uint256\"}],\"name\":\"AuctionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"activityId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionEndTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeBoxExpiryTs\",\"type\":\"uint256\"}],\"name\":\"NewTopBidOnAuction\",\"type\":\"event\"}]", "ContractName": "AuctionLib", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}