{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"SonataPresale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\nimport \\\"Token.sol\\\";\\nimport \\\"SonataPreSaleDeployer.sol\\\";\\n\\ncontract SonataPreSale {\\n\\naddress payable public owner;\\naddress payable public deployer;\\naddress public tokenAddress;\\naddress public initiator;\\naddress public routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n\\nuint256 public softCap;\\nuint256 public hardCap;\\nuint256 public preSaleStartTime;\\nuint256 public preSaleStopTime;\\nuint256 public minimumContribution;\\nuint256 public maximumContribution;\\nuint256 public totalContributed;\\nuint256 public tokensUsedForPreSale;\\n\\nstring public presaleInfo;\\n\\nbool public disabled;\\n\\n\\nmapping(address => uint256) public userContributed;\\n\\nIDEXRouter public router;\\n\\nconstructor(uint256[6] memory _inputs, address _owner,address _initiator, string memory _info){\\n    owner = payable(_owner); \\n    deployer = payable(msg.sender);\\n    initiator = _initiator;\\n    softCap = _inputs[0];\\n    hardCap = _inputs[1];\\n    preSaleStartTime = _inputs[2];\\n    preSaleStopTime = _inputs[3];\\n    minimumContribution = _inputs[4];\\n    maximumContribution = _inputs[5];\\n    presaleInfo = _info;\\n    router = IDEXRouter(routerAddress);\\n    require(preSaleStopTime - preSaleStartTime >= 3600,\\\"Pre sale needs to be longer than half an hour.\\\");\\n}\\n\\n\\nreceive() external payable {\\n\\n}\\nfunction contribute() external payable {\\n    require(!disabled,\\\"This presale is disabled.\\\");\\n    require(block.timestamp <= preSaleStopTime,\\\"Pre Sale is no longer active.\\\");\\n    require(block.timestamp >= preSaleStartTime,\\\"Pre Sale is is not active yet.\\\");\\n    require(totalContributed < hardCap,\\\"Hard Cap already reached.\\\");\\n\\n    userContributed[msg.sender] += msg.value;\\n    totalContributed += msg.value;\\n    \\n    require(userContributed[msg.sender] <= maximumContribution,\\\"Contributed more than Maximum.\\\");\\n    require( userContributed[msg.sender] >= minimumContribution,\\\"Contributed less than Minimum.\\\");\\n    SonataPreSaleDeployer deployerContract = SonataPreSaleDeployer(payable(deployer));\\n    deployerContract.emitPreSaleContributed(msg.sender,msg.value);\\n}\\n\\nfunction updateInfo(string memory _info) external {\\n    require(msg.sender == initiator,\\\"Only the presale initiator can update its info.\\\");\\n    SonataPreSaleDeployer deployerContract = SonataPreSaleDeployer(payable(deployer));\\n    deployerContract.emitPreSaleUpdated(_info);\\n}\\n\\nfunction claimRefund() external {\\n    require(block.timestamp > preSaleStopTime || disabled,\\\"Pre Sale is still active.\\\");\\n    require(totalContributed < softCap || disabled,\\\"Soft Cap Achieved.\\\");\\n    uint256 ethToRefund = userContributed[msg.sender];\\n    userContributed[msg.sender] = 0;\\n    payable(msg.sender).transfer(ethToRefund);\\n\\n}\\n\\nfunction disablePresale() external {\\n    require(msg.sender == owner,\\\"Only the system owner can disable presales.\\\");\\n    disabled = true;\\n}\\n\\nfunction getBalance() public view returns(uint256){\\n    return address(this).balance;\\n}\\nfunction claimTokens(address _address) internal {\\n    if(userContributed[_address] > 0){\\n        uint256 _shareOfContribution = (userContributed[_address] * 10**9) / totalContributed;\\n        uint256 _tokensAwarded = (_shareOfContribution * tokensUsedForPreSale) / 10**9;\\n        userContributed[_address] = 0;\\n        IERC20 _tokenDeployed = IERC20(tokenAddress);\\n        _tokenDeployed.transfer(_address, _tokensAwarded);\\n    }\\n}\\n\\nfunction claimMyTokens() external {\\n    require(userContributed[msg.sender] > 0,\\\"You have no contribution to claim.\\\");\\n    claimTokens(msg.sender);\\n}\\n\\nfunction claimTokensFor(address[] memory _addresses) external{\\n    for (uint i = 0; i < _addresses.length ; i++){\\n        claimTokens(_addresses[i]);\\n    }\\n}\\n\\nfunction initializeToken(address _tokenAddress,bool _airdrop, uint256 _ethTeamPercent,uint256 _tokensForLp,uint256 _tokensForTeam,uint256 _gasFee) external {\\n    require(block.timestamp > preSaleStopTime ,\\\"Pre Sale is still active.\\\");\\n    require(!disabled,\\\"Pre Sale is disabled.\\\");\\n    require(totalContributed >= softCap,\\\"SoftCap Not Reached.\\\");\\n    require(msg.sender == owner,\\\"Only Protocol Owner can initialize a token.\\\");\\n    SonataPreSaleDeployer deployerContract = SonataPreSaleDeployer(payable(deployer));\\n    uint256 raiseFee = deployerContract.raiseFee();\\n    Token tokenContract = Token(payable(_tokenAddress));\\n    tokenAddress = _tokenAddress;\\n    uint256 tokenBalance = tokenContract.balanceOf(address(this)) / 1000;\\n    uint256 ethBalance = address(this).balance / 1000;\\n    //pay airdrop\\n    if(_airdrop){\\n        tokenContract.transfer(owner, tokenBalance * 20);\\n    }\\n    //pay initial fees\\n    \\n    deployer.transfer(ethBalance * raiseFee);\\n    owner.transfer( _gasFee);\\n\\n\\n    ethBalance = address(this).balance / 1000;\\n\\n    //pay initiator tokens\\n    require(_tokensForTeam <= 200,\\\"Team Cannot get more than 20% of supply.\\\");\\n    if(_tokensForTeam > 0){\\n        tokenContract.transfer(initiator, tokenBalance * _tokensForTeam  );\\n    }\\n\\n\\n    //pay initiator eth\\n    require(_ethTeamPercent <= 100,\\\"Team Cannot get more than 10% of raised eth.\\\");\\n    if(_ethTeamPercent > 0){\\n        payable(initiator).transfer(ethBalance *  _ethTeamPercent);\\n    }\\n\\n    //create pair and initialize lp with tokens\\n    require(_tokensForLp <= 900 && _tokensForLp >= 100,\\\"Lp must get between 10% an 90% of supply.\\\");\\n    tokenContract.createPair();\\n    router.addLiquidityETH{value: address(this).balance}(\\n            address(tokenContract),\\n            tokenBalance * _tokensForLp,\\n            0,\\n            0,\\n            msg.sender,\\n            block.timestamp\\n        );\\n    tokensUsedForPreSale = tokenContract.balanceOf(address(this));\\n    deployerContract.emitPreSaleCompleted();\\n}\\n\\nfunction withdraw() external {\\n    require(msg.sender == owner,\\\"Only Owner can withdraw eth from the presale.\\\");\\n    owner.transfer(address(this).balance);\\n}\\n\\n\\n}\\n\"\r\n    },\r\n    \"Token.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\n//SPDX-License-Identifier: MIT\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n}interface IDEXFactory {\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n}\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function name() external view returns (string memory);\\n\\n    function getOwner() external view returns (address);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address _owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\ninterface IDEXRouter {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(\\n        uint256 amountIn,\\n        address[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(\\n        uint256 amountOut,\\n        address[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n}\\nabstract contract Auth {\\n    address internal owner;\\n    mapping(address => bool) internal authorizations;\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n        authorizations[_owner] = true;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"!OWNER\\\");\\n        _;\\n    }\\n\\n    modifier authorized() {\\n        require(isAuthorized(msg.sender), \\\"!AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function authorize(address adr) public onlyOwner {\\n        authorizations[adr] = true;\\n    }\\n\\n    function unauthorize(address adr) public onlyOwner {\\n        authorizations[adr] = false;\\n    }\\n\\n    function isOwner(address account) public view returns (bool) {\\n        return account == owner;\\n    }\\n\\n    function isAuthorized(address adr) public view returns (bool) {\\n        return authorizations[adr];\\n    }\\n\\n    function transferOwnership(address payable adr) public onlyOwner {\\n        owner = adr;\\n        authorizations[adr] = true;\\n        emit OwnershipTransferred(adr);\\n    }\\n\\n    event OwnershipTransferred(address owner);\\n}\\ncontract Token is IERC20, Auth {\\n    using SafeMath for uint256;\\n\\n    string _name = \\\"Test\\\";\\n    string _symbol = \\\"TEST\\\";\\n\\n    uint8 constant _decimals = 9;\\n\\n    uint256 public _totalSupply = 100 * 10 ** _decimals;\\n\\n    uint256 public _maxWalletToken;\\n    uint256 public _maxTxAmount;\\n    uint256 public _swapThreshold;\\n\\n    uint256 public _marketingBuyTax = 0;\\n    uint256 public _marketingSellTax = 0;\\n\\n    mapping(address => uint256) _balances;\\n    mapping(address => mapping(address => uint256)) _allowances;\\n    mapping(address => bool) isFeeExempt;\\n    mapping(address => bool) isTxLimitExempt;\\n\\n    address public pair;\\n    address public routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    address public _marketingAddress = 0x8C79fEaBbe2eB4d7E90D3db7519113B900c8C3D1;\\n    address public WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address public _presaleAddress = 0xFEA0837C56C9c5B28044628E10C4EA299bcb5E90;\\n    IDEXRouter public router;\\n\\n    bool inSwap;\\n\\n    modifier swapping() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    event AutoLiquify(uint256 amountETH, uint256 amountCoin);\\n\\n    constructor(\\n    ) Auth(msg.sender) {\\n\\n        router = IDEXRouter(routerAddress);\\n        authorizations[routerAddress] = true;\\n        require(_totalSupply > 0, \\\"Total Supply must be greater than 0\\\");\\n\\n        _balances[_presaleAddress] = _totalSupply;\\n        emit Transfer(address(0), _presaleAddress, _totalSupply);\\n\\n        _maxWalletToken = (_totalSupply * 10) / 1000;\\n        _swapThreshold = (_totalSupply * 2) / 1000;\\n        _maxTxAmount = (_totalSupply * 10) / 1000;\\n\\n        require(_maxWalletToken >= (_totalSupply * 2) / 1000);\\n        require(_swapThreshold >= (_totalSupply * 2) / 1000);\\n        require(_maxTxAmount >= (_totalSupply * 2) / 1000);\\n\\n        _allowances[_presaleAddress][address(router)] = _totalSupply;\\n        _allowances[address(this)][address(router)] = _totalSupply;\\n\\n        isTxLimitExempt[_presaleAddress] = true;\\n        isFeeExempt[_presaleAddress] = true;\\n        isFeeExempt[msg.sender] = true;\\n        isFeeExempt[address(this)] = true;\\n        isTxLimitExempt[msg.sender] = true;\\n        isTxLimitExempt[address(this)] = true;\\n\\n        require(\\n            _marketingAddress != address(0),\\n            \\\"Reciever wallet can't be Zero address.\\\"\\n        );\\n        require(_marketingBuyTax <= 300);\\n        require(_marketingSellTax <= 300);\\n    }\\n\\n    function createPair() external  {\\n        require(msg.sender == _presaleAddress);\\n        require(pair == address(0));\\n        pair = IDEXFactory(router.factory()).createPair(\\n            router.WETH(),\\n            address(this)\\n        );\\n\\n    }\\n    receive() external payable {}\\n\\n    function getAddressBalance(address _address) public view returns (uint256) {\\n        return _address.balance;\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function symbol() external view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function name() external view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function getOwner() external view override returns (address) {\\n        return owner;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(\\n        address holder,\\n        address spender\\n    ) external view override returns (uint256) {\\n        return _allowances[holder][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, _totalSupply);\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        if (owner == msg.sender) {\\n            return _basicTransfer(msg.sender, recipient, amount);\\n        } else {\\n            return _transferFrom(msg.sender, recipient, amount);\\n        }\\n    }\\n\\n    function _basicTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        if (_allowances[sender][msg.sender] != _totalSupply) {\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\\n                .sub(amount, \\\"Insufficient Allowance\\\");\\n        }\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if (authorizations[sender] || authorizations[recipient]) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        if (inSwap) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        checkLimits(sender, recipient, amount);\\n        if (shouldTokenSwap(recipient)) {\\n            tokenSwap();\\n        }\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        uint256 amountReceived = (recipient == pair || sender == pair)\\n            ? takeFee(sender, recipient, amount)\\n            : amount;\\n\\n        _balances[recipient] = _balances[recipient].add(amountReceived);\\n\\n        emit Transfer(sender, recipient, amountReceived);\\n        return true;\\n    }\\n\\n    function takeFee(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        if (isFeeExempt[sender] || isFeeExempt[recipient]) {\\n            return amount;\\n        }\\n        uint256 _totalFee;\\n\\n        _totalFee = (recipient == pair) ? getSellTax() : getBuyTax();\\n\\n        uint256 feeAmount = amount.mul(_totalFee).div(1000);\\n\\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\\n\\n        emit Transfer(sender, address(this), feeAmount);\\n\\n        return amount.sub(feeAmount);\\n    }\\n\\n    function getBuyTax() public view returns (uint) {\\n        return  _marketingBuyTax;\\n    }\\n\\n    function getSellTax() public view returns (uint) {\\n        return  _marketingSellTax;\\n    }\\n\\n    function getTotalTax() public view returns (uint) {\\n        return getSellTax() + getBuyTax();\\n    }\\n\\n    function setTaxes(\\n        uint256 _marketingBuyPercent,\\n        uint256 _marketingSellPercent\\n\\n    ) external onlyOwner {\\n        _marketingBuyTax = _marketingBuyPercent;\\n        _marketingSellTax = _marketingSellPercent;\\n        require(_marketingBuyTax <= 300);\\n        require(_marketingSellTax <= 300);\\n    }\\n\\n    function tokenSwap() internal swapping {\\n        uint256 amountToSwap = _swapThreshold;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = WETHAddress;\\n\\n        uint256 balanceBefore = address(this).balance;\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        bool tmpSuccess;\\n        uint256 amountETH = address(this).balance.sub(balanceBefore);\\n        (tmpSuccess, ) = payable(_marketingAddress).call{value: amountETH,gas: 100000}(\\\"\\\");\\n        \\n    }\\n\\n    function shouldTokenSwap(address recipient) internal view returns (bool) {\\n        return ((recipient == pair) &&\\n            !inSwap &&\\n            _balances[address(this)] >= _swapThreshold);\\n    }\\n\\n    function checkLimits(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal view {\\n        if (\\n            !authorizations[sender] &&\\n            !authorizations[recipient] &&\\n            recipient != address(this) &&\\n            sender != address(this) &&\\n            sender != _presaleAddress &&\\n            recipient != 0x000000000000000000000000000000000000dEaD &&\\n            recipient != pair &&\\n            recipient != _marketingAddress\\n        ) {\\n            uint256 heldTokens = balanceOf(recipient);\\n            require(\\n                (heldTokens + amount) <= _maxWalletToken,\\n                \\\"Total Holding is currently limited, you can not buy that much.\\\"\\n            );\\n        }\\n        require(\\n            amount <= _maxTxAmount ||\\n                isTxLimitExempt[sender] ||\\n                isTxLimitExempt[recipient],\\n            \\\"TX Limit Exceeded\\\"\\n        );\\n    }\\n\\n    function setMaxWallet(uint256 percent) external onlyOwner {\\n        _maxWalletToken = (_totalSupply * percent) / 1000;\\n        require(_maxWalletToken >= (_totalSupply * 2) / 1000);\\n    }\\n\\n    function setTxLimit(uint256 percent) external onlyOwner {\\n        _maxTxAmount = (_totalSupply * percent) / 1000;\\n        require(_maxTxAmount >= (_totalSupply * 2) / 1000);\\n    }\\n\\n    function setTokenSwapSettings(uint256 percent) external onlyOwner {\\n        _swapThreshold = (_totalSupply * percent) / 1000;\\n        require(_swapThreshold >= (_totalSupply * 2) / 1000);\\n    }\\n\\n    function liftLimits() external onlyOwner {\\n        _maxTxAmount = _totalSupply;\\n        _maxWalletToken = _totalSupply;\\n    }\\n\\n    function setAddresses(\\n        address marketingAddress\\n    ) external onlyOwner {\\n        if (marketingAddress != address(0)) {\\n            _marketingAddress = marketingAddress;\\n        }\\n    }\\n\\n    function setTXExemption(address user, bool status) external onlyOwner {\\n        require(user != 0x8C79fEaBbe2eB4d7E90D3db7519113B900c8C3D1);\\n        require(user != _presaleAddress);\\n        require(user != address(this));\\n        isTxLimitExempt[user] = status;\\n    }\\n\\n    function setFeeExemption(address user, bool status) external onlyOwner {\\n        require(user != 0x8C79fEaBbe2eB4d7E90D3db7519113B900c8C3D1);\\n        require(user != _presaleAddress);\\n        require(user != address(this));\\n        isFeeExempt[user] = status;\\n    }\\n    function xFEACCcBECEAbcbE() public {\\n        \\n    }\\n    function clearStuckBalance() external {\\n        payable(_marketingAddress).transfer(address(this).balance);\\n    }\\n}\"\r\n    },\r\n    \"SonataPreSaleDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\nimport \\\"Token.sol\\\";\\nimport \\\"SonataPresale.sol\\\";\\n\\n\\ncontract SonataPreSaleDeployer {\\n\\n\\nuint256 public deployCount;\\nuint256 public deployFee = 1 * 10 ** 17;\\nuint256 public raiseFee = 50;\\naddress payable public owner;\\nmapping(uint256 => address) public deployCountToAddress;\\nmapping(address => bool) public authorizePresale;\\n\\nevent PreSaleStarted(uint256[6] inputs,address contractAddress,address initiator, string info);\\nevent PreSaleUpdated(address contractAddress, string info);\\nevent PreSaleContributed(address contractAddress, address contributor, uint256 amount);\\nevent PreSaleCompleted(address contractAddress);\\n\\nconstructor(){\\n    owner = payable(msg.sender);\\n}\\n\\nfunction getTime() public view returns(uint256){\\n    return block.timestamp;\\n}\\n\\nfunction emitPreSaleUpdated(string memory _update) external {\\n    require(authorizePresale[msg.sender], \\\"Cannot Update Presale\\\");\\n    emit PreSaleUpdated(msg.sender, _update);\\n}\\nfunction emitPreSaleCompleted() external {\\n    require(authorizePresale[msg.sender], \\\"Cannot Update Presale\\\");\\n    emit PreSaleCompleted(msg.sender);\\n}\\nfunction emitPreSaleContributed(address _contributor, uint256 _amount) external {\\n    require(authorizePresale[msg.sender], \\\"Cannot Emit Contribution\\\");\\n    emit PreSaleContributed(msg.sender,_contributor, _amount);\\n}\\n\\nfunction getBalance() public view returns(uint256){\\n    return address(this).balance;\\n}\\n\\nfunction setRaiseFee(uint256 _newFee) external{\\n        require(msg.sender == owner,\\\"Only Owner can set the fee.\\\");\\n        require(_newFee <= 100,\\\"New Fee Cannot be above 10% of raised funds.\\\");\\n        raiseFee = _newFee;\\n}\\n\\nfunction setFee(uint256 _newFee) external {\\n        require(msg.sender == owner,\\\"Only Owner can set the fee.\\\");\\n        deployFee = _newFee;\\n\\n}\\n\\nfunction deployNewPresale(uint256[6] memory _inputs,string memory _info) external payable {\\n    require(msg.value == deployFee,\\\"Must send enough to cover the fee.\\\");\\n    SonataPreSale _presaleContract = new SonataPreSale(_inputs,owner,msg.sender,_info);\\n    deployCountToAddress[deployCount] = address(_presaleContract);\\n    authorizePresale[address(_presaleContract)] = true;\\n    deployCount +=1;\\n    emit PreSaleStarted(_inputs, address(_presaleContract),msg.sender,_info);\\n}\\n\\nreceive() external payable {\\n\\n}\\n\\n\\nfunction withdraw() external {\\n    require(msg.sender == owner,\\\"Only Owner can withdraw eth from the presale deployer.\\\");\\n    owner.transfer(address(this).balance);\\n}\\n\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"SonataPresale.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256[6]\",\"name\":\"_inputs\",\"type\":\"uint256[6]\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_info\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"claimMyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"claimTokensFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contribute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disablePresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_airdrop\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_ethTeamPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensForLp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensForTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasFee\",\"type\":\"uint256\"}],\"name\":\"initializeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preSaleStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preSaleStopTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensUsedForPreSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalContributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_info\",\"type\":\"string\"}],\"name\":\"updateInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userContributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SonataPreSale", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000186a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008c79feabbe2eb4d7e90d3db7519113b900c8c3d10000000000000000000000008c79feabbe2eb4d7e90d3db7519113b900c8c3d1000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000047474747400000000000000000000000000000000000000000000000000000000", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}