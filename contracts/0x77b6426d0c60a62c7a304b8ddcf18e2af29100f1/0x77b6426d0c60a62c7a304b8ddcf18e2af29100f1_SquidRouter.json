{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IAxelarGasService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IUpgradable } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol';\\n\\n/**\\n * @title IAxelarGasService Interface\\n * @notice This is an interface for the AxelarGasService contract which manages gas payments\\n * and refunds for cross-chain communication on the Axelar network.\\n * @dev This interface inherits IUpgradable\\n */\\ninterface IAxelarGasService is IUpgradable {\\n    error InvalidAddress();\\n    error NotCollector();\\n    error InvalidAmounts();\\n\\n    event GasPaidForContractCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasPaidForContractCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForContractCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForContractCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasPaidForExpressCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasPaidForExpressCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForExpressCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForExpressCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasAdded(bytes32 indexed txHash, uint256 indexed logIndex, address gasToken, uint256 gasFeeAmount, address refundAddress);\\n\\n    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\\n\\n    event ExpressGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, address gasToken, uint256 gasFeeAmount, address refundAddress);\\n\\n    event NativeExpressGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\\n\\n    event Refunded(bytes32 indexed txHash, uint256 indexed logIndex, address payable receiver, address token, uint256 amount);\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for a contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForContractCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for a contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForContractCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using native currency for a contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForContractCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Pay for gas using native currency for a contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForContractCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for an express contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForExpressCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for an express contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForExpressCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using native currency for an express contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForExpressCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Pay for gas using native currency for an express contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForExpressCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Add additional gas payment using ERC20 tokens after initiating a cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param gasToken The ERC20 token address used to add gas\\n     * @param gasFeeAmount The amount of tokens to add as gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Add additional gas payment using native currency after initiating a cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addNativeGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Add additional gas payment using ERC20 tokens after initiating an express cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param gasToken The ERC20 token address used to add gas\\n     * @param gasFeeAmount The amount of tokens to add as gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addExpressGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Add additional gas payment using native currency after initiating an express cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addNativeExpressGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Allows the gasCollector to collect accumulated fees from the contract.\\n     * @dev Use address(0) as the token address for native currency.\\n     * @param receiver The address to receive the collected fees\\n     * @param tokens Array of token addresses to be collected\\n     * @param amounts Array of amounts to be collected for each respective token address\\n     */\\n    function collectFees(\\n        address payable receiver,\\n        address[] calldata tokens,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    /**\\n     * @notice Refunds gas payment to the receiver in relation to a specific cross-chain transaction.\\n     * @dev Only callable by the gasCollector.\\n     * @dev Use address(0) as the token address to refund native currency.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param receiver The address to receive the refund\\n     * @param token The token address to be refunded\\n     * @param amount The amount to refund\\n     */\\n    function refund(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address payable receiver,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice Returns the address of the designated gas collector.\\n     * @return address of the gas collector\\n     */\\n    function gasCollector() external returns (address);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IAxelarGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\ninterface IAxelarGateway {\\n    /**********\\\\\\n    |* Errors *|\\n    \\\\**********/\\n\\n    error NotSelf();\\n    error NotProxy();\\n    error InvalidCodeHash();\\n    error SetupFailed();\\n    error InvalidAuthModule();\\n    error InvalidTokenDeployer();\\n    error InvalidAmount();\\n    error InvalidChainId();\\n    error InvalidCommands();\\n    error TokenDoesNotExist(string symbol);\\n    error TokenAlreadyExists(string symbol);\\n    error TokenDeployFailed(string symbol);\\n    error TokenContractDoesNotExist(address token);\\n    error BurnFailed(string symbol);\\n    error MintFailed(string symbol);\\n    error InvalidSetMintLimitsParams();\\n    error ExceedMintLimit(string symbol);\\n\\n    /**********\\\\\\n    |* Events *|\\n    \\\\**********/\\n\\n    event TokenSent(address indexed sender, string destinationChain, string destinationAddress, string symbol, uint256 amount);\\n\\n    event ContractCall(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload\\n    );\\n\\n    event ContractCallWithToken(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event Executed(bytes32 indexed commandId);\\n\\n    event TokenDeployed(string symbol, address tokenAddresses);\\n\\n    event ContractCallApproved(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event ContractCallApprovedWithMint(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\\n\\n    event OperatorshipTransferred(bytes newOperatorsData);\\n\\n    event Upgraded(address indexed implementation);\\n\\n    /********************\\\\\\n    |* Public Functions *|\\n    \\\\********************/\\n\\n    function sendToken(\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function callContract(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function callContractWithToken(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function isContractCallApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash\\n    ) external view returns (bool);\\n\\n    function isContractCallAndMintApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external view returns (bool);\\n\\n    function validateContractCall(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash\\n    ) external returns (bool);\\n\\n    function validateContractCallAndMint(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /***********\\\\\\n    |* Getters *|\\n    \\\\***********/\\n\\n    function authModule() external view returns (address);\\n\\n    function tokenDeployer() external view returns (address);\\n\\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\\n\\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\\n\\n    function allTokensFrozen() external view returns (bool);\\n\\n    function implementation() external view returns (address);\\n\\n    function tokenAddresses(string memory symbol) external view returns (address);\\n\\n    function tokenFrozen(string memory symbol) external view returns (bool);\\n\\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\\n\\n    function adminEpoch() external view returns (uint256);\\n\\n    function adminThreshold(uint256 epoch) external view returns (uint256);\\n\\n    function admins(uint256 epoch) external view returns (address[] memory);\\n\\n    /*******************\\\\\\n    |* Admin Functions *|\\n    \\\\*******************/\\n\\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata setupParams\\n    ) external;\\n\\n    /**********************\\\\\\n    |* External Functions *|\\n    \\\\**********************/\\n\\n    function setup(bytes calldata params) external;\\n\\n    function execute(bytes calldata input) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/express/AxelarExpressExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\\nimport { ExpressExecutorTracker } from './ExpressExecutorTracker.sol';\\n\\nimport { SafeTokenTransferFrom, SafeTokenTransfer } from '../libs/SafeTransfer.sol';\\nimport { IERC20 } from '../interfaces/IERC20.sol';\\n\\ncontract AxelarExpressExecutable is ExpressExecutorTracker {\\n    using SafeTokenTransfer for IERC20;\\n    using SafeTokenTransferFrom for IERC20;\\n\\n    IAxelarGateway public immutable gateway;\\n\\n    constructor(address gateway_) {\\n        if (gateway_ == address(0)) revert InvalidAddress();\\n\\n        gateway = IAxelarGateway(gateway_);\\n    }\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external {\\n        bytes32 payloadHash = keccak256(payload);\\n\\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\\n            revert NotApprovedByGateway();\\n\\n        address expressExecutor = _popExpressExecutor(commandId, sourceChain, sourceAddress, payloadHash);\\n\\n        if (expressExecutor != address(0)) {\\n            // slither-disable-next-line reentrancy-events\\n            emit ExpressExecutionFulfilled(commandId, sourceChain, sourceAddress, payloadHash, expressExecutor);\\n        } else {\\n            _execute(sourceChain, sourceAddress, payload);\\n        }\\n    }\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external {\\n        bytes32 payloadHash = keccak256(payload);\\n        if (\\n            !gateway.validateContractCallAndMint(\\n                commandId,\\n                sourceChain,\\n                sourceAddress,\\n                payloadHash,\\n                tokenSymbol,\\n                amount\\n            )\\n        ) revert NotApprovedByGateway();\\n\\n        address expressExecutor = _popExpressExecutorWithToken(\\n            commandId,\\n            sourceChain,\\n            sourceAddress,\\n            payloadHash,\\n            tokenSymbol,\\n            amount\\n        );\\n\\n        if (expressExecutor != address(0)) {\\n            // slither-disable-next-line reentrancy-events\\n            emit ExpressExecutionWithTokenFulfilled(\\n                commandId,\\n                sourceChain,\\n                sourceAddress,\\n                payloadHash,\\n                tokenSymbol,\\n                amount,\\n                expressExecutor\\n            );\\n\\n            address gatewayToken = gateway.tokenAddresses(tokenSymbol);\\n            IERC20(gatewayToken).safeTransfer(expressExecutor, amount);\\n        } else {\\n            _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\\n        }\\n    }\\n\\n    function expressExecute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external payable virtual {\\n        if (gateway.isCommandExecuted(commandId)) revert AlreadyExecuted();\\n\\n        address expressExecutor = msg.sender;\\n        bytes32 payloadHash = keccak256(payload);\\n\\n        emit ExpressExecuted(commandId, sourceChain, sourceAddress, payloadHash, expressExecutor);\\n\\n        _setExpressExecutor(commandId, sourceChain, sourceAddress, payloadHash, expressExecutor);\\n\\n        _execute(sourceChain, sourceAddress, payload);\\n    }\\n\\n    function expressExecuteWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external payable virtual {\\n        if (gateway.isCommandExecuted(commandId)) revert AlreadyExecuted();\\n\\n        address expressExecutor = msg.sender;\\n        address gatewayToken = gateway.tokenAddresses(symbol);\\n        bytes32 payloadHash = keccak256(payload);\\n\\n        emit ExpressExecutedWithToken(\\n            commandId,\\n            sourceChain,\\n            sourceAddress,\\n            payloadHash,\\n            symbol,\\n            amount,\\n            expressExecutor\\n        );\\n\\n        _setExpressExecutorWithToken(\\n            commandId,\\n            sourceChain,\\n            sourceAddress,\\n            payloadHash,\\n            symbol,\\n            amount,\\n            expressExecutor\\n        );\\n\\n        IERC20(gatewayToken).safeTransferFrom(expressExecutor, address(this), amount);\\n\\n        _executeWithToken(sourceChain, sourceAddress, payload, symbol, amount);\\n    }\\n\\n    function _execute(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) internal virtual {}\\n\\n    function _executeWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/express/ExpressExecutorTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarExpressExecutable } from '../interfaces/IAxelarExpressExecutable.sol';\\n\\nabstract contract ExpressExecutorTracker is IAxelarExpressExecutable {\\n    bytes32 internal constant PREFIX_EXPRESS_EXECUTE = keccak256('express-execute');\\n    bytes32 internal constant PREFIX_EXPRESS_EXECUTE_WITH_TOKEN = keccak256('express-execute-with-token');\\n\\n    function _expressExecuteSlot(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash\\n    ) internal pure returns (bytes32 slot) {\\n        slot = keccak256(abi.encode(PREFIX_EXPRESS_EXECUTE, commandId, sourceChain, sourceAddress, payloadHash));\\n    }\\n\\n    function _expressExecuteWithTokenSlot(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) internal pure returns (bytes32 slot) {\\n        slot = keccak256(\\n            abi.encode(\\n                PREFIX_EXPRESS_EXECUTE_WITH_TOKEN,\\n                commandId,\\n                sourceChain,\\n                sourceAddress,\\n                payloadHash,\\n                symbol,\\n                amount\\n            )\\n        );\\n    }\\n\\n    function getExpressExecutor(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash\\n    ) external view returns (address expressExecutor) {\\n        bytes32 slot = _expressExecuteSlot(commandId, sourceChain, sourceAddress, payloadHash);\\n\\n        assembly {\\n            expressExecutor := sload(slot)\\n        }\\n    }\\n\\n    function getExpressExecutorWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external view returns (address expressExecutor) {\\n        bytes32 slot = _expressExecuteWithTokenSlot(commandId, sourceChain, sourceAddress, payloadHash, symbol, amount);\\n\\n        assembly {\\n            expressExecutor := sload(slot)\\n        }\\n    }\\n\\n    function _setExpressExecutor(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        address expressExecutor\\n    ) internal {\\n        bytes32 slot = _expressExecuteSlot(commandId, sourceChain, sourceAddress, payloadHash);\\n        address currentExecutor;\\n\\n        assembly {\\n            currentExecutor := sload(slot)\\n        }\\n\\n        if (currentExecutor != address(0)) revert ExpressExecutorAlreadySet();\\n\\n        assembly {\\n            sstore(slot, expressExecutor)\\n        }\\n    }\\n\\n    function _setExpressExecutorWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount,\\n        address expressExecutor\\n    ) internal {\\n        bytes32 slot = _expressExecuteWithTokenSlot(commandId, sourceChain, sourceAddress, payloadHash, symbol, amount);\\n        address currentExecutor;\\n\\n        assembly {\\n            currentExecutor := sload(slot)\\n        }\\n\\n        if (currentExecutor != address(0)) revert ExpressExecutorAlreadySet();\\n\\n        assembly {\\n            sstore(slot, expressExecutor)\\n        }\\n    }\\n\\n    function _popExpressExecutor(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash\\n    ) internal returns (address expressExecutor) {\\n        bytes32 slot = _expressExecuteSlot(commandId, sourceChain, sourceAddress, payloadHash);\\n\\n        assembly {\\n            expressExecutor := sload(slot)\\n            if expressExecutor {\\n                sstore(slot, 0)\\n            }\\n        }\\n    }\\n\\n    function _popExpressExecutorWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) internal returns (address expressExecutor) {\\n        bytes32 slot = _expressExecuteWithTokenSlot(commandId, sourceChain, sourceAddress, payloadHash, symbol, amount);\\n\\n        assembly {\\n            expressExecutor := sload(slot)\\n            if expressExecutor {\\n                sstore(slot, 0)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from './IAxelarGateway.sol';\\n\\ninterface IAxelarExecutable {\\n    error InvalidAddress();\\n    error NotApprovedByGateway();\\n\\n    function gateway() external view returns (IAxelarGateway);\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExpressExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarExecutable } from './IAxelarExecutable.sol';\\n\\n/**\\n * @title IAxelarExpressExecutable\\n * @notice Interface for the Axelar Express Executable contract.\\n */\\ninterface IAxelarExpressExecutable is IAxelarExecutable {\\n    // Custom errors\\n    error AlreadyExecuted();\\n    error InsufficientValue();\\n    error ExpressExecutorAlreadySet();\\n\\n    /**\\n     * @notice Emitted when an express execution is successfully performed.\\n     * @param commandId The unique identifier for the command.\\n     * @param sourceChain The source chain.\\n     * @param sourceAddress The source address.\\n     * @param payloadHash The hash of the payload.\\n     * @param expressExecutor The address of the express executor.\\n     */\\n    event ExpressExecuted(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        bytes32 payloadHash,\\n        address indexed expressExecutor\\n    );\\n\\n    /**\\n     * @notice Emitted when an express execution with a token is successfully performed.\\n     * @param commandId The unique identifier for the command.\\n     * @param sourceChain The source chain.\\n     * @param sourceAddress The source address.\\n     * @param payloadHash The hash of the payload.\\n     * @param symbol The token symbol.\\n     * @param amount The amount of tokens.\\n     * @param expressExecutor The address of the express executor.\\n     */\\n    event ExpressExecutedWithToken(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        bytes32 payloadHash,\\n        string symbol,\\n        uint256 indexed amount,\\n        address indexed expressExecutor\\n    );\\n\\n    /**\\n     * @notice Emitted when an express execution is fulfilled.\\n     * @param commandId The commandId for the contractCall.\\n     * @param sourceChain The source chain.\\n     * @param sourceAddress The source address.\\n     * @param payloadHash The hash of the payload.\\n     * @param expressExecutor The address of the express executor.\\n     */\\n    event ExpressExecutionFulfilled(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        bytes32 payloadHash,\\n        address indexed expressExecutor\\n    );\\n\\n    /**\\n     * @notice Emitted when an express execution with a token is fulfilled.\\n     * @param commandId The commandId for the contractCallWithToken.\\n     * @param sourceChain The source chain.\\n     * @param sourceAddress The source address.\\n     * @param payloadHash The hash of the payload.\\n     * @param symbol The token symbol.\\n     * @param amount The amount of tokens.\\n     * @param expressExecutor The address of the express executor.\\n     */\\n    event ExpressExecutionWithTokenFulfilled(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        bytes32 payloadHash,\\n        string symbol,\\n        uint256 indexed amount,\\n        address indexed expressExecutor\\n    );\\n\\n    /**\\n     * @notice Returns the express executor for a given command.\\n     * @param commandId The commandId for the contractCall.\\n     * @param sourceChain The source chain.\\n     * @param sourceAddress The source address.\\n     * @param payloadHash The hash of the payload.\\n     * @return expressExecutor The address of the express executor.\\n     */\\n    function getExpressExecutor(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash\\n    ) external view returns (address expressExecutor);\\n\\n    /**\\n     * @notice Returns the express executor with token for a given command.\\n     * @param commandId The commandId for the contractCallWithToken.\\n     * @param sourceChain The source chain.\\n     * @param sourceAddress The source address.\\n     * @param payloadHash The hash of the payload.\\n     * @param symbol The token symbol.\\n     * @param amount The amount of tokens.\\n     * @return expressExecutor The address of the express executor.\\n     */\\n    function getExpressExecutorWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external view returns (address expressExecutor);\\n\\n    /**\\n     * @notice Express executes a contract call.\\n     * @param commandId The commandId for the contractCall.\\n     * @param sourceChain The source chain.\\n     * @param sourceAddress The source address.\\n     * @param payload The payload data.\\n     */\\n    function expressExecute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external payable;\\n\\n    /**\\n     * @notice Express executes a contract call with token.\\n     * @param commandId The commandId for the contractCallWithToken.\\n     * @param sourceChain The source chain.\\n     * @param sourceAddress The source address.\\n     * @param payload The payload data.\\n     * @param symbol The token symbol.\\n     * @param amount The amount of token.\\n     */\\n    function expressExecuteWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IGovernable } from './IGovernable.sol';\\n\\ninterface IAxelarGateway is IGovernable {\\n    /**********\\\\\\n    |* Errors *|\\n    \\\\**********/\\n\\n    error NotSelf();\\n    error NotProxy();\\n    error InvalidCodeHash();\\n    error SetupFailed();\\n    error InvalidAuthModule();\\n    error InvalidTokenDeployer();\\n    error InvalidAmount();\\n    error InvalidChainId();\\n    error InvalidCommands();\\n    error TokenDoesNotExist(string symbol);\\n    error TokenAlreadyExists(string symbol);\\n    error TokenDeployFailed(string symbol);\\n    error TokenContractDoesNotExist(address token);\\n    error BurnFailed(string symbol);\\n    error MintFailed(string symbol);\\n    error InvalidSetMintLimitsParams();\\n    error ExceedMintLimit(string symbol);\\n\\n    /**********\\\\\\n    |* Events *|\\n    \\\\**********/\\n\\n    event TokenSent(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationAddress,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event ContractCall(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload\\n    );\\n\\n    event ContractCallWithToken(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event Executed(bytes32 indexed commandId);\\n\\n    event TokenDeployed(string symbol, address tokenAddresses);\\n\\n    event ContractCallApproved(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event ContractCallApprovedWithMint(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\\n\\n    event OperatorshipTransferred(bytes newOperatorsData);\\n\\n    event Upgraded(address indexed implementation);\\n\\n    /********************\\\\\\n    |* Public Functions *|\\n    \\\\********************/\\n\\n    function sendToken(\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function callContract(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function callContractWithToken(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function isContractCallApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash\\n    ) external view returns (bool);\\n\\n    function isContractCallAndMintApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external view returns (bool);\\n\\n    function validateContractCall(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash\\n    ) external returns (bool);\\n\\n    function validateContractCallAndMint(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /***********\\\\\\n    |* Getters *|\\n    \\\\***********/\\n\\n    function authModule() external view returns (address);\\n\\n    function tokenDeployer() external view returns (address);\\n\\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\\n\\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\\n\\n    function allTokensFrozen() external view returns (bool);\\n\\n    function implementation() external view returns (address);\\n\\n    function tokenAddresses(string memory symbol) external view returns (address);\\n\\n    function tokenFrozen(string memory symbol) external view returns (bool);\\n\\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\\n\\n    function adminEpoch() external view returns (uint256);\\n\\n    function adminThreshold(uint256 epoch) external view returns (uint256);\\n\\n    function admins(uint256 epoch) external view returns (address[] memory);\\n\\n    /*******************\\\\\\n    |* Admin Functions *|\\n    \\\\*******************/\\n\\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata setupParams\\n    ) external;\\n\\n    /**********************\\\\\\n    |* External Functions *|\\n    \\\\**********************/\\n\\n    function setup(bytes calldata params) external;\\n\\n    function execute(bytes calldata input) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IContractIdentifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// General interface for upgradable contracts\\ninterface IContractIdentifier {\\n    /**\\n     * @notice Returns the contract ID. It can be used as a check during upgrades.\\n     * @dev Meant to be overridden in derived contracts.\\n     * @return bytes32 The contract ID\\n     */\\n    function contractId() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    error InvalidAccount();\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IGovernable Interface\\n * @notice This is an interface used by the AxelarGateway contract to manage governance and mint limiter roles.\\n */\\ninterface IGovernable {\\n    error NotGovernance();\\n    error NotMintLimiter();\\n    error InvalidGovernance();\\n    error InvalidMintLimiter();\\n\\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\\n    event MintLimiterTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    /**\\n     * @notice Returns the governance address.\\n     * @return address of the governance\\n     */\\n    function governance() external view returns (address);\\n\\n    /**\\n     * @notice Returns the mint limiter address.\\n     * @return address of the mint limiter\\n     */\\n    function mintLimiter() external view returns (address);\\n\\n    /**\\n     * @notice Transfer the governance role to another address.\\n     * @param newGovernance The new governance address\\n     */\\n    function transferGovernance(address newGovernance) external;\\n\\n    /**\\n     * @notice Transfer the mint limiter role to another address.\\n     * @param newGovernance The new mint limiter address\\n     */\\n    function transferMintLimiter(address newGovernance) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IInitProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IProxy } from './IProxy.sol';\\n\\n// General interface for upgradable contracts\\ninterface IInitProxy is IProxy {\\n    function init(\\n        address implementationAddress,\\n        address newOwner,\\n        bytes memory params\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IOwnable Interface\\n * @notice IOwnable is an interface that abstracts the implementation of a\\n * contract with ownership control features. It's commonly used in upgradable\\n * contracts and includes the functionality to get current owner, transfer\\n * ownership, and propose and accept ownership.\\n */\\ninterface IOwnable {\\n    error NotOwner();\\n    error InvalidOwner();\\n    error InvalidOwnerAddress();\\n\\n    event OwnershipTransferStarted(address indexed newOwner);\\n    event OwnershipTransferred(address indexed newOwner);\\n\\n    /**\\n     * @notice Returns the current owner of the contract.\\n     * @return address The address of the current owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the pending owner of the contract.\\n     * @return address The address of the pending owner\\n     */\\n    function pendingOwner() external view returns (address);\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new address\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function transferOwnership(address newOwner) external;\\n\\n    /**\\n     * @notice Proposes to transfer the contract's ownership to a new address.\\n     * The new owner needs to accept the ownership explicitly.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function proposeOwnership(address newOwner) external;\\n\\n    /**\\n     * @notice Transfers ownership to the pending owner.\\n     * @dev Can only be called by the pending owner\\n     */\\n    function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// General interface for upgradable contracts\\ninterface IProxy {\\n    error InvalidOwner();\\n    error InvalidImplementation();\\n    error SetupFailed();\\n    error NotOwner();\\n    error AlreadyInitialized();\\n\\n    function implementation() external view returns (address);\\n\\n    function setup(bytes calldata setupParams) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnable } from './IOwnable.sol';\\nimport { IContractIdentifier } from './IContractIdentifier.sol';\\n\\n// General interface for upgradable contracts\\ninterface IUpgradable is IOwnable, IContractIdentifier {\\n    error InvalidCodeHash();\\n    error InvalidImplementation();\\n    error SetupFailed();\\n    error NotProxy();\\n\\n    event Upgraded(address indexed newImplementation);\\n\\n    function implementation() external view returns (address);\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata params\\n    ) external;\\n\\n    function setup(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/libs/SafeTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '../interfaces/IERC20.sol';\\n\\nerror TokenTransferFailed();\\n\\n/*\\n * @title SafeTokenCall\\n * @dev This library is used for performing safe token transfers.\\n */\\nlibrary SafeTokenCall {\\n    /*\\n     * @notice Make a safe call to a token contract.\\n     * @param token The token contract to interact with.\\n     * @param callData The function call data.\\n     * @throws TokenTransferFailed error if transfer of token is not successful.\\n     */\\n    function safeCall(IERC20 token, bytes memory callData) internal {\\n        (bool success, bytes memory returnData) = address(token).call(callData);\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n\\n        if (!transferred || address(token).code.length == 0) revert TokenTransferFailed();\\n    }\\n}\\n\\n/*\\n * @title SafeTokenTransfer\\n * @dev This library safely transfers tokens from the contract to a recipient.\\n */\\nlibrary SafeTokenTransfer {\\n    /*\\n     * @notice Transfer tokens to a recipient.\\n     * @param token The token contract.\\n     * @param receiver The recipient of the tokens.\\n     * @param amount The amount of tokens to transfer.\\n     */\\n    function safeTransfer(\\n        IERC20 token,\\n        address receiver,\\n        uint256 amount\\n    ) internal {\\n        SafeTokenCall.safeCall(token, abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));\\n    }\\n}\\n\\n/*\\n * @title SafeTokenTransferFrom\\n * @dev This library helps to safely transfer tokens on behalf of a token holder.\\n */\\nlibrary SafeTokenTransferFrom {\\n    /*\\n     * @notice Transfer tokens on behalf of a token holder.\\n     * @param token The token contract.\\n     * @param from The address of the token holder.\\n     * @param to The address the tokens are to be sent to.\\n     * @param amount The amount of tokens to be transferred.\\n     */\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        SafeTokenCall.safeCall(token, abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount));\\n    }\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/BaseProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IProxy } from '../interfaces/IProxy.sol';\\n\\n/**\\n * @title BaseProxy Contract\\n * @dev This abstract contract implements a basic proxy that stores an implementation address. Fallback function\\n * calls are delegated to the implementation. This contract is meant to be inherited by other proxy contracts.\\n */\\nabstract contract BaseProxy is IProxy {\\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n    // keccak256('owner')\\n    bytes32 internal constant _OWNER_SLOT = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     * @return implementation_ The address of the current implementation contract\\n     */\\n    function implementation() public view virtual returns (address implementation_) {\\n        assembly {\\n            implementation_ := sload(_IMPLEMENTATION_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @dev Shadows the setup function of the implementation contract so it can't be called directly via the proxy.\\n     * @param params The setup parameters for the implementation contract.\\n     */\\n    function setup(bytes calldata params) external {}\\n\\n    /**\\n     * @dev Returns the contract ID. It can be used as a check during upgrades. Meant to be implemented in derived contracts.\\n     * @return bytes32 The contract ID\\n     */\\n    function contractId() internal pure virtual returns (bytes32);\\n\\n    /**\\n     * @dev Fallback function. Delegates the call to the current implementation contract.\\n     */\\n    fallback() external payable virtual {\\n        address implementation_ = implementation();\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n\\n            let result := delegatecall(gas(), implementation_, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Payable fallback function. Can be overridden in derived contracts.\\n     */\\n    receive() external payable virtual {}\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/InitProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IInitProxy } from '../interfaces/IInitProxy.sol';\\nimport { IContractIdentifier } from '../interfaces/IContractIdentifier.sol';\\nimport { BaseProxy } from './BaseProxy.sol';\\n\\n/**\\n * @title InitProxy Contract\\n * @notice A proxy contract that can be initialized to use a specified implementation and owner. Inherits from BaseProxy\\n * and implements the IInitProxy interface.\\n * @dev This proxy is constructed empty and then later initialized with the implementation contract address, new owner address,\\n * and any optional setup parameters.\\n */\\ncontract InitProxy is BaseProxy, IInitProxy {\\n    /**\\n     * @dev Initializes the contract and sets the caller as the owner of the contract.\\n     */\\n    constructor() {\\n        assembly {\\n            sstore(_OWNER_SLOT, caller())\\n        }\\n    }\\n\\n    function contractId() internal pure virtual override returns (bytes32) {\\n        return bytes32(0);\\n    }\\n\\n    /**\\n     * @notice Initializes the proxy contract with the specified implementation, new owner, and any optional setup parameters.\\n     * @param implementationAddress The address of the implementation contract\\n     * @param newOwner The address of the new proxy owner\\n     * @param params Optional parameters to be passed to the setup function of the implementation contract\\n     * @dev This function is only callable by the owner of the proxy. If the proxy has already been initialized, it will revert.\\n     * If the contract ID of the implementation is incorrect, it will also revert. It then stores the implementation address and\\n     * new owner address in the designated storage slots and calls the setup function on the implementation (if setup params exist).\\n     */\\n    function init(\\n        address implementationAddress,\\n        address newOwner,\\n        bytes memory params\\n    ) external {\\n        address owner;\\n\\n        assembly {\\n            owner := sload(_OWNER_SLOT)\\n        }\\n\\n        if (msg.sender != owner) revert NotOwner();\\n        if (implementation() != address(0)) revert AlreadyInitialized();\\n\\n        bytes32 id = contractId();\\n        // Skipping the check if contractId() is not set by an inheriting proxy contract\\n        if (id != bytes32(0) && IContractIdentifier(implementationAddress).contractId() != id)\\n            revert InvalidImplementation();\\n\\n        assembly {\\n            sstore(_IMPLEMENTATION_SLOT, implementationAddress)\\n            sstore(_OWNER_SLOT, newOwner)\\n        }\\n\\n        if (params.length != 0) {\\n            (bool success, ) = implementationAddress.delegatecall(\\n                abi.encodeWithSelector(BaseProxy.setup.selector, params)\\n            );\\n            if (!success) revert SetupFailed();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Upgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IUpgradable } from '../interfaces/IUpgradable.sol';\\nimport { Ownable } from '../utils/Ownable.sol';\\n\\n/**\\n * @title Upgradable Contract\\n * @notice This contract provides an interface for upgradable smart contracts and includes the functionality to perform upgrades.\\n */\\nabstract contract Upgradable is Ownable, IUpgradable {\\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n    address internal immutable implementationAddress;\\n\\n    /**\\n     * @notice Constructor sets the implementation address to the address of the contract itself\\n     * @dev This is used in the onlyProxy modifier to prevent certain functions from being called directly\\n     * on the implementation contract itself.\\n     * @dev The owner is initially set as address(1) because the actual owner is set within the proxy. It is not\\n     * set as the zero address because Ownable is designed to throw an error for ownership transfers to the zero address.\\n     */\\n    constructor() Ownable(address(1)) {\\n        implementationAddress = address(this);\\n    }\\n\\n    /**\\n     * @notice Modifier to ensure that a function can only be called by the proxy\\n     */\\n    modifier onlyProxy() {\\n        // Prevent setup from being called on the implementation\\n        if (address(this) == implementationAddress) revert NotProxy();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns the address of the current implementation\\n     * @return implementation_ Address of the current implementation\\n     */\\n    function implementation() public view returns (address implementation_) {\\n        assembly {\\n            implementation_ := sload(_IMPLEMENTATION_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @notice Upgrades the contract to a new implementation\\n     * @param newImplementation The address of the new implementation contract\\n     * @param newImplementationCodeHash The codehash of the new implementation contract\\n     * @param params Optional setup parameters for the new implementation contract\\n     * @dev This function is only callable by the owner.\\n     */\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata params\\n    ) external override onlyOwner {\\n        if (IUpgradable(newImplementation).contractId() != IUpgradable(this).contractId())\\n            revert InvalidImplementation();\\n\\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\\n\\n        emit Upgraded(newImplementation);\\n\\n        if (params.length > 0) {\\n            // slither-disable-next-line controlled-delegatecall\\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(this.setup.selector, params));\\n\\n            if (!success) revert SetupFailed();\\n        }\\n\\n        assembly {\\n            sstore(_IMPLEMENTATION_SLOT, newImplementation)\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets up the contract with initial data\\n     * @param data Initialization data for the contract\\n     * @dev This function is only callable by the proxy contract.\\n     */\\n    function setup(bytes calldata data) external override onlyProxy {\\n        _setup(data);\\n    }\\n\\n    /**\\n     * @notice Internal function to set up the contract with initial data\\n     * @param data Initialization data for the contract\\n     * @dev This function should be implemented in derived contracts.\\n     */\\n    function _setup(bytes calldata data) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnable } from '../interfaces/IOwnable.sol';\\n\\n/**\\n * @title Ownable\\n * @notice A contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The owner account is set through ownership transfer. This module makes\\n * it possible to transfer the ownership of the contract to a new account in one\\n * step, as well as to an interim pending owner. In the second flow the ownership does not\\n * change until the pending owner accepts the ownership transfer.\\n */\\nabstract contract Ownable is IOwnable {\\n    // keccak256('owner')\\n    bytes32 internal constant _OWNER_SLOT = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\\n    // keccak256('ownership-transfer')\\n    bytes32 internal constant _OWNERSHIP_TRANSFER_SLOT =\\n        0x9855384122b55936fbfb8ca5120e63c6537a1ac40caf6ae33502b3c5da8c87d1;\\n\\n    /**\\n     * @notice Initializes the contract by transferring ownership to the owner parameter.\\n     * @param _owner Address to set as the initial owner of the contract\\n     */\\n    constructor(address _owner) {\\n        _transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @notice Modifier that throws an error if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) revert NotOwner();\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns the current owner of the contract.\\n     * @return owner_ The current owner of the contract\\n     */\\n    function owner() public view returns (address owner_) {\\n        assembly {\\n            owner_ := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the pending owner of the contract.\\n     * @return owner_ The pending owner of the contract\\n     */\\n    function pendingOwner() public view returns (address owner_) {\\n        assembly {\\n            owner_ := sload(_OWNERSHIP_TRANSFER_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account `newOwner`.\\n     * @dev Can only be called by the current owner.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function transferOwnership(address newOwner) external virtual onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Propose to transfer ownership of the contract to a new account `newOwner`.\\n     * @dev Can only be called by the current owner. The ownership does not change\\n     * until the new owner accepts the ownership transfer.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function proposeOwnership(address newOwner) external virtual onlyOwner {\\n        if (newOwner == address(0)) revert InvalidOwnerAddress();\\n\\n        emit OwnershipTransferStarted(newOwner);\\n\\n        assembly {\\n            sstore(_OWNERSHIP_TRANSFER_SLOT, newOwner)\\n        }\\n    }\\n\\n    /**\\n     * @notice Accepts ownership of the contract.\\n     * @dev Can only be called by the pending owner\\n     */\\n    function acceptOwnership() external virtual {\\n        address newOwner = pendingOwner();\\n        if (newOwner != msg.sender) revert InvalidOwner();\\n\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Internal function to transfer ownership of the contract to a new account `newOwner`.\\n     * @dev Called in the constructor to set the initial owner.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        if (newOwner == address(0)) revert InvalidOwnerAddress();\\n\\n        emit OwnershipTransferred(newOwner);\\n\\n        assembly {\\n            sstore(_OWNER_SLOT, newOwner)\\n            sstore(_OWNERSHIP_TRANSFER_SLOT, 0)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/deposit/DepositReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {ISquidDepositService} from \\\"../interfaces/ISquidDepositService.sol\\\";\\n\\ncontract DepositReceiver {\\n    constructor(bytes memory delegateData, address refundRecipient) {\\n        // Reading the implementation of the AxelarDepositService\\n        // and delegating the call back to it\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = ISquidDepositService(msg.sender).receiverImplementation().delegatecall(delegateData);\\n\\n        // if not success revert with the original revert data\\n        if (!success) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n\\n        if (refundRecipient == address(0)) refundRecipient = msg.sender;\\n\\n        selfdestruct(payable(refundRecipient));\\n    }\\n\\n    // @dev This function is for receiving Ether from unwrapping WETH9\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/deposit/ReceiverImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {IAxelarGateway} from \\\"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IAxelarGateway.sol\\\";\\nimport {ISquidRouter} from \\\"../interfaces/ISquidRouter.sol\\\";\\nimport {ISquidMulticall} from \\\"../interfaces/ISquidMulticall.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ISquidDepositService} from \\\"../interfaces/ISquidDepositService.sol\\\";\\n\\ncontract ReceiverImplementation {\\n    using SafeERC20 for IERC20;\\n\\n    error ZeroAddressProvided();\\n    error InvalidSymbol();\\n    error NothingDeposited();\\n\\n    address private constant nativeCoin = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address immutable router;\\n    address immutable gateway;\\n\\n    constructor(address _router, address _gateway) {\\n        if (_router == address(0) || _gateway == address(0)) revert ZeroAddressProvided();\\n\\n        router = _router;\\n        gateway = _gateway;\\n    }\\n\\n    // Context: msg.sender == SquidDepositService, this == DepositReceiver\\n    function receiveAndBridgeCall(\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool enableExpress\\n    ) external {\\n        // Checking with AxelarDepositService if need to refund a token\\n        address tokenToRefund = ISquidDepositService(msg.sender).refundToken();\\n        if (tokenToRefund != address(0)) {\\n            _refund(tokenToRefund, refundRecipient);\\n            return;\\n        }\\n\\n        address tokenAddress = IAxelarGateway(gateway).tokenAddresses(bridgedTokenSymbol);\\n        if (tokenAddress == address(0)) revert InvalidSymbol();\\n        uint256 amount = IERC20(tokenAddress).balanceOf(address(this));\\n        if (amount == 0) revert NothingDeposited();\\n\\n        IERC20(tokenAddress).approve(router, amount);\\n        ISquidRouter(router).bridgeCall{value: address(this).balance}(\\n            bridgedTokenSymbol,\\n            amount,\\n            destinationChain,\\n            destinationAddress,\\n            payload,\\n            refundRecipient,\\n            enableExpress\\n        );\\n    }\\n\\n    // Context: msg.sender == SquidDepositService, this == DepositReceiver\\n    function receiveAndCallBridge(\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        address refundRecipient\\n    ) external {\\n        // Checking with AxelarDepositService if need to refund a token\\n        address tokenToRefund = ISquidDepositService(msg.sender).refundToken();\\n        if (tokenToRefund != address(0)) {\\n            _refund(tokenToRefund, refundRecipient);\\n            return;\\n        }\\n\\n        uint256 amount = IERC20(token).balanceOf(address(this));\\n        if (amount == 0) revert NothingDeposited();\\n\\n        IERC20(token).approve(router, amount);\\n        ISquidRouter(router).callBridge{value: address(this).balance}(\\n            token,\\n            amount,\\n            calls,\\n            bridgedTokenSymbol,\\n            destinationChain,\\n            destinationAddress\\n        );\\n    }\\n\\n    function receiveAndCallBridgeCall(\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool enableExpress\\n    ) external {\\n        // Checking with AxelarDepositService if need to refund a token\\n        address tokenToRefund = ISquidDepositService(msg.sender).refundToken();\\n        if (tokenToRefund != address(0)) {\\n            _refund(tokenToRefund, refundRecipient);\\n            return;\\n        }\\n\\n        uint256 amount = IERC20(token).balanceOf(address(this));\\n        if (amount == 0) revert NothingDeposited();\\n\\n        IERC20(token).approve(router, amount);\\n        ISquidRouter(router).callBridgeCall{value: address(this).balance}(\\n            token,\\n            amount,\\n            calls,\\n            bridgedTokenSymbol,\\n            destinationChain,\\n            destinationAddress,\\n            payload,\\n            refundRecipient,\\n            enableExpress\\n        );\\n    }\\n\\n    function receiveAndFundAndRunMulticall(\\n        address token,\\n        ISquidMulticall.Call[] memory calls,\\n        address refundRecipient\\n    ) external {\\n        // Checking with AxelarDepositService if need to refund a token\\n        address tokenToRefund = ISquidDepositService(msg.sender).refundToken();\\n\\n        if (tokenToRefund != address(0)) {\\n            _refund(tokenToRefund, refundRecipient);\\n            return;\\n        }\\n\\n        uint256 amount = IERC20(token).balanceOf(address(this));\\n        if (amount == 0) revert NothingDeposited();\\n\\n        IERC20(token).approve(router, amount);\\n        ISquidRouter(router).fundAndRunMulticall{value: address(this).balance}(token, amount, calls);\\n    }\\n\\n    function _refund(address tokenToRefund, address refundRecipient) private {\\n        if (refundRecipient == address(0)) refundRecipient = msg.sender;\\n\\n        if (tokenToRefund != nativeCoin) {\\n            uint256 contractBalance = IERC20(tokenToRefund).balanceOf(address(this));\\n            IERC20(tokenToRefund).safeTransfer(refundRecipient, contractBalance);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/deposit/SquidDepositService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {ISquidDepositService} from \\\"../interfaces/ISquidDepositService.sol\\\";\\nimport {ISquidMulticall} from \\\"../interfaces/ISquidMulticall.sol\\\";\\nimport {IAxelarGateway} from \\\"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IAxelarGateway.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {Upgradable} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Upgradable.sol\\\";\\nimport {DepositReceiver} from \\\"./DepositReceiver.sol\\\";\\nimport {ReceiverImplementation} from \\\"./ReceiverImplementation.sol\\\";\\n\\n/// @dev This should be owned by the microservice that is paying for gas.\\ncontract SquidDepositService is Upgradable, ISquidDepositService {\\n    using SafeERC20 for IERC20;\\n\\n    // This public storage is for ERC20 token intended to be refunded.\\n    // It triggers the DepositReceiver/ReceiverImplementation to switch into a refund mode.\\n    // Address is stored and deleted withing the same refund transaction.\\n    address public refundToken;\\n\\n    address private constant nativeCoin = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address immutable gateway;\\n    address public immutable refundIssuer;\\n    address public immutable receiverImplementation;\\n\\n    constructor(address _router, address _gateway, address _refundIssuer) {\\n        if (_gateway == address(0) || _refundIssuer == address(0)) revert ZeroAddressProvided();\\n\\n        gateway = _gateway;\\n        refundIssuer = _refundIssuer;\\n        receiverImplementation = address(new ReceiverImplementation(_router, _gateway));\\n    }\\n\\n    function addressForBridgeCallDeposit(\\n        bytes32 salt,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool enableExpress\\n    ) external view returns (address) {\\n        return\\n            _depositAddress(\\n                salt,\\n                abi.encodeWithSelector(\\n                    ReceiverImplementation.receiveAndBridgeCall.selector,\\n                    bridgedTokenSymbol,\\n                    destinationChain,\\n                    destinationAddress,\\n                    payload,\\n                    refundRecipient,\\n                    enableExpress\\n                ),\\n                refundRecipient\\n            );\\n    }\\n\\n    function addressForCallBridgeDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        address refundRecipient\\n    ) external view returns (address) {\\n        return\\n            _depositAddress(\\n                salt,\\n                abi.encodeWithSelector(\\n                    ReceiverImplementation.receiveAndCallBridge.selector,\\n                    token,\\n                    calls,\\n                    bridgedTokenSymbol,\\n                    destinationChain,\\n                    destinationAddress,\\n                    refundRecipient\\n                ),\\n                refundRecipient\\n            );\\n    }\\n\\n    function addressForCallBridgeCallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool enableExpress\\n    ) external view returns (address) {\\n        return\\n            _depositAddress(\\n                salt,\\n                abi.encodeWithSelector(\\n                    ReceiverImplementation.receiveAndCallBridgeCall.selector,\\n                    token,\\n                    calls,\\n                    bridgedTokenSymbol,\\n                    destinationChain,\\n                    destinationAddress,\\n                    payload,\\n                    refundRecipient,\\n                    enableExpress\\n                ),\\n                refundRecipient\\n            );\\n    }\\n\\n    function addressForFundAndRunMulticallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] memory calls,\\n        address refundRecipient\\n    ) external view returns (address) {\\n        return\\n            _depositAddress(\\n                salt,\\n                abi.encodeWithSelector(\\n                    ReceiverImplementation.receiveAndFundAndRunMulticall.selector,\\n                    token,\\n                    calls,\\n                    refundRecipient\\n                ),\\n                refundRecipient\\n            );\\n    }\\n\\n    function bridgeCallDeposit(\\n        bytes32 salt,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool enableExpress\\n    ) external {\\n        new DepositReceiver{salt: salt}(\\n            abi.encodeWithSelector(\\n                ReceiverImplementation.receiveAndBridgeCall.selector,\\n                bridgedTokenSymbol,\\n                destinationChain,\\n                destinationAddress,\\n                payload,\\n                refundRecipient,\\n                enableExpress\\n            ),\\n            refundRecipient\\n        );\\n    }\\n\\n    function callBridgeDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        address refundRecipient\\n    ) external {\\n        new DepositReceiver{salt: salt}(\\n            abi.encodeWithSelector(\\n                ReceiverImplementation.receiveAndCallBridge.selector,\\n                token,\\n                calls,\\n                bridgedTokenSymbol,\\n                destinationChain,\\n                destinationAddress,\\n                refundRecipient\\n            ),\\n            refundRecipient\\n        );\\n    }\\n\\n    function callBridgeCallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool express\\n    ) external {\\n        new DepositReceiver{salt: salt}(\\n            abi.encodeWithSelector(\\n                ReceiverImplementation.receiveAndCallBridgeCall.selector,\\n                token,\\n                calls,\\n                bridgedTokenSymbol,\\n                destinationChain,\\n                destinationAddress,\\n                payload,\\n                refundRecipient,\\n                express\\n            ),\\n            refundRecipient\\n        );\\n    }\\n\\n    function fundAndRunMulticallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] memory calls,\\n        address refundRecipient\\n    ) external {\\n        // NOTE: `DepositReceiver` is destroyed in the same runtime context that it is deployed.\\n        new DepositReceiver{salt: salt}(\\n            abi.encodeWithSelector(\\n                ReceiverImplementation.receiveAndFundAndRunMulticall.selector,\\n                token,\\n                calls,\\n                refundRecipient\\n            ),\\n            refundRecipient\\n        );\\n    }\\n\\n    /// @dev Refunds ERC20 token from the deposit address if it doesn't match the intended token\\n    // Only refundRecipient can refund the token that was intended to go cross-chain (if not sent yet)\\n    function refundBridgeCallDeposit(\\n        bytes32 salt,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool express,\\n        address tokenToRefund\\n    ) external {\\n        address intendedToken = IAxelarGateway(gateway).tokenAddresses(bridgedTokenSymbol);\\n        // Allowing only the refundRecipient to refund the intended token\\n        if (tokenToRefund == intendedToken && msg.sender != refundRecipient) return;\\n\\n        // Saving to public storage to be accessed by the DepositReceiver\\n        refundToken = tokenToRefund;\\n\\n        new DepositReceiver{salt: salt}(\\n            abi.encodeWithSelector(\\n                ReceiverImplementation.receiveAndBridgeCall.selector,\\n                bridgedTokenSymbol,\\n                destinationChain,\\n                destinationAddress,\\n                payload,\\n                refundRecipient,\\n                express\\n            ),\\n            refundRecipient\\n        );\\n\\n        refundToken = address(0);\\n    }\\n\\n    function refundCallBridgeDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        address refundRecipient,\\n        address tokenToRefund\\n    ) external {\\n        // Allowing only the refundRecipient to refund the intended token\\n        if (tokenToRefund == token && msg.sender != refundRecipient) return;\\n\\n        // Saving to public storage to be accessed by the DepositReceiver\\n        refundToken = tokenToRefund;\\n        new DepositReceiver{salt: salt}(\\n            abi.encodeWithSelector(\\n                ReceiverImplementation.receiveAndCallBridge.selector,\\n                token,\\n                calls,\\n                bridgedTokenSymbol,\\n                destinationChain,\\n                destinationAddress,\\n                refundRecipient\\n            ),\\n            refundRecipient\\n        );\\n\\n        refundToken = address(0);\\n    }\\n\\n    function refundCallBridgeCallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool express,\\n        address tokenToRefund\\n    ) external {\\n        // Allowing only the refundRecipient to refund the intended token\\n        if (tokenToRefund == token && msg.sender != refundRecipient) return;\\n\\n        // Saving to public storage to be accessed by the DepositReceiver\\n        refundToken = tokenToRefund;\\n        new DepositReceiver{salt: salt}(\\n            abi.encodeWithSelector(\\n                ReceiverImplementation.receiveAndCallBridgeCall.selector,\\n                token,\\n                calls,\\n                bridgedTokenSymbol,\\n                destinationChain,\\n                destinationAddress,\\n                payload,\\n                refundRecipient,\\n                express\\n            ),\\n            refundRecipient\\n        );\\n\\n        refundToken = address(0);\\n    }\\n\\n    function refundFundAndRunMulticallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] memory calls,\\n        address refundRecipient,\\n        address tokenToRefund\\n    ) external {\\n        // Allowing only the refundRecipient to refund the intended token\\n        if (tokenToRefund == token && msg.sender != refundRecipient) return;\\n\\n        // Saving to public storage to be accessed by the DepositReceiver\\n        refundToken = tokenToRefund;\\n        new DepositReceiver{salt: salt}(\\n            abi.encodeWithSelector(\\n                ReceiverImplementation.receiveAndFundAndRunMulticall.selector,\\n                token,\\n                calls,\\n                refundRecipient\\n            ),\\n            refundRecipient\\n        );\\n\\n        refundToken = address(0);\\n    }\\n\\n    function refundLockedAsset(address receiver, address token, uint256 amount) external {\\n        if (msg.sender != refundIssuer) revert NotRefundIssuer();\\n        if (receiver == address(0)) revert ZeroAddressProvided();\\n\\n        if (token == nativeCoin) {\\n            (bool sent, ) = receiver.call{value: amount}(\\\"\\\");\\n            if (!sent) revert NativeTransferFailed();\\n        } else {\\n            IERC20(token).safeTransfer(receiver, amount);\\n        }\\n    }\\n\\n    function _depositAddress(\\n        bytes32 salt,\\n        bytes memory delegateData,\\n        address refundRecipient\\n    ) private view returns (address) {\\n        /* Convert a hash which is bytes32 to an address which is 20-byte long\\n        according to https://docs.soliditylang.org/en/v0.8.9/control-structures.html?highlight=create2#salted-contract-creations-create2 */\\n        return\\n            address(\\n                uint160(\\n                    uint256(\\n                        keccak256(\\n                            abi.encodePacked(\\n                                bytes1(0xff),\\n                                address(this),\\n                                salt,\\n                                // Encoding delegateData and refundRecipient as constructor params\\n                                keccak256(\\n                                    abi.encodePacked(\\n                                        type(DepositReceiver).creationCode,\\n                                        abi.encode(delegateData, refundRecipient)\\n                                    )\\n                                )\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    function contractId() external pure returns (bytes32) {\\n        return keccak256(\\\"squid-deposit-service\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    error InvalidAccount();\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRoledPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IRoledPausable {\\n    event PauserProposed(address indexed currentPauser, address indexed pendingPauser);\\n    event PauserUpdated(address indexed pendingPauser);\\n    event Paused();\\n    event Unpaused();\\n\\n    error ContractIsPaused();\\n    error NotPauser();\\n    error NotPendingPauser();\\n\\n    function updatePauser(address _newPauser) external;\\n\\n    function acceptPauser() external;\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    function paused() external view returns (bool value);\\n\\n    function pauser() external view returns (address value);\\n\\n    function pendingPauser() external view returns (address value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISquidDepositService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nimport {IUpgradable} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol\\\";\\nimport {ISquidMulticall} from \\\"./ISquidMulticall.sol\\\";\\n\\n// This should be owned by the microservice that is paying for gas.\\ninterface ISquidDepositService is IUpgradable {\\n    error ZeroAddressProvided();\\n    error NotRefundIssuer();\\n    error NativeTransferFailed();\\n\\n    function addressForBridgeCallDeposit(\\n        bytes32 salt,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool enableExpress\\n    ) external view returns (address);\\n\\n    function addressForCallBridgeDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        address refundRecipient\\n    ) external view returns (address);\\n\\n    function addressForCallBridgeCallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool enableExpress\\n    ) external view returns (address);\\n\\n    function addressForFundAndRunMulticallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] memory calls,\\n        address refundRecipient\\n    ) external view returns (address);\\n\\n    function bridgeCallDeposit(\\n        bytes32 salt,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool enableExpress\\n    ) external;\\n\\n    function callBridgeDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        address refundRecipient\\n    ) external;\\n\\n    function callBridgeCallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool express\\n    ) external;\\n\\n    function fundAndRunMulticallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] memory calls,\\n        address refundRecipient\\n    ) external;\\n\\n    function refundBridgeCallDeposit(\\n        bytes32 salt,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool express,\\n        address tokenToRefund\\n    ) external;\\n\\n    function refundCallBridgeDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        address refundRecipient,\\n        address tokenToRefund\\n    ) external;\\n\\n    function refundCallBridgeCallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundRecipient,\\n        bool express,\\n        address tokenToRefund\\n    ) external;\\n\\n    function refundFundAndRunMulticallDeposit(\\n        bytes32 salt,\\n        address token,\\n        ISquidMulticall.Call[] memory calls,\\n        address refundRecipient,\\n        address tokenToRefund\\n    ) external;\\n\\n    function refundLockedAsset(address receiver, address token, uint256 amount) external;\\n\\n    function receiverImplementation() external returns (address receiver);\\n\\n    function refundToken() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISquidFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ISquidFeeCollector {\\n    event FeeCollected(address token, address integrator, uint256 squidFee, uint256 integratorFee);\\n    event FeeWithdrawn(address token, address account, uint256 amount);\\n\\n    error TransferFailed();\\n    error ExcessiveIntegratorFee();\\n\\n    function collectFee(address token, uint256 amountToTax, address integratorAddress, uint256 integratorFee) external;\\n\\n    function withdrawFee(address token) external;\\n\\n    function getBalance(address token, address account) external view returns (uint256 accountBalance);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISquidMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ISquidMulticall {\\n    enum CallType {\\n        Default,\\n        FullTokenBalance,\\n        FullNativeBalance,\\n        CollectTokenBalance\\n    }\\n\\n    struct Call {\\n        CallType callType;\\n        address target;\\n        uint256 value;\\n        bytes callData;\\n        bytes payload;\\n    }\\n\\n    error AlreadyRunning();\\n    error CallFailed(uint256 callPosition, bytes reason);\\n\\n    function run(Call[] calldata calls) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISquidRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {ISquidMulticall} from \\\"./ISquidMulticall.sol\\\";\\n\\ninterface ISquidRouter {\\n    event CrossMulticallExecuted(bytes32 indexed payloadHash);\\n    event CrossMulticallFailed(bytes32 indexed payloadHash, bytes reason, address indexed refundRecipient);\\n\\n    error ZeroAddressProvided();\\n    error ApprovalFailed();\\n\\n    function bridgeCall(\\n        string calldata bridgedTokenSymbol,\\n        uint256 amount,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasRefundRecipient,\\n        bool enableExpress\\n    ) external payable;\\n\\n    function callBridge(\\n        address token,\\n        uint256 amount,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress\\n    ) external payable;\\n\\n    function callBridgeCall(\\n        address token,\\n        uint256 amount,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasRefundRecipient,\\n        bool enableExpress\\n    ) external payable;\\n\\n    function fundAndRunMulticall(address token, uint256 amount, ISquidMulticall.Call[] memory calls) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/kyberswap/IAggregationExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IAggregationExecutor {\\n    function callBytes(bytes calldata data) external payable; // 0xd9c45357\\n\\n    // callbytes per swap sequence\\n    function swapSingleSequence(bytes calldata data) external;\\n\\n    function finalTransactionProcessing(\\n        address tokenIn,\\n        address tokenOut,\\n        address to,\\n        bytes calldata destTokenFeeData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/kyberswap/IExecutorHelper1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IExecutorHelper1 {\\n    struct UniSwap {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        address recipient;\\n        uint256 collectAmount; // amount that should be transferred to the pool\\n        uint256 limitReturnAmount;\\n        uint32 swapFee;\\n        uint32 feePrecision;\\n        uint32 tokenWeightInput;\\n    }\\n\\n    struct StableSwap {\\n        address pool;\\n        address tokenFrom;\\n        address tokenTo;\\n        uint8 tokenIndexFrom;\\n        uint8 tokenIndexTo;\\n        uint256 dx;\\n        uint256 minDy;\\n        uint256 poolLength;\\n        address poolLp;\\n        bool isSaddle; // true: saddle, false: stable\\n    }\\n\\n    struct CurveSwap {\\n        address pool;\\n        address tokenFrom;\\n        address tokenTo;\\n        int128 tokenIndexFrom;\\n        int128 tokenIndexTo;\\n        uint256 dx;\\n        uint256 minDy;\\n        bool usePoolUnderlying;\\n        bool useTriCrypto;\\n    }\\n\\n    struct UniSwapV3ProMM {\\n        address recipient;\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 swapAmount;\\n        uint256 limitReturnAmount;\\n        uint160 sqrtPriceLimitX96;\\n        bool isUniV3; // true = UniV3, false = ProMM\\n    }\\n\\n    struct SwapCallbackData {\\n        bytes path;\\n        address payer;\\n    }\\n\\n    struct SwapCallbackDataPath {\\n        address pool;\\n        address tokenIn;\\n        address tokenOut;\\n    }\\n\\n    struct BalancerV2 {\\n        address vault;\\n        bytes32 poolId;\\n        address assetIn;\\n        address assetOut;\\n        uint256 amount;\\n        uint256 limit;\\n    }\\n\\n    struct KyberRFQ {\\n        address rfq;\\n        bytes order;\\n        bytes signature;\\n        uint256 amount;\\n        address payable target;\\n    }\\n\\n    struct DODO {\\n        address recipient;\\n        address pool;\\n        address tokenFrom;\\n        address tokenTo;\\n        uint256 amount;\\n        uint256 minReceiveQuote;\\n        address sellHelper;\\n        bool isSellBase;\\n        bool isVersion2;\\n    }\\n\\n    struct GMX {\\n        address vault;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amount;\\n        uint256 minOut;\\n        address receiver;\\n    }\\n\\n    struct Synthetix {\\n        address synthetixProxy;\\n        address tokenIn;\\n        address tokenOut;\\n        bytes32 sourceCurrencyKey;\\n        uint256 sourceAmount;\\n        bytes32 destinationCurrencyKey;\\n        uint256 minAmount;\\n        bool useAtomicExchange;\\n    }\\n\\n    function executeUniSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeStableSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeCurveSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeKyberDMMSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeUniV3ProMMSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeRfqSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeBalV2Swap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeDODOSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeVelodromeSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeGMXSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeSynthetixSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeHashflowSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n\\n    function executeCamelotSwap(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/kyberswap/IExecutorHelper2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IExecutorHelper2 {\\n    function executeKyberLimitOrder(\\n        uint256 index,\\n        bytes memory data,\\n        uint256 previousAmountOut\\n    ) external payable returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/kyberswap/IMetaAggregationRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IAggregationExecutor} from \\\"./IAggregationExecutor.sol\\\";\\n\\ninterface IMetaAggregationRouter {\\n    struct SwapDescription {\\n        IERC20 srcToken;\\n        IERC20 dstToken;\\n        address[] srcReceivers;\\n        uint256[] srcAmounts;\\n        address dstReceiver;\\n        uint256 amount;\\n        uint256 minReturnAmount;\\n        uint256 flags;\\n        bytes permit;\\n    }\\n\\n    function swap(\\n        IAggregationExecutor caller,\\n        SwapDescription calldata desc,\\n        bytes calldata executorData,\\n        bytes calldata clientData\\n    ) external payable returns (uint256, uint256);\\n\\n    function swapSimpleMode(\\n        IAggregationExecutor caller,\\n        SwapDescription calldata desc,\\n        bytes calldata executorData,\\n        bytes calldata clientData\\n    ) external returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/kyberswap/IMetaAggregationRouterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IAggregationExecutor} from \\\"./IAggregationExecutor.sol\\\";\\n\\ninterface IMetaAggregationRouterV2 {\\n    struct SwapDescriptionV2 {\\n        IERC20 srcToken;\\n        IERC20 dstToken;\\n        address[] srcReceivers; // transfer src token to these addresses, default\\n        uint256[] srcAmounts;\\n        address[] feeReceivers;\\n        uint256[] feeAmounts;\\n        address dstReceiver;\\n        uint256 amount;\\n        uint256 minReturnAmount;\\n        uint256 flags;\\n        bytes permit;\\n    }\\n\\n    /// @dev  use for swapGeneric and swap to avoid stack too deep\\n    struct SwapExecutionParams {\\n        address callTarget; // call this address\\n        address approveTarget; // approve this address if _APPROVE_FUND set\\n        bytes targetData;\\n        SwapDescriptionV2 desc;\\n        bytes clientData;\\n    }\\n\\n    function swap(SwapExecutionParams calldata execution) external payable returns (uint256, uint256);\\n\\n    function swapSimpleMode(\\n        IAggregationExecutor caller,\\n        SwapDescriptionV2 memory desc,\\n        bytes calldata executorData,\\n        bytes calldata clientData\\n    ) external returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/kyberswap/ScaleDataHelper1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {IExecutorHelper1} from \\\"../../interfaces/kyberswap/IExecutorHelper1.sol\\\";\\n\\nlibrary ScaleDataHelper1 {\\n    function newUniSwap(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper1.UniSwap memory uniSwap = abi.decode(data, (IExecutorHelper1.UniSwap));\\n        uniSwap.collectAmount = (uniSwap.collectAmount * newAmount) / oldAmount;\\n        return abi.encode(uniSwap);\\n    }\\n\\n    function newStableSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper1.StableSwap memory stableSwap = abi.decode(data, (IExecutorHelper1.StableSwap));\\n        stableSwap.dx = (stableSwap.dx * newAmount) / oldAmount;\\n        return abi.encode(stableSwap);\\n    }\\n\\n    function newCurveSwap(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper1.CurveSwap memory curveSwap = abi.decode(data, (IExecutorHelper1.CurveSwap));\\n        curveSwap.dx = (curveSwap.dx * newAmount) / oldAmount;\\n        return abi.encode(curveSwap);\\n    }\\n\\n    function newKyberDMM(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper1.UniSwap memory kyberDMMSwap = abi.decode(data, (IExecutorHelper1.UniSwap));\\n        kyberDMMSwap.collectAmount = (kyberDMMSwap.collectAmount * newAmount) / oldAmount;\\n        return abi.encode(kyberDMMSwap);\\n    }\\n\\n    function newUniV3ProMM(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper1.UniSwapV3ProMM memory uniSwapV3ProMM = abi.decode(data, (IExecutorHelper1.UniSwapV3ProMM));\\n        uniSwapV3ProMM.swapAmount = (uniSwapV3ProMM.swapAmount * newAmount) / oldAmount;\\n\\n        return abi.encode(uniSwapV3ProMM);\\n    }\\n\\n    function newBalancerV2(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper1.BalancerV2 memory balancerV2 = abi.decode(data, (IExecutorHelper1.BalancerV2));\\n        balancerV2.amount = (balancerV2.amount * newAmount) / oldAmount;\\n        return abi.encode(balancerV2);\\n    }\\n\\n    function newDODO(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper1.DODO memory dodo = abi.decode(data, (IExecutorHelper1.DODO));\\n        dodo.amount = (dodo.amount * newAmount) / oldAmount;\\n        return abi.encode(dodo);\\n    }\\n\\n    function newVelodrome(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper1.UniSwap memory velodrome = abi.decode(data, (IExecutorHelper1.UniSwap));\\n        velodrome.collectAmount = (velodrome.collectAmount * newAmount) / oldAmount;\\n        return abi.encode(velodrome);\\n    }\\n\\n    function newGMX(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper1.GMX memory gmx = abi.decode(data, (IExecutorHelper1.GMX));\\n        gmx.amount = (gmx.amount * newAmount) / oldAmount;\\n        return abi.encode(gmx);\\n    }\\n\\n    function newSynthetix(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        IExecutorHelper1.Synthetix memory synthetix = abi.decode(data, (IExecutorHelper1.Synthetix));\\n        synthetix.sourceAmount = (synthetix.sourceAmount * newAmount) / oldAmount;\\n        return abi.encode(synthetix);\\n    }\\n\\n    function newCamelot(bytes memory data, uint256 oldAmount, uint256 newAmount) internal pure returns (bytes memory) {\\n        IExecutorHelper1.UniSwap memory camelot = abi.decode(data, (IExecutorHelper1.UniSwap));\\n        camelot.collectAmount = (camelot.collectAmount * newAmount) / oldAmount;\\n        return abi.encode(camelot);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/RoledPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IRoledPausable} from \\\"../interfaces/IRoledPausable.sol\\\";\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\n\\nabstract contract RoledPausable is IRoledPausable {\\n    using StorageSlot for bytes32;\\n\\n    bytes32 internal constant PAUSED_SLOT = keccak256(\\\"RoledPausable.paused\\\");\\n    bytes32 internal constant PAUSER_SLOT = keccak256(\\\"RoledPausable.pauser\\\");\\n    bytes32 internal constant PENDING_PAUSER_SLOT = keccak256(\\\"RoledPausable.pendingPauser\\\");\\n\\n    modifier whenNotPaused() {\\n        if (paused()) revert ContractIsPaused();\\n        _;\\n    }\\n\\n    modifier onlyPauser() {\\n        if (msg.sender != pauser()) revert NotPauser();\\n        _;\\n    }\\n\\n    constructor() {\\n        _setPauser(msg.sender);\\n    }\\n\\n    function updatePauser(address newPauser) external onlyPauser {\\n        PENDING_PAUSER_SLOT.setAddress(newPauser);\\n        emit PauserProposed(msg.sender, newPauser);\\n    }\\n\\n    function acceptPauser() external {\\n        if (msg.sender != pendingPauser()) revert NotPendingPauser();\\n        _setPauser(msg.sender);\\n        PENDING_PAUSER_SLOT.setAddress(address(0));\\n    }\\n\\n    function pause() external virtual onlyPauser {\\n        PAUSED_SLOT.setBool(true);\\n        emit Paused();\\n    }\\n\\n    function unpause() external virtual onlyPauser {\\n        PAUSED_SLOT.setBool(false);\\n        emit Unpaused();\\n    }\\n\\n    function pauser() public view returns (address value) {\\n        value = PAUSER_SLOT.getAddress();\\n    }\\n\\n    function paused() public view returns (bool value) {\\n        value = PAUSED_SLOT.getBool();\\n    }\\n\\n    function pendingPauser() public view returns (address value) {\\n        value = PENDING_PAUSER_SLOT.getAddress();\\n    }\\n\\n    function _setPauser(address _pauser) internal {\\n        PAUSER_SLOT.setAddress(_pauser);\\n        emit PauserUpdated(_pauser);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nlibrary StorageSlot {\\n    function setUint256(bytes32 slot, uint256 value) internal {\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function getUint256(bytes32 slot) internal view returns (uint256 value) {\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function setAddress(bytes32 slot, address value) internal {\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function getAddress(bytes32 slot) internal view returns (address value) {\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function setBool(bytes32 slot, bool value) internal {\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function getBool(bytes32 slot) internal view returns (bool value) {\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/patcher/KyberswapPatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IExecutorHelper1} from \\\"../interfaces/kyberswap/IExecutorHelper1.sol\\\";\\nimport {IExecutorHelper2} from \\\"../interfaces/kyberswap/IExecutorHelper2.sol\\\";\\nimport {IMetaAggregationRouterV2} from \\\"../interfaces/kyberswap/IMetaAggregationRouterV2.sol\\\";\\nimport {IMetaAggregationRouter} from \\\"../interfaces/kyberswap/IMetaAggregationRouter.sol\\\";\\nimport {ScaleDataHelper1} from \\\"../libraries/kyberswap/ScaleDataHelper1.sol\\\";\\n\\ncontract KyberswapPatcher {\\n    uint256 private constant _PARTIAL_FILL = 0x01;\\n    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;\\n    uint256 private constant _SHOULD_CLAIM = 0x04;\\n    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;\\n    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;\\n    uint256 private constant _SIMPLE_SWAP = 0x20;\\n\\n    struct Swap {\\n        bytes data;\\n        bytes4 functionSelector;\\n    }\\n\\n    struct SimpleSwapData {\\n        address[] firstPools;\\n        uint256[] firstSwapAmounts;\\n        bytes[] swapDatas;\\n        uint256 deadline;\\n        bytes destTokenFeeData;\\n    }\\n\\n    struct SwapExecutorDescription {\\n        Swap[][] swapSequences;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 minTotalAmountOut;\\n        address to;\\n        uint256 deadline;\\n        bytes destTokenFeeData;\\n    }\\n\\n    struct Data {\\n        address router;\\n        bytes inputData;\\n        uint256 newAmount;\\n    }\\n\\n    error CallFailed(string message, bytes reason);\\n\\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n        if (value == 0) return;\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)\\n        );\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"safeTransferFrom: Transfer from fail\\\");\\n    }\\n\\n    function safeApprove(address token, address to, uint256 value) internal {\\n        if (value == 0) return;\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"safeApprove: Approve fail\\\");\\n    }\\n\\n    function scaleAndSwap(uint256 newAmount, address router, bytes calldata inputData) external payable {\\n        bytes4 selector = bytes4(inputData[:4]);\\n        bytes memory dataToDecode = new bytes(inputData.length - 4);\\n        bytes memory callData;\\n\\n        for (uint256 i = 0; i < inputData.length - 4; ++i) {\\n            dataToDecode[i] = inputData[i + 4];\\n        }\\n\\n        if (\\n            selector == IMetaAggregationRouter.swap.selector ||\\n            selector == IMetaAggregationRouter.swapSimpleMode.selector\\n        ) {\\n            (\\n                address callTarget,\\n                IMetaAggregationRouter.SwapDescription memory desc,\\n                bytes memory targetData,\\n                bytes memory clientData\\n            ) = abi.decode(dataToDecode, (address, IMetaAggregationRouter.SwapDescription, bytes, bytes));\\n\\n            (desc, targetData) = _getScaledInputDataV1(\\n                desc,\\n                targetData,\\n                newAmount,\\n                selector == IMetaAggregationRouter.swapSimpleMode.selector || _flagsChecked(desc.flags, _SIMPLE_SWAP)\\n            );\\n            callData = abi.encodeWithSelector(selector, callTarget, desc, targetData, clientData);\\n\\n            safeTransferFrom(address(desc.srcToken), msg.sender, address(this), newAmount);\\n            safeApprove(address(desc.srcToken), router, newAmount);\\n        } else if (selector == IMetaAggregationRouterV2.swap.selector) {\\n            IMetaAggregationRouterV2.SwapExecutionParams memory params = abi.decode(\\n                dataToDecode,\\n                (IMetaAggregationRouterV2.SwapExecutionParams)\\n            );\\n\\n            (params.desc, params.targetData) = _getScaledInputDataV2(\\n                params.desc,\\n                params.targetData,\\n                newAmount,\\n                _flagsChecked(params.desc.flags, _SIMPLE_SWAP)\\n            );\\n            callData = abi.encodeWithSelector(selector, params);\\n\\n            safeTransferFrom(address(params.desc.srcToken), msg.sender, address(this), newAmount);\\n            safeApprove(address(params.desc.srcToken), router, newAmount);\\n        } else if (selector == IMetaAggregationRouterV2.swapSimpleMode.selector) {\\n            (\\n                address callTarget,\\n                IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\\n                bytes memory targetData,\\n                bytes memory clientData\\n            ) = abi.decode(dataToDecode, (address, IMetaAggregationRouterV2.SwapDescriptionV2, bytes, bytes));\\n\\n            (desc, targetData) = _getScaledInputDataV2(desc, targetData, newAmount, true);\\n            callData = abi.encodeWithSelector(selector, callTarget, desc, targetData, clientData);\\n\\n            safeTransferFrom(address(desc.srcToken), msg.sender, address(this), newAmount);\\n            safeApprove(address(desc.srcToken), router, newAmount);\\n        } else revert(\\\"KyberswapPatcher: Invalid selector\\\");\\n\\n        (bool success, bytes memory data) = router.call(callData);\\n        if (!success) revert CallFailed(\\\"KyberswapPatcher: call failed\\\", data);\\n    }\\n\\n    function _getScaledInputDataV1(\\n        IMetaAggregationRouter.SwapDescription memory desc,\\n        bytes memory executorData,\\n        uint256 newAmount,\\n        bool isSimpleMode\\n    ) internal pure returns (IMetaAggregationRouter.SwapDescription memory, bytes memory) {\\n        uint256 oldAmount = desc.amount;\\n        if (oldAmount == newAmount) {\\n            return (desc, executorData);\\n        }\\n\\n        // simple mode swap\\n        if (isSimpleMode) {\\n            return (\\n                _scaledSwapDescriptionV1(desc, oldAmount, newAmount),\\n                _scaledSimpleSwapData(executorData, oldAmount, newAmount)\\n            );\\n        }\\n\\n        //normal mode swap\\n        return (\\n            _scaledSwapDescriptionV1(desc, oldAmount, newAmount),\\n            _scaledExecutorCallBytesData(executorData, oldAmount, newAmount)\\n        );\\n    }\\n\\n    function _getScaledInputDataV2(\\n        IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\\n        bytes memory executorData,\\n        uint256 newAmount,\\n        bool isSimpleMode\\n    ) internal pure returns (IMetaAggregationRouterV2.SwapDescriptionV2 memory, bytes memory) {\\n        uint256 oldAmount = desc.amount;\\n        if (oldAmount == newAmount) {\\n            return (desc, executorData);\\n        }\\n\\n        // simple mode swap\\n        if (isSimpleMode) {\\n            return (\\n                _scaledSwapDescriptionV2(desc, oldAmount, newAmount),\\n                _scaledSimpleSwapData(executorData, oldAmount, newAmount)\\n            );\\n        }\\n\\n        //normal mode swap\\n        return (\\n            _scaledSwapDescriptionV2(desc, oldAmount, newAmount),\\n            _scaledExecutorCallBytesData(executorData, oldAmount, newAmount)\\n        );\\n    }\\n\\n    function _scaledSwapDescriptionV1(\\n        IMetaAggregationRouter.SwapDescription memory desc,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (IMetaAggregationRouter.SwapDescription memory) {\\n        desc.minReturnAmount = (desc.minReturnAmount * newAmount) / oldAmount;\\n        if (desc.minReturnAmount == 0) desc.minReturnAmount = 1;\\n        desc.amount = newAmount;\\n        for (uint256 i = 0; i < desc.srcReceivers.length; i++) {\\n            desc.srcAmounts[i] = (desc.srcAmounts[i] * newAmount) / oldAmount;\\n        }\\n        return desc;\\n    }\\n\\n    function _scaledSwapDescriptionV2(\\n        IMetaAggregationRouterV2.SwapDescriptionV2 memory desc,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (IMetaAggregationRouterV2.SwapDescriptionV2 memory) {\\n        desc.minReturnAmount = (desc.minReturnAmount * newAmount) / oldAmount;\\n        if (desc.minReturnAmount == 0) desc.minReturnAmount = 1;\\n        desc.amount = newAmount;\\n        for (uint256 i = 0; i < desc.srcReceivers.length; i++) {\\n            desc.srcAmounts[i] = (desc.srcAmounts[i] * newAmount) / oldAmount;\\n        }\\n        return desc;\\n    }\\n\\n    function _scaledSimpleSwapData(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        SimpleSwapData memory swapData = abi.decode(data, (SimpleSwapData));\\n        for (uint256 i = 0; i < swapData.firstPools.length; i++) {\\n            swapData.firstSwapAmounts[i] = (swapData.firstSwapAmounts[i] * newAmount) / oldAmount;\\n        }\\n        return abi.encode(swapData);\\n    }\\n\\n    function _scaledExecutorCallBytesData(\\n        bytes memory data,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    ) internal pure returns (bytes memory) {\\n        SwapExecutorDescription memory executorDesc = abi.decode(data, (SwapExecutorDescription));\\n        executorDesc.minTotalAmountOut = (executorDesc.minTotalAmountOut * newAmount) / oldAmount;\\n        for (uint256 i = 0; i < executorDesc.swapSequences.length; i++) {\\n            Swap memory swap = executorDesc.swapSequences[i][0];\\n            bytes4 functionSelector = swap.functionSelector;\\n\\n            if (functionSelector == IExecutorHelper1.executeUniSwap.selector) {\\n                swap.data = ScaleDataHelper1.newUniSwap(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper1.executeStableSwap.selector) {\\n                swap.data = ScaleDataHelper1.newStableSwap(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper1.executeCurveSwap.selector) {\\n                swap.data = ScaleDataHelper1.newCurveSwap(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper1.executeKyberDMMSwap.selector) {\\n                swap.data = ScaleDataHelper1.newKyberDMM(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper1.executeUniV3ProMMSwap.selector) {\\n                swap.data = ScaleDataHelper1.newUniV3ProMM(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper1.executeRfqSwap.selector) {\\n                revert(\\\"KyberswapPatcher: Can not scale RFQ swap\\\");\\n            } else if (functionSelector == IExecutorHelper1.executeBalV2Swap.selector) {\\n                swap.data = ScaleDataHelper1.newBalancerV2(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper1.executeDODOSwap.selector) {\\n                swap.data = ScaleDataHelper1.newDODO(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper1.executeVelodromeSwap.selector) {\\n                swap.data = ScaleDataHelper1.newVelodrome(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper1.executeGMXSwap.selector) {\\n                swap.data = ScaleDataHelper1.newGMX(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper1.executeSynthetixSwap.selector) {\\n                swap.data = ScaleDataHelper1.newSynthetix(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper1.executeHashflowSwap.selector) {\\n                revert(\\\"KyberswapPatcher: Can not scale RFQ swap\\\");\\n            } else if (functionSelector == IExecutorHelper1.executeCamelotSwap.selector) {\\n                swap.data = ScaleDataHelper1.newCamelot(swap.data, oldAmount, newAmount);\\n            } else if (functionSelector == IExecutorHelper2.executeKyberLimitOrder.selector) {\\n                revert(\\\"KyberswapPatcher: Can not scale RFQ swap\\\");\\n            } else revert(\\\"AggregationExecutor: Dex type not supported\\\");\\n        }\\n        return abi.encode(executorDesc);\\n    }\\n\\n    function _flagsChecked(uint256 number, uint256 flag) internal pure returns (bool) {\\n        return number & flag != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/SquidFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {Upgradable} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Upgradable.sol\\\";\\nimport {ISquidFeeCollector} from \\\"../interfaces/ISquidFeeCollector.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract SquidFeeCollector is ISquidFeeCollector, Upgradable {\\n    bytes32 private constant BALANCES_PREFIX = keccak256(\\\"SquidFeeCollector.balances\\\");\\n    bytes32 private constant SPECIFIC_FEES_PREFIX = keccak256(\\\"SquidFeeCollector.specificFees\\\");\\n    address public immutable squidTeam;\\n    // Value expected with 2 decimals\\n    /// eg. 825 is 8.25%\\n    uint256 public immutable squidDefaultFee;\\n\\n    error ZeroAddressProvided();\\n\\n    constructor(address _squidTeam, uint256 _squidDefaultFee) {\\n        if (_squidTeam == address(0)) revert ZeroAddressProvided();\\n\\n        squidTeam = _squidTeam;\\n        squidDefaultFee = _squidDefaultFee;\\n    }\\n\\n    /// @param integratorFee Value expected with 2 decimals\\n    /// eg. 825 is 8.25%\\n    function collectFee(address token, uint256 amountToTax, address integratorAddress, uint256 integratorFee) external {\\n        if (integratorFee > 1000) revert ExcessiveIntegratorFee();\\n\\n        uint256 specificFee = getSpecificFee(integratorAddress);\\n        uint256 squidFee = specificFee == 0 ? squidDefaultFee : specificFee;\\n\\n        uint256 baseFeeAmount = (amountToTax * integratorFee) / 10000;\\n        uint256 squidFeeAmount = (baseFeeAmount * squidFee) / 10000;\\n        uint256 integratorFeeAmount = baseFeeAmount - squidFeeAmount;\\n\\n        _safeTransferFrom(token, msg.sender, baseFeeAmount);\\n        _setBalance(token, squidTeam, getBalance(token, squidTeam) + squidFeeAmount);\\n        _setBalance(token, integratorAddress, getBalance(token, integratorAddress) + integratorFeeAmount);\\n\\n        emit FeeCollected(token, integratorAddress, squidFeeAmount, integratorFeeAmount);\\n    }\\n\\n    function withdrawFee(address token) external {\\n        uint256 balance = getBalance(token, msg.sender);\\n        _setBalance(token, msg.sender, 0);\\n        _safeTransfer(token, msg.sender, balance);\\n\\n        emit FeeWithdrawn(token, msg.sender, balance);\\n    }\\n\\n    function setSpecificFee(address integrator, uint256 fee) external onlyOwner {\\n        bytes32 slot = _computeSpecificFeeSlot(integrator);\\n        assembly {\\n            sstore(slot, fee)\\n        }\\n    }\\n\\n    function getBalance(address token, address account) public view returns (uint256 value) {\\n        bytes32 slot = _computeBalanceSlot(token, account);\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function getSpecificFee(address integrator) public view returns (uint256 value) {\\n        bytes32 slot = _computeSpecificFeeSlot(integrator);\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function contractId() external pure returns (bytes32 id) {\\n        id = keccak256(\\\"squid-fee-collector\\\");\\n    }\\n\\n    function _setBalance(address token, address account, uint256 amount) private {\\n        bytes32 slot = _computeBalanceSlot(token, account);\\n        assembly {\\n            sstore(slot, amount)\\n        }\\n    }\\n\\n    function _computeBalanceSlot(address token, address account) private pure returns (bytes32 slot) {\\n        slot = keccak256(abi.encodePacked(BALANCES_PREFIX, token, account));\\n    }\\n\\n    function _computeSpecificFeeSlot(address integrator) private pure returns (bytes32 slot) {\\n        slot = keccak256(abi.encodePacked(SPECIFIC_FEES_PREFIX, integrator));\\n    }\\n\\n    function _safeTransferFrom(address token, address from, uint256 amount) internal {\\n        (bool success, bytes memory returnData) = token.call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n        if (!transferred || token.code.length == 0) revert TransferFailed();\\n    }\\n\\n    function _safeTransfer(address token, address to, uint256 amount) internal {\\n        (bool success, bytes memory returnData) = token.call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n        if (!transferred || token.code.length == 0) revert TransferFailed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/SquidFeeCollectorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {InitProxy} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/InitProxy.sol\\\";\\n\\ncontract SquidFeeCollectorProxy is InitProxy {\\n    function contractId() internal pure override returns (bytes32 id) {\\n        id = keccak256(\\\"squid-fee-collector\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/SquidMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {ISquidMulticall} from \\\"../interfaces/ISquidMulticall.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport {IERC1155Receiver} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\n\\ncontract SquidMulticall is ISquidMulticall, IERC721Receiver, IERC1155Receiver {\\n    bytes4 private constant ERC165_INTERFACE_ID = 0x01ffc9a7;\\n    bytes4 private constant ERC721_TOKENRECEIVER_INTERFACE_ID = 0x150b7a02;\\n    bytes4 private constant ERC1155_TOKENRECEIVER_INTERFACE_ID = 0x4e2312e0;\\n\\n    bool private isRunning;\\n\\n    error TransferFailed();\\n\\n    function run(Call[] calldata calls) external payable {\\n        // Prevents reentrancy\\n        if (isRunning) revert AlreadyRunning();\\n        isRunning = true;\\n\\n        for (uint256 i = 0; i < calls.length; i++) {\\n            Call memory call = calls[i];\\n\\n            if (call.callType == CallType.FullTokenBalance) {\\n                (address token, uint256 amountParameterPosition) = abi.decode(call.payload, (address, uint256));\\n                uint256 amount = IERC20(token).balanceOf(address(this));\\n                _setCallDataParameter(call.callData, amountParameterPosition, amount);\\n            } else if (call.callType == CallType.FullNativeBalance) {\\n                call.value = address(this).balance;\\n            } else if (call.callType == CallType.CollectTokenBalance) {\\n                address token = abi.decode(call.payload, (address));\\n                _safeTransferFrom(token, msg.sender, IERC20(token).balanceOf(msg.sender));\\n                continue;\\n            }\\n\\n            (bool success, bytes memory data) = call.target.call{value: call.value}(call.callData);\\n            if (!success) revert CallFailed(i, data);\\n        }\\n\\n        isRunning = false;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\\n        return\\n            interfaceId == ERC1155_TOKENRECEIVER_INTERFACE_ID ||\\n            interfaceId == ERC721_TOKENRECEIVER_INTERFACE_ID ||\\n            interfaceId == ERC165_INTERFACE_ID;\\n    }\\n\\n    function _safeTransferFrom(address token, address from, uint256 amount) private {\\n        (bool success, bytes memory returnData) = token.call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n        if (!transferred || token.code.length == 0) revert TransferFailed();\\n    }\\n\\n    function _setCallDataParameter(bytes memory callData, uint256 parameterPosition, uint256 value) private pure {\\n        assembly {\\n            // 36 bytes shift because 32 for prefix + 4 for selector\\n            mstore(add(callData, add(36, mul(parameterPosition, 32))), value)\\n        }\\n    }\\n\\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\\n        return IERC1155Receiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external pure returns (bytes4) {\\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\\n    }\\n\\n    // Required to enable ETH reception with .transfer or .send\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/router/SquidRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {ISquidRouter} from \\\"../interfaces/ISquidRouter.sol\\\";\\nimport {ISquidMulticall} from \\\"../interfaces/ISquidMulticall.sol\\\";\\nimport {AxelarExpressExecutable} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/express/AxelarExpressExecutable.sol\\\";\\nimport {IAxelarGasService} from \\\"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IAxelarGasService.sol\\\";\\nimport {IAxelarGateway} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\\\";\\nimport {IERC20} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol\\\";\\nimport {SafeTokenTransfer, SafeTokenTransferFrom, TokenTransferFailed} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/libs/SafeTransfer.sol\\\";\\nimport {Upgradable} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Upgradable.sol\\\";\\nimport {RoledPausable} from \\\"../libraries/RoledPausable.sol\\\";\\n\\ncontract SquidRouter is ISquidRouter, AxelarExpressExecutable, Upgradable, RoledPausable {\\n    using SafeTokenTransferFrom for IERC20;\\n    using SafeTokenTransfer for IERC20;\\n\\n    IAxelarGasService private immutable gasService;\\n    ISquidMulticall private immutable squidMulticall;\\n\\n    constructor(\\n        address _gateway,\\n        address _gasService,\\n        address _multicall\\n    ) AxelarExpressExecutable(_gateway) {\\n        if (\\n            _gateway == address(0) ||\\n            _gasService == address(0) ||\\n            _multicall == address(0)\\n        ) revert ZeroAddressProvided();\\n\\n        gasService = IAxelarGasService(_gasService);\\n        squidMulticall = ISquidMulticall(_multicall);\\n    }\\n\\n    function bridgeCall(\\n        string calldata bridgedTokenSymbol,\\n        uint256 amount,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasRefundRecipient,\\n        bool enableExpress\\n    ) external payable whenNotPaused {\\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\\n\\n        IERC20(bridgedTokenAddress).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        _bridgeCall(\\n            bridgedTokenSymbol,\\n            bridgedTokenAddress,\\n            destinationChain,\\n            destinationAddress,\\n            payload,\\n            gasRefundRecipient,\\n            enableExpress\\n        );\\n    }\\n\\n    function callBridge(\\n        address token,\\n        uint256 amount,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress\\n    ) external payable whenNotPaused {\\n        fundAndRunMulticall(token, amount, calls);\\n\\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\\n        uint256 bridgedTokenAmount = IERC20(bridgedTokenAddress).balanceOf(address(this));\\n\\n        _approve(bridgedTokenAddress, address(gateway), bridgedTokenAmount);\\n        gateway.sendToken(destinationChain, destinationAddress, bridgedTokenSymbol, bridgedTokenAmount);\\n    }\\n\\n    function callBridgeCall(\\n        address token,\\n        uint256 amount,\\n        ISquidMulticall.Call[] calldata calls,\\n        string calldata bridgedTokenSymbol,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasRefundRecipient,\\n        bool enableExpress\\n    ) external payable whenNotPaused {\\n        fundAndRunMulticall(token, amount, calls);\\n\\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\\n\\n        _bridgeCall(\\n            bridgedTokenSymbol,\\n            bridgedTokenAddress,\\n            destinationChain,\\n            destinationAddress,\\n            payload,\\n            gasRefundRecipient,\\n            enableExpress\\n        );\\n    }\\n\\n    function contractId() external pure override returns (bytes32 id) {\\n        id = keccak256(\\\"squid-router\\\");\\n    }\\n\\n    function fundAndRunMulticall(\\n        address token,\\n        uint256 amount,\\n        ISquidMulticall.Call[] memory calls\\n    ) public payable whenNotPaused {\\n        uint256 valueToSend;\\n\\n        if (token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\n            valueToSend = amount;\\n        } else {\\n            _transferTokenToMulticall(token, amount);\\n        }\\n\\n        squidMulticall.run{value: valueToSend}(calls);\\n    }\\n\\n    function _executeWithToken(\\n        string calldata,\\n        string calldata,\\n        bytes calldata payload,\\n        string calldata bridgedTokenSymbol,\\n        uint256\\n    ) internal override {\\n        (ISquidMulticall.Call[] memory calls, address refundRecipient) = abi.decode(\\n            payload,\\n            (ISquidMulticall.Call[], address)\\n        );\\n\\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\\n        uint256 contractBalance = IERC20(bridgedTokenAddress).balanceOf(address(this));\\n\\n        _approve(bridgedTokenAddress, address(squidMulticall), contractBalance);\\n\\n        try squidMulticall.run(calls) {\\n            emit CrossMulticallExecuted(keccak256(payload));\\n        } catch (bytes memory reason) {\\n            // Refund tokens to refund recipient if swap fails\\n            IERC20(bridgedTokenAddress).safeTransfer(refundRecipient, contractBalance);\\n            emit CrossMulticallFailed(keccak256(payload), reason, refundRecipient);\\n        }\\n    }\\n\\n    function _bridgeCall(\\n        string calldata bridgedTokenSymbol,\\n        address bridgedTokenAddress,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasRefundRecipient,\\n        bool enableExpress\\n    ) private {\\n        uint256 bridgedTokenBalance = IERC20(bridgedTokenAddress).balanceOf(address(this));\\n\\n        if (address(this).balance > 0) {\\n            if (enableExpress) {\\n                gasService.payNativeGasForExpressCallWithToken{value: address(this).balance}(\\n                    address(this),\\n                    destinationChain,\\n                    destinationAddress,\\n                    payload,\\n                    bridgedTokenSymbol,\\n                    bridgedTokenBalance,\\n                    gasRefundRecipient\\n                );\\n            } else {\\n                gasService.payNativeGasForContractCallWithToken{value: address(this).balance}(\\n                    address(this),\\n                    destinationChain,\\n                    destinationAddress,\\n                    payload,\\n                    bridgedTokenSymbol,\\n                    bridgedTokenBalance,\\n                    gasRefundRecipient\\n                );\\n            }\\n        }\\n\\n        _approve(bridgedTokenAddress, address(gateway), bridgedTokenBalance);\\n        gateway.callContractWithToken(\\n            destinationChain,\\n            destinationAddress,\\n            payload,\\n            bridgedTokenSymbol,\\n            bridgedTokenBalance\\n        );\\n    }\\n\\n    function _approve(address token, address spender, uint256 amount) private {\\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\\n        if (allowance < amount) {\\n            if (allowance > 0) {\\n                _approveCall(token, spender, 0);\\n            }\\n            _approveCall(token, spender, type(uint256).max);\\n        }\\n    }\\n\\n    function _approveCall(address token, address spender, uint256 amount) private {\\n        // Unlimited approval is not security issue since the contract doesn't store tokens\\n        (bool success, ) = token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, amount));\\n        if (!success) revert ApprovalFailed();\\n    }\\n\\n    function _transferTokenToMulticall(address token, uint256 amount) private {\\n        (bool success, bytes memory returnData) = token.call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, msg.sender, address(squidMulticall), amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n        if (!transferred || token.code.length == 0) revert TokenTransferFailed();\\n    }\\n\\n    function _setup(bytes calldata data) internal override {\\n        address _pauser = abi.decode(data, (address));\\n        if (_pauser == address(0)) revert ZeroAddressProvided();\\n        _setPauser(_pauser);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/SquidRouterProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {InitProxy} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/InitProxy.sol\\\";\\n\\ncontract SquidRouterProxy is InitProxy {\\n    function contractId() internal pure override returns (bytes32 id) {\\n        id = keccak256(\\\"squid-router\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"viaIR\": true,\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gasService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_multicall\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractIsPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpressExecutorAlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCodeHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwnerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprovedByGateway\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPauser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPendingPauser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotProxy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetupFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressProvided\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"}],\"name\":\"CrossMulticallExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refundRecipient\",\"type\":\"address\"}],\"name\":\"CrossMulticallFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"expressExecutor\",\"type\":\"address\"}],\"name\":\"ExpressExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"expressExecutor\",\"type\":\"address\"}],\"name\":\"ExpressExecutedWithToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"expressExecutor\",\"type\":\"address\"}],\"name\":\"ExpressExecutionFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"expressExecutor\",\"type\":\"address\"}],\"name\":\"ExpressExecutionWithTokenFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentPauser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingPauser\",\"type\":\"address\"}],\"name\":\"PauserProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingPauser\",\"type\":\"address\"}],\"name\":\"PauserUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"bridgedTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destinationAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"gasRefundRecipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enableExpress\",\"type\":\"bool\"}],\"name\":\"bridgeCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"enum ISquidMulticall.CallType\",\"name\":\"callType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct ISquidMulticall.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"bridgedTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destinationAddress\",\"type\":\"string\"}],\"name\":\"callBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"enum ISquidMulticall.CallType\",\"name\":\"callType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct ISquidMulticall.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"bridgedTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"destinationAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"gasRefundRecipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enableExpress\",\"type\":\"bool\"}],\"name\":\"callBridgeCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"executeWithToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"expressExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"expressExecuteWithToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"enum ISquidMulticall.CallType\",\"name\":\"callType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"struct ISquidMulticall.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"fundAndRunMulticall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"contract IAxelarGateway\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"}],\"name\":\"getExpressExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"expressExecutor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getExpressExecutorWithToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"expressExecutor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingPauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"updatePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"newImplementationCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SquidRouter", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "0000000000000000000000004f4495243837681061c4743b74b3eedf548d56a50000000000000000000000002d5d7d31f671f86c782533cc367f14109a0827120000000000000000000000004fd39c9e151e50580779bd04b1f7ecc310079fd3", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}