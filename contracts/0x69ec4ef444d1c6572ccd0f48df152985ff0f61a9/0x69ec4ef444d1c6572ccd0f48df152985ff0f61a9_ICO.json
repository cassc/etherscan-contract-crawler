{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ICO.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"./interfaces/IICO.sol\\\";\\nimport \\\"./interfaces/IVesting.sol\\\";\\nimport \\\"./utils/ReentrancyGuard.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./interfaces/OracleWrapper.sol\\\";\\n\\ncontract ICO is Ownable, ReentrancyGuard, IICO {\\n    uint256 public totalTokenSold;\\n    uint256 public totalUSDRaised;\\n    uint256 public tokenDecimal;\\n    uint256 public minTokensBuy = (100 * (10 ** 18));\\n    uint256 public totalReferralAmount = (2000100 * (10 ** 18));\\n    uint256 private counter;\\n    uint8 public defaultPhase = 1;\\n    uint8 public totalPhases;\\n\\n    address public receiverAddress = 0xDF155a928dBB5556C52DC0c51b81308d6F41925D;\\n\\n    //ETH\\n    address public constant USDTORACLEADRESS =\\n        0x3E7d1eAB13ad0104d2750B8863b489D65364e32D;\\n    address public constant ETHORACLEADRESS =\\n        0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\\n\\n    /* ================ STRUCT SECTION ================ */\\n    /* Stores phases */\\n    struct Phases {\\n        uint256 tokenSold;\\n        uint256 tokenLimit;\\n        uint32 startTime;\\n        uint32 expirationTimestamp;\\n        uint32 price /* 10 ** 8 */;\\n        bool isComplete;\\n    }\\n\\n    mapping(uint256 => Phases) public phaseInfo;\\n    mapping(address => bool) public isVerified;\\n    mapping(address => string) public isInvested;\\n    mapping(string => address) public referralCodeMapping;\\n\\n    IERC20Metadata public tokenInstance; /* Dregn token instance */\\n    IERC20Metadata public usdtInstance; /* USDT token instance */\\n    IVesting public vestingInstance; /* vesting contract address */\\n\\n    OracleWrapper public USDTOracle = OracleWrapper(USDTORACLEADRESS);\\n    OracleWrapper public ETHOracle = OracleWrapper(ETHORACLEADRESS);\\n\\n    /* ================ CONSTRUCTOR SECTION ================ */\\n    constructor(\\n        address _tokenAddress,\\n        address _usdtAddress,\\n        address _vestingContract\\n    ) {\\n        tokenInstance = IERC20Metadata(_tokenAddress);\\n        usdtInstance = IERC20Metadata(_usdtAddress);\\n        vestingInstance = IVesting(_vestingContract);\\n\\n        totalPhases = 4;\\n        tokenDecimal = uint256(10 ** tokenInstance.decimals());\\n\\n        phaseInfo[1] = Phases({\\n            tokenLimit: 4_000_000 * tokenDecimal,\\n            tokenSold: 0,\\n            startTime: 1690761600,\\n            expirationTimestamp: 1691020799, //31th July 2023 to 02nd August 2023\\n            price: 10000000 /* 0.1 */,\\n            isComplete: false\\n        });\\n        phaseInfo[2] = Phases({\\n            tokenLimit: 4_000_000 * tokenDecimal,\\n            tokenSold: 0,\\n            startTime: 1691625600,\\n            expirationTimestamp: 1691884799, //10th August 2023 to 12th August 2023\\n            isComplete: false,\\n            price: 15000000 /* 0.15 */\\n        });\\n        phaseInfo[3] = Phases({\\n            tokenLimit: 4_000_000 * tokenDecimal,\\n            tokenSold: 0,\\n            startTime: 1693008000,\\n            expirationTimestamp: 1693267199, //26th August 2023 to 28th August 2023\\n            isComplete: false,\\n            price: 20000000 /* 0.2 */\\n        });\\n        phaseInfo[4] = Phases({\\n            tokenLimit: 10_000_000 * tokenDecimal,\\n            tokenSold: 0,\\n            startTime: 1696118400,\\n            expirationTimestamp: 1698796799, //01st October 2023 to 31th October 2023\\n            isComplete: false,\\n            price: 25000000 /* 0.25 */\\n        });\\n    }\\n\\n    /* ================ BUYING TOKENS SECTION ================ */\\n\\n    /* Receive Function */\\n    receive() external payable {\\n        /* Sending deposited currency to the receiver address */\\n        TransferHelper.safeTransferETH(receiverAddress, msg.value);\\n    }\\n\\n    /* Function lets user buy SDG tokens || Type 1 = BNB or ETH, Type = 2 for USDT */\\n    function buyTokens(\\n        uint8 _type,\\n        uint256 _usdtAmount,\\n        address _referralAddress\\n    ) external payable override nonReentrant {\\n        address _msgSender = msg.sender;\\n        require(isVerified[_msgSender], \\\"User KYC is not done.\\\");\\n        require(\\n            block.timestamp >= phaseInfo[0].startTime,\\n            \\\"Buying Phases are not Started yet\\\"\\n        );\\n        require(\\n            block.timestamp < phaseInfo[(totalPhases)].expirationTimestamp,\\n            \\\"Buying phases are over.\\\"\\n        );\\n\\n        uint256 _buyAmount;\\n\\n        /* If type == 1 */\\n        if (_type == 1) {\\n            _buyAmount = msg.value;\\n        }\\n        /* If type == 2 */\\n        else {\\n            _buyAmount = _usdtAmount;\\n            /* Balance Check */\\n            require(\\n                usdtInstance.balanceOf(_msgSender) >= _buyAmount,\\n                \\\"User doesn't have enough balance.\\\"\\n            );\\n\\n            /* Allowance Check */\\n            require(\\n                usdtInstance.allowance(_msgSender, address(this)) >= _buyAmount,\\n                \\\"Allowance provided is low.\\\"\\n            );\\n        }\\n        require(_buyAmount > 0, \\\"Please enter value more than 0.\\\");\\n\\n        /* Token calculation */\\n        (\\n            uint256 _tokenAmount,\\n            uint8 _phaseNo,\\n            uint256 _amountToUSD\\n        ) = calculateTokens(_buyAmount, 0, defaultPhase, _type);\\n\\n        require(\\n            _tokenAmount >= minTokensBuy,\\n            \\\"Please buy more then minimum value\\\"\\n        );\\n\\n        /* Setup for vesting in vesting contract */\\n        require(_tokenAmount > 0, \\\"Token amount should be more then zero.\\\");\\n        vestingInstance.registerUserByICO(_tokenAmount, _phaseNo, _msgSender);\\n\\n        uint256 _referralReward = 0;\\n        if (bytes(isInvested[_msgSender]).length == 0) {\\n            if ((_referralAddress != address(0)) && (totalReferralAmount > 0)) {\\n                require(\\n                    bytes(isInvested[_referralAddress]).length > 0,\\n                    \\\"Referral Address is not valid\\\"\\n                );\\n\\n                _referralReward = (_tokenAmount * 1000) / 10000;\\n                if (totalReferralAmount > _referralReward) {\\n                    _referralReward = _referralReward;\\n                } else {\\n                    _referralReward = totalReferralAmount;\\n                }\\n                vestingInstance.registerUserByICO(\\n                    _referralReward,\\n                    0,\\n                    _referralAddress\\n                );\\n                totalReferralAmount -= _referralReward;\\n            }\\n            string memory referralCode = randomString();\\n            isInvested[_msgSender] = referralCode;\\n            referralCodeMapping[referralCode] = _msgSender;\\n        }\\n\\n        /* Phase info setting */\\n        setPhaseInfo(_tokenAmount, _referralReward, defaultPhase);\\n\\n        /* Update Phase number and add token amount */\\n        defaultPhase = _phaseNo;\\n\\n        totalTokenSold += _tokenAmount;\\n        totalUSDRaised += _amountToUSD;\\n\\n        if (_type == 1) {\\n            /* Sending deposited currency to the receiver address */\\n            TransferHelper.safeTransferETH(receiverAddress, _buyAmount);\\n        } else {\\n            /* Sending deposited currency to the receiver address */\\n            TransferHelper.safeTransferFrom(\\n                address(usdtInstance),\\n                _msgSender,\\n                receiverAddress,\\n                _buyAmount\\n            );\\n        }\\n        /* Emits event */\\n        emit BuyTokenDetail(\\n            _buyAmount,\\n            _tokenAmount,\\n            _referralReward,\\n            uint32(block.timestamp),\\n            _type,\\n            _phaseNo,\\n            _referralAddress,\\n            _msgSender\\n        );\\n    }\\n\\n    function randomString() public returns (string memory referralCode) {\\n        bytes memory randomWord = new bytes(6);\\n        // since we have 36 letters\\n        bytes memory chars = new bytes(36);\\n        chars = \\\"abcdefghijklmnopqrstuvwxyz0123456789\\\";\\n        for (uint i = 0; i < 6; i++) {\\n            uint randomNumber = random();\\n            // Index access for string is not possible\\n            randomWord[i] = chars[randomNumber];\\n        }\\n        // randomWord = \\\"a3f5h6\\\";\\n        if (referralCodeMapping[string(randomWord)] == address(0)) {\\n            return string(randomWord);\\n        } else {\\n            randomString();\\n        }\\n    }\\n\\n    function random() internal returns (uint) {\\n        counter++;\\n        return\\n            uint(\\n                keccak256(\\n                    abi.encodePacked(\\n                        block.timestamp,\\n                        block.difficulty,\\n                        msg.sender,\\n                        counter\\n                    )\\n                )\\n            ) % 36;\\n    }\\n\\n    function getCurrentPhase() public view returns (uint8) {\\n        uint32 _time = uint32(block.timestamp);\\n\\n        Phases memory pInfoFirst = phaseInfo[1];\\n        Phases memory pInfoSecond = phaseInfo[2];\\n        Phases memory pInfoThird = phaseInfo[3];\\n        Phases memory pInfoLast = phaseInfo[4];\\n\\n        if (pInfoLast.expirationTimestamp >= _time) {\\n            if (pInfoThird.expirationTimestamp >= _time) {\\n                if (pInfoSecond.expirationTimestamp >= _time) {\\n                    if (pInfoFirst.expirationTimestamp >= _time) {\\n                        return 1;\\n                    } else {\\n                        return 2;\\n                    }\\n                } else {\\n                    return 3;\\n                }\\n            } else {\\n                return 4;\\n            }\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /* Function calculates ETH, USDT according to user's given amount */\\n    function calculateETHorUSDT(\\n        uint256 _amount,\\n        uint256 _previousTokens,\\n        uint8 _phaseNo,\\n        uint8 _type\\n    ) public view returns (uint256) {\\n        /* Phases cannot exceed totalPhases */\\n        require(\\n            _phaseNo <= totalPhases,\\n            \\\"Not enough tokens in the contract or phase expired.\\\"\\n        );\\n        Phases memory pInfo = phaseInfo[_phaseNo];\\n        /* If phase is still going on */\\n        if (block.timestamp < pInfo.expirationTimestamp) {\\n            uint256 _amountToUSD = ((_amount * pInfo.price) / tokenDecimal);\\n            (uint256 _cryptoUSDAmount, uint256 _decimals) = cryptoValues(_type);\\n            uint256 _tokensLeftToSell = (pInfo.tokenLimit + _previousTokens) -\\n                pInfo.tokenSold;\\n            require(\\n                _tokensLeftToSell >= _amount,\\n                \\\"Insufficient tokens available in phase.\\\"\\n            );\\n            return ((_amountToUSD * _decimals) / _cryptoUSDAmount);\\n        }\\n        /* In case the phase is expired. New will begin after sending the left tokens to the next phase */\\n        else {\\n            uint256 _remainingTokens = pInfo.tokenLimit - pInfo.tokenSold;\\n\\n            return\\n                calculateETHorUSDT(\\n                    _amount,\\n                    _remainingTokens + _previousTokens,\\n                    _phaseNo + 1,\\n                    _type\\n                );\\n        }\\n    }\\n\\n    /* Internal function to calculate tokens */\\n    function calculateTokens(\\n        uint256 _amount,\\n        uint256 _previousTokens,\\n        uint8 _phaseNo,\\n        uint8 _type\\n    ) public view returns (uint256, uint8, uint256) {\\n        /* Phases cannot exceed totalPhases */\\n        require(\\n            _phaseNo <= totalPhases,\\n            \\\"Not enough tokens in the contract or Phase expired.\\\"\\n        );\\n        Phases memory pInfo = phaseInfo[_phaseNo];\\n        /* If phase is still going on */\\n        if (block.timestamp < pInfo.expirationTimestamp) {\\n            (uint256 _amountToUSD, uint256 _typeDecimal) = cryptoValues(_type);\\n            uint256 _amountGivenInUsd = ((_amount * _amountToUSD) /\\n                _typeDecimal);\\n\\n            /* If phase is still going on */\\n            uint256 _tokensAmount = tokensUserWillGet(\\n                _amountGivenInUsd,\\n                pInfo.price\\n            );\\n            uint256 _tokensLeftToSell = (pInfo.tokenLimit + _previousTokens) -\\n                pInfo.tokenSold;\\n            require(\\n                _tokensLeftToSell >= _tokensAmount,\\n                \\\"Insufficient tokens available in phase.\\\"\\n            );\\n            return (_tokensAmount, _phaseNo, _amountGivenInUsd);\\n        }\\n        /*  In case the phase is expired. New will begin after sending the left tokens to the next phase */\\n        else {\\n            uint256 _remainingTokens = pInfo.tokenLimit - pInfo.tokenSold;\\n\\n            return\\n                calculateTokens(\\n                    _amount,\\n                    _remainingTokens + _previousTokens,\\n                    _phaseNo + 1,\\n                    _type\\n                );\\n        }\\n    }\\n\\n    /* Tokens user will get according to the price */\\n    function tokensUserWillGet(\\n        uint256 _amount,\\n        uint32 _price\\n    ) internal view returns (uint256) {\\n        return ((_amount * tokenDecimal * (10 ** 8)) /\\n            ((10 ** 8) * uint256(_price)));\\n    }\\n\\n    /* Returns the crypto values used */\\n    function cryptoValues(\\n        uint8 _type\\n    ) internal view returns (uint256, uint256) {\\n        uint256 _amountToUSD;\\n        uint256 _typeDecimal;\\n\\n        if (_type == 1) {\\n            _amountToUSD = ETHOracle.latestAnswer();\\n            _typeDecimal = 10 ** 18;\\n        } else {\\n            _amountToUSD = USDTOracle.latestAnswer();\\n            _typeDecimal = uint256(10 ** usdtInstance.decimals());\\n        }\\n        return (_amountToUSD, _typeDecimal);\\n    }\\n\\n    /* Sets phase info according to the tokens bought */\\n    function setPhaseInfo(\\n        uint256 _tokensUserWillGet,\\n        uint256 _referralReward,\\n        uint8 _phaseNo\\n    ) internal {\\n        require(_phaseNo <= totalPhases, \\\"All tokens have been exhausted.\\\");\\n\\n        Phases storage pInfo = phaseInfo[_phaseNo];\\n\\n        if (block.timestamp < pInfo.expirationTimestamp) {\\n            /* when phase has more tokens than reuired */\\n            if ((pInfo.tokenLimit - pInfo.tokenSold) > _tokensUserWillGet) {\\n                pInfo.tokenSold += _tokensUserWillGet;\\n            }\\n            /* when  phase has equal tokens as reuired */\\n            else if (\\n                (pInfo.tokenLimit - pInfo.tokenSold) == _tokensUserWillGet\\n            ) {\\n                pInfo.tokenSold = pInfo.tokenLimit;\\n                pInfo.isComplete = true;\\n            }\\n            /*  when tokens required are more than left tokens in phase */\\n            else {\\n                revert(\\\"Phase doesn't have enough tokens.\\\");\\n            }\\n        }\\n        /* if tokens left in phase afterb completion of expiration time */\\n        else {\\n            uint256 remainingTokens = pInfo.tokenLimit - pInfo.tokenSold;\\n            pInfo.tokenLimit = pInfo.tokenSold;\\n            pInfo.isComplete = true;\\n\\n            phaseInfo[_phaseNo + 1].tokenLimit += remainingTokens;\\n            setPhaseInfo(_tokensUserWillGet, _referralReward, _phaseNo + 1);\\n        }\\n    }\\n\\n    /* ================ OTHER FUNCTIONS SECTION ================ */\\n    /* Updates Receiver Address */\\n    function updateReceiverAddress(\\n        address _receiverAddress\\n    ) external onlyOwner {\\n        require(_receiverAddress != address(0), \\\"Zero address passed.\\\");\\n        receiverAddress = _receiverAddress;\\n    }\\n\\n    function updateUserKYC(address[] memory _userAddress) external onlyOwner {\\n        require(\\n            _userAddress.length <= 100,\\n            \\\"You can't send more than 100 emails to verify at once.\\\"\\n        );\\n        for (uint256 i = 0; i < _userAddress.length; i++) {\\n            require(_userAddress[i] != address(0), \\\"Zero address passed.\\\");\\n            isVerified[_userAddress[i]] = true;\\n        }\\n        emit UserKYC(_userAddress, true);\\n    }\\n\\n    function updateMinmumuTokensBuyAmount(\\n        uint256 _minTokensBuy\\n    ) external onlyOwner {\\n        minTokensBuy = _minTokensBuy;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IICO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\ninterface IICO {\\n    event BuyTokenDetail(\\n        uint256 buyAmount,\\n        uint256 tokenAmount,\\n        uint256 referralReward,\\n        uint32 timestamp,\\n        uint8 buyType,\\n        uint8 phaseNo,\\n        address referralAddress,\\n        address userAddress\\n    );\\n\\n    event UserKYC(address[] userAddress, bool success);\\n\\n    function buyTokens(\\n        uint8 _type,\\n        uint256 _usdtAmount,\\n        address _referralAddress\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\ninterface IVesting {\\n\\n    event RegisterUser(uint256 totalTokens, address userAddress, uint8 choice);\\n    \\n    event ClaimedToken(\\n        address userAddress,\\n        uint256 claimedAmount,\\n        uint32 timestamp,\\n        uint8 claimCount,\\n        uint8 choice\\n    );\\n\\n    function registerUserByICO(\\n        uint256 _amount,\\n        uint8 _choice,\\n        address _to\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/OracleWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\ninterface OracleWrapper {\\n    function latestAnswer() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x095ea7b3, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeApprove: approve failed\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0xa9059cbb, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeTransfer: transfer failed\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::transferFrom: transferFrom failed\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(\\n            success,\\n            \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\"\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdtAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vestingContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"buyType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"phaseNo\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"BuyTokenDetail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"userAddress\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"UserKYC\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETHORACLEADRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETHOracle\",\"outputs\":[{\"internalType\":\"contract OracleWrapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTORACLEADRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTOracle\",\"outputs\":[{\"internalType\":\"contract OracleWrapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_usdtAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referralAddress\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_previousTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_phaseNo\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"calculateETHorUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_previousTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_phaseNo\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"calculateTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPhase\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPhase\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isInvested\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTokensBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phaseInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expirationTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"price\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isComplete\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"referralCode\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiverAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"referralCodeMapping\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenInstance\",\"outputs\":[{\"internalType\":\"contract IERC20Metadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPhases\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReferralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUSDRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTokensBuy\",\"type\":\"uint256\"}],\"name\":\"updateMinmumuTokensBuyAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiverAddress\",\"type\":\"address\"}],\"name\":\"updateReceiverAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userAddress\",\"type\":\"address[]\"}],\"name\":\"updateUserKYC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtInstance\",\"outputs\":[{\"internalType\":\"contract IERC20Metadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingInstance\",\"outputs\":[{\"internalType\":\"contract IVesting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ICO", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000878c5213cce6fd8f63e10772969b7d49b36cabf4000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000632492d350d59b3deea616f4ab4e4fc250e4e4b1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}