{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/interfaces/IRewardsBooster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 IRewardsBooster\\n * @author Asymetrix Protocol Inc Team\\n * @notice An interface of the RewardsBooster contract.\\n */\\ninterface IRewardsBooster {\\n    /**\\n     * @notice Initial parameters structure.\\n     * @param ticket A Ticket contract address.\\n     * @param stEthOracle An oracle for stETH token.\\n     * @param asxOracle An oracle for ASX token that returns price of ASX token in WETH.\\n     * @param nonfungiblePositionManager A NonfungiblePositionManager contract address.\\n     * @param uniswapWrapper A wrapper contract address that helps to interact with Uniswap V3.\\n     * @param weth WETH token address.\\n     * @param asx ASX token address.\\n     * @param maxBoost A maximum possible boost coefficient. Is used when lock (position) is created by a user.\\n     * @param minBoostThreshold A threshold (in %) that all of the user's locks (positions) together must overcome for a\\n     *                          boost to be awarded during a rewards claim on the StakePrizePool contract.\\n     * @param maxBoostThreshold A threshold (in %) that all of the user's locks (positions) together must achieve to get\\n     *                          the maximum boost during a rewards claim on the StakePrizePool contract.\\n     * @param slippageTolerance A slippage tolerance to apply in time of swap of ETH/WETH for ASX.\\n     */\\n    struct InitParams {\\n        address ticket;\\n        address stEthOracle;\\n        address asxOracle;\\n        address nonfungiblePositionManager;\\n        address uniswapWrapper;\\n        address weth;\\n        address asx;\\n        uint16 maxBoost;\\n        uint16 minBoostThreshold;\\n        uint16 maxBoostThreshold;\\n        uint16 slippageTolerance;\\n    }\\n\\n    /**\\n     * @notice Staking pool structure.\\n     * @param isFungible Indicates if pool accepts fungible ERC-20 or non fungible ERC-721 tokens.\\n     * @param stakeToken Token address to stake in the staking pool.\\n     * @param stakeTokenValuer Valuer for the staked token.\\n     * @param liquidityPool Liquidity pool where liquidity is stored.\\n     * @param validator Validator whose main role is to execute different validations in time of stakes and unstakes.\\n     * @param minLockDuration Minimum look duration in the staking pool.\\n     * @param maxLockDuration Maximum look duration in the staking pool.\\n     * @param lockDurationSettingsNumber An amount of settings in the mapping with lock duration settings.\\n     */\\n    struct Pool {\\n        uint256 isFungible;\\n        address stakeToken;\\n        address stakeTokenValuer;\\n        address liquidityPool;\\n        address validator;\\n        uint32 minLockDuration;\\n        uint32 maxLockDuration;\\n        uint8 lockDurationSettingsNumber;\\n    }\\n\\n    /**\\n     * @notice User structure.\\n     * @param initializedLocksNumber Number of locks (positions) created and initialized by user.\\n     */\\n    struct User {\\n        uint8 initializedLocksNumber;\\n    }\\n\\n    /**\\n     * @notice Lock (position) structure.\\n     * @param amountOrId Amount of ERC-20 locked tokens (or ERC-721 NFT locked position ID).\\n     * @param createdAt Timestamp when the lock (position) was created.\\n     * @param updatedAt Timestamp when the lock (position) was updated last ime.\\n     * @param duration Duration of the lock (position).\\n     * @param maxBoost A maximum possible boost coefficient for user. Is set when lock (position) is created by a user.\\n     * @param isInitialized Indicates if the lock (position) is initialized or not.\\n     */\\n    struct Lock {\\n        uint256 amountOrId;\\n        uint32 createdAt;\\n        uint32 updatedAt;\\n        uint32 duration;\\n        uint16 maxBoost;\\n        bool isInitialized;\\n    }\\n\\n    /**\\n     * @notice LockDurationSettings structure.\\n     * @param lowerLockDuration Lower lock duration (in seconds).\\n     * @param upperLockDuration Upper lock duration (in seconds).\\n     * @param additionalBoost An additional boost that will be applied for locks that are in range of above durations.\\n     */\\n    struct LockDurationSettings {\\n        uint32 lowerLockDuration;\\n        uint32 upperLockDuration;\\n        uint16 additionalBoost;\\n    }\\n\\n    /**\\n     * @notice Event emitted when a new lock (position) is created by a user.\\n     * @param _pid Staking pool ID.\\n     * @param _user Lock (position) creator address.\\n     * @param _lid Lock (position) ID.\\n     * @param _lock Lock (position) structure.\\n     */\\n    event LockCreated(uint8 indexed _pid, address indexed _user, uint8 indexed _lid, Lock _lock);\\n\\n    /**\\n     * @notice Event emitted when a lock (position) is closed by a user.\\n     * @param _pid Staking pool ID.\\n     * @param _user Lock (position) creator address.\\n     * @param _lid Lock (position) ID.\\n     */\\n    event LockClosed(uint8 indexed _pid, address indexed _user, uint8 indexed _lid);\\n\\n    /**\\n     * @notice Event emitted when a lock duration was extended.\\n     * @param _pid Staking pool ID where to extend a lock duration for the position.\\n     * @param _user Lock (position) creator address.\\n     * @param _lid An ID of the lock (position) where to extend a lock duration.\\n     * @param _newDuration A new duration (in seconds) for the lock of the position.\\n     */\\n    event LockExtended(uint8 indexed _pid, address indexed _user, uint8 indexed _lid, uint32 _newDuration);\\n\\n    /**\\n     * @notice Event emitted when a new staking pool was added by an owner.\\n     * @param _pid Staking pool ID.\\n     * @param _pool Staking pool structure.\\n     */\\n    event PoolCreated(uint8 indexed _pid, Pool _pool);\\n\\n    /**\\n     * @notice Event emitted when accidentally transferred to this contract token (including ETH) was withdrawn\\n     *         (rescued) by an owner.\\n     * @param token A token that was withdraw. If token address is equal to zero address - ETH was withdrawn.\\n     * @param amountOrId An amount of native/ERC-20 tokens or ID of ERC-721 NFT token that was withdraw.\\n     * @param isFungible Indicates if token that was withdraw is fungible ERC-20 token.\\n     * @param recipient A recipient of withdrawn tokens.\\n     */\\n    event Rescued(address indexed token, uint256 amountOrId, bool indexed isFungible, address indexed recipient);\\n\\n    /**\\n     * @notice Calculates a boost coefficient for the array of users.\\n     * @param _users An array users to calculate boost coefficient for.\\n     * @return An array with boost coefficients for the users.\\n     * @return An array with flags that indicate if a user is able to use this coefficient to multiply his rewards.\\n     */\\n    function getBoostBatch(address[] calldata _users) external view returns (uint32[] memory, bool[] memory);\\n\\n    /**\\n     * @notice Calculates a boost coefficient for a user.\\n     * @param _user A user to calculate boost coefficient for.\\n     * @return A boost coefficient for a user.\\n     * @return A flag that indicates if a user is able to use this coefficient to multiply his rewards.\\n     */\\n    function getBoost(address _user) external view returns (uint32, bool);\\n\\n    /**\\n     * @notice Returns staking pool info by its ID.\\n     * @param _pid Staking pool ID.\\n     * @return Staking pool info.\\n     */\\n    function getPoolInfo(uint8 _pid) external view returns (Pool memory);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/interfaces/IValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 IValidator\\n * @author Asymetrix Protocol Inc Team\\n * @notice An interface that all validators should implement.\\n */\\ninterface IValidator {\\n    /**\\n     * @notice Validates if stake parameters are valid.\\n     * @param _pid Staking pool ID.\\n     * @param _amountOrId Amount of ERC-20 LP tokens or ID of ERC-721 NFT token to validate.\\n     */\\n    function validateStake(uint8 _pid, uint256 _amountOrId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/interfaces/IValuer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 IValuer\\n * @author Asymetrix Protocol Inc Team\\n * @notice An interface that all valuers should implement.\\n */\\ninterface IValuer {\\n    /**\\n     * @notice Returns the value of ERC-20 LP tokens (or ERC-721 NFT position) in USD in the liquidity pool.\\n     * @param _amountOrId An amount of ERC-20 LP tokens (or ERC-721 NFT position ID) to value.\\n     * @return _value The value of ERC-20 LP tokens (or ERC-721 NFT position) in USD.\\n     */\\n    function value(uint256 _amountOrId) external view returns (uint256 _value);\\n\\n    /**\\n     * @notice Returns token amounts inside the position in USD.\\n     * @param _id Id of the Uniswap V3 position.\\n     * @return _value0 The first token amount in USD.\\n     * @return _value1 The second token amount in USD.\\n     */\\n    function getTokenAmountsInUSD(uint256 _id) external view returns (uint256 _value0, uint256 _value1);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/libraries/RewardsBoosterErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title Asymetrix Protocol V2 RewardsBoosterErrors library\\n * @author Asymetrix Protocol Inc Team\\n * @notice A library with errors for rewards booster contracts.\\n */\\nlibrary RewardsBoosterErrors {\\n    error WrongLockDurtionSettingsNumber();\\n    error WrongBalancerPoolTokensNumber();\\n    error WrongLockDurtionSettings();\\n    error TooSmallBoostThreshold();\\n    error NoEmptySlotsInThisPool();\\n    error InvalidStakeArguments();\\n    error WrongValidityDuration();\\n    error TooBigBoostThreshold();\\n    error TooMuchLocksCreated();\\n    error StakeTokenWithdraw();\\n    error LockIsNotFinished();\\n    error WrongLockDurtion();\\n    error NotExistingPool();\\n    error NotExistingLock();\\n    error LengthsMismatch();\\n    error NotContract();\\n    error ZeroAddress();\\n    error ZeroAmount();\\n    error StalePrice();\\n    error WrongTick();\\n    error WrongTokensRatio();\\n    error WrongMaxTokenDominance();\\n    error StubMethod();\\n}\\n\"\r\n    },\r\n    \"contracts/rewards-booster/validators/ValidatorUniswapV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.10;\\n\\nimport { INonfungiblePositionManager } from \\\"../../vendor/uniswap-v3/interfaces/INonfungiblePositionManager.sol\\\";\\nimport { IUniswapV3Factory } from \\\"../../vendor/uniswap-v3/interfaces/IUniswapV3Factory.sol\\\";\\nimport { TickMath } from \\\"../../vendor/uniswap-v3/libraries/TickMath.sol\\\";\\nimport { RewardsBoosterErrors } from \\\"../libraries/RewardsBoosterErrors.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IRewardsBooster } from \\\"../interfaces/IRewardsBooster.sol\\\";\\nimport { IValidator } from \\\"../interfaces/IValidator.sol\\\";\\nimport { IValuer } from \\\"../interfaces/IValuer.sol\\\";\\n\\n/**\\n * @title Asymetrix Protocol V2 ValidatorUniswapV3\\n * @author Asymetrix Protocol Inc Team\\n * @notice A validator that validates staking parameters in time of staking in the Uniswap V3 staking pool on the\\n *         RewardsBooster contract.\\n */\\ncontract ValidatorUniswapV3 is Ownable, IValidator {\\n    using Address for address;\\n\\n    INonfungiblePositionManager private positionManager;\\n    IUniswapV3Factory private factory;\\n    IRewardsBooster private rewardsBooster;\\n    IValuer private valuerUniV3;\\n\\n    uint256 private maxTokenDominance;\\n\\n    int24 private minTick;\\n    int24 private maxTick;\\n\\n    uint256 public constant ONE_HUNDRED_PERCENT = 10000;\\n\\n    /**\\n     * @notice Deploy the ValidatorUniswapV3 contract.\\n     * @param _positionManager Uniswap V3 NonfungiblePositionManager contract address.\\n     * @param _factory Uniswap V3 Factory contract address.\\n     * @param _rewardsBooster RewardsBooster contract address.\\n     * @param _valuerUniV3 an address of the Uniswap V3 valuer.\\n     * @param _maxTick max tick allowed for the position.\\n     * @param _minTick min tick allowed for the position.\\n     * @param _maxTokenDominance max token dominance.\\n     */\\n    constructor(\\n        address _positionManager,\\n        address _factory,\\n        address _rewardsBooster,\\n        address _valuerUniV3,\\n        int24 _maxTick,\\n        int24 _minTick,\\n        uint256 _maxTokenDominance\\n    ) {\\n        onlyContract(_positionManager);\\n        onlyContract(_factory);\\n        onlyContract(_rewardsBooster);\\n\\n        _setMaxTick(_maxTick);\\n        _setMinTick(_minTick);\\n        _setValuerUniV3(_valuerUniV3);\\n        _setMaxTokenDominance(_maxTokenDominance);\\n\\n        positionManager = INonfungiblePositionManager(_positionManager);\\n        factory = IUniswapV3Factory(_factory);\\n        rewardsBooster = IRewardsBooster(_rewardsBooster);\\n    }\\n\\n    /**\\n     * @notice Sets new max token dominance.\\n     * @param _maxTokenDominance new max token dominance.\\n     */\\n    function setMaxTokenDominance(uint256 _maxTokenDominance) external onlyOwner {\\n        _setMaxTokenDominance(_maxTokenDominance);\\n    }\\n\\n    /**\\n     * @notice Sets new max tick.\\n     * @param _maxTick new max tick.\\n     */\\n    function setMaxTick(int24 _maxTick) external onlyOwner {\\n        _setMaxTick(_maxTick);\\n    }\\n\\n    /**\\n     * @notice Sets new min tick.\\n     * @param _minTick new min tick.\\n     */\\n    function setMinTick(int24 _minTick) external onlyOwner {\\n        _setMinTick(_minTick);\\n    }\\n\\n    /**\\n     * @notice Sets a Uniswap V3 valuer address.\\n     * @param _valuerUniV3 new address of the Uniswap V3 valuer.\\n     */\\n    function setValuerUniV3(address _valuerUniV3) external onlyOwner {\\n        _setValuerUniV3(_valuerUniV3);\\n    }\\n\\n    /// @inheritdoc IValidator\\n    function validateStake(uint8 _pid, uint256 _tokenId) external view {\\n        INonfungiblePositionManager.Position memory _position = positionManager.positions(_tokenId);\\n\\n        address _liquidityPool = factory.getPool(_position.token0, _position.token1, _position.fee);\\n        IRewardsBooster.Pool memory _stakingPool = rewardsBooster.getPoolInfo(_pid);\\n\\n        if (_liquidityPool != _stakingPool.liquidityPool) revert RewardsBoosterErrors.InvalidStakeArguments();\\n        if (_position.tickLower != minTick || _position.tickUpper != maxTick) revert RewardsBoosterErrors.WrongTick();\\n\\n        (uint256 _value0, uint256 _value1) = valuerUniV3.getTokenAmountsInUSD(_tokenId);\\n\\n        uint256 _maxTokenDominance = maxTokenDominance;\\n        uint256 _totalInUSD = _value0 + _value1;\\n        uint256 _tokenDominance = (_value0 * ONE_HUNDRED_PERCENT) / _totalInUSD;\\n\\n        if (\\n            _tokenDominance < (ONE_HUNDRED_PERCENT - _maxTokenDominance) ||\\n            _tokenDominance / _totalInUSD > _maxTokenDominance\\n        ) revert RewardsBoosterErrors.WrongTokensRatio();\\n    }\\n\\n    /**\\n     * @notice Returns maxTick.\\n     * @return maxTick.\\n     */\\n    function getMaxTick() external view returns (int24) {\\n        return maxTick;\\n    }\\n\\n    /**\\n     * @notice Returns minTick.\\n     * @return minTick.\\n     */\\n    function getMinTick() external view returns (int24) {\\n        return minTick;\\n    }\\n\\n    /**\\n     * @notice Returns NonfungiblePositionManager contract address.\\n     * @return NonfungiblePositionManager contract address.\\n     */\\n    function getPositionManager() external view returns (INonfungiblePositionManager) {\\n        return positionManager;\\n    }\\n\\n    /**\\n     * @notice Returns UniswapV3Factory contract address.\\n     * @return UniswapV3Factory contract address.\\n     */\\n    function getFactory() external view returns (IUniswapV3Factory) {\\n        return factory;\\n    }\\n\\n    /**\\n     * @notice Returns RewardsBooster contract address.\\n     * @return RewardsBooster contract address.\\n     */\\n    function getRewardsBooster() external view returns (IRewardsBooster) {\\n        return rewardsBooster;\\n    }\\n\\n    /**\\n     * @notice Private function which sets new max token dominance.\\n     * @param _maxTokenDominance new max token dominance.\\n     */\\n    function _setMaxTokenDominance(uint256 _maxTokenDominance) private {\\n        if (_maxTokenDominance > ONE_HUNDRED_PERCENT) revert RewardsBoosterErrors.WrongMaxTokenDominance();\\n\\n        maxTokenDominance = _maxTokenDominance;\\n    }\\n\\n    /**\\n     * @notice Private function which sets new max tick.\\n     * @param _maxTick new max tick.\\n     */\\n    function _setMaxTick(int24 _maxTick) private {\\n        if (_maxTick > TickMath.MAX_TICK || _maxTick < TickMath.MIN_TICK) revert RewardsBoosterErrors.WrongTick();\\n\\n        maxTick = _maxTick;\\n    }\\n\\n    /**\\n     * @notice Private function which sets new min tick.\\n     * @param _minTick new min tick.\\n     */\\n    function _setMinTick(int24 _minTick) private {\\n        if (_minTick < TickMath.MIN_TICK || _minTick > TickMath.MAX_TICK) revert RewardsBoosterErrors.WrongTick();\\n\\n        minTick = _minTick;\\n    }\\n\\n    /**\\n     * @notice Private function which sets a Uniswap V3 valuer address.\\n     * @param _valuerUniV3 new address of the Uniswap V3 valuer.\\n     */\\n    function _setValuerUniV3(address _valuerUniV3) private {\\n        onlyContract(_valuerUniV3);\\n\\n        valuerUniV3 = IValuer(_valuerUniV3);\\n    }\\n\\n    /**\\n     * @notice Checks if an address is a contract.\\n     * @param _contract An address to check.\\n     */\\n    function onlyContract(address _contract) private view {\\n        if (!_contract.isContract()) revert RewardsBoosterErrors.NotContract();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/uniswap-v3/interfaces/INonfungiblePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.5.0;\\n\\n/// @title Non-fungible token for positions\\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\\n/// and authorized.\\ninterface INonfungiblePositionManager {\\n    // details about the uniswap position\\n    struct Position {\\n        // the nonce for permits\\n        uint96 nonce;\\n        // the address that is approved for spending this token\\n        address operator;\\n        // the first token in the pool\\n        address token0;\\n        // the second token in the pool\\n        address token1;\\n        // the pool's fee\\n        uint24 fee;\\n        // the tick range of the position\\n        int24 tickLower;\\n        int24 tickUpper;\\n        // the liquidity of the position\\n        uint128 liquidity;\\n        // the fee growth of the aggregate position as of the last action on the individual position\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n        // how many uncollected tokens are owed to the position, as of the last computation\\n        uint128 tokensOwed0;\\n        uint128 tokensOwed1;\\n    }\\n\\n    struct CollectParams {\\n        uint256 tokenId;\\n        address recipient;\\n        uint128 amount0Max;\\n        uint128 amount1Max;\\n    }\\n\\n    /// @notice Returns the position information associated with a given token ID.\\n    /// @dev Throws if the token ID is not valid.\\n    /// @param tokenId The ID of the token that represents the position.\\n    /// @return The position information associated with a given token ID.\\n    function positions(uint256 tokenId) external view returns (Position memory);\\n\\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\\n    /// recipient The account that should receive the tokens,\\n    /// amount0Max The maximum amount of token0 to collect,\\n    /// amount1Max The maximum amount of token1 to collect\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/uniswap-v3/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.5.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @return pool The pool address\\n    function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/uniswap-v3/libraries/TickMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity 0.8.10;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    error T();\\n    error R();\\n\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        unchecked {\\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\\n\\n            uint256 ratio = absTick & 0x1 != 0\\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\\n                : 0x100000000000000000000000000000000;\\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n            if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n        }\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        unchecked {\\n            // second inequality must be < because the price can never reach the price at the max tick\\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n            uint256 r = ratio;\\n            uint256 msb = 0;\\n\\n            assembly {\\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(5, gt(r, 0xFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(4, gt(r, 0xFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(3, gt(r, 0xFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(2, gt(r, 0xF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(1, gt(r, 0x3))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := gt(r, 0x1)\\n                msb := or(msb, f)\\n            }\\n\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsBooster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_valuerUniV3\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"_maxTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"_minTick\",\"type\":\"int24\"},{\"internalType\":\"uint256\",\"name\":\"_maxTokenDominance\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidStakeArguments\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongMaxTokenDominance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongTick\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongTokensRatio\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ONE_HUNDRED_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFactory\",\"outputs\":[{\"internalType\":\"contract IUniswapV3Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxTick\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinTick\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPositionManager\",\"outputs\":[{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardsBooster\",\"outputs\":[{\"internalType\":\"contract IRewardsBooster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"_maxTick\",\"type\":\"int24\"}],\"name\":\"setMaxTick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTokenDominance\",\"type\":\"uint256\"}],\"name\":\"setMaxTokenDominance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"_minTick\",\"type\":\"int24\"}],\"name\":\"setMinTick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_valuerUniV3\",\"type\":\"address\"}],\"name\":\"setValuerUniV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"validateStake\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ValidatorUniswapV3", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000c36442b4a4522e871399cd717abdd847ab11fe880000000000000000000000001f98431c8ad98523631ae4a59f267346ea31f9840000000000000000000000004e28c08a87c2effc5b1441bed56cd956436792020000000000000000000000004c01c85aa0912a05c557d8c9a5abd9e9a14b7e3000000000000000000000000000000000000000000000000000000000000d89b4fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff2764c000000000000000000000000000000000000000000000000000000000000157c", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}