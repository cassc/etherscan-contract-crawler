{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@connext/interfaces/core/IConnext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {ExecuteArgs, TransferInfo, DestinationTransferStatus} from \\\"../libraries/LibConnextStorage.sol\\\";\\nimport {TokenId} from \\\"../libraries/TokenId.sol\\\";\\n\\ninterface IConnext {\\n\\n  // ============ BRIDGE ==============\\n\\n  function xcall(\\n    uint32 _destination,\\n    address _to,\\n    address _asset,\\n    address _delegate,\\n    uint256 _amount,\\n    uint256 _slippage,\\n    bytes calldata _callData\\n  ) external payable returns (bytes32);\\n\\n  function xcallIntoLocal(\\n    uint32 _destination,\\n    address _to,\\n    address _asset,\\n    address _delegate,\\n    uint256 _amount,\\n    uint256 _slippage,\\n    bytes calldata _callData\\n  ) external payable returns (bytes32);\\n\\n  function execute(ExecuteArgs calldata _args) external returns (bytes32 transferId);\\n\\n  function forceUpdateSlippage(TransferInfo calldata _params, uint256 _slippage) external;\\n\\n  function forceReceiveLocal(TransferInfo calldata _params) external;\\n\\n  function bumpTransfer(bytes32 _transferId) external payable;\\n\\n  function routedTransfers(bytes32 _transferId) external view returns (address[] memory);\\n\\n  function transferStatus(bytes32 _transferId) external view returns (DestinationTransferStatus);\\n\\n  function remote(uint32 _domain) external view returns (address);\\n\\n  function domain() external view returns (uint256);\\n\\n  function nonce() external view returns (uint256);\\n\\n  function approvedSequencers(address _sequencer) external view returns (bool);\\n\\n  function xAppConnectionManager() external view returns (address);\\n\\n  // ============ ROUTERS ==============\\n\\n  function LIQUIDITY_FEE_NUMERATOR() external view returns (uint256);\\n\\n  function LIQUIDITY_FEE_DENOMINATOR() external view returns (uint256);\\n\\n  function getRouterApproval(address _router) external view returns (bool);\\n\\n  function getRouterRecipient(address _router) external view returns (address);\\n\\n  function getRouterOwner(address _router) external view returns (address);\\n\\n  function getProposedRouterOwner(address _router) external view returns (address);\\n\\n  function getProposedRouterOwnerTimestamp(address _router) external view returns (uint256);\\n\\n  function maxRoutersPerTransfer() external view returns (uint256);\\n\\n  function routerBalances(address _router, address _asset) external view returns (uint256);\\n\\n  function getRouterApprovalForPortal(address _router) external view returns (bool);\\n\\n  function initializeRouter(address _owner, address _recipient) external;\\n\\n  function setRouterRecipient(address _router, address _recipient) external;\\n\\n  function proposeRouterOwner(address _router, address _proposed) external;\\n\\n  function acceptProposedRouterOwner(address _router) external;\\n\\n  function addRouterLiquidityFor(\\n    uint256 _amount,\\n    address _local,\\n    address _router\\n  ) external payable;\\n\\n  function addRouterLiquidity(uint256 _amount, address _local) external payable;\\n\\n  function removeRouterLiquidityFor(\\n    TokenId memory _canonical,\\n    uint256 _amount,\\n    address payable _to,\\n    address _router\\n  ) external;\\n\\n  function removeRouterLiquidity(TokenId memory _canonical, uint256 _amount, address payable _to) external;\\n\\n  // ============ TOKEN_FACET ==============\\n  function adoptedToCanonical(address _adopted) external view returns (TokenId memory);\\n\\n  function approvedAssets(TokenId calldata _canonical) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@connext/interfaces/libraries/LibConnextStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Enum representing status of destination transfer\\n * @dev Status is only assigned on the destination domain, will always be \\\"none\\\" for the\\n * origin domains\\n * @return uint - Index of value in enum\\n */\\nenum DestinationTransferStatus {\\n  None, // 0\\n  Reconciled, // 1\\n  Executed, // 2\\n  Completed // 3 - executed + reconciled\\n}\\n\\n/**\\n * @notice These are the parameters that will remain constant between the\\n * two chains. They are supplied on `xcall` and should be asserted on `execute`\\n * @property to - The account that receives funds, in the event of a crosschain call,\\n * will receive funds if the call fails.\\n *\\n * @param originDomain - The originating domain (i.e. where `xcall` is called)\\n * @param destinationDomain - The final domain (i.e. where `execute` / `reconcile` are called)\\\\\\n * @param canonicalDomain - The canonical domain of the asset you are bridging\\n * @param to - The address you are sending funds (and potentially data) to\\n * @param delegate - An address who can execute txs on behalf of `to`, in addition to allowing relayers\\n * @param receiveLocal - If true, will use the local asset on the destination instead of adopted.\\n * @param callData - The data to execute on the receiving chain. If no crosschain call is needed, then leave empty.\\n * @param slippage - Slippage user is willing to accept from original amount in expressed in BPS (i.e. if\\n * a user takes 1% slippage, this is expressed as 1_000)\\n * @param originSender - The msg.sender of the xcall\\n * @param bridgedAmt - The amount sent over the bridge (after potential AMM on xcall)\\n * @param normalizedIn - The amount sent to `xcall`, normalized to 18 decimals\\n * @param nonce - The nonce on the origin domain used to ensure the transferIds are unique\\n * @param canonicalId - The unique identifier of the canonical token corresponding to bridge assets\\n */\\nstruct TransferInfo {\\n  uint32 originDomain;\\n  uint32 destinationDomain;\\n  uint32 canonicalDomain;\\n  address to;\\n  address delegate;\\n  bool receiveLocal;\\n  bytes callData;\\n  uint256 slippage;\\n  address originSender;\\n  uint256 bridgedAmt;\\n  uint256 normalizedIn;\\n  uint256 nonce;\\n  bytes32 canonicalId;\\n}\\n\\n/**\\n * @notice\\n * @param params - The TransferInfo. These are consistent across sending and receiving chains.\\n * @param routers - The routers who you are sending the funds on behalf of.\\n * @param routerSignatures - Signatures belonging to the routers indicating permission to use funds\\n * for the signed transfer ID.\\n * @param sequencer - The sequencer who assigned the router path to this transfer.\\n * @param sequencerSignature - Signature produced by the sequencer for path assignment accountability\\n * for the path that was signed.\\n */\\nstruct ExecuteArgs {\\n  TransferInfo params;\\n  address[] routers;\\n  bytes[] routerSignatures;\\n  address sequencer;\\n  bytes sequencerSignature;\\n}\"\r\n    },\r\n    \"@connext/interfaces/libraries/TokenId.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity ^0.8.0;\\n\\n// ============= Structs =============\\n\\n// Tokens are identified by a TokenId:\\n// domain - 4 byte chain ID of the chain from which the token originates\\n// id - 32 byte identifier of the token address on the origin chain, in that chain's address format\\nstruct TokenId {\\n  uint32 domain;\\n  bytes32 id;\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/Connext/ConnextHeaderReporter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.17;\\n\\nimport { HeaderReporter } from \\\"../HeaderReporter.sol\\\";\\nimport { ConnextReporter } from \\\"./ConnextReporter.sol\\\";\\n\\ncontract ConnextHeaderReporter is HeaderReporter, ConnextReporter {\\n    constructor(\\n        address headerStorage,\\n        uint256 adapterChain,\\n        address connext,\\n        uint32 connextAdapterChain\\n    ) HeaderReporter(headerStorage, adapterChain) ConnextReporter(connext, connextAdapterChain) {} // solhint-disable no-empty-blocks\\n\\n    function _sendPayload(bytes memory payload, address adapter) internal override {\\n        _connextSend(payload, adapter);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/Connext/ConnextReporter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.17;\\n\\nimport { IConnext } from \\\"@connext/interfaces/core/IConnext.sol\\\";\\n\\nabstract contract ConnextReporter {\\n    string public constant PROVIDER = \\\"connext\\\";\\n    IConnext public immutable CONNEXT;\\n    uint32 public immutable CONNEXT_ADAPTER_CHAIN;\\n\\n    event ConnextTransfer(bytes32 transferId);\\n\\n    constructor(address connext, uint32 connextAdapterChain) {\\n        CONNEXT = IConnext(connext);\\n        CONNEXT_ADAPTER_CHAIN = connextAdapterChain;\\n    }\\n\\n    function _connextSend(bytes memory payload, address adapter) internal {\\n        bytes32 transferId = CONNEXT.xcall{ value: msg.value }(\\n            CONNEXT_ADAPTER_CHAIN, // _destination: Domain ID of the destination chain\\n            adapter, // _to: address of the target contract\\n            address(0), // _asset: use address zero for 0-value transfers\\n            msg.sender, // _delegate: address that can revert or forceLocal on destination\\n            0, // _amount: 0 because no funds are being transferred\\n            0, // _slippage: can be anything between 0-10000 because no funds are being transferred\\n            payload // _callData: the encoded calldata to send\\n        );\\n        emit ConnextTransfer(transferId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/HeaderReporter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.17;\\n\\nimport { IHeaderReporter } from \\\"../interfaces/IHeaderReporter.sol\\\";\\nimport { HeaderStorage } from \\\"../utils/HeaderStorage.sol\\\";\\n\\nabstract contract HeaderReporter is IHeaderReporter {\\n    HeaderStorage public immutable HEADER_STORAGE;\\n    uint256 public immutable ADAPTER_CHAIN;\\n\\n    event HeaderReported(address indexed emitter, uint256 indexed blockNumber, bytes32 indexed blockHeader);\\n\\n    /// @dev Constructs base reporter abstracted from specific message transport\\n    /// @param headerStorage HeaderStorage contract on this chain to use for block hash obtaining\\n    /// @param adapterChain Chain ID of the adapter that is served by this reporter\\n    constructor(address headerStorage, uint256 adapterChain) {\\n        HEADER_STORAGE = HeaderStorage(headerStorage);\\n        ADAPTER_CHAIN = adapterChain;\\n    }\\n\\n    function reportHeaders(uint256[] memory blockNumbers, address adapter) external payable {\\n        bytes32[] memory blockHeaders = HEADER_STORAGE.storeBlockHeaders(blockNumbers);\\n        bytes memory payload = abi.encode(blockNumbers, blockHeaders);\\n        _sendPayload(payload, adapter);\\n        for (uint i = 0; i < blockNumbers.length; i++) {\\n            emit HeaderReported(address(this), blockNumbers[i], blockHeaders[i]);\\n        }\\n    }\\n\\n    function _sendPayload(bytes memory payload, address adapter) internal virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHeaderReporter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.17;\\n\\ninterface IHeaderReporter {\\n    /// @dev Reports the given block hash to a different chain according to the reporter configuration.\\n    /// @param blockNumbers Block numbers to report hashes for.\\n    /// @param adapter Adapter contract address to report hashes for.\\n    function reportHeaders(uint256[] memory blockNumbers, address adapter) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/HeaderStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.17;\\n\\ncontract HeaderStorage {\\n    mapping(uint256 => bytes32) public headers;\\n\\n    event HeaderStored(uint256 indexed blockNumber, bytes32 indexed blockHeader);\\n\\n    error HeaderOutOfRange(address emitter, uint256 blockNumber);\\n\\n    /// @dev Stores and returns the header for the given block.\\n    /// @param blockNumber Block number.\\n    /// @return blockHeader Block header stored.\\n    /// @notice Reverts if the given block header was not previously stored and is now out of range.\\n    function storeBlockHeader(uint256 blockNumber) public returns (bytes32 blockHeader) {\\n        blockHeader = headers[blockNumber];\\n        if (blockHeader == 0) {\\n            blockHeader = blockhash(blockNumber);\\n            if (blockHeader == 0) revert HeaderOutOfRange(address(this), blockNumber);\\n            headers[blockNumber] = blockHeader;\\n            emit HeaderStored(blockNumber, blockHeader);\\n        }\\n    }\\n\\n    /// @dev Stores and returns the header for an array of given blocks.\\n    /// @param blockNumbers Array of block numbers.\\n    /// @return Array of block headers.\\n    /// @notice Reverts if the given block header was not previously stored and is now out of range.\\n    function storeBlockHeaders(uint256[] memory blockNumbers) public returns (bytes32[] memory) {\\n        bytes32[] memory blockHeaders = new bytes32[](blockNumbers.length);\\n        for (uint256 i = 0; i < blockNumbers.length; i++) {\\n            blockHeaders[i] = storeBlockHeader(blockNumbers[i]);\\n        }\\n        return blockHeaders;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"headerStorage\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"adapterChain\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"connext\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"connextAdapterChain\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transferId\",\"type\":\"bytes32\"}],\"name\":\"ConnextTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"emitter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"blockHeader\",\"type\":\"bytes32\"}],\"name\":\"HeaderReported\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADAPTER_CHAIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONNEXT\",\"outputs\":[{\"internalType\":\"contract IConnext\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONNEXT_ADAPTER_CHAIN\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HEADER_STORAGE\",\"outputs\":[{\"internalType\":\"contract HeaderStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROVIDER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"blockNumbers\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"reportHeaders\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "ConnextHeaderReporter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "00000000000000000000000022f1fc71a505c0b2bf4d5075801cc5e0ec84b09e00000000000000000000000000000000000000000000000000000000000000640000000000000000000000008898b472c54c31894e3b9bb83cea802a5d0e63c60000000000000000000000000000000000000000000000000000000000000064", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}