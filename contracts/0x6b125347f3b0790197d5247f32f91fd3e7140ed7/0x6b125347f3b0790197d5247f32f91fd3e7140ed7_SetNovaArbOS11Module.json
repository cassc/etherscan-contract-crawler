{"SourceCode": "// File: @arbitrum/nitro-contracts/src/challenge/IChallengeResultReceiver.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IChallengeResultReceiver {\r\n    function completeChallenge(\r\n        uint256 challengeIndex,\r\n        address winner,\r\n        address loser\r\n    ) external;\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/state/ModuleMemoryCompact.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nstruct ModuleMemory {\r\n    uint64 size;\r\n    uint64 maxSize;\r\n    bytes32 merkleRoot;\r\n}\r\n\r\nlibrary ModuleMemoryCompactLib {\r\n    function hash(ModuleMemory memory mem) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"Memory:\", mem.size, mem.maxSize, mem.merkleRoot));\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/state/Module.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nstruct Module {\r\n    bytes32 globalsMerkleRoot;\r\n    ModuleMemory moduleMemory;\r\n    bytes32 tablesMerkleRoot;\r\n    bytes32 functionsMerkleRoot;\r\n    uint32 internalsOffset;\r\n}\r\n\r\nlibrary ModuleLib {\r\n    using ModuleMemoryCompactLib for ModuleMemory;\r\n\r\n    function hash(Module memory mod) internal pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"Module:\",\r\n                    mod.globalsMerkleRoot,\r\n                    mod.moduleMemory.hash(),\r\n                    mod.tablesMerkleRoot,\r\n                    mod.functionsMerkleRoot,\r\n                    mod.internalsOffset\r\n                )\r\n            );\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/state/Instructions.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nstruct Instruction {\r\n    uint16 opcode;\r\n    uint256 argumentData;\r\n}\r\n\r\nlibrary Instructions {\r\n    uint16 internal constant UNREACHABLE = 0x00;\r\n    uint16 internal constant NOP = 0x01;\r\n    uint16 internal constant RETURN = 0x0F;\r\n    uint16 internal constant CALL = 0x10;\r\n    uint16 internal constant CALL_INDIRECT = 0x11;\r\n    uint16 internal constant LOCAL_GET = 0x20;\r\n    uint16 internal constant LOCAL_SET = 0x21;\r\n    uint16 internal constant GLOBAL_GET = 0x23;\r\n    uint16 internal constant GLOBAL_SET = 0x24;\r\n\r\n    uint16 internal constant I32_LOAD = 0x28;\r\n    uint16 internal constant I64_LOAD = 0x29;\r\n    uint16 internal constant F32_LOAD = 0x2A;\r\n    uint16 internal constant F64_LOAD = 0x2B;\r\n    uint16 internal constant I32_LOAD8_S = 0x2C;\r\n    uint16 internal constant I32_LOAD8_U = 0x2D;\r\n    uint16 internal constant I32_LOAD16_S = 0x2E;\r\n    uint16 internal constant I32_LOAD16_U = 0x2F;\r\n    uint16 internal constant I64_LOAD8_S = 0x30;\r\n    uint16 internal constant I64_LOAD8_U = 0x31;\r\n    uint16 internal constant I64_LOAD16_S = 0x32;\r\n    uint16 internal constant I64_LOAD16_U = 0x33;\r\n    uint16 internal constant I64_LOAD32_S = 0x34;\r\n    uint16 internal constant I64_LOAD32_U = 0x35;\r\n\r\n    uint16 internal constant I32_STORE = 0x36;\r\n    uint16 internal constant I64_STORE = 0x37;\r\n    uint16 internal constant F32_STORE = 0x38;\r\n    uint16 internal constant F64_STORE = 0x39;\r\n    uint16 internal constant I32_STORE8 = 0x3A;\r\n    uint16 internal constant I32_STORE16 = 0x3B;\r\n    uint16 internal constant I64_STORE8 = 0x3C;\r\n    uint16 internal constant I64_STORE16 = 0x3D;\r\n    uint16 internal constant I64_STORE32 = 0x3E;\r\n\r\n    uint16 internal constant MEMORY_SIZE = 0x3F;\r\n    uint16 internal constant MEMORY_GROW = 0x40;\r\n\r\n    uint16 internal constant DROP = 0x1A;\r\n    uint16 internal constant SELECT = 0x1B;\r\n    uint16 internal constant I32_CONST = 0x41;\r\n    uint16 internal constant I64_CONST = 0x42;\r\n    uint16 internal constant F32_CONST = 0x43;\r\n    uint16 internal constant F64_CONST = 0x44;\r\n    uint16 internal constant I32_EQZ = 0x45;\r\n    uint16 internal constant I32_RELOP_BASE = 0x46;\r\n    uint16 internal constant IRELOP_EQ = 0;\r\n    uint16 internal constant IRELOP_NE = 1;\r\n    uint16 internal constant IRELOP_LT_S = 2;\r\n    uint16 internal constant IRELOP_LT_U = 3;\r\n    uint16 internal constant IRELOP_GT_S = 4;\r\n    uint16 internal constant IRELOP_GT_U = 5;\r\n    uint16 internal constant IRELOP_LE_S = 6;\r\n    uint16 internal constant IRELOP_LE_U = 7;\r\n    uint16 internal constant IRELOP_GE_S = 8;\r\n    uint16 internal constant IRELOP_GE_U = 9;\r\n    uint16 internal constant IRELOP_LAST = IRELOP_GE_U;\r\n\r\n    uint16 internal constant I64_EQZ = 0x50;\r\n    uint16 internal constant I64_RELOP_BASE = 0x51;\r\n\r\n    uint16 internal constant I32_UNOP_BASE = 0x67;\r\n    uint16 internal constant IUNOP_CLZ = 0;\r\n    uint16 internal constant IUNOP_CTZ = 1;\r\n    uint16 internal constant IUNOP_POPCNT = 2;\r\n    uint16 internal constant IUNOP_LAST = IUNOP_POPCNT;\r\n\r\n    uint16 internal constant I32_ADD = 0x6A;\r\n    uint16 internal constant I32_SUB = 0x6B;\r\n    uint16 internal constant I32_MUL = 0x6C;\r\n    uint16 internal constant I32_DIV_S = 0x6D;\r\n    uint16 internal constant I32_DIV_U = 0x6E;\r\n    uint16 internal constant I32_REM_S = 0x6F;\r\n    uint16 internal constant I32_REM_U = 0x70;\r\n    uint16 internal constant I32_AND = 0x71;\r\n    uint16 internal constant I32_OR = 0x72;\r\n    uint16 internal constant I32_XOR = 0x73;\r\n    uint16 internal constant I32_SHL = 0x74;\r\n    uint16 internal constant I32_SHR_S = 0x75;\r\n    uint16 internal constant I32_SHR_U = 0x76;\r\n    uint16 internal constant I32_ROTL = 0x77;\r\n    uint16 internal constant I32_ROTR = 0x78;\r\n\r\n    uint16 internal constant I64_UNOP_BASE = 0x79;\r\n\r\n    uint16 internal constant I64_ADD = 0x7C;\r\n    uint16 internal constant I64_SUB = 0x7D;\r\n    uint16 internal constant I64_MUL = 0x7E;\r\n    uint16 internal constant I64_DIV_S = 0x7F;\r\n    uint16 internal constant I64_DIV_U = 0x80;\r\n    uint16 internal constant I64_REM_S = 0x81;\r\n    uint16 internal constant I64_REM_U = 0x82;\r\n    uint16 internal constant I64_AND = 0x83;\r\n    uint16 internal constant I64_OR = 0x84;\r\n    uint16 internal constant I64_XOR = 0x85;\r\n    uint16 internal constant I64_SHL = 0x86;\r\n    uint16 internal constant I64_SHR_S = 0x87;\r\n    uint16 internal constant I64_SHR_U = 0x88;\r\n    uint16 internal constant I64_ROTL = 0x89;\r\n    uint16 internal constant I64_ROTR = 0x8A;\r\n\r\n    uint16 internal constant I32_WRAP_I64 = 0xA7;\r\n    uint16 internal constant I64_EXTEND_I32_S = 0xAC;\r\n    uint16 internal constant I64_EXTEND_I32_U = 0xAD;\r\n\r\n    uint16 internal constant I32_REINTERPRET_F32 = 0xBC;\r\n    uint16 internal constant I64_REINTERPRET_F64 = 0xBD;\r\n    uint16 internal constant F32_REINTERPRET_I32 = 0xBE;\r\n    uint16 internal constant F64_REINTERPRET_I64 = 0xBF;\r\n\r\n    uint16 internal constant I32_EXTEND_8S = 0xC0;\r\n    uint16 internal constant I32_EXTEND_16S = 0xC1;\r\n    uint16 internal constant I64_EXTEND_8S = 0xC2;\r\n    uint16 internal constant I64_EXTEND_16S = 0xC3;\r\n    uint16 internal constant I64_EXTEND_32S = 0xC4;\r\n\r\n    uint16 internal constant INIT_FRAME = 0x8002;\r\n    uint16 internal constant ARBITRARY_JUMP = 0x8003;\r\n    uint16 internal constant ARBITRARY_JUMP_IF = 0x8004;\r\n    uint16 internal constant MOVE_FROM_STACK_TO_INTERNAL = 0x8005;\r\n    uint16 internal constant MOVE_FROM_INTERNAL_TO_STACK = 0x8006;\r\n    uint16 internal constant DUP = 0x8008;\r\n    uint16 internal constant CROSS_MODULE_CALL = 0x8009;\r\n    uint16 internal constant CALLER_MODULE_INTERNAL_CALL = 0x800A;\r\n\r\n    uint16 internal constant GET_GLOBAL_STATE_BYTES32 = 0x8010;\r\n    uint16 internal constant SET_GLOBAL_STATE_BYTES32 = 0x8011;\r\n    uint16 internal constant GET_GLOBAL_STATE_U64 = 0x8012;\r\n    uint16 internal constant SET_GLOBAL_STATE_U64 = 0x8013;\r\n\r\n    uint16 internal constant READ_PRE_IMAGE = 0x8020;\r\n    uint16 internal constant READ_INBOX_MESSAGE = 0x8021;\r\n    uint16 internal constant HALT_AND_SET_FINISHED = 0x8022;\r\n\r\n    uint256 internal constant INBOX_INDEX_SEQUENCER = 0;\r\n    uint256 internal constant INBOX_INDEX_DELAYED = 1;\r\n\r\n    function hash(Instruction memory inst) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"Instruction:\", inst.opcode, inst.argumentData));\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/state/Value.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nenum ValueType {\r\n    I32,\r\n    I64,\r\n    F32,\r\n    F64,\r\n    REF_NULL,\r\n    FUNC_REF,\r\n    INTERNAL_REF\r\n}\r\n\r\nstruct Value {\r\n    ValueType valueType;\r\n    uint256 contents;\r\n}\r\n\r\nlibrary ValueLib {\r\n    function hash(Value memory val) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"Value:\", val.valueType, val.contents));\r\n    }\r\n\r\n    function maxValueType() internal pure returns (ValueType) {\r\n        return ValueType.INTERNAL_REF;\r\n    }\r\n\r\n    function assumeI32(Value memory val) internal pure returns (uint32) {\r\n        uint256 uintval = uint256(val.contents);\r\n        require(val.valueType == ValueType.I32, \"NOT_I32\");\r\n        require(uintval < (1 << 32), \"BAD_I32\");\r\n        return uint32(uintval);\r\n    }\r\n\r\n    function assumeI64(Value memory val) internal pure returns (uint64) {\r\n        uint256 uintval = uint256(val.contents);\r\n        require(val.valueType == ValueType.I64, \"NOT_I64\");\r\n        require(uintval < (1 << 64), \"BAD_I64\");\r\n        return uint64(uintval);\r\n    }\r\n\r\n    function newRefNull() internal pure returns (Value memory) {\r\n        return Value({valueType: ValueType.REF_NULL, contents: 0});\r\n    }\r\n\r\n    function newI32(uint32 x) internal pure returns (Value memory) {\r\n        return Value({valueType: ValueType.I32, contents: uint256(x)});\r\n    }\r\n\r\n    function newI64(uint64 x) internal pure returns (Value memory) {\r\n        return Value({valueType: ValueType.I64, contents: uint256(x)});\r\n    }\r\n\r\n    function newBoolean(bool x) internal pure returns (Value memory) {\r\n        if (x) {\r\n            return newI32(uint32(1));\r\n        } else {\r\n            return newI32(uint32(0));\r\n        }\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/state/StackFrame.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nstruct StackFrame {\r\n    Value returnPc;\r\n    bytes32 localsMerkleRoot;\r\n    uint32 callerModule;\r\n    uint32 callerModuleInternals;\r\n}\r\n\r\nstruct StackFrameWindow {\r\n    StackFrame[] proved;\r\n    bytes32 remainingHash;\r\n}\r\n\r\nlibrary StackFrameLib {\r\n    using ValueLib for Value;\r\n\r\n    function hash(StackFrame memory frame) internal pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"Stack frame:\",\r\n                    frame.returnPc.hash(),\r\n                    frame.localsMerkleRoot,\r\n                    frame.callerModule,\r\n                    frame.callerModuleInternals\r\n                )\r\n            );\r\n    }\r\n\r\n    function hash(StackFrameWindow memory window) internal pure returns (bytes32 h) {\r\n        h = window.remainingHash;\r\n        for (uint256 i = 0; i < window.proved.length; i++) {\r\n            h = keccak256(abi.encodePacked(\"Stack frame stack:\", hash(window.proved[i]), h));\r\n        }\r\n    }\r\n\r\n    function peek(StackFrameWindow memory window) internal pure returns (StackFrame memory) {\r\n        require(window.proved.length == 1, \"BAD_WINDOW_LENGTH\");\r\n        return window.proved[0];\r\n    }\r\n\r\n    function pop(StackFrameWindow memory window) internal pure returns (StackFrame memory frame) {\r\n        require(window.proved.length == 1, \"BAD_WINDOW_LENGTH\");\r\n        frame = window.proved[0];\r\n        window.proved = new StackFrame[](0);\r\n    }\r\n\r\n    function push(StackFrameWindow memory window, StackFrame memory frame) internal pure {\r\n        StackFrame[] memory newProved = new StackFrame[](window.proved.length + 1);\r\n        for (uint256 i = 0; i < window.proved.length; i++) {\r\n            newProved[i] = window.proved[i];\r\n        }\r\n        newProved[window.proved.length] = frame;\r\n        window.proved = newProved;\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/state/ValueArray.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nstruct ValueArray {\r\n    Value[] inner;\r\n}\r\n\r\nlibrary ValueArrayLib {\r\n    function get(ValueArray memory arr, uint256 index) internal pure returns (Value memory) {\r\n        return arr.inner[index];\r\n    }\r\n\r\n    function set(\r\n        ValueArray memory arr,\r\n        uint256 index,\r\n        Value memory val\r\n    ) internal pure {\r\n        arr.inner[index] = val;\r\n    }\r\n\r\n    function length(ValueArray memory arr) internal pure returns (uint256) {\r\n        return arr.inner.length;\r\n    }\r\n\r\n    function push(ValueArray memory arr, Value memory val) internal pure {\r\n        Value[] memory newInner = new Value[](arr.inner.length + 1);\r\n        for (uint256 i = 0; i < arr.inner.length; i++) {\r\n            newInner[i] = arr.inner[i];\r\n        }\r\n        newInner[arr.inner.length] = val;\r\n        arr.inner = newInner;\r\n    }\r\n\r\n    function pop(ValueArray memory arr) internal pure returns (Value memory popped) {\r\n        popped = arr.inner[arr.inner.length - 1];\r\n        Value[] memory newInner = new Value[](arr.inner.length - 1);\r\n        for (uint256 i = 0; i < newInner.length; i++) {\r\n            newInner[i] = arr.inner[i];\r\n        }\r\n        arr.inner = newInner;\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/state/ValueStack.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nstruct ValueStack {\r\n    ValueArray proved;\r\n    bytes32 remainingHash;\r\n}\r\n\r\nlibrary ValueStackLib {\r\n    using ValueLib for Value;\r\n    using ValueArrayLib for ValueArray;\r\n\r\n    function hash(ValueStack memory stack) internal pure returns (bytes32 h) {\r\n        h = stack.remainingHash;\r\n        uint256 len = stack.proved.length();\r\n        for (uint256 i = 0; i < len; i++) {\r\n            h = keccak256(abi.encodePacked(\"Value stack:\", stack.proved.get(i).hash(), h));\r\n        }\r\n    }\r\n\r\n    function peek(ValueStack memory stack) internal pure returns (Value memory) {\r\n        uint256 len = stack.proved.length();\r\n        return stack.proved.get(len - 1);\r\n    }\r\n\r\n    function pop(ValueStack memory stack) internal pure returns (Value memory) {\r\n        return stack.proved.pop();\r\n    }\r\n\r\n    function push(ValueStack memory stack, Value memory val) internal pure {\r\n        return stack.proved.push(val);\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/state/Machine.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\nenum MachineStatus {\r\n    RUNNING,\r\n    FINISHED,\r\n    ERRORED,\r\n    TOO_FAR\r\n}\r\n\r\nstruct Machine {\r\n    MachineStatus status;\r\n    ValueStack valueStack;\r\n    ValueStack internalStack;\r\n    StackFrameWindow frameStack;\r\n    bytes32 globalStateHash;\r\n    uint32 moduleIdx;\r\n    uint32 functionIdx;\r\n    uint32 functionPc;\r\n    bytes32 modulesRoot;\r\n}\r\n\r\nlibrary MachineLib {\r\n    using StackFrameLib for StackFrameWindow;\r\n    using ValueStackLib for ValueStack;\r\n\r\n    function hash(Machine memory mach) internal pure returns (bytes32) {\r\n        // Warning: the non-running hashes are replicated in Challenge\r\n        if (mach.status == MachineStatus.RUNNING) {\r\n            return\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"Machine running:\",\r\n                        mach.valueStack.hash(),\r\n                        mach.internalStack.hash(),\r\n                        mach.frameStack.hash(),\r\n                        mach.globalStateHash,\r\n                        mach.moduleIdx,\r\n                        mach.functionIdx,\r\n                        mach.functionPc,\r\n                        mach.modulesRoot\r\n                    )\r\n                );\r\n        } else if (mach.status == MachineStatus.FINISHED) {\r\n            return keccak256(abi.encodePacked(\"Machine finished:\", mach.globalStateHash));\r\n        } else if (mach.status == MachineStatus.ERRORED) {\r\n            return keccak256(abi.encodePacked(\"Machine errored:\"));\r\n        } else if (mach.status == MachineStatus.TOO_FAR) {\r\n            return keccak256(abi.encodePacked(\"Machine too far:\"));\r\n        } else {\r\n            revert(\"BAD_MACH_STATUS\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/state/GlobalState.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nstruct GlobalState {\r\n    bytes32[2] bytes32Vals;\r\n    uint64[2] u64Vals;\r\n}\r\n\r\nlibrary GlobalStateLib {\r\n    uint16 internal constant BYTES32_VALS_NUM = 2;\r\n    uint16 internal constant U64_VALS_NUM = 2;\r\n\r\n    function hash(GlobalState memory state) internal pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"Global state:\",\r\n                    state.bytes32Vals[0],\r\n                    state.bytes32Vals[1],\r\n                    state.u64Vals[0],\r\n                    state.u64Vals[1]\r\n                )\r\n            );\r\n    }\r\n\r\n    function getBlockHash(GlobalState memory state) internal pure returns (bytes32) {\r\n        return state.bytes32Vals[0];\r\n    }\r\n\r\n    function getSendRoot(GlobalState memory state) internal pure returns (bytes32) {\r\n        return state.bytes32Vals[1];\r\n    }\r\n\r\n    function getInboxPosition(GlobalState memory state) internal pure returns (uint64) {\r\n        return state.u64Vals[0];\r\n    }\r\n\r\n    function getPositionInMessage(GlobalState memory state) internal pure returns (uint64) {\r\n        return state.u64Vals[1];\r\n    }\r\n\r\n    function isEmpty(GlobalState calldata state) internal pure returns (bool) {\r\n        return (state.bytes32Vals[0] == bytes32(0) &&\r\n            state.bytes32Vals[1] == bytes32(0) &&\r\n            state.u64Vals[0] == 0 &&\r\n            state.u64Vals[1] == 0);\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/challenge/ChallengeLib.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nlibrary ChallengeLib {\r\n    using MachineLib for Machine;\r\n    using ChallengeLib for Challenge;\r\n\r\n    /// @dev It's assumed that that uninitialzed challenges have mode NONE\r\n    enum ChallengeMode {\r\n        NONE,\r\n        BLOCK,\r\n        EXECUTION\r\n    }\r\n\r\n    struct Participant {\r\n        address addr;\r\n        uint256 timeLeft;\r\n    }\r\n\r\n    struct Challenge {\r\n        Participant current;\r\n        Participant next;\r\n        uint256 lastMoveTimestamp;\r\n        bytes32 wasmModuleRoot;\r\n        bytes32 challengeStateHash;\r\n        uint64 maxInboxMessages;\r\n        ChallengeMode mode;\r\n    }\r\n\r\n    struct SegmentSelection {\r\n        uint256 oldSegmentsStart;\r\n        uint256 oldSegmentsLength;\r\n        bytes32[] oldSegments;\r\n        uint256 challengePosition;\r\n    }\r\n\r\n    function timeUsedSinceLastMove(Challenge storage challenge) internal view returns (uint256) {\r\n        return block.timestamp - challenge.lastMoveTimestamp;\r\n    }\r\n\r\n    function isTimedOut(Challenge storage challenge) internal view returns (bool) {\r\n        return challenge.timeUsedSinceLastMove() > challenge.current.timeLeft;\r\n    }\r\n\r\n    function getStartMachineHash(bytes32 globalStateHash, bytes32 wasmModuleRoot)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        // Start the value stack with the function call ABI for the entrypoint\r\n        Value[] memory startingValues = new Value[](3);\r\n        startingValues[0] = ValueLib.newRefNull();\r\n        startingValues[1] = ValueLib.newI32(0);\r\n        startingValues[2] = ValueLib.newI32(0);\r\n        ValueArray memory valuesArray = ValueArray({inner: startingValues});\r\n        ValueStack memory values = ValueStack({proved: valuesArray, remainingHash: 0});\r\n        ValueStack memory internalStack;\r\n        StackFrameWindow memory frameStack;\r\n\r\n        Machine memory mach = Machine({\r\n            status: MachineStatus.RUNNING,\r\n            valueStack: values,\r\n            internalStack: internalStack,\r\n            frameStack: frameStack,\r\n            globalStateHash: globalStateHash,\r\n            moduleIdx: 0,\r\n            functionIdx: 0,\r\n            functionPc: 0,\r\n            modulesRoot: wasmModuleRoot\r\n        });\r\n        return mach.hash();\r\n    }\r\n\r\n    function getEndMachineHash(MachineStatus status, bytes32 globalStateHash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        if (status == MachineStatus.FINISHED) {\r\n            return keccak256(abi.encodePacked(\"Machine finished:\", globalStateHash));\r\n        } else if (status == MachineStatus.ERRORED) {\r\n            return keccak256(abi.encodePacked(\"Machine errored:\"));\r\n        } else if (status == MachineStatus.TOO_FAR) {\r\n            return keccak256(abi.encodePacked(\"Machine too far:\"));\r\n        } else {\r\n            revert(\"BAD_BLOCK_STATUS\");\r\n        }\r\n    }\r\n\r\n    function extractChallengeSegment(SegmentSelection calldata selection)\r\n        internal\r\n        pure\r\n        returns (uint256 segmentStart, uint256 segmentLength)\r\n    {\r\n        uint256 oldChallengeDegree = selection.oldSegments.length - 1;\r\n        segmentLength = selection.oldSegmentsLength / oldChallengeDegree;\r\n        // Intentionally done before challengeLength is potentially added to for the final segment\r\n        segmentStart = selection.oldSegmentsStart + segmentLength * selection.challengePosition;\r\n        if (selection.challengePosition == selection.oldSegments.length - 2) {\r\n            segmentLength += selection.oldSegmentsLength % oldChallengeDegree;\r\n        }\r\n    }\r\n\r\n    function hashChallengeState(\r\n        uint256 segmentsStart,\r\n        uint256 segmentsLength,\r\n        bytes32[] memory segments\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(segmentsStart, segmentsLength, segments));\r\n    }\r\n\r\n    function blockStateHash(MachineStatus status, bytes32 globalStateHash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        if (status == MachineStatus.FINISHED) {\r\n            return keccak256(abi.encodePacked(\"Block state:\", globalStateHash));\r\n        } else if (status == MachineStatus.ERRORED) {\r\n            return keccak256(abi.encodePacked(\"Block state, errored:\", globalStateHash));\r\n        } else if (status == MachineStatus.TOO_FAR) {\r\n            return keccak256(abi.encodePacked(\"Block state, too far:\"));\r\n        } else {\r\n            revert(\"BAD_BLOCK_STATUS\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/rollup/Node.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nstruct ExecutionState {\r\n    GlobalState globalState;\r\n    MachineStatus machineStatus;\r\n}\r\n\r\nstruct Assertion {\r\n    ExecutionState beforeState;\r\n    ExecutionState afterState;\r\n    uint64 numBlocks;\r\n}\r\n\r\nstruct Node {\r\n    // Hash of the state of the chain as of this node\r\n    bytes32 stateHash;\r\n    // Hash of the data that can be challenged\r\n    bytes32 challengeHash;\r\n    // Hash of the data that will be committed if this node is confirmed\r\n    bytes32 confirmData;\r\n    // Index of the node previous to this one\r\n    uint64 prevNum;\r\n    // Deadline at which this node can be confirmed\r\n    uint64 deadlineBlock;\r\n    // Deadline at which a child of this node can be confirmed\r\n    uint64 noChildConfirmedBeforeBlock;\r\n    // Number of stakers staked on this node. This includes real stakers and zombies\r\n    uint64 stakerCount;\r\n    // Number of stakers staked on a child node. This includes real stakers and zombies\r\n    uint64 childStakerCount;\r\n    // This value starts at zero and is set to a value when the first child is created. After that it is constant until the node is destroyed or the owner destroys pending nodes\r\n    uint64 firstChildBlock;\r\n    // The number of the latest child of this node to be created\r\n    uint64 latestChildNumber;\r\n    // The block number when this node was created\r\n    uint64 createdAtBlock;\r\n    // A hash of all the data needed to determine this node's validity, to protect against reorgs\r\n    bytes32 nodeHash;\r\n}\r\n\r\n/**\r\n * @notice Utility functions for Node\r\n */\r\nlibrary NodeLib {\r\n    /**\r\n     * @notice Initialize a Node\r\n     * @param _stateHash Initial value of stateHash\r\n     * @param _challengeHash Initial value of challengeHash\r\n     * @param _confirmData Initial value of confirmData\r\n     * @param _prevNum Initial value of prevNum\r\n     * @param _deadlineBlock Initial value of deadlineBlock\r\n     * @param _nodeHash Initial value of nodeHash\r\n     */\r\n    function createNode(\r\n        bytes32 _stateHash,\r\n        bytes32 _challengeHash,\r\n        bytes32 _confirmData,\r\n        uint64 _prevNum,\r\n        uint64 _deadlineBlock,\r\n        bytes32 _nodeHash\r\n    ) internal view returns (Node memory) {\r\n        Node memory node;\r\n        node.stateHash = _stateHash;\r\n        node.challengeHash = _challengeHash;\r\n        node.confirmData = _confirmData;\r\n        node.prevNum = _prevNum;\r\n        node.deadlineBlock = _deadlineBlock;\r\n        node.noChildConfirmedBeforeBlock = _deadlineBlock;\r\n        node.createdAtBlock = uint64(block.number);\r\n        node.nodeHash = _nodeHash;\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * @notice Update child properties\r\n     * @param number The child number to set\r\n     */\r\n    function childCreated(Node storage self, uint64 number) internal {\r\n        if (self.firstChildBlock == 0) {\r\n            self.firstChildBlock = uint64(block.number);\r\n        }\r\n        self.latestChildNumber = number;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the child confirmed deadline\r\n     * @param deadline The new deadline to set\r\n     */\r\n    function newChildConfirmDeadline(Node storage self, uint64 deadline) internal {\r\n        self.noChildConfirmedBeforeBlock = deadline;\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether the current block number has met or passed the node's deadline\r\n     */\r\n    function requirePastDeadline(Node memory self) internal view {\r\n        require(block.number >= self.deadlineBlock, \"BEFORE_DEADLINE\");\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether the current block number has met or passed deadline for children of this node to be confirmed\r\n     */\r\n    function requirePastChildConfirmDeadline(Node memory self) internal view {\r\n        require(block.number >= self.noChildConfirmedBeforeBlock, \"CHILD_TOO_RECENT\");\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/libraries/IGasRefunder.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.6.9 <0.9.0;\r\n\r\ninterface IGasRefunder {\r\n    function onGasSpent(\r\n        address payable spender,\r\n        uint256 gasUsed,\r\n        uint256 calldataSize\r\n    ) external returns (bool success);\r\n}\r\n\r\nabstract contract GasRefundEnabled {\r\n    /// @dev this refunds the sender for execution costs of the tx\r\n    /// calldata costs are only refunded if `msg.sender == tx.origin` to guarantee the value refunded relates to charging\r\n    /// for the `tx.input`. this avoids a possible attack where you generate large calldata from a contract and get over-refunded\r\n    modifier refundsGas(IGasRefunder gasRefunder) {\r\n        uint256 startGasLeft = gasleft();\r\n        _;\r\n        if (address(gasRefunder) != address(0)) {\r\n            uint256 calldataSize = msg.data.length;\r\n            uint256 calldataWords = (calldataSize + 31) / 32;\r\n            // account for the CALLDATACOPY cost of the proxy contract, including the memory expansion cost\r\n            startGasLeft += calldataWords * 6 + (calldataWords**2) / 512;\r\n            // if triggered in a contract call, the spender may be overrefunded by appending dummy data to the call\r\n            // so we check if it is a top level call, which would mean the sender paid calldata as part of tx.input\r\n            // solhint-disable-next-line avoid-tx-origin\r\n            if (msg.sender != tx.origin) {\r\n                // We can't be sure if this calldata came from the top level tx,\r\n                // so to be safe we tell the gas refunder there was no calldata.\r\n                calldataSize = 0;\r\n            }\r\n            gasRefunder.onGasSpent(payable(msg.sender), startGasLeft - gasleft(), calldataSize);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/bridge/IDelayedMessageProvider.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.6.9 <0.9.0;\r\n\r\ninterface IDelayedMessageProvider {\r\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\r\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\r\n\r\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\r\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\r\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/bridge/IOwnable.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.4.21 <0.9.0;\r\n\r\ninterface IOwnable {\r\n    function owner() external view returns (address);\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/bridge/IBridge.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.6.9 <0.9.0;\r\n\r\n\r\ninterface IBridge {\r\n    event MessageDelivered(\r\n        uint256 indexed messageIndex,\r\n        bytes32 indexed beforeInboxAcc,\r\n        address inbox,\r\n        uint8 kind,\r\n        address sender,\r\n        bytes32 messageDataHash,\r\n        uint256 baseFeeL1,\r\n        uint64 timestamp\r\n    );\r\n\r\n    event BridgeCallTriggered(\r\n        address indexed outbox,\r\n        address indexed to,\r\n        uint256 value,\r\n        bytes data\r\n    );\r\n\r\n    event InboxToggle(address indexed inbox, bool enabled);\r\n\r\n    event OutboxToggle(address indexed outbox, bool enabled);\r\n\r\n    event SequencerInboxUpdated(address newSequencerInbox);\r\n\r\n    function allowedDelayedInboxList(uint256) external returns (address);\r\n\r\n    function allowedOutboxList(uint256) external returns (address);\r\n\r\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\r\n    function delayedInboxAccs(uint256) external view returns (bytes32);\r\n\r\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\r\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\r\n\r\n    function rollup() external view returns (IOwnable);\r\n\r\n    function sequencerInbox() external view returns (address);\r\n\r\n    function activeOutbox() external view returns (address);\r\n\r\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\r\n\r\n    function allowedOutboxes(address outbox) external view returns (bool);\r\n\r\n    function sequencerReportedSubMessageCount() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Enqueue a message in the delayed inbox accumulator.\r\n     *      These messages are later sequenced in the SequencerInbox, either\r\n     *      by the sequencer as part of a normal batch, or by force inclusion.\r\n     */\r\n    function enqueueDelayedMessage(\r\n        uint8 kind,\r\n        address sender,\r\n        bytes32 messageDataHash\r\n    ) external payable returns (uint256);\r\n\r\n    function executeCall(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bool success, bytes memory returnData);\r\n\r\n    function delayedMessageCount() external view returns (uint256);\r\n\r\n    function sequencerMessageCount() external view returns (uint256);\r\n\r\n    // ---------- onlySequencerInbox functions ----------\r\n\r\n    function enqueueSequencerMessage(\r\n        bytes32 dataHash,\r\n        uint256 afterDelayedMessagesRead,\r\n        uint256 prevMessageCount,\r\n        uint256 newMessageCount\r\n    )\r\n        external\r\n        returns (\r\n            uint256 seqMessageIndex,\r\n            bytes32 beforeAcc,\r\n            bytes32 delayedAcc,\r\n            bytes32 acc\r\n        );\r\n\r\n    /**\r\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\r\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\r\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\r\n     *      every delayed inbox or every sequencer inbox call.\r\n     */\r\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\r\n        external\r\n        returns (uint256 msgNum);\r\n\r\n    // ---------- onlyRollupOrOwner functions ----------\r\n\r\n    function setSequencerInbox(address _sequencerInbox) external;\r\n\r\n    function setDelayedInbox(address inbox, bool enabled) external;\r\n\r\n    function setOutbox(address inbox, bool enabled) external;\r\n\r\n    // ---------- initializer ----------\r\n\r\n    function initialize(IOwnable rollup_) external;\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/rollup/IRollupEventInbox.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IRollupEventInbox {\r\n    function bridge() external view returns (IBridge);\r\n\r\n    function initialize(IBridge _bridge) external;\r\n\r\n    function rollup() external view returns (address);\r\n\r\n    function rollupInitialized(uint256 chainId, string calldata chainConfig) external;\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/bridge/IOutbox.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.6.9 <0.9.0;\r\n\r\n\r\ninterface IOutbox {\r\n    event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash);\r\n    event OutBoxTransactionExecuted(\r\n        address indexed to,\r\n        address indexed l2Sender,\r\n        uint256 indexed zero,\r\n        uint256 transactionIndex\r\n    );\r\n\r\n    function rollup() external view returns (address); // the rollup contract\r\n\r\n    function bridge() external view returns (IBridge); // the bridge contract\r\n\r\n    function spent(uint256) external view returns (bytes32); // packed spent bitmap\r\n\r\n    function roots(bytes32) external view returns (bytes32); // maps root hashes => L2 block hash\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function OUTBOX_VERSION() external view returns (uint128); // the outbox version\r\n\r\n    function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\r\n\r\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\r\n    ///         When the return value is zero, that means this is a system message\r\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\r\n    function l2ToL1Sender() external view returns (address);\r\n\r\n    /// @return l2Block return L2 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\r\n    function l2ToL1Block() external view returns (uint256);\r\n\r\n    /// @return l1Block return L1 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\r\n    function l2ToL1EthBlock() external view returns (uint256);\r\n\r\n    /// @return timestamp return L2 timestamp when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\r\n    function l2ToL1Timestamp() external view returns (uint256);\r\n\r\n    /// @return outputId returns the unique output identifier of the L2 to L1 tx or 0 if no L2 to L1 transaction is active\r\n    function l2ToL1OutputId() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Executes a messages in an Outbox entry.\r\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\r\n     *      is only created once the rollup confirms the respective assertion.\r\n     * @dev it is not possible to execute any L2-to-L1 transaction which contains data\r\n     *      to a contract address without any code (as enforced by the Bridge contract).\r\n     * @param proof Merkle proof of message inclusion in send root\r\n     * @param index Merkle path to message\r\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\r\n     * @param to destination address for L1 contract call\r\n     * @param l2Block l2 block number at which sendTxToL1 call was made\r\n     * @param l1Block l1 block number at which sendTxToL1 call was made\r\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\r\n     * @param value wei in L1 message\r\n     * @param data abi-encoded L1 message data\r\n     */\r\n    function executeTransaction(\r\n        bytes32[] calldata proof,\r\n        uint256 index,\r\n        address l2Sender,\r\n        address to,\r\n        uint256 l2Block,\r\n        uint256 l1Block,\r\n        uint256 l2Timestamp,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     *  @dev function used to simulate the result of a particular function call from the outbox\r\n     *       it is useful for things such as gas estimates. This function includes all costs except for\r\n     *       proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\r\n     *       not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\r\n     *       We can't include the cost of proof validation since this is intended to be used to simulate txs\r\n     *       that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\r\n     *       to confirm a pending merkle root, but that would be less practical for integrating with tooling.\r\n     *       It is only possible to trigger it when the msg sender is address zero, which should be impossible\r\n     *       unless under simulation in an eth_call or eth_estimateGas\r\n     */\r\n    function executeTransactionSimulation(\r\n        uint256 index,\r\n        address l2Sender,\r\n        address to,\r\n        uint256 l2Block,\r\n        uint256 l1Block,\r\n        uint256 l2Timestamp,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @param index Merkle path to message\r\n     * @return true if the message has been spent\r\n     */\r\n    function isSpent(uint256 index) external view returns (bool);\r\n\r\n    function calculateItemHash(\r\n        address l2Sender,\r\n        address to,\r\n        uint256 l2Block,\r\n        uint256 l1Block,\r\n        uint256 l2Timestamp,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external pure returns (bytes32);\r\n\r\n    function calculateMerkleRoot(\r\n        bytes32[] memory proof,\r\n        uint256 path,\r\n        bytes32 item\r\n    ) external pure returns (bytes32);\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/bridge/ISequencerInbox.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.6.9 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\ninterface ISequencerInbox is IDelayedMessageProvider {\r\n    struct MaxTimeVariation {\r\n        uint256 delayBlocks;\r\n        uint256 futureBlocks;\r\n        uint256 delaySeconds;\r\n        uint256 futureSeconds;\r\n    }\r\n\r\n    struct TimeBounds {\r\n        uint64 minTimestamp;\r\n        uint64 maxTimestamp;\r\n        uint64 minBlockNumber;\r\n        uint64 maxBlockNumber;\r\n    }\r\n\r\n    enum BatchDataLocation {\r\n        TxInput,\r\n        SeparateBatchEvent,\r\n        NoData\r\n    }\r\n\r\n    event SequencerBatchDelivered(\r\n        uint256 indexed batchSequenceNumber,\r\n        bytes32 indexed beforeAcc,\r\n        bytes32 indexed afterAcc,\r\n        bytes32 delayedAcc,\r\n        uint256 afterDelayedMessagesRead,\r\n        TimeBounds timeBounds,\r\n        BatchDataLocation dataLocation\r\n    );\r\n\r\n    event OwnerFunctionCalled(uint256 indexed id);\r\n\r\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\r\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\r\n\r\n    /// @dev a valid keyset was added\r\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\r\n\r\n    /// @dev a keyset was invalidated\r\n    event InvalidateKeyset(bytes32 indexed keysetHash);\r\n\r\n    function totalDelayedMessagesRead() external view returns (uint256);\r\n\r\n    function bridge() external view returns (IBridge);\r\n\r\n    /// @dev The size of the batch header\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function HEADER_LENGTH() external view returns (uint256);\r\n\r\n    /// @dev If the first batch data byte after the header has this bit set,\r\n    ///      the sequencer inbox has authenticated the data. Currently not used.\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DATA_AUTHENTICATED_FLAG() external view returns (bytes1);\r\n\r\n    function rollup() external view returns (IOwnable);\r\n\r\n    function isBatchPoster(address) external view returns (bool);\r\n\r\n    function isSequencer(address) external view returns (bool);\r\n\r\n    struct DasKeySetInfo {\r\n        bool isValidKeyset;\r\n        uint64 creationBlock;\r\n    }\r\n\r\n    function maxTimeVariation()\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function dasKeySetInfo(bytes32) external view returns (bool, uint64);\r\n\r\n    /// @notice Remove force inclusion delay after a L1 chainId fork\r\n    function removeDelayAfterFork() external;\r\n\r\n    /// @notice Force messages from the delayed inbox to be included in the chain\r\n    ///         Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and\r\n    ///         maxTimeVariation.delaySeconds has elapsed. As part of normal behaviour the sequencer will include these\r\n    ///         messages so it's only necessary to call this if the sequencer is down, or not including any delayed messages.\r\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\r\n    /// @param kind The kind of the last message to be included\r\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\r\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\r\n    /// @param sender The sender of the last message to be included\r\n    /// @param messageDataHash The messageDataHash of the last message to be included\r\n    function forceInclusion(\r\n        uint256 _totalDelayedMessagesRead,\r\n        uint8 kind,\r\n        uint64[2] calldata l1BlockAndTime,\r\n        uint256 baseFeeL1,\r\n        address sender,\r\n        bytes32 messageDataHash\r\n    ) external;\r\n\r\n    function inboxAccs(uint256 index) external view returns (bytes32);\r\n\r\n    function batchCount() external view returns (uint256);\r\n\r\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool);\r\n\r\n    /// @notice the creation block is intended to still be available after a keyset is deleted\r\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256);\r\n\r\n    // ---------- BatchPoster functions ----------\r\n\r\n    function addSequencerL2BatchFromOrigin(\r\n        uint256 sequenceNumber,\r\n        bytes calldata data,\r\n        uint256 afterDelayedMessagesRead,\r\n        IGasRefunder gasRefunder\r\n    ) external;\r\n\r\n    function addSequencerL2Batch(\r\n        uint256 sequenceNumber,\r\n        bytes calldata data,\r\n        uint256 afterDelayedMessagesRead,\r\n        IGasRefunder gasRefunder,\r\n        uint256 prevMessageCount,\r\n        uint256 newMessageCount\r\n    ) external;\r\n\r\n    // ---------- onlyRollupOrOwner functions ----------\r\n\r\n    /**\r\n     * @notice Set max delay for sequencer inbox\r\n     * @param maxTimeVariation_ the maximum time variation parameters\r\n     */\r\n    function setMaxTimeVariation(MaxTimeVariation memory maxTimeVariation_) external;\r\n\r\n    /**\r\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\r\n     * @param addr the address\r\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\r\n     */\r\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external;\r\n\r\n    /**\r\n     * @notice Makes Data Availability Service keyset valid\r\n     * @param keysetBytes bytes of the serialized keyset\r\n     */\r\n    function setValidKeyset(bytes calldata keysetBytes) external;\r\n\r\n    /**\r\n     * @notice Invalidates a Data Availability Service keyset\r\n     * @param ksHash hash of the keyset\r\n     */\r\n    function invalidateKeysetHash(bytes32 ksHash) external;\r\n\r\n    /**\r\n     * @notice Updates whether an address is authorized to be a sequencer.\r\n     * @dev The IsSequencer information is used only off-chain by the nitro node to validate sequencer feed signer.\r\n     * @param addr the address\r\n     * @param isSequencer_ if the specified address should be authorized as a sequencer\r\n     */\r\n    function setIsSequencer(address addr, bool isSequencer_) external;\r\n\r\n    // ---------- initializer ----------\r\n\r\n    function initialize(IBridge bridge_, MaxTimeVariation calldata maxTimeVariation_) external;\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/osp/IOneStepProver.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nstruct ExecutionContext {\r\n    uint256 maxInboxMessagesRead;\r\n    IBridge bridge;\r\n}\r\n\r\nabstract contract IOneStepProver {\r\n    function executeOneStep(\r\n        ExecutionContext memory execCtx,\r\n        Machine calldata mach,\r\n        Module calldata mod,\r\n        Instruction calldata instruction,\r\n        bytes calldata proof\r\n    ) external view virtual returns (Machine memory result, Module memory resultMod);\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/osp/IOneStepProofEntry.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\nlibrary OneStepProofEntryLib {\r\n    uint256 internal constant MAX_STEPS = 1 << 43;\r\n}\r\n\r\ninterface IOneStepProofEntry {\r\n    function proveOneStep(\r\n        ExecutionContext calldata execCtx,\r\n        uint256 machineStep,\r\n        bytes32 beforeHash,\r\n        bytes calldata proof\r\n    ) external view returns (bytes32 afterHash);\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/challenge/IChallengeManager.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IChallengeManager {\r\n    enum ChallengeTerminationType {\r\n        TIMEOUT,\r\n        BLOCK_PROOF,\r\n        EXECUTION_PROOF,\r\n        CLEARED\r\n    }\r\n\r\n    event InitiatedChallenge(\r\n        uint64 indexed challengeIndex,\r\n        GlobalState startState,\r\n        GlobalState endState\r\n    );\r\n\r\n    event Bisected(\r\n        uint64 indexed challengeIndex,\r\n        bytes32 indexed challengeRoot,\r\n        uint256 challengedSegmentStart,\r\n        uint256 challengedSegmentLength,\r\n        bytes32[] chainHashes\r\n    );\r\n\r\n    event ExecutionChallengeBegun(uint64 indexed challengeIndex, uint256 blockSteps);\r\n    event OneStepProofCompleted(uint64 indexed challengeIndex);\r\n\r\n    event ChallengeEnded(uint64 indexed challengeIndex, ChallengeTerminationType kind);\r\n\r\n    function initialize(\r\n        IChallengeResultReceiver resultReceiver_,\r\n        ISequencerInbox sequencerInbox_,\r\n        IBridge bridge_,\r\n        IOneStepProofEntry osp_\r\n    ) external;\r\n\r\n    function createChallenge(\r\n        bytes32 wasmModuleRoot_,\r\n        MachineStatus[2] calldata startAndEndMachineStatuses_,\r\n        GlobalState[2] calldata startAndEndGlobalStates_,\r\n        uint64 numBlocks,\r\n        address asserter_,\r\n        address challenger_,\r\n        uint256 asserterTimeLeft_,\r\n        uint256 challengerTimeLeft_\r\n    ) external returns (uint64);\r\n\r\n    function challengeInfo(uint64 challengeIndex_)\r\n        external\r\n        view\r\n        returns (ChallengeLib.Challenge memory);\r\n\r\n    function currentResponder(uint64 challengeIndex) external view returns (address);\r\n\r\n    function isTimedOut(uint64 challengeIndex) external view returns (bool);\r\n\r\n    function clearChallenge(uint64 challengeIndex_) external;\r\n\r\n    function timeout(uint64 challengeIndex_) external;\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/bridge/IInbox.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\n// solhint-disable-next-line compiler-version\r\npragma solidity >=0.6.9 <0.9.0;\r\n\r\n\r\n\r\n\r\ninterface IInbox is IDelayedMessageProvider {\r\n    function bridge() external view returns (IBridge);\r\n\r\n    function sequencerInbox() external view returns (ISequencerInbox);\r\n\r\n    /**\r\n     * @notice Send a generic L2 message to the chain\r\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\r\n     *      This method will be disabled upon L1 fork to prevent replay attacks on L2\r\n     * @param messageData Data of the message being sent\r\n     */\r\n    function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Send a generic L2 message to the chain\r\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\r\n     *      This method will be disabled upon L1 fork to prevent replay attacks on L2\r\n     * @param messageData Data of the message being sent\r\n     */\r\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\r\n\r\n    function sendL1FundedUnsignedTransaction(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        uint256 nonce,\r\n        address to,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    function sendL1FundedContractTransaction(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        address to,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    function sendUnsignedTransaction(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        uint256 nonce,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n\r\n    function sendContractTransaction(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev This method can only be called upon L1 fork and will not alias the caller\r\n     *      This method will revert if not called from origin\r\n     */\r\n    function sendL1FundedUnsignedTransactionToFork(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        uint256 nonce,\r\n        address to,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    /**\r\n     * @dev This method can only be called upon L1 fork and will not alias the caller\r\n     *      This method will revert if not called from origin\r\n     */\r\n    function sendUnsignedTransactionToFork(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        uint256 nonce,\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Send a message to initiate L2 withdrawal\r\n     * @dev This method can only be called upon L1 fork and will not alias the caller\r\n     *      This method will revert if not called from origin\r\n     */\r\n    function sendWithdrawEthToFork(\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        uint256 nonce,\r\n        uint256 value,\r\n        address withdrawTo\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Get the L1 fee for submitting a retryable\r\n     * @dev This fee can be paid by funds already in the L2 aliased address or by the current message value\r\n     * @dev This formula may change in the future, to future proof your code query this method instead of inlining!!\r\n     * @param dataLength The length of the retryable's calldata, in bytes\r\n     * @param baseFee The block basefee when the retryable is included in the chain, if 0 current block.basefee will be used\r\n     */\r\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Deposit eth from L1 to L2 to address of the sender if sender is an EOA, and to its aliased address if the sender is a contract\r\n     * @dev This does not trigger the fallback function when receiving in the L2 side.\r\n     *      Look into retryable tickets if you are interested in this functionality.\r\n     * @dev This function should not be called inside contract constructors\r\n     */\r\n    function depositEth() external payable returns (uint256);\r\n\r\n    /**\r\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\r\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\r\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\r\n     * @param to destination L2 contract address\r\n     * @param l2CallValue call value for retryable L2 message\r\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\r\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\r\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\r\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\r\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\r\n     * @param data ABI encoded data of L2 message\r\n     * @return unique message number of the retryable transaction\r\n     */\r\n    function createRetryableTicket(\r\n        address to,\r\n        uint256 l2CallValue,\r\n        uint256 maxSubmissionCost,\r\n        address excessFeeRefundAddress,\r\n        address callValueRefundAddress,\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    /**\r\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\r\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds\r\n     * come from the deposit alone, rather than falling back on the user's L2 balance\r\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\r\n     * createRetryableTicket method is the recommended standard.\r\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\r\n     * @param to destination L2 contract address\r\n     * @param l2CallValue call value for retryable L2 message\r\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\r\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\r\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\r\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\r\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\r\n     * @param data ABI encoded data of L2 message\r\n     * @return unique message number of the retryable transaction\r\n     */\r\n    function unsafeCreateRetryableTicket(\r\n        address to,\r\n        uint256 l2CallValue,\r\n        uint256 maxSubmissionCost,\r\n        address excessFeeRefundAddress,\r\n        address callValueRefundAddress,\r\n        uint256 gasLimit,\r\n        uint256 maxFeePerGas,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    // ---------- onlyRollupOrOwner functions ----------\r\n\r\n    /// @notice pauses all inbox functionality\r\n    function pause() external;\r\n\r\n    /// @notice unpauses all inbox functionality\r\n    function unpause() external;\r\n\r\n    // ---------- initializer ----------\r\n\r\n    /**\r\n     * @dev function to be called one time during the inbox upgrade process\r\n     *      this is used to fix the storage slots\r\n     */\r\n    function postUpgradeInit(IBridge _bridge) external;\r\n\r\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox) external;\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/rollup/IRollupCore.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IRollupCore {\r\n    struct Staker {\r\n        uint256 amountStaked;\r\n        uint64 index;\r\n        uint64 latestStakedNode;\r\n        // currentChallenge is 0 if staker is not in a challenge\r\n        uint64 currentChallenge;\r\n        bool isStaked;\r\n    }\r\n\r\n    event RollupInitialized(bytes32 machineHash, uint256 chainId);\r\n\r\n    event NodeCreated(\r\n        uint64 indexed nodeNum,\r\n        bytes32 indexed parentNodeHash,\r\n        bytes32 indexed nodeHash,\r\n        bytes32 executionHash,\r\n        Assertion assertion,\r\n        bytes32 afterInboxBatchAcc,\r\n        bytes32 wasmModuleRoot,\r\n        uint256 inboxMaxCount\r\n    );\r\n\r\n    event NodeConfirmed(uint64 indexed nodeNum, bytes32 blockHash, bytes32 sendRoot);\r\n\r\n    event NodeRejected(uint64 indexed nodeNum);\r\n\r\n    event RollupChallengeStarted(\r\n        uint64 indexed challengeIndex,\r\n        address asserter,\r\n        address challenger,\r\n        uint64 challengedNode\r\n    );\r\n\r\n    event UserStakeUpdated(address indexed user, uint256 initialBalance, uint256 finalBalance);\r\n\r\n    event UserWithdrawableFundsUpdated(\r\n        address indexed user,\r\n        uint256 initialBalance,\r\n        uint256 finalBalance\r\n    );\r\n\r\n    function confirmPeriodBlocks() external view returns (uint64);\r\n\r\n    function extraChallengeTimeBlocks() external view returns (uint64);\r\n\r\n    function chainId() external view returns (uint256);\r\n\r\n    function baseStake() external view returns (uint256);\r\n\r\n    function wasmModuleRoot() external view returns (bytes32);\r\n\r\n    function bridge() external view returns (IBridge);\r\n\r\n    function sequencerInbox() external view returns (ISequencerInbox);\r\n\r\n    function outbox() external view returns (IOutbox);\r\n\r\n    function rollupEventInbox() external view returns (IRollupEventInbox);\r\n\r\n    function challengeManager() external view returns (IChallengeManager);\r\n\r\n    function loserStakeEscrow() external view returns (address);\r\n\r\n    function stakeToken() external view returns (address);\r\n\r\n    function minimumAssertionPeriod() external view returns (uint256);\r\n\r\n    function isValidator(address) external view returns (bool);\r\n\r\n    function validatorWhitelistDisabled() external view returns (bool);\r\n\r\n    /**\r\n     * @notice Get the Node for the given index.\r\n     */\r\n    function getNode(uint64 nodeNum) external view returns (Node memory);\r\n\r\n    /**\r\n     * @notice Returns the block in which the given node was created for looking up its creation event.\r\n     * Unlike the Node's createdAtBlock field, this will be the ArbSys blockNumber if the host chain is an Arbitrum chain.\r\n     * That means that the block number returned for this is usable for event queries.\r\n     * This function will revert if the given node number does not exist.\r\n     * @dev This function is meant for internal use only and has no stability guarantees.\r\n     */\r\n    function getNodeCreationBlockForLogLookup(uint64 nodeNum) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Check if the specified node has been staked on by the provided staker.\r\n     * Only accurate at the latest confirmed node and afterwards.\r\n     */\r\n    function nodeHasStaker(uint64 nodeNum, address staker) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Get the address of the staker at the given index\r\n     * @param stakerNum Index of the staker\r\n     * @return Address of the staker\r\n     */\r\n    function getStakerAddress(uint64 stakerNum) external view returns (address);\r\n\r\n    /**\r\n     * @notice Check whether the given staker is staked\r\n     * @param staker Staker address to check\r\n     * @return True or False for whether the staker was staked\r\n     */\r\n    function isStaked(address staker) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Get the latest staked node of the given staker\r\n     * @param staker Staker address to lookup\r\n     * @return Latest node staked of the staker\r\n     */\r\n    function latestStakedNode(address staker) external view returns (uint64);\r\n\r\n    /**\r\n     * @notice Get the current challenge of the given staker\r\n     * @param staker Staker address to lookup\r\n     * @return Current challenge of the staker\r\n     */\r\n    function currentChallenge(address staker) external view returns (uint64);\r\n\r\n    /**\r\n     * @notice Get the amount staked of the given staker\r\n     * @param staker Staker address to lookup\r\n     * @return Amount staked of the staker\r\n     */\r\n    function amountStaked(address staker) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Retrieves stored information about a requested staker\r\n     * @param staker Staker address to retrieve\r\n     * @return A structure with information about the requested staker\r\n     */\r\n    function getStaker(address staker) external view returns (Staker memory);\r\n\r\n    /**\r\n     * @notice Get the original staker address of the zombie at the given index\r\n     * @param zombieNum Index of the zombie to lookup\r\n     * @return Original staker address of the zombie\r\n     */\r\n    function zombieAddress(uint256 zombieNum) external view returns (address);\r\n\r\n    /**\r\n     * @notice Get Latest node that the given zombie at the given index is staked on\r\n     * @param zombieNum Index of the zombie to lookup\r\n     * @return Latest node that the given zombie is staked on\r\n     */\r\n    function zombieLatestStakedNode(uint256 zombieNum) external view returns (uint64);\r\n\r\n    /// @return Current number of un-removed zombies\r\n    function zombieCount() external view returns (uint256);\r\n\r\n    function isZombie(address staker) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Get the amount of funds withdrawable by the given address\r\n     * @param owner Address to check the funds of\r\n     * @return Amount of funds withdrawable by owner\r\n     */\r\n    function withdrawableFunds(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @return Index of the first unresolved node\r\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\r\n     */\r\n    function firstUnresolvedNode() external view returns (uint64);\r\n\r\n    /// @return Index of the latest confirmed node\r\n    function latestConfirmed() external view returns (uint64);\r\n\r\n    /// @return Index of the latest rollup node created\r\n    function latestNodeCreated() external view returns (uint64);\r\n\r\n    /// @return Ethereum block that the most recent stake was created\r\n    function lastStakeBlock() external view returns (uint64);\r\n\r\n    /// @return Number of active stakers currently staked\r\n    function stakerCount() external view returns (uint64);\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/rollup/IRollupLogic.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\ninterface IRollupUserAbs is IRollupCore, IOwnable {\r\n    /// @dev the user logic just validated configuration and shouldn't write to state during init\r\n    /// this allows the admin logic to ensure consistency on parameters.\r\n    function initialize(address stakeToken) external view;\r\n\r\n    function removeWhitelistAfterFork() external;\r\n\r\n    function removeWhitelistAfterValidatorAfk() external;\r\n\r\n    function isERC20Enabled() external view returns (bool);\r\n\r\n    function rejectNextNode(address stakerAddress) external;\r\n\r\n    function confirmNextNode(bytes32 blockHash, bytes32 sendRoot) external;\r\n\r\n    function stakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external;\r\n\r\n    function stakeOnNewNode(\r\n        Assertion memory assertion,\r\n        bytes32 expectedNodeHash,\r\n        uint256 prevNodeInboxMaxCount\r\n    ) external;\r\n\r\n    function returnOldDeposit(address stakerAddress) external;\r\n\r\n    function reduceDeposit(uint256 target) external;\r\n\r\n    function removeZombie(uint256 zombieNum, uint256 maxNodes) external;\r\n\r\n    function removeOldZombies(uint256 startIndex) external;\r\n\r\n    function requiredStake(\r\n        uint256 blockNumber,\r\n        uint64 firstUnresolvedNodeNum,\r\n        uint64 latestCreatedNode\r\n    ) external view returns (uint256);\r\n\r\n    function currentRequiredStake() external view returns (uint256);\r\n\r\n    function countStakedZombies(uint64 nodeNum) external view returns (uint256);\r\n\r\n    function countZombiesStakedOnChildren(uint64 nodeNum) external view returns (uint256);\r\n\r\n    function requireUnresolvedExists() external view;\r\n\r\n    function requireUnresolved(uint256 nodeNum) external view;\r\n\r\n    function withdrawStakerFunds() external returns (uint256);\r\n\r\n    function createChallenge(\r\n        address[2] calldata stakers,\r\n        uint64[2] calldata nodeNums,\r\n        MachineStatus[2] calldata machineStatuses,\r\n        GlobalState[2] calldata globalStates,\r\n        uint64 numBlocks,\r\n        bytes32 secondExecutionHash,\r\n        uint256[2] calldata proposedTimes,\r\n        bytes32[2] calldata wasmModuleRoots\r\n    ) external;\r\n}\r\n\r\ninterface IRollupUser is IRollupUserAbs {\r\n    function newStakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external payable;\r\n\r\n    function newStakeOnNewNode(\r\n        Assertion calldata assertion,\r\n        bytes32 expectedNodeHash,\r\n        uint256 prevNodeInboxMaxCount\r\n    ) external payable;\r\n\r\n    function addToDeposit(address stakerAddress) external payable;\r\n}\r\n\r\ninterface IRollupUserERC20 is IRollupUserAbs {\r\n    function newStakeOnExistingNode(\r\n        uint256 tokenAmount,\r\n        uint64 nodeNum,\r\n        bytes32 nodeHash\r\n    ) external;\r\n\r\n    function newStakeOnNewNode(\r\n        uint256 tokenAmount,\r\n        Assertion calldata assertion,\r\n        bytes32 expectedNodeHash,\r\n        uint256 prevNodeInboxMaxCount\r\n    ) external;\r\n\r\n    function addToDeposit(address stakerAddress, uint256 tokenAmount) external;\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/rollup/Config.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nstruct Config {\r\n    uint64 confirmPeriodBlocks;\r\n    uint64 extraChallengeTimeBlocks;\r\n    address stakeToken;\r\n    uint256 baseStake;\r\n    bytes32 wasmModuleRoot;\r\n    address owner;\r\n    address loserStakeEscrow;\r\n    uint256 chainId;\r\n    string chainConfig;\r\n    uint64 genesisBlockNum;\r\n    ISequencerInbox.MaxTimeVariation sequencerInboxMaxTimeVariation;\r\n}\r\n\r\nstruct ContractDependencies {\r\n    IBridge bridge;\r\n    ISequencerInbox sequencerInbox;\r\n    IInbox inbox;\r\n    IOutbox outbox;\r\n    IRollupEventInbox rollupEventInbox;\r\n    IChallengeManager challengeManager;\r\n    address rollupAdminLogic;\r\n    IRollupUser rollupUserLogic;\r\n    // misc contracts that are useful when interacting with the rollup\r\n    address validatorUtils;\r\n    address validatorWalletCreator;\r\n}\r\n\r\n// File: @arbitrum/nitro-contracts/src/rollup/IRollupAdmin.sol\r\n\r\n// Copyright 2021-2022, Offchain Labs, Inc.\r\n// For license information, see https://github.com/OffchainLabs/nitro-contracts/blob/main/LICENSE\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IRollupAdmin {\r\n    event OwnerFunctionCalled(uint256 indexed id);\r\n\r\n    function initialize(Config calldata config, ContractDependencies calldata connectedContracts)\r\n        external;\r\n\r\n    /**\r\n     * @notice Add a contract authorized to put messages into this rollup's inbox\r\n     * @param _outbox Outbox contract to add\r\n     */\r\n    function setOutbox(IOutbox _outbox) external;\r\n\r\n    /**\r\n     * @notice Disable an old outbox from interacting with the bridge\r\n     * @param _outbox Outbox contract to remove\r\n     */\r\n    function removeOldOutbox(address _outbox) external;\r\n\r\n    /**\r\n     * @notice Enable or disable an inbox contract\r\n     * @param _inbox Inbox contract to add or remove\r\n     * @param _enabled New status of inbox\r\n     */\r\n    function setDelayedInbox(address _inbox, bool _enabled) external;\r\n\r\n    /**\r\n     * @notice Pause interaction with the rollup contract\r\n     */\r\n    function pause() external;\r\n\r\n    /**\r\n     * @notice Resume interaction with the rollup contract\r\n     */\r\n    function resume() external;\r\n\r\n    /**\r\n     * @notice Set the addresses of the validator whitelist\r\n     * @dev It is expected that both arrays are same length, and validator at\r\n     * position i corresponds to the value at position i\r\n     * @param _validator addresses to set in the whitelist\r\n     * @param _val value to set in the whitelist for corresponding address\r\n     */\r\n    function setValidator(address[] memory _validator, bool[] memory _val) external;\r\n\r\n    /**\r\n     * @notice Set a new owner address for the rollup proxy\r\n     * @param newOwner address of new rollup owner\r\n     */\r\n    function setOwner(address newOwner) external;\r\n\r\n    /**\r\n     * @notice Set minimum assertion period for the rollup\r\n     * @param newPeriod new minimum period for assertions\r\n     */\r\n    function setMinimumAssertionPeriod(uint256 newPeriod) external;\r\n\r\n    /**\r\n     * @notice Set number of blocks until a node is considered confirmed\r\n     * @param newConfirmPeriod new number of blocks until a node is confirmed\r\n     */\r\n    function setConfirmPeriodBlocks(uint64 newConfirmPeriod) external;\r\n\r\n    /**\r\n     * @notice Set number of extra blocks after a challenge\r\n     * @param newExtraTimeBlocks new number of blocks\r\n     */\r\n    function setExtraChallengeTimeBlocks(uint64 newExtraTimeBlocks) external;\r\n\r\n    /**\r\n     * @notice Set base stake required for an assertion\r\n     * @param newBaseStake maximum avmgas to be used per block\r\n     */\r\n    function setBaseStake(uint256 newBaseStake) external;\r\n\r\n    /**\r\n     * @notice Set the token used for stake, where address(0) == eth\r\n     * @dev Before changing the base stake token, you might need to change the\r\n     * implementation of the Rollup User logic!\r\n     * @param newStakeToken address of token used for staking\r\n     */\r\n    function setStakeToken(address newStakeToken) external;\r\n\r\n    /**\r\n     * @notice Upgrades the implementation of a beacon controlled by the rollup\r\n     * @param beacon address of beacon to be upgraded\r\n     * @param newImplementation new address of implementation\r\n     */\r\n    function upgradeBeacon(address beacon, address newImplementation) external;\r\n\r\n    function forceResolveChallenge(address[] memory stackerA, address[] memory stackerB) external;\r\n\r\n    function forceRefundStaker(address[] memory stacker) external;\r\n\r\n    function forceCreateNode(\r\n        uint64 prevNode,\r\n        uint256 prevNodeInboxMaxCount,\r\n        Assertion memory assertion,\r\n        bytes32 expectedNodeHash\r\n    ) external;\r\n\r\n    function forceConfirmNode(\r\n        uint64 nodeNum,\r\n        bytes32 blockHash,\r\n        bytes32 sendRoot\r\n    ) external;\r\n\r\n    function setLoserStakeEscrow(address newLoserStakerEscrow) external;\r\n\r\n    /**\r\n     * @notice Set the proving WASM module root\r\n     * @param newWasmModuleRoot new module root\r\n     */\r\n    function setWasmModuleRoot(bytes32 newWasmModuleRoot) external;\r\n\r\n    /**\r\n     * @notice set a new sequencer inbox contract\r\n     * @param _sequencerInbox new address of sequencer inbox\r\n     */\r\n    function setSequencerInbox(address _sequencerInbox) external;\r\n\r\n    /**\r\n     * @notice set the validatorWhitelistDisabled flag\r\n     * @param _validatorWhitelistDisabled new value of validatorWhitelistDisabled, i.e. true = disabled\r\n     */\r\n    function setValidatorWhitelistDisabled(bool _validatorWhitelistDisabled) external;\r\n}\r\n\r\n// File: src/gov-action-contracts/address-registries/interfaces.sol\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IL1Timelock {\r\n    function updateDelay(uint256 newDelay) external;\r\n    function getMinDelay() external view returns (uint256 duration);\r\n}\r\n\r\ninterface IRollupGetter {\r\n    function rollup() external view returns (IRollupCore);\r\n}\r\n\r\ninterface IBridgeGetter {\r\n    function bridge() external view returns (IBridge);\r\n}\r\n\r\ninterface IInboxGetter {\r\n    function inbox() external view returns (IInbox);\r\n}\r\n\r\ninterface ISequencerInboxGetter {\r\n    function sequencerInbox() external view returns (ISequencerInbox);\r\n}\r\n\r\ninterface IL1TimelockGetter {\r\n    function l1Timelock() external view returns (IL1Timelock);\r\n}\r\n\r\ninterface IL1GatewayRouter {\r\n    function setGateways(\r\n        address[] memory _token,\r\n        address[] memory _gateway,\r\n        uint256 _maxGas,\r\n        uint256 _gasPriceBid,\r\n        uint256 _maxSubmissionCost\r\n    ) external payable returns (uint256);\r\n}\r\n\r\ninterface IL1CustomGateway {\r\n    function forceRegisterTokenToL2(\r\n        address[] calldata _l1Addresses,\r\n        address[] calldata _l2Addresses,\r\n        uint256 _maxGas,\r\n        uint256 _gasPriceBid,\r\n        uint256 _maxSubmissionCost\r\n    ) external payable returns (uint256);\r\n}\r\n\r\ninterface IL1CustomGatewayGetter {\r\n    function customGateway() external view returns (IL1CustomGateway);\r\n}\r\n\r\ninterface IL1GatewayRouterGetter {\r\n    function gatewayRouter() external view returns (IL1GatewayRouter);\r\n}\r\n\r\ninterface IL1AddressRegistry is\r\n    IRollupGetter,\r\n    IInboxGetter,\r\n    ISequencerInboxGetter,\r\n    IBridgeGetter,\r\n    IL1TimelockGetter,\r\n    IL1GatewayRouterGetter,\r\n    IL1CustomGatewayGetter\r\n{}\r\n\r\n// File: src/gov-action-contracts/address-registries/L1AddressRegistry.sol\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\ncontract L1AddressRegistry is IL1AddressRegistry {\r\n    IInbox public immutable inbox;\r\n    IL1Timelock public immutable l1Timelock;\r\n    IL1CustomGateway public immutable customGateway;\r\n    IL1GatewayRouter public immutable gatewayRouter;\r\n\r\n    constructor(\r\n        IInbox _inbox,\r\n        IL1Timelock _l1Timelock,\r\n        IL1CustomGateway _customGateway,\r\n        IL1GatewayRouter _gatewayRouter\r\n    ) {\r\n        inbox = _inbox;\r\n        l1Timelock = _l1Timelock;\r\n        customGateway = _customGateway;\r\n        gatewayRouter = _gatewayRouter;\r\n    }\r\n\r\n    function rollup() public view returns (IRollupCore) {\r\n        return IRollupCore(address(bridge().rollup()));\r\n    }\r\n\r\n    function bridge() public view returns (IBridge) {\r\n        return inbox.bridge();\r\n    }\r\n\r\n    function sequencerInbox() public view returns (ISequencerInbox) {\r\n        return inbox.sequencerInbox();\r\n    }\r\n}\r\n\r\n// File: src/gov-action-contracts/arbos-upgrade/SetWasmModuleRootAction.sol\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n/// @notice should be included in an operation batch in the L1 timelock along with UpgradeArbOSVersionAction\r\ncontract SetWasmModuleRootAction {\r\n    address public immutable rollup;\r\n    bytes32 public immutable newWasmModuleRoot;\r\n\r\n    constructor(L1AddressRegistry _l1AddressRegistry, bytes32 _newWasmModuleRoot) {\r\n        rollup = address(_l1AddressRegistry.rollup());\r\n        newWasmModuleRoot = _newWasmModuleRoot;\r\n    }\r\n\r\n    function perform() external {\r\n        IRollupAdmin(rollup).setWasmModuleRoot(newWasmModuleRoot);\r\n\r\n        // verify:\r\n        require(\r\n            IRollupCore(rollup).wasmModuleRoot() == newWasmModuleRoot,\r\n            \"SetWasmModuleRootAction: wasm module root not set\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: src/gov-action-contracts/AIPs/ArbOS11/SetNovaArbOS11ModuleRootAction.sol\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n\r\n/// @notice action deployed on L1 to set nova's wasm module root for ARBOS11 upgrade\r\ncontract SetNovaArbOS11ModuleRootAction is SetWasmModuleRootAction {\r\n    constructor()\r\n        SetWasmModuleRootAction(\r\n            L1AddressRegistry(0x2F06643fc2CC18585Ae790b546388F0DE4Ec6635),\r\n            bytes32(0x92a7978d7ef64fa82a33c9d9af77647d9014c345a24ebf41635bc89e1c45e35b)\r\n        )\r\n    {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"newWasmModuleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"perform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SetNovaArbOS11ModuleRootAction", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://33cc10bbe484c4c4ee1c21ff38aa3d8e72045f2767aafaf9740fef0e496f3016"}