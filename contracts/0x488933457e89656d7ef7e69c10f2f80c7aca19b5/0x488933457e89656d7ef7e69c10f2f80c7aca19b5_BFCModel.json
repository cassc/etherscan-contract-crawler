{"SourceCode": "// File: contracts/module/safeMath.sol\r\n\r\n// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity 0.6.12;\r\n\r\n// from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @title BiFi's safe-math Contract\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ncontract safeMathModule {\r\n    uint256 constant one = 1 ether;\r\n\r\n    function expDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv( safeMul(a, one), b);\r\n    }\r\n    function expMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv( safeMul(a, b), one);\r\n    }\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addtion overflow\");\r\n        return c;\r\n    }\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(a >= b, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if(a == 0) { return 0;}\r\n        uint256 c = a * b;\r\n        require( (c/a) == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return (a/b);\r\n    }\r\n}\r\n\r\n// File: contracts/ERC20.sol\r\n\r\n/**\r\n * @title BiFi's ERC20 Mockup Contract\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ncontract ERC20 {\r\n    string symbol;\r\n    string name;\r\n    uint8 decimals = 18;\r\n    uint256 totalSupply = 1000 * 1e9 * 1e18; // token amount: 1000 Bilions\r\n\r\n    // Owner of this contract\r\n    address public owner;\r\n\r\n    // Balances for each account\r\n    mapping(address => uint256) balances;\r\n\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n\r\n    // Functions with this modifier can only be executed by the owner\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    event Transfer(address, address, uint256);\r\n    event Approval(address, address, uint256);\r\n\r\n    // Constructor\r\n    constructor (string memory _name, string memory _symbol) public {\r\n\r\n        owner = msg.sender;\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n\r\n    // What is the balance of a particular account?\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    // Transfer the balance from owner's account to another account\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n\r\n        require(balances[msg.sender] >= _amount, \"insuficient sender's balance\");\r\n        require(_amount > 0, \"requested amount must be positive\");\r\n        require(balances[_to] + _amount > balances[_to], \"receiver's balance overflows\");\r\n\r\n        balances[msg.sender] -= _amount;\r\n        balances[_to] += _amount;\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n    // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n    // fees in sub-currencies; the command should fail unless the _from account has\r\n    // deliberately authorized the sender of the message via some mechanism; we propose\r\n    // these standardized APIs for approval:\r\n    function transferFrom(address _from, address _to,uint256 _amount) public returns (bool success) {\r\n\r\n        require(balances[_from] >= _amount, \"insuficient sender's balance\");\r\n        require(allowed[_from][msg.sender] >= _amount, \"not allowed transfer\");\r\n        require(_amount > 0, \"requested amount must be positive\");\r\n        require(balances[_to] + _amount > balances[_to], \"receiver's balance overflows\");\r\n\r\n        balances[_from] -= _amount;\r\n        allowed[_from][msg.sender] -= _amount;\r\n        balances[_to] += _amount;\r\n        emit Transfer(_from, _to, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract BFCtoken is ERC20 {\r\n    constructor() public ERC20 (\"Bifrost\", \"BFC\") {}\r\n}\r\n\r\ncontract LPtoken is ERC20 {\r\n    constructor() public ERC20 (\"BFC-ETH\", \"LP\") {}\r\n}\r\n\r\ncontract BiFitoken is ERC20 {\r\n    constructor() public ERC20 (\"BiFi\", \"BiFi\") {}\r\n}\r\n\r\n// File: contracts/module/storageModule.sol\r\n\r\n\r\n/**\r\n * @title BiFi's Reward Distribution Storage Contract\r\n * @notice Define the basic Contract State\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ncontract storageModule {\r\n    address public owner;\r\n\r\n    bool public claimLock;\r\n    bool public withdrawLock;\r\n\r\n    uint256 public rewardPerBlock;\r\n    uint256 public decrementUnitPerBlock;\r\n    uint256 public rewardLane;\r\n\r\n    uint256 public lastBlockNum;\r\n    uint256 public totalDeposited;\r\n\r\n    ERC20 public lpErc; ERC20 public rewardErc;\r\n\r\n    mapping(address => Account) public accounts;\r\n\r\n    uint256 public passedPoint;\r\n    RewardVelocityPoint[] public registeredPoints;\r\n\r\n    struct Account {\r\n        uint256 deposited;\r\n        uint256 pointOnLane;\r\n        uint256 rewardAmount;\r\n    }\r\n\r\n    struct RewardVelocityPoint {\r\n        uint256 blockNumber;\r\n        uint256 rewardPerBlock;\r\n        uint256 decrementUnitPerBlock;\r\n    }\r\n\r\n    struct UpdateRewardLaneModel {\r\n        uint256 len; uint256 tmpBlockDelta;\r\n\r\n        uint256 memPassedPoint; uint256 tmpPassedPoint;\r\n\r\n        uint256 memThisBlockNum;\r\n        uint256 memLastBlockNum; uint256 tmpLastBlockNum;\r\n\r\n        uint256 memTotalDeposit;\r\n\r\n        uint256 memRewardLane; uint256 tmpRewardLane;\r\n        uint256 memRewardPerBlock; uint256 tmpRewardPerBlock;\r\n\r\n        uint256 memDecrementUnitPerBlock; uint256 tmpDecrementUnitPerBlock;\r\n    }\r\n}\r\n\r\n// File: contracts/module/eventModule.sol\r\n\r\n/**\r\n * @title BiFi's Reward Distribution Event Contract\r\n * @notice Define the service Events\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ncontract eventModule {\r\n    /// @dev Events for user actions\r\n    event Deposit(address userAddr, uint256 amount, uint256 userDeposit, uint256 totalDeposit);\r\n    event Withdraw(address userAddr, uint256 amount, uint256 userDeposit, uint256 totalDeposit);\r\n    event Claim(address userAddr, uint256 amount);\r\n    event UpdateRewardParams(uint256 atBlockNumber, uint256 rewardPerBlock, uint256 decrementUnitPerBlock);\r\n\r\n    /// @dev Events for admin actions below\r\n\r\n    /// @dev Contracts Access Control\r\n    event ClaimLock(bool lock);\r\n    event WithdrawLock(bool lock);\r\n    event OwnershipTransfer(address from, address to);\r\n\r\n    /// @dev Distribution Model Parameter editer\r\n    event SetRewardParams(uint256 rewardPerBlock, uint256 decrementUnitPerBlock);\r\n    event RegisterRewardParams(uint256 atBlockNumber, uint256 rewardPerBlock, uint256 decrementUnitPerBlock);\r\n    event DeleteRegisterRewardParams(uint256 index, uint256 atBlockNumber, uint256 rewardPerBlock, uint256 decrementUnitPerBlock, uint256 arrayLen);\r\n}\r\n\r\n// File: contracts/module/internalModule.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @title BiFi's Reward Distribution Internal Contract\r\n * @notice Implement the basic functions for staking and reward distribution\r\n * @dev All functions are internal.\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ncontract internalModule is storageModule, eventModule, safeMathModule {\r\n    /**\r\n     * @notice Deposit the Contribution Tokens\r\n     * @param userAddr The user address of the Contribution Tokens\r\n     * @param amount The amount of the Contribution Tokens\r\n     */\r\n    function _deposit(address userAddr, uint256 amount) internal {\r\n        Account memory user = accounts[userAddr];\r\n        uint256 totalDeposit = totalDeposited;\r\n\r\n        user.deposited = safeAdd(user.deposited, amount);\r\n        accounts[userAddr].deposited = user.deposited;\r\n        totalDeposit = safeAdd(totalDeposited, amount);\r\n        totalDeposited = totalDeposit;\r\n\r\n        if(amount > 0) {\r\n            /// @dev transfer the Contribution Toknes to this contract.\r\n            emit Deposit(userAddr, amount, user.deposited, totalDeposit);\r\n            require( lpErc.transferFrom(msg.sender, address(this), amount), \"token error\" );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw the Contribution Tokens\r\n     * @param userAddr The user address of the Contribution Tokens\r\n     * @param amount The amount of the Contribution Tokens\r\n     */\r\n    function _withdraw(address userAddr, uint256 amount) internal {\r\n        Account memory user = accounts[userAddr];\r\n        uint256 totalDeposit = totalDeposited;\r\n        require(user.deposited >= amount, \"not enough user Deposit\");\r\n\r\n        user.deposited = safeSub(user.deposited, amount);\r\n        accounts[userAddr].deposited = user.deposited;\r\n        totalDeposit = safeSub(totalDeposited, amount);\r\n        totalDeposited = totalDeposit;\r\n\r\n        if(amount > 0) {\r\n            /// @dev transfer the Contribution Tokens from this contact.\r\n            emit Withdraw(userAddr, amount, user.deposited, totalDeposit);\r\n            require( lpErc.transfer(userAddr, amount), \"token error\" );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate current reward\r\n     * @dev This function is called whenever the balance of the Contribution\r\n       Tokens of the user.\r\n     * @param userAddr The user address of the Contribution and Reward Tokens\r\n     */\r\n    function _redeemAll(address userAddr) internal {\r\n        Account memory user = accounts[userAddr];\r\n\r\n        uint256 newRewardLane = _updateRewardLane();\r\n\r\n        uint256 distance = safeSub(newRewardLane, user.pointOnLane);\r\n        uint256 rewardAmount = expMul(user.deposited, distance);\r\n\r\n        if(user.pointOnLane != newRewardLane) accounts[userAddr].pointOnLane = newRewardLane;\r\n        if(rewardAmount != 0) accounts[userAddr].rewardAmount = safeAdd(user.rewardAmount, rewardAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim the Reward Tokens\r\n     * @dev Transfer all reward the user has earned at once.\r\n     * @param userAddr The user address of the Reward Tokens\r\n     */\r\n    function _rewardClaim(address userAddr) internal {\r\n        Account memory user = accounts[userAddr];\r\n\r\n        if(user.rewardAmount != 0) {\r\n            uint256 amount = user.rewardAmount;\r\n            accounts[userAddr].rewardAmount = 0;\r\n\r\n            /// @dev transfer the Reward Tokens from this contract.\r\n            emit Claim(userAddr, amount);\r\n            require(rewardErc.transfer(userAddr, amount), \"token error\" );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update the reward lane value upto ths currnet moment (block)\r\n     * @dev This function should care the \"reward velocity points,\" at which the\r\n       parameters of reward distribution are changed.\r\n     * @return The current (calculated) reward lane value\r\n     */\r\n    function _updateRewardLane() internal returns (uint256) {\r\n        /// @dev Set up memory variables used for calculation temporarily.\r\n        UpdateRewardLaneModel memory vars;\r\n\r\n        vars.len = registeredPoints.length;\r\n        vars.memTotalDeposit = totalDeposited;\r\n\r\n        vars.tmpPassedPoint = vars.memPassedPoint = passedPoint;\r\n\r\n        vars.memThisBlockNum = block.number;\r\n        vars.tmpLastBlockNum = vars.memLastBlockNum = lastBlockNum;\r\n\r\n        vars.tmpRewardLane = vars.memRewardLane = rewardLane;\r\n        vars.tmpRewardPerBlock = vars.memRewardPerBlock = rewardPerBlock;\r\n        vars.tmpDecrementUnitPerBlock = vars.memDecrementUnitPerBlock = decrementUnitPerBlock;\r\n\r\n        for(uint256 i=vars.memPassedPoint; i<vars.len; i++) {\r\n            RewardVelocityPoint memory point = registeredPoints[i];\r\n\r\n            /**\r\n             * @dev Check whether this reward velocity point is valid and has\r\n               not applied yet.\r\n             */\r\n            if(vars.tmpLastBlockNum < point.blockNumber && point.blockNumber <= vars.memThisBlockNum) {\r\n                vars.tmpPassedPoint = i+1;\r\n                /// @dev Update the reward lane with the tmp variables\r\n                vars.tmpBlockDelta = safeSub(point.blockNumber, vars.tmpLastBlockNum);\r\n                (vars.tmpRewardLane, vars.tmpRewardPerBlock) =\r\n                _calcNewRewardLane(\r\n                    vars.tmpRewardLane,\r\n                    vars.memTotalDeposit,\r\n                    vars.tmpRewardPerBlock,\r\n                    vars.tmpDecrementUnitPerBlock,\r\n                    vars.tmpBlockDelta);\r\n\r\n                /// @dev Update the tmp variables with this reward velocity point.\r\n                vars.tmpLastBlockNum = point.blockNumber;\r\n                vars.tmpRewardPerBlock = point.rewardPerBlock;\r\n                vars.tmpDecrementUnitPerBlock = point.decrementUnitPerBlock;\r\n                /**\r\n                 * @dev Notify the update of the parameters (by passing the\r\n                   reward velocity points)\r\n                 */\r\n                emit UpdateRewardParams(point.blockNumber, point.rewardPerBlock, point.decrementUnitPerBlock);\r\n            } else {\r\n                /// @dev sorted array, exit eariler without accessing future points.\r\n                break;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @dev Update the reward lane for the remained period between the\r\n           latest velocity point and this moment (block)\r\n         */\r\n        if( vars.tmpLastBlockNum < vars.memThisBlockNum ) {\r\n            vars.tmpBlockDelta = safeSub(vars.memThisBlockNum, vars.tmpLastBlockNum);\r\n            vars.tmpLastBlockNum = vars.memThisBlockNum;\r\n            (vars.tmpRewardLane, vars.tmpRewardPerBlock) =\r\n            _calcNewRewardLane(\r\n                vars.tmpRewardLane,\r\n                vars.memTotalDeposit,\r\n                vars.tmpRewardPerBlock,\r\n                vars.tmpDecrementUnitPerBlock,\r\n                vars.tmpBlockDelta);\r\n        }\r\n\r\n        /**\r\n         * @dev Update the reward lane parameters with the tmp variables.\r\n         */\r\n        if(vars.memLastBlockNum != vars.tmpLastBlockNum) lastBlockNum = vars.tmpLastBlockNum;\r\n        if(vars.memPassedPoint != vars.tmpPassedPoint) passedPoint = vars.tmpPassedPoint;\r\n        if(vars.memRewardLane != vars.tmpRewardLane) rewardLane = vars.tmpRewardLane;\r\n        if(vars.memRewardPerBlock != vars.tmpRewardPerBlock) rewardPerBlock = vars.tmpRewardPerBlock;\r\n        if(vars.memDecrementUnitPerBlock != vars.tmpDecrementUnitPerBlock) decrementUnitPerBlock = vars.tmpDecrementUnitPerBlock;\r\n\r\n        return vars.tmpRewardLane;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate a new reward lane value with the given parameters\r\n     * @param _rewardLane The previous reward lane value\r\n     * @param _totalDeposit Thte total deposit amount of the Contribution Tokens\r\n     * @param _rewardPerBlock The reward token amount per a block\r\n     * @param _decrementUnitPerBlock The decerement amount of the reward token per a block\r\n     */\r\n    function _calcNewRewardLane(\r\n        uint256 _rewardLane,\r\n        uint256 _totalDeposit,\r\n        uint256 _rewardPerBlock,\r\n        uint256 _decrementUnitPerBlock,\r\n        uint256 delta) internal pure returns (uint256, uint256) {\r\n            uint256 executableDelta;\r\n            if(_decrementUnitPerBlock != 0) {\r\n                executableDelta = safeDiv(_rewardPerBlock, _decrementUnitPerBlock);\r\n                if(delta > executableDelta) delta = executableDelta;\r\n                else executableDelta = 0;\r\n            }\r\n\r\n            uint256 distance;\r\n            if(_totalDeposit != 0) {\r\n                distance = expMul( _sequencePartialSumAverage(_rewardPerBlock, delta, _decrementUnitPerBlock), safeMul( expDiv(one, _totalDeposit), delta) );\r\n                _rewardLane = safeAdd(_rewardLane, distance);\r\n            }\r\n\r\n            if(executableDelta != 0) _rewardPerBlock = 0;\r\n            else _rewardPerBlock = _getNewRewardPerBlock(_rewardPerBlock, _decrementUnitPerBlock, delta);\r\n\r\n            return (_rewardLane, _rewardPerBlock);\r\n    }\r\n\r\n    /**\r\n     * @notice Register a new reward velocity point\r\n     * @dev We assume that reward velocity points are stored in order of block\r\n       number. Namely, registerPoints is always a sorted array.\r\n     * @param _blockNumber The block number for the point.\r\n     * @param _rewardPerBlock The reward token amount per a block\r\n     * @param _decrementUnitPerBlock The decerement amount of the reward token per a block\r\n     */\r\n    function _registerRewardVelocity(uint256 _blockNumber, uint256 _rewardPerBlock, uint256 _decrementUnitPerBlock) internal {\r\n        RewardVelocityPoint memory varPoint = RewardVelocityPoint(_blockNumber, _rewardPerBlock, _decrementUnitPerBlock);\r\n        emit RegisterRewardParams(_blockNumber, _rewardPerBlock, _decrementUnitPerBlock);\r\n        registeredPoints.push(varPoint);\r\n    }\r\n\r\n    /**\r\n     * @notice Delete a existing reward velocity point\r\n     * @dev We assume that reward velocity points are stored in order of block\r\n       number. Namely, registerPoints is always a sorted array.\r\n     * @param _index The index number of deleting point in state array.\r\n     */\r\n    function _deleteRegisteredRewardVelocity(uint256 _index) internal {\r\n        uint256 len = registeredPoints.length;\r\n        require(len != 0 && _index < len, \"error: no elements in registeredPoints\");\r\n\r\n        RewardVelocityPoint memory point = registeredPoints[_index];\r\n        emit DeleteRegisterRewardParams(_index, point.blockNumber, point.rewardPerBlock, point.decrementUnitPerBlock, len-1);\r\n        for(uint256 i=_index; i<len-1; i++) {\r\n            registeredPoints[i] = registeredPoints[i+1];\r\n        }\r\n        registeredPoints.pop();\r\n     }\r\n\r\n    /**\r\n     * @notice Set paramaters for the reward distribution\r\n     * @param _rewardPerBlock The reward token amount per a block\r\n     * @param _decrementUnitPerBlock The decerement amount of the reward token per a block\r\n     */\r\n    function _setParams(uint256 _rewardPerBlock, uint256 _decrementUnitPerBlock) internal {\r\n        emit SetRewardParams(_rewardPerBlock, _decrementUnitPerBlock);\r\n        rewardPerBlock = _rewardPerBlock;\r\n        decrementUnitPerBlock = _decrementUnitPerBlock;\r\n    }\r\n\r\n    /**\r\n     * @return the avaerage of the RewardLance of the inactive (i.e., no-action)\r\n       periods.\r\n    */\r\n    function _sequencePartialSumAverage(uint256 a, uint256 n, uint256 d) internal pure returns (uint256) {\r\n        /**\r\n        @dev return Sn / n,\r\n                where Sn = ( (n{2*a + (n-1)d}) / 2 )\r\n            == ( (2na + (n-1)d) / 2 ) / n\r\n            caveat: use safeSub() to avoid the case that d is negative\r\n        */\r\n        if (n > 0)\r\n            return safeDiv(safeSub( safeMul(2,a), safeMul( safeSub(n,1), d) ), 2);\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    function _getNewRewardPerBlock(uint256 before, uint256 dec, uint256 delta) internal pure returns (uint256) {\r\n        return safeSub(before, safeMul(dec, delta));\r\n    }\r\n\r\n    function _setClaimLock(bool lock) internal {\r\n        emit ClaimLock(lock);\r\n        claimLock = lock;\r\n    }\r\n\r\n    function _setWithdrawLock(bool lock) internal {\r\n        emit WithdrawLock(lock);\r\n        withdrawLock = lock;\r\n    }\r\n\r\n    function _ownershipTransfer(address to) internal {\r\n        emit OwnershipTransfer(msg.sender, to);\r\n        owner = to;\r\n    }\r\n}\r\n\r\n// File: contracts/module/viewModule.sol\r\n\r\n\r\n/**\r\n * @title BiFi's Reward Distribution View Contract\r\n * @notice Implements the view functions for support front-end\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ncontract viewModule is internalModule {\r\n    function marketInformation(uint256 _fromBlockNumber, uint256 _toBlockNumber) external view returns (\r\n        uint256 rewardStartBlockNumber,\r\n        uint256 distributedAmount,\r\n        uint256 totalDeposit,\r\n        uint256 poolRate\r\n        )\r\n    {\r\n        if(rewardPerBlock == 0) rewardStartBlockNumber = registeredPoints[0].blockNumber;\r\n        else rewardStartBlockNumber = registeredPoints[0].blockNumber;\r\n\r\n        distributedAmount = _redeemAllView(address(0));\r\n\r\n        totalDeposit = totalDeposited;\r\n\r\n        poolRate = getPoolRate(address(0), _fromBlockNumber, _toBlockNumber);\r\n\r\n        return (\r\n            rewardStartBlockNumber,\r\n            distributedAmount,\r\n            totalDeposit,\r\n            poolRate\r\n        );\r\n    }\r\n\r\n    function userInformation(address userAddr, uint256 _fromBlockNumber, uint256 _toBlockNumber) external view returns (\r\n        uint256 stakedTokenAmount,\r\n        uint256 rewardStartBlockNumber,\r\n        uint256 claimStartBlockNumber,\r\n        uint256 earnedTokenAmount,\r\n        uint256 poolRate\r\n        )\r\n    {\r\n        Account memory user = accounts[userAddr];\r\n\r\n        stakedTokenAmount = user.deposited;\r\n\r\n        if(rewardPerBlock == 0) rewardStartBlockNumber = registeredPoints[0].blockNumber;\r\n        else rewardStartBlockNumber = registeredPoints[0].blockNumber;\r\n\r\n        earnedTokenAmount = _redeemAllView(userAddr);\r\n\r\n        poolRate = getPoolRate(userAddr, _fromBlockNumber, _toBlockNumber);\r\n\r\n        return (stakedTokenAmount, rewardStartBlockNumber, claimStartBlockNumber, earnedTokenAmount, poolRate);\r\n    }\r\n\r\n    function modelInfo() external view returns (uint256, uint256, uint256, uint256, uint256) {\r\n        return (rewardPerBlock, decrementUnitPerBlock, rewardLane, lastBlockNum, totalDeposited);\r\n    }\r\n\r\n    function getParams() external view returns (uint256, uint256, uint256, uint256) {\r\n        return (rewardPerBlock, rewardLane, lastBlockNum, totalDeposited);\r\n    }\r\n\r\n    function getRegisteredPointLength() external view returns (uint256) {\r\n        return registeredPoints.length;\r\n    }\r\n\r\n    function getRegisteredPoint(uint256 index) external view returns (uint256, uint256, uint256) {\r\n        RewardVelocityPoint memory point = registeredPoints[index];\r\n        return (point.blockNumber, point.rewardPerBlock, point.decrementUnitPerBlock);\r\n    }\r\n\r\n    function userInfo(address userAddr) external view returns (uint256, uint256, uint256) {\r\n        Account memory user = accounts[userAddr];\r\n        uint256 earnedRewardAmount = _redeemAllView(userAddr);\r\n\r\n        return (user.deposited, user.pointOnLane, earnedRewardAmount);\r\n    }\r\n\r\n    function distributionInfo() external view returns (uint256, uint256, uint256) {\r\n        uint256 totalDistributedRewardAmount_now = _distributedRewardAmountView();\r\n        return (rewardPerBlock, decrementUnitPerBlock, totalDistributedRewardAmount_now);\r\n    }\r\n\r\n    function _distributedRewardAmountView() internal view returns (uint256) {\r\n        return _redeemAllView( address(0) );\r\n    }\r\n\r\n    function _redeemAllView(address userAddr) internal view returns (uint256) {\r\n        Account memory user;\r\n        uint256 newRewardLane;\r\n        if( userAddr != address(0) ) {\r\n            user = accounts[userAddr];\r\n            newRewardLane = _updateRewardLaneView(lastBlockNum);\r\n        } else {\r\n            user = Account(totalDeposited, 0, 0);\r\n            newRewardLane = _updateRewardLaneView(0);\r\n        }\r\n\r\n        uint256 distance = safeSub(newRewardLane, user.pointOnLane);\r\n        uint256 rewardAmount = expMul(user.deposited, distance);\r\n\r\n        return safeAdd(user.rewardAmount, rewardAmount);\r\n    }\r\n\r\n    function _updateRewardLaneView(uint256 fromBlockNumber) internal view returns (uint256) {\r\n        /// @dev Set up memory variables used for calculation temporarily.\r\n        UpdateRewardLaneModel memory vars;\r\n\r\n        vars.len = registeredPoints.length;\r\n        vars.memTotalDeposit = totalDeposited;\r\n\r\n        if(fromBlockNumber == 0){\r\n            vars.tmpPassedPoint = vars.memPassedPoint = 0;\r\n\r\n            vars.memThisBlockNum = block.number;\r\n            vars.tmpLastBlockNum = vars.memLastBlockNum = 0;\r\n            vars.tmpRewardLane = vars.memRewardLane = 0;\r\n            vars.tmpRewardPerBlock = vars.memRewardPerBlock = 0;\r\n            vars.tmpDecrementUnitPerBlock = vars.memDecrementUnitPerBlock = 0;\r\n        } else {\r\n            vars.tmpPassedPoint = vars.memPassedPoint = passedPoint;\r\n            vars.memThisBlockNum = block.number;\r\n            vars.tmpLastBlockNum = vars.memLastBlockNum = fromBlockNumber;\r\n\r\n            vars.tmpRewardLane = vars.memRewardLane = rewardLane;\r\n            vars.tmpRewardPerBlock = vars.memRewardPerBlock = rewardPerBlock;\r\n            vars.tmpDecrementUnitPerBlock = vars.memDecrementUnitPerBlock = decrementUnitPerBlock;\r\n        }\r\n\r\n        for(uint256 i=vars.memPassedPoint; i<vars.len; i++) {\r\n            RewardVelocityPoint memory point = registeredPoints[i];\r\n            /**\r\n             * @dev Check whether this reward velocity point is valid and has\r\n               not applied yet.\r\n             */\r\n            if(vars.tmpLastBlockNum < point.blockNumber && point.blockNumber <= vars.memThisBlockNum) {\r\n                vars.tmpPassedPoint = i+1;\r\n                /// @dev Update the reward lane with the tmp variables\r\n                vars.tmpBlockDelta = safeSub(point.blockNumber, vars.tmpLastBlockNum);\r\n                (vars.tmpRewardLane, vars.tmpRewardPerBlock) =\r\n                _calcNewRewardLane(\r\n                    vars.tmpRewardLane,\r\n                    vars.memTotalDeposit,\r\n                    vars.tmpRewardPerBlock,\r\n                    vars.tmpDecrementUnitPerBlock,\r\n                    vars.tmpBlockDelta);\r\n\r\n                /// @dev Update the tmp variables with this reward velocity point.\r\n                vars.tmpLastBlockNum = point.blockNumber;\r\n                vars.tmpRewardPerBlock = point.rewardPerBlock;\r\n                vars.tmpDecrementUnitPerBlock = point.decrementUnitPerBlock;\r\n                /**\r\n                 * @dev Notify the update of the parameters (by passing the\r\n                   reward velocity points)\r\n                 */\r\n            } else {\r\n                /// @dev sorted array, exit eariler without accessing future points.\r\n                break;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @dev Update the reward lane for the remained period between the\r\n           latest velocity point and this moment (block)\r\n         */\r\n        if(vars.memThisBlockNum > vars.tmpLastBlockNum) {\r\n            vars.tmpBlockDelta = safeSub(vars.memThisBlockNum, vars.tmpLastBlockNum);\r\n            vars.tmpLastBlockNum = vars.memThisBlockNum;\r\n            (vars.tmpRewardLane, vars.tmpRewardPerBlock) =\r\n            _calcNewRewardLane(\r\n                vars.tmpRewardLane,\r\n                vars.memTotalDeposit,\r\n                vars.tmpRewardPerBlock,\r\n                vars.tmpDecrementUnitPerBlock,\r\n                vars.tmpBlockDelta);\r\n        }\r\n        return vars.tmpRewardLane;\r\n    }\r\n    /**\r\n     * @notice Get The rewardPerBlock of user in suggested period(see params)\r\n     * @param userAddr The Address of user, 0 for total\r\n     * @param fromBlockNumber calculation start block number\r\n     * @param toBlockNumber calculation end block number\r\n     * @notice this function calculate based on current contract state\r\n     */\r\n    function getPoolRate(address userAddr, uint256 fromBlockNumber, uint256 toBlockNumber) internal view returns (uint256) {\r\n        UpdateRewardLaneModel memory vars;\r\n\r\n        vars.len = registeredPoints.length;\r\n        vars.memTotalDeposit = totalDeposited;\r\n\r\n        vars.tmpLastBlockNum = vars.memLastBlockNum = fromBlockNumber;\r\n        (vars.memPassedPoint, vars.memRewardPerBlock, vars.memDecrementUnitPerBlock) = getParamsByBlockNumber(fromBlockNumber);\r\n        vars.tmpPassedPoint = vars.memPassedPoint;\r\n        vars.tmpRewardPerBlock = vars.memRewardPerBlock;\r\n        vars.tmpDecrementUnitPerBlock = vars.memDecrementUnitPerBlock;\r\n\r\n        vars.memThisBlockNum = toBlockNumber;\r\n        vars.tmpRewardLane = vars.memRewardLane = 0;\r\n\r\n        for(uint256 i=vars.memPassedPoint; i<vars.len; i++) {\r\n            RewardVelocityPoint memory point = registeredPoints[i];\r\n\r\n            if(vars.tmpLastBlockNum < point.blockNumber && point.blockNumber <= vars.memThisBlockNum) {\r\n                vars.tmpPassedPoint = i+1;\r\n                vars.tmpBlockDelta = safeSub(point.blockNumber, vars.tmpLastBlockNum);\r\n                (vars.tmpRewardLane, vars.tmpRewardPerBlock) =\r\n                _calcNewRewardLane(\r\n                    vars.tmpRewardLane,\r\n                    vars.memTotalDeposit,\r\n                    vars.tmpRewardPerBlock,\r\n                    vars.tmpDecrementUnitPerBlock,\r\n                    vars.tmpBlockDelta);\r\n\r\n                vars.tmpLastBlockNum = point.blockNumber;\r\n                vars.tmpRewardPerBlock = point.rewardPerBlock;\r\n                vars.tmpDecrementUnitPerBlock = point.decrementUnitPerBlock;\r\n\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(vars.memThisBlockNum > vars.tmpLastBlockNum) {\r\n            vars.tmpBlockDelta = safeSub(vars.memThisBlockNum, vars.tmpLastBlockNum);\r\n            vars.tmpLastBlockNum = vars.memThisBlockNum;\r\n            (vars.tmpRewardLane, vars.tmpRewardPerBlock) =\r\n            _calcNewRewardLane(\r\n                vars.tmpRewardLane,\r\n                vars.memTotalDeposit,\r\n                vars.tmpRewardPerBlock,\r\n                vars.tmpDecrementUnitPerBlock,\r\n                vars.tmpBlockDelta);\r\n        }\r\n\r\n        Account memory user;\r\n        if( userAddr != address(0) ) user = accounts[userAddr];\r\n        else user = Account(vars.memTotalDeposit, 0, 0);\r\n\r\n        return safeDiv(expMul(user.deposited, vars.tmpRewardLane), safeSub(toBlockNumber, fromBlockNumber));\r\n    }\r\n\r\n    function getParamsByBlockNumber(uint256 _blockNumber) internal view returns (uint256, uint256, uint256) {\r\n        uint256 _rewardPerBlock; uint256 _decrement;\r\n        uint256 i;\r\n\r\n        uint256 tmpthisPoint;\r\n\r\n        uint256 pointLength = registeredPoints.length;\r\n        if( pointLength > 0 ) {\r\n            for(i = 0; i < pointLength; i++) {\r\n                RewardVelocityPoint memory point = registeredPoints[i];\r\n                if(_blockNumber >= point.blockNumber && 0 != point.blockNumber) {\r\n                    tmpthisPoint = i;\r\n                    _rewardPerBlock = point.rewardPerBlock;\r\n                    _decrement = point.decrementUnitPerBlock;\r\n                } else if( 0 == point.blockNumber ) continue;\r\n                else break;\r\n            }\r\n        }\r\n        RewardVelocityPoint memory point = registeredPoints[tmpthisPoint];\r\n        _rewardPerBlock = point.rewardPerBlock;\r\n        _decrement = point.decrementUnitPerBlock;\r\n        if(_blockNumber > point.blockNumber) {\r\n            _rewardPerBlock = safeSub(_rewardPerBlock, safeMul(_decrement, safeSub(_blockNumber, point.blockNumber) ) );\r\n        }\r\n        return (i, _rewardPerBlock, _decrement);\r\n    }\r\n\r\n    function getUserPoolRate(address userAddr, uint256 fromBlockNumber, uint256 toBlockNumber) external view returns (uint256) {\r\n        return getPoolRate(userAddr, fromBlockNumber, toBlockNumber);\r\n    }\r\n\r\n    function getModelPoolRate(uint256 fromBlockNumber, uint256 toBlockNumber) external view returns (uint256) {\r\n        return getPoolRate(address(0), fromBlockNumber, toBlockNumber);\r\n    }\r\n}\r\n\r\n// File: contracts/module/externalModule.sol\r\n\r\n\r\n/**\r\n * @title BiFi's Reward Distribution External Contract\r\n * @notice Implements the service actions.\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ncontract externalModule is viewModule {\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"onlyOwner: external function access control!\");\r\n        _;\r\n    }\r\n    modifier checkClaimLocked() {\r\n        require(!claimLock, \"error: claim Locked\");\r\n        _;\r\n    }\r\n    modifier checkWithdrawLocked() {\r\n        require(!withdrawLock, \"error: withdraw Locked\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Deposit-Token address\r\n     * @param erc20Addr The address of Deposit Token\r\n     */\r\n    function setERC(address erc20Addr) external onlyOwner {\r\n        lpErc = ERC20(erc20Addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Contribution-Token address\r\n     * @param erc20Addr The address of Contribution Token\r\n     */\r\n    function setRE(address erc20Addr) external onlyOwner {\r\n        rewardErc = ERC20(erc20Addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the reward distribution parameters instantly\r\n     */\r\n    function setParam(uint256 _rewardPerBlock, uint256 _decrementUnitPerBlock) onlyOwner external {\r\n        _setParams(_rewardPerBlock, _decrementUnitPerBlock);\r\n    }\r\n\r\n    /**\r\n     * @notice Terminate Contract Distribution\r\n     */\r\n    function modelFinish(uint256 amount) external onlyOwner {\r\n        if( amount != 0) {\r\n            require( rewardErc.transfer(owner, amount), \"token error\" );\r\n        }\r\n        else {\r\n            require( rewardErc.transfer(owner, rewardErc.balanceOf(address(this))), \"token error\" );\r\n        }\r\n        delete totalDeposited;\r\n        delete rewardPerBlock;\r\n        delete decrementUnitPerBlock;\r\n        delete rewardLane;\r\n        delete totalDeposited;\r\n        delete registeredPoints;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the Remaining Contribution Tokens\r\n     */\r\n    function retrieveRewardAmount(uint256 amount) external onlyOwner {\r\n        if( amount != 0) {\r\n            require( rewardErc.transfer(owner, amount), \"token error\");\r\n        }\r\n        else {\r\n            require( rewardErc.transfer(owner, rewardErc.balanceOf(address(this))), \"token error\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit the Contribution Tokens\r\n     * @param amount The amount of the Contribution Tokens\r\n     */\r\n    function deposit(uint256 amount) external {\r\n        address userAddr = msg.sender;\r\n        _redeemAll(userAddr);\r\n        _deposit(userAddr, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit the Contribution Tokens to target user\r\n     * @param userAddr The target user\r\n     * @param amount The amount of the Contribution Tokens\r\n     */\r\n    function depositTo(address userAddr, uint256 amount) external {\r\n        _redeemAll(userAddr);\r\n        _deposit(userAddr, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw the Contribution Tokens\r\n     * @param amount The amount of the Contribution Tokens\r\n     */\r\n    function withdraw(uint256 amount) checkWithdrawLocked external {\r\n        address userAddr = msg.sender;\r\n        _redeemAll(userAddr);\r\n        _withdraw(userAddr, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim the Reward Tokens\r\n     * @dev Transfer all reward the user has earned at once.\r\n     */\r\n    function rewardClaim() checkClaimLocked external {\r\n        address userAddr = msg.sender;\r\n        _redeemAll(userAddr);\r\n        _rewardClaim(userAddr);\r\n    }\r\n    /**\r\n     * @notice Claim the Reward Tokens\r\n     * @param userAddr The targetUser\r\n     * @dev Transfer all reward the target user has earned at once.\r\n     */\r\n    function rewardClaimTo(address userAddr) checkClaimLocked external {\r\n        _redeemAll(userAddr);\r\n        _rewardClaim(userAddr);\r\n    }\r\n\r\n    /// @dev Set locks & access control\r\n    function setClaimLock(bool lock) onlyOwner external {\r\n        _setClaimLock(lock);\r\n    }\r\n    function setWithdrawLock(bool lock) onlyOwner external {\r\n        _setWithdrawLock(lock);\r\n    }\r\n    function ownershipTransfer(address to) onlyOwner external {\r\n        _ownershipTransfer(to);\r\n    }\r\n\r\n    /**\r\n     * @notice Register a new future reward velocity point\r\n     */\r\n    function registerRewardVelocity(uint256 _blockNumber, uint256 _rewardPerBlock, uint256 _decrementUnitPerBlock) onlyOwner public {\r\n        require(_blockNumber > block.number, \"new Reward params should register earlier\");\r\n        require(registeredPoints.length == 0 || _blockNumber > registeredPoints[registeredPoints.length-1].blockNumber, \"Earilier velocity points are already set.\");\r\n        _registerRewardVelocity(_blockNumber, _rewardPerBlock, _decrementUnitPerBlock);\r\n    }\r\n    function deleteRegisteredRewardVelocity(uint256 _index) onlyOwner external {\r\n        require(_index >= passedPoint, \"Reward velocity point already passed.\");\r\n        _deleteRegisteredRewardVelocity(_index);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the reward distribution parameters\r\n     */\r\n    function setRewardVelocity(uint256 _rewardPerBlock, uint256 _decrementUnitPerBlock) onlyOwner external {\r\n        _updateRewardLane();\r\n        _setParams(_rewardPerBlock, _decrementUnitPerBlock);\r\n    }\r\n}\r\n\r\n// File: contracts/DistributionModelV3.sol\r\n\r\n\r\n/**\r\n * @title BiFi's Reward Distribution Contract\r\n * @notice Implements voting process along with vote delegation\r\n * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\r\n */\r\ncontract DistributionModelV3 is externalModule {\r\n    constructor(address _owner, address _lpErc, address _rewardErc) public {\r\n        owner = _owner;\r\n        lpErc = ERC20(_lpErc);\r\n        rewardErc = ERC20(_rewardErc);\r\n        lastBlockNum = block.number;\r\n    }\r\n}\r\n\r\ncontract BFCModel is DistributionModelV3 {\r\n    constructor(address _owner, address _lpErc, address _rewardErc, uint256 _start)\r\n    DistributionModelV3(_owner, _lpErc, _rewardErc) public {\r\n        /*\r\n        _start: parameter start block nubmer\r\n        0x3935413a1cdd90ff: fixed point(1e18) reward per blocks\r\n        0x62e9bea75f: fixed point(1e18) decrement per blocks\r\n        */\r\n        _registerRewardVelocity(_start, 0x3935413a1cdd90ff, 0x62e9bea75f);\r\n    }\r\n}\r\n\r\ncontract BFCETHModel is DistributionModelV3 {\r\n    constructor(address _owner, address _lpErc, address _rewardErc, uint256 _start)\r\n    DistributionModelV3(_owner, _lpErc, _rewardErc) public {\r\n        /*\r\n        _start: parameter start block nubmer\r\n        0xe4d505786b744b3f: fixed point(1e18) reward per blocks\r\n        0x18ba6fb966b: fixed point(1e18) decrement per blocks\r\n        */\r\n        _registerRewardVelocity(_start, 0xe4d505786b744b3f, 0x18ba6fb966b);\r\n    }\r\n}\r\n\r\ncontract BiFiETHModel is DistributionModelV3 {\r\n    constructor(address _owner, address _lpErc, address _rewardErc, uint256 _start)\r\n    DistributionModelV3(_owner, _lpErc, _rewardErc) public {\r\n        /*\r\n        _start: parameter start block nubmer\r\n        0x11e0a46e285a68955: fixed point(1e18) reward per blocks\r\n        0x1ee90ba90c4: fixed point(1e18) decrement per blocks\r\n        */\r\n        _registerRewardVelocity(_start, 0x11e0a46e285a68955, 0x1ee90ba90c4);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lpErc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardErc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"}],\"name\":\"ClaimLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"atBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decrementUnitPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"arrayLen\",\"type\":\"uint256\"}],\"name\":\"DeleteRegisterRewardParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"atBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decrementUnitPerBlock\",\"type\":\"uint256\"}],\"name\":\"RegisterRewardParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decrementUnitPerBlock\",\"type\":\"uint256\"}],\"name\":\"SetRewardParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"atBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decrementUnitPerBlock\",\"type\":\"uint256\"}],\"name\":\"UpdateRewardParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"}],\"name\":\"WithdrawLock\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pointOnLane\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decrementUnitPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"deleteRegisteredRewardVelocity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toBlockNumber\",\"type\":\"uint256\"}],\"name\":\"getModelPoolRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRegisteredPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredPointLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toBlockNumber\",\"type\":\"uint256\"}],\"name\":\"getUserPoolRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBlockNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpErc\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toBlockNumber\",\"type\":\"uint256\"}],\"name\":\"marketInformation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardStartBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"distributedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"modelFinish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modelInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ownershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"passedPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decrementUnitPerBlock\",\"type\":\"uint256\"}],\"name\":\"registerRewardVelocity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decrementUnitPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"retrieveRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"rewardClaimTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardErc\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardLane\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"}],\"name\":\"setClaimLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Addr\",\"type\":\"address\"}],\"name\":\"setERC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decrementUnitPerBlock\",\"type\":\"uint256\"}],\"name\":\"setParam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Addr\",\"type\":\"address\"}],\"name\":\"setRE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decrementUnitPerBlock\",\"type\":\"uint256\"}],\"name\":\"setRewardVelocity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"}],\"name\":\"setWithdrawLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fromBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toBlockNumber\",\"type\":\"uint256\"}],\"name\":\"userInformation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardStartBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimStartBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnedTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BFCModel", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000359903041de93c69828f911aeb0be29cc9ccc58b0000000000000000000000000c7d5ae016f806603cb1782bea29ac69471cab9c000000000000000000000000db7bb52ac3f9e2f6153a3f9dcdd4d67f9f8360340000000000000000000000000000000000000000000000000000000000b09d48", "EVMVersion": "Default", "Library": "", "LicenseType": "BSD-3-Clause", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c4a83c86d0f7ef3050ab249a43e9a049c0888eb6032b03d57b942652efa27fd9"}