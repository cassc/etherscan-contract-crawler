{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@nftculture/nftc-contracts-private/contracts/access/v2/OwnableDeferral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title OwnableDeferral\\n * @author @NiftyMike | @NFTCulture\\n * @dev Implements checks for contract admin operations. Will be Backed by\\n * OZ Ownable.\\n *\\n * This contract is helpful when a contract tree gets complicated,\\n * and multiple contracts need to leverage Ownable.\\n *\\n * Sample Implementation:\\n *\\n * modifier isOwner() override(...) {\\n *     _isOwner();\\n *     _;\\n * }\\n *\\n * function _isOwner() internal view override(...) {\\n *     _checkOwner();\\n * }\\n */\\nabstract contract OwnableDeferral {\\n    modifier isOwner() virtual;\\n\\n    function _isOwner() internal view virtual;\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/access/v2/OwnableDeferralResolution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// OZ Libraries\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\n\\n// Local References\\nimport './OwnableDeferral.sol';\\n\\n// Error Codes\\nerror CallerIsNotOwner();\\n\\n/**\\n * @title OwnableDeferralResolution\\n * @author @NiftyMike | @NFTCulture\\n * @dev Implements checks for contract admin (Owner) operations. Backed by OZ Ownable.\\n *\\n * Ownership is assigned to contract deployer wallet by default.\\n *\\n * NOTE: IMPORTANT - This resolution will work great in a simple inheritance situation,\\n * however, if multiple inheritance is involved, it might not adequately satisfy\\n * override (...) conditions. In those scenarios, this code should be used as a\\n * starting point and then adjusted appropriately.\\n */\\ncontract OwnableDeferralResolution is Ownable, OwnableDeferral {\\n    modifier isOwner() virtual override {\\n        _isOwner();\\n        _;\\n    }\\n\\n    function _isOwner() internal view virtual override {\\n        // Same as _checkOwner() but using error code instead of a require statement.\\n        if (owner() != _msgSender()) revert CallerIsNotOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/chainnative/interfaces/IHTMLConstructorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/**\\n * @title IHTMLConstructorV2\\n * @author @NiftyMike | @NFTCulture\\n * @dev An API for rendering an HTML page, offering maximum flexibility.\\n */\\ninterface IHTMLConstructorV2 {\\n    /**\\n     * @notice Dynamically construct an html page string from page params passed via pageScope.\\n     *\\n     * @param pageScopeHead - a set of params to render the page.\\n     * @param pageScopeBody - a set of params to render the page.\\n     */\\n    function construct(\\n        string[] memory pageScopeHead,\\n        string[] memory pageScopeBody\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v2/interfaces/IChainNativeArtProducer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title IChainNativeArtProducer\\n * @author @NiftyMike | @NFTCulture\\n * @dev Super thin interface definition for a contract that\\n * produces art in a chain native way.\\n */\\ninterface IChainNativeArtProducer {\\n    /**\\n     * Given a token descriptor, return a string that can be directly inserted into an\\n     * NFT metadata attribute such as image.\\n     *\\n     * @param tokenType type of the art piece\\n     * @param extraData extra info that can be used to get the art, if applicable\\n     */\\n    function getArtAsString(uint64 tokenType, uint256 extraData) external view returns (string memory);\\n\\n    /**\\n     * Given a token descriptor, return a string that can be directly inserted into an\\n     * NFT metadata attribute such as animation_url.\\n     *\\n     * @param tokenType type of the art piece\\n     * @param extraData extra info that can be used to get the animation, if applicable\\n     */\\n    function getAnimationAsString(uint64 tokenType, uint256 extraData) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v3/art-managers/DynamicHTMLArtManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// OZ Libraries\\nimport '@openzeppelin/contracts/utils/Base64.sol';\\n\\n// Local References\\nimport '../interfaces/AbstractArtManager.sol';\\nimport '../../../chainnative/interfaces/IHTMLConstructorV2.sol';\\n\\n/**\\n * @title DynamicHTMLArtManager\\n * @author @NiftyMike | @NFTCulture\\n * @dev An on-chain contract that constructs a dynamically generated HTML page.\\n */\\nabstract contract DynamicHTMLArtManager is AbstractArtManager {\\n    function _getHtmlDataURI(uint64 tokenType, uint256 extraData) internal view returns (string memory) {\\n        DynamicArtV3 memory artObject = _getArtObject(tokenType);\\n\\n        string memory html = _callHtmlConstruct(\\n            tokenType,\\n            _extractPageScopeFromHeadData(tokenType, extraData, artObject.renderDataHead),\\n            _extractPageScopeFromBodyData(tokenType, extraData, artObject.renderDataBody)\\n        );\\n\\n        return _convertHtmlToDataURI(html);\\n    }\\n\\n    function _convertHtmlToDataURI(string memory html) internal pure returns (string memory) {\\n        return string.concat('data:text/html;base64,', Base64.encode(bytes(html)));\\n    }\\n\\n    function _callHtmlConstruct(\\n        uint64 tokenType,\\n        string[] memory pageScopeHead,\\n        string[] memory pageScopeBody\\n    ) internal view virtual returns (string memory) {\\n        return _getHtmlConstructor(tokenType).construct(pageScopeHead, pageScopeBody);\\n    }\\n\\n    /**\\n     * Function should return an IHTMLConstructor implementation given a tokenType.\\n     *\\n     * @param tokenType - tokenType to construct\\n     */\\n    function _getHtmlConstructor(uint64 tokenType) internal view virtual returns (IHTMLConstructorV2 htmlConstructorV2);\\n\\n    /**\\n     * Function should return a properly sized pageScopeHead for the embedded IHTMLConstructorV2 implementation.\\n     *\\n     * @param renderDataHead - a string array describing details of an art object.\\n     */\\n    function _extractPageScopeFromHeadData(\\n        uint64 tokenType,\\n        uint256 extraData,\\n        string[] memory renderDataHead\\n    ) internal view virtual returns (string[] memory pageScopeHead);\\n\\n    /**\\n     * Function should return a properly sized pageScopeBody for the embedded IHTMLConstructorV2 implementation.\\n     *\\n     * @param renderDataBody - a string array describing details of an art object.\\n     */\\n    function _extractPageScopeFromBodyData(\\n        uint64 tokenType,\\n        uint256 extraData,\\n        string[] memory renderDataBody\\n    ) internal view virtual returns (string[] memory pageScopeBody);\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v3/interfaces/AbstractArtManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// Local References\\nimport '../../../access/v2/OwnableDeferral.sol';\\nimport '../../v2/interfaces/IChainNativeArtProducer.sol';\\nimport './IDynamicArt.sol';\\n\\n// Error Codes\\nerror ArtPieceInputMismatch(uint256, uint256, uint256);\\nerror ArtPieceCountExceeded();\\nerror ArtPieceDoesNotExist(uint64);\\nerror ArtPieceAlreadyCreated(uint64);\\nerror NullTokenType();\\n\\n/**\\n * @title AbstractArtManager\\n * @author @NiftyMike | @NFTCulture\\n * @dev A class for managing the datastore that holds Art pieces as either strings or bytes.\\n */\\nabstract contract AbstractArtManager is IDynamicArtV3, IChainNativeArtProducer, OwnableDeferral {\\n    // Storage for Token Attribute Definitions\\n    mapping(uint64 => DynamicArtV3) private _artObjects;\\n    uint64[] private _artPieceTokenTypes;\\n\\n    uint256 private immutable _maxNumberOfArtPieces;\\n\\n    constructor(uint256 __maxNumberOfArtPieces) {\\n        _maxNumberOfArtPieces = __maxNumberOfArtPieces;\\n    }\\n\\n    function createArtPieces(\\n        uint64[] calldata tokenTypes,\\n        string[][] calldata renderDataHeads,\\n        string[][] calldata renderDataBodys\\n    ) external isOwner {\\n        if (tokenTypes.length != renderDataHeads.length || tokenTypes.length != renderDataBodys.length)\\n            revert ArtPieceInputMismatch(tokenTypes.length, renderDataHeads.length, renderDataBodys.length);\\n\\n        uint256 idx;\\n        for (; idx < tokenTypes.length; idx++) {\\n            _createArtPiece(tokenTypes[idx], renderDataHeads[idx], renderDataBodys[idx]);\\n        }\\n    }\\n\\n    function createArtPiece(\\n        uint64 tokenType,\\n        string[] calldata renderDataHead,\\n        string[] calldata renderDataBody\\n    ) external isOwner {\\n        _createArtPiece(tokenType, renderDataHead, renderDataBody);\\n    }\\n\\n    function updateArtPiece(\\n        uint64 tokenType,\\n        string[] calldata renderDataHead,\\n        string[] calldata renderDataBody\\n    ) external isOwner {\\n        if (tokenType == 0) revert NullTokenType();\\n        DynamicArtV3 memory current = _artObjects[tokenType];\\n        if (current.tokenType == 0) revert ArtPieceDoesNotExist(tokenType);\\n        _validateRenderData(renderDataHead, renderDataBody);\\n\\n        current.tokenType = tokenType;\\n\\n        if (renderDataHead.length > 0) {\\n            current.renderDataHead = renderDataHead;\\n        }\\n\\n        if (renderDataBody.length > 0) {\\n            current.renderDataBody = renderDataBody;\\n        }\\n\\n        _artObjects[tokenType] = current;\\n    }\\n\\n    function _createArtPiece(\\n        uint64 tokenType,\\n        string[] calldata renderDataHead,\\n        string[] calldata renderDataBody\\n    ) internal {\\n        if (tokenType == 0) revert NullTokenType();\\n        if (_maxNumberOfArtPieces > 0 && _artPieceTokenTypes.length + 1 > _maxNumberOfArtPieces)\\n            revert ArtPieceCountExceeded();\\n        if (_artObjects[tokenType].tokenType > 0) revert ArtPieceAlreadyCreated(tokenType);\\n        _validateRenderData(renderDataHead, renderDataBody);\\n\\n        DynamicArtV3 memory current;\\n        current.tokenType = tokenType;\\n        current.renderDataHead = renderDataHead;\\n        current.renderDataBody = renderDataBody;\\n\\n        _artObjects[tokenType] = current;\\n        _artPieceTokenTypes.push(tokenType);\\n    }\\n\\n    function _validateRenderData(\\n        string[] calldata renderDataHead,\\n        string[] calldata renderDataBody\\n    ) internal view virtual {\\n        // Default implementation does nothing. Override if checks are needed.\\n    }\\n\\n    function getArtObject(uint64 tokenType) external view returns (DynamicArtV3 memory) {\\n        return _getArtObject(tokenType);\\n    }\\n\\n    function _getArtObject(uint64 tokenType) internal view returns (DynamicArtV3 memory) {\\n        return _artObjects[tokenType];\\n    }\\n\\n    function getArtPieceTokenTypes() external view returns (uint64[] memory) {\\n        return _getArtPieceTokenTypes();\\n    }\\n\\n    function _getArtPieceTokenTypes() internal view returns (uint64[] memory) {\\n        return _artPieceTokenTypes;\\n    }\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v3/interfaces/IDynamicArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title IDynamicArtV3\\n * @author @NFTMike | @NFTCulture\\n * @dev Interface that defines the data structure of on-chain artwork.\\n *\\n * V3 implementation moves to a generic string array.\\n */\\ninterface IDynamicArtV3 {\\n    struct DynamicArtV3 {\\n        uint64 tokenType;\\n        string[] renderDataHead;\\n        string[] renderDataBody;\\n    }\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts/contracts/interfaces/scriptysol/IScriptyStorageProviderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n///////////////////////////////////////////////////////////\\n// \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557 //\\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d //\\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591 //\\n// \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591 //\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591 //\\n// \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591 //\\n///////////////////////////////////////////////////////////\\n\\n/**\\n * @title IScriptyStorageProviderV2\\n * @author @NiftyMike | @NFTCulture\\n * @dev An interface wrapper for a ScriptStorage contract, when we only need to read data from it.\\n * @dev Special thanks to @0xthedude and @xtremetom for providing this library.\\n * See: https://github.com/intartnft/scripty.sol\\n */\\ninterface IScriptyStorageProviderV2 {\\n    /**\\n     * @notice Get the full content\\n     * @param name - Name given to the content. Eg: threejs.min.js_r148\\n     * @param data - Arbitrary data. Not used by this contract.\\n     * @return content - Full content from merged chunks\\n     */\\n    function getContent(string memory name, bytes memory data) external view returns (bytes memory content);\\n\\n    /**\\n     * @notice Get content's chunk pointer list\\n     * @param name - Name given to the content. Eg: threejs.min.js_r148\\n     * @return pointers - List of pointers\\n     */\\n    function getContentChunkPointers(string memory name) external view returns (address[] memory pointers);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.6) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 0x20)\\n            let dataPtr := data\\n            let endPtr := add(data, mload(data))\\n\\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\\n            // set it to zero to make sure no dirty bytes are read in that section.\\n            let afterPtr := add(endPtr, 0x20)\\n            let afterCache := mload(afterPtr)\\n            mstore(afterPtr, 0x00)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 byte (24 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\\n                // Use this as an index into the lookup table, mload an entire word\\n                // so the desired character is in the least significant byte, and\\n                // mstore8 this least significant byte into the result and continue.\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // Reset the value that was cached\\n            mstore(afterPtr, afterCache)\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CRAART/SourceChainNativeArtStack.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\n// Local References\\nimport './SourceChainNativeArtStackBase.sol';\\n\\n/**\\n * @title SourceChainNativeArtStack\\n *\\n *  \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591 \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\\n * \u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\\n * \u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591\\n *  \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\\n *        \u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591      \u2591\u2592\u2593\u2588\u2593\u2592\u2591\\n *        \u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2592\u2593\u2588\u2593\u2592\u2591\\n * \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591 \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591 \u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2591\u2592\u2593\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2593\u2592\u2591\\n *\\n * @dev Thanks to Patrick Gillespie (@patorjk) for Text to ASCII Art Generator (TAAG).\\n */\\ncontract SourceChainNativeArtStack is SourceChainNativeArtStackBase {\\n    address private constant DEFAULT_HTML_CONSTRUCTOR_CONTRACT = 0xF265aA99E72F7f6716E00A74722AF969802A6a6C; // Mainnet v1\\n    uint256 private constant maxNumberOfArtPieces = 1;\\n\\n    constructor()\\n        SourceChainNativeArtStackBase(DEFAULT_HTML_CONSTRUCTOR_CONTRACT)\\n        AbstractArtManager(maxNumberOfArtPieces)\\n    {\\n        // Implementation version: v1.0.0\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CRAART/SourceChainNativeArtStackBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// NFTC Open Source Contracts See: https://github.com/NFTCulture/nftc-contracts\\nimport '@nftculture/nftc-contracts/contracts/interfaces/scriptysol/IScriptyStorageProviderV2.sol';\\n\\n// NFTC Prerelease Contracts\\nimport '@nftculture/nftc-contracts-private/contracts/access/v2/OwnableDeferralResolution.sol';\\nimport '@nftculture/nftc-contracts-private/contracts/metadata/v3/art-managers/DynamicHTMLArtManager.sol';\\n\\n// OZ Libraries\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\n\\n// Local References\\nimport '../LibMath.sol';\\n\\n// Error Codes\\nerror UnrecognizedExtension(string);\\nerror TokenTypeInvalid(uint256);\\nerror RenderDataInvalid(uint256);\\nerror UnrecognizedTagType(uint256);\\nerror ArrayMismatch(uint256);\\n\\n/**\\n * @title SourceChainNativeArtStackBase\\n * @author @NiftyMike | @NFTCulture\\n * @dev This contract implements the NFTC IChainNativeArtProducer API, which means\\n * it contains logic to return the contents of an NFT image / animation_url field\\n * for a given NFT token type.\\n *\\n * In this particular implementation, the contents of animation_url is stored on chain. The preview image used\\n * by marketplaces (the image field) is stored off-chain, initially in a hosted CDN, and at the conclusion of\\n * the mint, it will be moved to an ARWeave bucket.\\n *\\n * The content actually supports fully on-chain animation generation, including its main dependency, p5.js. The\\n * contract leverages Scripty.sol's blockchain storage system to host its own art generation script, and also\\n * to access the community uploaded instance of p5.js 1.5.0.\\n *\\n * At launch, full on-chain will not be enabled, to ensure performance and compatibility with marketplaces. The\\n * three scripts used to generate the artwork can be accessed at any time via the archival API of the contract.\\n */\\nabstract contract SourceChainNativeArtStackBase is DynamicHTMLArtManager, OwnableDeferralResolution {\\n    using Strings for uint256;\\n\\n    // Define additional reserved Render Data fields. New indexes would need a contract update.\\n    uint256 private constant RENDER_DATA_RESERVED_SLOTS = 6;\\n    uint256 private constant RENDER_DATA_INDEX_ART_BASE_URI = 6;\\n    uint256 private constant RENDER_DATA_INDEX_ART_EXTENSION = 7;\\n    uint256 private constant RENDER_DATA_INDEX_SCRIPTY_START = 8;\\n\\n    // Trigger _readDirectOrExternal to Dynamically append an on-chain script\\n    string private constant ON_CHAIN_SCRIPT_METAPHOR = '%scriptySolScript%';\\n    string private constant ENTROPY_INSERTION_POINT_METAPHOR = '%entropy%';\\n\\n    // Config for how html tags should be generated. New tag types or element rendering would need a contract update.\\n    uint256 private constant HTT_UNWRAPPED = 1;\\n    uint256 private constant HTT_ENTROPY_SCRIPT = 11;\\n    uint256 private constant HTT_SCRIPT = 100;\\n    uint256 private constant HTT_SCRIPT_DATA_URI = 200;\\n    uint256 private constant HTT_SCRIPT_DATA_URI_NEEDS_ENCODE = 220;\\n    uint256 private constant HTT_SCRIPT_DATA_URI_DEFER = 300;\\n    uint256 private constant HTT_SCRIPT_DATA_URI_DEFER_NEEDS_ENCODE = 320;\\n    uint256 private constant HTT_SCRIPT_GZIP_BASE_64 = 400;\\n\\n    // All ArchivalMetadata objects in this contract are of this type.\\n    string private constant JS_EXTENSION = 'js';\\n\\n    // Called to render HTML pages\\n    address private _htmlRenderer;\\n\\n    // Stores information about scripts that are archived on the Ethereum blockchain.\\n    struct ArchivalMetadataV2 {\\n        string extension; // This is the first indexer\\n        uint128 scriptOrdinal; // This is the second indexer\\n        uint128 htmlTagType; // Inspired by Script's HtmlTagType, but implemented as an int + constants instead of an enum.\\n        address scriptyStorageProvider; // Address where the file is hosted\\n        string scriptName; // The file name\\n    }\\n\\n    // File extension -> metadatas (zero indexed)\\n    mapping(string => ArchivalMetadataV2[]) private _metadata;\\n\\n    constructor(address __htmlRenderer) {\\n        _setHtmlRenderer(__htmlRenderer);\\n    }\\n\\n    function getHtmlRenderer() external view returns (address) {\\n        return _htmlRenderer;\\n    }\\n\\n    function _getHtmlConstructor(uint64) internal view override returns (IHTMLConstructorV2 htmlConstructor) {\\n        return IHTMLConstructorV2(_htmlRenderer);\\n    }\\n\\n    function setHtmlRenderer(address __htmlRenderer) external isOwner {\\n        _setHtmlRenderer(__htmlRenderer);\\n    }\\n\\n    function _setHtmlRenderer(address __htmlRenderer) internal {\\n        _htmlRenderer = __htmlRenderer;\\n    }\\n\\n    function getArtAsString(\\n        uint64 tokenType,\\n        uint256 extraDataAsTokenId\\n    ) external view override returns (string memory) {\\n        if (_getArtObject(tokenType).tokenType != tokenType) revert TokenTypeInvalid(tokenType);\\n\\n        // Prerender Phase: Display placeholder image, from api-server.\\n        // Postrender Phase / During Mint: Display preview image, from api-server.\\n        // Archive Phase: Display preview image, from ARWeave.\\n        return\\n            string.concat(\\n                _getArtObject(tokenType).renderDataHead[RENDER_DATA_INDEX_ART_BASE_URI],\\n                uint256(uint16(extraDataAsTokenId)).toString(), // TokenId is the lower 16 bits.\\n                _getArtObject(tokenType).renderDataHead[RENDER_DATA_INDEX_ART_EXTENSION]\\n            );\\n    }\\n\\n    function getAnimationAsString(\\n        uint64 tokenType,\\n        uint256 extraDataAsEntropy\\n    ) external view override returns (string memory) {\\n        if (_getArtObject(tokenType).tokenType != tokenType) revert TokenTypeInvalid(tokenType);\\n\\n        return _getHtmlDataURI(tokenType, extraDataAsEntropy);\\n    }\\n\\n    function _extractPageScopeFromHeadData(\\n        uint64 tokenType,\\n        uint256 extraDataAsEntropy,\\n        string[] memory renderDataHead\\n    ) internal view override returns (string[] memory pageScopeHead) {\\n        // Check if we need to truncate.\\n        if (renderDataHead.length > RENDER_DATA_RESERVED_SLOTS) {\\n            // Reserve 6 slots for <head>\\n            pageScopeHead = new string[](RENDER_DATA_RESERVED_SLOTS);\\n            pageScopeHead[0] = renderDataHead[0]; // Slot 0 - <head> -> <title> (JS not supported here)\\n            uint256 idx = 1;\\n            for (; idx < pageScopeHead.length; ) {\\n                // Slots 1 - 5 for <script> <!-- Unassigned --> <style> <script>\\n                pageScopeHead[idx] = _readDirectOrExternal(\\n                    tokenType,\\n                    extraDataAsEntropy,\\n                    renderDataHead,\\n                    renderDataHead[idx],\\n                    idx\\n                );\\n                unchecked {\\n                    idx++;\\n                }\\n            }\\n        } else {\\n            // Base contract will revert if length < 1.\\n            return renderDataHead;\\n        }\\n    }\\n\\n    function _extractPageScopeFromBodyData(\\n        uint64 tokenType,\\n        uint256 extraDataAsEntropy,\\n        string[] memory renderDataBody\\n    ) internal view virtual override returns (string[] memory pageScopeBody) {\\n        // Check if we need to truncate.\\n        if (renderDataBody.length > RENDER_DATA_RESERVED_SLOTS) {\\n            // Reserve 6 slots for <body>\\n            pageScopeBody = new string[](RENDER_DATA_RESERVED_SLOTS);\\n            uint256 idx;\\n            for (; idx < pageScopeBody.length; ) {\\n                // Slots 0 - 5 for <div> <!-- Unassigned --> <!-- Unassigned --> <!-- Unassigned --> <script>\\n                pageScopeBody[idx] = _readDirectOrExternal(\\n                    tokenType,\\n                    extraDataAsEntropy,\\n                    renderDataBody,\\n                    renderDataBody[idx],\\n                    idx\\n                );\\n\\n                unchecked {\\n                    idx++;\\n                }\\n            }\\n        } else {\\n            return renderDataBody;\\n        }\\n    }\\n\\n    function _readDirectOrExternal(\\n        uint64,\\n        uint256 extraDataAsEntropy,\\n        string[] memory renderData,\\n        string memory renderDataBlob,\\n        uint256 scriptyConfigSlot\\n    ) internal view returns (string memory appendBlob) {\\n        if (Strings.equal(renderDataBlob, ON_CHAIN_SCRIPT_METAPHOR)) {\\n            // We have at least one On-Chain request, so the config values for all 6 slots must be provided.\\n            if (renderData.length < RENDER_DATA_INDEX_SCRIPTY_START + RENDER_DATA_RESERVED_SLOTS) {\\n                // A Scripty on-chain metaphor was used, but the appropriate config details were not provided.\\n                revert RenderDataInvalid(renderData.length);\\n            }\\n\\n            uint256 scriptyConfig = LibMath.stringToUint256(\\n                renderData[RENDER_DATA_INDEX_SCRIPTY_START + scriptyConfigSlot]\\n            );\\n\\n            // This approach supports up to 8 on-chain hosted scripts per renderData slot. The limitation is pretty arbitrary.\\n            // [script 8 / script 7 / script 6 / script 5 / script 4 / script 3 / script 2 / script 1]\\n            uint32[8] memory scriptyScriptOrdinals = [\\n                uint32(scriptyConfig),\\n                uint32(scriptyConfig >> 32),\\n                uint32(scriptyConfig >> (32 * 2)),\\n                uint32(scriptyConfig >> (32 * 3)),\\n                uint32(scriptyConfig >> (32 * 4)),\\n                uint32(scriptyConfig >> (32 * 5)),\\n                uint32(scriptyConfig >> (32 * 6)),\\n                uint32(scriptyConfig >> (32 * 7))\\n            ];\\n\\n            uint256 scriptIdx;\\n            for (; scriptIdx < scriptyScriptOrdinals.length; scriptIdx++) {\\n                uint256 scriptyScriptConfig = scriptyScriptOrdinals[scriptIdx];\\n                if (scriptyScriptConfig > 0) {\\n                    // This can throw if scriptyScriptConfig does not exist.\\n                    ArchivalMetadataV2 memory metadata = _metadata[JS_EXTENSION][scriptyScriptConfig - 1];\\n                    (string memory openTag, string memory closingTag) = _selectOpenAndCloseTags(metadata.htmlTagType);\\n                    string memory archivedScript = _getArchivalScript(metadata.extension, metadata.scriptOrdinal);\\n                    appendBlob = string.concat(\\n                        appendBlob,\\n                        openTag,\\n                        (metadata.htmlTagType == HTT_SCRIPT_DATA_URI_NEEDS_ENCODE ||\\n                            metadata.htmlTagType == HTT_SCRIPT_DATA_URI_DEFER_NEEDS_ENCODE)\\n                            ? Base64.encode(bytes(archivedScript))\\n                            : archivedScript,\\n                        closingTag\\n                    );\\n                }\\n            }\\n        } else if (Strings.equal(renderDataBlob, ENTROPY_INSERTION_POINT_METAPHOR)) {\\n            (string memory openTag, string memory closingTag) = _selectOpenAndCloseTags(HTT_ENTROPY_SCRIPT);\\n            appendBlob = string.concat(\\n                appendBlob,\\n                openTag,\\n                _bytes32ToHexString(bytes32(extraDataAsEntropy)),\\n                closingTag\\n            );\\n        } else {\\n            // The normal case. Just append whatever is in the blob to the appropriate slot in the HTML\\n            appendBlob = renderDataBlob;\\n        }\\n    }\\n\\n    function _selectOpenAndCloseTags(uint256 htmlTagType) internal pure returns (string memory, string memory) {\\n        // Inspired by Scripty.sol tagOpenCloseForHTMLTag()\\n        if (htmlTagType == HTT_UNWRAPPED) {\\n            return ('', '');\\n        } else if (htmlTagType == HTT_ENTROPY_SCRIPT) {\\n            return ('<script>const entropy=\\\"', '\\\";</script>');\\n        } else if (htmlTagType == HTT_SCRIPT) {\\n            return ('<script>', '</script>');\\n        } else if (htmlTagType == HTT_SCRIPT_DATA_URI || htmlTagType == HTT_SCRIPT_DATA_URI_NEEDS_ENCODE) {\\n            return ('<script src=\\\"data:text/javascript;base64,', '\\\"></script>');\\n        } else if (htmlTagType == HTT_SCRIPT_DATA_URI_DEFER || htmlTagType == HTT_SCRIPT_DATA_URI_DEFER_NEEDS_ENCODE) {\\n            return ('<script defer=\\\"defer\\\" src=\\\"data:text/javascript;base64,', '\\\"></script>');\\n        } else if (htmlTagType == HTT_SCRIPT_GZIP_BASE_64) {\\n            return ('<script type=\\\"text/javascript+gzip\\\" src=\\\"data:text/javascript;base64,', '\\\"></script>');\\n        }\\n\\n        revert UnrecognizedTagType(htmlTagType);\\n    }\\n\\n    function _validateRenderData(\\n        string[] calldata renderDataHead,\\n        string[] calldata renderDataBody\\n    ) internal pure override {\\n        // Render datas must be at least length of the reserved slots, plus the two image slots.\\n        // It can be higher depending on if there are Scripty scripts to render.\\n        if (renderDataHead.length < RENDER_DATA_RESERVED_SLOTS + 2) {\\n            revert RenderDataInvalid(renderDataHead.length);\\n        } else if (renderDataBody.length < RENDER_DATA_RESERVED_SLOTS + 2) {\\n            revert RenderDataInvalid(renderDataBody.length);\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the metadata of the source archival assets for a token.\\n     *\\n     * @param extension the file extension of the archival asset.\\n     * @param scriptOrdinal the script ordinal of the Archival Metadata.\\n     */\\n    function getArchivalMetadataFor(\\n        string calldata extension,\\n        uint256 scriptOrdinal\\n    ) external view returns (ArchivalMetadataV2 memory) {\\n        require(_metadata[extension].length > 0, 'metadata is empty');\\n        return _metadata[extension][scriptOrdinal - 1];\\n    }\\n\\n    /**\\n     * Getter to retrieve any specific script stored referenced by the contract.\\n     *\\n     * @param extension - the file extension\\n     * @param scriptOrdinal - 1-indexed ordinal of the script\\n     */\\n    function getArchivalScript(string calldata extension, uint256 scriptOrdinal) external view returns (string memory) {\\n        return _getArchivalScript(extension, scriptOrdinal);\\n    }\\n\\n    function _getArchivalScript(string memory extension, uint256 scriptOrdinal) internal view returns (string memory) {\\n        if (keccak256(abi.encodePacked(extension)) == keccak256(abi.encodePacked(JS_EXTENSION))) {\\n            return string(_getJSBytes(scriptOrdinal));\\n        }\\n\\n        revert UnrecognizedExtension(extension);\\n    }\\n\\n    /**\\n     * @notice Admin function to configure the archival metadata for all tokens for a particular file extension.\\n     *\\n     * @param extension - the ArchivalMetadata Array to set\\n     * @param htmlTagTypes - how to render the scripts.\\n     * @param providers - addresses to archival data stores where the files are hosted.\\n     * @param scriptNames - the filenames that will be saved in the data store.\\n     *\\n     * @dev - This will NOT overwrite all config for a given extension. Call clearArchivalMetadata for that behavior instead.\\n     */\\n    function setArchivalMetadataArrayForExtension(\\n        string calldata extension,\\n        uint128[] memory htmlTagTypes,\\n        address[] memory providers,\\n        string[] calldata scriptNames\\n    ) external isOwner {\\n        if (scriptNames.length != providers.length || scriptNames.length != htmlTagTypes.length) {\\n            revert ArrayMismatch(scriptNames.length);\\n        } else if (!Strings.equal(extension, JS_EXTENSION)) {\\n            revert UnrecognizedExtension(extension);\\n        }\\n\\n        uint128 idx;\\n        for (; idx < scriptNames.length; idx++) {\\n            // struct ArchivalMetadataV2 {\\n            //     string extension; // This is the first indexer\\n            //     uint128 scriptOrdinal; // This is the second indexer. Note: One-Indexed\\n            //     uint128 htmlTagType; // Inspired by Script's HtmlTagType, but implemented as an int + constants instead of an enum.\\n            //     address scriptyStorageProvider; // Address where the file is hosted\\n            //     string scriptName; // The file name\\n            // }\\n            ArchivalMetadataV2 memory metadata = ArchivalMetadataV2(\\n                extension,\\n                idx + 1, // note, one indexed.\\n                htmlTagTypes[idx],\\n                providers[idx],\\n                scriptNames[idx]\\n            );\\n\\n            _metadata[extension].push(metadata);\\n        }\\n    }\\n\\n    /**\\n     * @notice Admin function to update the archival metadata details for a single file.\\n     *\\n     * @param extension - the native os extension of the files that will be saved.\\n     * @param scriptOrdinal - the scriptOrdinal of the file.\\n     * @param htmlTagType - how to render the script\\n     * @param provider - address of the archival data store.\\n     * @param scriptName - the filename that will be saved in the data store.\\n     */\\n    function updateArchivalMetadata(\\n        string calldata extension,\\n        uint128 scriptOrdinal,\\n        uint128 htmlTagType,\\n        address provider,\\n        string calldata scriptName\\n    ) external isOwner {\\n        uint256 idx = scriptOrdinal - 1;\\n        ArchivalMetadataV2 memory metadata = _metadata[extension][idx];\\n        require(metadata.scriptOrdinal == scriptOrdinal, 'Invalid addressing');\\n\\n        _metadata[extension][idx].extension = extension;\\n        _metadata[extension][idx].htmlTagType = htmlTagType;\\n        _metadata[extension][idx].scriptyStorageProvider = provider;\\n        _metadata[extension][idx].scriptName = scriptName;\\n    }\\n\\n    /**\\n     * @notice Admin function to clear out the entire Metadata Archive for a file extension.\\n     *\\n     * Important: This has no impact on the underlying datastore.\\n     *\\n     * @param extension the native os extension of the files that will be saved.\\n     */\\n    function clearArchivalMetadata(string calldata extension) external isOwner {\\n        ArchivalMetadataV2[] memory allMetadataForExtension = _metadata[extension];\\n        require(allMetadataForExtension.length > 0, 'array is empty');\\n        delete _metadata[extension];\\n    }\\n\\n    function _getJSBytes(uint256 scriptOrdinal) internal view returns (bytes memory) {\\n        uint256 idx = scriptOrdinal - 1;\\n        ArchivalMetadataV2 memory metadata = _metadata[JS_EXTENSION][idx];\\n        require(metadata.scriptOrdinal == scriptOrdinal, 'Type not configured');\\n\\n        IScriptyStorageProviderV2 provider = IScriptyStorageProviderV2(metadata.scriptyStorageProvider);\\n        return provider.getContent(metadata.scriptName, '');\\n    }\\n\\n    /**\\n     * We want to convert the incoming bytes32 value to a literal representation of the bytes,\\n     * Like \\\"0x0000000000000000000000000000000000000000000000000000000011f3f551\\\"\\n     *\\n     * @param bytesData - bytes data to stringify\\n     */\\n    function _bytes32ToHexString(bytes32 bytesData) internal pure returns (string memory result) {\\n        bytes memory alphabet = '0123456789abcdef';\\n\\n        bytes memory str = new bytes(66);\\n        str[0] = '0';\\n        str[1] = 'x';\\n\\n        uint256 idx;\\n        for (; idx < 32; idx++) {\\n            str[2 + idx * 2] = alphabet[uint(uint8(bytesData[idx] >> 4))];\\n            str[3 + idx * 2] = alphabet[uint(uint8(bytesData[idx] & 0x0f))];\\n        }\\n\\n        return string(str);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LibMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.11;\\r\\n\\r\\n/**\\r\\n * @title LibMath\\r\\n * @author An unnamed, faceless developer.\\r\\n */\\r\\nlibrary LibMath {\\r\\n    /**\\r\\n     * @dev Converts a boolean value to its uint256 representation.\\r\\n     * @param x - The boolean value to convert.\\r\\n     * @return r - The uint256 representation of the input boolean.\\r\\n     */\\r\\n    function toUint256(bool x) internal pure returns (uint256 r) {\\r\\n        assembly {\\r\\n            r := x\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Converts a string to a uint256.\\r\\n     *\\r\\n     * @dev - Credit to bonis.tech for first pass of implementation.\\r\\n     * @param str - the string to convert\\r\\n     */\\r\\n    function stringToUint256(string memory str) internal pure returns (uint256 result) {\\r\\n        bytes memory strAsBytes = bytes(str);\\r\\n        uint256 idx;\\r\\n        for (; idx < strAsBytes.length; ) {\\r\\n            uint256 char = uint256(uint8(strAsBytes[idx]));\\r\\n            if (char >= 48 && char <= 57) {\\r\\n                result = result * 10 + (char - 48);\\r\\n            }\\r\\n\\r\\n            unchecked {\\r\\n                idx++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ArrayMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"ArtPieceAlreadyCreated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArtPieceCountExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"ArtPieceDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ArtPieceInputMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NullTokenType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RenderDataInvalid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TokenTypeInvalid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"UnrecognizedExtension\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"UnrecognizedTagType\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"}],\"name\":\"clearArchivalMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"tokenType\",\"type\":\"uint64\"},{\"internalType\":\"string[]\",\"name\":\"renderDataHead\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"renderDataBody\",\"type\":\"string[]\"}],\"name\":\"createArtPiece\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"tokenTypes\",\"type\":\"uint64[]\"},{\"internalType\":\"string[][]\",\"name\":\"renderDataHeads\",\"type\":\"string[][]\"},{\"internalType\":\"string[][]\",\"name\":\"renderDataBodys\",\"type\":\"string[][]\"}],\"name\":\"createArtPieces\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"tokenType\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"extraDataAsEntropy\",\"type\":\"uint256\"}],\"name\":\"getAnimationAsString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"scriptOrdinal\",\"type\":\"uint256\"}],\"name\":\"getArchivalMetadataFor\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"},{\"internalType\":\"uint128\",\"name\":\"scriptOrdinal\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"htmlTagType\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"scriptyStorageProvider\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"scriptName\",\"type\":\"string\"}],\"internalType\":\"struct SourceChainNativeArtStackBase.ArchivalMetadataV2\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"scriptOrdinal\",\"type\":\"uint256\"}],\"name\":\"getArchivalScript\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"tokenType\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"extraDataAsTokenId\",\"type\":\"uint256\"}],\"name\":\"getArtAsString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"tokenType\",\"type\":\"uint64\"}],\"name\":\"getArtObject\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"tokenType\",\"type\":\"uint64\"},{\"internalType\":\"string[]\",\"name\":\"renderDataHead\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"renderDataBody\",\"type\":\"string[]\"}],\"internalType\":\"struct IDynamicArtV3.DynamicArtV3\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getArtPieceTokenTypes\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHtmlRenderer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"},{\"internalType\":\"uint128[]\",\"name\":\"htmlTagTypes\",\"type\":\"uint128[]\"},{\"internalType\":\"address[]\",\"name\":\"providers\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"scriptNames\",\"type\":\"string[]\"}],\"name\":\"setArchivalMetadataArrayForExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__htmlRenderer\",\"type\":\"address\"}],\"name\":\"setHtmlRenderer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"},{\"internalType\":\"uint128\",\"name\":\"scriptOrdinal\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"htmlTagType\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"scriptName\",\"type\":\"string\"}],\"name\":\"updateArchivalMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"tokenType\",\"type\":\"uint64\"},{\"internalType\":\"string[]\",\"name\":\"renderDataHead\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"renderDataBody\",\"type\":\"string[]\"}],\"name\":\"updateArtPiece\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SourceChainNativeArtStack", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}