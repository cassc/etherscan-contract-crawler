{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/AuraAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Archetype ParallelAutoAuctionExtension\\n//\\n//        d8888                 888               888\\n//       d88888                 888               888\\n//      d88P888                 888               888\\n//     d88P 888 888d888 .d8888b 88888b.   .d88b.  888888 888  888 88888b.   .d88b.\\n//    d88P  888 888P\\\"  d88P\\\"    888 \\\"88b d8P  Y8b 888    888  888 888 \\\"88b d8P  Y8b\\n//   d88P   888 888    888      888  888 88888888 888    888  888 888  888 88888888\\n//  d8888888888 888    Y88b.    888  888 Y8b.     Y88b.  Y88b 888 888 d88P Y8b.\\n// d88P     888 888     \\\"Y8888P 888  888  \\\"Y8888   \\\"Y888  \\\"Y88888 88888P\\\"   \\\"Y8888\\n//                                                            888 888\\n//                                                       Y8b d88P 888\\n//                                                        \\\"Y88P\\\"  888\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"./interfaces/ISharesHolder.sol\\\";\\nimport \\\"./ParallelAutoAuction.sol\\\";\\n\\n\\nerror NotVip();\\n\\nstruct Options {\\n    bool sharesUpdaterUpdatingLocked;\\n    bool vipRequiredTokensLocked;\\n    bool vipIdsLocked;\\n}\\n\\n\\ncontract AuraAuction is ParallelAutoAuction, ISharesHolder {\\n\\n    mapping(address => uint256) private _rewardTokenShares;\\n\\tmapping(address => bool) private _allowSharesUpdate;\\n    mapping(uint24 => bool) private _tokenIdIsVip;\\n\\n    address[] public tokensRequiredToOwnToBeVip;\\n\\n    Options public options;\\n\\n    function createBid(uint24 nftId) override public payable {\\n\\n        if (_tokenIdIsVip[nftId] && !userIsVip(msg.sender))\\n            revert NotVip();\\n\\n\\t\\tsuper.createBid(nftId);\\n\\t\\t_rewardTokenShares[msg.sender] += msg.value;\\n\\t}\\n\\n    /* ----------------------- *\\\\\\n    |* Vip token configuration *|\\n    \\\\* ----------------------- */\\n    function setVipIds(uint24[] memory ids, bool areVip) external onlyOwner {\\n        if (options.vipIdsLocked) revert OptionLocked();\\n        for (uint256 i = 0; i < ids.length; i++) _tokenIdIsVip[ids[i]] = areVip;\\n    }\\n\\n    function isVipId(uint24 id) external view returns (bool) {\\n        return _tokenIdIsVip[id];\\n    }\\n\\n    function setTokensRequiredToHoldToBeVip(address[] memory tokens) external onlyOwner {\\n        if (options.vipRequiredTokensLocked) revert OptionLocked(); \\n        tokensRequiredToOwnToBeVip = tokens;\\n    }\\n\\n    /**\\n     * @return itIs Only if `user` holds at least one `tokensRequiredToOwnToBeVip`.\\n     */\\n    function userIsVip(address user) public view returns (bool itIs) {\\n        for (uint256 i = 0; i < tokensRequiredToOwnToBeVip.length; i++)\\n            if (IERC721(tokensRequiredToOwnToBeVip[i]).balanceOf(user) > 0)\\n                return true;\\n    }\\n\\n\\n    /* ---------------------------- *\\\\\\n    |* ISharesHolder implementation *|\\n    \\\\* ---------------------------- */\\n\\tfunction getAndClearSharesFor(address user) external returns (uint256 shares) {\\n\\t\\trequire(_allowSharesUpdate[msg.sender]);\\n\\t\\tshares = _rewardTokenShares[user];\\n\\t\\tdelete _rewardTokenShares[user];\\n\\t}\\n\\n\\tfunction addSharesUpdater(address updater) external onlyOwner {\\n        if (options.sharesUpdaterUpdatingLocked) revert OptionLocked();\\n\\t\\t_allowSharesUpdate[updater] = true;\\n\\t}\\n\\n\\tfunction removeSharesUpdater(address updater) external onlyOwner {\\n        if (options.sharesUpdaterUpdatingLocked) revert OptionLocked();\\n\\t\\t_allowSharesUpdate[updater] = false;\\n\\t}\\n\\n\\tfunction getIsSharesUpdater(address updater) external view returns (bool) {\\n\\t\\treturn _allowSharesUpdate[updater];\\n\\t}\\n\\n\\tfunction getTokenShares(address user) external view returns (uint256) {\\n\\t\\treturn _rewardTokenShares[user];\\n\\t}\\n\\n    /* ---------------------------------- *\\\\\\n    |* Contract locking and configuration *|\\n    \\\\* ---------------------------------- */\\n    function lockSharesUpdaterUpdatingForever() external onlyOwner {\\n        options.sharesUpdaterUpdatingLocked = true;\\n    }\\n    \\n    function lockTokensRequiredToHoldToBeVipForever() external onlyOwner {\\n        options.vipRequiredTokensLocked = true;\\n    }\\n\\n    function lockVipIdsForever() external onlyOwner {\\n        options.vipIdsLocked = true;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAuctionInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IAuctionInfo {\\n    /**\\n     * @return The auctioned NFT (or maybe any other type of token).\\n     */\\n    function getAuctionedToken() external view returns (address);\\n\\n    /**\\n     * @return An array with all the token ids that \\n     * can currently get auctioned.\\n     */\\n    function getIdsToAuction() external view returns (uint24[] memory);\\n\\n    /**\\n     * @return The current minimum bid price for an auctionable `tokenId`.\\n     * If `tokenId` not in `this.getIdsToAuction()`, it should revert.\\n     */\\n    function getMinPriceFor(uint24 tokenId) external view returns (uint96);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IEthAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IAuctionInfo.sol\\\";\\n\\ninterface IEthAuction is IAuctionInfo {\\n    /**\\n     * @dev Create a `msg.value` bid for a NFT.\\n     */\\n    function createBid(uint24 nftId) external payable;\\n}\\n\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IExternallyMintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IExternallyMintable is IERC721 {\\n    /**\\n     * @dev Allows the minter to mint a NFT to `to`.\\n     */\\n    function mint(uint24 tokenId, address to) external;\\n    \\n    /**\\n     * @return If `tokenId` was already minted (ie, if it exists).\\n     */\\n    function exists(uint24 tokenId) external view returns (bool);\\n    \\n    /**\\n     * @dev Sets a `minter` so it can use the `mint` method.\\n     */\\n    function addMinter(address minter) external;\\n\\n    /**\\n     * @dev Disallow `minter` from using the `mint` method.\\n     */\\n    function removeMinter(address minter) external;\\n\\n    /**\\n     * @return If `minter` is allowed to call the `mint` function.\\n     */\\n    function isMinter(address minter) external view returns (bool);\\n\\n    /**\\n     * @return The max supply of the token, so the auction that will\\n     * use it knows wheres the mints limit.\\n     */\\n    function maxSupply() external view returns (uint24);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IHoldsParallelAutoAuctionData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nstruct AuctionConfig {\\n    address auctionedNft;\\n    /**\\n     * @notice The number of auctions that can happen at the same time. For\\n     * example, if `lines == 3`, those will be the auctioned token ids over\\n     * time:\\n     *\\n     * --- TIME --->\\n     * \\n     *  line 1: |--- 1 ---|---- 4 ----|--- 7 ---|---- 10 ---- ...\\n     *  line 2: |-- 2 --|----- 5 -----|-- 8 --|---- 11 ---- ...\\n     *  line 3: |---- 3 ----|-- 6 --|---- 9 ----|----- 12 ----- ...\\n     *\\n     * Then, from the front-end, you only need to call `lineToState[l].head`\\n     * to query the current auctioned nft at line `l`. For example, in the\\n     * graph above, `lineToState[2].head == 11`.\\n     */\\n    uint8 lines;\\n    // @notice The base duration is the time that takes a single auction\\n    // without considering time buffering.\\n    uint32 baseDuration;\\n    // @notice Extra auction time if a bid happens close to the auction end.\\n    uint32 timeBuffer;\\n    // @notice The minimum price accepted in an auction.\\n    uint96 startingPrice;\\n    // @notice The minimum bid increment.\\n    uint96 bidIncrement;\\n}\\n\\n    \\n/**\\n * @dev LineState represents a single auction line, so there will be\\n * exactly `_auctionConfig.lines` LineStates.\\n */\\nstruct LineState {\\n    // @notice head Is the current auctioned token id at the line.\\n    uint24 head;\\n    uint40 startTime;\\n    uint40 endTime;\\n    address currentWinner;\\n    uint96 currentPrice;\\n}\\n\\ninterface IHoldsParallelAutoAuctionData {\\n    function auctionConfig() external view returns (AuctionConfig memory);\\n    /**\\n     * @return Current line state at `tokenId`, with data updated if the\\n     * auction for that line should get settled.\\n     */\\n    function lineState(uint24 tokenId) external view returns (LineState memory);\\n    /**\\n     * @return All `LineState`s.\\n     */\\n    function lineStates() external view returns (LineState[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IParallelAutoAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IEthAuction.sol\\\";\\nimport \\\"./IHoldsParallelAutoAuctionData.sol\\\";\\n\\ninterface IParallelAutoAuction is IEthAuction, IHoldsParallelAutoAuctionData {\\n    \\n    event Bid(uint24 indexed tokenId, address bidder, uint256 value);\\n    event Won(uint24 indexed tokenId, address bidder, uint256 value);\\n\\n    /**\\n     * @dev This method lets a `nftId` winner to claim it after an aunction ends,\\n     * It can also be used to claim the last auctioned `nftIds`s. Note that this\\n     * has to do with the original `BonklerAuction` contract, which automatically\\n     * settles auction when the auction for the next `nftId` starts.\\n     */\\n    function settleAuction(uint24 nftId) external;\\n}\\n\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/ISharesHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface ISharesHolder {\\n\\n\\t/**\\n\\t * @param updater Should be an IRewardClaimer.\\n\\t */\\n\\tfunction addSharesUpdater(address updater) external;\\n\\n\\t/**\\n\\t * @dev An IRewardClaimer will use this function to calculate rewards for\\n\\t * a bidder.\\n\\t */\\n\\tfunction getAndClearSharesFor(address user) external returns (uint256);\\n\\n\\tfunction getTokenShares(address user) external view returns (uint256);\\n\\n\\tfunction getIsSharesUpdater(address updater) external view returns (bool);\\n\\n}\\n\\n\"\r\n    },\r\n    \"contracts/ParallelAutoAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Archetype ParallelAutoAuction\\n//\\n//        d8888                 888               888\\n//       d88888                 888               888\\n//      d88P888                 888               888\\n//     d88P 888 888d888 .d8888b 88888b.   .d88b.  888888 888  888 88888b.   .d88b.\\n//    d88P  888 888P\\\"  d88P\\\"    888 \\\"88b d8P  Y8b 888    888  888 888 \\\"88b d8P  Y8b\\n//   d88P   888 888    888      888  888 88888888 888    888  888 888  888 88888888\\n//  d8888888888 888    Y88b.    888  888 Y8b.     Y88b.  Y88b 888 888 d88P Y8b.\\n// d88P     888 888     \\\"Y8888P 888  888  \\\"Y8888   \\\"Y888  \\\"Y88888 88888P\\\"   \\\"Y8888\\n//                                                            888 888\\n//                                                       Y8b d88P 888\\n//                                                        \\\"Y88P\\\"  888\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./interfaces/IParallelAutoAuction.sol\\\";\\nimport \\\"./interfaces/IExternallyMintable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"solady/src/utils/SafeTransferLib.sol\\\";\\n\\n\\nerror WrongTokenId();\\nerror WrongBidAmount();\\nerror AuctionPaused();\\nerror OptionLocked();\\n\\nstruct StateLocks {\\n    bool initializationLocked;\\n    bool baseDurationLocked;\\n    bool timeBufferLocked;\\n    bool startingPriceLocked;\\n    bool bidIncrementLocked;\\n}\\n\\n\\ncontract ParallelAutoAuction is IParallelAutoAuction, Ownable {\\n    \\n    // @notice The config for the auction should be immutable.\\n    AuctionConfig private _auctionConfig;\\n    \\n    StateLocks private _stateLocks;\\n\\n    // @notice `_lineToState[i]` should only be mutable from the line `i`. \\n    mapping(uint8 => LineState) private _lineToState;\\n\\n    function initialize(\\n        address nftToAuction,\\n        uint8 lines,\\n        uint32 baseDuration,\\n        uint32 timeBuffer,\\n        uint96 startingPrice,\\n        uint96 bidIncrement\\n    ) external onlyOwner {\\n        require(!_stateLocks.initializationLocked); \\n        _stateLocks.initializationLocked = true;\\n\\n        require(bidIncrement > 0);\\n\\n        _auctionConfig.auctionedNft = nftToAuction;\\n        _auctionConfig.lines = lines;\\n        _auctionConfig.baseDuration = baseDuration;\\n        _auctionConfig.timeBuffer = timeBuffer;\\n        _auctionConfig.startingPrice = startingPrice;\\n        _auctionConfig.bidIncrement = bidIncrement;\\n    }\\n\\n    /* ------------- *\\\\\\n    |* Bidding logic *|\\n    \\\\* ------------- */\\n    /**\\n     * @dev Create a bid for a NFT, with a given amount.\\n     * This contract only accepts payment in ETH.\\n     */\\n    function createBid(uint24 nftId) public payable virtual {\\n        \\n        uint8 lineNumber = tokenIdToLineNumber(nftId);\\n        LineState storage line = _lineToState[lineNumber];\\n        IExternallyMintable token = IExternallyMintable(_auctionConfig.auctionedNft);\\n        \\n        if (!token.isMinter(address(this)))\\n            revert AuctionPaused();\\n\\n        /* ---------- AUCTION UPDATING AND SETTLEMENT ---------- */\\n        if (block.timestamp > line.endTime) {\\n            if (!token.exists(line.head) && line.head > 0) _settleAuction(line);\\n            _updateLine(line, lineNumber);\\n        }\\n\\n        if (line.head != nftId || nftId > token.maxSupply())\\n            revert WrongTokenId();\\n        \\n        /* ------------------ BIDDING LOGIC ------------------ */\\n        bool winnerExists = line.currentWinner != address(0);\\n        if (\\n            (!winnerExists && _auctionConfig.startingPrice > msg.value) ||\\n            (winnerExists && line.currentPrice + _auctionConfig.bidIncrement > msg.value)\\n        ) revert WrongBidAmount();\\n\\n        if (line.currentPrice != 0)\\n            SafeTransferLib.forceSafeTransferETH(line.currentWinner, line.currentPrice);\\n\\n        line.currentPrice = uint96(msg.value);\\n        line.currentWinner = msg.sender;\\n\\n        emit Bid(nftId, msg.sender, msg.value);\\n        \\n        uint40 extendedTime = uint40(block.timestamp + _auctionConfig.timeBuffer);\\n        if (extendedTime > line.endTime)\\n            line.endTime = extendedTime;\\n\\n    }\\n\\n    function settleAuction(uint24 nftId) external {\\n        LineState memory line = _lineToState[tokenIdToLineNumber(nftId)];\\n        IExternallyMintable token = IExternallyMintable(_auctionConfig.auctionedNft);\\n        require(block.timestamp > line.endTime, \\\"Auction still ongoing.\\\");\\n        require(line.head != 0, \\\"Auction not started.\\\");\\n        require(!token.exists(nftId), \\\"Token already settled.\\\");\\n        _settleAuction(line);\\n    }\\n\\n    function _settleAuction(LineState memory line) private {\\n        emit Won(line.head, line.currentWinner, line.currentPrice);\\n        address nftContract = _auctionConfig.auctionedNft;\\n        IExternallyMintable(nftContract).mint(line.head, line.currentWinner);\\n        payable(nftContract).transfer(line.currentPrice);\\n    }\\n    \\n    /**\\n     * @dev `line.head` will be the current token id auctioned at the\\n     * `line`. If is the first auction for this line (if `line.head == 0`)\\n     * then the token id should be the line number itself. Otherwise\\n     * increment the id by the number of lines. For more info about the \\n     * second case check the `AuctionConfig.lines` doc.\\n     * @notice This function should be the only one allowed to change\\n     * `line.startTime`, `line.endTime` and `line.head` state, and it should\\n     * do so only when the dev is sure thats its time to auction the next\\n     * token id.\\n     */\\n    function _updateLine(LineState storage line, uint8 lineNumber) private {\\n        line.startTime = uint40(block.timestamp);\\n        line.endTime = uint40(block.timestamp + _auctionConfig.baseDuration);\\n\\n        if (line.head == 0) line.head = lineNumber; \\n        else {\\n            line.head += _auctionConfig.lines;\\n            line.currentPrice = 0;\\n            line.currentWinner = address(0);\\n        }\\n    }\\n\\n    /* --------------------------- *\\\\\\n    |* IAuctionInfo implementation *|\\n    \\\\* --------------------------- */\\n    function getIdsToAuction() external view returns (uint24[] memory) {\\n        uint24[] memory ids = new uint24[](_auctionConfig.lines);\\n        for (uint8 i = 0; i < _auctionConfig.lines; i++) {\\n            LineState memory line = _lineToState[i+1];\\n            uint24 lineId = line.head;\\n            if (lineId == 0) lineId = i + 1;\\n            else if (block.timestamp > line.endTime) lineId += _auctionConfig.lines;\\n            ids[i] = lineId;\\n        }\\n        return ids;\\n    }\\n\\n    function getAuctionedToken() external view returns (address) {\\n        return _auctionConfig.auctionedNft;\\n    }\\n    \\n    // TODO it should revert if `tokenId != expectedHead`\\n    function getMinPriceFor(uint24 tokenId) external view returns (uint96) {\\n        uint8 lineNumber = uint8(tokenId % _auctionConfig.lines);\\n        LineState memory line = _lineToState[lineNumber];\\n        if (block.timestamp > line.endTime) return _auctionConfig.startingPrice;\\n        else return line.currentPrice + _auctionConfig.bidIncrement;\\n    }\\n    \\n\\n    /* -------------------------------------------- *\\\\\\n    |* IHoldsParallelAutoAuctionData implementation *|\\n    \\\\* -------------------------------------------- */\\n    function auctionConfig() external view returns (AuctionConfig memory) {\\n        return _auctionConfig;    \\n    }\\n\\n    function lineState(uint24 tokenId) external view returns (LineState memory) {\\n        return _lineState(tokenId);\\n    }\\n\\n    function lineStates() external view returns (LineState[] memory lines) {\\n        lines = new LineState[](_auctionConfig.lines);\\n        for (uint8 i = 0; i < _auctionConfig.lines; i++)\\n            lines[i] = _lineState(i+1);\\n    }\\n    \\n    function _lineState(uint24 tokenId) private view returns (LineState memory line) {\\n        uint8 lineNumber = tokenIdToLineNumber(tokenId);\\n        line = _lineToState[lineNumber];\\n        \\n        if (block.timestamp > line.endTime) {\\n            line.head += line.head == 0 ? lineNumber : _auctionConfig.lines;\\n            line.startTime = uint40(block.timestamp);\\n            line.endTime = uint40(block.timestamp + _auctionConfig.baseDuration);\\n            line.currentWinner = address(0);\\n            line.currentPrice = 0;\\n        }\\n    }\\n\\n    /**\\n     * @return A value that will always be in {1, 2, ..., _auctionConfig.lines}.\\n     * So the returned value will always be a valid line number.\\n     */\\n    function tokenIdToLineNumber(uint24 tokenId) public view returns (uint8) {\\n        return uint8((tokenId - 1) % _auctionConfig.lines) + 1;\\n    }\\n\\n\\n    /* ----------------------------------- *\\\\\\n    |* General contract state manipulation *|\\n    \\\\* ----------------------------------- */\\n    /**\\n     * @dev Updating `baseDuration` will only affect to future auctions.\\n     */\\n    function setBaseDuration(uint32 baseDuration) external onlyOwner {\\n        if (_stateLocks.baseDurationLocked) revert OptionLocked();\\n        _auctionConfig.baseDuration = baseDuration;\\n    }\\n\\n    /**\\n     * @dev Updating `timeBuffer` will only affect to future bufferings.\\n     */\\n    function setTimeBuffer(uint32 timeBuffer) external onlyOwner {\\n        if (_stateLocks.timeBufferLocked) revert OptionLocked();\\n        _auctionConfig.timeBuffer = timeBuffer; \\n    }\\n\\n    /**\\n     * @dev Updating `startingPrice` will only affect to future auctions.\\n     */\\n    function setStartingPrice(uint96 startingPrice) external onlyOwner {\\n        if (_stateLocks.startingPriceLocked) revert OptionLocked();\\n        _auctionConfig.startingPrice = startingPrice;\\n    }\\n\\n    /**\\n     * @dev Updating `bidIncrement` will only affect to future increments.\\n     */\\n    function setBidIncrement(uint96 bidIncrement) external onlyOwner {\\n        if (_stateLocks.bidIncrementLocked) revert OptionLocked();\\n        _auctionConfig.bidIncrement = bidIncrement;\\n    }\\n    \\n\\n    /* ---------------- *\\\\\\n    |* Contract locking *|\\n    \\\\* ---------------- */\\n    function lockBaseDurationForever() external onlyOwner {\\n        _stateLocks.baseDurationLocked = true;\\n    }\\n\\n    function lockTimeBufferForever() external onlyOwner {\\n        _stateLocks.timeBufferLocked = true;\\n    }\\n\\n    function lockStartingPriceForever() external onlyOwner {\\n        _stateLocks.startingPriceLocked = true;\\n    }\\n\\n    function lockBidIncrementForever() external onlyOwner {\\n        _stateLocks.bidIncrementLocked = true;\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overriden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x0c, 0x70a08231000000000000000000000000)\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            // The `amount` argument is already written to the memory word at 0x6c.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x14, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x34.\\n            amount := mload(0x34)\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x00, 0x70a08231000000000000000000000000)\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AuctionPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotVip\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OptionLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongBidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongTokenId\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"tokenId\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Bid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"tokenId\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Won\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"addSharesUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"auctionedNft\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"lines\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"baseDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timeBuffer\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"startingPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"bidIncrement\",\"type\":\"uint96\"}],\"internalType\":\"struct AuctionConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"nftId\",\"type\":\"uint24\"}],\"name\":\"createBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAndClearSharesFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuctionedToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIdsToAuction\",\"outputs\":[{\"internalType\":\"uint24[]\",\"name\":\"\",\"type\":\"uint24[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"getIsSharesUpdater\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"tokenId\",\"type\":\"uint24\"}],\"name\":\"getMinPriceFor\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTokenShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftToAuction\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"lines\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"baseDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timeBuffer\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"startingPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"bidIncrement\",\"type\":\"uint96\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"id\",\"type\":\"uint24\"}],\"name\":\"isVipId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"tokenId\",\"type\":\"uint24\"}],\"name\":\"lineState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint24\",\"name\":\"head\",\"type\":\"uint24\"},{\"internalType\":\"uint40\",\"name\":\"startTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"endTime\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"currentWinner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"currentPrice\",\"type\":\"uint96\"}],\"internalType\":\"struct LineState\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lineStates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint24\",\"name\":\"head\",\"type\":\"uint24\"},{\"internalType\":\"uint40\",\"name\":\"startTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"endTime\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"currentWinner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"currentPrice\",\"type\":\"uint96\"}],\"internalType\":\"struct LineState[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockBaseDurationForever\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockBidIncrementForever\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockSharesUpdaterUpdatingForever\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockStartingPriceForever\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTimeBufferForever\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTokensRequiredToHoldToBeVipForever\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockVipIdsForever\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"options\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"sharesUpdaterUpdatingLocked\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"vipRequiredTokensLocked\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"vipIdsLocked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"removeSharesUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"baseDuration\",\"type\":\"uint32\"}],\"name\":\"setBaseDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"bidIncrement\",\"type\":\"uint96\"}],\"name\":\"setBidIncrement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"startingPrice\",\"type\":\"uint96\"}],\"name\":\"setStartingPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"timeBuffer\",\"type\":\"uint32\"}],\"name\":\"setTimeBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"setTokensRequiredToHoldToBeVip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24[]\",\"name\":\"ids\",\"type\":\"uint24[]\"},{\"internalType\":\"bool\",\"name\":\"areVip\",\"type\":\"bool\"}],\"name\":\"setVipIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"nftId\",\"type\":\"uint24\"}],\"name\":\"settleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"tokenId\",\"type\":\"uint24\"}],\"name\":\"tokenIdToLineNumber\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensRequiredToOwnToBeVip\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userIsVip\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"itIs\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AuraAuction", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}