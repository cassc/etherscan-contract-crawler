{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() external {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/infrastructure/Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {VaultProxy} from \\\"../vault/VaultProxy.sol\\\";\\nimport {BaseVault} from \\\"../vault/BaseVault.sol\\\";\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\n\\n/**\\n * @title Factory\\n * @notice Contract to deploy new instances of {VaultProxy}, authorize modules during deployment.\\n * Deployer owns this contract and is responsible to manage base vault implementation address and\\n * deploying new proxy vaults.\\n */\\ncontract Factory is Ownable2Step {\\n\\n    // deployed instance of the base vault.\\n    address private baseVaultImpl;\\n\\n    // Emitted for every new deployment of a proxy vault contract.\\n    event NewVaultDeployed(address indexed newProxy, address indexed owner, address[] modules, bytes[] initData);\\n\\n    // Emitted when base vault implementation address is changed.\\n    event BaseVaultImplChanged(address indexed _newBaseVaultImpl);\\n\\n    /**\\n     * @param _baseVaultImpl - Deployed instance of the implementation base vault {BaseVault}.\\n     */\\n    constructor(address _baseVaultImpl) {\\n        require(\\n            _baseVaultImpl != address(0),\\n            \\\"F: Invalid address\\\"\\n        );\\n        baseVaultImpl = _baseVaultImpl;\\n    }\\n\\n    /**\\n     * @notice Function to be executed by Kresus deployer to deploy a new instance of {VaultProxy}\\n     * and authorize list of `_modules`.\\n     * @param _owner - Address of the owner of base vault contract.\\n     * @param _modules - Modules to be authorized to make changes to the state of vault contract.\\n     * @param _initData - Bytes data for each module to be authorized. Intialization data for {KresusModule}\\n     * includes timedelay and kbg address for a vault which is authorizing {KresusModule}.\\n     */\\n    function deployVault(\\n        address _owner,\\n        address[] calldata _modules,\\n        bytes[] calldata _initData\\n    ) \\n        external\\n        onlyOwner()\\n    {\\n        address payable newProxy = payable(new VaultProxy(baseVaultImpl));\\n        BaseVault(newProxy).init(_owner, _modules, _initData);\\n        emit NewVaultDeployed(newProxy, _owner, _modules, _initData);\\n    }\\n\\n    /**\\n     * @notice Function to change base vault implementation address.\\n     * @param _newBaseVaultImpl - Implementation address of new base vault {BaseVault}.\\n     */\\n    function changeBaseVaultImpl(address _newBaseVaultImpl) external onlyOwner() {\\n        baseVaultImpl =  _newBaseVaultImpl;\\n        emit BaseVaultImplChanged(_newBaseVaultImpl);\\n    }\\n\\n    /**\\n     * @notice Function to get current base vault implementation contract address.\\n     */\\n    function getBaseVaultImpl() external view returns(address) {\\n        return baseVaultImpl;\\n    }\\n\\n    /**\\n     * @notice Function to override {Ownable} implementation to prevent transferring ownership to null address.\\n     */\\n    function renounceOwnership() public pure override {\\n        revert(\\\"F: Method not allowed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/common/IModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IModule\\n * @notice Interface for a Module.\\n */\\ninterface IModule {\\n\\n    /**\\t\\n     * @notice Adds a module to a vault. Cannot execute when vault is locked (or under recovery)\\t\\n     * @param _vault The target vault.\\t\\n     * @param _module The modules to authorise.\\t\\n     */\\t\\n    function addModule(address _vault, address _module, bytes memory _initData) external;\\n\\n    /**\\n     * @notice Inits a Module for a vault by e.g. setting some vault specific parameters in storage.\\n     * @param _vault The target vault.\\n     * @param _initData - Data to be initialised specific to a module when it is authorized.\\n     */\\n    function init(address _vault, bytes calldata _initData) external;\\n\\n\\n    /**\\n     * @notice Returns whether the module implements a callback for a given static call method.\\n     * @param _methodId The method id.\\n     * @return _isSupported True if `_methodId` is supported, else false.\\n     */\\n    function supportsStaticCall(bytes4 _methodId) external view returns (bool _isSupported);\\n}\"\r\n    },\r\n    \"contracts/vault/BaseVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../modules/common/IModule.sol\\\";\\nimport \\\"./IVault.sol\\\";\\n\\n/**\\n * @title BaseVault\\n * @notice Simple modular vault that authorises modules to call its invoke() method.\\n */\\ncontract BaseVault is IVault {\\n\\n    // Zero address\\n    address constant internal ZERO_ADDRESS = address(0);\\n    // The owner\\n    address public owner;\\n    // The authorised modules\\n    mapping (address => bool) public authorised;\\n    // module executing static calls\\n    address public staticCallExecutor;\\n    // The number of modules\\n    uint256 public modules;\\n\\n    event AuthorisedModule(address indexed module, bool value);\\n    event Invoked(address indexed module, address indexed target, uint256 indexed value, bytes data);\\n    event Received(uint256 indexed value, address indexed sender, bytes data);\\n    event StaticCallEnabled(address indexed module);\\n\\n    /**\\n     * @notice Throws if the sender is not an authorised module.\\n     */\\n    modifier moduleOnly {\\n        require(authorised[msg.sender], \\\"BV: sender not authorized\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Inits the vault by setting the owner and authorising a list of modules.\\n     * @param _owner The owner.\\n     * @param _initData bytes32 initialization data specific to the module.\\n     * @param _modules The modules to authorise.\\n     */\\n    function init(\\n        address _owner,\\n        address[] calldata _modules,\\n        bytes[] calldata _initData\\n    )\\n        external\\n    {\\n        uint256 len = _modules.length;\\n        require(owner == ZERO_ADDRESS, \\\"BV: vault already initialised\\\");\\n        require(_owner != ZERO_ADDRESS, \\\"BV: Invalid address\\\");\\n        require(len > 0, \\\"BV: empty modules\\\");\\n        require(_initData.length == len, \\\"BV: inconsistent lengths\\\");\\n        owner = _owner;\\n        modules = len;\\n        for (uint256 i = 0; i < len; i++) {\\n            require(_modules[i] != ZERO_ADDRESS, \\\"BV: Invalid address\\\");\\n            require(!authorised[_modules[i]], \\\"BV: Invalid module\\\");\\n            authorised[_modules[i]] = true;\\n            IModule(_modules[i]).init(address(this), _initData[i]);\\n            emit AuthorisedModule(_modules[i], true);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IVault\\n     */\\n    function authoriseModule(\\n        address _module,\\n        bool _value,\\n        bytes memory _initData\\n    ) \\n        external\\n        moduleOnly\\n    {\\n        if (authorised[_module] != _value) {\\n            emit AuthorisedModule(_module, _value);\\n            if (_value) {\\n                modules += 1;\\n                authorised[_module] = true;\\n                IModule(_module).init(address(this), _initData);\\n            } else {\\n                modules -= 1;\\n                require(modules > 0, \\\"BV: cannot remove last module\\\");\\n                delete authorised[_module];\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @inheritdoc IVault\\n    */\\n    function enabled(\\n        bytes4 _sig\\n    )\\n        public\\n        view\\n        returns(address)\\n    {\\n        address executor = staticCallExecutor;\\n        if(executor != ZERO_ADDRESS && IModule(executor).supportsStaticCall(_sig)) {\\n            return executor;\\n        }\\n        return ZERO_ADDRESS;\\n    }\\n\\n    /**\\n    * @inheritdoc IVault\\n    */\\n    function enableStaticCall(\\n        address _module\\n    )\\n        external\\n        moduleOnly\\n    {\\n        if(staticCallExecutor != _module) {\\n            require(authorised[_module], \\\"BV: unauthorized executor\\\");\\n            staticCallExecutor = _module;\\n            emit StaticCallEnabled(_module);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IVault\\n     */\\n    function setOwner(\\n        address _newOwner\\n    )\\n        external\\n        moduleOnly\\n    {\\n        require(_newOwner != ZERO_ADDRESS, \\\"BV: address cannot be null\\\");\\n        owner = _newOwner;\\n    }\\n\\n    /**\\n     * @notice Performs a generic transaction to `_target` using `_data` and `_value`.\\n     * @param _target The address for the transaction.\\n     * @param _value The value of the transaction.\\n     * @param _data The data of the transaction.\\n     * @return _result The bytes result after call.\\n     */\\n    function invoke(\\n        address _target,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) \\n        external \\n        moduleOnly \\n        returns(bytes memory _result) \\n    {\\n        bool success;\\n        require(address(this).balance >= _value, \\\"BV: Insufficient balance\\\");\\n        emit Invoked(msg.sender, _target, _value, _data);\\n        (success, _result) = _target.call{value: _value}(_data);\\n        if (!success) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice This method delegates the static call to a target contract if the data corresponds\\n     * to an enabled module, or logs the call otherwise.\\n     */\\n    fallback() external payable {\\n        address module = enabled(msg.sig);\\n        if (module == ZERO_ADDRESS) {\\n            emit Received(msg.value, msg.sender, msg.data);\\n        } else {\\n            require(authorised[module], \\\"BV: unauthorised module\\\");\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                calldatacopy(0, 0, calldatasize())\\n                let result := staticcall(gas(), module, 0, calldatasize(), 0, 0)\\n                returndatacopy(0, 0, returndatasize())\\n                switch result\\n                case 0 {revert(0, returndatasize())}\\n                default {return (0, returndatasize())}\\n            }\\n        }\\n    }\\n\\n    receive() external payable {\\n        emit Received(msg.value, msg.sender, \\\"\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/vault/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IVault\\n * @notice Interface for the {BaseVault}\\n */\\ninterface IVault {\\n\\n    /**\\n     * @notice Enables/Disables a module.\\n     * @param _module The target module.\\n     * @param _value Set to `true` to authorise the module.\\n     */\\n    function authoriseModule(address _module, bool _value, bytes memory _initData) external;\\n\\n    /**\\n     * @notice Enables a static method by specifying the target module to which the call must be delegated.\\n     * @param _module The target module.\\n     */\\n    function enableStaticCall(address _module) external;\\n\\n    /**\\n     * @notice Inits the vault by setting the owner and authorising a list of modules.\\n     * @param _owner The owner.\\n     * @param _initData bytes32 initialization data specific to the module.\\n     * @param _modules The modules to authorise.\\n     */\\n    function init(address _owner, address[] calldata _modules, bytes[] calldata _initData) external;\\n\\n    /**\\n     * @notice Sets a new owner for the vault.\\n     * @param _newOwner The new owner.\\n     */\\n    function setOwner(address _newOwner) external;\\n\\n    /**\\n     * @notice Returns the vault owner.\\n     * @return The vault owner address.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the number of authorised modules.\\n     * @return The number of authorised modules.\\n     */\\n    function modules() external view returns (uint256);\\n\\n    /**\\n     * @notice Checks if a module is authorised on the vault.\\n     * @param _module The module address to check.\\n     * @return True if the module is authorised, otherwise false.\\n     */\\n    function authorised(address _module) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the module responsible, if static call is enabled for `_sig`, otherwise return zero address.\\n     * @param _sig The signature of the static call.\\n     * @return The module doing the redirection or zero address\\n     */\\n    function enabled(bytes4 _sig) external view returns (address);\\n}\"\r\n    },\r\n    \"contracts/vault/VaultProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {Proxy} from \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\n\\n/**\\n * @title VaultProxy\\n * @notice Basic proxy that delegates all calls to a fixed implementing contract.\\n * The implementing contract cannot be upgraded.\\n */\\ncontract VaultProxy is Proxy{\\n\\n    address public immutable implementation;\\n\\n    /**\\n     * @param _impl Deployed instance of {BaseVault}.\\n     */\\n    constructor(address _impl) {\\n        implementation = _impl;\\n    }\\n\\n    /**\\n     * @inheritdoc Proxy\\n     */\\n    function _implementation() internal view override returns(address) {\\n        return implementation;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseVaultImpl\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newBaseVaultImpl\",\"type\":\"address\"}],\"name\":\"BaseVaultImplChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"modules\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"initData\",\"type\":\"bytes[]\"}],\"name\":\"NewVaultDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newBaseVaultImpl\",\"type\":\"address\"}],\"name\":\"changeBaseVaultImpl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_initData\",\"type\":\"bytes[]\"}],\"name\":\"deployVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseVaultImpl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Factory", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000a4ff93cf7aef1f126d5685dff3ca795147ce91f5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}