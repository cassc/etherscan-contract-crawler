{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC11554K.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"./IGuardians.sol\\\";\\n\\n/**\\n * @dev {IERC11554K} interface:\\n */\\ninterface IERC11554K {\\n    function controllerMint(\\n        address mintAddress,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) external;\\n\\n    function controllerBurn(\\n        address burnAddress,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) external;\\n\\n    function setGuardians(IGuardians guardians_) external;\\n\\n    function setURI(string calldata newuri) external;\\n\\n    function setCollectionURI(string calldata collectionURI_) external;\\n\\n    function setVerificationStatus(bool _isVerified) external;\\n\\n    function setGlobalRoyalty(address receiver, uint96 feeNumerator) external;\\n\\n    function owner() external view returns (address);\\n\\n    function balanceOf(\\n        address user,\\n        uint256 item\\n    ) external view returns (uint256);\\n\\n    function royaltyInfo(\\n        uint256 _tokenId,\\n        uint256 _salePrice\\n    ) external view returns (address, uint256);\\n\\n    function totalSupply(uint256 _tokenId) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC11554KController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"./IERC11554K.sol\\\";\\nimport \\\"./IGuardians.sol\\\";\\n\\n/**\\n * @dev {IERC11554KController} interface:\\n */\\ninterface IERC11554KController {\\n    /// @dev Batch minting request data structure.\\n    struct BatchRequestMintData {\\n        /// @dev Collection address.\\n        IERC11554K collection;\\n        /// @dev Item id.\\n        uint256 id;\\n        /// @dev Guardian address.\\n        address guardianAddress;\\n        /// @dev Amount to mint.\\n        uint256 amount;\\n        /// @dev Service fee to guardian.\\n        uint256 serviceFee;\\n        /// @dev Is item supply expandable.\\n        bool isExpandable;\\n        /// @dev Recipient address.\\n        address mintAddress;\\n        /// @dev Guardian class index.\\n        uint256 guardianClassIndex;\\n        /// @dev Guardian fee amount to pay.\\n        uint256 guardianFeeAmount;\\n    }\\n\\n    function requestMint(\\n        IERC11554K collection,\\n        uint256 id,\\n        address guardian,\\n        uint256 amount,\\n        uint256 serviceFee,\\n        bool expandable,\\n        address mintAddress,\\n        uint256 guardianClassIndex,\\n        uint256 guardianFeeAmount\\n    ) external returns (uint256);\\n\\n    function mint(IERC11554K collection, uint256 id) external;\\n\\n    function owner() external returns (address);\\n\\n    function originators(\\n        address collection,\\n        uint256 tokenId\\n    ) external returns (address);\\n\\n    function isActiveCollection(address collection) external returns (bool);\\n\\n    function isLinkedCollection(address collection) external returns (bool);\\n\\n    function paymentToken() external returns (IERC20Upgradeable);\\n\\n    function maxMintPeriod() external returns (uint256);\\n\\n    function remediationBurn(\\n        IERC11554K collection,\\n        address owner,\\n        uint256 id,\\n        uint256 amount\\n    ) external;\\n\\n    function setMaxMintPeriod(uint256 maxMintPeriod_) external;\\n\\n    function setRemediator(address _remediator) external;\\n\\n    function setCollectionFee(uint256 collectionFee_) external;\\n\\n    function setBeneficiary(address beneficiary_) external;\\n\\n    function setGuardians(IGuardians guardians_) external;\\n\\n    function setPaymentToken(IERC20Upgradeable paymentToken_) external;\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function setVersion(bytes32 version_) external;\\n\\n    function guardians() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC11554KDrops.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"./IERC11554K.sol\\\";\\n\\n/**\\n * @dev {IERC11554KDrops} interface:\\n */\\ninterface IERC11554KDrops is IERC11554K {\\n    function setItemUriID(uint256 id, uint256 uriID) external;\\n\\n    function setVaulted() external;\\n\\n    function setRevealed(string calldata collectionURI_) external;\\n\\n    function setMintingDrops(address mintingDrops_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeesManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"./IERC11554K.sol\\\";\\nimport \\\"./IGuardians.sol\\\";\\nimport \\\"./IERC11554KController.sol\\\";\\n\\n/**\\n * @dev {IFeesManager} interface:\\n */\\ninterface IFeesManager {\\n    function receiveFees(\\n        IERC11554K erc11554k,\\n        uint256 id,\\n        IERC20Upgradeable asset,\\n        uint256 _salePrice\\n    ) external;\\n\\n    function calculateTotalFee(\\n        IERC11554K erc11554k,\\n        uint256 id,\\n        uint256 _salePrice\\n    ) external returns (uint256);\\n\\n    function payGuardianFee(\\n        uint256 guardianFeeAmount,\\n        uint256 guardianClassFeeRateMultiplied,\\n        address guardian,\\n        uint256 storagePaidUntil,\\n        address payer,\\n        IERC20Upgradeable paymentAsset\\n    ) external;\\n\\n    function refundGuardianFee(\\n        uint256 guardianFeeAmount,\\n        uint256 guardianClassFeeRateMultiplied,\\n        address guardian,\\n        uint256 storagePaidUntil,\\n        address recipient,\\n        IERC20Upgradeable paymentAsset\\n    ) external;\\n\\n    function moveFeesBetweenGuardians(\\n        address guardianFrom,\\n        address guardianTo,\\n        IERC20Upgradeable asset\\n    ) external;\\n\\n    function setGuardians(IGuardians guardians_) external;\\n\\n    function setController(IERC11554KController controller_) external;\\n\\n    function setGlobalTradingFee(uint256 globalTradingFee_) external;\\n\\n    function setTradingFeeSplit(\\n        uint256 protocolSplit,\\n        uint256 guardianSplit\\n    ) external;\\n\\n    function setExchange(address exchange_) external;\\n\\n    function setVersion(bytes32 version_) external;\\n\\n    function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGuardians.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"./IERC11554K.sol\\\";\\nimport \\\"./IERC11554KController.sol\\\";\\nimport \\\"./IFeesManager.sol\\\";\\n\\n/**\\n * @dev {IGuardians} interface:\\n */\\ninterface IGuardians {\\n    enum GuardianFeeRatePeriods {\\n        SECONDS,\\n        MINUTES,\\n        HOURS,\\n        DAYS\\n    }\\n\\n    function controllerStoreItem(\\n        IERC11554K collection,\\n        address mintAddress,\\n        uint256 id,\\n        address guardian,\\n        uint256 guardianClassIndex,\\n        uint256 guardianFeeAmount,\\n        uint256 numItems,\\n        address feePayer,\\n        IERC20Upgradeable paymentAsset\\n    ) external;\\n\\n    function controllerTakeItemOut(\\n        address guardian,\\n        IERC11554K collection,\\n        uint256 id,\\n        uint256 numItems,\\n        address from\\n    ) external;\\n\\n    function shiftGuardianFeesOnTokenMove(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) external;\\n\\n    function setController(IERC11554KController controller_) external;\\n\\n    function setFeesManager(IFeesManager feesManager_) external;\\n\\n    function setMinStorageTime(uint256 minStorageTime_) external;\\n\\n    function setMinimumRequestFee(uint256 minimumRequestFee_) external;\\n\\n    function setMaximumGuardianFeeSet(uint256 maximumGuardianFeeSet_) external;\\n\\n    function setGuardianFeeSetWindow(uint256 guardianFeeSetWindow_) external;\\n\\n    function moveItems(\\n        IERC11554K collection,\\n        uint256[] calldata ids,\\n        address oldGuardian,\\n        address newGuardian,\\n        uint256[] calldata newGuardianClassIndeces\\n    ) external;\\n\\n    function copyGuardianClasses(\\n        address oldGuardian,\\n        address newGuardian\\n    ) external;\\n\\n    function setActivity(address guardian, bool activity) external;\\n\\n    function setPrivacy(address guardian, bool privacy) external;\\n\\n    function setLogo(address guardian, string calldata logo) external;\\n\\n    function setName(address guardian, string calldata name) external;\\n\\n    function setPhysicalAddressHash(\\n        address guardian,\\n        bytes32 physicalAddressHash\\n    ) external;\\n\\n    function setPolicy(address guardian, string calldata policy) external;\\n\\n    function setRedirect(address guardian, string calldata redirect) external;\\n\\n    function changeWhitelistUsersStatus(\\n        address guardian,\\n        address[] calldata users,\\n        bool whitelistStatus\\n    ) external;\\n\\n    function removeGuardian(address guardian) external;\\n\\n    function setGuardianClassMintingFee(\\n        address guardian,\\n        uint256 classID,\\n        uint256 mintingFee\\n    ) external;\\n\\n    function setGuardianClassRedemptionFee(\\n        address guardian,\\n        uint256 classID,\\n        uint256 redemptionFee\\n    ) external;\\n\\n    function setGuardianClassGuardianFeeRate(\\n        address guardian,\\n        uint256 classID,\\n        uint256 guardianFeeRate\\n    ) external;\\n\\n    function setGuardianClassGuardianFeePeriodAndRate(\\n        address guardian,\\n        uint256 classID,\\n        GuardianFeeRatePeriods guardianFeeRatePeriod,\\n        uint256 guardianFeeRate\\n    ) external;\\n\\n    function setGuardianClassURI(\\n        address guardian,\\n        uint256 classID,\\n        string calldata uri\\n    ) external;\\n\\n    function setGuardianClassActiveStatus(\\n        address guardian,\\n        uint256 classID,\\n        bool activeStatus\\n    ) external;\\n\\n    function setGuardianClassMaximumCoverage(\\n        address guardian,\\n        uint256 classID,\\n        uint256 maximumCoverage\\n    ) external;\\n\\n    function addGuardianClass(\\n        address guardian,\\n        uint256 maximumCoverage,\\n        uint256 mintingFee,\\n        uint256 redemptionFee,\\n        uint256 guardianFeeRate,\\n        GuardianFeeRatePeriods guardianFeeRatePeriod,\\n        string calldata uri\\n    ) external;\\n\\n    function registerGuardian(\\n        address guardian,\\n        string calldata name,\\n        string calldata logo,\\n        string calldata policy,\\n        string calldata redirect,\\n        bytes32 physicalAddressHash,\\n        bool privacy\\n    ) external;\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function setVersion(bytes32 version_) external;\\n\\n    function isAvailable(address guardian) external view returns (bool);\\n\\n    function guardianInfo(\\n        address guardian\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32,\\n            string memory,\\n            string memory,\\n            string memory,\\n            string memory,\\n            bool,\\n            bool\\n        );\\n\\n    function guardianWhitelist(\\n        address guardian,\\n        address user\\n    ) external view returns (bool);\\n\\n    function delegated(address guardian) external view returns (address);\\n\\n    function getRedemptionFee(\\n        address guardian,\\n        uint256 classID\\n    ) external view returns (uint256);\\n\\n    function getMintingFee(\\n        address guardian,\\n        uint256 classID\\n    ) external view returns (uint256);\\n\\n    function isClassActive(\\n        address guardian,\\n        uint256 classID\\n    ) external view returns (bool);\\n\\n    function minStorageTime() external view returns (uint256);\\n\\n    function feesManager() external view returns (address);\\n\\n    function stored(\\n        address guardian,\\n        IERC11554K collection,\\n        uint256 id\\n    ) external view returns (uint256);\\n\\n    function whereItemStored(\\n        IERC11554K collection,\\n        uint256 id\\n    ) external view returns (address);\\n\\n    function itemGuardianClass(\\n        IERC11554K collection,\\n        uint256 id\\n    ) external view returns (uint256);\\n\\n    function guardianFeePaidUntil(\\n        address user,\\n        address collection,\\n        uint256 id\\n    ) external view returns (uint256);\\n\\n    function isFeeAboveMinimum(\\n        uint256 guardianFeeAmount,\\n        uint256 numItems,\\n        address guardian,\\n        uint256 guardianClassIndex\\n    ) external view returns (bool);\\n\\n    function getGuardianFeeRateByCollectionItem(\\n        IERC11554K collection,\\n        uint256 itemId\\n    ) external view returns (uint256);\\n\\n    function getGuardianFeeRate(\\n        address guardian,\\n        uint256 guardianClassIndex\\n    ) external view returns (uint256);\\n\\n    function isWhitelisted(address guardian) external view returns (bool);\\n\\n    function inRepossession(\\n        address user,\\n        IERC11554K collection,\\n        uint256 id\\n    ) external view returns (uint256);\\n\\n    function isDelegated(\\n        address guardian,\\n        address delegatee,\\n        IERC11554K collection\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/MintingDrops.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./interfaces/IERC11554KController.sol\\\";\\nimport \\\"./interfaces/IERC11554KDrops.sol\\\";\\nimport \\\"./interfaces/IGuardians.sol\\\";\\n\\n/**\\n * @dev MintingDrops manages minting drops for a collection.\\n */\\ncontract MintingDrops is Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice Minting Drops types\\n    enum DropType {\\n        /// @notice ERC-721 (ERC-1155 with each id having single item) random minting drop\\n        NFT,\\n        /// @notice Users choose set of items and randomly mint items in each set\\n        SEMI,\\n        /// @notice Users choose which item to mint\\n        DETERMINED\\n    }\\n\\n    /// @notice Is minting drop private or public.\\n    bool public immutable isPrivate;\\n    /// @notice Collection contract.\\n    IERC11554KDrops public immutable collection;\\n    /// @notice Controller contract.\\n    IERC11554KController public immutable controller;\\n    /// @notice Maximum number of items, independant of id, per user.\\n    uint256 public immutable maxItemsPerUser;\\n    /// @notice Maximum items to mint per ID for collection.\\n    uint256 public immutable maxItemsPerID;\\n    /// @notice Maximum items to mint in the drop.\\n    uint256 public immutable maxItems;\\n    /// @notice A pre-set amount of guardian fee that each item would have.\\n    uint256 public immutable guardianFeeAmountPerItem;\\n    /// @notice A pre-set guardian class index where items will be stored.\\n    uint256 public immutable guardianClassIndex;\\n    /// @notice A pre-set amount of service fee that each item's minting will provide.\\n    uint256 public immutable serviceFeePerItem;\\n    /// @notice Items variations in case of non-NFT drop.\\n    uint256 public immutable variations;\\n    /// @notice Drop type.\\n    DropType public immutable dropType;\\n    /// @notice Guardian that vaults items during drop.\\n    address public immutable managingGuardian;\\n    /// @notice Allowlist merkle root for checking if user in allowlist or not.\\n    bytes32 public allowlistMerkleRoot;\\n    /// @notice Minted items.\\n    uint256 public mintedItems;\\n    /// @notice ETH drop minting fee.\\n    uint256 public dropFee;\\n    /// @notice Minting Drop start time. Can only be set once.\\n    uint256 public startTime;\\n    /// @notice Minting Drop end time. Can only be set once.\\n    uint256 public endTime;\\n    /// @notice Which user owns item with URI ID\\n    mapping(uint256 => address) public uriIDUser;\\n    /// @notice Items minted for each URI ID.\\n    mapping(uint256 => uint256) public itemsIDMinted;\\n    /// @notice Mapped URI IDs to collection item IDs.\\n    mapping(uint256 => uint256) public uriIDItemID;\\n    /// @notice How many items a user has minted.\\n    mapping(address => uint256) public itemsPerUser;\\n\\n    /// @notice Helper initial state of URI ids for NFT random minting drop\\n    uint256[] public helperIdsList;\\n    /// @notice Items classes variations prefix sums. i-th element is sum of classes variations from 0-th to i-th.\\n    uint256[] public prefixSumsVariations;\\n\\n    /// @notice Minted drop\\n    event MintedDrop(\\n        uint256 id,\\n        uint256 randomUriID,\\n        uint256 amount,\\n        address minter\\n    );\\n\\n    error AccessDenied();\\n    error NotPrivate();\\n    error EqualItems();\\n    error InvalidAmount();\\n    error AlreadySet();\\n    error MintingLimitExceeded();\\n    error UserMintingLimitExceeded();\\n    error AlreadyMinted();\\n    error ETHTransferFailed();\\n    error LowSentETH();\\n    error NotNFTDrop();\\n    error NotSEMIDrop();\\n    error NotManagingGuardian();\\n    error NotStarted();\\n    error InvalidItemID();\\n    error HasEnded();\\n\\n    /**\\n     * @dev Only guardian modifier.\\n     */\\n    modifier onlyManagingGuardian() {\\n        if (managingGuardian != _msgSender()) {\\n            revert NotManagingGuardian();\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        IERC11554KController controller_,\\n        IERC11554KDrops collection_,\\n        bool isPrivate_,\\n        uint256 maxItemsPerUser_,\\n        uint256 maxItemsPerID_,\\n        uint256 maxItems_,\\n        uint256 variations_,\\n        address managingGuardian_,\\n        DropType dropType_,\\n        uint256 serviceFeePerItem_,\\n        uint256 guardianFeeAmountPerItem_,\\n        uint256 guardianClassIndex_\\n    ) {\\n        controller = controller_;\\n        collection = collection_;\\n        isPrivate = isPrivate_;\\n        maxItemsPerUser = maxItemsPerUser_;\\n        maxItemsPerID = maxItemsPerID_;\\n        maxItems = maxItems_;\\n        variations = variations_;\\n        managingGuardian = managingGuardian_;\\n        dropType = dropType_;\\n        serviceFeePerItem = serviceFeePerItem_;\\n        guardianFeeAmountPerItem = guardianFeeAmountPerItem_;\\n        guardianClassIndex = guardianClassIndex_;\\n        controller_.paymentToken().approve(\\n            address(controller_),\\n            type(uint256).max\\n        );\\n        controller_.paymentToken().approve(\\n            IGuardians(controller_.guardians()).feesManager(),\\n            type(uint256).max\\n        );\\n    }\\n\\n    /**\\n     * @notice Fallback ETH receive function.\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @notice Withdraws ETH to receiver.\\n     *\\n     * Requirements:\\n     *\\n     * 1) The caller must be a contract owner.\\n     * @param amount ETH amount to withdraw.\\n     * @param receiver address to send ETH.\\n     */\\n    function withdrawEther(\\n        uint256 amount,\\n        address payable receiver\\n    ) external payable onlyOwner {\\n        (bool success, ) = receiver.call{value: amount}(\\\"\\\"); // solhint-disable-line avoid-low-level-calls\\n        if (!success) {\\n            revert ETHTransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Withdraws payment token asset to receiver.\\n     *\\n     * Requirements:\\n     *\\n     * 1) The caller must be a contract owner.\\n     * @param amount ETH amount to withdraw.\\n     * @param receiver address to send ETH.\\n     */\\n    function withdrawPaymentToken(\\n        uint256 amount,\\n        address receiver\\n    ) external payable onlyOwner {\\n        IERC20(address(controller.paymentToken())).safeTransfer(\\n            receiver,\\n            amount\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets helper ids list for NFT random drop. Can do it only once.\\n     *\\n     * Requirements:\\n     *\\n     * 1) The caller must be a contract owner.\\n     */\\n    function setHelperIdsList() external onlyOwner {\\n        if (helperIdsList.length > 0) {\\n            revert AlreadySet();\\n        }\\n        if (dropType != DropType.NFT) {\\n            revert NotNFTDrop();\\n        }\\n        uint256 maxItems_ = maxItems;\\n        for (uint256 i = 1; i <= maxItems_; ++i) {\\n            helperIdsList.push(i);\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets items classes variations if they are different by class in case of SEMI drop.\\n     * Calculates prefix sums of classes variations to later on derive exact URI ID of an item.\\n     *\\n     * Requirements:\\n     *\\n     * 1) The caller must be a contract owner.\\n     * 2) Variations list length must be a number of classes.\\n     */\\n    function setClassesVariations(\\n        uint256[] calldata variationsList\\n    ) external onlyOwner {\\n        if (prefixSumsVariations.length > 0) {\\n            revert AlreadySet();\\n        }\\n        if (dropType != DropType.SEMI) {\\n            revert NotSEMIDrop();\\n        }\\n        for (uint256 i = 0; i < variationsList.length; ++i) {\\n            // Calculate next prefix variations sum of first i claases by taking (i-1)-th prefix sum and adding i-th variations.\\n            prefixSumsVariations.push(\\n                (i > 0 ? prefixSumsVariations[i - 1] : 0) + variationsList[i]\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets dropFee to dropFee_.\\n     *\\n     * Requirements:\\n     *\\n     * 1) The caller must be a contract owner.\\n     * @param dropFee_ New drops fee\\n     */\\n    function setDropFee(uint256 dropFee_) external onlyOwner {\\n        dropFee = dropFee_;\\n    }\\n\\n    /**\\n     * @notice Sets startTime to startTime_.\\n     *\\n     * Requirements:\\n     *\\n     * 1) The caller must be a contract owner.\\n     * @param startTime_ New start time\\n     */\\n    function setStartTime(uint256 startTime_) external onlyOwner {\\n        if (startTime != 0) {\\n            revert AlreadySet();\\n        }\\n        startTime = startTime_;\\n    }\\n\\n    /**\\n     * @notice Sets endTime to endTime_.\\n     *\\n     * Requirements:\\n     *\\n     * 1) The caller must be a contract owner.\\n     * @param endTime_ New end time\\n     */\\n    function setEndTime(uint256 endTime_) external onlyOwner {\\n        if (endTime != 0) {\\n            revert AlreadySet();\\n        }\\n        endTime = endTime_;\\n    }\\n\\n    /**\\n     * @notice Sets allowlist root if drop is private\\n     *\\n     * Requirements:\\n     *\\n     * 1) The caller must be a contract owner.\\n     * @param allowlistMerkleRoot_ Allowlist merkle root\\n     */\\n    function setAllowlistMerkleRoot(\\n        bytes32 allowlistMerkleRoot_\\n    ) external onlyOwner {\\n        if (!isPrivate) {\\n            revert NotPrivate();\\n        }\\n        allowlistMerkleRoot = allowlistMerkleRoot_;\\n    }\\n\\n    /**\\n     * @notice Sets collection status to vaulted.\\n     *\\n     * Requirements:\\n     *\\n     * 1) The caller must be a managing guardian.\\n     **/\\n    function setVaulted() external virtual onlyManagingGuardian {\\n        collection.setVaulted();\\n    }\\n\\n    /**\\n     * @notice Does minting drop for user based on IERC11554KController requestMint.\\n     *\\n     * Requirements:\\n     *\\n     * 1) Must satisfy all controller.requestMint() and controller.mint() conditions\\n     * 2) Sender should be in allowlist if the drop is private.\\n     * 3) Amount items to mint cannot exceed maxItemsPerMint.\\n     * 4) Must send enough ETH to cover dropFee * amount and to cover all additional fees\\n     * @param amount Amount of items to mint.\\n     * @param itemId If minting drop allows users to mint to any id then just means URI item id (regardless of whether we have variations or not),\\n     * in case of semi-random items sets with variations allows to mint to specific items class. If its random NFT minting then fully ignored.\\n     * @param allowlistProof, merkle proof list of user inclusing in drop allowlist, used if drop is private.\\n     * @return id\\n     */\\n    function mint(\\n        uint256 amount,\\n        uint256 itemId,\\n        bytes32[] calldata allowlistProof\\n    ) external payable virtual returns (uint256 id, uint256 uriID) {\\n        if (startTime != 0 && startTime > block.timestamp) {\\n            revert NotStarted();\\n        }\\n        if (endTime != 0 && endTime < block.timestamp) {\\n            revert HasEnded();\\n        }\\n        if (\\n            isPrivate &&\\n            !MerkleProof.verifyCalldata(\\n                allowlistProof,\\n                allowlistMerkleRoot,\\n                keccak256(abi.encodePacked(msg.sender))\\n            )\\n        ) {\\n            revert AccessDenied();\\n        }\\n        if (amount > 1 && dropType == DropType.NFT) {\\n            revert InvalidAmount();\\n        }\\n\\n        if (itemsPerUser[msg.sender] + amount > maxItemsPerUser) {\\n            revert UserMintingLimitExceeded();\\n        }\\n\\n        if (mintedItems + amount > maxItems) {\\n            revert MintingLimitExceeded();\\n        }\\n        if (msg.value != dropFee * amount) {\\n            revert LowSentETH();\\n        }\\n        if (\\n            dropType == DropType.SEMI &&\\n            prefixSumsVariations.length > 0 &&\\n            itemId > prefixSumsVariations.length\\n        ) {\\n            revert InvalidItemID();\\n        }\\n        if (dropType == DropType.DETERMINED) {\\n            uriID = itemId;\\n        } else {\\n            if (dropType == DropType.NFT) {\\n                uint256 curHelperLen = helperIdsList.length - mintedItems;\\n                uriID = uint256(blockhash(block.number)) % curHelperLen;\\n                uint256 realIDValue = helperIdsList[uriID];\\n                if (curHelperLen > 1) {\\n                    helperIdsList[uriID] = helperIdsList[curHelperLen - 1];\\n                    helperIdsList[curHelperLen - 1] = realIDValue;\\n                }\\n                uriID = realIDValue;\\n            } else {\\n                // 2 cases, if variations are different per class or if they are equal \\\"variations\\\".\\n                if (prefixSumsVariations.length > 0) {\\n                    // Take previous class variations (itemIds are numbered from 1 instead of 0, so substract -1 additionally everywhere).\\n                    uint256 prevClassVariations = (\\n                        itemId > 1 ? prefixSumsVariations[itemId - 2] : 0\\n                    );\\n                    // Calculate random variation for class itemId.\\n                    // URI IDs start from prefixSumsVariations[itemId - 2] + 1 until prefixSumsVariations[itemId - 1].\\n                    // So we need to have a random number in range from [0; prefixSumsVariations[itemId - 1] - prefixSumsVariations[itemId - 2] - 1].\\n                    uriID =\\n                        uint256(blockhash(block.number)) %\\n                        (prefixSumsVariations[itemId - 1] -\\n                            prevClassVariations);\\n                    // Add up URI IDs shift for itemId class.\\n                    uriID += prevClassVariations + 1;\\n                } else {\\n                    uriID = uint256(blockhash(block.number)) % variations;\\n                    uriID += variations * (itemId - 1) + 1;\\n                }\\n            }\\n        }\\n        if (itemsIDMinted[uriID] + amount > maxItemsPerID) {\\n            revert MintingLimitExceeded();\\n        }\\n        mintedItems += amount; //total items overall\\n        itemsPerUser[msg.sender] += amount; //total items per user\\n        itemsIDMinted[uriID] += amount; //total items per id\\n        id = controller.requestMint(\\n            collection,\\n            dropType == DropType.NFT ? 0 : uriIDItemID[uriID], // If dropType is NFT drop then mint new item, otherwise take mapped URI ID to actual collection item id.\\n            managingGuardian,\\n            amount,\\n            serviceFeePerItem * amount,\\n            dropType == DropType.NFT ? false : true,\\n            msg.sender,\\n            guardianClassIndex,\\n            guardianFeeAmountPerItem * amount\\n        );\\n        // If drop type is not NFT type then map URI ID to collection item id.\\n        if (dropType != DropType.NFT && uriIDItemID[uriID] == 0) {\\n            uriIDItemID[uriID] = id;\\n        }\\n        controller.mint(collection, id);\\n        collection.setItemUriID(id, uriID);\\n        emit MintedDrop(id, uriID, amount, msg.sender);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC11554KController\",\"name\":\"controller_\",\"type\":\"address\"},{\"internalType\":\"contract IERC11554KDrops\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPrivate_\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxItemsPerUser_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxItemsPerID_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxItems_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"variations_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"managingGuardian_\",\"type\":\"address\"},{\"internalType\":\"enum MintingDrops.DropType\",\"name\":\"dropType_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"serviceFeePerItem_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"guardianFeeAmountPerItem_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"guardianClassIndex_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessDenied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ETHTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EqualItems\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HasEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidItemID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LowSentETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintingLimitExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotManagingGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotNFTDrop\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPrivate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSEMIDrop\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UserMintingLimitExceeded\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomUriID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"MintedDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowlistMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collection\",\"outputs\":[{\"internalType\":\"contract IERC11554KDrops\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IERC11554KController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropType\",\"outputs\":[{\"internalType\":\"enum MintingDrops.DropType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardianClassIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardianFeeAmountPerItem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"helperIdsList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPrivate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"itemsIDMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"itemsPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managingGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxItems\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxItemsPerID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxItemsPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"allowlistProof\",\"type\":\"bytes32[]\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uriID\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintedItems\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prefixSumsVariations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceFeePerItem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"allowlistMerkleRoot_\",\"type\":\"bytes32\"}],\"name\":\"setAllowlistMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"variationsList\",\"type\":\"uint256[]\"}],\"name\":\"setClassesVariations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropFee_\",\"type\":\"uint256\"}],\"name\":\"setDropFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"endTime_\",\"type\":\"uint256\"}],\"name\":\"setEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setHelperIdsList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime_\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setVaulted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uriIDItemID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uriIDUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"variations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdrawPaymentToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MintingDrops", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000cb4977b21e157d61a8f0f0b7d7973a9ef74628050000000000000000000000007ff9fd0c3efb69b6477487c47e257ff35506e39a00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000002c0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000da72cf4472b874f51166398e1f2ab2c8094d6608000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006124fee993bc00000000000000000000000000000000000000000000000000000000000000000015", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}