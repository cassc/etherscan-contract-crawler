{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"src/Interfaces/IBondCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-1.0\\r\\n\\r\\npragma solidity >=0.7.5 <=0.8.10;\\r\\n\\r\\ninterface IBondCalculator {\\r\\n    function valuation(address tokenIn, uint256 amount_) external view returns (uint256 amountOut);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Interfaces/IFounderVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IFounderVesting {\\r\\n    event PayeeAdded(address account, uint256 shares);\\r\\n    event ERC20PaymentReleased(IERC20 indexed token, address to, uint256 amount);\\r\\n    event PaymentReceived(address from, uint256 amount);\\r\\n    event InitialMint(uint256 amount);\\r\\n\\r\\n    function getTotalShares() external view returns (uint256);\\r\\n\\r\\n    function getTotalReleased(IERC20 token) external view returns (uint256);\\r\\n\\r\\n    function getShares(address account) external view returns (uint256);\\r\\n\\r\\n    function getReleased(IERC20 token, address account) external view returns (uint256);\\r\\n\\r\\n    function release(IERC20 token) external;\\r\\n\\r\\n    function releaseAmount(IERC20 token, uint256 amount) external;\\r\\n\\r\\n    function getReleasable(IERC20 token, address account) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Interfaces/ITHEO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface ITHEO is IERC20 {\\r\\n    function mint(address account_, uint256 amount_) external;\\r\\n\\r\\n    function burn(uint256 amount) external;\\r\\n\\r\\n    function burnFrom(address account_, uint256 amount_) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Interfaces/ITheopetraAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\ninterface ITheopetraAuthority {\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\r\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\r\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\r\\n    event ManagerPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\r\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\r\\n    event SignerPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\r\\n\\r\\n    event GovernorPulled(address indexed from, address indexed to);\\r\\n    event GuardianPulled(address indexed from, address indexed to);\\r\\n    event PolicyPulled(address indexed from, address indexed to);\\r\\n    event ManagerPulled(address indexed from, address indexed to);\\r\\n    event VaultPulled(address indexed from, address indexed to);\\r\\n    event SignerPulled(address indexed from, address indexed to);\\r\\n\\r\\n    /* ========== VIEW ========== */\\r\\n\\r\\n    function governor() external view returns (address);\\r\\n\\r\\n    function guardian() external view returns (address);\\r\\n\\r\\n    function policy() external view returns (address);\\r\\n\\r\\n    function manager() external view returns (address);\\r\\n\\r\\n    function vault() external view returns (address);\\r\\n\\r\\n    function whitelistSigner() external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\nimport \\\"./IBondCalculator.sol\\\";\\r\\n\\r\\ninterface ITreasury {\\r\\n    function deposit(\\r\\n        uint256 _amount,\\r\\n        address _token,\\r\\n        uint256 _profit\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function withdraw(uint256 _amount, address _token) external;\\r\\n\\r\\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\\r\\n\\r\\n    function mint(address _recipient, uint256 _amount) external;\\r\\n\\r\\n    function manage(address _token, uint256 _amount) external;\\r\\n\\r\\n    function incurDebt(uint256 amount_, address token_) external;\\r\\n\\r\\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\\r\\n\\r\\n    function tokenPerformanceUpdate() external;\\r\\n\\r\\n    function baseSupply() external view returns (uint256);\\r\\n\\r\\n    function deltaTokenPrice() external view returns (int256);\\r\\n\\r\\n    function deltaTreasuryYield() external view returns (int256);\\r\\n\\r\\n    function getTheoBondingCalculator() external view returns (IBondCalculator);\\r\\n\\r\\n    function setTheoBondingCalculator(address _theoBondingCalculator) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\nimport { IERC20 } from \\\"../Interfaces/IERC20.sol\\\";\\r\\n\\r\\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\\r\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\r\\n/// Taken from Solmate\\r\\nlibrary SafeERC20 {\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(\\r\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\\r\\n        );\\r\\n\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(\\r\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\r\\n        );\\r\\n\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        (bool success, bytes memory data) = address(token).call(\\r\\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\\r\\n        );\\r\\n\\r\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 amount) internal {\\r\\n        (bool success, ) = to.call{ value: amount }(new bytes(0));\\r\\n\\r\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\\r\\n        if (a > 3) {\\r\\n            c = a;\\r\\n            uint256 b = add(div(a, 2), 1);\\r\\n            while (b < c) {\\r\\n                c = b;\\r\\n                b = div(add(div(a, b), b), 2);\\r\\n            }\\r\\n        } else if (a != 0) {\\r\\n            c = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Expects percentage to be trailed by 00,\\r\\n     */\\r\\n    function percentageAmount(uint256 total_, uint8 percentage_) internal pure returns (uint256 percentAmount_) {\\r\\n        return div(mul(total_, percentage_), 1000);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * Expects percentage to be trailed by 00,\\r\\n     */\\r\\n    function substractPercentage(uint256 total_, uint8 percentageToSub_) internal pure returns (uint256 result_) {\\r\\n        return sub(total_, div(mul(total_, percentageToSub_), 1000));\\r\\n    }\\r\\n\\r\\n    function percentageOfTotal(uint256 part_, uint256 total_) internal pure returns (uint256 percent_) {\\r\\n        return div(mul(part_, 100), total_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Taken from Hypersonic https://github.com/M2629/HyperSonic/blob/main/Math.sol\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\\r\\n    }\\r\\n\\r\\n    function quadraticPricing(uint256 payment_, uint256 multiplier_) internal pure returns (uint256) {\\r\\n        return sqrrt(mul(multiplier_, payment_));\\r\\n    }\\r\\n\\r\\n    function bondingCurve(uint256 supply_, uint256 multiplier_) internal pure returns (uint256) {\\r\\n        return mul(multiplier_, supply_);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Libraries/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @title SignedSafeMath\\r\\n * @dev Signed math operations with safety checks that revert on error.\\r\\n */\\r\\nlibrary SignedSafeMath {\\r\\n    int256 private constant _INT256_MIN = -2**255;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two signed integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\r\\n\\r\\n        int256 c = a * b;\\r\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two signed integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\r\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\r\\n\\r\\n        int256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two signed integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two signed integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Theopetra/TheopetraFounderVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.5;\\r\\n\\r\\nimport \\\"../Types/TheopetraAccessControlled.sol\\\";\\r\\n\\r\\nimport \\\"../Libraries/SafeMath.sol\\\";\\r\\nimport \\\"../Libraries/SafeERC20.sol\\\";\\r\\nimport \\\"../Libraries/SignedSafeMath.sol\\\";\\r\\n\\r\\nimport \\\"../Interfaces/IFounderVesting.sol\\\";\\r\\nimport \\\"../Interfaces/ITHEO.sol\\\";\\r\\nimport \\\"../Interfaces/ITreasury.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title TheopetraFounderVesting\\r\\n * @dev This contract allows to split THEO payments among a group of accounts. The sender does not need to be aware\\r\\n * that the THEO will be split in this way, since it is handled transparently by the contract.\\r\\n *\\r\\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\\r\\n * account to a number of shares. Of all the THEO that this contract receives, each account will then be able to claim\\r\\n * an amount proportional to the percentage of total shares they were assigned.\\r\\n *\\r\\n * `TheopetraFounderVesting` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\\r\\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\\r\\n * function.\\r\\n */\\r\\ncontract TheopetraFounderVesting is IFounderVesting, TheopetraAccessControlled {\\r\\n    /* ========== DEPENDENCIES ========== */\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    using SignedSafeMath for int256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n    ITreasury private treasury;\\r\\n    ITHEO private THEO;\\r\\n    IFounderVesting private vesting;\\r\\n\\r\\n    uint256 private fdvTarget;\\r\\n\\r\\n    uint256 private totalShares;\\r\\n\\r\\n    mapping(address => uint256) private shares;\\r\\n    address[] private payees;\\r\\n\\r\\n    mapping(IERC20 => uint256) private erc20TotalReleased;\\r\\n    mapping(IERC20 => mapping(address => uint256)) private erc20Released;\\r\\n\\r\\n    uint256 private immutable deployTime = block.timestamp;\\r\\n    uint256[] private unlockTimes;\\r\\n    uint256[] private unlockAmounts;\\r\\n\\r\\n    bool private founderRebalanceLocked = false;\\r\\n    bool private initialized = false;\\r\\n\\r\\n    /**\\r\\n     * @notice return the decimals in the percentage values and\\r\\n     * thus the number of shares per percentage point (1% = 10_000_000 shares)\\r\\n     */\\r\\n    function decimals() public pure returns (uint8) {\\r\\n        return 9;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates an instance of `TheopetraFounderVesting` where each account in `payees` is assigned the number of shares at\\r\\n     * the matching position in the `shares` array.\\r\\n     *\\r\\n     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\\r\\n     * duplicates in `payees`.\\r\\n     */\\r\\n    constructor(\\r\\n        ITheopetraAuthority _authority,\\r\\n        address _treasury,\\r\\n        address _theo,\\r\\n        \\r\\n        uint256 _fdvTarget,\\r\\n        address[] memory _payees,\\r\\n        uint256[] memory _shares,\\r\\n        uint256[] memory _unlockTimes,\\r\\n        uint256[] memory _unlockAmounts\\r\\n    ) TheopetraAccessControlled(_authority) {\\r\\n        require(_payees.length == _shares.length, \\\"TheopetraFounderVesting: payees and shares length mismatch\\\");\\r\\n        require(_payees.length > 0, \\\"TheopetraFounderVesting: no payees\\\");\\r\\n        require(\\r\\n            _unlockTimes.length == _unlockAmounts.length,\\r\\n            \\\"TheopetraFounderVesting: unlock times and amounts length mismatch\\\"\\r\\n        );\\r\\n        require(_unlockTimes.length > 0, \\\"TheopetraFounderVesting: no unlock schedule\\\");\\r\\n\\r\\n        fdvTarget = _fdvTarget;\\r\\n        THEO = ITHEO(_theo);\\r\\n        treasury = ITreasury(_treasury);\\r\\n        \\r\\n        unlockTimes = _unlockTimes;\\r\\n        unlockAmounts = _unlockAmounts;\\r\\n\\r\\n        for (uint256 i = 0; i < _payees.length; i++) {\\r\\n            _addPayee(_payees[i], _shares[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function initialMint(address _vesting) public onlyGovernor {\\r\\n        require(!initialized, \\\"TheopetraFounderVesting: initialMint can only be run once\\\");\\r\\n        initialized = true;\\r\\n        \\r\\n        vesting = IFounderVesting(_vesting);\\r\\n        // mint tokens for the initial shares\\r\\n        uint256 tokensToMint = totalShares.mul(THEO.totalSupply() - THEO.balanceOf(address(vesting))).div(10**decimals());\\r\\n        treasury.mint(address(this), tokensToMint);\\r\\n        emit InitialMint(tokensToMint);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter for the total shares held by payees.\\r\\n     */\\r\\n    function getTotalShares() public view override returns (uint256) {\\r\\n        return totalShares;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter for the total amount of `token` already released. `token` should be the address of an IERC20\\r\\n     * contract.\\r\\n     */\\r\\n    function getTotalReleased(IERC20 token) public view override returns (uint256) {\\r\\n        return erc20TotalReleased[token];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter for the amount of shares held by an account.\\r\\n     */\\r\\n    function getShares(address account) external view override returns (uint256) {\\r\\n        return shares[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter for the amount of `token` tokens already released to a payee. `token` should be the address of an\\r\\n     * IERC20 contract.\\r\\n     */\\r\\n    function getReleased(IERC20 token, address account) public view override returns (uint256) {\\r\\n        return erc20Released[token][account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Getter for unlocked multiplier for time-locked funds. This is the percent currently unlocked as a decimal ratio of 1.\\r\\n     */\\r\\n    function getUnlockedMultiplier() public view returns (uint256) {\\r\\n        uint256 timeSinceDeploy = block.timestamp - deployTime;\\r\\n        for (uint256 i = unlockTimes.length; i > 0; i--) {\\r\\n            if (timeSinceDeploy >= unlockTimes[i - 1]) {\\r\\n                return unlockAmounts[i - 1];\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Scale the founder amount with respect to the FDV target value\\r\\n     * @dev calculated as currentFDV / FDVtarget (using 9 decimals)\\r\\n     * @return uint256 proportion of FDV target, 9 decimals\\r\\n     */\\r\\n    function getFdvFactor() public view returns (uint256) {\\r\\n        IBondCalculator theoBondingCalculator = treasury.getTheoBondingCalculator();\\r\\n        if (address(theoBondingCalculator) == address(0)) {\\r\\n            revert(\\\"TheopetraFounderVesting: No bonding calculator\\\");\\r\\n        }\\r\\n\\r\\n        // expects valuation to be come back as fixed point with 9 decimals\\r\\n        uint256 currentPrice = IBondCalculator(theoBondingCalculator).valuation(address(THEO), 1_000_000_000);\\r\\n        uint256 calculatedFdv = currentPrice.mul(THEO.totalSupply());\\r\\n\\r\\n        if (calculatedFdv >= fdvTarget.mul(10**decimals())) {\\r\\n            return 10**decimals();\\r\\n        }\\r\\n\\r\\n        return calculatedFdv.div(fdvTarget);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints or burns tokens for this contract to balance shares to their appropriate percentage\\r\\n     */\\r\\n    function rebalance() public {\\r\\n        require(shares[msg.sender] > 0, \\\"TheopetraFounderVesting: account has no shares\\\");\\r\\n\\r\\n        uint256 totalSupply = THEO.totalSupply() - THEO.balanceOf(address(vesting));\\r\\n        uint256 contractBalance = THEO.balanceOf(address(this));\\r\\n        uint256 externalReleased = vesting.getTotalReleased(THEO);\\r\\n        uint256 totalReleased = erc20TotalReleased[THEO];\\r\\n\\r\\n        // Checks if rebalance has been locked\\r\\n        if (founderRebalanceLocked) return;\\r\\n\\r\\n        uint256 founderAmount = totalShares\\r\\n            .mul(totalSupply - (contractBalance + totalReleased + externalReleased))\\r\\n            .mul(getFdvFactor())\\r\\n            .div(10**decimals())\\r\\n            .div(10**decimals());\\r\\n\\r\\n        if (founderAmount > (contractBalance + totalReleased)) {\\r\\n            treasury.mint(address(this), founderAmount - (contractBalance + totalReleased));\\r\\n        } else if (founderAmount < (contractBalance + totalReleased)) {\\r\\n            THEO.burn(contractBalance + totalReleased - founderAmount);\\r\\n        }\\r\\n\\r\\n        // locks the rebalance to not occur again after it is called once after unlock schedule\\r\\n        uint256 timeSinceDeploy = block.timestamp - deployTime;\\r\\n        if (timeSinceDeploy > unlockTimes[unlockTimes.length - 1]) {\\r\\n            founderRebalanceLocked = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers a transfer to `account` of the amount of `token` tokens they are owed, according to their\\r\\n     * percentage of the total shares and their previous withdrawals. `token` must be the address of an IERC20\\r\\n     * contract.\\r\\n     */\\r\\n    function release(IERC20 token) external override {\\r\\n        address account = msg.sender;\\r\\n        require(shares[account] > 0, \\\"TheopetraFounderVesting: account has no shares\\\");\\r\\n\\r\\n        rebalance();\\r\\n\\r\\n        uint256 totalReceived = token.balanceOf(address(this)) + getTotalReleased(token);\\r\\n        uint256 payment = _pendingPayment(account, totalReceived, getReleased(token, account));\\r\\n\\r\\n        require(payment != 0, \\\"TheopetraFounderVesting: account is not due payment\\\");\\r\\n\\r\\n        erc20Released[token][account] += payment;\\r\\n        erc20TotalReleased[token] += payment;\\r\\n\\r\\n        SafeERC20.safeTransfer(token, account, payment);\\r\\n        emit ERC20PaymentReleased(token, account, payment);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers a transfer to `account` of the amount of `token` tokens specified, according to their\\r\\n     * percentage of the total shares and their previous withdrawals. `token` must be the address of an IERC20\\r\\n     * contract.\\r\\n     */\\r\\n    function releaseAmount(IERC20 token, uint256 amount) external override {\\r\\n        address account = msg.sender;\\r\\n        require(shares[account] > 0, \\\"TheopetraFounderVesting: account has no shares\\\");\\r\\n        require(amount > 0, \\\"TheopetraFounderVesting: amount cannot be 0\\\");\\r\\n\\r\\n        rebalance();\\r\\n\\r\\n        uint256 totalReceived = token.balanceOf(address(this)) + getTotalReleased(token);\\r\\n        uint256 payment = _pendingPayment(account, totalReceived, getReleased(token, account));\\r\\n\\r\\n        require(payment != 0, \\\"TheopetraFounderVesting: account is not due payment\\\");\\r\\n        require(amount <= payment, \\\"TheopetraFounderVesting: requested amount is more than due payment for account\\\");\\r\\n\\r\\n        erc20Released[token][account] += amount;\\r\\n        erc20TotalReleased[token] += amount;\\r\\n\\r\\n        SafeERC20.safeTransfer(token, account, amount);\\r\\n        emit ERC20PaymentReleased(token, account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens that could be paid to `account` at the current time.\\r\\n     */\\r\\n    function getReleasable(IERC20 token, address account) external view override returns (uint256) {\\r\\n        require(shares[account] > 0, \\\"TheopetraFounderVesting: account has no shares\\\");\\r\\n\\r\\n        uint256 totalReceived = token.balanceOf(address(this)) + getTotalReleased(token);\\r\\n        uint256 payment = _pendingPayment(account, totalReceived, getReleased(token, account));\\r\\n\\r\\n        return payment;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev internal logic for computing the pending payment of an `account` given the token historical balances and\\r\\n     * already released amounts.\\r\\n     */\\r\\n    function _pendingPayment(\\r\\n        address account,\\r\\n        uint256 totalReceived,\\r\\n        uint256 alreadyReleased\\r\\n    ) private view returns (uint256) {\\r\\n        return\\r\\n            (totalReceived * shares[account] * getUnlockedMultiplier()) /\\r\\n            (totalShares * 10**decimals()) -\\r\\n            alreadyReleased;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a new payee to the contract.\\r\\n     * @param account The address of the payee to add.\\r\\n     * @param shares_ The number of shares owned by the payee.\\r\\n     */\\r\\n    function _addPayee(address account, uint256 shares_) private {\\r\\n        require(account != address(0), \\\"TheopetraFounderVesting: account is the zero address\\\");\\r\\n        require(shares_ > 0, \\\"TheopetraFounderVesting: shares are 0\\\");\\r\\n        require(shares[account] == 0, \\\"TheopetraFounderVesting: account already has shares\\\");\\r\\n\\r\\n        payees.push(account);\\r\\n        shares[account] = shares_;\\r\\n        totalShares = totalShares + shares_;\\r\\n        emit PayeeAdded(account, shares_);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/Types/TheopetraAccessControlled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.7.5;\\r\\n\\r\\nimport \\\"../Interfaces/ITheopetraAuthority.sol\\\";\\r\\n\\r\\nabstract contract TheopetraAccessControlled {\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event AuthorityUpdated(ITheopetraAuthority indexed authority);\\r\\n\\r\\n    string constant UNAUTHORIZED = \\\"UNAUTHORIZED\\\"; // save gas\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    ITheopetraAuthority public authority;\\r\\n\\r\\n    /* ========== Constructor ========== */\\r\\n\\r\\n    constructor(ITheopetraAuthority _authority) {\\r\\n        authority = _authority;\\r\\n        emit AuthorityUpdated(_authority);\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    modifier onlyGovernor() {\\r\\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyGuardian() {\\r\\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyPolicy() {\\r\\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyManager() {\\r\\n        require(msg.sender == authority.manager(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyVault() {\\r\\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /* ========== GOV ONLY ========== */\\r\\n\\r\\n    function setAuthority(ITheopetraAuthority _newAuthority) external onlyGovernor {\\r\\n        authority = _newAuthority;\\r\\n        emit AuthorityUpdated(_newAuthority);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ITheopetraAuthority\",\"name\":\"_authority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_theo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fdvTarget\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_payees\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_shares\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_unlockTimes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_unlockAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ITheopetraAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20PaymentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InitialMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"PayeeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReceived\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract ITheopetraAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFdvFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReleasable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReleased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTotalReleased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockedMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vesting\",\"type\":\"address\"}],\"name\":\"initialMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"releaseAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITheopetraAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TheopetraFounderVesting", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000fe9fab692c951eeb28345b3a22008f4057eaa232000000000000000000000000f3143ae15dea73f4e8f32360f6b669173c854388000000000000000000000000fac0403a24229d7e2edd994d50f5940624cbeac20000000000000000000000000000000000000000000000000000000005f5e1000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000036000000000000000000000000000000000000000000000000000000000000005c000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000ba97a9ff5328f8b8d791c226e753efb826a0edf7000000000000000000000000bf18760c784335c073b181226c2825daff2ec56d0000000000000000000000008969bce75ffe8e0285431ec2a72b1b88312e9a38000000000000000000000000b49785f9849a058d77fb9ad9e5155de4b69113ba0000000000000000000000008a34ff9d491784fd45e4e67b236fdd3e8ccbdc1800000000000000000000000044f2f712d655ff391689be5fa0bbe12d41ddca1a0000000000000000000000004dcedac8fb573d0b0a2a503ebda6d2b54735e31600000000000000000000000062dbef112beaac0f2650a6035424220139ced94900000000000000000000000064d287db1813e03bce07d8dc3041e13a61de5722000000000000000000000000636ea3248ace54e695903cb0f16029f16ae57e2500000000000000000000000091a8c1c2c4ea62e94a47ad2a2d83fd5f1bae621d000000000000000000000000e59599841f395067971829b7f96c759fc5050a5200000000000000000000000083a94059b4725cd051af7543eccd53c12375f9c6000000000000000000000000f875ee97fbd4d248f1ecc037966329af71dfbb060000000000000000000000004a353506c67e8742b2474febcaf698a8b0778b7d000000000000000000000000d6cb2d2694e26fe5092e3187edd23396a7e94749000000000000000000000000f85ce443d3f031728e0e97503c06322c2f51a0c700000000000000000000000063f74af5ee4d7181ef09e8ae6991bd84ba7c39bd000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000009896800000000000000000000000000000000000000000000000000000000000989680000000000000000000000000000000000000000000000000000000000044aa2000000000000000000000000000000000000000000000000000000000001e8480000000000000000000000000000000000000000000000000000000000007a12000000000000000000000000000000000000000000000000000000000002dc6c000000000000000000000000000000000000000000000000000000000002f4d6000000000000000000000000000000000000000000000000000000000018cba8000000000000000000000000000000000000000000000000000000000042c1d800000000000000000000000000000000000000000000000000000000000a7d8c000000000000000000000000000000000000000000000000000000000009896800000000000000000000000000000000000000000000000000000000000a7d8c000000000000000000000000000000000000000000000000000000000009896800000000000000000000000000000000000000000000000000000000001d905c00000000000000000000000000000000000000000000000000000000000a7d8c00000000000000000000000000000000000000000000000000000000000a7d8c0000000000000000000000000000000000000000000000000000000000007a12000000000000000000000000000000000000000000000000000000000007270e000000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000001de90800000000000000000000000000000000000000000000000000000000002061d8000000000000000000000000000000000000000000000000000000000022efc00000000000000000000000000000000000000000000000000000000000256971000000000000000000000000000000000000000000000000000000000027f75900000000000000000000000000000000000000000000000000000000002a854100000000000000000000000000000000000000000000000000000000002ce8f900000000000000000000000000000000000000000000000000000000002f7600000000000000000000000000000000000000000000000000000000000031eed00000000000000000000000000000000000000000000000000000000000347cb8000000000000000000000000000000000000000000000000000000000036f588000000000000000000000000000000000000000000000000000000000039837000000000000000000000000000000000000000000000000000000000003c115800000000000000000000000000000000000000000000000000000000003e8a28000000000000000000000000000000000000000000000000000000000041181000000000000000000000000000000000000000000000000000000000004391c10000000000000000000000000000000000000000000000000000000000461fa9000000000000000000000000000000000000000000000000000000000048ad9100000000000000000000000000000000000000000000000000000000004afc3100000000000000000000000000000000000000000000000000000000004d893800000000000000000000000000000000000000000000000000000000005002080000000000000000000000000000000000000000000000000000000000528ff000000000000000000000000000000000000000000000000000000000005508c000000000000000000000000000000000000000000000000000000000005796a800000000000000000000000000000000000000000000000000000000005a2490000000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000005f5e1000000000000000000000000000000000000000000000000000000000008321560000000000000000000000000000000000000000000000000000000000a6e49c0000000000000000000000000000000000000000000000000000000000caa7e20000000000000000000000000000000000000000000000000000000000ee6b280000000000000000000000000000000000000000000000000000000001122e6e000000000000000000000000000000000000000000000000000000000135f1b4000000000000000000000000000000000000000000000000000000000159b4fa00000000000000000000000000000000000000000000000000000000017d78400000000000000000000000000000000000000000000000000000000001a13b860000000000000000000000000000000000000000000000000000000001c4fecc0000000000000000000000000000000000000000000000000000000001e8c21200000000000000000000000000000000000000000000000000000000020c8558000000000000000000000000000000000000000000000000000000000230489e0000000000000000000000000000000000000000000000000000000002540be4000000000000000000000000000000000000000000000000000000000277cf2a00000000000000000000000000000000000000000000000000000000029b92700000000000000000000000000000000000000000000000000000000002bf55b60000000000000000000000000000000000000000000000000000000002e318fc000000000000000000000000000000000000000000000000000000000306dc4200000000000000000000000000000000000000000000000000000000032a9f8800000000000000000000000000000000000000000000000000000000034e62ce0000000000000000000000000000000000000000000000000000000003722614000000000000000000000000000000000000000000000000000000000395e95a0000000000000000000000000000000000000000000000000000000003b9aca00", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}