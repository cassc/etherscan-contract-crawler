{"SourceCode": "// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\n// File: contracts/lib/CompoundOracleInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n// AT MAINNET ADDRESS: 0x02557a5E05DeFeFFD4cAe6D83eA3d173B272c904\r\n\r\ncontract CompoundOracleInterface {\r\n    // returns asset:eth -- to get USDC:eth, have to do 10**24/result,\r\n\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    /**\r\n  * @notice retrieves price of an asset\r\n  * @dev function to get price for an asset\r\n  * @param asset Asset for which to get the price\r\n  * @return uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused\r\n  */\r\n    function getPrice(address asset) public view returns (uint);\r\n    function getUnderlyingPrice(ERC20 cToken) public view returns (uint);\r\n    // function getPrice(address asset) public view returns (uint) {\r\n    //     return 527557000000000;\r\n    // }\r\n\r\n}\r\n\r\n// File: contracts/lib/UniswapExchangeInterface.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n// Solidity Interface\r\ncontract UniswapExchangeInterface {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to ERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade ERC20 to ETH\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // ERC20 comaptibility for liquidity tokens\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public decimals;\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\n// File: contracts/lib/UniswapFactoryInterface.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n// Solidity Interface\r\ncontract UniswapFactoryInterface {\r\n    // Public Variables\r\n    address public exchangeTemplate;\r\n    uint256 public tokenCount;\r\n    // // Create Exchange\r\n    function createExchange(address token) external returns (address exchange);\r\n    // Get Exchange and Token Info\r\n    function getExchange(address token) external view returns (address exchange);\r\n    function getToken(address exchange) external view returns (address token);\r\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\r\n    // Never use\r\n    function initializeFactory(address template) external;\r\n    // function createExchange(address token) external returns (address exchange) {\r\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\r\n    // }\r\n    // // Get Exchange and Token Info\r\n    // function getExchange(address token) external view returns (address exchange){\r\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\r\n    // }\r\n    // function getToken(address exchange) external view returns (address token) {\r\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\r\n    // }\r\n    // function getTokenWithId(uint256 tokenId) external view returns (address token) {\r\n    //     return 0x06D014475F84Bb45b9cdeD1Cf3A1b8FE3FbAf128;\r\n    // }\r\n}\r\n\r\n// File: contracts/OptionsUtils.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n\r\n\r\n\r\ncontract OptionsUtils {\r\n    // defauls are for mainnet\r\n    UniswapFactoryInterface public UNISWAP_FACTORY;\r\n\r\n    CompoundOracleInterface public COMPOUND_ORACLE;\r\n\r\n    constructor(address _uniswapFactory, address _compoundOracle) public {\r\n        UNISWAP_FACTORY = UniswapFactoryInterface(_uniswapFactory);\r\n        COMPOUND_ORACLE = CompoundOracleInterface(_compoundOracle);\r\n    }\r\n\r\n    // TODO: for now gets Uniswap, later update to get other exchanges\r\n    function getExchange(address _token)\r\n        public\r\n        view\r\n        returns (UniswapExchangeInterface)\r\n    {\r\n        if (address(UNISWAP_FACTORY.getExchange(_token)) == address(0)) {\r\n            revert(\"No payout exchange\");\r\n        }\r\n\r\n        UniswapExchangeInterface exchange = UniswapExchangeInterface(\r\n            UNISWAP_FACTORY.getExchange(_token)\r\n        );\r\n\r\n        return exchange;\r\n    }\r\n\r\n    function isETH(IERC20 _ierc20) public pure returns (bool) {\r\n        return _ierc20 == IERC20(0);\r\n    }\r\n}\r\n\r\n// File: contracts/OptionsExchange.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract OptionsExchange {\r\n    uint256 constant LARGE_BLOCK_SIZE = 1651753129000;\r\n    uint256 constant LARGE_APPROVAL_NUMBER = 10**30;\r\n\r\n    UniswapFactoryInterface public UNISWAP_FACTORY;\r\n\r\n    constructor(address _uniswapFactory) public {\r\n        UNISWAP_FACTORY = UniswapFactoryInterface(_uniswapFactory);\r\n    }\r\n\r\n    /*** Events ***/\r\n    event SellOTokens(\r\n        address seller,\r\n        address payable receiver,\r\n        address oTokenAddress,\r\n        address payoutTokenAddress,\r\n        uint256 oTokensToSell,\r\n        uint256 payoutTokensReceived\r\n    );\r\n    event BuyOTokens(\r\n        address buyer,\r\n        address payable receiver,\r\n        address oTokenAddress,\r\n        address paymentTokenAddress,\r\n        uint256 oTokensToBuy,\r\n        uint256 premiumPaid\r\n    );\r\n\r\n    /**\r\n    * @notice This function sells oTokens on Uniswap and sends back payoutTokens to the receiver\r\n    * @param receiver The address to send the payout tokens back to\r\n    * @param oTokenAddress The address of the oToken to sell\r\n    * @param payoutTokenAddress The address of the token to receive the premiums in\r\n    * @param oTokensToSell The number of oTokens to sell\r\n    */\r\n    function sellOTokens(\r\n        address payable receiver,\r\n        address oTokenAddress,\r\n        address payoutTokenAddress,\r\n        uint256 oTokensToSell\r\n    ) public {\r\n        // @note: first need to bootstrap the uniswap exchange to get the address.\r\n        IERC20 oToken = IERC20(oTokenAddress);\r\n        IERC20 payoutToken = IERC20(payoutTokenAddress);\r\n        oToken.transferFrom(msg.sender, address(this), oTokensToSell);\r\n        uint256 payoutTokensReceived = uniswapSellOToken(\r\n            oToken,\r\n            payoutToken,\r\n            oTokensToSell,\r\n            receiver\r\n        );\r\n\r\n        emit SellOTokens(\r\n            msg.sender,\r\n            receiver,\r\n            oTokenAddress,\r\n            payoutTokenAddress,\r\n            oTokensToSell,\r\n            payoutTokensReceived\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice This function buys oTokens on Uniswap and using paymentTokens from the receiver\r\n    * @param receiver The address to send the oTokens back to\r\n    * @param oTokenAddress The address of the oToken to buy\r\n    * @param paymentTokenAddress The address of the token to pay the premiums in\r\n    * @param oTokensToBuy The number of oTokens to buy\r\n    */\r\n    function buyOTokens(\r\n        address payable receiver,\r\n        address oTokenAddress,\r\n        address paymentTokenAddress,\r\n        uint256 oTokensToBuy\r\n    ) public payable {\r\n        IERC20 oToken = IERC20(oTokenAddress);\r\n        IERC20 paymentToken = IERC20(paymentTokenAddress);\r\n        uniswapBuyOToken(paymentToken, oToken, oTokensToBuy, receiver);\r\n    }\r\n\r\n    /**\r\n    * @notice This function calculates the amount of premiums that the seller\r\n    * will receive if they sold oTokens on Uniswap\r\n    * @param oTokenAddress The address of the oToken to sell\r\n    * @param payoutTokenAddress The address of the token to receive the premiums in\r\n    * @param oTokensToSell The number of oTokens to sell\r\n    */\r\n    function premiumReceived(\r\n        address oTokenAddress,\r\n        address payoutTokenAddress,\r\n        uint256 oTokensToSell\r\n    ) public view returns (uint256) {\r\n        // get the amount of ETH that will be paid out if oTokensToSell is sold.\r\n        UniswapExchangeInterface oTokenExchange = getExchange(oTokenAddress);\r\n        uint256 ethReceived = oTokenExchange.getTokenToEthInputPrice(\r\n            oTokensToSell\r\n        );\r\n\r\n        if (!isETH(IERC20(payoutTokenAddress))) {\r\n            // get the amount of payout tokens that will be received if the ethRecieved is sold.\r\n            UniswapExchangeInterface payoutExchange = getExchange(\r\n                payoutTokenAddress\r\n            );\r\n            return payoutExchange.getEthToTokenInputPrice(ethReceived);\r\n        }\r\n        return ethReceived;\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice This function calculates the premiums to be paid if a buyer wants to\r\n    * buy oTokens on Uniswap\r\n    * @param oTokenAddress The address of the oToken to buy\r\n    * @param paymentTokenAddress The address of the token to pay the premiums in\r\n    * @param oTokensToBuy The number of oTokens to buy\r\n    */\r\n    function premiumToPay(\r\n        address oTokenAddress,\r\n        address paymentTokenAddress,\r\n        uint256 oTokensToBuy\r\n    ) public view returns (uint256) {\r\n        // get the amount of ETH that needs to be paid for oTokensToBuy.\r\n        UniswapExchangeInterface oTokenExchange = getExchange(oTokenAddress);\r\n        uint256 ethToPay = oTokenExchange.getEthToTokenOutputPrice(\r\n            oTokensToBuy\r\n        );\r\n\r\n        if (!isETH(IERC20(paymentTokenAddress))) {\r\n            // get the amount of paymentTokens that needs to be paid to get the desired ethToPay.\r\n            UniswapExchangeInterface paymentTokenExchange = getExchange(\r\n                paymentTokenAddress\r\n            );\r\n            return paymentTokenExchange.getTokenToEthOutputPrice(ethToPay);\r\n        }\r\n\r\n        return ethToPay;\r\n    }\r\n\r\n    function uniswapSellOToken(\r\n        IERC20 oToken,\r\n        IERC20 payoutToken,\r\n        uint256 _amt,\r\n        address payable _transferTo\r\n    ) internal returns (uint256) {\r\n        require(!isETH(oToken), \"Can only sell oTokens\");\r\n        UniswapExchangeInterface exchange = getExchange(address(oToken));\r\n\r\n        if (isETH(payoutToken)) {\r\n            //Token to ETH\r\n            oToken.approve(address(exchange), _amt);\r\n            return\r\n                exchange.tokenToEthTransferInput(\r\n                    _amt,\r\n                    1,\r\n                    LARGE_BLOCK_SIZE,\r\n                    _transferTo\r\n                );\r\n        } else {\r\n            //Token to Token\r\n            oToken.approve(address(exchange), _amt);\r\n            return\r\n                exchange.tokenToTokenTransferInput(\r\n                    _amt,\r\n                    1,\r\n                    1,\r\n                    LARGE_BLOCK_SIZE,\r\n                    _transferTo,\r\n                    address(payoutToken)\r\n                );\r\n        }\r\n    }\r\n\r\n    function uniswapBuyOToken(\r\n        IERC20 paymentToken,\r\n        IERC20 oToken,\r\n        uint256 _amt,\r\n        address payable _transferTo\r\n    ) public returns (uint256) {\r\n        require(!isETH(oToken), \"Can only buy oTokens\");\r\n\r\n        if (!isETH(paymentToken)) {\r\n            UniswapExchangeInterface exchange = getExchange(\r\n                address(paymentToken)\r\n            );\r\n\r\n            uint256 paymentTokensToTransfer = premiumToPay(\r\n                address(oToken),\r\n                address(paymentToken),\r\n                _amt\r\n            );\r\n            paymentToken.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                paymentTokensToTransfer\r\n            );\r\n\r\n            // Token to Token\r\n            paymentToken.approve(address(exchange), LARGE_APPROVAL_NUMBER);\r\n\r\n            emit BuyOTokens(\r\n                msg.sender,\r\n                _transferTo,\r\n                address(oToken),\r\n                address(paymentToken),\r\n                _amt,\r\n                paymentTokensToTransfer\r\n            );\r\n\r\n            return\r\n                exchange.tokenToTokenTransferInput(\r\n                    paymentTokensToTransfer,\r\n                    1,\r\n                    1,\r\n                    LARGE_BLOCK_SIZE,\r\n                    _transferTo,\r\n                    address(oToken)\r\n                );\r\n        } else {\r\n            // ETH to Token\r\n            UniswapExchangeInterface exchange = UniswapExchangeInterface(\r\n                UNISWAP_FACTORY.getExchange(address(oToken))\r\n            );\r\n\r\n            uint256 ethToTransfer = exchange.getEthToTokenOutputPrice(_amt);\r\n\r\n            emit BuyOTokens(\r\n                msg.sender,\r\n                _transferTo,\r\n                address(oToken),\r\n                address(paymentToken),\r\n                _amt,\r\n                ethToTransfer\r\n            );\r\n\r\n            return\r\n                exchange.ethToTokenTransferOutput.value(ethToTransfer)(\r\n                    _amt,\r\n                    LARGE_BLOCK_SIZE,\r\n                    _transferTo\r\n                );\r\n        }\r\n    }\r\n\r\n    function getExchange(address _token)\r\n        internal\r\n        view\r\n        returns (UniswapExchangeInterface)\r\n    {\r\n        UniswapExchangeInterface exchange = UniswapExchangeInterface(\r\n            UNISWAP_FACTORY.getExchange(_token)\r\n        );\r\n\r\n        if (address(exchange) == address(0)) {\r\n            revert(\"No payout exchange\");\r\n        }\r\n\r\n        return exchange;\r\n    }\r\n\r\n    function isETH(IERC20 _ierc20) internal pure returns (bool) {\r\n        return _ierc20 == IERC20(0);\r\n    }\r\n\r\n    function() external payable {\r\n        // to get ether from uniswap exchanges\r\n    }\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/OptionsContract.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Opyn's Options Contract\r\n * @author Opyn\r\n */\r\ncontract OptionsContract is Ownable, ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    /* represents floting point numbers, where number = value * 10 ** exponent\r\n    i.e 0.1 = 10 * 10 ** -3 */\r\n    struct Number {\r\n        uint256 value;\r\n        int32 exponent;\r\n    }\r\n\r\n    // Keeps track of the weighted collateral and weighted debt for each vault.\r\n    struct Vault {\r\n        uint256 collateral;\r\n        uint256 oTokensIssued;\r\n        uint256 underlying;\r\n        bool owned;\r\n    }\r\n\r\n    OptionsExchange public optionsExchange;\r\n\r\n    mapping(address => Vault) internal vaults;\r\n\r\n    address payable[] internal vaultOwners;\r\n\r\n    // 10 is 0.01 i.e. 1% incentive.\r\n    Number public liquidationIncentive = Number(10, -3);\r\n\r\n    // 100 is egs. 0.1 i.e. 10%.\r\n    Number public transactionFee = Number(0, -3);\r\n\r\n    /* 500 is 0.5. Max amount that a Vault can be liquidated by i.e.\r\n    max collateral that can be taken in one function call */\r\n    Number public liquidationFactor = Number(500, -3);\r\n\r\n    /* 16 means 1.6. The minimum ratio of a Vault's collateral to insurance promised.\r\n    The ratio is calculated as below:\r\n    vault.collateral / (Vault.oTokensIssued * strikePrice) */\r\n    Number public minCollateralizationRatio = Number(16, -1);\r\n\r\n    // The amount of insurance promised per oToken\r\n    Number public strikePrice;\r\n\r\n    // The amount of underlying that 1 oToken protects.\r\n    Number public oTokenExchangeRate;\r\n\r\n    /* UNIX time.\r\n    Exercise period starts at `(expiry - windowSize)` and ends at `expiry` */\r\n    uint256 internal windowSize;\r\n\r\n    /* The total fees accumulated in the contract any time liquidate or exercise is called */\r\n    uint256 internal totalFee;\r\n\r\n    // The time of expiry of the options contract\r\n    uint256 public expiry;\r\n\r\n    // The precision of the collateral\r\n    int32 public collateralExp = -18;\r\n\r\n    // The precision of the underlying\r\n    int32 public underlyingExp = -18;\r\n\r\n    // The collateral asset\r\n    IERC20 public collateral;\r\n\r\n    // The asset being protected by the insurance\r\n    IERC20 public underlying;\r\n\r\n    // The asset in which insurance is denominated in.\r\n    IERC20 public strike;\r\n\r\n    // The Oracle used for the contract\r\n    CompoundOracleInterface public COMPOUND_ORACLE;\r\n\r\n    // The name of  the contract\r\n    string public name;\r\n\r\n    // The symbol of  the contract\r\n    string public symbol;\r\n\r\n    // The number of decimals of the contract\r\n    uint8 public decimals;\r\n\r\n    /**\r\n    * @param _collateral The collateral asset\r\n    * @param _collExp The precision of the collateral (-18 if ETH)\r\n    * @param _underlying The asset that is being protected\r\n    * @param _underlyingExp The precision of the underlying asset\r\n    * @param _oTokenExchangeExp The precision of the `amount of underlying` that 1 oToken protects\r\n    * @param _strikePrice The amount of strike asset that will be paid out per oToken\r\n    * @param _strikeExp The precision of the strike price.\r\n    * @param _strike The asset in which the insurance is calculated\r\n    * @param _expiry The time at which the insurance expires\r\n    * @param _optionsExchange The contract which interfaces with the exchange + oracle\r\n    * @param _oracleAddress The address of the oracle\r\n    * @param _windowSize UNIX time. Exercise window is from `expiry - _windowSize` to `expiry`.\r\n    */\r\n    constructor(\r\n        IERC20 _collateral,\r\n        int32 _collExp,\r\n        IERC20 _underlying,\r\n        int32 _underlyingExp,\r\n        int32 _oTokenExchangeExp,\r\n        uint256 _strikePrice,\r\n        int32 _strikeExp,\r\n        IERC20 _strike,\r\n        uint256 _expiry,\r\n        OptionsExchange _optionsExchange,\r\n        address _oracleAddress,\r\n        uint256 _windowSize\r\n    ) public {\r\n        require(block.timestamp < _expiry, \"Can't deploy an expired contract\");\r\n        require(\r\n            _windowSize <= _expiry,\r\n            \"Exercise window can't be longer than the contract's lifespan\"\r\n        );\r\n        require(\r\n            isWithinExponentRange(_collExp),\r\n            \"collateral exponent not within expected range\"\r\n        );\r\n        require(\r\n            isWithinExponentRange(_underlyingExp),\r\n            \"underlying exponent not within expected range\"\r\n        );\r\n        require(\r\n            isWithinExponentRange(_strikeExp),\r\n            \"strike price exponent not within expected range\"\r\n        );\r\n        require(\r\n            isWithinExponentRange(_oTokenExchangeExp),\r\n            \"oToken exchange rate exponent not within expected range\"\r\n        );\r\n\r\n        collateral = _collateral;\r\n        collateralExp = _collExp;\r\n\r\n        underlying = _underlying;\r\n        underlyingExp = _underlyingExp;\r\n        oTokenExchangeRate = Number(1, _oTokenExchangeExp);\r\n\r\n        strikePrice = Number(_strikePrice, _strikeExp);\r\n        strike = _strike;\r\n\r\n        expiry = _expiry;\r\n        COMPOUND_ORACLE = CompoundOracleInterface(_oracleAddress);\r\n        optionsExchange = _optionsExchange;\r\n        windowSize = _windowSize;\r\n    }\r\n\r\n    /*** Events ***/\r\n    event VaultOpened(address payable vaultOwner);\r\n    event ETHCollateralAdded(\r\n        address payable vaultOwner,\r\n        uint256 amount,\r\n        address payer\r\n    );\r\n    event ERC20CollateralAdded(\r\n        address payable vaultOwner,\r\n        uint256 amount,\r\n        address payer\r\n    );\r\n    event IssuedOTokens(\r\n        address issuedTo,\r\n        uint256 oTokensIssued,\r\n        address payable vaultOwner\r\n    );\r\n    event Liquidate(\r\n        uint256 amtCollateralToPay,\r\n        address payable vaultOwner,\r\n        address payable liquidator\r\n    );\r\n    event Exercise(\r\n        uint256 amtUnderlyingToPay,\r\n        uint256 amtCollateralToPay,\r\n        address payable exerciser,\r\n        address payable vaultExercisedFrom\r\n    );\r\n    event RedeemVaultBalance(\r\n        uint256 amtCollateralRedeemed,\r\n        uint256 amtUnderlyingRedeemed,\r\n        address payable vaultOwner\r\n    );\r\n    event BurnOTokens(address payable vaultOwner, uint256 oTokensBurned);\r\n    event RemoveCollateral(uint256 amtRemoved, address payable vaultOwner);\r\n    event UpdateParameters(\r\n        uint256 liquidationIncentive,\r\n        uint256 liquidationFactor,\r\n        uint256 transactionFee,\r\n        uint256 minCollateralizationRatio,\r\n        address owner\r\n    );\r\n    event TransferFee(address payable to, uint256 fees);\r\n    event RemoveUnderlying(\r\n        uint256 amountUnderlying,\r\n        address payable vaultOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Throws if called Options contract is expired.\r\n     */\r\n    modifier notExpired() {\r\n        require(!hasExpired(), \"Options contract expired\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice This function gets the array of vaultOwners\r\n     */\r\n    function getVaultOwners() public view returns (address payable[] memory) {\r\n        address payable[] memory owners;\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < vaultOwners.length; i++) {\r\n            if (hasVault(vaultOwners[i])) {\r\n                owners[index] = vaultOwners[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return owners;\r\n    }\r\n\r\n    /**\r\n     * @notice Can only be called by owner. Used to update the fees, minminCollateralizationRatio, etc\r\n     * @param _liquidationIncentive The incentive paid to liquidator. 10 is 0.01 i.e. 1% incentive.\r\n     * @param _liquidationFactor Max amount that a Vault can be liquidated by. 500 is 0.5.\r\n     * @param _transactionFee The fees paid to our protocol every time a execution happens. 100 is egs. 0.1 i.e. 10%.\r\n     * @param _minCollateralizationRatio The minimum ratio of a Vault's collateral to insurance promised. 16 means 1.6.\r\n     */\r\n    function updateParameters(\r\n        uint256 _liquidationIncentive,\r\n        uint256 _liquidationFactor,\r\n        uint256 _transactionFee,\r\n        uint256 _minCollateralizationRatio\r\n    ) public onlyOwner {\r\n        require(\r\n            _liquidationIncentive <= 200,\r\n            \"Can't have >20% liquidation incentive\"\r\n        );\r\n        require(\r\n            _liquidationFactor <= 1000,\r\n            \"Can't liquidate more than 100% of the vault\"\r\n        );\r\n        require(_transactionFee <= 100, \"Can't have transaction fee > 10%\");\r\n        require(\r\n            _minCollateralizationRatio >= 10,\r\n            \"Can't have minCollateralizationRatio < 1\"\r\n        );\r\n\r\n        liquidationIncentive.value = _liquidationIncentive;\r\n        liquidationFactor.value = _liquidationFactor;\r\n        transactionFee.value = _transactionFee;\r\n        minCollateralizationRatio.value = _minCollateralizationRatio;\r\n\r\n        emit UpdateParameters(\r\n            _liquidationIncentive,\r\n            _liquidationFactor,\r\n            _transactionFee,\r\n            _minCollateralizationRatio,\r\n            owner()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Can only be called by owner. Used to set the name, symbol and decimals of the contract\r\n     * @param _name The name of the contract\r\n     * @param _symbol The symbol of the contract\r\n     */\r\n    function setDetails(string memory _name, string memory _symbol)\r\n        public\r\n        onlyOwner\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = uint8(-1 * oTokenExchangeRate.exponent);\r\n        require(\r\n            decimals >= 0,\r\n            \"1 oToken cannot protect less than the smallest unit of the asset\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Can only be called by owner. Used to take out the protocol fees from the contract.\r\n     * @param _address The address to send the fee to.\r\n     */\r\n    function transferFee(address payable _address) public onlyOwner {\r\n        uint256 fees = totalFee;\r\n        totalFee = 0;\r\n        transferCollateral(_address, fees);\r\n\r\n        emit TransferFee(_address, fees);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a `owner` has already created a Vault\r\n     * @param owner The address of the supposed owner\r\n     * @return true or false\r\n     */\r\n    function hasVault(address payable owner) public view returns (bool) {\r\n        return vaults[owner].owned;\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new empty Vault and sets the owner of the vault to be the msg.sender.\r\n     */\r\n    function openVault() public notExpired returns (bool) {\r\n        require(!hasVault(msg.sender), \"Vault already created\");\r\n\r\n        vaults[msg.sender] = Vault(0, 0, 0, true);\r\n        vaultOwners.push(msg.sender);\r\n\r\n        emit VaultOpened(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice If the collateral type is ETH, anyone can call this function any time before\r\n     * expiry to increase the amount of collateral in a Vault. Will fail if ETH is not the\r\n     * collateral asset.\r\n     * Remember that adding ETH collateral even if no oTokens have been created can put the owner at a\r\n     * risk of losing the collateral if an exercise event happens.\r\n     * Ensure that you issue and immediately sell oTokens to allow the owner to earn premiums.\r\n     * (Either call the createAndSell function in the oToken contract or batch the\r\n     * addERC20Collateral, issueOTokens and sell transactions and ensure they happen atomically to protect\r\n     * the end user).\r\n     * @param vaultOwner the index of the Vault to which collateral will be added.\r\n     */\r\n    function addETHCollateral(address payable vaultOwner)\r\n        public\r\n        payable\r\n        notExpired\r\n        returns (uint256)\r\n    {\r\n        require(isETH(collateral), \"ETH is not the specified collateral type\");\r\n        require(hasVault(vaultOwner), \"Vault does not exist\");\r\n\r\n        emit ETHCollateralAdded(vaultOwner, msg.value, msg.sender);\r\n        return _addCollateral(vaultOwner, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice If the collateral type is any ERC20, anyone can call this function any time before\r\n     * expiry to increase the amount of collateral in a Vault. Can only transfer in the collateral asset.\r\n     * Will fail if ETH is the collateral asset.\r\n     * The user has to allow the contract to handle their ERC20 tokens on his behalf before these\r\n     * functions are called.\r\n     * Remember that adding ERC20 collateral even if no oTokens have been created can put the owner at a\r\n     * risk of losing the collateral. Ensure that you issue and immediately sell the oTokens!\r\n     * (Either call the createAndSell function in the oToken contract or batch the\r\n     * addERC20Collateral, issueOTokens and sell transactions and ensure they happen atomically to protect\r\n     * the end user).\r\n     * @param vaultOwner the index of the Vault to which collateral will be added.\r\n     * @param amt the amount of collateral to be transferred in.\r\n     */\r\n    function addERC20Collateral(address payable vaultOwner, uint256 amt)\r\n        public\r\n        notExpired\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            collateral.transferFrom(msg.sender, address(this), amt),\r\n            \"Could not transfer in collateral tokens\"\r\n        );\r\n        require(hasVault(vaultOwner), \"Vault does not exist\");\r\n\r\n        emit ERC20CollateralAdded(vaultOwner, amt, msg.sender);\r\n        return _addCollateral(vaultOwner, amt);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the amount of underlying to be transferred during an exercise call\r\n     */\r\n    function underlyingRequiredToExercise(uint256 oTokensToExercise)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint64 underlyingPerOTokenExp = uint64(\r\n            oTokenExchangeRate.exponent - underlyingExp\r\n        );\r\n        return oTokensToExercise.mul(10**underlyingPerOTokenExp);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if exercise can be called\r\n     */\r\n    function isExerciseWindow() public view returns (bool) {\r\n        return ((block.timestamp >= expiry.sub(windowSize)) &&\r\n            (block.timestamp < expiry));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if the oToken contract has expired\r\n     */\r\n    function hasExpired() public view returns (bool) {\r\n        return (block.timestamp >= expiry);\r\n    }\r\n\r\n    /**\r\n     * @notice Called by anyone holding the oTokens and underlying during the\r\n     * exercise window i.e. from `expiry - windowSize` time to `expiry` time. The caller\r\n     * transfers in their oTokens and corresponding amount of underlying and gets\r\n     * `strikePrice * oTokens` amount of collateral out. The collateral paid out is taken from\r\n     * the each vault owner starting with the first and iterating until the oTokens to exercise\r\n     * are found.\r\n     * NOTE: This uses a for loop and hence could run out of gas if the array passed in is too big!\r\n     * @param oTokensToExercise the number of oTokens being exercised.\r\n     * @param vaultsToExerciseFrom the array of vaults to exercise from.\r\n     */\r\n    function exercise(\r\n        uint256 oTokensToExercise,\r\n        address payable[] memory vaultsToExerciseFrom\r\n    ) public payable {\r\n        for (uint256 i = 0; i < vaultsToExerciseFrom.length; i++) {\r\n            address payable vaultOwner = vaultsToExerciseFrom[i];\r\n            require(\r\n                hasVault(vaultOwner),\r\n                \"Cannot exercise from a vault that doesn't exist\"\r\n            );\r\n            Vault storage vault = vaults[vaultOwner];\r\n            if (oTokensToExercise == 0) {\r\n                return;\r\n            } else if (vault.oTokensIssued >= oTokensToExercise) {\r\n                _exercise(oTokensToExercise, vaultOwner);\r\n                return;\r\n            } else {\r\n                oTokensToExercise = oTokensToExercise.sub(vault.oTokensIssued);\r\n                _exercise(vault.oTokensIssued, vaultOwner);\r\n            }\r\n        }\r\n        require(\r\n            oTokensToExercise == 0,\r\n            \"Specified vaults have insufficient collateral\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice This function allows the vault owner to remove their share of underlying after an exercise\r\n     */\r\n    function removeUnderlying() public {\r\n        require(hasVault(msg.sender), \"Vault does not exist\");\r\n        Vault storage vault = vaults[msg.sender];\r\n\r\n        require(vault.underlying > 0, \"No underlying balance\");\r\n\r\n        uint256 underlyingToTransfer = vault.underlying;\r\n        vault.underlying = 0;\r\n\r\n        transferUnderlying(msg.sender, underlyingToTransfer);\r\n        emit RemoveUnderlying(underlyingToTransfer, msg.sender);\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice This function is called to issue the option tokens. Remember that issuing oTokens even if they\r\n     * haven't been sold can put the owner at a risk of not making premiums on the oTokens. Ensure that you\r\n     * issue and immidiately sell the oTokens! (Either call the createAndSell function in the oToken contract\r\n     * of batch the issueOTokens transaction with a sell transaction and ensure it happens atomically).\r\n     * @dev The owner of a Vault should only be able to have a max of\r\n     * repo.collateral * collateralToStrike / (minminCollateralizationRatio * strikePrice) tokens issued.\r\n     * @param oTokensToIssue The number of o tokens to issue\r\n     * @param receiver The address to send the oTokens to\r\n     */\r\n    function issueOTokens(uint256 oTokensToIssue, address receiver)\r\n        public\r\n        notExpired\r\n    {\r\n        //check that we're properly collateralized to mint this number, then call _mint(address account, uint256 amount)\r\n        require(hasVault(msg.sender), \"Vault does not exist\");\r\n\r\n        Vault storage vault = vaults[msg.sender];\r\n\r\n        // checks that the vault is sufficiently collateralized\r\n        uint256 newOTokensBalance = vault.oTokensIssued.add(oTokensToIssue);\r\n        require(isSafe(vault.collateral, newOTokensBalance), \"unsafe to mint\");\r\n\r\n        // issue the oTokens\r\n        vault.oTokensIssued = newOTokensBalance;\r\n        _mint(receiver, oTokensToIssue);\r\n\r\n        emit IssuedOTokens(receiver, oTokensToIssue, msg.sender);\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the vault for a given address\r\n     * @param vaultOwner the owner of the Vault to return\r\n     */\r\n    function getVault(address payable vaultOwner)\r\n        public\r\n        view\r\n        returns (uint256, uint256, uint256, bool)\r\n    {\r\n        Vault storage vault = vaults[vaultOwner];\r\n        return (\r\n            vault.collateral,\r\n            vault.oTokensIssued,\r\n            vault.underlying,\r\n            vault.owned\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if the given ERC20 is ETH.\r\n     * @param _ierc20 the ERC20 asset.\r\n     */\r\n    function isETH(IERC20 _ierc20) public pure returns (bool) {\r\n        return _ierc20 == IERC20(0);\r\n    }\r\n\r\n    /**\r\n     * @notice allows the owner to burn their oTokens to increase the collateralization ratio of\r\n     * their vault.\r\n     * @param amtToBurn number of oTokens to burn\r\n     * @dev only want to call this function before expiry. After expiry, no benefit to calling it.\r\n     */\r\n    function burnOTokens(uint256 amtToBurn) public notExpired {\r\n        require(hasVault(msg.sender), \"Vault does not exist\");\r\n\r\n        Vault storage vault = vaults[msg.sender];\r\n\r\n        vault.oTokensIssued = vault.oTokensIssued.sub(amtToBurn);\r\n        _burn(msg.sender, amtToBurn);\r\n\r\n        emit BurnOTokens(msg.sender, amtToBurn);\r\n    }\r\n\r\n    /**\r\n     * @notice allows the owner to remove excess collateral from the vault before expiry. Removing collateral lowers\r\n     * the collateralization ratio of the vault.\r\n     * @param amtToRemove Amount of collateral to remove in 10^-18.\r\n     */\r\n    function removeCollateral(uint256 amtToRemove) public notExpired {\r\n        require(amtToRemove > 0, \"Cannot remove 0 collateral\");\r\n        require(hasVault(msg.sender), \"Vault does not exist\");\r\n\r\n        Vault storage vault = vaults[msg.sender];\r\n        require(\r\n            amtToRemove <= getCollateral(msg.sender),\r\n            \"Can't remove more collateral than owned\"\r\n        );\r\n\r\n        // check that vault will remain safe after removing collateral\r\n        uint256 newCollateralBalance = vault.collateral.sub(amtToRemove);\r\n\r\n        require(\r\n            isSafe(newCollateralBalance, vault.oTokensIssued),\r\n            \"Vault is unsafe\"\r\n        );\r\n\r\n        // remove the collateral\r\n        vault.collateral = newCollateralBalance;\r\n        transferCollateral(msg.sender, amtToRemove);\r\n\r\n        emit RemoveCollateral(amtToRemove, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice after expiry, each vault holder can get back their proportional share of collateral\r\n     * from vaults that they own.\r\n     * @dev The owner gets all of their collateral back if no exercise event took their collateral.\r\n     */\r\n    function redeemVaultBalance() public {\r\n        require(hasExpired(), \"Can't collect collateral until expiry\");\r\n        require(hasVault(msg.sender), \"Vault does not exist\");\r\n\r\n        // pay out owner their share\r\n        Vault storage vault = vaults[msg.sender];\r\n\r\n        // To deal with lower precision\r\n        uint256 collateralToTransfer = vault.collateral;\r\n        uint256 underlyingToTransfer = vault.underlying;\r\n\r\n        vault.collateral = 0;\r\n        vault.oTokensIssued = 0;\r\n        vault.underlying = 0;\r\n\r\n        transferCollateral(msg.sender, collateralToTransfer);\r\n        transferUnderlying(msg.sender, underlyingToTransfer);\r\n\r\n        emit RedeemVaultBalance(\r\n            collateralToTransfer,\r\n            underlyingToTransfer,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * This function returns the maximum amount of collateral liquidatable if the given vault is unsafe\r\n     * @param vaultOwner The index of the vault to be liquidated\r\n     */\r\n    function maxOTokensLiquidatable(address payable vaultOwner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (isUnsafe(vaultOwner)) {\r\n            Vault storage vault = vaults[vaultOwner];\r\n            uint256 maxCollateralLiquidatable = vault\r\n                .collateral\r\n                .mul(liquidationFactor.value)\r\n                .div(10**uint256(-liquidationFactor.exponent));\r\n\r\n            uint256 one = 10**uint256(-liquidationIncentive.exponent);\r\n            Number memory liqIncentive = Number(\r\n                liquidationIncentive.value.add(one),\r\n                liquidationIncentive.exponent\r\n            );\r\n            return calculateOTokens(maxCollateralLiquidatable, liqIncentive);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This function can be called by anyone who notices a vault is undercollateralized.\r\n     * The caller gets a reward for reducing the amount of oTokens in circulation.\r\n     * @dev Liquidator comes with _oTokens. They get _oTokens * strikePrice * (incentive + fee)\r\n     * amount of collateral out. They can liquidate a max of liquidationFactor * vault.collateral out\r\n     * in one function call i.e. partial liquidations.\r\n     * @param vaultOwner The index of the vault to be liquidated\r\n     * @param oTokensToLiquidate The number of oTokens being taken out of circulation\r\n     */\r\n    function liquidate(address payable vaultOwner, uint256 oTokensToLiquidate)\r\n        public\r\n        notExpired\r\n    {\r\n        require(hasVault(vaultOwner), \"Vault does not exist\");\r\n\r\n        Vault storage vault = vaults[vaultOwner];\r\n\r\n        // cannot liquidate a safe vault.\r\n        require(isUnsafe(vaultOwner), \"Vault is safe\");\r\n\r\n        // Owner can't liquidate themselves\r\n        require(msg.sender != vaultOwner, \"Owner can't liquidate themselves\");\r\n\r\n        uint256 amtCollateral = calculateCollateralToPay(\r\n            oTokensToLiquidate,\r\n            Number(1, 0)\r\n        );\r\n        uint256 amtIncentive = calculateCollateralToPay(\r\n            oTokensToLiquidate,\r\n            liquidationIncentive\r\n        );\r\n        uint256 amtCollateralToPay = amtCollateral.add(amtIncentive);\r\n\r\n        // calculate the maximum amount of collateral that can be liquidated\r\n        uint256 maxCollateralLiquidatable = vault.collateral.mul(\r\n            liquidationFactor.value\r\n        );\r\n\r\n        if (liquidationFactor.exponent > 0) {\r\n            maxCollateralLiquidatable = maxCollateralLiquidatable.mul(\r\n                10**uint256(liquidationFactor.exponent)\r\n            );\r\n        } else {\r\n            maxCollateralLiquidatable = maxCollateralLiquidatable.div(\r\n                10**uint256(-1 * liquidationFactor.exponent)\r\n            );\r\n        }\r\n\r\n        require(\r\n            amtCollateralToPay <= maxCollateralLiquidatable,\r\n            \"Can only liquidate liquidation factor at any given time\"\r\n        );\r\n\r\n        // deduct the collateral and oTokensIssued\r\n        vault.collateral = vault.collateral.sub(amtCollateralToPay);\r\n        vault.oTokensIssued = vault.oTokensIssued.sub(oTokensToLiquidate);\r\n\r\n        // transfer the collateral and burn the _oTokens\r\n        _burn(msg.sender, oTokensToLiquidate);\r\n        transferCollateral(msg.sender, amtCollateralToPay);\r\n\r\n        emit Liquidate(amtCollateralToPay, vaultOwner, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice checks if a vault is unsafe. If so, it can be liquidated\r\n     * @param vaultOwner The number of the vault to check\r\n     * @return true or false\r\n     */\r\n    function isUnsafe(address payable vaultOwner) public view returns (bool) {\r\n        bool stillUnsafe = !isSafe(\r\n            getCollateral(vaultOwner),\r\n            getOTokensIssued(vaultOwner)\r\n        );\r\n        return stillUnsafe;\r\n    }\r\n\r\n    /**\r\n     * @notice This function returns if an -30 <= exponent <= 30\r\n     */\r\n    function isWithinExponentRange(int32 val) internal pure returns (bool) {\r\n        return ((val <= 30) && (val >= -30));\r\n    }\r\n\r\n    /**\r\n     * @notice This function calculates and returns the amount of collateral in the vault\r\n    */\r\n    function getCollateral(address payable vaultOwner)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Vault storage vault = vaults[vaultOwner];\r\n        return vault.collateral;\r\n    }\r\n\r\n    /**\r\n     * @notice This function calculates and returns the amount of puts issued by the Vault\r\n    */\r\n    function getOTokensIssued(address payable vaultOwner)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Vault storage vault = vaults[vaultOwner];\r\n        return vault.oTokensIssued;\r\n    }\r\n\r\n    /**\r\n     * @notice Called by anyone holding the oTokens and underlying during the\r\n     * exercise window i.e. from `expiry - windowSize` time to `expiry` time. The caller\r\n     * transfers in their oTokens and corresponding amount of underlying and gets\r\n     * `strikePrice * oTokens` amount of collateral out. The collateral paid out is taken from\r\n     * the specified vault holder. At the end of the expiry window, the vault holder can redeem their balance\r\n     * of collateral. The vault owner can withdraw their underlying at any time.\r\n     * The user has to allow the contract to handle their oTokens and underlying on his behalf before these functions are called.\r\n     * @param oTokensToExercise the number of oTokens being exercised.\r\n     * @param vaultToExerciseFrom the address of the vaultOwner to take collateral from.\r\n     * @dev oTokenExchangeRate is the number of underlying tokens that 1 oToken protects.\r\n     */\r\n    function _exercise(\r\n        uint256 oTokensToExercise,\r\n        address payable vaultToExerciseFrom\r\n    ) internal {\r\n        // 1. before exercise window: revert\r\n        require(\r\n            isExerciseWindow(),\r\n            \"Can't exercise outside of the exercise window\"\r\n        );\r\n\r\n        require(hasVault(vaultToExerciseFrom), \"Vault does not exist\");\r\n\r\n        Vault storage vault = vaults[vaultToExerciseFrom];\r\n        require(oTokensToExercise > 0, \"Can't exercise 0 oTokens\");\r\n        // Check correct amount of oTokens passed in)\r\n        require(\r\n            oTokensToExercise <= vault.oTokensIssued,\r\n            \"Can't exercise more oTokens than the owner has\"\r\n        );\r\n        // Ensure person calling has enough oTokens\r\n        require(\r\n            balanceOf(msg.sender) >= oTokensToExercise,\r\n            \"Not enough oTokens\"\r\n        );\r\n\r\n        // 1. Check sufficient underlying\r\n        // 1.1 update underlying balances\r\n        uint256 amtUnderlyingToPay = underlyingRequiredToExercise(\r\n            oTokensToExercise\r\n        );\r\n        vault.underlying = vault.underlying.add(amtUnderlyingToPay);\r\n\r\n        // 2. Calculate Collateral to pay\r\n        // 2.1 Payout enough collateral to get (strikePrice * oTokens) amount of collateral\r\n        uint256 amtCollateralToPay = calculateCollateralToPay(\r\n            oTokensToExercise,\r\n            Number(1, 0)\r\n        );\r\n\r\n        // 2.2 Take a small fee on every exercise\r\n        uint256 amtFee = calculateCollateralToPay(\r\n            oTokensToExercise,\r\n            transactionFee\r\n        );\r\n        totalFee = totalFee.add(amtFee);\r\n\r\n        uint256 totalCollateralToPay = amtCollateralToPay.add(amtFee);\r\n        require(\r\n            totalCollateralToPay <= vault.collateral,\r\n            \"Vault underwater, can't exercise\"\r\n        );\r\n\r\n        // 3. Update collateral + oToken balances\r\n        vault.collateral = vault.collateral.sub(totalCollateralToPay);\r\n        vault.oTokensIssued = vault.oTokensIssued.sub(oTokensToExercise);\r\n\r\n        // 4. Transfer in underlying, burn oTokens + pay out collateral\r\n        // 4.1 Transfer in underlying\r\n        if (isETH(underlying)) {\r\n            require(msg.value == amtUnderlyingToPay, \"Incorrect msg.value\");\r\n        } else {\r\n            require(\r\n                underlying.transferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    amtUnderlyingToPay\r\n                ),\r\n                \"Could not transfer in tokens\"\r\n            );\r\n        }\r\n        // 4.2 burn oTokens\r\n        _burn(msg.sender, oTokensToExercise);\r\n\r\n        // 4.3 Pay out collateral\r\n        transferCollateral(msg.sender, amtCollateralToPay);\r\n\r\n        emit Exercise(\r\n            amtUnderlyingToPay,\r\n            amtCollateralToPay,\r\n            msg.sender,\r\n            vaultToExerciseFrom\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice adds `_amt` collateral to `vaultOwner` and returns the new balance of the vault\r\n     * @param vaultOwner the index of the vault\r\n     * @param amt the amount of collateral to add\r\n     */\r\n    function _addCollateral(address payable vaultOwner, uint256 amt)\r\n        internal\r\n        notExpired\r\n        returns (uint256)\r\n    {\r\n        Vault storage vault = vaults[vaultOwner];\r\n        vault.collateral = vault.collateral.add(amt);\r\n\r\n        return vault.collateral;\r\n    }\r\n\r\n    /**\r\n     * @notice checks if a hypothetical vault is safe with the given collateralAmt and oTokensIssued\r\n     * @param collateralAmt The amount of collateral the hypothetical vault has\r\n     * @param oTokensIssued The amount of oTokens generated by the hypothetical vault\r\n     * @return true or false\r\n     */\r\n    function isSafe(uint256 collateralAmt, uint256 oTokensIssued)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // get price from Oracle\r\n        uint256 collateralToEthPrice = getPrice(address(collateral));\r\n        uint256 strikeToEthPrice = getPrice(address(strike));\r\n\r\n        // check `oTokensIssued * minCollateralizationRatio * strikePrice <= collAmt * collateralToStrikePrice`\r\n        uint256 leftSideVal = oTokensIssued\r\n            .mul(minCollateralizationRatio.value)\r\n            .mul(strikePrice.value);\r\n        int32 leftSideExp = minCollateralizationRatio.exponent +\r\n            strikePrice.exponent;\r\n\r\n        uint256 rightSideVal = (collateralAmt.mul(collateralToEthPrice)).div(\r\n            strikeToEthPrice\r\n        );\r\n        int32 rightSideExp = collateralExp;\r\n\r\n        uint256 exp = 0;\r\n        bool stillSafe = false;\r\n\r\n        if (rightSideExp < leftSideExp) {\r\n            exp = uint256(leftSideExp - rightSideExp);\r\n            stillSafe = leftSideVal.mul(10**exp) <= rightSideVal;\r\n        } else {\r\n            exp = uint256(rightSideExp - leftSideExp);\r\n            stillSafe = leftSideVal <= rightSideVal.mul(10**exp);\r\n        }\r\n\r\n        return stillSafe;\r\n    }\r\n\r\n    /**\r\n     * This function returns the maximum amount of oTokens that can safely be issued against the specified amount of collateral.\r\n     * @param collateralAmt The amount of collateral against which oTokens will be issued.\r\n     */\r\n    function maxOTokensIssuable(uint256 collateralAmt)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return calculateOTokens(collateralAmt, minCollateralizationRatio);\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice This function is used to calculate the amount of tokens that can be issued.\r\n     * @dev The amount of oTokens is determined by:\r\n     * oTokensIssued  <= collateralAmt * collateralToStrikePrice / (proportion * strikePrice)\r\n     * @param collateralAmt The amount of collateral\r\n     * @param proportion The proportion of the collateral to pay out. If 100% of collateral\r\n     * should be paid out, pass in Number(1, 0). The proportion might be less than 100% if\r\n     * you are calculating fees.\r\n     */\r\n    function calculateOTokens(uint256 collateralAmt, Number memory proportion)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 collateralToEthPrice = getPrice(address(collateral));\r\n        uint256 strikeToEthPrice = getPrice(address(strike));\r\n\r\n        // oTokensIssued  <= collAmt * collateralToStrikePrice / (proportion * strikePrice)\r\n        uint256 denomVal = proportion.value.mul(strikePrice.value);\r\n        int32 denomExp = proportion.exponent + strikePrice.exponent;\r\n\r\n        uint256 numeratorVal = (collateralAmt.mul(collateralToEthPrice)).div(\r\n            strikeToEthPrice\r\n        );\r\n        int32 numeratorExp = collateralExp;\r\n\r\n        uint256 exp = 0;\r\n        uint256 numOptions = 0;\r\n\r\n        if (numeratorExp < denomExp) {\r\n            exp = uint256(denomExp - numeratorExp);\r\n            numOptions = numeratorVal.div(denomVal.mul(10**exp));\r\n        } else {\r\n            exp = uint256(numeratorExp - denomExp);\r\n            numOptions = numeratorVal.mul(10**exp).div(denomVal);\r\n        }\r\n\r\n        return numOptions;\r\n    }\r\n\r\n    /**\r\n     * @notice This function calculates the amount of collateral to be paid out.\r\n     * @dev The amount of collateral to paid out is determined by:\r\n     * (proportion * strikePrice * strikeToCollateralPrice * oTokens) amount of collateral.\r\n     * @param _oTokens The number of oTokens.\r\n     * @param proportion The proportion of the collateral to pay out. If 100% of collateral\r\n     * should be paid out, pass in Number(1, 0). The proportion might be less than 100% if\r\n     * you are calculating fees.\r\n     */\r\n    function calculateCollateralToPay(\r\n        uint256 _oTokens,\r\n        Number memory proportion\r\n    ) internal view returns (uint256) {\r\n        // Get price from oracle\r\n        uint256 collateralToEthPrice = getPrice(address(collateral));\r\n        uint256 strikeToEthPrice = getPrice(address(strike));\r\n\r\n        // calculate how much should be paid out\r\n        uint256 amtCollateralToPayInEthNum = _oTokens\r\n            .mul(strikePrice.value)\r\n            .mul(proportion.value)\r\n            .mul(strikeToEthPrice);\r\n        int32 amtCollateralToPayExp = strikePrice.exponent +\r\n            proportion.exponent -\r\n            collateralExp;\r\n        uint256 amtCollateralToPay = 0;\r\n        if (amtCollateralToPayExp > 0) {\r\n            uint32 exp = uint32(amtCollateralToPayExp);\r\n            amtCollateralToPay = amtCollateralToPayInEthNum.mul(10**exp).div(\r\n                collateralToEthPrice\r\n            );\r\n        } else {\r\n            uint32 exp = uint32(-1 * amtCollateralToPayExp);\r\n            amtCollateralToPay = (amtCollateralToPayInEthNum.div(10**exp)).div(\r\n                collateralToEthPrice\r\n            );\r\n        }\r\n\r\n        return amtCollateralToPay;\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice This function transfers `amt` collateral to `_addr`\r\n     * @param _addr The address to send the collateral to\r\n     * @param _amt The amount of the collateral to pay out.\r\n     */\r\n    function transferCollateral(address payable _addr, uint256 _amt) internal {\r\n        if (isETH(collateral)) {\r\n            _addr.transfer(_amt);\r\n        } else {\r\n            collateral.transfer(_addr, _amt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This function transfers `amt` underlying to `_addr`\r\n     * @param _addr The address to send the underlying to\r\n     * @param _amt The amount of the underlying to pay out.\r\n     */\r\n    function transferUnderlying(address payable _addr, uint256 _amt) internal {\r\n        if (isETH(underlying)) {\r\n            _addr.transfer(_amt);\r\n        } else {\r\n            underlying.transfer(_addr, _amt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This function gets the price ETH (wei) to asset price.\r\n     * @param asset The address of the asset to get the price of\r\n     */\r\n    function getPrice(address asset) internal view returns (uint256) {\r\n        if (address(collateral) == address(strike)) {\r\n            return 1;\r\n        } else if (asset == address(0)) {\r\n            return (10**18);\r\n        } else {\r\n            return COMPOUND_ORACLE.getPrice(asset);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/oToken.sol\r\n\r\npragma solidity 0.5.10;\r\n\r\n\r\n/**\r\n * @title Opyn's Options Contract\r\n * @author Opyn\r\n */\r\n\r\ncontract oToken is OptionsContract {\r\n    /**\r\n    * @param _collateral The collateral asset\r\n    * @param _collExp The precision of the collateral (-18 if ETH)\r\n    * @param _underlying The asset that is being protected\r\n    * @param _underlyingExp The precision of the underlying asset\r\n    * @param _oTokenExchangeExp The precision of the `amount of underlying` that 1 oToken protects\r\n    * @param _strikePrice The amount of strike asset that will be paid out\r\n    * @param _strikeExp The precision of the strike asset (-18 if ETH)\r\n    * @param _strike The asset in which the insurance is calculated\r\n    * @param _expiry The time at which the insurance expires\r\n    * @param _optionsExchange The contract which interfaces with the exchange + oracle\r\n    * @param _oracleAddress The address of the oracle\r\n    * @param _windowSize UNIX time. Exercise window is from `expiry - _windowSize` to `expiry`.\r\n    */\r\n    constructor(\r\n        IERC20 _collateral,\r\n        int32 _collExp,\r\n        IERC20 _underlying,\r\n        int32 _underlyingExp,\r\n        int32 _oTokenExchangeExp,\r\n        uint256 _strikePrice,\r\n        int32 _strikeExp,\r\n        IERC20 _strike,\r\n        uint256 _expiry,\r\n        OptionsExchange _optionsExchange,\r\n        address _oracleAddress,\r\n        uint256 _windowSize\r\n    )\r\n        public\r\n        OptionsContract(\r\n            _collateral,\r\n            _collExp,\r\n            _underlying,\r\n            _underlyingExp,\r\n            _oTokenExchangeExp,\r\n            _strikePrice,\r\n            _strikeExp,\r\n            _strike,\r\n            _expiry,\r\n            _optionsExchange,\r\n            _oracleAddress,\r\n            _windowSize\r\n        )\r\n    {}\r\n\r\n    /**\r\n     * @notice opens a Vault, adds ETH collateral, and mints new oTokens in one step\r\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\r\n     * if an exercise event happens.\r\n     * The sell function provides the owner a chance to earn premiums.\r\n     * Ensure that you create and immediately sell oTokens atmoically.\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function createETHCollateralOption(uint256 amtToCreate, address receiver)\r\n        external\r\n        payable\r\n    {\r\n        openVault();\r\n        addETHCollateralOption(amtToCreate, receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice adds ETH collateral, and mints new oTokens in one step to an existing Vault\r\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\r\n     * if an exercise event happens.\r\n     * The sell function provides the owner a chance to earn premiums.\r\n     * Ensure that you create and immediately sell oTokens atmoically.\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function addETHCollateralOption(uint256 amtToCreate, address receiver)\r\n        public\r\n        payable\r\n    {\r\n        addETHCollateral(msg.sender);\r\n        issueOTokens(amtToCreate, receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice opens a Vault, adds ETH collateral, mints new oTokens and sell in one step\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param receiver address to receive the premiums\r\n     */\r\n    function createAndSellETHCollateralOption(\r\n        uint256 amtToCreate,\r\n        address payable receiver\r\n    ) external payable {\r\n        openVault();\r\n        addETHCollateralOption(amtToCreate, address(this));\r\n        this.approve(address(optionsExchange), amtToCreate);\r\n        optionsExchange.sellOTokens(\r\n            receiver,\r\n            address(this),\r\n            address(0),\r\n            amtToCreate\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice adds ETH collateral to an existing Vault, and mints new oTokens and sells the oTokens in one step\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function addAndSellETHCollateralOption(\r\n        uint256 amtToCreate,\r\n        address payable receiver\r\n    ) public payable {\r\n        addETHCollateral(msg.sender);\r\n        issueOTokens(amtToCreate, address(this));\r\n        this.approve(address(optionsExchange), amtToCreate);\r\n        optionsExchange.sellOTokens(\r\n            receiver,\r\n            address(this),\r\n            address(0),\r\n            amtToCreate\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice opens a Vault, adds ERC20 collateral, and mints new oTokens in one step\r\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\r\n     * if an exercise event happens.\r\n     * The sell function provides the owner a chance to earn premiums.\r\n     * Ensure that you create and immediately sell oTokens atmoically.\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param amtCollateral amount of collateral added\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function createERC20CollateralOption(\r\n        uint256 amtToCreate,\r\n        uint256 amtCollateral,\r\n        address receiver\r\n    ) external {\r\n        openVault();\r\n        addERC20CollateralOption(amtToCreate, amtCollateral, receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice adds ERC20 collateral, and mints new oTokens in one step\r\n     * Remember that creating oTokens can put the owner at a risk of losing the collateral\r\n     * if an exercise event happens.\r\n     * The sell function provides the owner a chance to earn premiums.\r\n     * Ensure that you create and immediately sell oTokens atmoically.\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param amtCollateral amount of collateral added\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function addERC20CollateralOption(\r\n        uint256 amtToCreate,\r\n        uint256 amtCollateral,\r\n        address receiver\r\n    ) public {\r\n        addERC20Collateral(msg.sender, amtCollateral);\r\n        issueOTokens(amtToCreate, receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice opens a Vault, adds ERC20 collateral, mints new oTokens and sells the oTokens in one step\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param amtCollateral amount of collateral added\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function createAndSellERC20CollateralOption(\r\n        uint256 amtToCreate,\r\n        uint256 amtCollateral,\r\n        address payable receiver\r\n    ) external {\r\n        openVault();\r\n        addERC20CollateralOption(amtToCreate, amtCollateral, address(this));\r\n        this.approve(address(optionsExchange), amtToCreate);\r\n        optionsExchange.sellOTokens(\r\n            receiver,\r\n            address(this),\r\n            address(0),\r\n            amtToCreate\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice adds ERC20 collateral, mints new oTokens and sells the oTokens in one step\r\n     * @param amtToCreate number of oTokens to create\r\n     * @param amtCollateral amount of collateral added\r\n     * @param receiver address to send the Options to\r\n     */\r\n    function addAndSellERC20CollateralOption(\r\n        uint256 amtToCreate,\r\n        uint256 amtCollateral,\r\n        address payable receiver\r\n    ) public {\r\n        addERC20Collateral(msg.sender, amtCollateral);\r\n        issueOTokens(amtToCreate, address(this));\r\n        this.approve(address(optionsExchange), amtToCreate);\r\n        optionsExchange.sellOTokens(\r\n            receiver,\r\n            address(this),\r\n            address(0),\r\n            amtToCreate\r\n        );\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"vaultOwner\",\"type\":\"address\"},{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"addERC20Collateral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVaultOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"hasVault\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isExerciseWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"vaultOwner\",\"type\":\"address\"}],\"name\":\"getVault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oTokensToIssue\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"issueOTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtToCreate\",\"type\":\"uint256\"},{\"name\":\"amtCollateral\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"addAndSellERC20CollateralOption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtToRemove\",\"type\":\"uint256\"}],\"name\":\"removeCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationFactor\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"exponent\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtToCreate\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"createAndSellETHCollateralOption\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"optionsExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtToCreate\",\"type\":\"uint256\"},{\"name\":\"amtCollateral\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"createERC20CollateralOption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oTokensToExercise\",\"type\":\"uint256\"},{\"name\":\"vaultsToExerciseFrom\",\"type\":\"address[]\"}],\"name\":\"exercise\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtToCreate\",\"type\":\"uint256\"},{\"name\":\"amtCollateral\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"addERC20CollateralOption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"collateralAmt\",\"type\":\"uint256\"}],\"name\":\"maxOTokensIssuable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"oTokensToExercise\",\"type\":\"uint256\"}],\"name\":\"underlyingRequiredToExercise\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"openVault\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMPOUND_ORACLE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationIncentive\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"exponent\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vaultOwner\",\"type\":\"address\"}],\"name\":\"addETHCollateral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionFee\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"exponent\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strike\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlyingExp\",\"outputs\":[{\"name\":\"\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralExp\",\"outputs\":[{\"name\":\"\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oTokenExchangeRate\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"exponent\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemVaultBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setDetails\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtToCreate\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"addETHCollateralOption\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCollateralizationRatio\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"exponent\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vaultOwner\",\"type\":\"address\"},{\"name\":\"oTokensToLiquidate\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"strikePrice\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"exponent\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtToCreate\",\"type\":\"uint256\"},{\"name\":\"amtCollateral\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"createAndSellERC20CollateralOption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"vaultOwner\",\"type\":\"address\"}],\"name\":\"isUnsafe\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtToCreate\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"addAndSellETHCollateralOption\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"vaultOwner\",\"type\":\"address\"}],\"name\":\"maxOTokensLiquidatable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expiry\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"transferFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtToBurn\",\"type\":\"uint256\"}],\"name\":\"burnOTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtToCreate\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"createETHCollateralOption\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_liquidationIncentive\",\"type\":\"uint256\"},{\"name\":\"_liquidationFactor\",\"type\":\"uint256\"},{\"name\":\"_transactionFee\",\"type\":\"uint256\"},{\"name\":\"_minCollateralizationRatio\",\"type\":\"uint256\"}],\"name\":\"updateParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ierc20\",\"type\":\"address\"}],\"name\":\"isETH\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeUnderlying\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_collateral\",\"type\":\"address\"},{\"name\":\"_collExp\",\"type\":\"int32\"},{\"name\":\"_underlying\",\"type\":\"address\"},{\"name\":\"_underlyingExp\",\"type\":\"int32\"},{\"name\":\"_oTokenExchangeExp\",\"type\":\"int32\"},{\"name\":\"_strikePrice\",\"type\":\"uint256\"},{\"name\":\"_strikeExp\",\"type\":\"int32\"},{\"name\":\"_strike\",\"type\":\"address\"},{\"name\":\"_expiry\",\"type\":\"uint256\"},{\"name\":\"_optionsExchange\",\"type\":\"address\"},{\"name\":\"_oracleAddress\",\"type\":\"address\"},{\"name\":\"_windowSize\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"vaultOwner\",\"type\":\"address\"}],\"name\":\"VaultOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"vaultOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payer\",\"type\":\"address\"}],\"name\":\"ETHCollateralAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"vaultOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payer\",\"type\":\"address\"}],\"name\":\"ERC20CollateralAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"issuedTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oTokensIssued\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"vaultOwner\",\"type\":\"address\"}],\"name\":\"IssuedOTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amtCollateralToPay\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"vaultOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"Liquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amtUnderlyingToPay\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtCollateralToPay\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"exerciser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"vaultExercisedFrom\",\"type\":\"address\"}],\"name\":\"Exercise\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amtCollateralRedeemed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtUnderlyingRedeemed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"vaultOwner\",\"type\":\"address\"}],\"name\":\"RedeemVaultBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"vaultOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oTokensBurned\",\"type\":\"uint256\"}],\"name\":\"BurnOTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amtRemoved\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"vaultOwner\",\"type\":\"address\"}],\"name\":\"RemoveCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"liquidationIncentive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"liquidationFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"transactionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minCollateralizationRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"UpdateParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"TransferFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amountUnderlying\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"vaultOwner\",\"type\":\"address\"}],\"name\":\"RemoveUnderlying\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "oToken", "CompilerVersion": "v0.5.10+commit.5a6ea5b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeefffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000000000000000000000000000000000000000000000000000000000001fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000000005e81368000000000000000000000000039246c4f3f6592c974ebc44f80ba6dc69b817c710000000000000000000000007054e08461e3ecb7718b63540addb3c3a1746415000000000000000000000000000000000000000000000000000000005e813680", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://24408987c6dcfcda4c0e73ff0354366a3d057faa494c86e0ef89208047b75fda"}