{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/facets/DiamondLoupeFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\\r\\n// The EIP-2535 Diamond standard requires these functions.\\r\\n\\r\\nimport { LibDiamond } from  \\\"../libraries/LibDiamond.sol\\\";\\r\\nimport { IDiamondLoupe } from \\\"../interfaces/IDiamondLoupe.sol\\\";\\r\\nimport { IERC165 } from \\\"../interfaces/IERC165.sol\\\";\\r\\n\\r\\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\\r\\n    // Diamond Loupe Functions\\r\\n    ////////////////////////////////////////////////////////////////////\\r\\n    /// These functions are expected to be called frequently by tools.\\r\\n    //\\r\\n    // struct Facet {\\r\\n    //     address facetAddress;\\r\\n    //     bytes4[] functionSelectors;\\r\\n    // }\\r\\n    /// @notice Gets all facets and their selectors.\\r\\n    /// @return facets_ Facet\\r\\n    function facets() external override view returns (Facet[] memory facets_) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        uint256 selectorCount = ds.selectors.length;\\r\\n        // create an array set to the maximum size possible\\r\\n        facets_ = new Facet[](selectorCount);\\r\\n        // create an array for counting the number of selectors for each facet\\r\\n        uint16[] memory numFacetSelectors = new uint16[](selectorCount);\\r\\n        // total number of facets\\r\\n        uint256 numFacets;\\r\\n        // loop through function selectors\\r\\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\\r\\n            bytes4 selector = ds.selectors[selectorIndex];\\r\\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            bool continueLoop = false;\\r\\n            // find the functionSelectors array for selector and add selector to it\\r\\n            for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\r\\n                if (facets_[facetIndex].facetAddress == facetAddress_) {\\r\\n                    facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;                                   \\r\\n                    numFacetSelectors[facetIndex]++;\\r\\n                    continueLoop = true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            // if functionSelectors array exists for selector then continue loop\\r\\n            if (continueLoop) {\\r\\n                continueLoop = false;\\r\\n                continue;\\r\\n            }\\r\\n            // create a new functionSelectors array for selector\\r\\n            facets_[numFacets].facetAddress = facetAddress_;\\r\\n            facets_[numFacets].functionSelectors = new bytes4[](selectorCount);\\r\\n            facets_[numFacets].functionSelectors[0] = selector;\\r\\n            numFacetSelectors[numFacets] = 1;\\r\\n            numFacets++;\\r\\n        }\\r\\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\r\\n            uint256 numSelectors = numFacetSelectors[facetIndex];\\r\\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\\r\\n            // setting the number of selectors\\r\\n            assembly {\\r\\n                mstore(selectors, numSelectors)\\r\\n            }\\r\\n        }\\r\\n        // setting the number of facets\\r\\n        assembly {\\r\\n            mstore(facets_, numFacets)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Gets all the function selectors supported by a specific facet.\\r\\n    /// @param _facet The facet address.\\r\\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\\r\\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        uint256 selectorCount = ds.selectors.length;\\r\\n        uint256 numSelectors;\\r\\n        _facetFunctionSelectors = new bytes4[](selectorCount);\\r\\n        // loop through function selectors\\r\\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\\r\\n            bytes4 selector = ds.selectors[selectorIndex];\\r\\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            if (_facet == facetAddress_) {\\r\\n                _facetFunctionSelectors[numSelectors] = selector;\\r\\n                numSelectors++;\\r\\n            }\\r\\n        }\\r\\n        // Set the number of selectors in the array\\r\\n        assembly {\\r\\n            mstore(_facetFunctionSelectors, numSelectors)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Get all the facet addresses used by a diamond.\\r\\n    /// @return facetAddresses_\\r\\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        uint256 selectorCount = ds.selectors.length;\\r\\n        // create an array set to the maximum size possible\\r\\n        facetAddresses_ = new address[](selectorCount);\\r\\n        uint256 numFacets;\\r\\n        // loop through function selectors\\r\\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\\r\\n            bytes4 selector = ds.selectors[selectorIndex];\\r\\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            bool continueLoop = false;\\r\\n            // see if we have collected the address already and break out of loop if we have\\r\\n            for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\r\\n                if (facetAddress_ == facetAddresses_[facetIndex]) {\\r\\n                    continueLoop = true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            // continue loop if we already have the address\\r\\n            if (continueLoop) {\\r\\n                continueLoop = false;\\r\\n                continue;\\r\\n            }\\r\\n            // include address\\r\\n            facetAddresses_[numFacets] = facetAddress_;\\r\\n            numFacets++;\\r\\n        }\\r\\n        // Set the number of facet addresses in the array\\r\\n        assembly {\\r\\n            mstore(facetAddresses_, numFacets)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Gets the facet address that supports the given selector.\\r\\n    /// @dev If facet is not found return address(0).\\r\\n    /// @param _functionSelector The function selector.\\r\\n    /// @return facetAddress_ The facet address.\\r\\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        facetAddress_ = ds.facetAddressAndSelectorPosition[_functionSelector].facetAddress;\\r\\n    }\\r\\n\\r\\n    // This implements ERC-165.\\r\\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        return ds.supportedInterfaces[_interfaceId];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\ninterface IDiamond {\\r\\n    enum FacetCutAction {Add, Replace, Remove}\\r\\n    // Add=0, Replace=1, Remove=2\\r\\n\\r\\n    struct FacetCut {\\r\\n        address facetAddress;\\r\\n        FacetCutAction action;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\nimport { IDiamond } from \\\"./IDiamond.sol\\\";\\r\\n\\r\\ninterface IDiamondCut is IDiamond {    \\r\\n\\r\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\r\\n    ///         a function with delegatecall\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    ///                  _calldata is executed with delegatecall on _init\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;    \\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\n// A loupe is a small magnifying glass used to look at diamonds.\\r\\n// These functions look at diamonds\\r\\ninterface IDiamondLoupe {\\r\\n    /// These functions are expected to be called frequently\\r\\n    /// by tools.\\r\\n\\r\\n    struct Facet {\\r\\n        address facetAddress;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\r\\n    /// @return facets_ Facet\\r\\n    function facets() external view returns (Facet[] memory facets_);\\r\\n\\r\\n    /// @notice Gets all the function selectors supported by a specific facet.\\r\\n    /// @param _facet The facet address.\\r\\n    /// @return facetFunctionSelectors_\\r\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\r\\n\\r\\n    /// @notice Get all the facet addresses used by a diamond.\\r\\n    /// @return facetAddresses_\\r\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\r\\n\\r\\n    /// @notice Gets the facet that supports the given selector.\\r\\n    /// @dev If facet is not found return address(0).\\r\\n    /// @param _functionSelector The function selector.\\r\\n    /// @return facetAddress_ The facet address.\\r\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC165 {\\r\\n    /// @notice Query if a contract implements an interface\\r\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\r\\n    /// @dev Interface identification is specified in ERC-165. This function\\r\\n    ///  uses less than 30,000 gas.\\r\\n    /// @return `true` if the contract implements `interfaceID` and\\r\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\nimport { IDiamond } from \\\"../interfaces/IDiamond.sol\\\";\\r\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\r\\n\\r\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\r\\n// The loupe functions are required by the EIP2535 Diamonds standard\\r\\n\\r\\nerror NoSelectorsGivenToAdd();\\r\\nerror NotContractOwner(address _user, address _contractOwner);\\r\\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\\r\\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\\r\\nerror NoBytecodeAtAddress(address _contractAddress, string _message);\\r\\nerror IncorrectFacetCutAction(uint8 _action);\\r\\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\\r\\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\\r\\nerror CannotReplaceImmutableFunction(bytes4 _selector);\\r\\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\\r\\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\\r\\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\\r\\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\\r\\nerror CannotRemoveImmutableFunction(bytes4 _selector);\\r\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\r\\n\\r\\nlibrary LibDiamond {\\r\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\r\\n\\r\\n    struct FacetAddressAndSelectorPosition {\\r\\n        address facetAddress;\\r\\n        uint16 selectorPosition;\\r\\n    }\\r\\n\\r\\n    struct DiamondStorage {\\r\\n        // function selector => facet address and selector position in selectors array\\r\\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\\r\\n        bytes4[] selectors;\\r\\n        mapping(bytes4 => bool) supportedInterfaces;\\r\\n        // owner of the contract\\r\\n        address contractOwner;\\r\\n    }\\r\\n\\r\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\r\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    function setContractOwner(address _newOwner) internal {\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        address previousOwner = ds.contractOwner;\\r\\n        ds.contractOwner = _newOwner;\\r\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\r\\n    }\\r\\n\\r\\n    function contractOwner() internal view returns (address contractOwner_) {\\r\\n        contractOwner_ = diamondStorage().contractOwner;\\r\\n    }\\r\\n\\r\\n    function enforceIsContractOwner() internal view {\\r\\n        if(msg.sender != diamondStorage().contractOwner) {\\r\\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\\r\\n        }        \\r\\n    }\\r\\n\\r\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n\\r\\n    // Internal function version of diamondCut\\r\\n    function diamondCut(\\r\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\r\\n        address _init,\\r\\n        bytes memory _calldata\\r\\n    ) internal {\\r\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\r\\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\\r\\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\\r\\n            if(functionSelectors.length == 0) {\\r\\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\\r\\n            }\\r\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\r\\n            if (action == IDiamond.FacetCutAction.Add) {\\r\\n                addFunctions(facetAddress, functionSelectors);\\r\\n            } else if (action == IDiamond.FacetCutAction.Replace) {\\r\\n                replaceFunctions(facetAddress, functionSelectors);\\r\\n            } else if (action == IDiamond.FacetCutAction.Remove) {\\r\\n                removeFunctions(facetAddress, functionSelectors);\\r\\n            } else {\\r\\n                revert IncorrectFacetCutAction(uint8(action));\\r\\n            }\\r\\n        }\\r\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\r\\n        initializeDiamondCut(_init, _calldata);\\r\\n    }\\r\\n\\r\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\r\\n        if(_facetAddress == address(0)) {\\r\\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\\r\\n        }\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        uint16 selectorCount = uint16(ds.selectors.length);                \\r\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            if(oldFacetAddress != address(0)) {\\r\\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\\r\\n            }            \\r\\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress, selectorCount);\\r\\n            ds.selectors.push(selector);\\r\\n            selectorCount++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        if(_facetAddress == address(0)) {\\r\\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\\r\\n        }\\r\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            // can't replace immutable functions -- functions defined directly in the diamond in this case\\r\\n            if(oldFacetAddress == address(this)) {\\r\\n                revert CannotReplaceImmutableFunction(selector);\\r\\n            }\\r\\n            if(oldFacetAddress == _facetAddress) {\\r\\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\\r\\n            }\\r\\n            if(oldFacetAddress == address(0)) {\\r\\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\\r\\n            }\\r\\n            // replace old facet address\\r\\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {        \\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        uint256 selectorCount = ds.selectors.length;\\r\\n        if(_facetAddress != address(0)) {\\r\\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\\r\\n        }        \\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds.facetAddressAndSelectorPosition[selector];\\r\\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\\r\\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\\r\\n            }\\r\\n            \\r\\n            \\r\\n            // can't remove immutable functions -- functions defined directly in the diamond\\r\\n            if(oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\\r\\n                revert CannotRemoveImmutableFunction(selector);\\r\\n            }\\r\\n            // replace selector with last selector\\r\\n            selectorCount--;\\r\\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\\r\\n                bytes4 lastSelector = ds.selectors[selectorCount];\\r\\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\\r\\n                ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition;\\r\\n            }\\r\\n            // delete last selector\\r\\n            ds.selectors.pop();\\r\\n            delete ds.facetAddressAndSelectorPosition[selector];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\r\\n        if (_init == address(0)) {\\r\\n            return;\\r\\n        }\\r\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");        \\r\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\r\\n        if (!success) {\\r\\n            if (error.length > 0) {\\r\\n                // bubble up error\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(error)\\r\\n                    revert(add(32, error), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert InitializationFunctionReverted(_init, _calldata);\\r\\n            }\\r\\n        }        \\r\\n    }\\r\\n\\r\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\r\\n        uint256 contractSize;\\r\\n        assembly {\\r\\n            contractSize := extcodesize(_contract)\\r\\n        }\\r\\n        if(contractSize == 0) {\\r\\n            revert NoBytecodeAtAddress(_contract, _errorMessage);\\r\\n        }        \\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facetAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"facetAddresses_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"_facetFunctionSelectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"facets_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DiamondLoupeFacet", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}