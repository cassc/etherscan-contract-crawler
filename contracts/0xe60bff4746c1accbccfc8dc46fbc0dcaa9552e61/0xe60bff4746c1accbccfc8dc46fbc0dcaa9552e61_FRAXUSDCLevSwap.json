{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.0;\r\npragma abicoder v2;\r\n\r\n\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Detailed is IERC20 {\r\n  function name() external view returns (string memory);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function decimals() external view returns (uint8);\r\n}\r\n\r\nlibrary Address {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * It is unsafe to assume that an address for which this function returns\r\n   * false is an externally-owned account (EOA) and not a contract.\r\n   *\r\n   * Among others, `isContract` will return false for the following\r\n   * types of addresses:\r\n   *\r\n   *  - an externally-owned account\r\n   *  - a contract in construction\r\n   *  - an address where a contract will be created\r\n   *  - an address where a contract lived, but was destroyed\r\n   * ====\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256('')`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      codehash := extcodehash(account)\r\n    }\r\n    return (codehash != accountHash && codehash != 0x0);\r\n  }\r\n\r\n  /**\r\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n   * `recipient`, forwarding all available gas and reverting on errors.\r\n   *\r\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n   * imposed by `transfer`, making them unable to receive funds via\r\n   * `transfer`. {sendValue} removes this limitation.\r\n   *\r\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n   *\r\n   * IMPORTANT: because control is transferred to `recipient`, care must be\r\n   * taken to not create reentrancy vulnerabilities. Consider using\r\n   * {ReentrancyGuard} or the\r\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n   */\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n    (bool success, ) = recipient.call{value: amount}('');\r\n    require(success, 'Address: unable to send value, recipient may have reverted');\r\n  }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n  }\r\n\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    require(\r\n      (value == 0) || (token.allowance(address(this), spender) == 0),\r\n      'SafeERC20: approve from non-zero to non-zero allowance'\r\n    );\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n  }\r\n\r\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = address(token).call(data);\r\n    require(success, 'SafeERC20: low-level call failed');\r\n\r\n    if (returndata.length != 0) {\r\n      // Return data is optional\r\n      // solhint-disable-next-line max-line-length\r\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\r\n    }\r\n  }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n  // Booleans are more expensive than uint256 or any type that takes up a full\r\n  // word because each write operation emits an extra SLOAD to first read the\r\n  // slot's contents, replace the bits taken up by the boolean, and then write\r\n  // back. This is the compiler's defense against contract upgrades and\r\n  // pointer aliasing, and it cannot be disabled.\r\n\r\n  // The values being non-zero value makes deployment a bit more expensive,\r\n  // but in exchange the refund on every call to nonReentrant will be lower in\r\n  // amount. Since refunds are capped to a percentage of the total\r\n  // transaction's gas, it is best to keep them low in cases like this one, to\r\n  // increase the likelihood of the full refund coming into effect.\r\n  uint256 private constant _NOT_ENTERED = 1;\r\n  uint256 private constant _ENTERED = 2;\r\n\r\n  uint256 private _status;\r\n\r\n  constructor() {\r\n    _status = _NOT_ENTERED;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * Calling a `nonReentrant` function from another `nonReentrant`\r\n   * function is not supported. It is possible to prevent this from happening\r\n   * by making the `nonReentrant` function external, and make it call a\r\n   * `private` function that does the actual work.\r\n   */\r\n  modifier nonReentrant() {\r\n    // On the first call to nonReentrant, _notEntered will be true\r\n    require(_status != _ENTERED, 'ReentrancyGuard: reentrant call');\r\n\r\n    // Any calls to nonReentrant after this point will fail\r\n    _status = _ENTERED;\r\n\r\n    _;\r\n\r\n    // By storing the original value once again, a refund is triggered (see\r\n    // https://eips.ethereum.org/EIPS/eip-2200)\r\n    _status = _NOT_ENTERED;\r\n  }\r\n}\r\n\r\ninterface IPriceOracleGetter {\r\n  /**\r\n   * @dev returns the asset price in ETH\r\n   * @param asset the address of the asset\r\n   * @return the ETH price of the asset\r\n   **/\r\n  function getAssetPrice(address asset) external view returns (uint256);\r\n}\r\n\r\ninterface ILendingPoolAddressesProvider {\r\n  event MarketIdSet(string newMarketId);\r\n  event LendingPoolUpdated(address indexed newAddress);\r\n  event IncentiveControllerUpdated(address indexed newAddress);\r\n  event IncentiveTokenUpdated(address indexed newAddress);\r\n  event ConfigurationAdminUpdated(address indexed newAddress);\r\n  event EmergencyAdminUpdated(address indexed newAddress);\r\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n  event PriceOracleUpdated(address indexed newAddress);\r\n  event LendingRateOracleUpdated(address indexed newAddress);\r\n  event ProxyCreated(bytes32 id, address indexed newAddress);\r\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n  function getMarketId() external view returns (string memory);\r\n\r\n  function setMarketId(string calldata marketId) external payable;\r\n\r\n  function setAddress(bytes32 id, address newAddress) external payable;\r\n\r\n  function setAddressAsProxy(bytes32 id, address impl) external payable;\r\n\r\n  function getAddress(bytes32 id) external view returns (address);\r\n\r\n  function getLendingPool() external view returns (address);\r\n\r\n  function setLendingPoolImpl(address pool) external payable;\r\n\r\n  function getIncentiveController() external view returns (address);\r\n\r\n  function setIncentiveControllerImpl(address incentiveController) external payable;\r\n\r\n  function getIncentiveToken() external view returns (address);\r\n\r\n  function setIncentiveTokenImpl(address incentiveToken) external payable;\r\n\r\n  function getLendingPoolConfigurator() external view returns (address);\r\n\r\n  function setLendingPoolConfiguratorImpl(address configurator) external payable;\r\n\r\n  function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n  function setLendingPoolCollateralManager(address manager) external payable;\r\n\r\n  function getPoolAdmin() external view returns (address);\r\n\r\n  function setPoolAdmin(address admin) external payable;\r\n\r\n  function getEmergencyAdmin() external view returns (address);\r\n\r\n  function setEmergencyAdmin(address admin) external payable;\r\n\r\n  function getPriceOracle() external view returns (address);\r\n\r\n  function setPriceOracle(address priceOracle) external payable;\r\n\r\n  function getLendingRateOracle() external view returns (address);\r\n\r\n  function setLendingRateOracle(address lendingRateOracle) external payable;\r\n}\r\n\r\nlibrary DataTypes {\r\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n  struct ReserveData {\r\n    //stores the reserve configuration\r\n    ReserveConfigurationMap configuration;\r\n    //the liquidity index. Expressed in ray\r\n    uint128 liquidityIndex;\r\n    //variable borrow index. Expressed in ray\r\n    uint128 variableBorrowIndex;\r\n    //the current supply rate. Expressed in ray\r\n    uint128 currentLiquidityRate;\r\n    //the current variable borrow rate. Expressed in ray\r\n    uint128 currentVariableBorrowRate;\r\n    //the current stable borrow rate. Expressed in ray\r\n    uint128 currentStableBorrowRate;\r\n    uint40 lastUpdateTimestamp;\r\n    //tokens addresses\r\n    address aTokenAddress;\r\n    address stableDebtTokenAddress;\r\n    address variableDebtTokenAddress;\r\n    //address of the interest rate strategy\r\n    address interestRateStrategyAddress;\r\n    //address of the yield contract\r\n    address yieldAddress;\r\n    //the id of the reserve. Represents the position in the list of the active reserves\r\n    uint8 id;\r\n  }\r\n\r\n  struct ReserveConfigurationMap {\r\n    //bit 0-15: LTV\r\n    //bit 16-31: Liq. threshold\r\n    //bit 32-47: Liq. bonus\r\n    //bit 48-55: Decimals\r\n    //bit 56: Reserve is active\r\n    //bit 57: reserve is frozen\r\n    //bit 58: borrowing is enabled\r\n    //bit 59: stable rate borrowing enabled\r\n    //bit 60-63: reserved\r\n    //bit 64-79: reserve factor\r\n    uint256 data;\r\n  }\r\n\r\n  struct UserConfigurationMap {\r\n    uint256 data;\r\n  }\r\n\r\n  enum InterestRateMode {\r\n    NONE,\r\n    STABLE,\r\n    VARIABLE\r\n  }\r\n}\r\n\r\ninterface ILendingPool {\r\n  /**\r\n   * @dev Emitted on deposit()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address initiating the deposit\r\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\r\n   * @param amount The amount deposited\r\n   * @param referral The referral code used\r\n   **/\r\n  event Deposit(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint16 indexed referral\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on withdraw()\r\n   * @param reserve The address of the underlyng asset being withdrawn\r\n   * @param user The address initiating the withdrawal, owner of aTokens\r\n   * @param to Address that will receive the underlying\r\n   * @param amount The amount to be withdrawn\r\n   **/\r\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\r\n\r\n  /**\r\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n   * @param reserve The address of the underlying asset being borrowed\r\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n   * initiator of the transaction on flashLoan()\r\n   * @param onBehalfOf The address that will be getting the debt\r\n   * @param amount The amount borrowed out\r\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\r\n   * @param borrowRate The numeric rate at which the user has borrowed\r\n   * @param referral The referral code used\r\n   **/\r\n  event Borrow(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint256 borrowRateMode,\r\n    uint256 borrowRate,\r\n    uint16 indexed referral\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on repay()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The beneficiary of the repayment, getting his debt reduced\r\n   * @param repayer The address of the user initiating the repay(), providing the funds\r\n   * @param amount The amount repaid\r\n   **/\r\n  event Repay(\r\n    address indexed reserve,\r\n    address indexed user,\r\n    address indexed repayer,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   **/\r\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   **/\r\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on flashLoan()\r\n   * @param target The address of the flash loan receiver contract\r\n   * @param initiator The address initiating the flash loan\r\n   * @param asset The address of the asset being flash borrowed\r\n   * @param amount The amount flash borrowed\r\n   * @param premium The fee flash borrowed\r\n   * @param referralCode The referral code used\r\n   **/\r\n  event FlashLoan(\r\n    address indexed target,\r\n    address indexed initiator,\r\n    address indexed asset,\r\n    uint256 amount,\r\n    uint256 premium,\r\n    uint16 referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the pause is triggered.\r\n   */\r\n  event Paused();\r\n\r\n  /**\r\n   * @dev Emitted when the pause is lifted.\r\n   */\r\n  event Unpaused();\r\n\r\n  /**\r\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\r\n   * LendingPoolCollateral manager using a DELEGATECALL\r\n   * This allows to have the events in the generated ABI for LendingPool.\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\r\n   * @param liquidator The address of the liquidator\r\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  event LiquidationCall(\r\n    address indexed collateralAsset,\r\n    address indexed debtAsset,\r\n    address indexed user,\r\n    uint256 debtToCover,\r\n    uint256 liquidatedCollateralAmount,\r\n    address liquidator,\r\n    bool receiveAToken\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\r\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\r\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\r\n   * gets added to the LendingPool ABI\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param liquidityRate The new liquidity rate\r\n   * @param stableBorrowRate The new stable borrow rate\r\n   * @param variableBorrowRate The new variable borrow rate\r\n   * @param liquidityIndex The new liquidity index\r\n   * @param variableBorrowIndex The new variable borrow index\r\n   **/\r\n  event ReserveDataUpdated(\r\n    address indexed reserve,\r\n    uint256 liquidityRate,\r\n    uint256 stableBorrowRate,\r\n    uint256 variableBorrowRate,\r\n    uint256 liquidityIndex,\r\n    uint256 variableBorrowIndex\r\n  );\r\n\r\n  /**\r\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n   * - Caller is anyone.\r\n   * @param asset The address of the underlying asset to deposit\r\n   * @param amount The amount to be deposited\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\r\n\r\n  /**\r\n   * @dev Deposits an `amount` of underlying asset into the reserve for supplier from vault\r\n   * - Caller is only Vault which is registered in this contract\r\n   * @param asset The address of the underlying asset to deposit\r\n   * @param amount The amount to be deposited\r\n   **/\r\n  function depositYield(address asset, uint256 amount) external;\r\n\r\n  /**\r\n   * @dev Grab an Yield `amount` of underlying asset into the vault\r\n   * - Caller is only Vault which is registered in this contract\r\n   * @param asset The address of the underlying asset to get yield\r\n   * @param amount The yield amount\r\n   **/\r\n  function getYield(address asset, uint256 amount) external;\r\n\r\n  /**\r\n   * @dev Get underlying asset and aToken's total balance\r\n   * @param asset The address of the underlying asset\r\n   **/\r\n  function getTotalBalanceOfAssetPair(address asset) external view returns (uint256, uint256);\r\n\r\n  /**\r\n   * @dev Get total underlying asset which is borrowable\r\n   *  and also list of underlying asset\r\n   **/\r\n  function getBorrowingAssetAndVolumes()\r\n    external\r\n    view\r\n    returns (uint256, uint256[] memory, address[] memory, uint256);\r\n\r\n  /**\r\n   * @dev Register the vault address\r\n   * - To check if the caller is vault for some functions\r\n   * - Caller is only LendingPoolConfigurator\r\n   * @param _vaultAddress The address of the Vault\r\n   **/\r\n  function registerVault(address _vaultAddress) external payable;\r\n\r\n  /**\r\n   * @dev Unregister the vault address\r\n   * - To check if the caller is vault for some functions\r\n   * - Caller is only LendingPoolConfigurator\r\n   * @param _vaultAddress The address of the Vault\r\n   **/\r\n  function unregisterVault(address _vaultAddress) external payable;\r\n\r\n  /**\r\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n   * - E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n   * - Caller is anyone\r\n   * @param asset The address of the underlying asset to withdraw\r\n   * @param amount The underlying amount to be withdrawn\r\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n   * @param to Address that will receive the underlying, same as msg.sender if the user\r\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n   *   different wallet\r\n   * @return The final amount withdrawn\r\n   **/\r\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n   * - E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n   * - Caller is anyone\r\n   * @param asset The address of the underlying asset to withdraw\r\n   * @param amount The underlying amount to be withdrawn\r\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n   * @param from The address of user who is depositor of underlying asset\r\n   * @param to Address that will receive the underlying, same as msg.sender if the user\r\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n   *   different wallet\r\n   * @return The final amount withdrawn\r\n   **/\r\n  function withdrawFrom(\r\n    address asset,\r\n    uint256 amount,\r\n    address from,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n   * - Caller is anyone\r\n   * @param asset The address of the underlying asset to borrow\r\n   * @param amount The amount to be borrowed\r\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n   * if he has been given credit delegation allowance\r\n   **/\r\n  function borrow(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    uint16 referralCode,\r\n    address onBehalfOf\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n   * - Caller is anyone\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n   * other borrower whose debt should be removed\r\n   * @return The final amount repaid\r\n   **/\r\n  function repay(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 rateMode,\r\n    address onBehalfOf\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n   * @param asset The address of the underlying asset deposited\r\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n   **/\r\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\r\n\r\n  /**\r\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n   * - Caller is anyone\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  function liquidationCall(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool receiveAToken\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns the user account data across all the reserves\r\n   * @param user The address of the user\r\n   * @return totalCollateralETH the total collateral in ETH of the user\r\n   * @return totalDebtETH the total debt in ETH of the user\r\n   * @return availableBorrowsETH the borrowing power left of the user\r\n   * @return currentLiquidationThreshold the liquidation threshold of the user\r\n   * @return ltv the loan to value of the user\r\n   * @return healthFactor the current health factor of the user\r\n   **/\r\n  function getUserAccountData(\r\n    address user\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 totalCollateralETH,\r\n      uint256 totalDebtETH,\r\n      uint256 availableBorrowsETH,\r\n      uint256 currentLiquidationThreshold,\r\n      uint256 ltv,\r\n      uint256 healthFactor\r\n    );\r\n\r\n  /**\r\n   * @dev Initializes a reserve, activating it, assigning an aToken and debt tokens and an\r\n   * interest rate strategy\r\n   * - Only callable by the LendingPoolConfigurator contract\r\n   * - Caller is only LendingPoolConfigurator\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param yieldAddress The address of the underlying asset's yield contract of the reserve\r\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\r\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\r\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\r\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\r\n   **/\r\n  function initReserve(\r\n    address reserve,\r\n    address yieldAddress,\r\n    address aTokenAddress,\r\n    address stableDebtAddress,\r\n    address variableDebtAddress,\r\n    address interestRateStrategyAddress\r\n  ) external payable;\r\n\r\n  /**\r\n   * @dev Updates the address of the interest rate strategy contract\r\n   * - Caller is only LendingPoolConfigurator\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param rateStrategyAddress The address of the interest rate strategy contract\r\n   **/\r\n  function setReserveInterestRateStrategyAddress(\r\n    address reserve,\r\n    address rateStrategyAddress\r\n  ) external payable;\r\n\r\n  /**\r\n   * @dev Sets the configuration bitmap of the reserve as a whole\r\n   * - Caller is only LendingPoolConfigurator\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param configuration The new configuration bitmap\r\n   **/\r\n  function setConfiguration(address reserve, uint256 configuration) external payable;\r\n\r\n  /**\r\n   * @dev Returns the configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The configuration of the reserve\r\n   **/\r\n  function getConfiguration(\r\n    address asset\r\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n  /**\r\n   * @dev Returns the configuration of the user across all the reserves\r\n   * @param user The user address\r\n   * @return The configuration of the user\r\n   **/\r\n  function getUserConfiguration(\r\n    address user\r\n  ) external view returns (DataTypes.UserConfigurationMap memory);\r\n\r\n  /**\r\n   * @dev Returns the normalized income normalized income of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve's normalized income\r\n   */\r\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the normalized variable debt per unit of asset\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve normalized variable debt\r\n   */\r\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the state and configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The state of the reserve\r\n   **/\r\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\r\n\r\n  /**\r\n   * @dev Validates and finalizes an aToken transfer\r\n   * - Only callable by the overlying aToken of the `asset`\r\n   * - Caller is only aToken contract which is storing the underlying asset of depositors\r\n   * @param asset The address of the underlying asset of the aToken\r\n   * @param from The user from which the aTokens are transferred\r\n   * @param to The user receiving the aTokens\r\n   * @param amount The amount being transferred/withdrawn\r\n   * @param balanceFromAfter The aToken balance of the `from` user before the transfer\r\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\r\n   */\r\n  function finalizeTransfer(\r\n    address asset,\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    uint256 balanceFromAfter,\r\n    uint256 balanceToBefore\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns the list of the initialized reserves\r\n   **/\r\n  function getReservesList() external view returns (address[] memory);\r\n\r\n  /**\r\n   * @dev Returns the cached LendingPoolAddressesProvider connected to this contract\r\n   **/\r\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\r\n\r\n  /**\r\n   * @dev Set the _pause state of a reserve\r\n   * - Caller is only LendingPoolConfigurator\r\n   * @param val `true` to pause the reserve, `false` to un-pause it\r\n   */\r\n  function setPause(bool val) external payable;\r\n\r\n  /**\r\n   * @dev Returns if the LendingPool is paused\r\n   */\r\n  function paused() external view returns (bool);\r\n}\r\n\r\nlibrary Errors {\r\n  //common errors\r\n  string internal constant CALLER_NOT_POOL_ADMIN = '33'; // 'The caller must be the pool admin'\r\n  string internal constant BORROW_ALLOWANCE_NOT_ENOUGH = '59'; // User borrows on behalf, but allowance are too small\r\n\r\n  //contract specific errors\r\n  string internal constant VL_INVALID_AMOUNT = '1'; // 'Amount must be greater than 0'\r\n  string internal constant VL_NO_ACTIVE_RESERVE = '2'; // 'Action requires an active reserve'\r\n  string internal constant VL_RESERVE_FROZEN = '3'; // 'Action cannot be performed because the reserve is frozen'\r\n  string internal constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = '4'; // 'The current liquidity is not enough'\r\n  string internal constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = '5'; // 'User cannot withdraw more than the available balance'\r\n  string internal constant VL_TRANSFER_NOT_ALLOWED = '6'; // 'Transfer cannot be allowed.'\r\n  string internal constant VL_BORROWING_NOT_ENABLED = '7'; // 'Borrowing is not enabled'\r\n  string internal constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = '8'; // 'Invalid interest rate mode selected'\r\n  string internal constant VL_COLLATERAL_BALANCE_IS_0 = '9'; // 'The collateral balance is 0'\r\n  string internal constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '10'; // 'Health factor is lesser than the liquidation threshold'\r\n  string internal constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = '11'; // 'There is not enough collateral to cover a new borrow'\r\n  string internal constant VL_STABLE_BORROWING_NOT_ENABLED = '12'; // stable borrowing not enabled\r\n  string internal constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = '13'; // collateral is (mostly) the same currency that is being borrowed\r\n  string internal constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '14'; // 'The requested amount is greater than the max loan size in stable rate mode\r\n  string internal constant VL_NO_DEBT_OF_SELECTED_TYPE = '15'; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\r\n  string internal constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '16'; // 'To repay on behalf of an user an explicit amount to repay is needed'\r\n  string internal constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = '17'; // 'User does not have a stable rate loan in progress on this reserve'\r\n  string internal constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = '18'; // 'User does not have a variable rate loan in progress on this reserve'\r\n  string internal constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = '19'; // 'The underlying balance needs to be greater than 0'\r\n  string internal constant VL_DEPOSIT_ALREADY_IN_USE = '20'; // 'User deposit is already being used as collateral'\r\n  string internal constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = '21'; // 'User does not have any stable rate loan for this reserve'\r\n  string internal constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '22'; // 'Interest rate rebalance conditions were not met'\r\n  string internal constant LP_LIQUIDATION_CALL_FAILED = '23'; // 'Liquidation call failed'\r\n  string internal constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = '24'; // 'There is not enough liquidity available to borrow'\r\n  string internal constant LP_REQUESTED_AMOUNT_TOO_SMALL = '25'; // 'The requested amount is too small for a FlashLoan.'\r\n  string internal constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = '26'; // 'The actual balance of the protocol is inconsistent'\r\n  string internal constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = '27'; // 'The caller of the function is not the lending pool configurator'\r\n  string internal constant LP_INCONSISTENT_FLASHLOAN_PARAMS = '28';\r\n  string internal constant CT_CALLER_MUST_BE_LENDING_POOL = '29'; // 'The caller of this function must be a lending pool'\r\n  string internal constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = '30'; // 'User cannot give allowance to himself'\r\n  string internal constant CT_TRANSFER_AMOUNT_NOT_GT_0 = '31'; // 'Transferred amount needs to be greater than zero'\r\n  string internal constant RL_RESERVE_ALREADY_INITIALIZED = '32'; // 'Reserve has already been initialized'\r\n  string internal constant LPC_RESERVE_LIQUIDITY_NOT_0 = '34'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_ATOKEN_POOL_ADDRESS = '35'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = '36'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = '37'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '38'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '39'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_ADDRESSES_PROVIDER_ID = '40'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_CONFIGURATION = '75'; // 'Invalid risk parameters for the reserve'\r\n  string internal constant LPC_CALLER_NOT_EMERGENCY_ADMIN = '76'; // 'The caller must be the emergency admin'\r\n  string internal constant LPAPR_PROVIDER_NOT_REGISTERED = '41'; // 'Provider is not registered'\r\n  string internal constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '42'; // 'Health factor is not below the threshold'\r\n  string internal constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = '43'; // 'The collateral chosen cannot be liquidated'\r\n  string internal constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '44'; // 'User did not borrow the specified currency'\r\n  string internal constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = '45'; // \"There isn't enough liquidity available to liquidate\"\r\n  string internal constant LPCM_NO_ERRORS = '46'; // 'No errors'\r\n  string internal constant LP_INVALID_FLASHLOAN_MODE = '47'; //Invalid flashloan mode selected\r\n  string internal constant MATH_MULTIPLICATION_OVERFLOW = '48';\r\n  string internal constant MATH_ADDITION_OVERFLOW = '49';\r\n  string internal constant MATH_DIVISION_BY_ZERO = '50';\r\n  string internal constant RL_LIQUIDITY_INDEX_OVERFLOW = '51'; //  Liquidity index overflows uint128\r\n  string internal constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = '52'; //  Variable borrow index overflows uint128\r\n  string internal constant RL_LIQUIDITY_RATE_OVERFLOW = '53'; //  Liquidity rate overflows uint128\r\n  string internal constant RL_VARIABLE_BORROW_RATE_OVERFLOW = '54'; //  Variable borrow rate overflows uint128\r\n  string internal constant RL_STABLE_BORROW_RATE_OVERFLOW = '55'; //  Stable borrow rate overflows uint128\r\n  string internal constant CT_INVALID_MINT_AMOUNT = '56'; //invalid amount to mint\r\n  string internal constant LP_FAILED_REPAY_WITH_COLLATERAL = '57';\r\n  string internal constant CT_INVALID_BURN_AMOUNT = '58'; //invalid amount to burn\r\n  string internal constant LP_FAILED_COLLATERAL_SWAP = '60';\r\n  string internal constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = '61';\r\n  string internal constant LP_REENTRANCY_NOT_ALLOWED = '62';\r\n  string internal constant LP_CALLER_MUST_BE_AN_ATOKEN = '63';\r\n  string internal constant LP_IS_PAUSED = '64'; // 'Pool is paused'\r\n  string internal constant LP_NO_MORE_RESERVES_ALLOWED = '65';\r\n  string internal constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = '66';\r\n  string internal constant RC_INVALID_LTV = '67';\r\n  string internal constant RC_INVALID_LIQ_THRESHOLD = '68';\r\n  string internal constant RC_INVALID_LIQ_BONUS = '69';\r\n  string internal constant RC_INVALID_DECIMALS = '70';\r\n  string internal constant RC_INVALID_RESERVE_FACTOR = '71';\r\n  string internal constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = '72';\r\n  string internal constant VL_INCONSISTENT_FLASHLOAN_PARAMS = '73';\r\n  string internal constant LP_INCONSISTENT_PARAMS_LENGTH = '74';\r\n  string internal constant UL_INVALID_INDEX = '77';\r\n  string internal constant LP_NOT_CONTRACT = '78';\r\n  string internal constant SDT_STABLE_DEBT_OVERFLOW = '79';\r\n  string internal constant SDT_BURN_EXCEEDS_BALANCE = '80';\r\n  string internal constant VT_COLLATERAL_DEPOSIT_REQUIRE_ETH = '81'; //Only accept ETH for collateral deposit\r\n  string internal constant VT_COLLATERAL_DEPOSIT_INVALID = '82'; //Collateral deposit failed\r\n  string internal constant VT_LIQUIDITY_DEPOSIT_INVALID = '83'; //Only accept USDC, USDT, DAI for liquidity deposit\r\n  string internal constant VT_COLLATERAL_WITHDRAW_INVALID = '84'; //Collateral withdraw failed\r\n  string internal constant VT_COLLATERAL_WITHDRAW_INVALID_AMOUNT = '85'; //Collateral withdraw has not enough amount\r\n  string internal constant VT_CONVERT_ASSET_BY_CURVE_INVALID = '86'; //Convert asset by curve invalid\r\n  string internal constant VT_PROCESS_YIELD_INVALID = '87'; //Processing yield is invalid\r\n  string internal constant VT_TREASURY_INVALID = '88'; //Treasury is invalid\r\n  string internal constant LP_ATOKEN_INIT_INVALID = '89'; //aToken invalid init\r\n  string internal constant VT_FEE_TOO_BIG = '90'; //Fee is too big\r\n  string internal constant VT_COLLATERAL_DEPOSIT_VAULT_UNAVAILABLE = '91';\r\n  string internal constant LP_LIQUIDATION_CONVERT_FAILED = '92';\r\n  string internal constant VT_DEPLOY_FAILED = '93'; // Vault deploy failed\r\n  string internal constant VT_INVALID_CONFIGURATION = '94'; // Invalid vault configuration\r\n  string internal constant VL_OVERFLOW_MAX_RESERVE_CAPACITY = '95'; // overflow max capacity of reserve\r\n  string internal constant VT_WITHDRAW_AMOUNT_MISMATCH = '96'; // not performed withdraw 100%\r\n  string internal constant VT_SWAP_MISMATCH_RETURNED_AMOUNT = '97'; //Returned amount is not enough\r\n  string internal constant CALLER_NOT_YIELD_PROCESSOR = '98'; // 'The caller must be the pool admin'\r\n  string internal constant VT_EXTRA_REWARDS_INDEX_INVALID = '97'; // Invalid extraRewards index\r\n  string internal constant VT_SWAP_PATH_LENGTH_INVALID = '100'; // Invalid token or fee length\r\n  string internal constant VT_SWAP_PATH_TOKEN_INVALID = '101'; // Invalid token information\r\n  string internal constant CLAIMER_UNAUTHORIZED = '102'; // 'The claimer is not authorized'\r\n  string internal constant YD_INVALID_CONFIGURATION = '103'; // 'The yield distribution's invalid configuration'\r\n  string internal constant CALLER_NOT_EMISSION_MANAGER = '104'; // 'The caller must be emission manager'\r\n  string internal constant CALLER_NOT_INCENTIVE_CONTROLLER = '105'; // 'The caller must be incentive controller'\r\n  string internal constant YD_VR_ASSET_ALREADY_IN_USE = '106'; // Vault is already registered\r\n  string internal constant YD_VR_INVALID_VAULT = '107'; // Invalid vault is used for an asset\r\n  string internal constant YD_VR_INVALID_REWARDS_AMOUNT = '108'; // Rewards amount should be bigger than before\r\n  string internal constant YD_VR_REWARD_TOKEN_NOT_VALID = '109'; // The reward token must be same with configured address\r\n  string internal constant YD_VR_ASSET_NOT_REGISTERED = '110';\r\n  string internal constant YD_VR_CALLER_NOT_VAULT = '111'; // The caller must be same with configured vault address\r\n  string internal constant LS_INVALID_CONFIGURATION = '112'; // Invalid Leverage Swapper configuration\r\n  string internal constant LS_SWAP_AMOUNT_NOT_GT_0 = '113'; // Collateral amount needs to be greater than zero\r\n  string internal constant LS_STABLE_COIN_NOT_SUPPORTED = '114'; // Doesn't support swap for the stable coin\r\n  string internal constant LS_SUPPLY_NOT_ALLOWED = '115'; // no sufficient funds\r\n  string internal constant LS_SUPPLY_FAILED = '116'; // Deposit fails when leverage works\r\n  string internal constant LS_REMOVE_ITERATION_OVER = '117'; // Withdraw iteration limit over\r\n  string internal constant CALLER_NOT_WHITELIST_USER = '118'; // 'The caller must be whitelist user'\r\n  string internal constant SAT_INVALID_OWNER = '119';\r\n  string internal constant SAT_INVALID_EXPIRATION = '120';\r\n  string internal constant SAT_INVALID_SIGNATURE = '121';\r\n  string internal constant SAT_INVALID_DEPOSITOR = '122';\r\n  string internal constant SAT_INVALID_RECIPIENT = '123';\r\n  string internal constant SAT_ONLY_ONE_AMOUNT_FORMAT_ALLOWED = '125';\r\n  string internal constant LS_REPAY_FAILED = '126';\r\n\r\n  enum CollateralManagerErrors {\r\n    NO_ERROR,\r\n    NO_COLLATERAL_AVAILABLE,\r\n    COLLATERAL_CANNOT_BE_LIQUIDATED,\r\n    CURRRENCY_NOT_BORROWED,\r\n    HEALTH_FACTOR_ABOVE_THRESHOLD,\r\n    NOT_ENOUGH_LIQUIDITY,\r\n    NO_ACTIVE_RESERVE,\r\n    HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\r\n    INVALID_EQUAL_ASSETS_TO_SWAP,\r\n    FROZEN_RESERVE\r\n  }\r\n}\r\n\r\nlibrary PercentageMath {\r\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\r\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\r\n\r\n  /**\r\n   * @dev Executes a percentage multiplication\r\n   * @param value The value of which the percentage needs to be calculated\r\n   * @param percentage The percentage of the value to be calculated\r\n   * @return The percentage of value\r\n   **/\r\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\r\n    if (value == 0 || percentage == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\r\n  }\r\n\r\n  /**\r\n   * @dev Executes a percentage division\r\n   * @param value The value of which the percentage needs to be calculated\r\n   * @param percentage The percentage of the value to be calculated\r\n   * @return The value divided the percentage\r\n   **/\r\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\r\n    uint256 halfPercentage = percentage / 2;\r\n\r\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\r\n  }\r\n}\r\n\r\ninterface IGeneralVault {\r\n  function pricePerShare() external view returns (uint256);\r\n\r\n  function vaultYieldInPrice() external view returns (uint256);\r\n\r\n  function withdrawOnLiquidation(address _asset, uint256 _amount) external returns (uint256);\r\n\r\n  function convertOnLiquidation(address _assetOut, uint256 _amountIn) external;\r\n\r\n  function processYield() external;\r\n\r\n  function getYieldAmount() external view returns (uint256);\r\n\r\n  function setTreasuryInfo(address _treasury, uint256 _fee) external;\r\n\r\n  function depositCollateral(address _asset, uint256 _amount) external payable;\r\n\r\n  function depositCollateralFrom(address _asset, uint256 _amount, address _user) external payable;\r\n\r\n  function withdrawCollateral(\r\n    address _asset,\r\n    uint256 _amount,\r\n    uint256 _slippage,\r\n    address _to\r\n  ) external;\r\n}\r\n\r\ninterface ICurveAddressProvider {\r\n  function get_address(uint256 id) external view returns (address);\r\n}\r\n\r\ninterface ICurveExchange {\r\n  function exchange(\r\n    address _pool,\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    uint256 _expected,\r\n    address _receiver\r\n  ) external payable returns (uint256);\r\n\r\n  function exchange_multiple(\r\n    address[9] memory _route,\r\n    uint256[3][4] memory _swap_params,\r\n    uint256 _amount,\r\n    uint256 _expected,\r\n    address[4] memory _pools,\r\n    address _receiver\r\n  ) external payable returns (uint256);\r\n}\r\n\r\nlibrary CurveswapAdapter {\r\n  using PercentageMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct Path {\r\n    address[9] routes;\r\n    uint256[3][4] swapParams;\r\n  }\r\n\r\n  address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n  function swapExactTokensForTokens(\r\n    ILendingPoolAddressesProvider addressesProvider,\r\n    address poolAddress,\r\n    address assetToSwapFrom,\r\n    address assetToSwapTo,\r\n    uint256 amountToSwap,\r\n    uint256 slippage // 2% = 200\r\n  ) external returns (uint256) {\r\n    uint256 minAmountOut = _getMinAmount(\r\n      addressesProvider,\r\n      assetToSwapFrom,\r\n      assetToSwapTo,\r\n      amountToSwap,\r\n      slippage\r\n    );\r\n\r\n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\r\n    address curveAddressProvider = addressesProvider.getAddress('CURVE_ADDRESS_PROVIDER');\r\n    address curveExchange = ICurveAddressProvider(curveAddressProvider).get_address(2);\r\n\r\n    IERC20(assetToSwapFrom).safeApprove(address(curveExchange), 0);\r\n    IERC20(assetToSwapFrom).safeApprove(address(curveExchange), amountToSwap);\r\n\r\n    uint256 receivedAmount = ICurveExchange(curveExchange).exchange(\r\n      poolAddress,\r\n      assetToSwapFrom,\r\n      assetToSwapTo,\r\n      amountToSwap,\r\n      minAmountOut,\r\n      address(this)\r\n    );\r\n\r\n    require(receivedAmount != 0, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\r\n    uint256 balanceOfAsset;\r\n    if (assetToSwapTo == ETH) {\r\n      balanceOfAsset = address(this).balance;\r\n    } else {\r\n      balanceOfAsset = IERC20(assetToSwapTo).balanceOf(address(this));\r\n    }\r\n    require(balanceOfAsset >= receivedAmount, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\r\n    return receivedAmount;\r\n  }\r\n\r\n  function _getDecimals(address asset) internal view returns (uint256) {\r\n    if (asset == ETH) {\r\n      return 18;\r\n    }\r\n    return IERC20Detailed(asset).decimals();\r\n  }\r\n\r\n  function _getPrice(\r\n    ILendingPoolAddressesProvider addressesProvider,\r\n    address asset\r\n  ) internal view returns (uint256) {\r\n    if (asset == ETH) {\r\n      return 1e18;\r\n    }\r\n    return IPriceOracleGetter(addressesProvider.getPriceOracle()).getAssetPrice(asset);\r\n  }\r\n\r\n  function _getMinAmount(\r\n    ILendingPoolAddressesProvider addressesProvider,\r\n    address assetToSwapFrom,\r\n    address assetToSwapTo,\r\n    uint256 amountToSwap,\r\n    uint256 slippage\r\n  ) internal view returns (uint256) {\r\n    uint256 fromAssetDecimals = _getDecimals(assetToSwapFrom);\r\n    uint256 toAssetDecimals = _getDecimals(assetToSwapTo);\r\n\r\n    uint256 fromAssetPrice = _getPrice(addressesProvider, assetToSwapFrom);\r\n    uint256 toAssetPrice = _getPrice(addressesProvider, assetToSwapTo);\r\n\r\n    uint256 minAmountOut = ((amountToSwap * fromAssetPrice * 10 ** toAssetDecimals) /\r\n      (toAssetPrice * 10 ** fromAssetDecimals)).percentMul(\r\n        PercentageMath.PERCENTAGE_FACTOR - slippage\r\n      );\r\n\r\n    return minAmountOut;\r\n  }\r\n}\r\n\r\ninterface IGeneralLevSwap {\r\n  enum FlashLoanType {\r\n    AAVE,\r\n    BALANCER\r\n  }\r\n\r\n  enum SwapType {\r\n    NONE,\r\n    NO_SWAP,\r\n    UNISWAP,\r\n    BALANCER,\r\n    CURVE\r\n  }\r\n\r\n  struct MultipSwapPath {\r\n    address[9] routes;\r\n    uint256[3][4] routeParams;\r\n    // uniswap/balancer/curve\r\n    SwapType swapType;\r\n    uint256 poolCount;\r\n    address swapFrom;\r\n    address swapTo;\r\n    uint256 inAmount;\r\n    uint256 outAmount;\r\n  }\r\n\r\n  struct SwapInfo {\r\n    MultipSwapPath[3] paths;\r\n    MultipSwapPath[3] reversePaths;\r\n    uint256 pathLength;\r\n  }\r\n\r\n  struct FlashLoanParams {\r\n    bool isEnterPosition;\r\n    uint256 minCollateralAmount;\r\n    address user;\r\n    address sAsset;\r\n    SwapInfo swapInfo;\r\n  }\r\n\r\n  struct LeverageParams {\r\n    address user;\r\n    uint256 principal;\r\n    uint256 leverage;\r\n    address borrowAsset;\r\n    FlashLoanType flashLoanType;\r\n    SwapInfo swapInfo;\r\n  }\r\n\r\n  function enterPositionWithFlashloan(\r\n    uint256 _principal,\r\n    uint256 _leverage,\r\n    address _stableAsset,\r\n    FlashLoanType _flashLoanType,\r\n    SwapInfo calldata _swapInfo\r\n  ) external;\r\n\r\n  function withdrawWithFlashloan(\r\n    uint256 _repayAmount,\r\n    uint256 _requiredAmount,\r\n    address _stableAsset,\r\n    address _sAsset,\r\n    FlashLoanType _flashLoanType,\r\n    SwapInfo calldata _swapInfo\r\n  ) external;\r\n\r\n  function zapDeposit(\r\n    address _zappingAsset,\r\n    uint256 _principal,\r\n    MultipSwapPath[3] calldata _zapPaths,\r\n    uint256 _zapPathLength\r\n  ) external;\r\n\r\n  function zapLeverageWithFlashloan(\r\n    address _zappingAsset,\r\n    uint256 _principal,\r\n    uint256 _leverage,\r\n    address _borrowAsset,\r\n    FlashLoanType _flashLoanType,\r\n    MultipSwapPath[3] calldata _zapPaths,\r\n    uint256 _zapPathLength,\r\n    SwapInfo calldata _swapInfo\r\n  ) external;\r\n\r\n  function getAvailableBorrowAssets() external pure returns (address[] memory);\r\n}\r\n\r\ninterface IScaledBalanceToken {\r\n  /**\r\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\r\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\r\n   * @param user The user whose balance is calculated\r\n   * @return The scaled balance of the user\r\n   **/\r\n  function scaledBalanceOf(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the scaled balance of the user and the scaled total supply.\r\n   * @param user The address of the user\r\n   * @return The scaled balance of the user\r\n   * @return The scaled balance and the scaled total supply\r\n   **/\r\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\r\n\r\n  /**\r\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\r\n   * @return The scaled total supply\r\n   **/\r\n  function scaledTotalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface ISturdyIncentivesController {\r\n  event RewardsAccrued(address indexed user, uint256 amount);\r\n\r\n  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);\r\n\r\n  event RewardsClaimed(\r\n    address indexed user,\r\n    address indexed to,\r\n    address indexed claimer,\r\n    uint256 amount\r\n  );\r\n\r\n  event ClaimerSet(address indexed user, address indexed claimer);\r\n\r\n  /*\r\n   * @dev Returns the configuration of the distribution for a certain asset\r\n   * @param asset The address of the reference asset of the distribution\r\n   * @return The asset index, the emission per second and the last updated timestamp\r\n   **/\r\n  function getAssetData(address asset) external view returns (uint256, uint256, uint256);\r\n\r\n  /**\r\n   * @dev Whitelists an address to claim the rewards on behalf of another address\r\n   * @param user The address of the user\r\n   * @param claimer The address of the claimer\r\n   */\r\n  function setClaimer(address user, address claimer) external payable;\r\n\r\n  /**\r\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\r\n   * @param user The address of the user\r\n   * @return The claimer address\r\n   */\r\n  function getClaimer(address user) external view returns (address);\r\n\r\n  /**\r\n   * @dev Configure assets for a certain rewards emission\r\n   * @param assets The assets to incentivize\r\n   * @param emissionsPerSecond The emission for each asset\r\n   */\r\n  function configureAssets(\r\n    address[] calldata assets,\r\n    uint256[] calldata emissionsPerSecond\r\n  ) external payable;\r\n\r\n  /**\r\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\r\n   * @param user The address of the user\r\n   * @param userBalance The balance of the user of the asset in the lending pool\r\n   * @param totalSupply The total supply of the asset in the lending pool\r\n   **/\r\n  function handleAction(address user, uint256 totalSupply, uint256 userBalance) external;\r\n\r\n  /**\r\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\r\n   * @param user The address of the user\r\n   * @return The rewards\r\n   **/\r\n  function getRewardsBalance(\r\n    address[] calldata assets,\r\n    address user\r\n  ) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\r\n   * @param amount Amount of rewards to claim\r\n   * @param to Address that will be receiving the rewards\r\n   * @return Rewards claimed\r\n   **/\r\n  function claimRewards(\r\n    address[] calldata assets,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\r\n   * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\r\n   * @param amount Amount of rewards to claim\r\n   * @param user Address to check and claim rewards\r\n   * @param to Address that will be receiving the rewards\r\n   * @return Rewards claimed\r\n   **/\r\n  function claimRewardsOnBehalf(\r\n    address[] calldata assets,\r\n    uint256 amount,\r\n    address user,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev returns the unclaimed rewards of the user\r\n   * @param user the address of the user\r\n   * @return the unclaimed user rewards\r\n   */\r\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev returns the unclaimed rewards of the user\r\n   * @param user the address of the user\r\n   * @param asset The asset to incentivize\r\n   * @return the user index for the asset\r\n   */\r\n  function getUserAssetData(address user, address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev for backward compatibility with previous implementation of the Incentives controller\r\n   */\r\n  function REWARD_TOKEN() external view returns (address);\r\n\r\n  /**\r\n   * @dev for backward compatibility with previous implementation of the Incentives controller\r\n   */\r\n  function PRECISION() external view returns (uint8);\r\n\r\n  /**\r\n   * @dev Gets the distribution end timestamp of the emissions\r\n   */\r\n  function DISTRIBUTION_END() external view returns (uint256);\r\n}\r\n\r\ninterface IInitializableAToken {\r\n  /**\r\n   * @dev Emitted when an aToken is initialized\r\n   * @param underlyingAsset The address of the underlying asset\r\n   * @param pool The address of the associated lending pool\r\n   * @param treasury The address of the treasury\r\n   * @param incentivesController The address of the incentives controller for this aToken\r\n   * @param aTokenDecimals the decimals of the underlying\r\n   * @param aTokenName the name of the aToken\r\n   * @param aTokenSymbol the symbol of the aToken\r\n   * @param params A set of encoded parameters for additional initialization\r\n   **/\r\n  event Initialized(\r\n    address indexed underlyingAsset,\r\n    address indexed pool,\r\n    address treasury,\r\n    address incentivesController,\r\n    uint8 aTokenDecimals,\r\n    string aTokenName,\r\n    string aTokenSymbol,\r\n    bytes params\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the aToken\r\n   * @param pool The address of the lending pool where this aToken will be used\r\n   * @param treasury The address of the Sturdy treasury, receiving the fees on this aToken\r\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   * @param incentivesController The smart contract managing potential incentives distribution\r\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\r\n   * @param aTokenName The name of the aToken\r\n   * @param aTokenSymbol The symbol of the aToken\r\n   */\r\n  function initialize(\r\n    ILendingPool pool,\r\n    address treasury,\r\n    address underlyingAsset,\r\n    ISturdyIncentivesController incentivesController,\r\n    uint8 aTokenDecimals,\r\n    string calldata aTokenName,\r\n    string calldata aTokenSymbol,\r\n    bytes calldata params\r\n  ) external;\r\n}\r\n\r\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\r\n  /**\r\n   * @dev Emitted after the mint action\r\n   * @param from The address performing the mint\r\n   * @param value The amount being\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event Mint(address indexed from, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Mints `amount` aTokens to `user`\r\n   * @param user The address receiving the minted tokens\r\n   * @param amount The amount of tokens getting minted\r\n   * @param index The new liquidity index of the reserve\r\n   * @return `true` if the the previous balance of the user was 0\r\n   */\r\n  function mint(address user, uint256 amount, uint256 index) external payable returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted after aTokens are burned\r\n   * @param from The owner of the aTokens, getting them burned\r\n   * @param target The address that will receive the underlying\r\n   * @param value The amount being burned\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Emitted during the transfer action\r\n   * @param from The user whose tokens are being transferred\r\n   * @param to The recipient\r\n   * @param value The amount being transferred\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\r\n   * @param user The owner of the aTokens, getting them burned\r\n   * @param receiverOfUnderlying The address that will receive the underlying\r\n   * @param amount The amount being burned\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  function burn(\r\n    address user,\r\n    address receiverOfUnderlying,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external payable;\r\n\r\n  /**\r\n   * @dev Mints aTokens to the reserve treasury\r\n   * @param amount The amount of tokens getting minted\r\n   * @param index The new liquidity index of the reserve\r\n   */\r\n  function mintToTreasury(uint256 amount, uint256 index) external payable;\r\n\r\n  /**\r\n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\r\n   * @param from The address getting liquidated, current owner of the aTokens\r\n   * @param to The recipient\r\n   * @param value The amount of tokens getting transferred\r\n   **/\r\n  function transferOnLiquidation(address from, address to, uint256 value) external payable;\r\n\r\n  /**\r\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\r\n   * assets in borrow(), withdraw() and flashLoan()\r\n   * @param user The recipient of the underlying\r\n   * @param amount The amount getting transferred\r\n   * @return The amount transferred\r\n   **/\r\n  function transferUnderlyingTo(address user, uint256 amount) external payable returns (uint256);\r\n\r\n  /**\r\n   * @dev Invoked to execute actions on the aToken side after a repayment.\r\n   * @param user The user executing the repayment\r\n   * @param amount The amount getting repaid\r\n   **/\r\n  function handleRepayment(address user, uint256 amount) external;\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view returns (ISturdyIncentivesController);\r\n\r\n  /**\r\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   **/\r\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\r\n}\r\n\r\ninterface IFlashLoanReceiver {\r\n  function executeOperation(\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata premiums,\r\n    address initiator,\r\n    bytes calldata params\r\n  ) external returns (bool);\r\n}\r\n\r\ninterface IFlashLoanRecipient {\r\n  /**\r\n   * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\r\n   *\r\n   * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\r\n   * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\r\n   * Vault, or else the entire flash loan will revert.\r\n   *\r\n   * `userData` is the same value passed in the `IVault.flashLoan` call.\r\n   */\r\n  function receiveFlashLoan(\r\n    IERC20[] memory tokens,\r\n    uint256[] memory amounts,\r\n    uint256[] memory feeAmounts,\r\n    bytes memory userData\r\n  ) external;\r\n}\r\n\r\ninterface IVaultWhitelist {\r\n  function whitelistUser(address vault, address user) external view returns (bool);\r\n\r\n  function whitelistUserCount(address vault) external view returns (uint256);\r\n\r\n  function whitelistContract(address vault, address sender) external view returns (bool);\r\n}\r\n\r\ninterface IAaveFlashLoan {\r\n  /**\r\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n   * as long as the amount taken plus a fee is returned.\r\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n   * For further details please visit https://developers.aave.com\r\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n   * @param assets The addresses of the assets being flash-borrowed\r\n   * @param amounts The amounts amounts being flash-borrowed\r\n   * @param modes Types of the debt to open if the flash loan is not returned:\r\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n   * @param params Variadic packed params to pass to the receiver as extra information\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function flashLoan(\r\n    address receiverAddress,\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata modes,\r\n    address onBehalfOf,\r\n    bytes calldata params,\r\n    uint16 referralCode\r\n  ) external;\r\n}\r\n\r\ninterface IBalancerVault {\r\n  // Pools\r\n  //\r\n  // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\r\n  // functionality:\r\n  //\r\n  //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\r\n  // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\r\n  // which increase with the number of registered tokens.\r\n  //\r\n  //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\r\n  // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\r\n  // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\r\n  // independent of the number of registered tokens.\r\n  //\r\n  //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\r\n  // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\r\n\r\n  enum PoolSpecialization {\r\n    GENERAL,\r\n    MINIMAL_SWAP_INFO,\r\n    TWO_TOKEN\r\n  }\r\n\r\n  /**\r\n   * @dev Returns a Pool's contract address and specialization setting.\r\n   */\r\n  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\r\n\r\n  // Swaps\r\n  //\r\n  // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\r\n  // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\r\n  // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\r\n  //\r\n  // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\r\n  // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\r\n  // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\r\n  // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\r\n  // individual swaps.\r\n  //\r\n  // There are two swap kinds:\r\n  //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\r\n  // `onSwap` hook) the amount of tokens out (to send to the recipient).\r\n  //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\r\n  // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\r\n  //\r\n  // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\r\n  // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\r\n  // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\r\n  // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\r\n  // the final intended token.\r\n  //\r\n  // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\r\n  // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\r\n  // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\r\n  // much less gas than they would otherwise.\r\n  //\r\n  // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\r\n  // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\r\n  // updating the Pool's internal accounting).\r\n  //\r\n  // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\r\n  // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\r\n  // minimum amount of tokens to receive (by passing a negative value) is specified.\r\n  //\r\n  // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\r\n  // this point in time (e.g. if the transaction failed to be included in a block promptly).\r\n  //\r\n  // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\r\n  // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\r\n  // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\r\n  // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\r\n  //\r\n  // Finally, Internal Balance can be used when either sending or receiving tokens.\r\n\r\n  enum SwapKind {\r\n    GIVEN_IN,\r\n    GIVEN_OUT\r\n  }\r\n\r\n  /**\r\n   * @dev Performs a swap with a single Pool.\r\n   *\r\n   * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\r\n   * taken from the Pool, which must be greater than or equal to `limit`.\r\n   *\r\n   * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\r\n   * sent to the Pool, which must be less than or equal to `limit`.\r\n   *\r\n   * Internal Balance usage and the recipient are determined by the `funds` struct.\r\n   *\r\n   * Emits a `Swap` event.\r\n   */\r\n  function swap(\r\n    SingleSwap memory singleSwap,\r\n    FundManagement memory funds,\r\n    uint256 limit,\r\n    uint256 deadline\r\n  ) external payable returns (uint256);\r\n\r\n  /**\r\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\r\n   * the `kind` value.\r\n   *\r\n   * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\r\n   * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\r\n   *\r\n   * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\r\n   * used to extend swap behavior.\r\n   */\r\n  struct SingleSwap {\r\n    bytes32 poolId;\r\n    SwapKind kind;\r\n    address assetIn;\r\n    address assetOut;\r\n    uint256 amount;\r\n    bytes userData;\r\n  }\r\n\r\n  /**\r\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\r\n   * `recipient` account.\r\n   *\r\n   * If the caller is not `sender`, it must be an authorized relayer for them.\r\n   *\r\n   * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\r\n   * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\r\n   * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\r\n   * `joinPool`.\r\n   *\r\n   * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\r\n   * transferred. This matches the behavior of `exitPool`.\r\n   *\r\n   * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\r\n   * revert.\r\n   */\r\n  struct FundManagement {\r\n    address sender;\r\n    bool fromInternalBalance;\r\n    address payable recipient;\r\n    bool toInternalBalance;\r\n  }\r\n\r\n  /**\r\n   * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\r\n   * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\r\n   * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\r\n   * `getPoolTokenInfo`).\r\n   *\r\n   * If the caller is not `sender`, it must be an authorized relayer for them.\r\n   *\r\n   * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\r\n   * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\r\n   * it just enforces these minimums.\r\n   *\r\n   * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\r\n   * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\r\n   * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\r\n   *\r\n   * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\r\n   * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\r\n   * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\r\n   * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\r\n   *\r\n   * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\r\n   * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\r\n   * do so will trigger a revert.\r\n   *\r\n   * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\r\n   * `tokens` array. This array must match the Pool's registered tokens.\r\n   *\r\n   * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\r\n   * their own custom logic. This typically requires additional information from the user (such as the expected number\r\n   * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\r\n   * passed directly to the Pool's contract.\r\n   *\r\n   * Emits a `PoolBalanceChanged` event.\r\n   */\r\n  function exitPool(\r\n    bytes32 poolId,\r\n    address sender,\r\n    address payable recipient,\r\n    ExitPoolRequest memory request\r\n  ) external;\r\n\r\n  struct ExitPoolRequest {\r\n    address[] assets;\r\n    uint256[] minAmountsOut;\r\n    bytes userData;\r\n    bool toInternalBalance;\r\n  }\r\n\r\n  enum ExitKind {\r\n    EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\r\n    EXACT_BPT_IN_FOR_TOKENS_OUT,\r\n    BPT_IN_FOR_EXACT_TOKENS_OUT\r\n  }\r\n\r\n  function joinPool(\r\n    bytes32 poolId,\r\n    address sender,\r\n    address recipient,\r\n    JoinPoolRequest memory request\r\n  ) external payable;\r\n\r\n  struct JoinPoolRequest {\r\n    address[] assets;\r\n    uint256[] maxAmountsIn;\r\n    bytes userData;\r\n    bool fromInternalBalance;\r\n  }\r\n\r\n  enum JoinKind {\r\n    INIT,\r\n    EXACT_TOKENS_IN_FOR_BPT_OUT,\r\n    TOKEN_IN_FOR_EXACT_BPT_OUT\r\n  }\r\n\r\n  function getPoolTokenInfo(\r\n    bytes32 poolId,\r\n    IERC20 token\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager);\r\n\r\n  function getPoolTokens(\r\n    bytes32 poolId\r\n  )\r\n    external\r\n    view\r\n    returns (address[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);\r\n\r\n  struct BatchSwapStep {\r\n    bytes32 poolId;\r\n    uint256 assetInIndex;\r\n    uint256 assetOutIndex;\r\n    uint256 amount;\r\n    bytes userData;\r\n  }\r\n\r\n  function batchSwap(\r\n    SwapKind kind,\r\n    BatchSwapStep[] memory swaps,\r\n    address[] memory assets,\r\n    FundManagement memory funds,\r\n    int256[] memory limits,\r\n    uint256 deadline\r\n  ) external payable returns (int256[] memory);\r\n\r\n  function flashLoan(\r\n    address recipient,\r\n    IERC20[] memory tokens,\r\n    uint256[] memory amounts,\r\n    bytes memory userData\r\n  ) external;\r\n}\r\n\r\nlibrary ReserveConfiguration {\r\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\r\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\r\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\r\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant COLLATERAL_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore\r\n\r\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\r\n  uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\r\n  uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\r\n  uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\r\n  uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\r\n  uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\r\n  uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\r\n  uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\r\n  uint256 constant COLLATERAL_ENABLED_START_BIT_POSITION = 60;\r\n  uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\r\n\r\n  uint256 constant MAX_VALID_LTV = 65535;\r\n  uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\r\n  uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\r\n  uint256 constant MAX_VALID_DECIMALS = 255;\r\n  uint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\r\n\r\n  /**\r\n   * @dev Sets the Loan to Value of the reserve\r\n   * @param self The reserve configuration\r\n   * @param ltv the new ltv\r\n   **/\r\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\r\n    require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\r\n\r\n    self.data = (self.data & LTV_MASK) | ltv;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the Loan to Value of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The loan to value\r\n   **/\r\n  function getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\r\n    return self.data & ~LTV_MASK;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the liquidation threshold of the reserve\r\n   * @param self The reserve configuration\r\n   * @param threshold The new liquidation threshold\r\n   **/\r\n  function setLiquidationThreshold(\r\n    DataTypes.ReserveConfigurationMap memory self,\r\n    uint256 threshold\r\n  ) internal pure {\r\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\r\n\r\n    self.data =\r\n      (self.data & LIQUIDATION_THRESHOLD_MASK) |\r\n      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the liquidation threshold of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The liquidation threshold\r\n   **/\r\n  function getLiquidationThreshold(\r\n    DataTypes.ReserveConfigurationMap storage self\r\n  ) internal view returns (uint256) {\r\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the liquidation bonus of the reserve\r\n   * @param self The reserve configuration\r\n   * @param bonus The new liquidation bonus\r\n   **/\r\n  function setLiquidationBonus(\r\n    DataTypes.ReserveConfigurationMap memory self,\r\n    uint256 bonus\r\n  ) internal pure {\r\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\r\n\r\n    self.data =\r\n      (self.data & LIQUIDATION_BONUS_MASK) |\r\n      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the liquidation bonus of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The liquidation bonus\r\n   **/\r\n  function getLiquidationBonus(\r\n    DataTypes.ReserveConfigurationMap storage self\r\n  ) internal view returns (uint256) {\r\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the decimals of the underlying asset of the reserve\r\n   * @param self The reserve configuration\r\n   * @param decimals The decimals\r\n   **/\r\n  function setDecimals(\r\n    DataTypes.ReserveConfigurationMap memory self,\r\n    uint256 decimals\r\n  ) internal pure {\r\n    require(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\r\n\r\n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the decimals of the underlying asset of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The decimals of the asset\r\n   **/\r\n  function getDecimals(\r\n    DataTypes.ReserveConfigurationMap storage self\r\n  ) internal view returns (uint256) {\r\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the active state of the reserve\r\n   * @param self The reserve configuration\r\n   * @param active The active state\r\n   **/\r\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\r\n    self.data =\r\n      (self.data & ACTIVE_MASK) |\r\n      (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the active state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The active state\r\n   **/\r\n  function getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\r\n    return (self.data & ~ACTIVE_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the frozen state of the reserve\r\n   * @param self The reserve configuration\r\n   * @param frozen The frozen state\r\n   **/\r\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\r\n    self.data =\r\n      (self.data & FROZEN_MASK) |\r\n      (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the frozen state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The frozen state\r\n   **/\r\n  function getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\r\n    return (self.data & ~FROZEN_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Enables or disables borrowing on the reserve\r\n   * @param self The reserve configuration\r\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\r\n   **/\r\n  function setBorrowingEnabled(\r\n    DataTypes.ReserveConfigurationMap memory self,\r\n    bool enabled\r\n  ) internal pure {\r\n    self.data =\r\n      (self.data & BORROWING_MASK) |\r\n      (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the borrowing state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The borrowing state\r\n   **/\r\n  function getBorrowingEnabled(\r\n    DataTypes.ReserveConfigurationMap storage self\r\n  ) internal view returns (bool) {\r\n    return (self.data & ~BORROWING_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the collateral state of the reserve\r\n   * @param self The reserve configuration\r\n   * @param enabled The collateral state\r\n   **/\r\n  function setCollateralEnabled(\r\n    DataTypes.ReserveConfigurationMap memory self,\r\n    bool enabled\r\n  ) internal pure {\r\n    self.data =\r\n      (self.data & COLLATERAL_MASK) |\r\n      (uint256(enabled ? 1 : 0) << COLLATERAL_ENABLED_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the collateral state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The collateral state\r\n   **/\r\n  function getCollateralEnabled(\r\n    DataTypes.ReserveConfigurationMap storage self\r\n  ) internal view returns (bool) {\r\n    return (self.data & ~COLLATERAL_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Enables or disables stable rate borrowing on the reserve\r\n   * @param self The reserve configuration\r\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\r\n   **/\r\n  function setStableRateBorrowingEnabled(\r\n    DataTypes.ReserveConfigurationMap memory self,\r\n    bool enabled\r\n  ) internal pure {\r\n    self.data =\r\n      (self.data & STABLE_BORROWING_MASK) |\r\n      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the stable rate borrowing state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The stable rate borrowing state\r\n   **/\r\n  function getStableRateBorrowingEnabled(\r\n    DataTypes.ReserveConfigurationMap storage self\r\n  ) internal view returns (bool) {\r\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the reserve factor of the reserve\r\n   * @param self The reserve configuration\r\n   * @param reserveFactor The reserve factor\r\n   **/\r\n  function setReserveFactor(\r\n    DataTypes.ReserveConfigurationMap memory self,\r\n    uint256 reserveFactor\r\n  ) internal pure {\r\n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);\r\n\r\n    self.data =\r\n      (self.data & RESERVE_FACTOR_MASK) |\r\n      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the reserve factor of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The reserve factor\r\n   **/\r\n  function getReserveFactor(\r\n    DataTypes.ReserveConfigurationMap storage self\r\n  ) internal view returns (uint256) {\r\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration flags of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled, collateral enabled\r\n   **/\r\n  function getFlags(\r\n    DataTypes.ReserveConfigurationMap storage self\r\n  ) internal view returns (bool, bool, bool, bool, bool) {\r\n    uint256 dataLocal = self.data;\r\n\r\n    return (\r\n      (dataLocal & ~ACTIVE_MASK) != 0,\r\n      (dataLocal & ~FROZEN_MASK) != 0,\r\n      (dataLocal & ~BORROWING_MASK) != 0,\r\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0,\r\n      (dataLocal & ~COLLATERAL_MASK) != 0\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration paramters of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\r\n   **/\r\n  function getParams(\r\n    DataTypes.ReserveConfigurationMap storage self\r\n  ) internal view returns (uint256, uint256, uint256, uint256, uint256) {\r\n    uint256 dataLocal = self.data;\r\n\r\n    return (\r\n      dataLocal & ~LTV_MASK,\r\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\r\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\r\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\r\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration paramters of the reserve from a memory object\r\n   * @param self The reserve configuration\r\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\r\n   **/\r\n  function getParamsMemory(\r\n    DataTypes.ReserveConfigurationMap memory self\r\n  ) internal pure returns (uint256, uint256, uint256, uint256, uint256) {\r\n    return (\r\n      self.data & ~LTV_MASK,\r\n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\r\n      (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\r\n      (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\r\n      (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration flags of the reserve from a memory object\r\n   * @param self The reserve configuration\r\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled, collateral enabled\r\n   **/\r\n  function getFlagsMemory(\r\n    DataTypes.ReserveConfigurationMap memory self\r\n  ) internal pure returns (bool, bool, bool, bool, bool) {\r\n    return (\r\n      (self.data & ~ACTIVE_MASK) != 0,\r\n      (self.data & ~FROZEN_MASK) != 0,\r\n      (self.data & ~BORROWING_MASK) != 0,\r\n      (self.data & ~STABLE_BORROWING_MASK) != 0,\r\n      (self.data & ~COLLATERAL_MASK) != 0\r\n    );\r\n  }\r\n}\r\n\r\nlibrary Math {\r\n  enum Rounding {\r\n    Down, // Toward negative infinity\r\n    Up, // Toward infinity\r\n    Zero // Toward zero\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the largest of two numbers.\r\n   */\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the smallest of two numbers.\r\n   */\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the average of two numbers. The result is rounded towards\r\n   * zero.\r\n   */\r\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b) / 2 can overflow.\r\n    return (a & b) + (a ^ b) / 2;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the ceiling of the division of two numbers.\r\n   *\r\n   * This differs from standard division with `/` in that it rounds up instead\r\n   * of rounding down.\r\n   */\r\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b - 1) / b can overflow on addition, so we distribute.\r\n    return a == 0 ? 0 : (a - 1) / b + 1;\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n   * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n   * with further edits by Uniswap Labs also under MIT license.\r\n   */\r\n  function mulDiv(\r\n    uint256 x,\r\n    uint256 y,\r\n    uint256 denominator\r\n  ) internal pure returns (uint256 result) {\r\n    unchecked {\r\n      // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n      // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n      // variables such that product = prod1 * 2^256 + prod0.\r\n      uint256 prod0; // Least significant 256 bits of the product\r\n      uint256 prod1; // Most significant 256 bits of the product\r\n      assembly {\r\n        let mm := mulmod(x, y, not(0))\r\n        prod0 := mul(x, y)\r\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n      }\r\n\r\n      // Handle non-overflow cases, 256 by 256 division.\r\n      if (prod1 == 0) {\r\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n        // The surrounding unchecked block does not change this fact.\r\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n        return prod0 / denominator;\r\n      }\r\n\r\n      // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n      require(denominator > prod1, 'Math: mulDiv overflow');\r\n\r\n      ///////////////////////////////////////////////\r\n      // 512 by 256 division.\r\n      ///////////////////////////////////////////////\r\n\r\n      // Make division exact by subtracting the remainder from [prod1 prod0].\r\n      uint256 remainder;\r\n      assembly {\r\n        // Compute remainder using mulmod.\r\n        remainder := mulmod(x, y, denominator)\r\n\r\n        // Subtract 256 bit number from 512 bit number.\r\n        prod1 := sub(prod1, gt(remainder, prod0))\r\n        prod0 := sub(prod0, remainder)\r\n      }\r\n\r\n      // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n      // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n      // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n      uint256 twos = denominator & (~denominator + 1);\r\n      assembly {\r\n        // Divide denominator by twos.\r\n        denominator := div(denominator, twos)\r\n\r\n        // Divide [prod1 prod0] by twos.\r\n        prod0 := div(prod0, twos)\r\n\r\n        // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n        twos := add(div(sub(0, twos), twos), 1)\r\n      }\r\n\r\n      // Shift in bits from prod1 into prod0.\r\n      prod0 |= prod1 * twos;\r\n\r\n      // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n      // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n      // four bits. That is, denominator * inv = 1 mod 2^4.\r\n      uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n      // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n      // in modular arithmetic, doubling the correct bits in each step.\r\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n      // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n      // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n      // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n      // is no longer required.\r\n      result = prod0 * inverse;\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n   */\r\n  function mulDiv(\r\n    uint256 x,\r\n    uint256 y,\r\n    uint256 denominator,\r\n    Rounding rounding\r\n  ) internal pure returns (uint256) {\r\n    uint256 result = mulDiv(x, y, denominator);\r\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n      result += 1;\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\nlibrary WadRayMath {\r\n  uint256 internal constant WAD = 1e18;\r\n  uint256 internal constant halfWAD = WAD / 2;\r\n\r\n  uint256 internal constant RAY = 1e27;\r\n  uint256 internal constant halfRAY = RAY / 2;\r\n\r\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\r\n\r\n  /**\r\n   * @return One ray, 1e27\r\n   **/\r\n  function ray() internal pure returns (uint256) {\r\n    return RAY;\r\n  }\r\n\r\n  /**\r\n   * @return One wad, 1e18\r\n   **/\r\n\r\n  function wad() internal pure returns (uint256) {\r\n    return WAD;\r\n  }\r\n\r\n  /**\r\n   * @return Half ray, 1e27/2\r\n   **/\r\n  function halfRay() internal pure returns (uint256) {\r\n    return halfRAY;\r\n  }\r\n\r\n  /**\r\n   * @return Half ray, 1e18/2\r\n   **/\r\n  function halfWad() internal pure returns (uint256) {\r\n    return halfWAD;\r\n  }\r\n\r\n  /**\r\n   * @dev Multiplies two wad, rounding half up to the nearest wad\r\n   * @param a Wad\r\n   * @param b Wad\r\n   * @return The result of a*b, in wad\r\n   **/\r\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0 || b == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return (a * b + halfWAD) / WAD;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two wad, rounding half up to the nearest wad\r\n   * @param a Wad\r\n   * @param b Wad\r\n   * @return The result of a/b, in wad\r\n   **/\r\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 halfB = b / 2;\r\n\r\n    return (a * WAD + halfB) / b;\r\n  }\r\n\r\n  /**\r\n   * @dev Multiplies two ray, rounding half up to the nearest ray\r\n   * @param a Ray\r\n   * @param b Ray\r\n   * @return The result of a*b, in ray\r\n   **/\r\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0 || b == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return (a * b + halfRAY) / RAY;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two ray, rounding half up to the nearest ray\r\n   * @param a Ray\r\n   * @param b Ray\r\n   * @return The result of a/b, in ray\r\n   **/\r\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 halfB = b / 2;\r\n\r\n    return (a * RAY + halfB) / b;\r\n  }\r\n\r\n  /**\r\n   * @dev Casts ray down to wad\r\n   * @param a Ray\r\n   * @return a casted to wad, rounded half up to the nearest wad\r\n   **/\r\n  function rayToWad(uint256 a) internal pure returns (uint256) {\r\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\r\n    uint256 result = halfRatio + a;\r\n\r\n    return result / WAD_RAY_RATIO;\r\n  }\r\n\r\n  /**\r\n   * @dev Converts wad up to ray\r\n   * @param a Wad\r\n   * @return a converted in ray\r\n   **/\r\n  function wadToRay(uint256 a) internal pure returns (uint256) {\r\n    uint256 result = a * WAD_RAY_RATIO;\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nlibrary BalancerswapAdapter2 {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct Path {\r\n    address[] tokens;\r\n    bytes32[] poolIds;\r\n  }\r\n\r\n  address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\r\n\r\n  function swapExactTokensForTokens(\r\n    address assetToSwapFrom,\r\n    address assetToSwapTo,\r\n    uint256 amountToSwap,\r\n    Path calldata path,\r\n    uint256 minAmountOut\r\n  ) external returns (uint256) {\r\n    // Check path is valid\r\n    uint256 length = path.tokens.length;\r\n    require(length > 1 && length - 1 == path.poolIds.length, Errors.VT_SWAP_PATH_LENGTH_INVALID);\r\n    require(\r\n      path.tokens[0] == assetToSwapFrom && path.tokens[length - 1] == assetToSwapTo,\r\n      Errors.VT_SWAP_PATH_TOKEN_INVALID\r\n    );\r\n\r\n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\r\n    IERC20(assetToSwapFrom).safeApprove(address(BALANCER_VAULT), 0);\r\n    if (IERC20(assetToSwapFrom).allowance(address(this), address(BALANCER_VAULT)) == 0)\r\n      IERC20(assetToSwapFrom).safeApprove(address(BALANCER_VAULT), amountToSwap);\r\n\r\n    IBalancerVault.BatchSwapStep[] memory swaps = new IBalancerVault.BatchSwapStep[](length - 1);\r\n    int256[] memory limits = new int256[](length);\r\n    for (uint256 i; i < length - 1; ++i) {\r\n      swaps[i] = IBalancerVault.BatchSwapStep({\r\n        poolId: path.poolIds[i],\r\n        assetInIndex: i,\r\n        assetOutIndex: i + 1,\r\n        amount: 0,\r\n        userData: '0'\r\n      });\r\n    }\r\n    swaps[0].amount = amountToSwap;\r\n    limits[0] = int256(amountToSwap);\r\n    unchecked {\r\n      limits[length - 1] = int256(0 - minAmountOut);\r\n    }\r\n\r\n    IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({\r\n      sender: address(this),\r\n      fromInternalBalance: false,\r\n      recipient: payable(address(this)),\r\n      toInternalBalance: false\r\n    });\r\n\r\n    int256[] memory receivedAmount = IBalancerVault(BALANCER_VAULT).batchSwap(\r\n      IBalancerVault.SwapKind.GIVEN_IN,\r\n      swaps,\r\n      path.tokens,\r\n      funds,\r\n      limits,\r\n      block.timestamp\r\n    );\r\n\r\n    uint256 receivedPositveAmount;\r\n    unchecked {\r\n      receivedPositveAmount = uint256(0 - receivedAmount[length - 1]);\r\n    }\r\n\r\n    require(receivedPositveAmount != 0, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\r\n    require(\r\n      IERC20(assetToSwapTo).balanceOf(address(this)) >= receivedPositveAmount,\r\n      Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT\r\n    );\r\n\r\n    return receivedPositveAmount;\r\n  }\r\n}\r\n\r\n/// @title Callback for IUniswapV3PoolActions#swap\r\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\r\ninterface IUniswapV3SwapCallback {\r\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\r\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\r\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\r\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\r\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\r\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\r\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\r\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\r\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\r\n  function uniswapV3SwapCallback(\r\n    int256 amount0Delta,\r\n    int256 amount1Delta,\r\n    bytes calldata data\r\n  ) external;\r\n}\r\n\r\ninterface ISwapRouter is IUniswapV3SwapCallback {\r\n  struct ExactInputSingleParams {\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint24 fee;\r\n    address recipient;\r\n    uint256 deadline;\r\n    uint256 amountIn;\r\n    uint256 amountOutMinimum;\r\n    uint160 sqrtPriceLimitX96;\r\n  }\r\n\r\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n  /// @return amountOut The amount of the received token\r\n  function exactInputSingle(ExactInputSingleParams calldata params)\r\n    external\r\n    payable\r\n    returns (uint256 amountOut);\r\n\r\n  struct ExactInputParams {\r\n    bytes path;\r\n    address recipient;\r\n    uint256 deadline;\r\n    uint256 amountIn;\r\n    uint256 amountOutMinimum;\r\n  }\r\n\r\n  /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n  /// @return amountOut The amount of the received token\r\n  function exactInput(ExactInputParams calldata params)\r\n    external\r\n    payable\r\n    returns (uint256 amountOut);\r\n\r\n  struct ExactOutputSingleParams {\r\n    address tokenIn;\r\n    address tokenOut;\r\n    uint24 fee;\r\n    address recipient;\r\n    uint256 deadline;\r\n    uint256 amountOut;\r\n    uint256 amountInMaximum;\r\n    uint160 sqrtPriceLimitX96;\r\n  }\r\n\r\n  /// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n  /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n  /// @return amountIn The amount of the input token\r\n  function exactOutputSingle(ExactOutputSingleParams calldata params)\r\n    external\r\n    payable\r\n    returns (uint256 amountIn);\r\n\r\n  struct ExactOutputParams {\r\n    bytes path;\r\n    address recipient;\r\n    uint256 deadline;\r\n    uint256 amountOut;\r\n    uint256 amountInMaximum;\r\n  }\r\n\r\n  /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n  /// @return amountIn The amount of the input token\r\n  function exactOutput(ExactOutputParams calldata params)\r\n    external\r\n    payable\r\n    returns (uint256 amountIn);\r\n}\r\n\r\nlibrary UniswapAdapter2 {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct Path {\r\n    address[] tokens;\r\n    uint256[] fees;\r\n  }\r\n\r\n  function swapExactTokensForTokens(\r\n    ILendingPoolAddressesProvider addressesProvider,\r\n    address assetToSwapFrom,\r\n    address assetToSwapTo,\r\n    uint256 amountToSwap,\r\n    Path calldata path,\r\n    uint256 minAmountOut\r\n  ) external returns (uint256) {\r\n    // Check path is valid\r\n    uint256 length = path.tokens.length;\r\n    require(length > 1 && length - 1 == path.fees.length, Errors.VT_SWAP_PATH_LENGTH_INVALID);\r\n    require(\r\n      path.tokens[0] == assetToSwapFrom && path.tokens[length - 1] == assetToSwapTo,\r\n      Errors.VT_SWAP_PATH_TOKEN_INVALID\r\n    );\r\n\r\n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\r\n    address UNISWAP_ROUTER = addressesProvider.getAddress('uniswapRouter');\r\n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), 0);\r\n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), amountToSwap);\r\n\r\n    uint256 receivedAmount;\r\n    if (length > 2) {\r\n      bytes memory _path;\r\n\r\n      for (uint256 i; i < length - 1; ++i) {\r\n        _path = abi.encodePacked(_path, path.tokens[i], uint24(path.fees[i]));\r\n      }\r\n      _path = abi.encodePacked(_path, assetToSwapTo);\r\n\r\n      ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\r\n        path: _path,\r\n        recipient: address(this),\r\n        deadline: block.timestamp,\r\n        amountIn: amountToSwap,\r\n        amountOutMinimum: minAmountOut\r\n      });\r\n\r\n      // Executes the swap.\r\n      receivedAmount = ISwapRouter(UNISWAP_ROUTER).exactInput(params);\r\n    } else {\r\n      ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\r\n        tokenIn: assetToSwapFrom,\r\n        tokenOut: assetToSwapTo,\r\n        fee: uint24(path.fees[0]),\r\n        recipient: address(this),\r\n        deadline: block.timestamp,\r\n        amountIn: amountToSwap,\r\n        amountOutMinimum: minAmountOut,\r\n        sqrtPriceLimitX96: 0\r\n      });\r\n\r\n      // Executes the swap.\r\n      receivedAmount = ISwapRouter(UNISWAP_ROUTER).exactInputSingle(params);\r\n    }\r\n\r\n    require(receivedAmount != 0, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\r\n    require(\r\n      IERC20(assetToSwapTo).balanceOf(address(this)) >= receivedAmount,\r\n      Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT\r\n    );\r\n\r\n    return receivedAmount;\r\n  }\r\n}\r\n\r\nlibrary CurveswapAdapter2 {\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct Path {\r\n    address[9] routes;\r\n    uint256[3][4] swapParams;\r\n  }\r\n\r\n  address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n  function swapExactTokensForTokens(\r\n    ILendingPoolAddressesProvider addressesProvider,\r\n    address assetToSwapFrom,\r\n    address assetToSwapTo,\r\n    uint256 amountToSwap,\r\n    Path calldata path,\r\n    uint256 minAmountOut\r\n  ) external returns (uint256) {\r\n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\r\n    address curveAddressProvider = addressesProvider.getAddress('CURVE_ADDRESS_PROVIDER');\r\n    address curveExchange = ICurveAddressProvider(curveAddressProvider).get_address(2);\r\n\r\n    IERC20(assetToSwapFrom).safeApprove(address(curveExchange), 0);\r\n    IERC20(assetToSwapFrom).safeApprove(address(curveExchange), amountToSwap);\r\n\r\n    address[4] memory pools;\r\n    uint256 receivedAmount = ICurveExchange(curveExchange).exchange_multiple(\r\n      path.routes,\r\n      path.swapParams,\r\n      amountToSwap,\r\n      minAmountOut,\r\n      pools,\r\n      address(this)\r\n    );\r\n\r\n    require(receivedAmount != 0, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\r\n    uint256 balanceOfAsset;\r\n    if (assetToSwapTo == ETH) {\r\n      balanceOfAsset = address(this).balance;\r\n    } else {\r\n      balanceOfAsset = IERC20(assetToSwapTo).balanceOf(address(this));\r\n    }\r\n    require(balanceOfAsset >= receivedAmount, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\r\n    return receivedAmount;\r\n  }\r\n}\r\n\r\nabstract contract GeneralLevSwap is IFlashLoanReceiver, IFlashLoanRecipient, ReentrancyGuard {\r\n  using SafeERC20 for IERC20;\r\n  using PercentageMath for uint256;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n  using WadRayMath for uint256;\r\n\r\n  uint256 private constant USE_VARIABLE_DEBT = 2;\r\n\r\n  address private constant AAVE_LENDING_POOL_ADDRESS = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;\r\n\r\n  address private constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\r\n\r\n  IVaultWhitelist private constant VAULT_WHITELIST =\r\n    IVaultWhitelist(0x88eE44794bAf865E3b0b192d1F9f0AC3Daf1EA0E);\r\n\r\n  address public immutable COLLATERAL; // The address of external asset\r\n\r\n  uint256 public immutable DECIMALS; // The collateral decimals\r\n\r\n  address public immutable VAULT; // The address of vault\r\n\r\n  ILendingPoolAddressesProvider internal immutable PROVIDER;\r\n\r\n  IPriceOracleGetter internal immutable ORACLE;\r\n\r\n  ILendingPool internal immutable LENDING_POOL;\r\n\r\n  mapping(address => bool) internal ENABLED_BORROW_ASSETS;\r\n\r\n  //1 == not inExec\r\n  //2 == inExec;\r\n  //setting default to 1 to save some gas.\r\n  uint256 private _balancerFlashLoanLock = 1;\r\n\r\n  /**\r\n   * @param _asset The external asset ex. wFTM\r\n   * @param _vault The deployed vault address\r\n   * @param _provider The deployed AddressProvider\r\n   */\r\n  constructor(address _asset, address _vault, address _provider) {\r\n    require(\r\n      _asset != address(0) && _provider != address(0) && _vault != address(0),\r\n      Errors.LS_INVALID_CONFIGURATION\r\n    );\r\n\r\n    COLLATERAL = _asset;\r\n    DECIMALS = IERC20Detailed(_asset).decimals();\r\n    VAULT = _vault;\r\n    PROVIDER = ILendingPoolAddressesProvider(_provider);\r\n    ORACLE = IPriceOracleGetter(PROVIDER.getPriceOracle());\r\n    LENDING_POOL = ILendingPool(PROVIDER.getLendingPool());\r\n    IERC20(COLLATERAL).approve(_vault, type(uint256).max);\r\n  }\r\n\r\n  /**\r\n   * Get borrow coins available to borrow\r\n   */\r\n  function getAvailableBorrowAssets() external pure virtual returns (address[] memory) {\r\n    return new address[](0);\r\n  }\r\n\r\n  /**\r\n   * This function is called after your contract has received the flash loaned amount\r\n   * overriding executeOperation() in IFlashLoanReceiver\r\n   */\r\n  function executeOperation(\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata premiums,\r\n    address initiator,\r\n    bytes calldata params\r\n  ) external override returns (bool) {\r\n    require(initiator == address(this), Errors.LS_INVALID_CONFIGURATION);\r\n    require(msg.sender == AAVE_LENDING_POOL_ADDRESS, Errors.LS_INVALID_CONFIGURATION);\r\n    require(assets.length == amounts.length, Errors.LS_INVALID_CONFIGURATION);\r\n    require(assets.length == premiums.length, Errors.LS_INVALID_CONFIGURATION);\r\n    require(amounts[0] != 0, Errors.LS_INVALID_CONFIGURATION);\r\n    require(assets[0] != address(0), Errors.LS_INVALID_CONFIGURATION);\r\n\r\n    _executeOperation(assets[0], amounts[0], premiums[0], params);\r\n\r\n    // approve the Aave LendingPool contract allowance to *pull* the owed amount\r\n    IERC20(assets[0]).safeApprove(AAVE_LENDING_POOL_ADDRESS, 0);\r\n    IERC20(assets[0]).safeApprove(AAVE_LENDING_POOL_ADDRESS, amounts[0] + premiums[0]);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * This function is called after your contract has received the flash loaned amount\r\n   * overriding receiveFlashLoan() in IFlashLoanRecipient\r\n   */\r\n  function receiveFlashLoan(\r\n    IERC20[] memory tokens,\r\n    uint256[] memory amounts,\r\n    uint256[] memory feeAmounts,\r\n    bytes memory userData\r\n  ) external override {\r\n    require(msg.sender == BALANCER_VAULT, Errors.LS_INVALID_CONFIGURATION);\r\n    require(_balancerFlashLoanLock == 2, Errors.LS_INVALID_CONFIGURATION);\r\n    require(tokens.length == amounts.length, Errors.LS_INVALID_CONFIGURATION);\r\n    require(tokens.length == feeAmounts.length, Errors.LS_INVALID_CONFIGURATION);\r\n    require(amounts[0] != 0, Errors.LS_INVALID_CONFIGURATION);\r\n    require(address(tokens[0]) != address(0), Errors.LS_INVALID_CONFIGURATION);\r\n    _balancerFlashLoanLock = 1;\r\n\r\n    _executeOperation(address(tokens[0]), amounts[0], feeAmounts[0], userData);\r\n\r\n    // send tokens to Balancer vault contract\r\n    IERC20(tokens[0]).safeTransfer(msg.sender, amounts[0] + feeAmounts[0]);\r\n  }\r\n\r\n  function _executeOperation(\r\n    address asset,\r\n    uint256 borrowAmount,\r\n    uint256 fee,\r\n    bytes memory params\r\n  ) internal {\r\n    // parse params\r\n    IGeneralLevSwap.FlashLoanParams memory opsParams = abi.decode(\r\n      params,\r\n      (IGeneralLevSwap.FlashLoanParams)\r\n    );\r\n    require(opsParams.minCollateralAmount != 0, Errors.LS_INVALID_CONFIGURATION);\r\n    require(opsParams.user != address(0), Errors.LS_INVALID_CONFIGURATION);\r\n\r\n    if (opsParams.isEnterPosition) {\r\n      _enterPositionWithFlashloan(asset, borrowAmount, fee, opsParams);\r\n    } else {\r\n      require(opsParams.sAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\r\n      _withdrawWithFlashloan(asset, borrowAmount, opsParams);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param _principal - The amount of collateral\r\n   * @param _leverage - Extra leverage value and must be greater than 0, ex. 300% = 300_00\r\n   *                    _principal + _principal * _leverage should be used as collateral\r\n   * @param _borrowAsset - The borrowing asset address when leverage works\r\n   * @param _flashLoanType - 0 is Aave, 1 is Balancer\r\n   * @param _swapInfo - The uniswap/balancer swap paths between borrowAsset and collateral\r\n   */\r\n  function enterPositionWithFlashloan(\r\n    uint256 _principal,\r\n    uint256 _leverage,\r\n    address _borrowAsset,\r\n    IGeneralLevSwap.FlashLoanType _flashLoanType,\r\n    IGeneralLevSwap.SwapInfo calldata _swapInfo\r\n  ) external nonReentrant {\r\n    require(_principal != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\r\n    require(_leverage != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\r\n    require(_leverage < 900_00, Errors.LS_INVALID_CONFIGURATION);\r\n    require(_borrowAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\r\n    require(ENABLED_BORROW_ASSETS[_borrowAsset], Errors.LS_STABLE_COIN_NOT_SUPPORTED);\r\n    require(IERC20(COLLATERAL).balanceOf(msg.sender) >= _principal, Errors.LS_SUPPLY_NOT_ALLOWED);\r\n    IERC20(COLLATERAL).safeTransferFrom(msg.sender, address(this), _principal);\r\n\r\n    _leverageWithFlashloan(\r\n      IGeneralLevSwap.LeverageParams(\r\n        msg.sender,\r\n        _principal,\r\n        _leverage,\r\n        _borrowAsset,\r\n        _flashLoanType,\r\n        _swapInfo\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param _repayAmount - The amount of repay\r\n   * @param _requiredAmount - The amount of collateral\r\n   * @param _borrowAsset - The borrowing asset address when leverage works\r\n   * @param _sAsset - staked asset address of collateral internal asset\r\n   * @param _flashLoanType - 0 is Aave, 1 is Balancer\r\n   * @param _swapInfo - The uniswap/balancer/curve swap infos between borrowAsset and collateral\r\n   */\r\n  function withdrawWithFlashloan(\r\n    uint256 _repayAmount,\r\n    uint256 _requiredAmount,\r\n    address _borrowAsset,\r\n    address _sAsset,\r\n    IGeneralLevSwap.FlashLoanType _flashLoanType,\r\n    IGeneralLevSwap.SwapInfo calldata _swapInfo\r\n  ) external nonReentrant {\r\n    require(_repayAmount != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\r\n    require(_requiredAmount != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\r\n    require(_borrowAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\r\n    require(ENABLED_BORROW_ASSETS[_borrowAsset], Errors.LS_STABLE_COIN_NOT_SUPPORTED);\r\n    require(_sAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\r\n    require(\r\n      _sAsset ==\r\n        LENDING_POOL.getReserveData(IAToken(_sAsset).UNDERLYING_ASSET_ADDRESS()).aTokenAddress,\r\n      Errors.LS_INVALID_CONFIGURATION\r\n    );\r\n\r\n    uint256[] memory amounts = new uint256[](1);\r\n    amounts[0] = _repayAmount;\r\n\r\n    bytes memory params = abi.encode(\r\n      false /*leavePosition*/,\r\n      _requiredAmount,\r\n      msg.sender,\r\n      _sAsset,\r\n      _swapInfo\r\n    );\r\n\r\n    if (_flashLoanType == IGeneralLevSwap.FlashLoanType.AAVE) {\r\n      // 0 means revert the transaction if not validated\r\n      uint256[] memory modes = new uint256[](1);\r\n      modes[0] = 0;\r\n\r\n      address[] memory assets = new address[](1);\r\n      assets[0] = _borrowAsset;\r\n      IAaveFlashLoan(AAVE_LENDING_POOL_ADDRESS).flashLoan(\r\n        address(this),\r\n        assets,\r\n        amounts,\r\n        modes,\r\n        address(this),\r\n        params,\r\n        0\r\n      );\r\n    } else {\r\n      require(_balancerFlashLoanLock == 1, Errors.LS_INVALID_CONFIGURATION);\r\n      IERC20[] memory assets = new IERC20[](1);\r\n      assets[0] = IERC20(_borrowAsset);\r\n      _balancerFlashLoanLock = 2;\r\n      IBalancerVault(BALANCER_VAULT).flashLoan(address(this), assets, amounts, params);\r\n    }\r\n\r\n    // remained borrow asset -> collateral\r\n    _swapTo(\r\n      _borrowAsset,\r\n      IERC20(_borrowAsset).balanceOf(address(this)),\r\n      _swapInfo.paths,\r\n      _swapInfo.pathLength,\r\n      false\r\n    );\r\n\r\n    uint256 collateralAmount = IERC20(COLLATERAL).balanceOf(address(this));\r\n    if (collateralAmount > _requiredAmount) {\r\n      _supply(collateralAmount - _requiredAmount, msg.sender);\r\n      collateralAmount = _requiredAmount;\r\n    }\r\n\r\n    // finally deliver the collateral to user\r\n    IERC20(COLLATERAL).safeTransfer(msg.sender, collateralAmount);\r\n  }\r\n\r\n  function _enterPositionWithFlashloan(\r\n    address _borrowAsset,\r\n    uint256 _borrowedAmount,\r\n    uint256 _fee,\r\n    IGeneralLevSwap.FlashLoanParams memory _params\r\n  ) internal {\r\n    //swap borrow asset to collateral\r\n    _swapTo(\r\n      _borrowAsset,\r\n      _borrowedAmount,\r\n      _params.swapInfo.paths,\r\n      _params.swapInfo.pathLength,\r\n      true\r\n    );\r\n\r\n    uint256 collateralAmount = IERC20(COLLATERAL).balanceOf(address(this));\r\n    require(collateralAmount >= _params.minCollateralAmount, Errors.LS_SUPPLY_FAILED);\r\n\r\n    //deposit collateral\r\n    _supply(collateralAmount, _params.user);\r\n\r\n    //borrow\r\n    _borrow(_borrowAsset, _borrowedAmount + _fee, _params.user);\r\n  }\r\n\r\n  function _withdrawWithFlashloan(\r\n    address _borrowAsset,\r\n    uint256 _borrowedAmount,\r\n    IGeneralLevSwap.FlashLoanParams memory _params\r\n  ) internal {\r\n    // repay\r\n    _repay(_borrowAsset, _borrowedAmount, _params.user);\r\n\r\n    // withdraw collateral\r\n    // get internal asset address\r\n    address internalAsset = IAToken(_params.sAsset).UNDERLYING_ASSET_ADDRESS();\r\n    // get reserve info of internal asset\r\n    DataTypes.ReserveConfigurationMap memory configuration = LENDING_POOL.getConfiguration(\r\n      internalAsset\r\n    );\r\n    (, uint256 assetLiquidationThreshold, , , ) = configuration.getParamsMemory();\r\n    require(assetLiquidationThreshold != 0, Errors.LS_INVALID_CONFIGURATION);\r\n    // get user info\r\n    (\r\n      uint256 totalCollateralETH,\r\n      uint256 totalDebtETH,\r\n      ,\r\n      uint256 currentLiquidationThreshold,\r\n      ,\r\n\r\n    ) = LENDING_POOL.getUserAccountData(_params.user);\r\n\r\n    uint256 withdrawalAmountETH = (((totalCollateralETH * currentLiquidationThreshold) /\r\n      PercentageMath.PERCENTAGE_FACTOR -\r\n      totalDebtETH) * PercentageMath.PERCENTAGE_FACTOR) / assetLiquidationThreshold;\r\n\r\n    uint256 withdrawalAmount = Math.min(\r\n      IERC20(_params.sAsset).balanceOf(_params.user),\r\n      (withdrawalAmountETH * (10 ** DECIMALS)) / ORACLE.getAssetPrice(COLLATERAL)\r\n    );\r\n\r\n    require(withdrawalAmount >= _params.minCollateralAmount, Errors.LS_SUPPLY_NOT_ALLOWED);\r\n\r\n    IERC20(_params.sAsset).safeTransferFrom(_params.user, address(this), withdrawalAmount);\r\n    _remove(withdrawalAmount, 0, _params.user);\r\n\r\n    // collateral -> borrow asset\r\n    _swapFrom(_borrowAsset, _params.swapInfo.reversePaths, _params.swapInfo.pathLength);\r\n  }\r\n\r\n  function _supply(uint256 _amount, address _user) internal {\r\n    // whitelist checking\r\n    if (VAULT_WHITELIST.whitelistUserCount(VAULT) != 0) {\r\n      require(VAULT_WHITELIST.whitelistUser(VAULT, _user), Errors.CALLER_NOT_WHITELIST_USER);\r\n    }\r\n\r\n    IERC20(COLLATERAL).safeApprove(VAULT, 0);\r\n    IERC20(COLLATERAL).safeApprove(VAULT, _amount);\r\n    IGeneralVault(VAULT).depositCollateralFrom(COLLATERAL, _amount, _user);\r\n  }\r\n\r\n  function _remove(uint256 _amount, uint256 _slippage, address _user) internal {\r\n    // whitelist checking\r\n    if (VAULT_WHITELIST.whitelistUserCount(VAULT) != 0) {\r\n      require(VAULT_WHITELIST.whitelistUser(VAULT, _user), Errors.CALLER_NOT_WHITELIST_USER);\r\n    }\r\n\r\n    IGeneralVault(VAULT).withdrawCollateral(COLLATERAL, _amount, _slippage, address(this));\r\n  }\r\n\r\n  function _borrow(address _borrowAsset, uint256 _amount, address borrower) internal {\r\n    LENDING_POOL.borrow(_borrowAsset, _amount, USE_VARIABLE_DEBT, 0, borrower);\r\n  }\r\n\r\n  function _repay(address _borrowAsset, uint256 _amount, address borrower) internal {\r\n    IERC20(_borrowAsset).safeApprove(address(LENDING_POOL), 0);\r\n    IERC20(_borrowAsset).safeApprove(address(LENDING_POOL), _amount);\r\n\r\n    uint256 paybackAmount = LENDING_POOL.repay(_borrowAsset, _amount, USE_VARIABLE_DEBT, borrower);\r\n    require(paybackAmount != 0, Errors.LS_REPAY_FAILED);\r\n  }\r\n\r\n  /**\r\n   * @param _zappingAsset - The stable coin address which will zap into lp token\r\n   * @param _principal - The amount of collateral\r\n   * @param _zapPaths - The uniswap/balancer/curve swap paths between zappingAsset and collateral\r\n   * @param _zapPathLength - The uniswap/balancer/curve swap path length between zappingAsset and collateral\r\n   */\r\n  function zapDeposit(\r\n    address _zappingAsset,\r\n    uint256 _principal,\r\n    IGeneralLevSwap.MultipSwapPath[3] calldata _zapPaths,\r\n    uint256 _zapPathLength\r\n  ) external nonReentrant {\r\n    require(_principal != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\r\n    require(_zappingAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\r\n    require(ENABLED_BORROW_ASSETS[_zappingAsset], Errors.LS_STABLE_COIN_NOT_SUPPORTED);\r\n    require(\r\n      IERC20(_zappingAsset).balanceOf(msg.sender) >= _principal,\r\n      Errors.LS_SUPPLY_NOT_ALLOWED\r\n    );\r\n\r\n    IERC20(_zappingAsset).safeTransferFrom(msg.sender, address(this), _principal);\r\n\r\n    uint256 suppliedAmount = _swapTo(_zappingAsset, _principal, _zapPaths, _zapPathLength, true);\r\n    // supply to LP\r\n    _supply(suppliedAmount, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @param _zappingAsset - The stable coin address which will zap into lp token\r\n   * @param _principal - The amount of the stable coin\r\n   * @param _leverage - Extra leverage value and must be greater than 0, ex. 300% = 300_00\r\n   *                    principal + principal * leverage should be used as collateral\r\n   * @param _borrowAsset - The borrowing asset address when leverage works\r\n   * @param _flashLoanType - 0 is Aave, 1 is Balancer\r\n   * @param _zapPaths - The uniswap/balancer/curve swap paths between zappingAsset and collateral\r\n   * @param _zapPathLength - The uniswap/balancer/curve swap path length between zappingAsset and collateral\r\n   * @param _swapInfo - The uniswap/balancer/curve swap between borrowAsset and collateral\r\n   */\r\n  function zapLeverageWithFlashloan(\r\n    address _zappingAsset,\r\n    uint256 _principal,\r\n    uint256 _leverage,\r\n    address _borrowAsset,\r\n    IGeneralLevSwap.FlashLoanType _flashLoanType,\r\n    IGeneralLevSwap.MultipSwapPath[3] calldata _zapPaths,\r\n    uint256 _zapPathLength,\r\n    IGeneralLevSwap.SwapInfo calldata _swapInfo\r\n  ) external nonReentrant {\r\n    require(_principal != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\r\n    require(_leverage != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\r\n    require(_leverage < 900_00, Errors.LS_INVALID_CONFIGURATION);\r\n    require(_borrowAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\r\n    require(_zappingAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\r\n    require(ENABLED_BORROW_ASSETS[_zappingAsset], Errors.LS_STABLE_COIN_NOT_SUPPORTED);\r\n    require(ENABLED_BORROW_ASSETS[_borrowAsset], Errors.LS_STABLE_COIN_NOT_SUPPORTED);\r\n    require(\r\n      IERC20(_zappingAsset).balanceOf(msg.sender) >= _principal,\r\n      Errors.LS_SUPPLY_NOT_ALLOWED\r\n    );\r\n\r\n    IERC20(_zappingAsset).safeTransferFrom(msg.sender, address(this), _principal);\r\n\r\n    uint256 collateralAmount = _swapTo(_zappingAsset, _principal, _zapPaths, _zapPathLength, true);\r\n\r\n    _leverageWithFlashloan(\r\n      IGeneralLevSwap.LeverageParams(\r\n        msg.sender,\r\n        collateralAmount,\r\n        _leverage,\r\n        _borrowAsset,\r\n        _flashLoanType,\r\n        _swapInfo\r\n      )\r\n    );\r\n  }\r\n\r\n  function _leverageWithFlashloan(IGeneralLevSwap.LeverageParams memory _params) internal {\r\n    uint256 minCollateralAmount = _params.principal.percentMul(\r\n      PercentageMath.PERCENTAGE_FACTOR + _params.leverage\r\n    );\r\n\r\n    bytes memory params = abi.encode(\r\n      true /*enterPosition*/,\r\n      minCollateralAmount,\r\n      _params.user,\r\n      address(0),\r\n      _params.swapInfo\r\n    );\r\n\r\n    uint256 borrowAssetDecimals = IERC20Detailed(_params.borrowAsset).decimals();\r\n    uint256[] memory amounts = new uint256[](1);\r\n    amounts[0] = _params.swapInfo.paths[0].inAmount;\r\n    if (_params.flashLoanType == IGeneralLevSwap.FlashLoanType.AAVE) {\r\n      // 0 means revert the transaction if not validated\r\n      uint256[] memory modes = new uint256[](1);\r\n      address[] memory assets = new address[](1);\r\n      assets[0] = _params.borrowAsset;\r\n      IAaveFlashLoan(AAVE_LENDING_POOL_ADDRESS).flashLoan(\r\n        address(this),\r\n        assets,\r\n        amounts,\r\n        modes,\r\n        address(this),\r\n        params,\r\n        0\r\n      );\r\n    } else {\r\n      require(_balancerFlashLoanLock == 1, Errors.LS_INVALID_CONFIGURATION);\r\n\r\n      IERC20[] memory assets = new IERC20[](1);\r\n      assets[0] = IERC20(_params.borrowAsset);\r\n      _balancerFlashLoanLock = 2;\r\n      IBalancerVault(BALANCER_VAULT).flashLoan(address(this), assets, amounts, params);\r\n      _balancerFlashLoanLock = 1;\r\n    }\r\n  }\r\n\r\n  function _swapTo(\r\n    address _borrowingAsset,\r\n    uint256 _amount,\r\n    IGeneralLevSwap.MultipSwapPath[3] memory _paths,\r\n    uint256 _pathLength,\r\n    bool _checkOutAmount\r\n  ) internal returns (uint256) {\r\n    require(_pathLength > 0, Errors.LS_INVALID_CONFIGURATION);\r\n    require(_paths[0].swapFrom == _borrowingAsset, Errors.LS_INVALID_CONFIGURATION);\r\n    require(_paths[_pathLength - 1].swapTo == COLLATERAL, Errors.LS_INVALID_CONFIGURATION);\r\n\r\n    uint256 amount = _amount;\r\n    if (amount == 0) return 0;\r\n\r\n    for (uint256 i; i < _pathLength; ++i) {\r\n      if (_paths[i].swapType == IGeneralLevSwap.SwapType.NONE) continue;\r\n      amount = _processSwap(amount, _paths[i], false, _checkOutAmount);\r\n    }\r\n\r\n    return amount;\r\n  }\r\n\r\n  function _swapFrom(\r\n    address _borrowingAsset,\r\n    IGeneralLevSwap.MultipSwapPath[3] memory _paths,\r\n    uint256 _pathLength\r\n  ) internal returns (uint256) {\r\n    require(_pathLength > 0, Errors.LS_INVALID_CONFIGURATION);\r\n    require(_paths[0].swapFrom == COLLATERAL, Errors.LS_INVALID_CONFIGURATION);\r\n    require(_paths[_pathLength - 1].swapTo == _borrowingAsset, Errors.LS_INVALID_CONFIGURATION);\r\n\r\n    uint256 amount = IERC20(COLLATERAL).balanceOf(address(this));\r\n    if (amount == 0) return 0;\r\n\r\n    for (uint256 i; i < _pathLength; ++i) {\r\n      if (_paths[i].swapType == IGeneralLevSwap.SwapType.NONE) continue;\r\n      amount = _processSwap(amount, _paths[i], true, true);\r\n    }\r\n\r\n    return amount;\r\n  }\r\n\r\n  function _swapByPath(\r\n    uint256 _fromAmount,\r\n    IGeneralLevSwap.MultipSwapPath memory _path,\r\n    bool _checkOutAmount\r\n  ) internal returns (uint256) {\r\n    uint256 poolCount = _path.poolCount;\r\n    uint256 outAmount = _checkOutAmount ? _path.outAmount : 0;\r\n    require(poolCount > 0, Errors.LS_INVALID_CONFIGURATION);\r\n\r\n    if (_path.swapType == IGeneralLevSwap.SwapType.BALANCER) {\r\n      // Balancer Swap\r\n      BalancerswapAdapter2.Path memory path;\r\n      path.tokens = new address[](poolCount + 1);\r\n      path.poolIds = new bytes32[](poolCount);\r\n\r\n      for (uint256 i; i < poolCount; ++i) {\r\n        path.tokens[i] = _path.routes[i * 2];\r\n        path.poolIds[i] = bytes32(_path.routeParams[i][0]);\r\n      }\r\n      path.tokens[poolCount] = _path.routes[poolCount * 2];\r\n\r\n      return\r\n        BalancerswapAdapter2.swapExactTokensForTokens(\r\n          _path.swapFrom,\r\n          _path.swapTo,\r\n          _fromAmount,\r\n          path,\r\n          outAmount\r\n        );\r\n    }\r\n\r\n    if (_path.swapType == IGeneralLevSwap.SwapType.UNISWAP) {\r\n      // UniSwap\r\n      UniswapAdapter2.Path memory path;\r\n      path.tokens = new address[](poolCount + 1);\r\n      path.fees = new uint256[](poolCount);\r\n\r\n      for (uint256 i; i < poolCount; ++i) {\r\n        path.tokens[i] = _path.routes[i * 2];\r\n        path.fees[i] = _path.routeParams[i][0];\r\n      }\r\n      path.tokens[poolCount] = _path.routes[poolCount * 2];\r\n\r\n      return\r\n        UniswapAdapter2.swapExactTokensForTokens(\r\n          PROVIDER,\r\n          _path.swapFrom,\r\n          _path.swapTo,\r\n          _fromAmount,\r\n          path,\r\n          outAmount\r\n        );\r\n    }\r\n\r\n    // Curve Swap\r\n    return\r\n      CurveswapAdapter2.swapExactTokensForTokens(\r\n        PROVIDER,\r\n        _path.swapFrom,\r\n        _path.swapTo,\r\n        _fromAmount,\r\n        CurveswapAdapter2.Path(_path.routes, _path.routeParams),\r\n        outAmount\r\n      );\r\n  }\r\n\r\n  function _processSwap(\r\n    uint256,\r\n    IGeneralLevSwap.MultipSwapPath memory,\r\n    bool,\r\n    bool\r\n  ) internal virtual returns (uint256);\r\n}\r\n\r\ncontract FRAXUSDCLevSwap is GeneralLevSwap {\r\n  address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n  address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n  address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n\r\n  constructor(\r\n    address _asset,\r\n    address _vault,\r\n    address _provider\r\n  ) GeneralLevSwap(_asset, _vault, _provider) {\r\n    ENABLED_BORROW_ASSETS[DAI] = true;\r\n    ENABLED_BORROW_ASSETS[USDC] = true;\r\n    ENABLED_BORROW_ASSETS[USDT] = true;\r\n  }\r\n\r\n  function getAvailableBorrowAssets() external pure override returns (address[] memory assets) {\r\n    assets = new address[](3);\r\n    assets[0] = DAI;\r\n    assets[1] = USDC;\r\n    assets[2] = USDT;\r\n  }\r\n\r\n  // FRAXUSDC <-> borrowing asset\r\n  function _processSwap(\r\n    uint256 _amount,\r\n    IGeneralLevSwap.MultipSwapPath memory _path,\r\n    bool,\r\n    bool _checkOutAmount\r\n  ) internal override returns (uint256) {\r\n    return _swapByPath(_amount, _path, _checkOutAmount);\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"COLLATERAL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_leverage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowAsset\",\"type\":\"address\"},{\"internalType\":\"enum IGeneralLevSwap.FlashLoanType\",\"name\":\"_flashLoanType\",\"type\":\"uint8\"},{\"components\":[{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"paths\",\"type\":\"tuple[3]\"},{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"reversePaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256\",\"name\":\"pathLength\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.SwapInfo\",\"name\":\"_swapInfo\",\"type\":\"tuple\"}],\"name\":\"enterPositionWithFlashloan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"premiums\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableBorrowAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"feeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"receiveFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_requiredAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sAsset\",\"type\":\"address\"},{\"internalType\":\"enum IGeneralLevSwap.FlashLoanType\",\"name\":\"_flashLoanType\",\"type\":\"uint8\"},{\"components\":[{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"paths\",\"type\":\"tuple[3]\"},{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"reversePaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256\",\"name\":\"pathLength\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.SwapInfo\",\"name\":\"_swapInfo\",\"type\":\"tuple\"}],\"name\":\"withdrawWithFlashloan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_zappingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_principal\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"_zapPaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256\",\"name\":\"_zapPathLength\",\"type\":\"uint256\"}],\"name\":\"zapDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_zappingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_leverage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowAsset\",\"type\":\"address\"},{\"internalType\":\"enum IGeneralLevSwap.FlashLoanType\",\"name\":\"_flashLoanType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"_zapPaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256\",\"name\":\"_zapPathLength\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"paths\",\"type\":\"tuple[3]\"},{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"reversePaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256\",\"name\":\"pathLength\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.SwapInfo\",\"name\":\"_swapInfo\",\"type\":\"tuple\"}],\"name\":\"zapLeverageWithFlashloan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FRAXUSDCLevSwap", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003175df0976dfa876431c2e9ee6bc45b65d3473cc000000000000000000000000f8c91e5bffdd79ef7d1d6f9ae3391e021ffcbd73000000000000000000000000b7499a92fc36e9053a4324affae59d333635d9c3", "EVMVersion": "Default", "Library": "BalancerswapAdapter2:c0ddd95419e2375b7cdc9c12a8db464584e158f3;UniswapAdapter2:31d5b63b54259b37e74c767706f135ac1c9b8879;CurveswapAdapter2:31780cc26c7c66a7a72bde665147de4001b302ec", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0e4b604563efdf0c3c44ab369961f2dc8d4a577fdeca525cf5285005a7b341f7"}