{"SourceCode": "// SPDX-License-Identifier: BUSL-1.1\r\n// File: lib/ipor-protocol/contracts/amm-eth/interfaces/IAmmPoolsLensEth.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n/// @title Interface of the AmmPoolsLensEth contract.\r\ninterface IAmmPoolsLensEth {\r\n    /// @notice Retrieves the exchange rate between stEth and ipstEth using the AmmLibEth library.\r\n    /// @return The exchange rate calculated based on the balance of stEth in the AMM Treasury and the total supply of ipstEth.\r\n    /// @dev This function acts as a wrapper around the `getExchangeRate` function in the AmmLibEth library.\r\n    function getIpstEthExchangeRate() external view returns (uint256);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/libraries/errors/IporErrors.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\nlibrary IporErrors {\r\n    // 000-199 - general codes\r\n\r\n    /// @notice General problem, address is wrong\r\n    string public constant WRONG_ADDRESS = \"IPOR_000\";\r\n\r\n    /// @notice General problem. Wrong decimals\r\n    string public constant WRONG_DECIMALS = \"IPOR_001\";\r\n\r\n    /// @notice General problem, addresses mismatch\r\n    string public constant ADDRESSES_MISMATCH = \"IPOR_002\";\r\n\r\n    /// @notice Sender's asset balance is too low to transfer and to open a swap\r\n    string public constant SENDER_ASSET_BALANCE_TOO_LOW = \"IPOR_003\";\r\n\r\n    /// @notice Value is not greater than zero\r\n    string public constant VALUE_NOT_GREATER_THAN_ZERO = \"IPOR_004\";\r\n\r\n    /// @notice Input arrays length mismatch\r\n    string public constant INPUT_ARRAYS_LENGTH_MISMATCH = \"IPOR_005\";\r\n\r\n    /// @notice Amount is too low to transfer\r\n    string public constant NOT_ENOUGH_AMOUNT_TO_TRANSFER = \"IPOR_006\";\r\n\r\n    /// @notice msg.sender is not an appointed owner, so cannot confirm his appointment to be an owner of a specific smart contract\r\n    string public constant SENDER_NOT_APPOINTED_OWNER = \"IPOR_007\";\r\n\r\n    /// @notice only Router can have access to function\r\n    string public constant CALLER_NOT_IPOR_PROTOCOL_ROUTER = \"IPOR_008\";\r\n\r\n    /// @notice Chunk size is equal to zero\r\n    string public constant CHUNK_SIZE_EQUAL_ZERO = \"IPOR_009\";\r\n\r\n    /// @notice Chunk size is too big\r\n    string public constant CHUNK_SIZE_TOO_BIG = \"IPOR_010\";\r\n\r\n    /// @notice Caller is not a  guardian\r\n    string public constant CALLER_NOT_GUARDIAN = \"IPOR_011\";\r\n\r\n    /// @notice Request contains invalid method signature, which is not supported by the Ipor Protocol Router\r\n    string public constant ROUTER_INVALID_SIGNATURE = \"IPOR_012\";\r\n\r\n    /// @notice Only AMM Treasury can have access to function\r\n    string public constant CALLER_NOT_AMM_TREASURY = \"IPOR_013\";\r\n\r\n    /// @notice Caller is not an owner\r\n    string public constant CALLER_NOT_OWNER = \"IPOR_014\";\r\n\r\n    /// @notice Method is paused\r\n    string public constant METHOD_PAUSED = \"IPOR_015\";\r\n\r\n    /// @notice Reentrancy appears\r\n    string public constant REENTRANCY = \"IPOR_016\";\r\n\r\n    /// @notice Asset is not supported\r\n    string public constant ASSET_NOT_SUPPORTED = \"IPOR_017\";\r\n\r\n    /// @notice Return back ETH failed in Ipor Protocol Router\r\n    string public constant ROUTER_RETURN_BACK_ETH_FAILED = \"IPOR_018\";\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/libraries/IporContractValidator.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\nlibrary IporContractValidator {\r\n    function checkAddress(address addr) internal pure returns (address) {\r\n        require(addr != address(0), IporErrors.WRONG_ADDRESS);\r\n        return addr;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/amm-eth/interfaces/IStETH.sol\r\n\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n/// @title Interface of the StETH contract.\r\ninterface IStETH is IERC20 {\r\n    function submit(address _referral) external payable returns (uint256);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/interfaces/IIpToken.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n/// @title Interface of ipToken - Liquidity Pool Token managed by Router in IPOR Protocol for a given asset.\r\n/// For more information refer to the documentation https://ipor-labs.gitbook.io/ipor-labs/automated-market-maker/liquidity-provisioning#liquidity-tokens\r\ninterface IIpToken is IERC20 {\r\n    /// @notice Gets the asset / stablecoin address which is associated with particular ipToken smart contract instance\r\n    /// @return asset / stablecoin address\r\n    function getAsset() external view returns (address);\r\n\r\n    /// @notice Gets the Token Manager's address.\r\n    function getTokenManager() external view returns (address);\r\n\r\n    /// @notice Sets token manager's address. IpToken contract Owner only\r\n    /// @dev only Token Manager can mint or burn ipTokens. Function emits `TokenManagerChanged` event.\r\n    /// @param newTokenManager Token Managers's address\r\n    function setTokenManager(address newTokenManager) external;\r\n\r\n    /// @notice Creates the ipTokens in the `amount` given and assigns them to the `account`\r\n    /// @dev Emits {Transfer} from ERC20 asset and {Mint} event from ipToken\r\n    /// @param account to which the created ipTokens were assigned\r\n    /// @param amount volume of ipTokens created\r\n    function mint(address account, uint256 amount) external;\r\n\r\n    /// @notice Burns the `amount` of ipTokens from `account`, reducing the total supply\r\n    /// @dev Emits {Transfer} from ERC20 asset and {Burn} event from ipToken\r\n    /// @param account from which burned ipTokens are taken\r\n    /// @param amount volume of ipTokens that will be burned, represented in 18 decimals\r\n    function burn(address account, uint256 amount) external;\r\n\r\n    /// @notice Emitted after the `amount` ipTokens were mint and transferred to `account`.\r\n    /// @param account address where ipTokens are transferred after minting\r\n    /// @param amount of ipTokens minted, represented in 18 decimals\r\n    event Mint(address indexed account, uint256 amount);\r\n\r\n    /// @notice Emitted after `amount` ipTokens were transferred from `account` and burnt.\r\n    /// @param account address from which ipTokens are transferred to be burned\r\n    /// @param amount volume of ipTokens burned\r\n    event Burn(address indexed account, uint256 amount);\r\n\r\n    /// @notice Emitted when Token Manager address is changed by its owner.\r\n    /// @param newTokenManager new address of Token Manager\r\n    event TokenManagerChanged(address indexed newTokenManager);\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/libraries/math/IporMath.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\nlibrary IporMath {\r\n    uint256 private constant RAY = 1e27;\r\n\r\n    //@notice Division with rounding up on last position, x, and y is with MD\r\n    function division(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = (x + (y / 2)) / y;\r\n    }\r\n\r\n    function divisionInt(int256 x, int256 y) internal pure returns (int256 z) {\r\n        uint256 absX = uint256(x < 0 ? -x : x);\r\n        uint256 absY = uint256(y < 0 ? -y : y);\r\n\r\n        // Use bitwise XOR to get the sign on MBS bit then shift to LSB\r\n        // sign == 0x0000...0000 ==  0 if the number is non-negative\r\n        // sign == 0xFFFF...FFFF == -1 if the number is negative\r\n        int256 sign = (x ^ y) >> 255;\r\n\r\n        uint256 divAbs;\r\n        uint256 remainder;\r\n\r\n        unchecked {\r\n            divAbs = absX / absY;\r\n            remainder = absX % absY;\r\n        }\r\n        // Check if we need to round\r\n        if (sign < 0) {\r\n            // remainder << 1 left shift is equivalent to multiplying by 2\r\n            if (remainder << 1 > absY) {\r\n                ++divAbs;\r\n            }\r\n        } else {\r\n            if (remainder << 1 >= absY) {\r\n                ++divAbs;\r\n            }\r\n        }\r\n\r\n        // (sign | 1) is cheaper than (sign < 0) ? -1 : 1;\r\n        unchecked {\r\n            z = int256(divAbs) * (sign | 1);\r\n        }\r\n    }\r\n\r\n    function divisionWithoutRound(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x / y;\r\n    }\r\n\r\n    function convertWadToAssetDecimals(uint256 value, uint256 assetDecimals) internal pure returns (uint256) {\r\n        if (assetDecimals == 18) {\r\n            return value;\r\n        } else if (assetDecimals > 18) {\r\n            return value * 10 ** (assetDecimals - 18);\r\n        } else {\r\n            return division(value, 10 ** (18 - assetDecimals));\r\n        }\r\n    }\r\n\r\n    function convertWadToAssetDecimalsWithoutRound(\r\n        uint256 value,\r\n        uint256 assetDecimals\r\n    ) internal pure returns (uint256) {\r\n        if (assetDecimals == 18) {\r\n            return value;\r\n        } else if (assetDecimals > 18) {\r\n            return value * 10 ** (assetDecimals - 18);\r\n        } else {\r\n            return divisionWithoutRound(value, 10 ** (18 - assetDecimals));\r\n        }\r\n    }\r\n\r\n    function convertToWad(uint256 value, uint256 assetDecimals) internal pure returns (uint256) {\r\n        if (value > 0) {\r\n            if (assetDecimals == 18) {\r\n                return value;\r\n            } else if (assetDecimals > 18) {\r\n                return division(value, 10 ** (assetDecimals - 18));\r\n            } else {\r\n                return value * 10 ** (18 - assetDecimals);\r\n            }\r\n        } else {\r\n            return value;\r\n        }\r\n    }\r\n\r\n    function absoluteValue(int256 value) internal pure returns (uint256) {\r\n        return (uint256)(value < 0 ? -value : value);\r\n    }\r\n\r\n    function percentOf(uint256 value, uint256 rate) internal pure returns (uint256) {\r\n        return division(value * rate, 1e18);\r\n    }\r\n\r\n    /// @notice Calculates x^n where x and y are represented in RAY (27 decimals)\r\n    /// @param x base, represented in 27 decimals\r\n    /// @param n exponent, represented in 27 decimals\r\n    /// @return z x^n represented in 27 decimals\r\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch x\r\n            case 0 {\r\n                switch n\r\n                case 0 {\r\n                    z := RAY\r\n                }\r\n                default {\r\n                    z := 0\r\n                }\r\n            }\r\n            default {\r\n                switch mod(n, 2)\r\n                case 0 {\r\n                    z := RAY\r\n                }\r\n                default {\r\n                    z := x\r\n                }\r\n                let half := div(RAY, 2) // for rounding.\r\n                for {\r\n                    n := div(n, 2)\r\n                } n {\r\n                    n := div(n, 2)\r\n                } {\r\n                    let xx := mul(x, x)\r\n                    if iszero(eq(div(xx, x), x)) {\r\n                        revert(0, 0)\r\n                    }\r\n                    let xxRound := add(xx, half)\r\n                    if lt(xxRound, xx) {\r\n                        revert(0, 0)\r\n                    }\r\n                    x := div(xxRound, RAY)\r\n                    if mod(n, 2) {\r\n                        let zx := mul(z, x)\r\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\r\n                            revert(0, 0)\r\n                        }\r\n                        let zxRound := add(zx, half)\r\n                        if lt(zxRound, zx) {\r\n                            revert(0, 0)\r\n                        }\r\n                        z := div(zxRound, RAY)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/amm-eth/AmmLibEth.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n\r\n\r\n/// @title Library for AMM operations with ETH.\r\nlibrary AmmLibEth {\r\n    /// @notice Retrieves the exchange rate between stEth and ipstETH.\r\n    /// @param stEth Address of the stEth token.\r\n    /// @param ipstEth Address of the IP Token of stETH.\r\n    /// @param ammTreasuryEth Address of the AMM Treasury for stEth.\r\n    /// @dev The exchange rate is calculated based on the balance of stEth in the AMM Treasury and the total supply of ipstEth.\r\n    /// If the total supply of ipstEth is zero, the function returns 1e18.\r\n    function getExchangeRate(address stEth, address ipstEth, address ammTreasuryEth) internal view returns (uint256) {\r\n        uint256 ipTokenTotalSupply = IIpToken(ipstEth).totalSupply();\r\n\r\n        if (ipTokenTotalSupply > 0) {\r\n            return IporMath.division(IStETH(stEth).balanceOf(ammTreasuryEth) * 1e18, ipTokenTotalSupply);\r\n        } else {\r\n            return 1e18;\r\n        }\r\n    }\r\n}\r\n\r\n// File: lib/ipor-protocol/contracts/amm-eth/AmmPoolsLensEth.sol\r\n\r\n\r\npragma solidity 0.8.20;\r\n\r\n\r\n\r\n\r\n/// @dev It is not recommended to use lens contract directly, should be used only through IporProtocolRouter.\r\ncontract AmmPoolsLensEth is IAmmPoolsLensEth {\r\n    using IporContractValidator for address;\r\n\r\n    address public immutable stEth;\r\n    address public immutable ipstEth;\r\n    address public immutable ammTreasuryEth;\r\n\r\n    constructor(address stEthInput, address ipstEthInput, address ammTreasuryEthInput) {\r\n        stEth = stEthInput.checkAddress();\r\n        ipstEth = ipstEthInput.checkAddress();\r\n        ammTreasuryEth = ammTreasuryEthInput.checkAddress();\r\n    }\r\n\r\n    function getIpstEthExchangeRate() external view returns (uint256) {\r\n        return AmmLibEth.getExchangeRate(stEth, ipstEth, ammTreasuryEth);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stEthInput\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ipstEthInput\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ammTreasuryEthInput\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ammTreasuryEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIpstEthExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ipstEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AmmPoolsLensEth", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ae7ab96520de3a18e5e111b5eaab095312d7fe84000000000000000000000000c40431b6c510aeb45fbb5e21e40d49f12b0c1f0c00000000000000000000000063395edaf74a80aa1155db7cd9bba976a88dee4e", "EVMVersion": "paris", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d65f8d79e7bc0b8a167ab12ba0c08d4327ff861c6b1d76f49171d03a5c87e4de"}