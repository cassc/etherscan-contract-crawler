{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"remappings\": []\r\n  },\r\n  \"sources\": {\r\n    \"contracts/ExternalRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.19;\\n\\nimport { Math } from \\\"./libraries/Math-sol-8.19.sol\\\";\\n\\ninterface IERC20 {\\n    function balanceOf(address) external view returns (uint256);\\n}\\ninterface IUniswapV2Pair {\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IUniswapV3Pair {\\n    function slot0() external view returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n    );\\n    function liquidity() external view returns (uint128);\\n    function ticks(int24 tick) external view  returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            uint256 feeGrowthOutside0X128,\\n            uint256 feeGrowthOutside1X128,\\n            int56 tickCumulativeOutside,\\n            uint160 secondsPerLiquidityOutsideX128,\\n            uint32 secondsOutside,\\n            bool initialized\\n    );\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n    function positions(bytes32 key) external view returns (\\n            uint128 _liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n    );\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function fee() external view returns (uint24);\\n    function tickSpacing() external view returns (int24);\\n    function maxLiquidityPerTick() external view returns (uint128);\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n}\\n\\ninterface IPair {\\n\\n    function amountIn(address output, uint _amountOut, address caller) external view returns (uint _amountIn);\\n    function amountOut(address input, uint _amountIn, address caller) external view returns (uint _amountOut);\\n    function swap(\\n        address to,\\n        address caller,\\n        address factory\\n    ) external returns (uint);\\n    function borrow(address to, uint _amountOut, bool isToken0, bytes calldata data) external;\\n    function getReserves() external view returns (\\n        uint112 _reserve0, \\n        uint112 _reserve1, \\n        uint32 _blockTimestampLast\\n    );\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function factory() external view returns (address);\\n}\\ninterface IGenerator {\\n    struct Info {\\n        address owner;\\n        uint16 burnFee;\\n        address burnToken;\\n        uint16 teamFee;\\n        address teamAddress;\\n        uint16 lpFee;\\n        address referrer;\\n        uint16 referFee;\\n        uint16 labFee;\\n    }\\n    function factoryInfo(address) external view returns (Info memory);\\n    function FEE_DENOMINATOR() external view returns (uint16);\\n}\\ninterface IFactory {\\n    function generator() external view returns (address);\\n}\\ncontract ExternalRouter {\\n\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n    event FeeCollected(address indexed collected, address indexed token, uint amount, address indexed factory);\\n    struct SwapCallbackData {\\n        address payer;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 maxAmountIn;\\n    }\\n\\n    struct SwapParameters {\\n        address pair;\\n        address input;\\n        uint48 fee;\\n        uint160 sqrtPriceLimitX96;\\n        uint256 minOutput;\\n        int8 swapType;\\n    }\\n\\n    bool private _swapping;\\n\\n    modifier inSwap() {\\n        require(_swapping, \\\"Router: must be in swap\\\");\\n        _;\\n    }\\n\\n    modifier swapping() {  \\n        _swapping = true;\\n        _;\\n        _swapping = false;\\n    }\\n\\n    modifier ensure(uint deadline) {\\n        require(deadline >= block.timestamp, \\\"EXPIRED\\\");\\n        _;\\n    }\\n\\n    function pancakeV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external inSwap() { //ensure that we are in a swap currently before just sending stuff places.\\n        _v3Callback(amount0Delta, amount1Delta, data);\\n    }\\n\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata _data\\n    ) external inSwap() { //ensure that we are in a swap currently before just sending stuff places.\\n        _v3Callback(amount0Delta, amount1Delta, _data);\\n    }\\n\\n    function _v3Callback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata _data\\n    ) internal {\\n        require(amount0Delta > 0 || amount1Delta > 0, \\\"Invalid output\\\"); // swaps entirely within 0-liquidity regions are not supported\\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\\n        uint256 amountToPay = amount0Delta > 0 ? uint256(amount0Delta) : uint256(amount1Delta);\\n        require(data.maxAmountIn <= amountToPay, \\\"Invalid input amount\\\"); //ensure they are not trying to take more than we intended.\\n        assert(data.payer == address(this) || data.payer == tx.origin); //ensure that the payer is either us or the original caller.\\n        if (data.payer == address(this)) {\\n            safeTransfer(data.tokenIn, msg.sender, amountToPay);\\n        } else {\\n            safeTransferFrom(data.tokenIn, data.payer, msg.sender, amountToPay);\\n        }\\n    }\\n\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max));\\n        return int256(value);\\n    }\\n\\n    function _swapV3(address pairAddress, address input, uint256 inputAmount, uint160 sqrtPriceLimitX96, uint256 minOutput, address to, address from) internal returns (uint256 outputAmount) { //exactInput\\n        IUniswapV3Pair pair = IUniswapV3Pair(pairAddress);\\n        address token0 = pair.token0();\\n        address token1 = pair.token1();\\n        bool zeroForOne = token0 == input;\\n        int256 amount0;\\n        int256 amount1;\\n        address _input = input;\\n        uint256 _inputAmount = inputAmount;\\n        {\\n            (amount0, amount1) = pair.swap(\\n                to,\\n                zeroForOne,\\n                toInt256(_inputAmount),\\n                sqrtPriceLimitX96 == 0 ? (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1) : sqrtPriceLimitX96,\\n                abi.encode(SwapCallbackData(from, _input, zeroForOne ? token1 : token0, _inputAmount))\\n            );\\n        }\\n        outputAmount = uint256(-(zeroForOne ? amount1 : amount0));\\n        require(outputAmount >= minOutput, \\\"S3:IO\\\");\\n    }\\n\\n    function _swapV2(\\n        address pairAddress,\\n        address input,\\n        uint256 inputAmount,\\n        uint256 minOutput,\\n        uint48 fee,\\n        address to,\\n        bool multihop\\n    ) internal returns (uint256 amountOutput) { //exactInput\\n        if (!multihop) safeTransferFrom(input, msg.sender, pairAddress, inputAmount);\\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\\n        address token0 = pair.token0();\\n        bool isInputToken0 = token0 == input;\\n        {\\n            (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\\n            (uint256 reserveInput, uint256 reserveOutput) = isInputToken0  ? (reserve0, reserve1)  : (reserve1, reserve0);\\n            inputAmount = IERC20(input).balanceOf(pairAddress) - reserveInput;\\n            uint amountInMinusFee = inputAmount * (10000 - fee);\\n            uint256 numerator = amountInMinusFee * reserveOutput;\\n            uint256 denominator = reserveInput * 10000 + amountInMinusFee;\\n            amountOutput = numerator / denominator;\\n        }\\n        require(amountOutput >= minOutput, \\\"S2:IO\\\");\\n        (uint256 amount0Out, uint256 amount1Out) = isInputToken0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));\\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\\n    }\\n\\n\\n    function _swap(\\n        address pair,\\n        address input,\\n        uint256 inputAmount,\\n        uint256 minOutput,\\n        address to,\\n        bool multihop\\n    ) internal returns (uint256 amountOut) {\\n        if (!multihop) safeTransferFrom(input, msg.sender, pair, inputAmount);\\n        amountOut = IPair(pair).swap(to, msg.sender, address(this));\\n        require(amountOut >= minOutput, \\\"S:IO\\\");\\n    }\\n\\n    function _takeFees(address input, uint256 amountIn, address f) internal returns (uint256) {\\n        address generator = IFactory(f).generator();\\n        IGenerator gen = IGenerator(generator);\\n        IGenerator.Info memory fees = gen.factoryInfo(f);\\n        uint16 totalFee = fees.teamFee + fees.referFee + fees.labFee;\\n        if (totalFee > 0) {\\n            uint amountFee = Math.muldiv(amountIn, totalFee, gen.FEE_DENOMINATOR());\\n            amountIn -= amountFee;\\n            if (amountFee > 0) {\\n                uint256 amountTeam;\\n                if (fees.teamFee > 0) {\\n                    amountTeam = Math.muldiv(amountFee, fees.teamFee, totalFee);\\n                    safeTransferFrom(input, msg.sender, fees.teamAddress, amountTeam);\\n                    emit FeeCollected(fees.teamAddress, input, amountTeam, f);\\n                }\\n                uint256 amountRefer;\\n                if (fees.referFee > 0) {\\n                    amountRefer = Math.min(amountFee - amountTeam, Math.muldiv(amountFee, fees.referFee, totalFee));\\n                    if (amountRefer > 0) {\\n                        safeTransferFrom(input, msg.sender, fees.referrer, amountRefer);\\n                        emit FeeCollected(fees.referrer, input, amountRefer, f);\\n                    }\\n                }\\n                if (fees.labFee > 0) {\\n                    uint labAmount = amountFee - amountTeam - amountRefer;\\n                    if (labAmount > 0) {                       \\n                        address team = gen.factoryInfo(generator).teamAddress;\\n                        safeTransferFrom(input, msg.sender, team, labAmount);\\n                        emit FeeCollected(team, input, labAmount, generator);\\n                    }\\n                }\\n            }\\n        }\\n        return amountIn;\\n    }\\n\\n    function swapWithFees(\\n        uint256 inputAmount,\\n        SwapParameters[] memory swaps,\\n        address to,\\n        uint deadline,\\n        address f\\n    ) external ensure(deadline) swapping() {\\n        uint amountIn = _takeFees(swaps[0].input, inputAmount, f);\\n        for (uint i; i < swaps.length; i++) {\\n            address _to = i == swaps.length - 1 ? to : (swaps[i+1].swapType != 2 ? swaps[i+1].pair : address(this));\\n            if (swaps[i].swapType == 1) {\\n                amountIn = _swapV2(swaps[i].pair, swaps[i].input, amountIn, swaps[i].minOutput, swaps[i].fee, _to, i != 0);\\n            } else if (swaps[i].swapType == 2) {\\n                amountIn = _swapV3(swaps[i].pair, swaps[i].input, amountIn, swaps[i].sqrtPriceLimitX96, swaps[i].minOutput, _to, i == 0 ? msg.sender : address(this));\\n            } else {\\n                amountIn = _swap(swaps[i].pair, swaps[i].input, amountIn, swaps[i].minOutput, _to, i != 0);\\n            }\\n        }\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper: transferFrom failed\\\"\\n        );\\n    }\\n\\n  function safeTransfer(\\n    address token,\\n    address to,\\n    uint256 value\\n) internal {\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n    require(\\n      success && (data.length == 0 || abi.decode(data, (bool))),\\n      \\\"TransferHelper::safeTransfer: transfer failed\\\"\\n    );\\n  }\\n    \\n}\"\r\n    },\r\n    \"contracts/libraries/Math-sol-8.19.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n/// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function muldiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2**256.\\n        // Also prevents denominator == 0\\n        require(denominator > prod1);\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0]\\n        // Compute remainder using mulmod\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        // Subtract 256 bit number from 512 bit number\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator\\n        // Compute largest power of two divisor of denominator.\\n        // Always >= 1.\\n        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n        // Divide denominator by power of two\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        // Divide [prod1 prod0] by the factors of two\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        // Shift in bits from prod1 into prod0. For this we need\\n        // to flip `twos` such that it is 2**256 / twos.\\n        // If twos is zero, then it becomes one\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        // Invert denominator mod 2**256\\n        // Now that denominator is an odd number, it has an inverse\\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n        // Compute the inverse by starting with a seed that is correct\\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n        uint256 inv = (3 * denominator) ^ 2;\\n        // Now use Newton-Raphson iteration to improve the precision.\\n        // Thanks to Hensel's lifting lemma, this also works in modular\\n        // arithmetic, doubling the correct bits in each step.\\n        inv *= 2 - denominator * inv; // inverse mod 2**8\\n        inv *= 2 - denominator * inv; // inverse mod 2**16\\n        inv *= 2 - denominator * inv; // inverse mod 2**32\\n        inv *= 2 - denominator * inv; // inverse mod 2**64\\n        inv *= 2 - denominator * inv; // inverse mod 2**128\\n        inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n        // Because the division is now exact we can divide by multiplying\\n        // with the modular inverse of denominator. This will give us the\\n        // correct result modulo 2**256. Since the precoditions guarantee\\n        // that the outcome is less than 2**256, this is the final result.\\n        // We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = muldiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collected\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"pancakeV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"fee\",\"type\":\"uint48\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"},{\"internalType\":\"uint256\",\"name\":\"minOutput\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"swapType\",\"type\":\"int8\"}],\"internalType\":\"struct ExternalRouter.SwapParameters[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"}],\"name\":\"swapWithFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ExternalRouter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5e4829b3ae117ab32521a6cb126d2742c760b36cde710c25c06f8d8691104f5b"}