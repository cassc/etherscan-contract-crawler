{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Presale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\ncontract TokenPreSale is Ownable, ReentrancyGuard {\\n    struct Presale {\\n        uint256 price;\\n        uint256 tokensToSell;\\n        uint256 inSale;\\n    }\\n\\n    struct userTokens {\\n        uint256 totalQuantity;\\n        uint256 ethAmountSent;\\n        uint256 usdcAmountSent;\\n        uint256 usdtAmountSent;\\n        uint256 claimedQuantity;\\n    }\\n\\n    struct PresaleStatus {\\n        bool completed;\\n        bool isSuccess;\\n    }\\n\\n    struct funds {\\n        uint256 ethAmountReceived;\\n        uint256 usdcAmountReceived;\\n        uint256 usdtAmountReceived;\\n    }\\n\\n    IERC20 public token;\\n    IERC20 public constant usdc =\\n        IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\\n    IERC20 public constant usdt =\\n        IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\\n\\n    AggregatorV3Interface public constant priceFeedUsdcUsd =\\n        AggregatorV3Interface(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\\n    AggregatorV3Interface public constant priceFeedUsdtUsd =\\n        AggregatorV3Interface(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\\n    AggregatorV3Interface public constant priceFeedEthUsd =\\n        AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\\n\\n    bool public paused;\\n    Presale public presale;\\n    PresaleStatus public presaleStatus;\\n    uint256 public tokensReservedForUsers;\\n    mapping(address => userTokens) public user;\\n    funds private fundsReceived;\\n\\n    event PresaleCreated(uint256 _startTime);\\n\\n    event PresaleUpdated(\\n        bytes32 indexed key,\\n        uint256 prevValue,\\n        uint256 newValue,\\n        uint256 timestamp\\n    );\\n\\n    event TokensBought(\\n        address indexed user,\\n        uint256 tokensBought,\\n        uint256 amountPaid,\\n        uint256 timestamp\\n    );\\n\\n    event TokensClaimed(\\n        address indexed user,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    event PresalePaused(uint256 timestamp);\\n    event PresaleUnpaused(uint256 timestamp);\\n\\n    bytes32 private constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n    mapping(bytes32 => mapping(address => bool)) public roles;\\n\\n    constructor() Ownable() {\\n        grantAdminRole(msg.sender);\\n    }\\n\\n    function setToken(address _token) external onlyOwner {\\n        token = IERC20(_token);\\n    }\\n\\n    function grantAdminRole(address _admin) public onlyOwner {\\n        require(!roles[ADMIN_ROLE][_admin], \\\"Already owner\\\");\\n        roles[ADMIN_ROLE][_admin] = true;\\n    }\\n\\n    function revokeAdminRole(address _admin) external onlyOwner {\\n        require(roles[ADMIN_ROLE][_admin], \\\"Not an owner\\\");\\n        roles[ADMIN_ROLE][_admin] = false;\\n    }\\n\\n    function hasAdminRole(address _admin) external view returns (bool) {\\n        return roles[ADMIN_ROLE][_admin];\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(\\n            roles[ADMIN_ROLE][msg.sender],\\n            \\\"Access Denied, only admins allowed\\\"\\n        );\\n        _;\\n    }\\n\\n    function checkSaleState(uint256 amount) private view {\\n        require(amount > 0 && amount <= presale.inSale, \\\"Invalid sale amount\\\");\\n    }\\n\\n    function pausePresale() external onlyAdmin {\\n        require(!paused, \\\"Already paused\\\");\\n        paused = true;\\n        emit PresalePaused(block.timestamp);\\n    }\\n\\n    function unPausePresale() external onlyAdmin {\\n        require(paused, \\\"Not paused\\\");\\n        paused = false;\\n        emit PresaleUnpaused(block.timestamp);\\n    }\\n\\n    function fundsReceive() external view onlyAdmin returns (funds memory) {\\n        return fundsReceived;\\n    }\\n\\n    // input tokens in wei\\n    function createPresale(\\n        uint256 _price,\\n        uint256 _tokenAmountToSell\\n    ) external onlyAdmin {\\n        require(_price > 0, \\\"Price should be greater than zero\\\");\\n        require(\\n            _tokenAmountToSell > 0,\\n            \\\"Tokens to sell should be greater than zero\\\"\\n        );\\n\\n        presale = Presale({\\n            price: _price,\\n            tokensToSell: _tokenAmountToSell,\\n            inSale: _tokenAmountToSell\\n        });\\n\\n        emit PresaleCreated(block.timestamp);\\n    }\\n\\n    function setGaryPrice(uint256 _newPrice) external onlyAdmin {\\n        require(_newPrice > 0, \\\"Zero price\\\");\\n        require(!paused, \\\"Cann't change when paused\\\");\\n\\n        uint256 prevValue = presale.price;\\n        presale.price = _newPrice;\\n\\n        emit PresaleUpdated(\\n            bytes32(\\\"PRICE\\\"),\\n            prevValue,\\n            _newPrice,\\n            block.timestamp\\n        );\\n    }\\n\\n    // input tokens in wei\\n    function addTokenAmountForSale(\\n        uint256 _tokenAmountToSale\\n    ) external onlyAdmin {\\n        require(!paused, \\\"Cann't change when paused\\\");\\n\\n        uint256 prevValue = presale.tokensToSell;\\n        presale.tokensToSell += _tokenAmountToSale;\\n        presale.inSale += _tokenAmountToSale;\\n        emit PresaleUpdated(\\n            bytes32(\\\"TokenAmount\\\"),\\n            prevValue,\\n            presale.tokensToSell,\\n            block.timestamp\\n        );\\n    }\\n\\n    function getTokenAmountForEth(\\n        uint256 _ethAmount\\n    ) public view returns (uint256 tokenQuantity) {\\n        uint256 tokenQuantityIn1Eth = (((1e18 / presale.price) *\\n            1e18 *\\n            getLatestEthPrice()) / 1e8);\\n        return (tokenQuantityIn1Eth * _ethAmount) / 1e18;\\n    }\\n\\n    function getLatestEthPrice() public view returns (uint256) {\\n        (\\n            uint256 roundID,\\n            int price,\\n            uint256 startedAt,\\n            uint256 timeStamp,\\n            uint80 answeredInRound\\n        ) = priceFeedEthUsd.latestRoundData();\\n\\n        return uint256(price);\\n    }\\n\\n    function buyWithEth() external payable nonReentrant returns (bool) {\\n        require(!paused, \\\"Presale paused\\\");\\n        require(!presaleStatus.completed, \\\"presale is no longer active\\\");\\n\\n        userTokens storage _user = user[msg.sender];\\n        uint256 tokenQuantityToPurchase = getTokenAmountForEth(msg.value);\\n        checkSaleState(tokenQuantityToPurchase);\\n\\n        fundsReceived.ethAmountReceived += msg.value;\\n        presale.inSale -= tokenQuantityToPurchase;\\n        tokensReservedForUsers += tokenQuantityToPurchase;\\n\\n        if (_user.totalQuantity > 0) {\\n            _user.totalQuantity += tokenQuantityToPurchase;\\n            _user.ethAmountSent += msg.value;\\n        } else {\\n            user[msg.sender] = userTokens({\\n                totalQuantity: tokenQuantityToPurchase,\\n                ethAmountSent: msg.value,\\n                usdcAmountSent: 0,\\n                usdtAmountSent: 0,\\n                claimedQuantity: 0\\n            });\\n        }\\n\\n        emit TokensBought(\\n            msg.sender,\\n            tokenQuantityToPurchase,\\n            msg.value,\\n            block.timestamp\\n        );\\n        return true;\\n    }\\n\\n    function getTokenAmountForUsdc(\\n        uint256 usdcToSpent\\n    ) public view returns (uint256 tokenQuantity) {\\n        uint256 tokenQuantityIn1Usdc = (((1e18 / presale.price) *\\n            1e18 *\\n            getLatestUsdcPrice()) / 1e8);\\n        return (usdcToSpent * tokenQuantityIn1Usdc) / 1e6;\\n    }\\n\\n    function getLatestUsdcPrice() public view returns (uint256) {\\n        (\\n            uint256 roundID,\\n            int price,\\n            uint256 startedAt,\\n            uint256 timeStamp,\\n            uint80 answeredInRound\\n        ) = priceFeedUsdcUsd.latestRoundData();\\n\\n        return uint256(price);\\n    }\\n\\n    // input tokens with wei\\n    function buyWithUsdc(\\n        uint256 usdcToSpent\\n    ) external nonReentrant returns (bool) {\\n        require(!paused, \\\"Presale paused\\\");\\n        require(!presaleStatus.completed, \\\"presale is no longer active\\\");\\n\\n        userTokens storage _user = user[msg.sender];\\n        uint256 tokenQuantityToPurchase = getTokenAmountForUsdc(usdcToSpent);\\n        checkSaleState(tokenQuantityToPurchase);\\n        usdc.transferFrom(msg.sender, address(this), usdcToSpent);\\n\\n        fundsReceived.usdcAmountReceived += usdcToSpent;\\n        presale.inSale -= tokenQuantityToPurchase;\\n        tokensReservedForUsers += tokenQuantityToPurchase;\\n\\n        if (_user.totalQuantity > 0) {\\n            _user.totalQuantity += tokenQuantityToPurchase;\\n            _user.usdcAmountSent += usdcToSpent;\\n        } else {\\n            user[msg.sender] = userTokens({\\n                totalQuantity: tokenQuantityToPurchase,\\n                ethAmountSent: 0,\\n                usdcAmountSent: usdcToSpent,\\n                usdtAmountSent: 0,\\n                claimedQuantity: 0\\n            });\\n        }\\n\\n        emit TokensBought(\\n            msg.sender,\\n            tokenQuantityToPurchase * 1e18,\\n            usdcToSpent,\\n            block.timestamp\\n        );\\n        return true;\\n    }\\n\\n    function getTokenAmountForUsdt(\\n        uint256 usdtToSpent\\n    ) public view returns (uint256 tokenQuantity) {\\n        uint256 tokenQuantityIn1USDT = (((1e18 / presale.price) *\\n            1e18 *\\n            getLatestUsdtPrice()) / 1e8);\\n        return (usdtToSpent * tokenQuantityIn1USDT) / 1e6;\\n    }\\n\\n    function getLatestUsdtPrice() public view returns (uint256) {\\n        (\\n            uint256 roundID,\\n            int price,\\n            uint256 startedAt,\\n            uint256 timeStamp,\\n            uint80 answeredInRound\\n        ) = priceFeedUsdtUsd.latestRoundData();\\n\\n        return uint256(price);\\n    }\\n\\n    // input tokens with wei\\n    function buyWithUsdt(\\n        uint256 usdtToSpent\\n    ) external nonReentrant returns (bool) {\\n        require(!paused, \\\"Presale paused\\\");\\n        require(!presaleStatus.completed, \\\"presale is no longer active\\\");\\n\\n        userTokens storage _user = user[msg.sender];\\n        uint256 tokenQuantityToPurchase = getTokenAmountForUsdt(usdtToSpent);\\n        checkSaleState(tokenQuantityToPurchase);\\n        usdt.transferFrom(msg.sender, address(this), usdtToSpent);\\n\\n        fundsReceived.usdtAmountReceived += usdtToSpent;\\n        presale.inSale -= tokenQuantityToPurchase;\\n        tokensReservedForUsers += tokenQuantityToPurchase;\\n\\n        if (_user.totalQuantity > 0) {\\n            _user.totalQuantity += tokenQuantityToPurchase;\\n            _user.usdtAmountSent += usdtToSpent;\\n        } else {\\n            user[msg.sender] = userTokens({\\n                totalQuantity: tokenQuantityToPurchase,\\n                ethAmountSent: 0,\\n                usdcAmountSent: 0,\\n                usdtAmountSent: usdtToSpent,\\n                claimedQuantity: 0\\n            });\\n        }\\n\\n        emit TokensBought(\\n            msg.sender,\\n            tokenQuantityToPurchase * 1e18,\\n            usdtToSpent,\\n            block.timestamp\\n        );\\n        return true;\\n    }\\n\\n    function withdrawFunds() external onlyAdmin nonReentrant {\\n        if (presaleStatus.completed && !presaleStatus.isSuccess) {\\n            uint256 ethAmountReceived = fundsReceived.ethAmountReceived;\\n            uint256 usdcAmountReceived = fundsReceived.usdcAmountReceived;\\n            uint256 usdtAmountReceived = fundsReceived.usdtAmountReceived;\\n\\n            uint256 ethBalance = address(this).balance;\\n            uint256 usdcBalance = usdc.balanceOf(address(this));\\n            uint256 usdtBalance = usdt.balanceOf(address(this));\\n\\n            if (ethBalance > ethAmountReceived) {\\n                payable(msg.sender).transfer(ethBalance - ethAmountReceived);\\n            }\\n\\n            if (usdcBalance > usdcAmountReceived) {\\n                usdc.transfer(msg.sender, usdcBalance - usdcAmountReceived);\\n            }\\n\\n            if (usdtBalance > usdtAmountReceived) {\\n                usdt.transfer(msg.sender, usdtBalance - usdtAmountReceived);\\n            }\\n        } else {\\n            uint256 ethAmount = address(this).balance;\\n            if (ethAmount > 0) {\\n                payable(msg.sender).transfer(ethAmount);\\n            }\\n\\n            uint256 usdcBalance = usdc.balanceOf(address(this));\\n            if (usdcBalance > 0) {\\n                usdc.transfer(msg.sender, usdcBalance);\\n            }\\n\\n            uint256 usdtBalance = usdt.balanceOf(address(this));\\n            if (usdtBalance > 0) {\\n                usdt.transfer(msg.sender, usdtBalance);\\n            }\\n        }\\n    }\\n\\n    function withdrawRemainingTokens() external onlyAdmin {\\n        require(\\n            presaleStatus.completed,\\n            \\\"Cann't withdraw untill presale status is not updated\\\"\\n        );\\n\\n        uint256 remainingTokens = token.balanceOf(address(this)) -\\n            tokensReservedForUsers;\\n\\n        if (remainingTokens > 0) {\\n            token.transfer(msg.sender, remainingTokens);\\n        }\\n    }\\n\\n    function updatePresaleStatus(\\n        bool _success\\n    ) external nonReentrant onlyAdmin {\\n        require(!presaleStatus.completed, \\\"Can only be called once\\\");\\n        presaleStatus.completed = true;\\n        presaleStatus.isSuccess = _success;\\n\\n        if (_success) {\\n            require(\\n                token.balanceOf(address(this)) >= tokensReservedForUsers,\\n                \\\"Cann't change status unless sufficient tokens are sent\\\"\\n            );\\n        } else {\\n            uint256 ethAmountReceived = fundsReceived.ethAmountReceived;\\n            uint256 usdcAmountReceived = fundsReceived.usdcAmountReceived;\\n            uint256 usdtAmountReceived = fundsReceived.usdtAmountReceived;\\n\\n            uint256 ethBalance = address(this).balance;\\n            uint256 usdcBalance = usdc.balanceOf(address(this));\\n            uint256 usdtBalance = usdt.balanceOf(address(this));\\n\\n            bool areFundsSufficient = ethBalance >= ethAmountReceived &&\\n                usdcBalance >= usdcAmountReceived &&\\n                usdtBalance >= usdtAmountReceived;\\n\\n            require(\\n                areFundsSufficient,\\n                \\\"Cann't change status unless funds are sufficient for refund\\\"\\n            );\\n\\n            tokensReservedForUsers = 0;\\n            uint256 remainingTokens = token.balanceOf(address(this));\\n            token.transfer(msg.sender, remainingTokens);\\n        }\\n    }\\n\\n    function claimableAmount(\\n        address _userAddress\\n    ) public view returns (uint256) {\\n        userTokens memory _userTokens = user[_userAddress];\\n\\n        uint claimAmount = _userTokens.totalQuantity -\\n            _userTokens.claimedQuantity;\\n        require(_userTokens.totalQuantity > 0, \\\"Nothing to claim\\\");\\n        require(claimAmount > 0, \\\"Already claimed\\\");\\n\\n        return claimAmount;\\n    }\\n\\n    function claimTokens() public nonReentrant returns (bool) {\\n        require(!paused, \\\"Cann't claim tokens, presale is paused\\\");\\n        require(presaleStatus.completed, \\\"Presale is not marked completed yet\\\");\\n        require(\\n            presaleStatus.isSuccess,\\n            \\\"Cann't claim tokens, presale is failed\\\"\\n        );\\n\\n        userTokens storage _user = user[msg.sender];\\n        uint claimAmount = _user.totalQuantity - _user.claimedQuantity;\\n        tokensReservedForUsers -= claimAmount;\\n        _user.claimedQuantity = claimAmount;\\n\\n        require(claimAmount > 0, \\\"Already Claimed\\\");\\n\\n        token.transfer(msg.sender, claimAmount);\\n        emit TokensClaimed(msg.sender, claimAmount, block.timestamp);\\n        return true;\\n    }\\n\\n    function claimRefund() external nonReentrant {\\n        require(!paused, \\\"Cann't claim Refund, presale is paused\\\");\\n        require(presaleStatus.completed, \\\"Presale is not marked completed yet\\\");\\n        require(\\n            !presaleStatus.isSuccess,\\n            \\\"Cann't claim Refund, presale is successful\\\"\\n        );\\n\\n        userTokens storage _user = user[msg.sender];\\n\\n        if (_user.ethAmountSent > 0) {\\n            uint256 ethAmount = _user.ethAmountSent;\\n            _user.ethAmountSent = 0;\\n            payable(msg.sender).transfer(ethAmount);\\n        }\\n\\n        if (_user.usdcAmountSent > 0) {\\n            uint256 usdcAmount = _user.usdcAmountSent;\\n            _user.usdcAmountSent = 0;\\n            usdc.transfer(msg.sender, usdcAmount);\\n        }\\n\\n        if (_user.usdtAmountSent > 0) {\\n            uint256 usdtAmount = _user.usdtAmountSent;\\n            _user.usdtAmountSent = 0;\\n            usdt.transfer(msg.sender, usdtAmount);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"PresaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PresalePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PresaleUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PresaleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokensBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmountToSale\",\"type\":\"uint256\"}],\"name\":\"addTokenAmountForSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyWithEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdcToSpent\",\"type\":\"uint256\"}],\"name\":\"buyWithUsdc\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtToSpent\",\"type\":\"uint256\"}],\"name\":\"buyWithUsdt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"claimableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmountToSell\",\"type\":\"uint256\"}],\"name\":\"createPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundsReceive\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ethAmountReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdcAmountReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdtAmountReceived\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenPreSale.funds\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestEthPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestUsdcPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestUsdtPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethAmount\",\"type\":\"uint256\"}],\"name\":\"getTokenAmountForEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdcToSpent\",\"type\":\"uint256\"}],\"name\":\"getTokenAmountForUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtToSpent\",\"type\":\"uint256\"}],\"name\":\"getTokenAmountForUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"grantAdminRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"hasAdminRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausePresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensToSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inSale\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSuccess\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedEthUsd\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedUsdcUsd\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedUsdtUsd\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"revokeAdminRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"roles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setGaryPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensReservedForUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPausePresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"name\":\"updatePresaleStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdc\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmountSent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdcAmountSent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdtAmountSent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRemainingTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenPreSale", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}