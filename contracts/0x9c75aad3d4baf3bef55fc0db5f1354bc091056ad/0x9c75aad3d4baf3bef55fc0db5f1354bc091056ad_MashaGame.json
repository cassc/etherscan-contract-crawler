{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/helpers/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\nabstract contract Context {\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Context.sol\\\";\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function waiveOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"\r\n    },\r\n    \"contracts/helpers/ShuffleId.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\nerror ShuffleIdMaxAmountMissmatch();\\nerror ShuffleIdMaxAmountExceed();\\n\\n/// @notice Library to get pseudo random number and get shuffled token Ids\\nlibrary ShuffleId {\\n    using ShuffleId for IdMatrix;\\n\\n    struct IdMatrix {\\n        uint256 _count;\\n        /// @dev The maximum count of tokens token tracker will hold.\\n        uint256 _max;\\n        // Used for random index assignment\\n        mapping(uint256 => uint256) _matrix;\\n    }\\n\\n    function count(IdMatrix storage self) internal view returns (uint256) {\\n        return self._count;\\n    }\\n    function max(IdMatrix storage self) internal view returns (uint256) {\\n        return self._max;\\n    }\\n\\n\\n    /// Update the max supply for the collection\\n    /// @param supply the new token supply.\\n    /// @dev create additional token supply for this collection.\\n    function setMax(IdMatrix storage self, uint256 supply) internal {\\n        if (self._count >= supply) revert ShuffleIdMaxAmountMissmatch();\\n        self._max = supply;\\n    }\\n\\n    /// @dev Randomly gets a new token ID and keeps track of the ones that are still available.\\n    /// @return the next token ID\\n    function next(IdMatrix storage self) internal returns (uint256) {\\n        if (self._count >= self._max) revert ShuffleIdMaxAmountExceed();\\n        uint256 maxIndex = self._max - self._count;\\n        uint256 random = diceRoll(maxIndex, self._count);\\n\\n        uint256 value = 0;\\n        if (self._matrix[random] == 0) {\\n            // If this matrix position is empty, set the value to the generated random number.\\n            value = random;\\n        } else {\\n            // Otherwise, use the previously stored number from the matrix.\\n            value = self._matrix[random];\\n        }\\n\\n        // If the last available tokenID is still unused...\\n        if (self._matrix[maxIndex - 1] == 0) {\\n            // ...store that ID in the current matrix position.\\n            self._matrix[random] = maxIndex - 1;\\n        } else {\\n            // ...otherwise copy over the stored number to the current matrix position.\\n            self._matrix[random] = self._matrix[maxIndex - 1];\\n        }\\n        self._count++;\\n        return value;\\n    }\\n\\n    /// @dev Generate almost random number in range\\n    /// @return rundom number\\n    function diceRoll(uint256 range, uint256 seed) internal view returns (uint256) {\\n        return\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        msg.sender,\\n                        gasleft(),\\n                        seed,\\n                        // block.basefee,\\n                        block.coinbase,\\n                        block.difficulty,\\n                        block.gaslimit,\\n                        block.timestamp\\n                    )\\n                )\\n            ) % range;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\ninterface IERC20 {\\n\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/MashaGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.4;\\n\\nimport \\\"./helpers/Ownable.sol\\\";\\nimport \\\"./helpers/ShuffleId.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\n\\ncontract MashaGame is Ownable{\\n\\n    event GameFinish(address indexed _user, uint256 winAmount, uint256 number, uint256 bidResult);\\n\\n    struct GameItem {\\n        address user;\\n        uint256 amount;\\n        uint256 targetNumber;\\n        uint256 realNumber;\\n        uint256 winAMount;\\n    }\\n\\n    IERC20 public token;\\n\\n    struct PrizeRule {\\n        uint256 min;\\n        uint256 max;\\n        uint256 multiply;\\n    }\\n\\n    PrizeRule[11] public rules;\\n\\n    GameItem[] private games;\\n\\n    uint256 private totalBids;\\n    address public deadAddress = 0x000000000000000000000000000000000000dEaD;\\n\\n    constructor (address _token) {\\n        token = IERC20(_token);\\n\\n        rules[0] = PrizeRule(0, 350, 0);\\n        rules[1] = PrizeRule(351, 480, 105);\\n        rules[2] = PrizeRule(481, 580, 110);\\n        rules[3] = PrizeRule(581, 650, 115);\\n        rules[4] = PrizeRule(651, 730, 120);\\n        rules[5] = PrizeRule(731, 800, 131);\\n        rules[6] = PrizeRule(801, 860, 140);\\n        rules[7] = PrizeRule(861, 910, 165);\\n        rules[8] = PrizeRule(911, 950, 170);\\n        rules[9] = PrizeRule(951, 980, 180);\\n        rules[10] = PrizeRule(981, 999, 200);\\n    }\\n\\n    function getTotalGames() external view returns(uint256)\\n    {\\n        return games.length - 1;\\n    }\\n\\n    function getBid(uint256 _number) external view returns(GameItem memory)\\n    {\\n        require(games.length - 1 >= _number, 'Error: out of bounds');\\n        return games[_number];\\n    }\\n\\n    function bid(uint256 _amount, uint256 _number) external {\\n        require(token.allowance(msg.sender, address(this)) >= _amount, 'Error: low allowance amount');\\n        require(token.balanceOf(msg.sender) >= _amount, 'Error: low balance');\\n        require(_number <= 10, 'Error: number to large');\\n\\n        uint256 gameResult = _getPercent();\\n\\n        if (gameResult < _number) {\\n            token.transferFrom(msg.sender, address(this), _amount);\\n            games.push(GameItem(msg.sender, _amount, _number, gameResult, 0));\\n\\n            emit GameFinish(msg.sender, 0, _number, gameResult);\\n            return;\\n        }\\n\\n        uint256 winAmount = _amount * rules[_number].multiply / 100;\\n        uint256 transferAmount = 0;\\n        games.push(GameItem(msg.sender, _amount, _number, gameResult, winAmount));\\n\\n        if (winAmount > _amount) {\\n            transferAmount = winAmount - _amount;\\n            uint256 feeAmount = transferAmount * 5 / 100;\\n\\n            token.transfer(deadAddress, feeAmount);\\n            token.transfer(owner(), feeAmount);\\n\\n            token.transfer(msg.sender, transferAmount - (2 * feeAmount));\\n        } else if (_amount > winAmount) {\\n            transferAmount = _amount - winAmount;\\n            token.transferFrom(msg.sender, address(this), transferAmount);\\n        }\\n\\n        emit GameFinish(msg.sender, winAmount, _number, gameResult);\\n    }\\n\\n    function _getPercent() internal returns(uint256)\\n    {\\n        totalBids++;\\n        uint256 random = uint256(ShuffleId.diceRoll(1000, totalBids));\\n\\n        for (uint256 i = 0; i < rules.length; i ++) {\\n            if (random >= rules[i].min && random <= rules[i].max) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    function updateRule(uint256 _number, uint256 _min, uint256 _max, uint256 _multiply) external onlyOwner\\n    {\\n        require(_number <= 10, 'Error: rule number must be less or equal 10');\\n        rules[_number].min = _min;\\n        rules[_number].max = _max;\\n        rules[_number].multiply = _multiply;\\n    }\\n\\n    function emergencyWithdraw(address _token, uint256 _amount) external onlyOwner\\n    {\\n        IERC20 withdrawToken = IERC20(_token);\\n        withdrawToken.transfer(owner(), _amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidResult\",\"type\":\"uint256\"}],\"name\":\"GameFinish\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getBid\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"realNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winAMount\",\"type\":\"uint256\"}],\"internalType\":\"struct MashaGame.GameItem\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalGames\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rules\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_multiply\",\"type\":\"uint256\"}],\"name\":\"updateRule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"waiveOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MashaGame", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d4885ab4b30004ccf18b14c4f9caba7f12f4bd94", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}