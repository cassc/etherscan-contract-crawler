{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title The interface for the Uniswap V3 Factory\\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\\ninterface IUniswapV3Factory {\\n    /// @notice Emitted when the owner of the factory is changed\\n    /// @param oldOwner The owner before the owner was changed\\n    /// @param newOwner The owner after the owner was changed\\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a pool is created\\n    /// @param token0 The first token of the pool by address sort order\\n    /// @param token1 The second token of the pool by address sort order\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\\n    /// @param pool The address of the created pool\\n    event PoolCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        uint24 indexed fee,\\n        int24 tickSpacing,\\n        address pool\\n    );\\n\\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\\n    /// @param fee The enabled fee, denominated in hundredths of a bip\\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\\n\\n    /// @notice Returns the current owner of the factory\\n    /// @dev Can be changed by the current owner via setOwner\\n    /// @return The address of the factory owner\\n    function owner() external view returns (address);\\n\\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\\n    /// @return The tick spacing\\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\\n\\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\\n    /// @return pool The pool address\\n    function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n\\n    /// @notice Creates a pool for the given two tokens and fee\\n    /// @param tokenA One of the two tokens in the desired pool\\n    /// @param tokenB The other of the two tokens in the desired pool\\n    /// @param fee The desired fee for the pool\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n    /// are invalid.\\n    /// @return pool The address of the newly created pool\\n    function createPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external returns (address pool);\\n\\n    /// @notice Updates the owner of the factory\\n    /// @dev Must be called by the current owner\\n    /// @param _owner The new owner of the factory\\n    function setOwner(address _owner) external;\\n\\n    /// @notice Enables a fee amount with the given tickSpacing\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\\n}\\n\"\r\n    },\r\n    \"contracts/InitialFairOffering.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"./interfaces/IInscription.sol\\\";\\nimport \\\"./interfaces/IInscriptionFactory.sol\\\";\\nimport \\\"./interfaces/INonfungiblePositionManager.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./libs/TransferHelper.sol\\\";\\nimport \\\"./libs/PriceFormat.sol\\\";\\nimport \\\"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\\\";\\nimport \\\"./interfaces/ICustomizedVesting.sol\\\";\\n\\n// This contract will be created while deploying\\n// The liquidity can not be removed\\ncontract InitialFairOffering {\\n    int24 private constant MIN_TICK = -887272; // add liquidity with full range\\n    int24 private constant MAX_TICK = -MIN_TICK; // add liquidity with full range\\n    int24 public constant TICK_SPACING = 60; // Tick space is 60\\n    uint24 public constant UNISWAP_FEE = 3000;\\n\\n    INonfungiblePositionManager public constant nonfungiblePositionManager =\\n        INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\\n\\n    IUniswapV3Factory public uniswapV3Factory =\\n        IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\\n\\n    IWETH public weth;\\n\\n    IInscriptionFactory public inscriptionFactory;\\n\\n    bool public liquidityAdded = false;\\n\\n    struct MintData {\\n        uint128 ethAmount; // eth payed by user(deduce commission)\\n        uint128 tokenAmount; // token minted by user\\n        uint128 tokenLiquidity; // token liquidity saved in this contract\\n    }\\n\\n    mapping(address => MintData) public mintData;\\n\\n    struct Deposit {\\n        address owner;\\n        uint128 liquidity;\\n        address token0;\\n        address token1;\\n    }\\n    mapping(uint => Deposit) public deposits; // uint - tokenId of liquidity NFT\\n    mapping(uint => uint) public tokenIds;\\n    uint public tokenIdCount;\\n    uint public totalBackToDeployAmount;\\n    uint public totalRefundedAmount;\\n\\n    struct Position {\\n        uint96 nonce;\\n        address operator;\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint128 liquidity;\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n        uint128 tokensOwed0;\\n        uint128 tokensOwed1;\\n        uint256 tokenId;\\n    }\\n\\n    struct Pool {\\n        address pool;\\n        address token0;\\n        address token1;\\n        uint uintRate;\\n        uint160 sqrtPriceX96;\\n    }\\n    Pool public poolData;\\n\\n    IInscriptionFactory.Token public token;\\n\\n    event MintDeposit(\\n        address token,\\n        uint128 ethAmount,\\n        uint128 tokenAmount,\\n        uint128 tokenLiquidity\\n    );\\n    event Refund(\\n        address sender,\\n        uint128 etherAmount,\\n        uint128 senderToken,\\n        uint128 liquidityToken,\\n        uint16 refundFee\\n    );\\n\\n    // This contract can be only created by InscriptionFactory contract\\n    constructor(address _inscriptionFactory, address _weth) {\\n        inscriptionFactory = IInscriptionFactory(_inscriptionFactory);\\n        weth = IWETH(_weth);\\n    }\\n\\n    receive() external payable {\\n        // Change all received ETH to WETH\\n        if (msg.sender != address(weth))\\n            TransferHelper.safeTransferETH(address(weth), msg.value);\\n    }\\n\\n    function initialize(IInscriptionFactory.Token memory _token) public {\\n        // Check if the deployer has sent the liquidity ferc20 tokens\\n        require(\\n            address(inscriptionFactory) == msg.sender,\\n            \\\"Only inscription factory allowed\\\"\\n        );\\n        require(_token.inscriptionId > 0, \\\"token data wrong\\\");\\n        token = _token;\\n        _initializePool(address(weth), _token.addr);\\n    }\\n\\n    function _initializePool(\\n        address _weth,\\n        address _token\\n    )\\n        private\\n        returns (\\n            address _token0,\\n            address _token1,\\n            uint _uintRate,\\n            uint160 _sqrtPriceX96,\\n            address _pool\\n        )\\n    {\\n        _token0 = _token;\\n        _token1 = _weth;\\n\\n        _uintRate = PriceFormat.getInitialRate(\\n            token.crowdFundingRate,\\n            token.liquidityEtherPercent,\\n            token.liquidityTokenPercent,\\n            token.limitPerMint\\n        ); // weth quantity per token\\n        require(_uintRate > 0, \\\"uint rate zero\\\");\\n\\n        if (_token < _weth) {\\n            _sqrtPriceX96 = PriceFormat.priceToSqrtPriceX96(\\n                int(_uintRate),\\n                TICK_SPACING\\n            );\\n        } else {\\n            _token0 = _weth;\\n            _token1 = _token;\\n            _uintRate = 10 ** 36 / _uintRate; // token quantity per weth\\n            _sqrtPriceX96 = PriceFormat.priceToSqrtPriceX96(\\n                int(_uintRate),\\n                TICK_SPACING\\n            );\\n        }\\n        _pool = nonfungiblePositionManager.createAndInitializePoolIfNecessary(\\n            _token0,\\n            _token1,\\n            UNISWAP_FEE,\\n            _sqrtPriceX96\\n        );\\n        poolData = Pool(_pool, _token0, _token1, _uintRate, _sqrtPriceX96);\\n    }\\n\\n    function addLiquidity(uint16 slippage) public {\\n        require(slippage >= 0 && slippage <= 10000, \\\"slippage error\\\");\\n        require(\\n            IInscription(token.addr).totalRollups() >= token.maxRollups,\\n            \\\"mint not finished\\\"\\n        );\\n        require(\\n            uniswapV3Factory.getPool(address(weth), token.addr, UNISWAP_FEE) >\\n                address(0x0),\\n            \\\"Pool not exist, create pool in uniswapV3 manually\\\"\\n        );\\n        require(token.liquidityEtherPercent > 0, \\\"no liquidity add\\\");\\n        uint256 totalTokenLiquidity = IInscription(token.addr).balanceOf(\\n            address(this)\\n        );\\n        require(totalTokenLiquidity > 0, \\\"no token in fto contract\\\");\\n        uint256 balanceOfWeth = IWETH(weth).balanceOf(address(this));\\n        require(balanceOfWeth > 0, \\\"no eth in fto contract\\\");\\n\\n        // Send ether back to deployer, the eth liquidity is based on the balance of this contract. So, anyone can send eth to this contract\\n        uint256 backToDeployAmount = (balanceOfWeth *\\n            (10000 - token.liquidityEtherPercent)) / 10000;\\n        uint256 maxBackToDeployAmount = (token.maxRollups *\\n            (10000 - inscriptionFactory.fundingCommission()) *\\n            token.crowdFundingRate *\\n            (10000 - token.liquidityEtherPercent)) / 100000000;\\n\\n        uint256 sum = totalBackToDeployAmount + backToDeployAmount;\\n\\n        if (sum <= maxBackToDeployAmount) {\\n            weth.withdraw(backToDeployAmount); // Change WETH to ETH\\n            TransferHelper.safeTransferETH(token.deployer, backToDeployAmount);\\n            totalBackToDeployAmount += backToDeployAmount;\\n        } else {\\n            backToDeployAmount = 0;\\n        }\\n\\n        liquidityAdded = true; // allow the transferring of token\\n\\n        _mintNewPosition(\\n            balanceOfWeth - backToDeployAmount,\\n            totalTokenLiquidity, // ferc20 token amount\\n            MIN_TICK,\\n            MAX_TICK,\\n            slippage\\n        );\\n    }\\n\\n    function refund() public {\\n        require(mintData[msg.sender].ethAmount > 0, \\\"you have not mint\\\");\\n        require(\\n            IInscription(token.addr).totalRollups() < token.maxRollups,\\n            \\\"mint has finished\\\"\\n        );\\n\\n        if (\\n            token.isVesting &&\\n            token.customizedVestingContractAddress != address(0x0)\\n        ) {\\n            // standard fto mode\\n            ICustomizedVesting(token.customizedVestingContractAddress)\\n                .removeAllocation(msg.sender, mintData[msg.sender].tokenAmount);\\n        } else {\\n            // not fto mode\\n            // check balance and allowance of tokens, if the balance or allowance is smaller than the what he/she get while do mint, the refund fail\\n            require(\\n                IInscription(token.addr).balanceOf(msg.sender) >=\\n                    mintData[msg.sender].tokenAmount,\\n                \\\"Your balance token not enough\\\"\\n            );\\n            require(\\n                IInscription(token.addr).allowance(msg.sender, address(this)) >=\\n                    mintData[msg.sender].tokenAmount,\\n                \\\"Your allowance not enough\\\"\\n            );\\n\\n            // Burn the tokens from msg.sender\\n            IInscription(token.addr).burnFrom(\\n                msg.sender,\\n                mintData[msg.sender].tokenAmount\\n            );\\n        }\\n\\n        // Burn the token liquidity in this contract\\n        uint128 refundToken = (mintData[msg.sender].tokenLiquidity *\\n            token.refundFee) / 10000;\\n        IInscription(token.addr).burn(\\n            address(this),\\n            mintData[msg.sender].tokenLiquidity - refundToken\\n        );\\n\\n        // Refund Ether\\n        uint128 refundEth = (mintData[msg.sender].ethAmount * token.refundFee) /\\n            10000;\\n        weth.withdraw(mintData[msg.sender].ethAmount - refundEth); // Change WETH to ETH\\n        TransferHelper.safeTransferETH(\\n            msg.sender,\\n            mintData[msg.sender].ethAmount - refundEth\\n        ); // Send balance to donator\\n\\n        totalRefundedAmount =\\n            totalRefundedAmount +\\n            mintData[msg.sender].tokenAmount +\\n            mintData[msg.sender].tokenLiquidity -\\n            refundToken;\\n\\n        emit Refund(\\n            msg.sender,\\n            mintData[msg.sender].ethAmount - refundEth,\\n            mintData[msg.sender].tokenAmount,\\n            mintData[msg.sender].tokenLiquidity - refundToken,\\n            token.refundFee\\n        );\\n\\n        mintData[msg.sender].tokenAmount = 0;\\n        mintData[msg.sender].tokenLiquidity = 0;\\n        mintData[msg.sender].ethAmount = 0;\\n    }\\n\\n    function positions(\\n        uint128 pageNo,\\n        uint128 pageSize\\n    ) public view returns (Position[] memory _positions) {\\n        require(pageNo > 0 && pageSize > 0, \\\"pageNo and size can not be zero\\\");\\n        Position[] memory filtered = new Position[](tokenIdCount);\\n        uint128 count = 0;\\n        for (uint128 i = 0; i < tokenIdCount; i++) {\\n            (\\n                uint96 nonce,\\n                address operator,\\n                address token0,\\n                address token1,\\n                uint24 fee,\\n                int24 tickLower,\\n                int24 tickUpper,\\n                uint128 liquidity,\\n                uint256 feeGrowthInside0LastX128,\\n                uint256 feeGrowthInside1LastX128,\\n                uint128 tokensOwed0,\\n                uint128 tokensOwed1\\n            ) = nonfungiblePositionManager.positions(tokenIds[i]);\\n            if (liquidity == 0) continue;\\n            filtered[count] = Position(\\n                nonce,\\n                operator,\\n                token0,\\n                token1,\\n                fee,\\n                tickLower,\\n                tickUpper,\\n                liquidity,\\n                feeGrowthInside0LastX128,\\n                feeGrowthInside1LastX128,\\n                tokensOwed0,\\n                tokensOwed1,\\n                tokenIds[i]\\n            );\\n            count++;\\n        }\\n\\n        uint128 startIndex = (pageNo - 1) * pageSize;\\n        if (startIndex > count) return new Position[](0);\\n\\n        _positions = new Position[](pageSize);\\n        uint128 index;\\n        for (uint128 i = 0; i < filtered.length; i++) {\\n            if (i >= startIndex && i < startIndex + pageSize) {\\n                _positions[index] = filtered[i];\\n                index++;\\n            } else continue;\\n        }\\n    }\\n\\n    // Call from Inscription::mint only\\n    function setMintData(\\n        address _addr,\\n        uint128 _ethAmount,\\n        uint128 _tokenAmount,\\n        uint128 _tokenLiquidity\\n    ) public {\\n        require(msg.sender == token.addr, \\\"Only call from inscription allowed\\\");\\n        require(\\n            _ethAmount > 0 &&\\n                _tokenAmount > 0 &&\\n                _tokenLiquidity > 0 &&\\n                _addr > address(0x0),\\n            \\\"setEtherLiquidity wrong params\\\"\\n        );\\n\\n        mintData[_addr].ethAmount = mintData[_addr].ethAmount + _ethAmount;\\n        mintData[_addr].tokenAmount =\\n            mintData[_addr].tokenAmount +\\n            _tokenAmount;\\n        mintData[_addr].tokenLiquidity =\\n            mintData[_addr].tokenLiquidity +\\n            _tokenLiquidity;\\n\\n        emit MintDeposit(msg.sender, _ethAmount, _tokenAmount, _tokenLiquidity);\\n    }\\n\\n    function collectFee(\\n        uint256 _tokenId\\n    ) public returns (uint256 amount0, uint256 amount1) {\\n        // Collect\\n        INonfungiblePositionManager.CollectParams\\n            memory params = INonfungiblePositionManager.CollectParams({\\n                tokenId: _tokenId,\\n                recipient: address(this),\\n                amount0Max: type(uint128).max,\\n                amount1Max: type(uint128).max\\n            });\\n        (amount0, amount1) = nonfungiblePositionManager.collect(params);\\n    }\\n\\n    function _mintNewPosition(\\n        uint amount0ToAdd,\\n        uint amount1ToAdd,\\n        int24 lowerTick,\\n        int24 upperTick,\\n        uint16 slippage\\n    )\\n        private\\n        returns (uint tokenId, uint128 liquidity, uint amount0, uint amount1)\\n    {\\n        // If weth < ferc20, set token0/amount0 is weth and token1/amount1 is ferc20\\n        // Otherwise, set token0/amount0 is ferc20, and token1/amount1 is weth\\n        address _token0;\\n        address _token1;\\n        uint _amount0;\\n        uint _amount1;\\n        int24 _lowerTick;\\n        int24 _upperTick;\\n        if (address(weth) > token.addr) {\\n            _token0 = token.addr;\\n            _token1 = address(weth);\\n            _amount0 = amount1ToAdd;\\n            _amount1 = amount0ToAdd;\\n            _lowerTick = lowerTick;\\n            _upperTick = upperTick;\\n        } else {\\n            _token0 = address(weth);\\n            _token1 = token.addr;\\n            _amount0 = amount0ToAdd;\\n            _amount1 = amount1ToAdd;\\n            _lowerTick = -upperTick;\\n            _upperTick = -lowerTick;\\n        }\\n\\n        // Approve the position manager\\n        TransferHelper.safeApprove(\\n            _token0,\\n            address(nonfungiblePositionManager),\\n            _amount0\\n        );\\n        TransferHelper.safeApprove(\\n            _token1,\\n            address(nonfungiblePositionManager),\\n            _amount1\\n        );\\n\\n        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager\\n            .MintParams({\\n                token0: _token0,\\n                token1: _token1,\\n                fee: UNISWAP_FEE,\\n                tickLower: (lowerTick / TICK_SPACING) * TICK_SPACING, // full range\\n                tickUpper: (upperTick / TICK_SPACING) * TICK_SPACING,\\n                amount0Desired: _amount0,\\n                amount1Desired: _amount1,\\n                amount0Min: (_amount0 * (10000 - slippage)) / 10000, // slipage\\n                amount1Min: (_amount1 * (10000 - slippage)) / 10000,\\n                recipient: address(this),\\n                deadline: block.timestamp\\n            });\\n\\n        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager\\n            .mint(params);\\n\\n        _createDeposit(msg.sender, tokenId);\\n\\n        if (amount0 < _amount0) {\\n            TransferHelper.safeApprove(\\n                _token0,\\n                address(nonfungiblePositionManager),\\n                0\\n            );\\n        }\\n\\n        if (amount1 < _amount1) {\\n            TransferHelper.safeApprove(\\n                _token1,\\n                address(nonfungiblePositionManager),\\n                0\\n            );\\n        }\\n    }\\n\\n    function _createDeposit(address _operator, uint _tokenId) private {\\n        (\\n            ,\\n            ,\\n            address token0,\\n            address token1,\\n            ,\\n            ,\\n            ,\\n            uint128 liquidity,\\n            ,\\n            ,\\n            ,\\n\\n        ) = nonfungiblePositionManager.positions(_tokenId);\\n\\n        if (deposits[_tokenId].owner == address(0x0)) {\\n            tokenIds[tokenIdCount] = _tokenId;\\n            tokenIdCount++;\\n        }\\n\\n        deposits[_tokenId] = Deposit({\\n            owner: _operator,\\n            liquidity: liquidity,\\n            token0: token0,\\n            token1: token1\\n        });\\n    }\\n\\n    // function onERC721Received(\\n    //     address operator,\\n    //     address from,\\n    //     uint tokenId,\\n    //     bytes calldata\\n    // ) public returns (bytes4) {\\n    //     _createDeposit(operator, tokenId);\\n    //     return IERC721Receiver.onERC721Received.selector;\\n    // }\\n\\n    // Add liquidity with lower/upper tick\\n    // function addLiquidity(\\n    //     uint16 ratio,            // The ratio of balance of eths and tokens will be added to liquidity pool\\n    //     int24 lowerTick,\\n    //     int24 upperTick,\\n    //     uint16 slippage\\n    // ) public {\\n    //     require(ratio > 0 && ratio <= 10000, \\\"ratio error\\\");\\n    //     require(slippage >= 0 && slippage <= 10000, \\\"slippage error\\\");\\n    //     require(IInscription(token.addr).balanceOf(msg.sender) >= token.minBalanceToManagerLiquidity, \\\"Balance not enough to add liquidity\\\");\\n    //     require(IInscription(token.addr).totalRollups() >= token.maxRollups, \\\"mint not finished\\\");\\n    //     require(uniswapV3Factory.getPool(address(weth), token.addr, UNISWAP_FEE) > address(0x0), \\\"Pool not exist, create pool in uniswapV3 manually\\\");\\n    //     require(token.liquidityEtherPercent > 0, \\\"no liquidity add\\\");\\n    //     uint256 totalTokenLiquidity = IInscription(token.addr).balanceOf(address(this));\\n    //     require(totalTokenLiquidity > 0, \\\"no token in fto\\\");\\n    //     uint256 balanceOfWeth = IWETH(weth).balanceOf(address(this));\\n    //     require(balanceOfWeth > 0, \\\"no eth in fto\\\");\\n\\n    //     // Send ether back to deployer, the eth liquidity is based on the balance of this contract. So, anyone can send eth to this contract\\n    //     uint256 backToDeployAmount = balanceOfWeth * (10000 - token.liquidityEtherPercent) * ratio / 100000000;\\n    //     uint256 maxBackToDeployAmount = token.maxRollups * (10000 - inscriptionFactory.fundingCommission()) * token.crowdFundingRate * (10000 - token.liquidityEtherPercent) / 100000000;\\n\\n    //     uint256 sum = totalBackToDeployAmount + backToDeployAmount;\\n\\n    //     if(sum <= maxBackToDeployAmount) {\\n    //         weth.withdraw(backToDeployAmount);  // Change WETH to ETH\\n    //         TransferHelper.safeTransferETH(token.deployer, backToDeployAmount);\\n    //         totalBackToDeployAmount += backToDeployAmount;\\n    //     } else {\\n    //         backToDeployAmount = 0;\\n    //     }\\n\\n    //     _mintNewPosition(\\n    //         balanceOfWeth * ratio / 10000 - backToDeployAmount,\\n    //         totalTokenLiquidity * ratio / 10000,  // ferc20 token amount\\n    //         lowerTick == 0 ? MIN_TICK : lowerTick,\\n    //         upperTick == 0 ? MAX_TICK : upperTick,\\n    //         slippage\\n    //     );\\n    // }\\n\\n    // function decreaseLiquidity(\\n    //     uint tokenId\\n    // ) public returns (uint amount0, uint amount1) {\\n    //     require(IInscription(token.addr).totalRollups() >= token.maxRollups, \\\"mint not finished\\\");\\n    //     require(IInscription(token.addr).balanceOf(msg.sender) >= token.minBalanceToManagerLiquidity, \\\"Balance not enough to decrease liquidity\\\");\\n    //     uint128 decreaseLiquidityAmount = deposits[tokenId].liquidity;\\n\\n    //     INonfungiblePositionManager.DecreaseLiquidityParams memory params = INonfungiblePositionManager.DecreaseLiquidityParams({\\n    //         tokenId: tokenId,\\n    //         liquidity: decreaseLiquidityAmount,\\n    //         amount0Min: 0,\\n    //         amount1Min: 0,\\n    //         deadline: block.timestamp\\n    //     });\\n\\n    //     (amount0, amount1) = nonfungiblePositionManager.decreaseLiquidity(params);\\n\\n    //     // Collect\\n    //     INonfungiblePositionManager.CollectParams memory params2 = INonfungiblePositionManager.CollectParams({\\n    //         tokenId: tokenId,\\n    //         recipient: address(this),\\n    //         amount0Max: type(uint128).max,\\n    //         amount1Max: type(uint128).max\\n    //     });\\n\\n    //     (amount0, amount1) = nonfungiblePositionManager.collect(params2);\\n\\n    //     deposits[tokenId].liquidity = 0;\\n    // }\\n\\n    // function setMinBalanceToManagerLiquidity(uint128 _minBalanceToManagerLiquidity) public {\\n    //     require(msg.sender == token.deployer, \\\"Call must be deployer\\\");\\n    //     token.minBalanceToManagerLiquidity = _minBalanceToManagerLiquidity;\\n    // }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICustomizedCondition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ICustomizedCondition {\\n    function getStatus(address _tokenAddress, address _sender) external view returns(bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICustomizedVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ICustomizedVesting {\\n    function addAllocation(address recipient, uint amount) external;\\n    function removeAllocation(address recipient, uint amount) external;\\n    function claim() external;\\n    function available(address address_) external view returns (uint);\\n    function released(address address_) external view returns (uint);\\n    function outstanding(address address_) external view returns (uint);\\n    function setTokenAddress(address _tokenAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInscription.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./ICustomizedCondition.sol\\\";\\nimport \\\"./ICustomizedVesting.sol\\\";\\n\\ninterface IInscription {\\n    struct FERC20 {\\n        uint128 cap;                                            // Max amount\\n        uint128 limitPerMint;                                   // Limitaion of each mint\\n\\n        address onlyContractAddress;                            // Only addresses that hold these assets can mint\\n        uint32  maxMintSize;                                    // max mint size, that means the max mint quantity is: maxMintSize * limitPerMint\\n        uint64  inscriptionId;                                  // Inscription Id\\n        \\n        uint128 onlyMinQuantity;                                // Only addresses that the quantity of assets hold more than this amount can mint\\n        uint128 crowdFundingRate;                               // rate of crowdfunding\\n\\n        address whitelist;                                      // whitelist contract\\n        uint40  freezeTime;                                     // The frozen time (interval) between two mints is a fixed number of seconds. You can mint, but you will need to pay an additional mint fee, and this fee will be double for each mint.\\n        uint16  fundingCommission;                              // commission rate of fund raising, 1000 means 10%\\n        uint16  liquidityTokenPercent;\\n        bool    isIFOMode;                                      // receiving fee of crowdfunding\\n\\n        address payable inscriptionFactory;                     // Inscription factory contract address\\n        uint128 baseFee;                                        // base fee of the second mint after frozen interval. The first mint after frozen time is free.\\n\\n        address payable ifoContractAddress;                     // Initial fair offering contract\\n        uint96  maxRollups;                                     // Max rollups\\n\\n        ICustomizedCondition customizedConditionContractAddress;// Customized condition for mint\\n        ICustomizedVesting customizedVestingContractAddress;    // Customized vesting contract\\n    }\\n\\n    function mint(address _to) payable external;\\n    function getFerc20Data() external view returns(FERC20 memory);\\n    function balanceOf(address owner) external view returns(uint256);\\n    function totalSupply() external view returns(uint256);\\n    function allowance(address owner, address spender) external view returns(uint256);\\n    function totalRollups() external view returns(uint256);\\n    function burn(address account, uint256 amount) external;\\n    function burnFrom(address account, uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IInscriptionFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IInscriptionFactory {\\n    struct Token {\\n        uint128         cap;                                // Hard cap of token\\n        uint128         limitPerMint;                       // Limitation per mint\\n\\n        address         onlyContractAddress;\\n        uint32          maxMintSize;                        // max mint size, that means the max mint quantity is: maxMintSize * limitPerMint\\n        uint64          inscriptionId;                      // Inscription id\\n\\n        uint128         onlyMinQuantity;\\n        uint128         crowdFundingRate;\\n\\t\\t\\t\\t\\n        address         addr;                               // Contract address of inscribed token\\n        uint40          freezeTime;\\n        uint40          timestamp;                          // Inscribe timestamp\\n        uint16          liquidityTokenPercent;              // 10000 is 100%\\n\\n        address         ifoContractAddress;                 // Initial fair offerting contract\\n        uint16          refundFee;                          // To avoid the refund attack, deploy sets this fee rate\\n        uint40          startTime;\\n        uint40          duration;\\n\\n        address         customizedConditionContractAddress; // Customized condition for mint\\n        uint96          maxRollups;                         // max rollups\\n\\n        address         deployer;                           // Deployer\\n        string          tick;                               // same as symbol in ERC20, max 5 chars, 10 bytes(80)\\n        uint16          liquidityEtherPercent;\\n        \\n        string          name;                               // full name of token, max 16 chars, 32 bytes(256)\\n\\n        address         customizedVestingContractAddress;   // Customized contract for token vesting\\n        bool            isIFOMode;                          // is ifo mode\\n        bool            isWhitelist;                        // is whitelst condition\\n        bool            isVesting;\\n        bool            isVoted;\\n        \\n        string          logoUrl;                            // logo url, ifpfs cid, 64 chars, 128 bytes, 4 slots, ex.QmPK1s3pNYLi9ERiq3BDxKa4XosgWwFRQUydHUtz4YgpqB\\n    }\\n\\n    function deploy(\\n        string memory _name,\\n        string memory _tick,\\n        uint256 _cap,\\n        uint256 _limitPerMint,\\n        uint256 _maxMintSize, // The max lots of each mint\\n        uint256 _freezeTime, // Freeze seconds between two mint, during this freezing period, the mint fee will be increased\\n        address _onlyContractAddress, // Only the holder of this asset can mint, optional\\n        uint256 _onlyMinQuantity, // The min quantity of asset for mint, optional\\n        uint256 _crowdFundingRate,\\n        address _crowdFundingAddress\\n    ) external returns (address _inscriptionAddress);\\n\\n    function updateStockTick(string memory _tick, bool _status) external;\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function getIncriptionIdByAddress(address _addr) external view returns(uint256);\\n\\n    function getIncriptionByAddress(address _addr) external view returns(Token memory tokens, uint256 totalSupplies, uint256 totalRollups);\\n\\n    function fundingCommission() external view returns(uint16);\\n\\n    function isExisting(string memory _tick) external view returns(bool);\\n\\n    function isLiquidityAdded(address _addr) external view returns(bool);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/INonfungiblePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface INonfungiblePositionManager {\\n    struct MintParams {\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint amount0Desired;\\n        uint amount1Desired;\\n        uint amount0Min;\\n        uint amount1Min;\\n        address recipient;\\n        uint deadline;\\n    }\\n\\n    function mint(\\n        MintParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint tokenId, uint128 liquidity, uint amount0, uint amount1);\\n\\n    struct IncreaseLiquidityParams {\\n        uint tokenId;\\n        uint amount0Desired;\\n        uint amount1Desired;\\n        uint amount0Min;\\n        uint amount1Min;\\n        uint deadline;\\n    }\\n\\n    function increaseLiquidity(\\n        IncreaseLiquidityParams calldata params\\n    ) external payable returns (uint128 liquidity, uint amount0, uint amount1);\\n\\n    struct DecreaseLiquidityParams {\\n        uint tokenId;\\n        uint128 liquidity;\\n        uint amount0Min;\\n        uint amount1Min;\\n        uint deadline;\\n    }\\n\\n    function decreaseLiquidity(\\n        DecreaseLiquidityParams calldata params\\n    ) external payable returns (uint amount0, uint amount1);\\n\\n    struct CollectParams {\\n        uint tokenId;\\n        address recipient;\\n        uint128 amount0Max;\\n        uint128 amount1Max;\\n    }\\n\\n    function collect(\\n        CollectParams calldata params\\n    ) external payable returns (uint amount0, uint amount1);\\n\\n    function positions(\\n        uint256 tokenId\\n    ) external view returns (\\n        uint96 nonce,\\n        address operator,\\n        address token0,\\n        address token1,\\n        uint24 fee,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 liquidity,\\n        uint256 feeGrowthInside0LastX128,\\n        uint256 feeGrowthInside1LastX128,\\n        uint128 tokensOwed0,\\n        uint128 tokensOwed1\\n    );\\n\\n    function createAndInitializePoolIfNecessary(\\n        address token0,\\n        address token1,\\n        uint24 fee,\\n        uint160 sqrtPriceX96\\n    ) external returns (address pool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n// import \\\"./IERC20.sol\\\";\\n\\ninterface IWETH {\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function balanceOf(address account) external view returns (uint);\\n    function totalSupply() external view returns(uint);\\n    function deposit() external payable;\\n    function withdraw(uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Logarithm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Logarithm {\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) public pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than zero.\\n    ///\\n    /// Caveats:\\n    /// - The results are nor perfectly accurate to the last digit, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as a signed 59.18-decimal fixed-point number.\\n    function log2(int256 x, int256 scale, int256 halfScale) public pure returns (int256 result) {\\n        require(x > 0);\\n        unchecked {\\n            // This works because log2(x) = -log2(1/x).\\n            int256 sign;\\n            if (x >= scale) {\\n                sign = 1;\\n            } else {\\n                sign = -1;\\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\\n                assembly {\\n                    x := div(1000000000000000000000000000000000000, x)\\n                }\\n            }\\n\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = mostSignificantBit(uint256(x / scale));\\n\\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\\n            result = int256(n) * scale;\\n\\n            // This is y = x * 2^(-n).\\n            int256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == scale) {\\n                return result * sign;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (int256 delta = int256(halfScale); delta > 0; delta >>= 1) {\\n                y = (y * y) / scale;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * scale) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n            result *= sign;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/libs/PriceFormat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0 <0.9.0;\\n\\nimport \\\"./TickMath.sol\\\";\\nimport \\\"./Logarithm.sol\\\";\\n\\nlibrary PriceFormat {\\n    function getInitialRate(\\n        uint128 _crowdFundingRate,\\n        uint16  _etherToLiquidityPercent,\\n        uint16  _tokenToLiquidityPercent,\\n        uint128 _limitPerMint\\n    ) internal pure returns(uint) {\\n        // return _crowdFundingRate * _etherToLiquidityPercent * (10000 - _tokenToLiquidityPercent) * 10**14 / _tokenToLiquidityPercent / _limitPerMint;\\n        // To avoid the result is zero, the params must satisfy the following condition:\\n        // _crowdFundingRate * 10**18 > _limitPerMint\\n        uint128 precision = 10**12;\\n        return (_crowdFundingRate / precision) * _etherToLiquidityPercent * (10000 - _tokenToLiquidityPercent) * 10**14 / _tokenToLiquidityPercent / (_limitPerMint / precision);\\n    }\\n\\n    function tickToSqrtPriceX96(int24 _tick) internal pure returns(uint160) {\\n        return TickMath.getSqrtRatioAtTick(_tick);\\n    }\\n\\n    function priceToTick(int256 _price, int24 _tickSpace) internal pure returns(int24) {\\n        // math.log(10**18,2) * 10**18 = 59794705707972520000\\n        // math.log(1.0001,2) * 10**18 = 144262291094538\\n        return round((Logarithm.log2(_price * 1e18, 1e18, 5e17) - 59794705707972520000 ), (int(144262291094538) * _tickSpace)) * _tickSpace;\\n    }\\n\\n    function priceToSqrtPriceX96(int256 _price, int24 _tickSpace) internal pure returns(uint160) {\\n        return tickToSqrtPriceX96(priceToTick(_price, _tickSpace));\\n    }\\n\\n    function round(int256 _a, int256 _b) internal pure returns(int24) {\\n        return int24(10000 * _a / _b % 10000 > 10000 / 2 ? _a / _b + 1 : _a / _b);\\n    }\\n}\"\r\n    },\r\n    \"contracts/libs/TickMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0 <0.9.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        // uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        int256 absTick = tick < 0 ? int256(-int256(tick)) : int256(int256(tick));\\n        require(absTick <= int256(MAX_TICK), 'T');\\n\\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        // second inequality must be < because the price can never reach the price at the max tick\\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb = 0;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n\\n        if (msb >= 128) r = ratio >> (msb - 127);\\n        else r = ratio << (127 - msb);\\n\\n        int256 log_2 = (int256(msb) - 128) << 64;\\n\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(63, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(62, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(61, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(60, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(59, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(58, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(57, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(56, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(55, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(54, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(53, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(52, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(51, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(50, f))\\n        }\\n\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libs/Logarithm.sol\": {\r\n        \"Logarithm\": \"0x16882fd345b2ed4e6578f538d7141af5702e6d4a\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_inscriptionFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"ethAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"tokenAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"tokenLiquidity\",\"type\":\"uint128\"}],\"name\":\"MintDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"etherAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"senderToken\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidityToken\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"refundFee\",\"type\":\"uint16\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TICK_SPACING\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_FEE\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"slippage\",\"type\":\"uint16\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"collectFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"cap\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"limitPerMint\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"onlyContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"maxMintSize\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"inscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"onlyMinQuantity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"crowdFundingRate\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"freezeTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"liquidityTokenPercent\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"ifoContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"refundFee\",\"type\":\"uint16\"},{\"internalType\":\"uint40\",\"name\":\"startTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"customizedConditionContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"maxRollups\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"liquidityEtherPercent\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"customizedVestingContractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isIFOMode\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWhitelist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isVesting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isVoted\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"logoUrl\",\"type\":\"string\"}],\"internalType\":\"struct IInscriptionFactory.Token\",\"name\":\"_token\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inscriptionFactory\",\"outputs\":[{\"internalType\":\"contract IInscriptionFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"ethAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"tokenAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"tokenLiquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonfungiblePositionManager\",\"outputs\":[{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uintRate\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceX96\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"pageNo\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"pageSize\",\"type\":\"uint128\"}],\"name\":\"positions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"nonce\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside0LastX128\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInside1LastX128\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"tokensOwed0\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"tokensOwed1\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct InitialFairOffering.Position[]\",\"name\":\"_positions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_ethAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_tokenAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_tokenLiquidity\",\"type\":\"uint128\"}],\"name\":\"setMintData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"cap\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"limitPerMint\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"onlyContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"maxMintSize\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"inscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"onlyMinQuantity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"crowdFundingRate\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"freezeTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"liquidityTokenPercent\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"ifoContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"refundFee\",\"type\":\"uint16\"},{\"internalType\":\"uint40\",\"name\":\"startTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"customizedConditionContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"maxRollups\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"liquidityEtherPercent\",\"type\":\"uint16\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"customizedVestingContractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isIFOMode\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWhitelist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isVesting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isVoted\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"logoUrl\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenIdCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBackToDeployAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRefundedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV3Factory\",\"outputs\":[{\"internalType\":\"contract IUniswapV3Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InitialFairOffering", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000017fe21fab4784ecae27c7bb43d3d3cf3b73e7aa7000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}