{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface ITokenLockerManagerV1 {\r\n  function tokenLockerCount() external view returns (uint40);\r\n  function lpLockerCount() external view returns (uint40);\r\n  function creationEnabled() external view returns (bool);\r\n  function setCreationEnabled(bool value_) external;\r\n  function createTokenLocker(\r\n    address tokenAddress_,\r\n    uint256 amount_,\r\n    uint40 unlockTime_\r\n  ) external payable;\r\n  function createLpLocker(\r\n    address tokenAddress_,\r\n    uint256 amount_,\r\n    uint40 unlockTime_\r\n  ) external payable;\r\n  function getTokenLockAddress(uint40 id_) external view returns (address);\r\n  function getLpLockAddress(uint40 id_) external view returns (address);\r\n  function getTokenLockData(uint40 id_) external view returns (\r\n    bool isLpToken,\r\n    uint40 id,\r\n    address contractAddress,\r\n    address lockOwner,\r\n    address token,\r\n    address createdBy,\r\n    uint40 createdAt,\r\n    uint40 blockTime,\r\n    uint40 unlockTime,\r\n    uint256 balance,\r\n    uint256 totalSupply\r\n  );\r\n  function getLpLockData(uint40 id_) external view returns (\r\n    bool isLpToken,\r\n    uint40 id,\r\n    address contractAddress,\r\n    address lockOwner,\r\n    address token,\r\n    address createdBy,\r\n    uint40 createdAt,\r\n    uint40 blockTime,\r\n    uint40 unlockTime,\r\n    uint256 balance,\r\n    uint256 totalSupply\r\n  );\r\n  function getLpData(uint40 id_) external view returns (\r\n    bool hasLpData,\r\n    uint40 id,\r\n    address token0,\r\n    address token1,\r\n    uint256 balance0,\r\n    uint256 balance1,\r\n    uint256 price0,\r\n    uint256 price1\r\n  );\r\n  function getTokenLockersForAddress(address address_) external view returns (uint40[] memory);\r\n  function getLpLockersForAddress(address address_) external view returns (uint40[] memory);\r\n  function notifyTokenLockerOwnerChange(uint40 id_, address newOwner_, address previousOwner_, address createdBy_) external;\r\n  function notifyLpLockerOwnerChange(uint40 id_, address newOwner_, address previousOwner_, address createdBy_) external;\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\nabstract contract Ownable is Context {\r\n  constructor(address owner_) {\r\n    _owner_ = owner_;\r\n    emit OwnershipTransferred(address(0), _owner());\r\n  }\r\n\r\n  address private _owner_;\r\n\r\n  event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n  function _owner() internal view returns (address) {\r\n    return _owner_;\r\n  }\r\n\r\n  function owner() external view returns (address) {\r\n    return _owner();\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner() == _msgSender(), \"Only the owner can execute this function\");\r\n    _;\r\n  }\r\n\r\n  function _transferOwnership(address newOwner_) virtual internal onlyOwner {\r\n    // keep track of old owner for event\r\n    address oldOwner = _owner();\r\n\r\n    // set the new owner\r\n    _owner_ = newOwner_;\r\n\r\n    // emit event about ownership change\r\n    emit OwnershipTransferred(oldOwner, _owner());\r\n  }\r\n\r\n  function transferOwnership(address newOwner_) external onlyOwner {\r\n    _transferOwnership(newOwner_);\r\n  }\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  function name() external pure returns (string memory);\r\n  function symbol() external pure returns (string memory);\r\n  function decimals() external pure returns (uint8);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address owner) external view returns (uint);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n  function nonces(address owner) external view returns (uint);\r\n\r\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n  event Mint(address indexed sender, uint amount0, uint amount1);\r\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n  event Swap(\r\n    address indexed sender,\r\n    uint amount0In,\r\n    uint amount1In,\r\n    uint amount0Out,\r\n    uint amount1Out,\r\n    address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n  function factory() external view returns (address);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function price0CumulativeLast() external view returns (uint);\r\n  function price1CumulativeLast() external view returns (uint);\r\n  function kLast() external view returns (uint);\r\n\r\n  function mint(address to) external returns (uint liquidity);\r\n  function burn(address to) external returns (uint amount0, uint amount1);\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n  function skim(address to) external;\r\n  function sync() external;\r\n\r\n  function initialize(address, address) external;\r\n}\r\n\r\ninterface IERC20 {\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Util {\r\n  /**\r\n   * @dev retrieves basic information about a token, including sender balance\r\n   */\r\n  function getTokenData(address address_) external view returns (\r\n    string memory name,\r\n    string memory symbol,\r\n    uint8 decimals,\r\n    uint256 totalSupply,\r\n    uint256 balance\r\n  ){\r\n    IERC20 _token = IERC20(address_);\r\n\r\n    name = _token.name();\r\n    symbol = _token.symbol();\r\n    decimals = _token.decimals();\r\n    totalSupply = _token.totalSupply();\r\n    balance = _token.balanceOf(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev this throws an error on false, instead of returning false,\r\n   * but can still be used the same way on frontend.\r\n   */\r\n  function isLpToken(address address_) external view returns (bool) {\r\n    IUniswapV2Pair pair = IUniswapV2Pair(address_);\r\n\r\n    try pair.token0() returns (address tokenAddress_) {\r\n      // any address returned successfully should be valid?\r\n      // but we might as well check that it's not 0\r\n      return tokenAddress_ != address(0);\r\n    } catch Error(string memory /* reason */) {\r\n      return false;\r\n    } catch (bytes memory /* lowLevelData */) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev this function will revert the transaction if it's called\r\n   * on a token that isn't an LP token. so, it's recommended to be\r\n   * sure that it's being called on an LP token, or expect the error.\r\n   */\r\n  function getLpData(address address_) external view returns (\r\n    address token0,\r\n    address token1,\r\n    uint256 balance0,\r\n    uint256 balance1,\r\n    uint256 price0,\r\n    uint256 price1\r\n  ) {\r\n    IUniswapV2Pair _pair = IUniswapV2Pair(address_);\r\n\r\n    token0 = _pair.token0();\r\n    token1 = _pair.token1();\r\n\r\n    balance0 = IERC20(token0).balanceOf(address(_pair));\r\n    balance1 = IERC20(token1).balanceOf(address(_pair));\r\n\r\n    price0 = _pair.price0CumulativeLast();\r\n    price1 = _pair.price1CumulativeLast();\r\n  }\r\n}\r\n\r\ncontract TokenLockerV1 is Ownable {\r\n  event Extended(uint40 newUnlockTime);\r\n  event Deposited(uint256 amount);\r\n  event Withdrew();\r\n\r\n  constructor(address manager_, uint40 id_, address owner_, address tokenAddress_, uint40 unlockTime_) Ownable(owner_) {\r\n    require(unlockTime_ > 0, \"Unlock time must be in the future\");\r\n\r\n    _manager = ITokenLockerManagerV1(manager_);\r\n    _id = id_;\r\n    _token = IERC20(tokenAddress_);\r\n    _createdBy = owner_;\r\n    _createdAt = uint40(block.timestamp);\r\n    _unlockTime = unlockTime_;\r\n    _isLpToken = Util.isLpToken(tokenAddress_);\r\n  }\r\n\r\n  ITokenLockerManagerV1 private _manager;\r\n  bool private _isLpToken;\r\n  uint40 private _id;\r\n  IERC20 private _token;\r\n  address private _createdBy;\r\n  uint40 private _createdAt;\r\n  uint40 private _unlockTime;\r\n\r\n  bool private _transferLocked;\r\n\r\n  modifier transferLocked() {\r\n    require(!_transferLocked, \"Transfering is locked. Wait for the previous transaction to complete\");\r\n    _transferLocked = true;\r\n    _;\r\n    _transferLocked = false;\r\n  }\r\n\r\n  function _balance() private view returns (uint256) {\r\n    return _token.balanceOf(address(this));\r\n  }\r\n\r\n  function getIsLpToken() external view returns (bool) {\r\n    return _isLpToken;\r\n  }\r\n\r\n  function getLockData() external view returns (\r\n    bool isLpToken,\r\n    uint40 id,\r\n    address contractAddress,\r\n    address lockOwner,\r\n    address token,\r\n    address createdBy,\r\n    uint40 createdAt,\r\n    uint40 blockTime,\r\n    uint40 unlockTime,\r\n    uint256 balance,\r\n    uint256 totalSupply\r\n  ){\r\n    isLpToken = _isLpToken;\r\n    id = _id;\r\n    contractAddress = address(this);\r\n    lockOwner = _owner();\r\n    token = address(_token);\r\n    createdBy = _createdBy;\r\n    createdAt = _createdAt;\r\n    blockTime = uint40(block.timestamp);\r\n    unlockTime = _unlockTime;\r\n    balance = _balance();\r\n    totalSupply = _token.totalSupply();\r\n  }\r\n\r\n  function getLpData() external view returns (\r\n    bool hasLpData,\r\n    uint40 id,\r\n    address token0,\r\n    address token1,\r\n    uint256 balance0,\r\n    uint256 balance1,\r\n    uint256 price0,\r\n    uint256 price1\r\n  ) {\r\n    // always return the id\r\n    id = _id;\r\n\r\n    if (!_isLpToken) {\r\n      // if this isn't an lp token, don't even bother calling getLpData\r\n      hasLpData = false;\r\n    } else {\r\n      // this is an lp token, so let's get some data\r\n      try Util.getLpData(address(_token)) returns (\r\n        address token0_,\r\n        address token1_,\r\n        uint256 balance0_,\r\n        uint256 balance1_,\r\n        uint256 price0_,\r\n        uint256 price1_\r\n      ){\r\n        hasLpData = true;\r\n        token0 = token0_;\r\n        token1 = token1_;\r\n        balance0 = balance0_;\r\n        balance1 = balance1_;\r\n        price0 = price0_;\r\n        price1 = price1_;\r\n      } catch Error(string memory /* reason */) {\r\n        hasLpData = false;\r\n      } catch (bytes memory /* lowLevelData */) {\r\n        hasLpData = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev deposit and extend duration in one call\r\n   */\r\n  function deposit(uint256 amount_, uint40 newUnlockTime_) external onlyOwner transferLocked {\r\n    if (newUnlockTime_ != 0) {\r\n      require(\r\n        newUnlockTime_ >= _unlockTime && newUnlockTime_ >= uint40(block.timestamp),\r\n        \"New unlock time must be a future time beyond the previous value\"\r\n      );\r\n      _unlockTime = newUnlockTime_;\r\n      emit Extended(_unlockTime);\r\n    }\r\n\r\n    if (amount_ != 0) {\r\n      uint256 oldBalance = _balance();\r\n      _token.transferFrom(_msgSender(), address(this), amount_);\r\n      emit Deposited(_balance() - oldBalance);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev withdraw all of the deposited token\r\n   */\r\n  function withdraw() external onlyOwner transferLocked {\r\n    require(uint40(block.timestamp) >= _unlockTime, \"Wait until unlockTime to withdraw \");\r\n\r\n    _token.transfer(_owner(), _balance());\r\n\r\n    emit Withdrew();\r\n  }\r\n\r\n  /**\r\n   * @dev recovery function -\r\n   * just in case this contract winds up with additional tokens (from dividends, etc).\r\n   * attempting to withdraw the locked token will revert.\r\n   */\r\n  function withdrawToken(address address_) external onlyOwner transferLocked {\r\n    require(address_ != address(_token), \"Use 'withdraw' to withdraw the primary locked token\");\r\n\r\n    IERC20 theToken = IERC20(address_);\r\n    theToken.transfer(_owner(), theToken.balanceOf(address(this)));\r\n  }\r\n\r\n  /**\r\n   * @dev recovery function -\r\n   * just in case this contract winds up with eth in it (from dividends etc)\r\n   */\r\n  function withdrawEth() external onlyOwner transferLocked {\r\n    address payable receiver = payable(_owner());\r\n    receiver.transfer(address(this).balance);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner_) override internal onlyOwner {\r\n    address previousOwner = _owner();\r\n    super._transferOwnership(newOwner_);\r\n\r\n    // we need to notify the manager contract that we transferred\r\n    // ownership, so that the new owner is searchable.\r\n    if (_isLpToken)\r\n      _manager.notifyLpLockerOwnerChange(_id, newOwner_, previousOwner, _createdBy);\r\n    else\r\n      _manager.notifyTokenLockerOwnerChange(_id, newOwner_, previousOwner, _createdBy);\r\n  }\r\n\r\n  receive() external payable {\r\n    // we need this function to receive eth,\r\n    // which might happen from dividend tokens.\r\n    // use `withdrawEth` to remove eth from the contract.\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"id_\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"unlockTime_\",\"type\":\"uint40\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"newUnlockTime\",\"type\":\"uint40\"}],\"name\":\"Extended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Withdrew\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"newUnlockTime_\",\"type\":\"uint40\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIsLpToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLockData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isLpToken\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"id\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lockOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"createdBy\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"createdAt\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"blockTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"unlockTime\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLpData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasLpData\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"id\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokenLockerV1", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000057136ec54ddafd1695479cae1140fbc6d5a916d100000000000000000000000000000000000000000000000000000000000000000000000000000000000000008d335dd41c970ed83b1e57b3ba3f583243107793000000000000000000000000626bb5e02694372b5a919a5981659595c2fd37880000000000000000000000000000000000000000000000000000000066cc5237", "EVMVersion": "Default", "Library": "Util:635822169386f76a8368420988b2e417b695a641", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b4db4abab33082aad02dea6b3a2818085caaf9bbd6febac9f3f7c8845a8ab8e6"}