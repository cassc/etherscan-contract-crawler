{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Generate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport {Errors} from \\\"src/libraries/Errors.sol\\\";\\nimport {IVault} from \\\"src/interfaces/IVault.sol\\\";\\nimport {Clones} from \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport {IOperator} from \\\"src/storage/interfaces/IOperator.sol\\\";\\n\\nlibrary Generate {\\n    /// @notice deploys a new clone of `StvAccount`\\n    /// @param capacityOfStv capacity of the stv\\n    /// @param manager address of the manager\\n    /// @param operator address of the operator\\n    /// @param maxFundraisingPeriod max fundraising period for an stv\\n    function generate(uint96 capacityOfStv, address manager, address operator, uint40 maxFundraisingPeriod)\\n        external\\n        returns (IVault.StvInfo memory stv)\\n    {\\n        address stvAccountImplementation = IOperator(operator).getAddress(\\\"STVACCOUNT\\\");\\n        address defaultStableCoin = IOperator(operator).getAddress(\\\"DEFAULTSTABLECOIN\\\");\\n\\n        if (capacityOfStv < 1e6) revert Errors.InputMismatch();\\n\\n        stv.manager = manager;\\n        stv.endTime = uint40(block.timestamp) + maxFundraisingPeriod;\\n        stv.capacityOfStv = capacityOfStv;\\n\\n        bytes32 salt = keccak256(\\n            abi.encodePacked(\\n                manager, defaultStableCoin, capacityOfStv, maxFundraisingPeriod, block.timestamp, block.chainid\\n            )\\n        );\\n        address contractAddress = Clones.cloneDeterministic(stvAccountImplementation, salt);\\n        stv.stvId = contractAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nlibrary Errors {\\n    // Zero Errors\\n    error ZeroAmount();\\n    error ZeroAddress();\\n    error ZeroTotalRaised();\\n    error ZeroClaimableAmount();\\n\\n    // Modifier Errors\\n    error NotOwner();\\n    error NotAdmin();\\n    error CallerNotVault();\\n    error CallerNotTrade();\\n    error CallerNotVaultOwner();\\n    error CallerNotGenerate();\\n    error NoAccess();\\n    error NotPlugin();\\n\\n    // State Errors\\n    error BelowMinFundraisingPeriod();\\n    error AboveMaxFundraisingPeriod();\\n    error BelowMinLeverage();\\n    error AboveMaxLeverage();\\n    error BelowMinEndTime();\\n    error TradeTokenNotApplicable();\\n\\n    // STV errors\\n    error StvDoesNotExist();\\n    error AlreadyOpened();\\n    error MoreThanTotalRaised();\\n    error MoreThanTotalReceived();\\n    error StvNotOpen();\\n    error StvNotClose();\\n    error ClaimNotApplicable();\\n    error StvStatusMismatch();\\n\\n    // General Errors\\n    error BalanceLessThanAmount();\\n    error FundraisingPeriodEnded();\\n    error TotalRaisedMoreThanCapacity();\\n    error StillFundraising();\\n    error CommandMisMatch();\\n    error TradeCommandMisMatch();\\n    error NotInitialised();\\n    error Initialised();\\n    error LengthMismatch();\\n    error TransferFailed();\\n    error DelegateCallFailed();\\n    error CallFailed(bytes);\\n    error AccountAlreadyExists();\\n    error SwapFailed();\\n    error ExchangeDataMismatch();\\n    error AccountNotExists();\\n    error InputMismatch();\\n    error AboveMaxDistributeIndex();\\n    error BelowMinStvDepositAmount();\\n\\n    // Protocol specific errors\\n    error GmxFeesMisMatch();\\n    error UpdateOrderRequestMisMatch();\\n    error CancelOrderRequestMisMatch();\\n\\n    // Subscriptions\\n    error NotASubscriber();\\n    error AlreadySubscribed();\\n    error MoreThanLimit();\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\ninterface IVault {\\n    /// @notice Enum to describe the trading status of the vault\\n    /// @dev NOT_OPENED - Not open\\n    /// @dev OPEN - opened position\\n    /// @dev CANCELLED_WITH_ZERO_RAISE - cancelled without any raise\\n    /// @dev CANCELLED_WITH_NO_FILL - cancelled with raise but not opening a position\\n    /// @dev CANCELLED_BY_MANAGER - cancelled by the manager after raising\\n    /// @dev DISTRIBUTED - distributed fees\\n    /// @dev LIQUIDATED - liquidated position\\n    enum StvStatus {\\n        NOT_OPENED,\\n        OPEN,\\n        CANCELLED_WITH_ZERO_RAISE,\\n        CANCELLED_WITH_NO_FILL,\\n        CANCELLED_BY_MANAGER,\\n        DISTRIBUTED,\\n        LIQUIDATED\\n    }\\n\\n    struct StvInfo {\\n        address stvId;\\n        uint40 endTime;\\n        StvStatus status;\\n        address manager;\\n        uint96 capacityOfStv;\\n    }\\n\\n    struct StvBalance {\\n        uint96 totalRaised;\\n        uint96 totalRemainingAfterDistribute;\\n    }\\n\\n    struct InvestorInfo {\\n        uint96 depositAmount;\\n        uint96 claimedAmount;\\n        bool claimed;\\n    }\\n\\n    function getQ() external view returns (address);\\n    function maxFundraisingPeriod() external view returns (uint40);\\n    function distributeOut(address stvId, bool isCancel, uint256 indexFrom, uint256 indexTo) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/storage/interfaces/IOperator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\ninterface IOperator {\\n    function getMaxDistributeIndex() external view returns (uint256);\\n    function getAddress(string calldata adapter) external view returns (address);\\n    function getAddresses(string[] calldata adapters) external view returns (address[] memory);\\n    function getTraderAccount(address trader) external view returns (address);\\n    function getPlugin(address plugin) external view returns (bool);\\n    function getPlugins(address[] calldata plugins) external view returns (bool[] memory);\\n    function setAddress(string calldata adapter, address addr) external;\\n    function setAddresses(string[] calldata adapters, address[] calldata addresses) external;\\n    function setPlugin(address plugin, bool isPlugin) external;\\n    function setPlugins(address[] calldata plugins, bool[] calldata isPlugin) external;\\n    function setTraderAccount(address trader, address account) external;\\n    function getAllSubscribers(address manager) external view returns (address[] memory);\\n    function getIsSubscriber(address manager, address subscriber) external view returns (bool);\\n    function getSubscriptionAmount(address manager, address subscriber) external view returns (uint96);\\n    function getTotalSubscribedAmountPerManager(address manager) external view returns (uint96);\\n    function setSubscribe(address manager, address subscriber, uint96 maxLimit) external;\\n    function setUnsubscribe(address manager, address subscriber) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@synthetix/=src/interfaces/synthetix/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {\r\n      \"src/Generate.sol\": {\r\n        \"Generate\": \"0xaf8feebbe35cd32b777417945c3c44b1b2c4a45d\"\r\n      },\r\n      \"src/SpotTrade/SpotTrade.sol\": {\r\n        \"SpotTrade\": \"0x061bcdd25a7573ee97adf9f325ee75e249aeb9e3\"\r\n      },\r\n      \"src/Trade.sol\": {\r\n        \"Trade\": \"0x05259f2afd2b749a50869c2fb5336747e61fbb30\"\r\n      },\r\n      \"src/libraries/BytesCheck.sol\": {\r\n        \"BytesCheck\": \"0x66cd7e17e140cdeae62924978575d3e49695e5e8\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"InputMismatch\",\"type\":\"error\"}]", "ContractName": "Generate", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}