{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/bonds/VectorBonding.sol\": {\r\n      \"content\": \"import \\\"../libraries/SafeMath.sol\\\";\\nimport \\\"../libraries/FixedPoint.sol\\\";\\nimport \\\"../libraries/Address.sol\\\";\\nimport \\\"../libraries/SafeERC20.sol\\\";\\nimport \\\"../interface/ITreasury.sol\\\";\\n\\ninterface IUniswapV2Router02 {\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function WETH() external pure returns (address);\\n}\\n\\ninterface IvETH {\\n    function deposit(\\n        address _restakedLST,\\n        address _to,\\n        uint256 _amount\\n    ) external;\\n}\\n\\n// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\ncontract VectorBonding {\\n    using FixedPoint for *;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    enum PARAMETER {\\n        VESTING,\\n        PAYOUT,\\n        DEBT\\n    }\\n\\n    enum BondType {\\n        TAKEINPRINCIPAL,\\n        WETHTOVETH,\\n        WETHTOLP\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /// EVENTS ///\\n\\n    event BondCreated(uint256 deposit, uint256 payout, uint256 expires);\\n    event BondRedeemed(address recipient, uint256 payout, uint256 remaining);\\n    event BondPriceChanged(uint256 internalPrice, uint256 debtRatio);\\n    event ControlVariableAdjustment(\\n        uint256 initialBCV,\\n        uint256 newBCV,\\n        uint256 adjustment,\\n        bool addition\\n    );\\n\\n    /// STATE VARIABLES ///\\n\\n    uint256 public constant FEE_DENOM = 1_000_000;\\n\\n    address public owner;\\n\\n    IERC20 public immutable VEC; // token paid for principal\\n    IERC20 public immutable principalToken; // inflow token\\n    ITreasury public immutable treasury; // pays for and receives principal\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\n\\n    address public LP;\\n    address public feeTo;\\n    address public immutable vETH;\\n\\n    // in ten-thousandths of a %. i.e. 5000 = 0.5%\\n    uint256 public feePercent;\\n    uint256 public totalPrincipalBonded;\\n    uint256 public totalPayoutGiven;\\n    uint256 public totalDebt; // total value of outstanding bonds; used for pricing\\n    uint256 public lastDecay; // reference timestamp for debt decay\\n\\n    Terms public terms; // stores terms for new bonds\\n    Adjust public adjustment; // stores adjustment to BCV data\\n\\n    bool public immutable feeInVEC;\\n\\n    BondType public bondType;\\n\\n    mapping(address => Bond) public bondInfo; // stores bond information for depositors\\n\\n    /// STRUCTS ///\\n\\n    // Info for creating new bonds\\n    struct Terms {\\n        uint256 controlVariable; // scaling variable for price\\n        uint256 vestingTerm; // in seconds\\n        uint256 minimumPrice; // vs principal value\\n        uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\n        uint256 maxDebt; // payout token decimal debt ratio, max % total supply created as debt\\n    }\\n\\n    // Info for bond holder\\n    struct Bond {\\n        uint256 payout; // payout token remaining to be paid\\n        uint256 vesting; // seconds left to vest\\n        uint256 lastBlockTimestamp; // Last interaction\\n        uint256 truePricePaid; // Price paid (principal tokens per payout token) in ten-millionths - 4000000 = 0.4\\n    }\\n\\n    // Info for incremental adjustments to control variable\\n    struct Adjust {\\n        bool add; // addition or subtraction\\n        uint256 rate; // increment\\n        uint256 target; // BCV when adjustment finished\\n        uint256 buffer; // minimum length (in seconds) between adjustments\\n        uint256 lastBlockTimestamp; // timestamp when last adjustment made\\n    }\\n\\n    /// CONSTRUCTOR ///\\n\\n    constructor(\\n        address _treasury,\\n        address _vETH,\\n        address _principalToken,\\n        bool _feeInVEC\\n    ) {\\n        treasury = ITreasury(_treasury);\\n        VEC = IERC20(ITreasury(_treasury).VEC());\\n        principalToken = IERC20(_principalToken);\\n        owner = msg.sender;\\n        feeInVEC = _feeInVEC;\\n        vETH = _vETH;\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\n        );\\n\\n        uniswapV2Router = _uniswapV2Router;\\n    }\\n\\n    /// INITIALIZATION ///\\n\\n    /**\\n     *  @notice initializes bond parameters\\n     *  @param _controlVariable uint256\\n     *  @param _vestingTerm uint256\\n     *  @param _minimumPrice uint256\\n     *  @param _maxPayout uint256\\n     *  @param _maxDebt uint256\\n     *  @param _initialDebt uint256\\n     */\\n    function initializeBond(\\n        uint256 _controlVariable,\\n        uint256 _vestingTerm,\\n        uint256 _minimumPrice,\\n        uint256 _maxPayout,\\n        uint256 _maxDebt,\\n        uint256 _initialDebt,\\n        BondType _bondType\\n    ) external onlyOwner {\\n        require(currentDebt() == 0, \\\"Debt must be 0 for initialization\\\");\\n        bondType = _bondType;\\n\\n        if (_bondType == BondType.WETHTOVETH) {\\n            require(address(principalToken) == uniswapV2Router.WETH(), \\\"Principal must be WETH\\\");\\n            principalToken.approve(vETH, type(uint256).max);\\n        } else if (_bondType == BondType.WETHTOLP) {\\n            require(address(principalToken) == uniswapV2Router.WETH(), \\\"Principal must be WETH\\\");\\n            LP = treasury.LP();\\n            principalToken.approve(address(uniswapV2Router), type(uint256).max);\\n            VEC.approve(address(uniswapV2Router), type(uint256).max);\\n        }\\n\\n        terms = Terms({\\n            controlVariable: _controlVariable,\\n            vestingTerm: _vestingTerm,\\n            minimumPrice: _minimumPrice,\\n            maxPayout: _maxPayout,\\n            maxDebt: _maxDebt\\n        });\\n        totalDebt = _initialDebt;\\n        lastDecay = block.timestamp;\\n    }\\n\\n    /// POLICY FUNCTIONS ///\\n\\n    /// @notice Withdraw stuck token from contract\\n    function withdrawStuckToken(\\n        address _token,\\n        address _to,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\n        require(_token != address(VEC), \\\"Can not withdraw VEC\\\");\\n        IERC20(_token).safeTransfer(_to, _amount);\\n    }\\n\\n    function setFeeAndFeeTo(\\n        address _feeTo,\\n        uint256 _feePercent\\n    ) external onlyOwner {\\n        require(_feePercent <= FEE_DENOM, \\\"Fee > FEE_DENOM\\\");\\n        feeTo = _feeTo;\\n        feePercent = _feePercent;\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        owner = newOwner;\\n    }\\n\\n    /**\\n     *  @notice set parameters for new bonds\\n     *  @param _parameter PARAMETER\\n     *  @param _input uint256\\n     */\\n    function setBondTerms(\\n        PARAMETER _parameter,\\n        uint256 _input\\n    ) external onlyOwner {\\n        if (_parameter == PARAMETER.VESTING) {\\n            // 0\\n            require(_input >= 129600, \\\"Vesting must be longer than 36 hours\\\");\\n            terms.vestingTerm = _input;\\n        } else if (_parameter == PARAMETER.PAYOUT) {\\n            // 1\\n            require(_input <= 100000, \\\"Cannot be greater than 100% of supply\\\");\\n            terms.maxPayout = _input;\\n        } else if (_parameter == PARAMETER.DEBT) {\\n            // 2\\n            terms.maxDebt = _input;\\n        }\\n    }\\n\\n    /**\\n     *  @notice set control variable adjustment\\n     *  @param _addition bool\\n     *  @param _increment uint256\\n     *  @param _target uint256\\n     *  @param _buffer uint256\\n     */\\n    function setAdjustment(\\n        bool _addition,\\n        uint256 _increment,\\n        uint256 _target,\\n        uint256 _buffer\\n    ) external onlyOwner {\\n        require(\\n            _increment <= terms.controlVariable.mul(30).div(1000),\\n            \\\"Increment too large\\\"\\n        );\\n\\n        adjustment = Adjust({\\n            add: _addition,\\n            rate: _increment,\\n            target: _target,\\n            buffer: _buffer,\\n            lastBlockTimestamp: block.timestamp\\n        });\\n    }\\n\\n    /// USER FUNCTIONS ///\\n\\n    /**\\n     *  @notice deposit bond\\n     *  @param _amount uint256\\n     *  @param _maxPrice uint256\\n     *  @return uint256\\n     */\\n    function deposit(\\n        uint256 _amount,\\n        uint256 _maxPrice\\n    ) external returns (uint256) {\\n        require(\\n            IERC20(principalToken).balanceOf(msg.sender) >= _amount,\\n            \\\"Balance too low\\\"\\n        );\\n\\n        decayDebt();\\n\\n        uint256 nativePrice = bondPrice();\\n\\n        require(\\n            _maxPrice >= nativePrice,\\n            \\\"Slippage limit: more than max price\\\"\\n        ); // slippage protection\\n\\n        uint256 value;\\n        uint256 payout;\\n        uint256 fee;\\n\\n        (payout, fee, value) = payoutFor(_amount); // payout to bonder is computed\\n\\n        if (!feeInVEC) _amount = _amount.sub(fee);\\n\\n        require(payout >= 10 ** VEC.decimals() / 100, \\\"Bond too small\\\"); // must be > 0.01 payout token ( underflow protection )\\n        require(payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\n\\n        // total debt is increased\\n        totalDebt = totalDebt.add(value);\\n\\n        require(totalDebt <= terms.maxDebt, \\\"Max capacity reached\\\");\\n\\n        // depositor info is stored\\n        bondInfo[msg.sender] = Bond({\\n            payout: bondInfo[msg.sender].payout.add(payout),\\n            vesting: terms.vestingTerm,\\n            lastBlockTimestamp: block.timestamp,\\n            truePricePaid: bondPrice()\\n        });\\n\\n        totalPrincipalBonded = totalPrincipalBonded.add(_amount); // total bonded increased\\n        totalPayoutGiven = totalPayoutGiven.add(payout); // total payout increased\\n\\n        treasury.mint(address(this), payout);\\n\\n        if (bondType == BondType.TAKEINPRINCIPAL) {\\n            principalToken.safeTransferFrom(\\n                msg.sender,\\n                address(treasury),\\n                _amount\\n            );\\n        } else if (bondType == BondType.WETHTOVETH) {\\n            principalToken.safeTransferFrom(msg.sender, address(this), _amount);\\n            IvETH(vETH).deposit(address(principalToken), address(treasury), _amount);\\n        } else {\\n            principalToken.safeTransferFrom(msg.sender, address(this), _amount);\\n\\n            uint256 vecBefore = VEC.balanceOf(address(this));\\n            swapETHForTokens(_amount / 2);\\n            addLiquidity(\\n                VEC.balanceOf(address(this)) - vecBefore,\\n                principalToken.balanceOf(address(this))\\n            );\\n        }\\n\\n        if (fee != 0) {\\n            if (feeInVEC) {\\n                treasury.mint(feeTo, fee);\\n            } else {\\n                principalToken.safeTransferFrom(msg.sender, feeTo, fee);\\n            }\\n        }\\n\\n        // indexed events are emitted\\n        emit BondCreated(\\n            _amount,\\n            payout,\\n            block.timestamp.add(terms.vestingTerm)\\n        );\\n        emit BondPriceChanged(_bondPrice(), debtRatio());\\n\\n        adjust(); // control variable is adjusted\\n        return payout;\\n    }\\n\\n    /**\\n     *  @notice redeem bond for user\\n     *  @param _depositor address\\n     *  @return uint256\\n     */\\n    function redeem(address _depositor) external returns (uint256) {\\n        Bond memory info = bondInfo[_depositor];\\n        uint256 percentVested = percentVestedFor(_depositor); // (seconds since last interaction / vesting term remaining)\\n\\n        if (percentVested >= 10000) {\\n            // if fully vested\\n            delete bondInfo[_depositor]; // delete user info\\n            emit BondRedeemed(_depositor, info.payout, 0); // emit bond data\\n            VEC.safeTransfer(_depositor, info.payout);\\n            return info.payout;\\n        } else {\\n            // if unfinished\\n            // calculate payout vested\\n            uint256 payout = info.payout.mul(percentVested).div(10000);\\n\\n            // store updated deposit info\\n            bondInfo[_depositor] = Bond({\\n                payout: info.payout.sub(payout),\\n                vesting: info.vesting.sub(\\n                    block.timestamp.sub(info.lastBlockTimestamp)\\n                ),\\n                lastBlockTimestamp: block.timestamp,\\n                truePricePaid: info.truePricePaid\\n            });\\n\\n            emit BondRedeemed(_depositor, payout, bondInfo[_depositor].payout);\\n            VEC.safeTransfer(_depositor, payout);\\n            return payout;\\n        }\\n    }\\n\\n    /// INTERNAL HELPER FUNCTIONS ///\\n\\n    /// @dev INTERNAL function to swap `ethAmount` for VEC\\n    function swapETHForTokens(uint256 ethAmount) internal {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = uniswapV2Router.WETH();\\n        path[1] = address(VEC);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            ethAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    /// @dev INTERNAL function to add `tokenAmount` and `ethAmount` to LP\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) internal {\\n        // add the liquidity\\n        uniswapV2Router.addLiquidity(\\n            address(VEC),\\n            address(principalToken),\\n            tokenAmount,\\n            ethAmount,\\n            0,\\n            0,\\n            address(treasury),\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     *  @notice makes incremental adjustment to control variable\\n     */\\n    function adjust() internal {\\n        uint256 timestampCanAdjust = adjustment.lastBlockTimestamp.add(\\n            adjustment.buffer\\n        );\\n        if (adjustment.rate != 0 && block.timestamp >= timestampCanAdjust) {\\n            uint256 initial = terms.controlVariable;\\n            if (adjustment.add) {\\n                terms.controlVariable = terms.controlVariable.add(\\n                    adjustment.rate\\n                );\\n                if (terms.controlVariable >= adjustment.target) {\\n                    adjustment.rate = 0;\\n                }\\n            } else {\\n                terms.controlVariable = terms.controlVariable.sub(\\n                    adjustment.rate\\n                );\\n                if (terms.controlVariable <= adjustment.target) {\\n                    adjustment.rate = 0;\\n                }\\n            }\\n            adjustment.lastBlockTimestamp = block.timestamp;\\n            emit ControlVariableAdjustment(\\n                initial,\\n                terms.controlVariable,\\n                adjustment.rate,\\n                adjustment.add\\n            );\\n        }\\n    }\\n\\n    /**\\n     *  @notice reduce total debt\\n     */\\n    function decayDebt() internal {\\n        totalDebt = totalDebt.sub(debtDecay());\\n        lastDecay = block.timestamp;\\n    }\\n\\n    /**\\n     *  @notice calculate current bond price and remove floor if above\\n     *  @return price_ uint256\\n     */\\n    function _bondPrice() internal returns (uint256 price_) {\\n        price_ = terms.controlVariable.mul(debtRatio()).div(1e2);\\n        if (price_ < terms.minimumPrice) {\\n            price_ = terms.minimumPrice;\\n        } else if (terms.minimumPrice != 0) {\\n            terms.minimumPrice = 0;\\n        }\\n    }\\n\\n    /// VIEW FUNCTIONS ///\\n\\n    /**\\n     *  @notice calculate current bond premium\\n     *  @return price_ uint256\\n     */\\n    function bondPrice() public view returns (uint256 price_) {\\n        price_ = terms.controlVariable.mul(debtRatio()).div(1e2);\\n        if (price_ < terms.minimumPrice) {\\n            price_ = terms.minimumPrice;\\n        }\\n    }\\n\\n    /**\\n     *  @notice determine maximum bond size\\n     *  @return uint256\\n     */\\n    function maxPayout() public view returns (uint256) {\\n        return VEC.totalSupply().mul(terms.maxPayout).div(100000);\\n    }\\n\\n    /**\\n     *  @notice calculate user's interest due for new bond, accounting for Fee\\n     *  @param _amount uint256\\n     *  @return _payout uint256\\n     *  @return _fee uint256\\n     *  @return _value uint256\\n     */\\n    function payoutFor(\\n        uint256 _amount\\n    ) public view returns (uint256 _payout, uint256 _fee, uint256 _value) {\\n        if (!feeInVEC) {\\n            _fee = _amount.mul(feePercent).div(FEE_DENOM);\\n            _value = treasury.valueOfToken(\\n                address(principalToken),\\n                _amount.sub(_fee)\\n            );\\n            _payout = FixedPoint\\n                .fraction(_value, bondPrice())\\n                .decode112with18();\\n        } else {\\n            _value = treasury.valueOfToken(address(principalToken), _amount);\\n            uint256 total = FixedPoint\\n                .fraction(_value, bondPrice())\\n                .decode112with18();\\n            _payout = total;\\n            _fee = total.mul(feePercent).div(FEE_DENOM);\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate current ratio of debt to payout token supply\\n     *  @return debtRatio_ uint256\\n     */\\n    function debtRatio() public view returns (uint256 debtRatio_) {\\n        debtRatio_ = FixedPoint\\n            .fraction(\\n                currentDebt().mul(10 ** VEC.decimals()),\\n                VEC.totalSupply()\\n            )\\n            .decode112with18()\\n            .div(1e9);\\n    }\\n\\n    /**\\n     *  @notice calculate debt factoring in decay\\n     *  @return uint256\\n     */\\n    function currentDebt() public view returns (uint256) {\\n        return totalDebt.sub(debtDecay());\\n    }\\n\\n    /**\\n     *  @notice amount to decay total debt by\\n     *  @return decay_ uint256\\n     */\\n    function debtDecay() public view returns (uint256 decay_) {\\n        uint256 timestampSinceLast = block.timestamp.sub(lastDecay);\\n        decay_ = totalDebt.mul(timestampSinceLast).div(terms.vestingTerm);\\n        if (decay_ > totalDebt) {\\n            decay_ = totalDebt;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate how far into vesting a depositor is\\n     *  @param _depositor address\\n     *  @return percentVested_ uint256\\n     */\\n    function percentVestedFor(\\n        address _depositor\\n    ) public view returns (uint256 percentVested_) {\\n        Bond memory bond = bondInfo[_depositor];\\n        uint256 timestampSinceLast = block.timestamp.sub(\\n            bond.lastBlockTimestamp\\n        );\\n        uint256 vesting = bond.vesting;\\n\\n        if (vesting > 0) {\\n            percentVested_ = timestampSinceLast.mul(10000).div(vesting);\\n        } else {\\n            percentVested_ = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate amount of payout token available for claim by depositor\\n     *  @param _depositor address\\n     *  @return pendingPayout_ uint256\\n     */\\n    function pendingPayoutFor(\\n        address _depositor\\n    ) external view returns (uint256 pendingPayout_) {\\n        uint256 percentVested = percentVestedFor(_depositor);\\n        uint256 payout = bondInfo[_depositor].payout;\\n\\n        if (percentVested >= 10000) {\\n            pendingPayout_ = payout;\\n        } else {\\n            pendingPayout_ = payout.mul(percentVested).div(10000);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IERC20 {\\n\\n  function decimals() external view returns (uint8);\\n  \\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/interface/ITreasury.sol\": {\r\n      \"content\": \"pragma solidity >=0.7.5;\\n\\ninterface ITreasury {\\n    function mint(address _to, uint256 _amount) external;\\n    function valueOfToken( address _token, uint _amount ) external view returns ( uint value_ );\\n    function VEC() external view returns (address);\\n    function vETH() external view returns (address);\\n    function LP() external view returns (address);\\n    function excessReserves() external view returns (uint256);\\n    function RESERVE_BACKING() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.7.5;\\n\\n\\n// TODO(zx): replace with OZ implementation.\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    // function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n    //     require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    //     return _functionCallWithValue(target, data, value, errorMessage);\\n    // }\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n  /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    function addressToString(address _address) internal pure returns(string memory) {\\n        bytes32 _bytes = bytes32(uint256(_address));\\n        bytes memory HEX = \\\"0123456789abcdef\\\";\\n        bytes memory _addr = new bytes(42);\\n\\n        _addr[0] = '0';\\n        _addr[1] = 'x';\\n\\n        for(uint256 i = 0; i < 20; i++) {\\n            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\\n            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\\n        }\\n\\n        return string(_addr);\\n\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.7.5;\\n\\nimport \\\"./FullMath.sol\\\";\\n\\n\\nlibrary Babylonian {\\n\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        if (x == 0) return 0;\\n\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) {\\n            xx >>= 128;\\n            r <<= 64;\\n        }\\n        if (xx >= 0x10000000000000000) {\\n            xx >>= 64;\\n            r <<= 32;\\n        }\\n        if (xx >= 0x100000000) {\\n            xx >>= 32;\\n            r <<= 16;\\n        }\\n        if (xx >= 0x10000) {\\n            xx >>= 16;\\n            r <<= 8;\\n        }\\n        if (xx >= 0x100) {\\n            xx >>= 8;\\n            r <<= 4;\\n        }\\n        if (xx >= 0x10) {\\n            xx >>= 4;\\n            r <<= 2;\\n        }\\n        if (xx >= 0x8) {\\n            r <<= 1;\\n        }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return (r < r1 ? r : r1);\\n    }\\n}\\n\\nlibrary BitMath {\\n\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\\n\\n        if (x >= 0x100000000000000000000000000000000) {\\n            x >>= 128;\\n            r += 128;\\n        }\\n        if (x >= 0x10000000000000000) {\\n            x >>= 64;\\n            r += 64;\\n        }\\n        if (x >= 0x100000000) {\\n            x >>= 32;\\n            r += 32;\\n        }\\n        if (x >= 0x10000) {\\n            x >>= 16;\\n            r += 16;\\n        }\\n        if (x >= 0x100) {\\n            x >>= 8;\\n            r += 8;\\n        }\\n        if (x >= 0x10) {\\n            x >>= 4;\\n            r += 4;\\n        }\\n        if (x >= 0x4) {\\n            x >>= 2;\\n            r += 2;\\n        }\\n        if (x >= 0x2) r += 1;\\n    }\\n}\\n\\n\\nlibrary FixedPoint {\\n\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    struct uq144x112 {\\n        uint256 _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\n\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\\n\\n        return uint(self._x) / 5192296858534827;\\n    }\\n\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\n\\n        if (numerator <= uint144(-1)) {\\n            uint256 result = (numerator << RESOLUTION) / denominator;\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\n            return uq112x112(uint224(result));\\n        } else {\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\n            return uq112x112(uint224(result));\\n        }\\n    }\\n    \\n    // square root of a UQ112x112\\n    // lossy between 0/1 and 40 bits\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        if (self._x <= uint144(-1)) {\\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\\n        }\\n\\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\\n        safeShiftBits -= safeShiftBits % 2;\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.7.5;\\n\\nlibrary FullMath {\\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\\n        uint256 mm = mulmod(x, y, uint256(-1));\\n        l = x * y;\\n        h = mm - l;\\n        if (mm < l) h -= 1;\\n    }\\n\\n    function fullDiv(\\n        uint256 l,\\n        uint256 h,\\n        uint256 d\\n    ) private pure returns (uint256) {\\n        uint256 pow2 = d & -d;\\n        d /= pow2;\\n        l /= pow2;\\n        l += h * ((-pow2) / pow2 + 1);\\n        uint256 r = 1;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        return l * r;\\n    }\\n\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d\\n    ) internal pure returns (uint256) {\\n        (uint256 l, uint256 h) = fullMul(x, y);\\n\\n        uint256 mm = mulmod(x, y, d);\\n        if (mm > l) h -= 1;\\n        l -= mm;\\n\\n        if (h == 0) return l / d;\\n\\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\\n        return fullDiv(l, h, d);\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport {IERC20} from \\\"../interface/IERC20.sol\\\";\\n\\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\n/// Taken from Solmate\\nlibrary SafeERC20 {\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        (bool success, ) = to.call{value: amount}(new bytes(0));\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.7.5;\\n\\n\\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    // Only used in the  BondingCalculator.sol\\n    function sqrrt(uint256 a) internal pure returns (uint c) {\\n        if (a > 3) {\\n            c = a;\\n            uint b = add( div( a, 2), 1 );\\n            while (b < c) {\\n                c = b;\\n                b = div( add( div( a, b ), b), 2 );\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_principalToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_feeInVEC\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"}],\"name\":\"BondCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"internalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtRatio\",\"type\":\"uint256\"}],\"name\":\"BondPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"name\":\"BondRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialBCV\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBCV\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adjustment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"addition\",\"type\":\"bool\"}],\"name\":\"ControlVariableAdjustment\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_DENOM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VEC\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adjustment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlockTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bondInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"truePricePaid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondType\",\"outputs\":[{\"internalType\":\"enum VectorBonding.BondType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtDecay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"decay_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"debtRatio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeInVEC\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_controlVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vestingTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialDebt\",\"type\":\"uint256\"},{\"internalType\":\"enum VectorBonding.BondType\",\"name\":\"_bondType\",\"type\":\"uint8\"}],\"name\":\"initializeBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDecay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"payoutFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"pendingPayoutFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingPayout_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"percentVestedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percentVested_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"principalToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_addition\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_increment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buffer\",\"type\":\"uint256\"}],\"name\":\"setAdjustment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum VectorBonding.PARAMETER\",\"name\":\"_parameter\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"setBondTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feePercent\",\"type\":\"uint256\"}],\"name\":\"setFeeAndFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"terms\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"controlVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayoutGiven\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPrincipalBonded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"contract ITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStuckToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VectorBonding", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000002dd568028682ff2961cc341a4849f1b32f37106400000000000000000000000038d64ce1bdf1a9f24e0ec469c9cade61236fb4a00000000000000000000000006685fcfce05e7502bf9f0aa03b36025b093747260000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}